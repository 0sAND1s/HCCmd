# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM, hence 32768.
  11  0000              	ORG 32768 - (Start - Mover)
  12  7FF1
  13  7FF1              ;Move code to execution address.
  14  7FF1              Mover:
  15  7FF1 21 33 16     	ld		hl, EndCode - Mover - 1
  16  7FF4 09           	add		hl, bc
  17  7FF5 11 24 96     	ld		de, EndCode - 1
  18  7FF8 01 25 16     	ld		bc, EndCode - Start
  19  7FFB ED B8        	lddr
  20  7FFD              	;Clear variables, to not move our binary on IF1 variable insert
  21  7FFD              	;ld		hl, ($5C53)
  22  7FFD              	;ld		hl, Start			;default free space
  23  7FFD              	;ld		($5CB2), hl			;STK free
  24  7FFD C3 00 80     	jp		Start
  25  8000
  26  8000              Start:
  27  8000              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  28  8000 ~            		call InitFonts
  29  8000              	ENDIF
  30  8000 CD 72 87     	call IF1Init
  31  8003
  32  8003              	;install error handler
  33  8003 2A 3D 5C     	ld		hl, (ERRSP)
  34  8006 E5           	push	hl
  35  8007 21 57 80     	ld		hl, ErrorHandler
  36  800A E5           	push	hl
  37  800B ED 73 3D 5C  	ld		(ERRSP), sp
  38  800F
  39  800F              HCRunInitDisk:
  40  800F              	;Clear file cache
  41  800F 21 25 96     	ld		hl, UnallocStart
  42  8012 54           	ld		d, h
  43  8013 5D           	ld		e, l
  44  8014 13           	inc		de
  45  8015 01 05 09     	ld		bc, TrackBuf - UnallocStart
  46  8018 36 00        	ld		(hl), 0
  47  801A ED B0        	ldir
  48  801C              	;Set track buffer to del marker
  49  801C 01 00 10     	ld		bc, SPT*SECT_SZ
  50  801F 36 E5        	ld		(hl), DEL_MARKER
  51  8021 ED B0        	ldir
  52  8023
  53  8023              	;main program
  54  8023 CD 69 89     	call 	ReadCatalogTrack
  55  8026 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  56  8027 28 1C        	jr		z, HCRunMain
  57  8029
  58  8029 6F           	ld		l, a
  59  802A 26 00        	ld		h, 0
  60  802C 11 4E 91     	ld		de, MsgErrCode
  61  802F CD 02 87     	call	Byte2Txt
  62  8032 21 43 91     	ld		hl, MsgErr
  63  8035 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  64  8038 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  65  803A CD C1 8B     	call	PrintStrClr
  66  803D CD 73 8B     	call	ReadChar
  67  8040 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  68  8042 32 19 8A     	ld		(RWTSDrive), a
  69  8045
  70  8045              HCRunMain:
  71  8045 CD 89 80     	call 	InitUI
  72  8048 CD FC 83     	call 	GetFileNames
  73  804B CD 09 81     	call	DisplayDiskInfo
  74  804E C3 63 81     	jp		ReadKeyLoop
  75  8051
  76  8051              HCRunEnd:
  77  8051              	;restore error handler
  78  8051 E1           	pop		hl
  79  8052 E1           	pop		hl
  80  8053 22 3D 5C     	ld		(ERRSP), hl
  81  8056
  82  8056 C9           	ret
  83  8057
  84  8057              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  85  8057
  86  8057              ErrorHandler:
  87  8057 E1           	pop		hl
  88  8058 22 3D 5C     	ld		(ERRSP), hl
  89  805B
  90  805B 3A 3A 5C     	ld		a, (ERRNR)		;make something with the error code, display the error message maybe.
  91  805E 6F           	ld		l, a
  92  805F 26 00        	ld		h, 0
  93  8061 11 4E 91     	ld		de, MsgErrCode
  94  8064 CD 02 87     	call	Byte2Txt
  95  8067 21 43 91     	ld		hl, MsgErr
  96  806A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  97  806D 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  98  806F CD C1 8B     	call	PrintStrClr
  99  8072
 100  8072 3A 3A 5C     	ld		a, (ERRNR)
 101  8075 CD EF 89     	call	GetErrMsg
 102  8078
 103  8078 21 2A AF     	ld		hl, DataBuf
 104  807B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 105  807E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 106  8080 CD C1 8B     	call	PrintStrClr
 107  8083
 108  8083 CD 73 8B     	call	ReadChar
 109  8086 C3 00 80     	jp	Start
 110  8089
 111  8089
 112  8089
 113  8089
 114  8089              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115  8089
 116  8089              InitUI:
 117  8089 AF           	xor		a
 118  808A 32 27 96     	ld		(SelFile), A
 119  808D 32 25 96     	ld		(FileCnt), A
 120  8090 3E 11        	ld		a, LST_FIRST_COL + 1
 121  8092 32 26 96     	ld		(NameCol), A
 122  8095
 123  8095 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 124  8098 ED 4B 1E 8D  	ld		bc, (CurrScrAttrAddr)
 125  809C 09           	add		hl, bc
 126  809D 22 28 96     	ld		(CursorAddr), hl
 127  80A0
 128  80A0 CD 79 8B     	call	ClrScr
 129  80A3
 130  80A3 3E 84        	ld		a, CHR_DC
 131  80A5 CD 3A 8C     	call	DrawVLines
 132  80A8
 133  80A8 3E 28        	ld		a, SCR_LBL_CLR
 134  80AA 11 00 17     	ld		de, 23 << 8
 135  80AD 21 D4 90     	ld		hl, BtnBar
 136  80B0 CD C1 8B     	call	PrintStrClr
 137  80B3
 138  80B3
 139  80B3 21 74 90     	ld		hl, VerMsg1
 140  80B6 11 00 00     	ld		de, LST_FIRST_LINE << 8
 141  80B9 CD 99 8B     	call	PrintStr
 142  80BC 21 84 90     	ld		hl, VerMsg2
 143  80BF 11 00 01     	ld		de, LST_FIRST_LINE + 1 << 8
 144  80C2 CD 99 8B     	call	PrintStr
 145  80C5 21 94 90     	ld		hl, VerMsg3
 146  80C8 11 00 02     	ld		de, LST_FIRST_LINE + 2 << 8
 147  80CB CD 99 8B     	call	PrintStr
 148  80CE
 149  80CE
 150  80CE 3E 28        	ld		a, SCR_LBL_CLR
 151  80D0 21 A4 90     	ld		hl, MsgDskInf
 152  80D3 11 00 03     	ld		de, LST_DISK_INFO << 8
 153  80D6 CD C1 8B     	call	PrintStrClr
 154  80D9
 155  80D9 3E 28        	ld		a, SCR_LBL_CLR
 156  80DB 21 B4 90     	ld		hl, MsgFileInf
 157  80DE 11 00 07     	ld		de, LST_FILE_INFO << 8
 158  80E1 CD C1 8B     	call	PrintStrClr
 159  80E4
 160  80E4 3E 28        	ld		a, SCR_LBL_CLR
 161  80E6 21 C4 90     	ld		hl, MsgMessages
 162  80E9 11 00 0D     	ld		de, LST_LINE_MSG << 8
 163  80EC CD C1 8B     	call	PrintStrClr
 164  80EF
 165  80EF 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 166  80F2 ED 53 B0 5C  	ld		(LineCol), de
 167  80F6 21 2A 96     	ld		hl, AUCnt
 168  80F9 11 00 00     	ld		de, 0
 169  80FC 73 23 72 2B  	ld		(hl), de
 170  8100
 171  8100 3E 28        	ld		a, SCR_SEL_CLR
 172  8102 CD 59 8C     	call	DrawCursor
 173  8105
 174  8105 CD E4 89     	call	SetFastKeys
 175  8108
 176  8108 C9           	ret
 177  8109
 178  8109
 179  8109              DisplayDiskInfo:
 180  8109 3A 19 8A     	ld		a, (RWTSDrive)
 181  810C C6 C1        	add		'A' + $80
 182  810E 32 22 91     	ld		(MsgDriveLet), a
 183  8111 21 13 91     	ld		hl, MsgDrive
 184  8114 11 00 04     	ld		de, LST_DISK_INFO + 1 << 8
 185  8117 CD 99 8B     	call	PrintStr
 186  811A
 187  811A 3A 25 96     	ld		a, (FileCnt)
 188  811D 6F           	ld		l, a
 189  811E 26 00        	ld		h, 0
 190  8120 11 2C 91     	ld		de, MsgFilesCntNo
 191  8123 CD 02 87     	call	Byte2Txt
 192  8126 21 23 91     	ld		hl, MsgFilesCnt
 193  8129 11 00 05     	ld		de, LST_DISK_INFO + 2 << 8
 194  812C CD 99 8B     	call	PrintStr
 195  812F
 196  812F ED 5B 2A 96  	ld		de, (AUCnt)
 197  8133 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 198  8136 B7           	or		a
 199  8137 ED 52        	sbc		hl, de
 200  8139 CB 15        	rl		l								;*2, 2K/AU
 201  813B CB 14        	rl		h
 202  813D 11 3A 91     	ld		de, MsgFreeSpaceNo - 2
 203  8140 CD F7 86     	call	Word2Txt
 204  8143 3E 3A        	ld		a, ':'
 205  8145 32 3B 91     	ld		(MsgFreeSpaceNo -1), a
 206  8148 21 33 91     	ld		hl, MsgFreeSpace
 207  814B 11 00 06     	ld		de, LST_DISK_INFO + 3 << 8
 208  814E CD 99 8B     	call	PrintStr
 209  8151
 210  8151 C9           	ret
 211  8152
 212  8152              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 213  8152
 214  8152              CalcFileCache:
 215  8152 3A 27 96     	ld		a, (SelFile)
 216  8155 11 19 00     	ld		de, CACHE_SZ
 217  8158 CD 5E 87     	call	Mul
 218  815B 01 2E 96     	ld		bc, FileCache
 219  815E 09           	add		hl, bc					;HL = file AU cnt
 220  815F 22 2C 96     	ld		(SelFileCache), hl
 221  8162 C9           	ret
 222  8163
 223  8163              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 224  8163
 225  8163
 226  8163              ReadKeyLoop:
 227  8163 CD 52 81     	call	CalcFileCache
 228  8166 CD 26 85     	call	DisplayFileInfo
 229  8169
 230  8169 CD 73 8B     	call	ReadChar
 231  816C
 232  816C FE 0A        	cp		KEY_DOWN
 233  816E 20 11        	jr		nz, CheckUp
 234  8170
 235  8170 3A 25 96     	ld		a, (FileCnt)
 236  8173 47           	ld		b, a
 237  8174 3A 27 96     	ld		a, (SelFile)
 238  8177 3C           	inc		a
 239  8178 B8           	cp		b
 240  8179 30 E8        	jr		nc, ReadKeyLoop
 241  817B 32 27 96     	ld		(SelFile), a
 242  817E C3 AD 83     	jp		MoveIt
 243  8181
 244  8181              CheckUp:
 245  8181 FE 0B        	cp		KEY_UP
 246  8183 20 0D        	jr		nz, CheckRight
 247  8185
 248  8185 3A 27 96     	ld		a, (SelFile)
 249  8188 B7           	or		a
 250  8189 28 D8        	jr		z, ReadKeyLoop
 251  818B
 252  818B 3D           	dec		a
 253  818C 32 27 96     	ld		(SelFile), a
 254  818F C3 AD 83     	jp		MoveIt
 255  8192
 256  8192              CheckRight:
 257  8192 FE 09        	cp		KEY_RIGHT
 258  8194 20 12        	jr		nz, CheckLeft
 259  8196
 260  8196 3A 25 96     	ld		a, (FileCnt)
 261  8199 47           	ld		b, a
 262  819A 3A 27 96     	ld		a, (SelFile)
 263  819D C6 17        	add		LST_LINES_CNT
 264  819F B8           	cp		b
 265  81A0 30 C1        	jr		nc, ReadKeyLoop
 266  81A2
 267  81A2 32 27 96     	ld		(SelFile), a
 268  81A5 C3 AD 83     	jp		MoveIt
 269  81A8
 270  81A8              CheckLeft:
 271  81A8 FE 08        	cp		KEY_LEFT
 272  81AA 20 0D        	jr		nz, CheckEnter
 273  81AC
 274  81AC 3A 27 96     	ld		a, (SelFile)
 275  81AF D6 17        	sub		LST_LINES_CNT
 276  81B1 38 B0        	jr		c, ReadKeyLoop
 277  81B3
 278  81B3 32 27 96     	ld		(SelFile), a
 279  81B6 C3 AD 83     	jp		MoveIt
 280  81B9
 281  81B9              CheckEnter:
 282  81B9 FE 0D        	cp		KEY_ENTER
 283  81BB C2 C4 81     	jp		nz, CheckKeyInfo
 284  81BE CD 93 84     	call	HandleFile
 285  81C1 C3 45 80     	jp		HCRunMain
 286  81C4
 287  81C4              CheckKeyInfo:
 288  81C4 FE 34        	cp		'4'
 289  81C6 20 20        	jr		nz, CheckKeyCopy
 290  81C8 DD 2A 2C 96  	ld		ix, (SelFileCache)
 291  81CC 21 05 92     	ld		hl, MsgReadingExt
 292  81CF 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 293  81D2 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 294  81D4 CD C1 8B     	call	PrintStrClr
 295  81D7 CD 93 89     	call	ReadFileHeader
 296  81DA 21 13 92     	ld		hl, MsgClear
 297  81DD 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
 298  81E0 3E 0F        	ld		a, SCR_DEF_CLR
 299  81E2 CD C1 8B     	call	PrintStrClr
 300  81E5 C3 63 81     	jp		ReadKeyLoop
 301  81E8
 302  81E8              CheckKeyCopy:
 303  81E8 FE 35        	cp		'5'
 304  81EA 20 39        	jr		nz, CheckKeyFileInfo
 305  81EC
 306  81EC 3A 19 8A     	ld 		a, (RWTSDrive)
 307  81EF 3C           	inc		a
 308  81F0 EE 03        	xor		%11
 309  81F2 C6 40        	add		'A' - 1
 310  81F4 32 69 92     	ld		(MsgCopyFileDrv), a
 311  81F7 21 5E 92     	ld		hl, MsgCopyFile
 312  81FA 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 313  81FD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 314  81FF CD C1 8B     	call	PrintStrClr
 315  8202 2A 2C 96     	ld	hl, (SelFileCache)
 316  8205 CD D2 8A     	call	CopyFile
 317  8208 B7           	or		a
 318  8209 28 17        	jr		z, CopyFileOK
 319  820B
 320  820B 6F           	ld		l, a
 321  820C 26 00        	ld		h, 0
 322  820E 11 4E 91     	ld		de, MsgErrCode
 323  8211 CD 02 87     	call	Byte2Txt
 324  8214 21 43 91     	ld		hl, MsgErr
 325  8217 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 326  821A 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 327  821C CD C1 8B     	call	PrintStrClr
 328  821F CD 73 8B     	call	ReadChar
 329  8222
 330  8222              CopyFileOK:
 331  8222 C3 0F 80     	jp		HCRunInitDisk
 332  8225
 333  8225              CheckKeyFileInfo:
 334  8225 FE 20        	cp		' '
 335  8227 20 06        	jr		nz, CheckKeyDriveA
 336  8229 CD 9B 86     	call	ReadAllHeaders
 337  822C C3 63 81     	jp		ReadKeyLoop
 338  822F
 339  822F              CheckKeyDriveA:
 340  822F FE 31        	cp		'1'
 341  8231 20 05        	jr		nz, CheckKeyDriveB
 342  8233 3E 00        	ld		a, DRIVE_A_CPM
 343  8235 C3 06 83     	jp		SelectDrive
 344  8238
 345  8238              CheckKeyDriveB:
 346  8238 FE 32        	cp		'2'
 347  823A 20 05        	jr		nz, CheckKeyView
 348  823C 3E 01        	ld		a, DRIVE_B_CPM
 349  823E C3 06 83     	jp		SelectDrive
 350  8241
 351  8241              CheckKeyView:
 352  8241 FE 33        	cp		'3'
 353  8243 20 06        	jr		nz, CheckKeyRename
 354  8245 CD 09 85     	call	ViewFile
 355  8248 C3 45 80     	jp		HCRunMain
 356  824B
 357  824B              CheckKeyRename:
 358  824B FE 36        	cp		'6'
 359  824D 20 4B        	jr		nz, CheckKeyDel
 360  824F
 361  824F 21 4E 92     	ld		hl, MsgNewFileName
 362  8252 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 363  8255 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 364  8257 CD C1 8B     	call	PrintStrClr
 365  825A
 366  825A 21 13 92     	ld		hl, MsgClear
 367  825D 11 2A AF     	ld		de, DataBuf
 368  8260 01 0B 00     	ld		bc, NAMELEN
 369  8263 ED B0        	ldir
 370  8265 3E A0        	ld		a, $80 | ' '
 371  8267 12           	ld		(de), a
 372  8268 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 373  826B 21 2A AF     	ld		hl, DataBuf
 374  826E CD 99 8B     	call	PrintStr
 375  8271
 376  8271 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 377  8274 01 0B 00     	ld		bc, NAMELEN
 378  8277 CD DA 8C     	call	ReadString
 379  827A
 380  827A 11 2A AF     	ld		de, DataBuf
 381  827D 1A           	ld		a, (de)
 382  827E FE 20        	cp		' '					;If starting with space, input was canceled.
 383  8280 CA 8C 82     	jp		z, RenameCanceled
 384  8283 2A 2C 96     	ld		hl, (SelFileCache)
 385  8286 CD AF 8A     	call	RenameFile
 386  8289 C3 0F 80     	jp		HCRunInitDisk
 387  828C
 388  828C              RenameCanceled:
 389  828C 21 13 92     	ld		hl, MsgClear
 390  828F 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 391  8292 3E 0F        	ld		a, SCR_DEF_CLR
 392  8294 CD C1 8B     	call	PrintStrClr
 393  8297 C3 63 81     	jp		ReadKeyLoop
 394  829A
 395  829A              CheckKeyDel:
 396  829A FE 38        	cp		'8'
 397  829C 20 2D        	jr		nz, CheckKeyAttrib
 398  829E
 399  829E 21 23 92     	ld		hl, MsgDelete
 400  82A1 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 401  82A4 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 402  82A6 CD C1 8B     	call	PrintStrClr
 403  82A9 CD 73 8B     	call	ReadChar
 404  82AC FE 79        	cp		'y'
 405  82AE 28 0E        	jr		z, DoFileDelete
 406  82B0 21 13 92     	ld		hl, MsgClear
 407  82B3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 408  82B6 3E 0F        	ld		a, SCR_DEF_CLR
 409  82B8 CD C1 8B     	call	PrintStrClr
 410  82BB C3 63 81     	jp		ReadKeyLoop
 411  82BE              DoFileDelete:
 412  82BE 2A 2C 96     	ld		hl, (SelFileCache)
 413  82C1 3A 19 8A     	ld 		a, (RWTSDrive)
 414  82C4 3C           	inc		a					;Convert to BASIC drive number: 1,2
 415  82C5 CD 79 8A     	call	DeleteFile
 416  82C8 C3 0F 80     	jp		HCRunInitDisk
 417  82CB
 418  82CB              CheckKeyAttrib:
 419  82CB FE 37        	cp		'7'
 420  82CD 20 3D        	jr		nz, CheckKeyExtra
 421  82CF
 422  82CF 21 32 92     	ld		hl, MsgSetRO
 423  82D2 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 424  82D5 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 425  82D7 CD C1 8B     	call	PrintStrClr
 426  82DA CD 73 8B     	call	ReadChar
 427  82DD 1E 00        	ld		e, 0
 428  82DF FE 79        	cp		'y'
 429  82E1 20 02        	jr		nz, CheckSYS
 430  82E3 1E 01        	ld		e, 1
 431  82E5
 432  82E5              CheckSYS:
 433  82E5 D5           	push	de
 434  82E6 21 40 92     		ld		hl, MsgSetSYS
 435  82E9 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 436  82EC 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 437  82EE CD C1 8B     		call	PrintStrClr
 438  82F1 CD 73 8B     		call	ReadChar
 439  82F4 FE 79        		cp		'y'
 440  82F6 D1           	pop		de
 441  82F7 20 04        	jr		nz, AttrChange
 442  82F9 3E 02        	ld		a, %10
 443  82FB B3           	or		e
 444  82FC 5F           	ld		e, a
 445  82FD
 446  82FD              AttrChange:
 447  82FD 2A 2C 96     	ld		hl, (SelFileCache)
 448  8300 CD 85 8A     	call	ChangeFileAttrib
 449  8303 C3 0F 80     	jp		HCRunInitDisk
 450  8306
 451  8306              SelectDrive:
 452  8306 32 19 8A     	ld 		(RWTSDrive), a
 453  8309 C3 0F 80     	jp		HCRunInitDisk
 454  830C
 455  830C              CheckKeyExtra:
 456  830C FE 39        	cp		'9'
 457  830E C2 A5 83     	jp		nz, CheckKeyExit
 458  8311 21 6B 92     	ld		hl, MsgMenu0
 459  8314 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 460  8317 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 461  8319 CD C1 8B     	call	PrintStrClr
 462  831C 3A 19 8A     	ld		a, (RWTSDrive)
 463  831F C6 41        	add		'A'
 464  8321 32 86 92     	ld		(MsgMenu1Drv), a
 465  8324 32 AC 92     	ld		(MsgFormatDrv), a
 466  8327 32 94 92     	ld		(MsgMenu2Drv), a
 467  832A
 468  832A              CheckKeyExtraMenu:
 469  832A 21 78 92     	ld		hl, MsgMenu1
 470  832D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 471  8330 CD 99 8B     	call	PrintStr
 472  8333 21 88 92     	ld		hl, MsgMenu2
 473  8336 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 474  8339 CD 99 8B     	call	PrintStr
 475  833C 21 96 92     	ld		hl, MsgMenu3
 476  833F 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 477  8342 CD 99 8B     	call	PrintStr
 478  8345 CD 73 8B     	call	ReadChar
 479  8348 F5           	push	af
 480  8349
 481  8349 21 13 92     		ld		hl, MsgClear
 482  834C 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 483  834F CD 99 8B     		call	PrintStr
 484  8352 21 13 92     		ld		hl, MsgClear
 485  8355 11 00 10     		ld		de, LST_LINE_MSG + 3 << 8
 486  8358 CD 99 8B     		call	PrintStr
 487  835B 21 13 92     		ld		hl, MsgClear
 488  835E 11 00 11     		ld		de, LST_LINE_MSG + 4 << 8
 489  8361 CD 99 8B     		call	PrintStr
 490  8364
 491  8364 F1           	pop		af
 492  8365 FE 33        	cp		'3'
 493  8367 28 39        	jr		z, ExtraMenuExit
 494  8369
 495  8369 FE 31        	cp		'1'
 496  836B 20 2C        	jr		nz, CheckExtra2
 497  836D
 498  836D 21 A1 92     	ld		hl, MsgFormat
 499  8370 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500  8373 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501  8375 CD C1 8B     	call	PrintStrClr
 502  8378
 503  8378 CD 97 87     	call	FormatDisk
 504  837B B7           	or		a
 505  837C CA 0F 80     	jp		z, HCRunInitDisk
 506  837F
 507  837F              	;Display error for format
 508  837F 6F           	ld		l, a
 509  8380 26 00        	ld		h, 0
 510  8382 11 4E 91     	ld		de, MsgErrCode
 511  8385 CD 02 87     	call	Byte2Txt
 512  8388 21 43 91     	ld		hl, MsgErr
 513  838B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 514  838E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 515  8390 CD C1 8B     	call	PrintStrClr
 516  8393 CD 73 8B     	call	ReadChar
 517  8396 C3 0F 80     	jp		HCRunInitDisk
 518  8399
 519  8399              CheckExtra2:
 520  8399 FE 32        	cp		'2'
 521  839B 20 8D        	jr		nz, CheckKeyExtraMenu
 522  839D
 523  839D CD 67 88     	call	CopyDisk
 524  83A0 18 00        	jr		ExtraMenuExit
 525  83A2
 526  83A2              ExtraMenuExit:
 527  83A2 C3 45 80     	jp		HCRunMain
 528  83A5
 529  83A5              CheckKeyExit:
 530  83A5 FE 30        	cp		'0'
 531  83A7 C2 63 81     	jp		nz, ReadKeyLoop
 532  83AA C3 51 80     	jp		HCRunEnd
 533  83AD
 534  83AD              MoveIt:
 535  83AD CD 64 8C     	call 	MoveCursor
 536  83B0 C3 63 81     	jp		ReadKeyLoop
 537  83B3
 538  83B3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 539  83B3
 540  83B3
 541  83B3              DisplayFilename:
 542  83B3 06 0B        	LD		B, NAMELEN
 543  83B5              DispLoop:
 544  83B5 1A           	LD		A, (DE)
 545  83B6
 546  83B6              	;clear bit 7
 547  83B6 CB BF        	RES 	7, A
 548  83B8 32 81 5C     	LD		(CODE), A
 549  83BB
 550  83BB 13           	INC		DE
 551  83BC D5           	PUSH	DE
 552  83BD C5           	PUSH	BC
 553  83BE CD 9C 8C     		CALL	PrintChar
 554  83C1 C1           	POP		BC
 555  83C2 D1           	POP 	DE
 556  83C3
 557  83C3 21 B0 5C     	LD		HL, COL
 558  83C6 34           	INC		(HL)
 559  83C7 10 EC        	DJNZ	DispLoop
 560  83C9              	;now a name is displayed
 561  83C9
 562  83C9              	;check bounds
 563  83C9 3A B1 5C     	LD		A, (LINE)
 564  83CC 3C           	INC		A
 565  83CD FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 566  83CF 38 0A        	JR		C, LineOK
 567  83D1
 568  83D1              	;set names column to the next one
 569  83D1 3A 26 96     	LD		A, (NameCol)
 570  83D4 C6 0C        	ADD		NAMELEN + 1
 571  83D6 32 26 96     	LD		(NameCol), A
 572  83D9
 573  83D9 3E 00        	LD		A, LST_FIRST_LINE
 574  83DB              LineOK:
 575  83DB 32 B1 5C     	LD		(LINE), A
 576  83DE
 577  83DE 3A 26 96     	LD		A, (NameCol)
 578  83E1 32 B0 5C     	LD		(COL), A
 579  83E4
 580  83E4 C9           	RET
 581  83E5
 582  83E5
 583  83E5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 584  83E5
 585  83E5              DisplayFilenames:
 586  83E5 11 2E 96     	ld		de, FileCache
 587  83E8 3A 25 96     	ld		a, (FileCnt)
 588  83EB 47           	ld		b,	a
 589  83EC
 590  83EC              DisplayFilenamesLoop:
 591  83EC C5           	push	bc
 592  83ED D5           		push	de
 593  83EE CD B3 83     			call	DisplayFilename
 594  83F1 D1           		pop		de
 595  83F2 EB           		ex		de, hl
 596  83F3 01 19 00     		ld		bc, CACHE_SZ
 597  83F6 09           		add		hl, bc
 598  83F7 EB           		ex		de, hl
 599  83F8 C1           	pop		bc
 600  83F9 10 F1        	djnz	DisplayFilenamesLoop
 601  83FB
 602  83FB C9           	ret
 603  83FC
 604  83FC
 605  83FC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 606  83FC              ;Selects only valid filenames (not deleted and only from first extension)
 607  83FC              GetFileNames:
 608  83FC DD 21 2A 9F  	ld ix, TrackBuf
 609  8400 11 2E 96     	ld de, FileCache
 610  8403 06 80        	ld b, MAX_EXT_CNT
 611  8405
 612  8405              StoreFilenamesLoop:
 613  8405 AF           	xor a
 614  8406 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 615  8409 C2 85 84     	jp nz, NextExt			;check for deleted
 616  840C
 617  840C              	;count AU
 618  840C D9           	exx
 619  840D E5           	push hl
 620  840E CD C6 87     		call CheckExtAlloc
 621  8411 EB           		ex de, hl			;save first AU no.
 622  8412
 623  8412              		;store disk alocated AU count
 624  8412 2A 2A 96     		ld hl, (AUCnt)
 625  8415 48           		ld c, b
 626  8416 06 00        		ld b, 0
 627  8418 09           		add hl, bc
 628  8419 22 2A 96     		ld (AUCnt), hl
 629  841C E1           	pop hl
 630  841D D9           	exx
 631  841E
 632  841E AF           	xor	a
 633  841F DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 634  8422 20 3A        	jr nz, FindExt
 635  8424
 636  8424 DD E5        	push ix
 637  8426 E1           	pop hl
 638  8427 23           	inc hl					;skip del flag
 639  8428
 640  8428 C5           	push bc
 641  8429 D5           		push de
 642  842A E5           			push hl
 643  842B EB           				ex de, hl
 644  842C CD B3 83     				call DisplayFilename
 645  842F E1           			pop hl
 646  8430 D1           		pop de
 647  8431 01 0B 00     		ld bc, NAMELEN
 648  8434 ED B0        		ldir				;save file name
 649  8436
 650  8436 D9           		exx
 651  8437 D5           		push 	de			;de = first AU
 652  8438 D9           		exx
 653  8439 E1           		pop		hl
 654  843A EB           		ex		de, hl
 655  843B 73 23 72 2B  		ld		(hl), de	;save first AU
 656  843F
 657  843F 23           		inc		hl
 658  8440 23           		inc		hl
 659  8441
 660  8441 D9           		exx					;save AU cnt for file
 661  8442 C5           		push	bc
 662  8443 D9           		exx
 663  8444 C1           		pop		bc
 664  8445 71 23 70 2B  		ld		(hl), bc
 665  8449
 666  8449 23           		inc		hl
 667  844A 23           		inc		hl
 668  844B
 669  844B              		;xor		a			;make flag 0 to signal that header is not read yet
 670  844B              		;ld		(hl), a
 671  844B
 672  844B 01 0A 00     		ld		bc, HDR_SZ + 1
 673  844E 09           		add		hl, bc
 674  844F
 675  844F EB           		ex		de, hl
 676  8450 C1           	pop bc
 677  8451
 678  8451
 679  8451 3A 25 96     	ld 		a, (FileCnt)			;inc file counter
 680  8454 3C           	inc		a
 681  8455 32 25 96     	ld 		(FileCnt), a
 682  8458 FE 5C        	cp		LST_MAX_FILES
 683  845A 38 29        	jr		c, NextExt
 684  845C 18 34        	jr		GetFileNamesEnd
 685  845E
 686  845E
 687  845E              FindExt:					;BC' = AU cnt for this ext
 688  845E C5           	push	bc
 689  845F D5           		push 	de
 690  8460 DD E5        			push	ix
 691  8462 D1           			pop		de
 692  8463 13           			inc		de				;DE = name to find
 693  8464
 694  8464 21 2E 96     			ld		hl, FileCache
 695  8467 3A 25 96     			ld		a, (FileCnt)
 696  846A 4F           			ld		c, a
 697  846B CD 82 89     			call	FindCache
 698  846E 20 13        			jr		nz, FindExtEnd
 699  8470
 700  8470 01 0D 00     			ld		bc, CACHE_AU_CNT
 701  8473 09           			add		hl, bc
 702  8474 D9           			exx
 703  8475 C5           			push	bc
 704  8476 D9           			exx
 705  8477 C1           			pop		bc
 706  8478
 707  8478 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 708  847C EB           			ex		de, hl
 709  847D 09           			add		hl, bc
 710  847E EB           			ex		de, hl
 711  847F 73 23 72 2B  			ld		(hl), de
 712  8483              FindExtEnd:
 713  8483 D1           		pop		de
 714  8484 C1           	pop		bc
 715  8485
 716  8485              NextExt:
 717  8485 C5           	push bc
 718  8486 01 20 00     		ld bc, EXT_SZ
 719  8489 DD 09        		add ix, bc
 720  848B C1           	pop	bc
 721  848C
 722  848C 05           	dec	b
 723  848D 78           	ld	a, b
 724  848E B7           	or	a
 725  848F C2 05 84     	jp	nz, StoreFilenamesLoop
 726  8492              GetFileNamesEnd:
 727  8492 C9           	ret
 728  8493
 729  8493              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 730  8493
 731  8493              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 732  8493              ;IN: HL = file name
 733  8493              HandleFile:
 734  8493              	;Make HL point to the selected file
 735  8493 DD 2A 2C 96  	ld		ix, (SelFileCache)
 736  8497 DD E5        	push	ix
 737  8499 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 738  849C B7           		or		a
 739  849D CC 93 89     		call	z, ReadFileHeader
 740  84A0
 741  84A0 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 742  84A3 FE 00        		cp		PROG_TYPE
 743  84A5 28 51        		jr		z, HandleFileProg
 744  84A7
 745  84A7 FE 03        		cp		BYTE_TYPE
 746  84A9 20 5D        		jr		nz, HandleFileText
 747  84AB
 748  84AB DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 748  84AF 66 12
 749  84B1 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 750  84B4 19           		add		hl, de
 751  84B5 7C           		ld		a, h
 752  84B6 B5           		or		l
 753  84B7 28 29        		jr		z, HandleFileSCR
 754  84B9
 755  84B9
 756  84B9              HandleFileCODE:
 757  84B9 21 71 91     		ld		hl, MsgLoadingCODE
 758  84BC 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 759  84BF 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 760  84C1 CD C1 8B     		call	PrintStrClr
 761  84C4
 762  84C4              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 763  84C4 21 FD 88     		ld		hl, IF1FileLoad
 764  84C7 11 00 5B     		ld		de, PRN_BUF
 765  84CA 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 766  84CD ED B0        		ldir
 767  84CF 3E C9        		ld		a, $C9
 768  84D1 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 769  84D2
 770  84D2 E1           	pop		hl
 771  84D3 ED 5B 2D AF  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 772  84D7 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 773  84D8 C1           	pop		bc						;2nd, 3rd call for error handler
 774  84D9 C1           	pop		bc
 775  84DA ED 43 3D 5C  	ld		(ERRSP), bc
 776  84DE D5           	push	de						;push CODE address to return to = start of CODE block
 777  84DF C3 00 5B     	jp		PRN_BUF
 778  84E2
 779  84E2
 780  84E2
 781  84E2
 782  84E2              HandleFileSCR:
 783  84E2 21 62 91     		ld		hl, MsgLoadingSCR
 784  84E5 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 785  84E8 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 786  84EA CD C1 8B     		call	PrintStrClr
 787  84ED
 788  84ED E1           	pop		hl
 789  84EE
 790  84EE              	IFDEF _ROM_FNT_
 791  84EE ~            		;Load to alternate SCREEN$ memory
 792  84EE ~            		ld		de, HC_VID_BANK1
 793  84EE ~            		call	IF1FileLoad
 794  84EE ~
 795  84EE ~            		;Set display to alternate SCREEN$ memory
 796  84EE ~            		ld		a, HC_CFG_VID_C000
 797  84EE ~            		out 	(HC_CFG_PORT), a
 798  84EE ~            		call	ReadChar
 799  84EE ~
 800  84EE ~            		;Set back to regular SCREEN$ memory
 801  84EE ~            		ld		a, HC_CFG_VID_4000
 802  84EE ~            		out 	(HC_CFG_PORT), a
 803  84EE              	ELSE
 804  84EE 11 00 40     		ld		de, HC_VID_BANK0
 805  84F1 CD FD 88     		call	IF1FileLoad
 806  84F4 CD 73 8B     		call	ReadChar
 807  84F7              	ENDIF
 808  84F7
 809  84F7 C9           	ret
 810  84F8
 811  84F8              HandleFileProg:
 812  84F8 21 53 91     		ld		hl, MsgLoadingPrg
 813  84FB 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 814  84FE 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 815  8500 CD C1 8B     		call	PrintStrClr
 816  8503 E1           	pop		hl
 817  8504 CD CB 89     	call	LoadProgram
 818  8507 C9           	ret
 819  8508
 820  8508
 821  8508              HandleFileText:
 822  8508 E1           	pop		hl
 823  8509
 824  8509
 825  8509              ViewFile:
 826  8509 CD 79 8B     	call	ClrScr
 827  850C 2A 2C 96     	ld		hl, (SelFileCache)
 828  850F 11 2A B7     	ld		de, FileData			;File buffer, after the index
 829  8512
 830  8512 D5           	push	de
 831  8513 D5           		push	de
 832  8514 CD FD 88     			call	IF1FileLoad		;DE = last addr.
 833  8517 EB           			ex		de, hl
 834  8518 D1           		pop		de
 835  8519 B7           		or		a
 836  851A ED 52        		sbc		hl, de
 837  851C 44           		ld		b, h
 838  851D 4D           		ld		c, l
 839  851E E1           	pop		hl
 840  851F CD 20 8D     	call	InitViewer
 841  8522 CD 7A 8D     	call	PrintLoop
 842  8525 C9           	ret
 843  8526
 844  8526              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 845  8526
 846  8526
 847  8526              DisplayFileInfo:
 848  8526 2A 2C 96     	ld		hl, (SelFileCache)
 849  8529 E5           	push	hl
 850  852A              		;disk size
 851  852A 01 0D 00     		ld		bc, CACHE_AU_CNT
 852  852D 09           		add		hl, bc
 853  852E 5E 23 56 2B  		ld		de, (hl)
 854  8532 EB           		ex		de, hl
 855  8533 11 8A 91     		ld		de, MsgFileSzDskN
 856  8536
 857  8536 06 0B        		ld		b, 11
 858  8538              MultKb:
 859  8538 29           		add		hl, hl
 860  8539 10 FD        		djnz	MultKb
 861  853B
 862  853B
 863  853B CD F7 86     		call	Word2Txt
 864  853E 21 81 91     		ld		hl, MsgFileSzDsk
 865  8541 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
 866  8544 CD 99 8B     		call	PrintStr
 867  8547 E1           	pop		hl
 868  8548 E5           	push	hl
 869  8549              		;attributes
 870  8549 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 871  854C 09           		add		hl, bc
 872  854D EB           		ex		de, hl
 873  854E 21 9A 91     		ld		hl, MsgFileAttrN
 874  8551 1A           		ld		a, (de)
 875  8552 E6 80        		and		%10000000
 876  8554 28 14        		jr		z, NotRO
 877  8556
 878  8556 01 52 2F     		ld		bc, '/R'
 879  8559 71 23 70 2B  		ld		(hl), bc
 880  855D 23           		inc		hl
 881  855E 23           		inc		hl
 882  855F 01 4F 2C     		ld		bc, ',O'
 883  8562 71 23 70 2B  		ld		(hl), bc
 884  8566 23           		inc		hl
 885  8567 23           		inc		hl
 886  8568 18 12        		jr		CheckSys
 887  856A              NotRO:
 888  856A 01 2D 2D     		ld		bc, '--'
 889  856D 71 23 70 2B  		ld		(hl), bc
 890  8571 23           		inc		hl
 891  8572 23           		inc		hl
 892  8573 01 2D 2C     		ld		bc, ',-'
 893  8576 71 23 70 2B  		ld		(hl), bc
 894  857A 23           		inc		hl
 895  857B 23           		inc		hl
 896  857C
 897  857C              CheckSys:
 898  857C 13           		inc		de
 899  857D 1A           		ld		a, (de)
 900  857E E6 80        		and		%10000000
 901  8580 28 0E        		jr		z, NotSYS
 902  8582
 903  8582 01 48 49     		ld		bc, 'IH'
 904  8585 71 23 70 2B  		ld		(hl), bc
 905  8589 23           		inc		hl
 906  858A 23           		inc		hl
 907  858B 3E C4        		ld		a, 'D' + $80
 908  858D 77           		ld		(hl), a
 909  858E 18 0C        		jr		AttrEnd
 910  8590              NotSYS:
 911  8590 01 2D 2D     		ld		bc, '--'
 912  8593 71 23 70 2B  		ld		(hl), bc
 913  8597 23           		inc		hl
 914  8598 23           		inc		hl
 915  8599 3E AD        		ld		a, '-' + $80
 916  859B 77           		ld		(hl), a
 917  859C              AttrEnd:
 918  859C 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
 919  859F 21 91 91     		ld		hl, MsgFileAttr
 920  85A2 CD 99 8B     		call	PrintStr
 921  85A5 DD E1        	pop		ix
 922  85A7 DD E5        	push	ix
 923  85A9 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 924  85AC B7           		or		a
 925  85AD CA 4C 86             jp		z, HeadNotRead
 926  85B0
 927  85B0 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
 928  85B3 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
 929  85B6 CA 4C 86             jp		z, HeadNotRead
 930  85B9
 931  85B9 DD 7E 10     		ld		a, (ix + CACHE_HDR)
 932  85BC FE 00        		cp		PROG_TYPE
 933  85BE 20 0B        		jr		nz, CheckNoArr
 934  85C0
 935  85C0 21 B4 91     		ld		hl, MsgFileTypePrg
 936  85C3 11 AA 91     		ld		de, MsgFileTypeN
 937  85C6 CD 95 86     		call	MoveMsg
 938  85C9 18 51        		jr		PrepFileLen
 939  85CB
 940  85CB              CheckNoArr:
 941  85CB FE 01        		cp		NUMB_TYPE
 942  85CD 20 0B        		jr		nz, CheckChrArr
 943  85CF
 944  85CF 21 D0 91     		ld		hl, MsgFileTypeNoA
 945  85D2 11 AA 91     		ld		de, MsgFileTypeN
 946  85D5 CD 95 86     		call	MoveMsg
 947  85D8 18 42        		jr		PrepFileLen
 948  85DA
 949  85DA              CheckChrArr:
 950  85DA FE 02        		cp		CHAR_TYPE
 951  85DC 20 0B        		jr		nz, CheckByte
 952  85DE
 953  85DE 21 C9 91     		ld		hl, MsgFileTypeChrA
 954  85E1 11 AA 91     		ld		de, MsgFileTypeN
 955  85E4 CD 95 86     		call	MoveMsg
 956  85E7 18 33        		jr		PrepFileLen
 957  85E9
 958  85E9              CheckByte:
 959  85E9 FE 03        		cp		BYTE_TYPE
 960  85EB 20 24        		jr		nz, CheckText
 961  85ED
 962  85ED DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
 962  85F1 66 12
 963  85F3 01 00 E5     		ld		bc, -SCR_LEN
 964  85F6 09           		add		hl, bc
 965  85F7 7C           		ld		a, h
 966  85F8 B5           		or		l
 967  85F9 20 0B        		jr		nz, NotScr
 968  85FB
 969  85FB 21 C2 91     		ld		hl, MsgFileTypeSCR
 970  85FE 11 AA 91     		ld		de, MsgFileTypeN
 971  8601 CD 95 86     		call	MoveMsg
 972  8604 18 16        		jr		PrepFileLen
 973  8606              NotScr:
 974  8606 21 BB 91     		ld		hl, MsgFileTypeByte
 975  8609 11 AA 91     		ld		de, MsgFileTypeN
 976  860C CD 95 86     		call	MoveMsg
 977  860F 18 0B        		jr		PrepFileLen
 978  8611
 979  8611              CheckText:
 980  8611 21 D7 91     		ld		hl, MsgFileTypeText
 981  8614 11 AA 91     		ld		de, MsgFileTypeN
 982  8617 CD 95 86     		call	MoveMsg
 983  861A 18 39        		jr		NoHeader
 984  861C
 985  861C              PrepFileLen:
 986  861C              		;File len
 987  861C DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
 988  861F DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 989  8622 11 EE 91     		ld		de, MsgFileLenN
 990  8625 CD F7 86     		call	Word2Txt
 991  8628 26 C2        		ld		h, 'B' | $80
 992  862A 2E 20        		ld		l, ' '
 993  862C 22 F3 91     		ld		(MsgFileLenN + 5), hl
 994  862F
 995  862F DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 996  8632 FE 00        		cp		PROG_TYPE
 997  8634 28 06        		jr		z, PrintProgStart
 998  8636
 999  8636 FE 03        		cp		BYTE_TYPE
1000  8638 28 0A        		jr		z, PrintByteStart
1001  863A 18 22        		jr		PrintStartNotRead
1002  863C
1003  863C              PrintProgStart:
1004  863C DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1005  863F DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1006  8642 18 25        		jr		PrintStart
1007  8644
1008  8644              PrintByteStart:
1009  8644 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1010  8647 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1011  864A 18 1D        		jr		PrintStart
1012  864C
1013  864C              HeadNotRead:
1014  864C 21 DE 91             ld        hl, MsgFileTypeUnkn
1015  864F 11 AA 91             ld        de, MsgFileTypeN
1016  8652 CD 95 86             call    MoveMsg
1017  8655
1018  8655              NoHeader:
1019  8655 21 DE 91     		ld		hl, MsgFileTypeUnkn
1020  8658 11 EE 91     		ld		de, MsgFileLenN
1021  865B CD 95 86     		call	MoveMsg
1022  865E
1023  865E              PrintStartNotRead:
1024  865E 21 DE 91     		ld		hl, MsgFileTypeUnkn
1025  8661 11 FE 91     		ld		de, MsgFileStartN
1026  8664 CD 95 86     		call	MoveMsg
1027  8667 18 0E        		jr		PrintStartStr
1028  8669
1029  8669              PrintStart:
1030  8669 1E 20        	ld		e, ' '
1031  866B 16 A0        	ld		d, ' ' | $80
1032  866D ED 53 03 92  	ld		(MsgFileStartN + 5), de
1033  8671 11 FE 91     	ld		de, MsgFileStartN
1034  8674 CD F7 86     	call	Word2Txt
1035  8677              PrintStartStr:
1036  8677 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1037  867A 21 F5 91     	ld		hl, MsgFileStart
1038  867D CD 99 8B     	call	PrintStr
1039  8680
1040  8680 DD E1        	pop		ix
1041  8682 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1042  8685 21 A1 91     	ld		hl, MsgFileType
1043  8688 CD 99 8B     	call	PrintStr
1044  868B
1045  868B 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1046  868E 21 E5 91     	ld		hl, MsgFileLen
1047  8691 CD 99 8B     	call	PrintStr
1048  8694
1049  8694 C9           	ret
1050  8695
1051  8695              MoveMsg:
1052  8695 01 07 00     	ld		bc, 7
1053  8698 ED B0        	ldir
1054  869A C9           	ret
1055  869B
1056  869B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1057  869B
1058  869B              ReadAllHeaders:
1059  869B 21 05 92     	ld		hl, MsgReadingExt
1060  869E 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1061  86A1 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1062  86A3 CD C1 8B     	call	PrintStrClr
1063  86A6
1064  86A6 CD 52 81     	call	CalcFileCache
1065  86A9
1066  86A9 3A 27 96     	ld		a, (SelFile)
1067  86AC 47           	ld		b, a
1068  86AD 3A 25 96     	ld		a, (FileCnt)
1069  86B0 90           	sub		b
1070  86B1 B7           	or		a
1071  86B2 C8           	ret		z
1072  86B3
1073  86B3 47           	ld		b, a
1074  86B4
1075  86B4 DD 2A 2C 96  	ld		ix, (SelFileCache)
1076  86B8              NextFile:
1077  86B8 C5           	push	bc
1078  86B9 CD 93 89     		call	ReadFileHeader
1079  86BC 01 19 00     		ld		bc, CACHE_SZ
1080  86BF DD 09        		add		ix, bc
1081  86C1 DD E5        		push	ix
1082  86C3 CD 52 81     			call	CalcFileCache
1083  86C6 CD 26 85     			call	DisplayFileInfo
1084  86C9 DD E1        		pop		ix
1085  86CB
1086  86CB CD 76 8B     		call	KbdHit
1087  86CE 38 03        		jr		c, AKey
1088  86D0 C1           	pop		bc
1089  86D1 18 15        	jr		ReadAllHeadersEnd
1090  86D3
1091  86D3              AKey:
1092  86D3 3A 27 96     		ld		a, (SelFile)
1093  86D6 3C           		inc		a
1094  86D7 47           		ld		b, a
1095  86D8 3A 25 96     		ld		a, (FileCnt)
1096  86DB B8           		cp		b
1097  86DC 28 16        		jr		z, DontInc
1098  86DE 78           		ld		a, b
1099  86DF 32 27 96     		ld		(SelFile), a
1100  86E2 CD 64 8C     		call	MoveCursor
1101  86E5 C1           	pop		bc
1102  86E6 10 D0        	djnz	NextFile
1103  86E8
1104  86E8              ReadAllHeadersEnd:
1105  86E8 21 13 92     	ld		hl, MsgClear
1106  86EB 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1107  86EE 3E 0F        	ld		a, SCR_DEF_CLR
1108  86F0 CD C1 8B     	call	PrintStrClr
1109  86F3 C9           	ret
1110  86F4
1111  86F4              DontInc:
1112  86F4 C1           	pop		bc
1113  86F5 18 F1        	jr		ReadAllHeadersEnd
1114  86F7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1115  86F7
1116  86F7              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 86F7              	ifndef	_HCCFG_
   2+ 86F7              	define	_HCCFG_
   3+ 86F7
   4+ 86F7              ;HC specific code, for configuration
   5+ 86F7
   6+ 86F7              HC_CFG_PORT			EQU	$7E
   7+ 86F7
   8+ 86F7              ;BASIC/CPM ROM selection
   9+ 86F7              HC_CFG_ROM_BAS		EQU	%0
  10+ 86F7              HC_CFG_ROM_CPM		EQU	%1
  11+ 86F7
  12+ 86F7              ;Address for ROM paging: 0 or $E000
  13+ 86F7              HC_CFG_ROM_0000		EQU %00
  14+ 86F7              HC_CFG_ROM_E000		EQU %10
  15+ 86F7
  16+ 86F7              ;Cfg. port Enable/Disable
  17+ 86F7              HC_CFG_PORT_DIS		EQU %000
  18+ 86F7              HC_CFG_PORT_EN		EQU	%100
  19+ 86F7
  20+ 86F7              ;Video memory bank: $4000 or $C000
  21+ 86F7              HC_CFG_VID_4000		EQU	%0000
  22+ 86F7              HC_CFG_VID_C000		EQU	%1000
  23+ 86F7
  24+ 86F7
  25+ 86F7              ;Standar BASIC config
  26+ 86F7              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 86F7              ;Standar CP/M config
  28+ 86F7              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 86F7
  30+ 86F7
  31+ 86F7              HC_VID_BANK0		EQU	$4000
  32+ 86F7              HC_VID_BANK1		EQU	$C000
  33+ 86F7
  34+ 86F7              	endif
# file closed: hccfg.asm
1117  86F7              	include "disk.asm"
# file opened: disk.asm
   1+ 86F7              ;HC IF1 routines and constants
   2+ 86F7
   3+ 86F7              ;IF1 routines error codes, also returned by BASIC commands
   4+ 86F7              ;12 = Writing to a 'read' file
   5+ 86F7              ;13 = Reading a 'write' file
   6+ 86F7              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 86F7              ;15 = Disk full (disk or catalog full)
   8+ 86F7              ;16 = Disk error (hardware error)
   9+ 86F7              ;17 = File not found
  10+ 86F7              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 86F7              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 86F7
  13+ 86F7              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 86F7              ;00h = OK
  15+ 86F7              ;08h = cannot format disk
  16+ 86F7              ;10h = disk protected (read-only?)
  17+ 86F7              ;20h = volume error
  18+ 86F7              ;40h = drive error
  19+ 86F7              ;80h = reading error
  20+ 86F7              ;Codes I encountered:
  21+ 86F7              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 86F7
  23+ 86F7
  24+ 86F7              	ifndef	_DISK_
  25+ 86F7              	define	_DISK_
  26+ 86F7
  27+ 86F7              	include	"math.asm"
# file opened: math.asm
   1++86F7              	ifndef	_MATH_
   2++86F7              	define	_MATH_
   3++86F7
   4++86F7              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++86F7              ;http://map.tni.nl/sources/external/z80bits.html
   6++86F7
   7++86F7
   8++86F7              Word2Txt:
   9++86F7              	IFUSED
  10++86F7 D5           	push	de
  11++86F8 CD 18 87     		call	Word2Txt_
  12++86FB D1           	pop		de
  13++86FC
  14++86FC 06 04        	ld		b, 4
  15++86FE CD 0D 87     	call	StrippLeading0
  16++8701 C9           	ret
  17++8702
  18++8702              Byte2Txt:
  19++8702 D5           	push	de
  20++8703 CD 24 87     		call	Byte2Txt_
  21++8706 D1           	pop		de
  22++8707
  23++8707 06 02        	ld		b, 2
  24++8709 CD 0D 87     	call	StrippLeading0
  25++870C C9           	ret
  26++870D              	ENDIF
  27++870D
  28++870D
  29++870D              StrippLeading0:
  30++870D 1A           	ld		a, (de)
  31++870E FE 31        	cp		'1'
  32++8710 D0           	ret		nc
  33++8711
  34++8711 3E 20        	ld		a, ' '
  35++8713 12           	ld		(de), a
  36++8714 13           	inc		de
  37++8715 10 F6        	djnz	StrippLeading0
  38++8717 C9           	ret
  39++8718
  40++8718
  41++8718              ;Converts the number in HL to ASCII in decimal string at DE
  42++8718              Word2Txt_:
  43++8718 01 F0 D8     	ld bc, -10000
  44++871B CD 33 87     	call DigitLoop
  45++871E 01 18 FC     	ld bc, -1000
  46++8721 CD 33 87     	call DigitLoop
  47++8724              Byte2Txt_:
  48++8724 01 9C FF     	ld bc, -100
  49++8727 CD 33 87     	call DigitLoop
  50++872A 01 F6 FF     	ld bc, -10
  51++872D CD 33 87     	call DigitLoop
  52++8730 01 FF FF     	ld bc, -1
  53++8733
  54++8733              DigitLoop:
  55++8733 3E 2F        	ld	a, '0' - 1
  56++8735              DivNrLoop:
  57++8735 3C           	inc	a			;increase reminder
  58++8736 09           	add	hl, bc		;substract divizor
  59++8737 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++8739 ED 42        	sbc	hl, bc		;nope, restore
  61++873B
  62++873B 12           	ld (de), a
  63++873C 13           	inc de
  64++873D C9           	ret
  65++873E
  66++873E
  67++873E              ;Input: HL = Dividend, C = Divisor
  68++873E              ;Output: HL = Quotient, A = Remainder
  69++873E              ;Warning: doesn't work with divisor >= $80
  70++873E              Div:
  71++873E              	IFUSED
  72++873E AF           	xor a
  73++873F 06 10        	ld b, 16
  74++8741
  75++8741              DivLoop:
  76++8741 29           	add	hl,hl
  77++8742 17           	rla
  78++8743 B9           	cp	c
  79++8744 38 02        	jr	c, NoSub
  80++8746 91           	sub	c
  81++8747 2C           	inc	l
  82++8748              NoSub:
  83++8748 10 F7        	djnz DivLoop
  84++874A
  85++874A C9           	ret
  86++874B              	ENDIF
  87++874B
  88++874B              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++874B              ;Output: A:C = Quotient, HL = Remainder
  90++874B              Div2:
  91++874B 21 00 00     	ld hl, 0
  92++874E 06 10        	ld b, 16
  93++8750              Div2Loop:
  94++8750 CB 31        	sll c		; unroll 16 times
  95++8752 17           	rla			; ...
  96++8753 ED 6A        	adc	hl,hl		; ...
  97++8755 ED 52        	sbc	hl,de		; ...
  98++8757 30 02        	jr	nc,$+4		; ...
  99++8759 19           	add	hl,de		; ...
 100++875A 0D           	dec	c		; ...
 101++875B 10 F3        	djnz Div2Loop
 102++875D C9           	ret
 103++875E
 104++875E
 105++875E              ;Input: A = Multiplier, DE = Multiplicand
 106++875E              ;Output: A:HL = Product
 107++875E              Mul:
 108++875E              	IFUSED
 109++875E 21 00 00     	ld hl, 0
 110++8761 01 00 07     	ld bc, $0700
 111++8764
 112++8764 87           	add	a, a		; optimised 1st iteration
 113++8765 30 02        	jr	nc, MulLoop
 114++8767 62           	ld	h, d
 115++8768 6B           	ld	l, e
 116++8769
 117++8769              MulLoop:
 118++8769 29           	add	hl,hl
 119++876A 17           	rla
 120++876B 30 02        	jr	nc, NoAdd
 121++876D 19           	add	hl,de
 122++876E 89           	adc	a,c
 123++876F              NoAdd:
 124++876F 10 F8        	djnz MulLoop
 125++8771
 126++8771 C9           	ret
 127++8772              	ENDIF
 128++8772
 129++8772              	endif
# file closed: math.asm
  28+ 8772
  29+ 8772              DRIVE_CUR_BAS	EQU 0
  30+ 8772              DRIVE_A_BAS		EQU	1
  31+ 8772              DRIVE_B_BAS		EQU	2
  32+ 8772              DRIVE_A_CPM		EQU	0
  33+ 8772              DRIVE_B_CPM		EQU	1
  34+ 8772              ;Disk geometry stuff
  35+ 8772              SPT				EQU	16			;sectors per track
  36+ 8772              SECT_SZ			EQU	256			;sector size in bytes
  37+ 8772              TRACK_CNT		EQU	80			;track count
  38+ 8772              HEAD_CNT		EQU	2			;disk face count
  39+ 8772              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 8772              EXT_SZ			EQU	32			;directory entry size
  41+ 8772              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 8772              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 8772              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 8772              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 8772              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 8772              REC_SZ			EQU 128			;cp/m record size
  47+ 8772              DEL_MARKER		EQU	$E5
  48+ 8772              EOF_MARKER		EQU	$1B
  49+ 8772
  50+ 8772
  51+ 8772              ;Extension structure (directory entry)
  52+ 8772              EXT_DEL_FLAG	EQU	0
  53+ 8772              EXT_NAME		EQU 1
  54+ 8772              EXT_IDX			EQU 12
  55+ 8772              EXT_S1			EQU 13
  56+ 8772              EXT_S2			EQU 14
  57+ 8772              EXT_RC			EQU	15
  58+ 8772              EXT_AU0			EQU	16
  59+ 8772              EXT_AU1			EQU	18
  60+ 8772              EXT_AU2			EQU	20
  61+ 8772              EXT_AU3			EQU	22
  62+ 8772              EXT_AU4			EQU	24
  63+ 8772              EXT_AU5			EQU	26
  64+ 8772              EXT_AU6			EQU	28
  65+ 8772              EXT_AU7			EQU	30
  66+ 8772              EXT_SIZE		EQU 32
  67+ 8772
  68+ 8772              ;FCB structure
  69+ 8772              FCB_DRIVE		EQU 0
  70+ 8772              FCB_NAME		EQU EXT_NAME
  71+ 8772              FCB_EX_IDX		EQU EXT_IDX
  72+ 8772              FCB_S1			EQU EXT_S1
  73+ 8772              FCB_S2			EQU EXT_S2
  74+ 8772              FCB_RC			EQU	EXT_RC
  75+ 8772              FCB_AU			EQU	EXT_AU0
  76+ 8772              FCB_CR			EQU	32
  77+ 8772              FCB_R0			EQU 33
  78+ 8772              FCB_R1			EQU 34
  79+ 8772              FCB_R2			EQU 35
  80+ 8772              FCB_SIZE		EQU 36
  81+ 8772
  82+ 8772
  83+ 8772
  84+ 8772              ;System variables for disk
  85+ 8772              DSTR1			EQU	$5CD6		;drive
  86+ 8772              FSTR1			EQU	$5CDC		;file name
  87+ 8772              NSTR1			EQU	$5CDA		;name length
  88+ 8772              HD11			EQU	$5CED		;BDOS argument
  89+ 8772              COPIES			EQU	$5CEF		;BDOS function
  90+ 8772
  91+ 8772              ERRSP			EQU $5C3D
  92+ 8772              ERRNR			EQU $5C3A
  93+ 8772              ERRMSG			EQU	$0260
  94+ 8772
  95+ 8772              PRN_BUF			EQU	23296
  96+ 8772
  97+ 8772              ;STR_COPYRIGHT	EQU	$1539
  98+ 8772
  99+ 8772              REPDEL			EQU	23561
 100+ 8772              REPPER			EQU	23562
 101+ 8772              PIP				EQU	23609
 102+ 8772
 103+ 8772
 104+ 8772              ;RWTS routine commands
 105+ 8772              RWTS_CMD_POS	EQU	0			;position head
 106+ 8772              RWTS_CMD_READ	EQU	1			;read sector
 107+ 8772              RWTS_CMD_WRITE	EQU	2			;write sector
 108+ 8772              RWTS_CMD_FMT	EQU	4			;format all tracks
 109+ 8772
 110+ 8772
 111+ 8772              ;File name stuff
 112+ 8772              NAMELEN			EQU	11			;name length
 113+ 8772              RO_POS			EQU	8			;read-only attribute position in name
 114+ 8772              SYS_POS			EQU	9			;system attribute position in name
 115+ 8772
 116+ 8772              ;File types (first byte in header)
 117+ 8772              PROG_TYPE		EQU	0			;program
 118+ 8772              NUMB_TYPE		EQU	1			;number array
 119+ 8772              CHAR_TYPE		EQU	2			;char array
 120+ 8772              BYTE_TYPE		EQU	3			;bytes
 121+ 8772              TEXT_TYPE		EQU	4			;text, >= 4
 122+ 8772
 123+ 8772              ;File header offsets
 124+ 8772              HDR_TYPE		EQU	0
 125+ 8772              HDR_LEN			EQU 1
 126+ 8772              HDR_ADDR		EQU 3
 127+ 8772              HDR_PLEN		EQU	5
 128+ 8772              HDR_LINE		EQU 7
 129+ 8772              HDR_SZ			EQU	9
 130+ 8772
 131+ 8772              ;BASIC disk channel structure
 132+ 8772              CH_RW_FLAG		EQU 11
 133+ 8772              CH_FCB			EQU	12
 134+ 8772              CH_DATA			EQU	50
 135+ 8772              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 136+ 8772
 137+ 8772              CACHE_NAME		EQU	0					;11B
 138+ 8772              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 139+ 8772              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 140+ 8772              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 141+ 8772              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 142+ 8772              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 143+ 8772
 144+ 8772              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 145+ 8772
 146+ 8772              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 8772              IF1Init:
 148+ 8772 CF           	rst		08
 149+ 8773 31           	defb	49		;create system variables
 150+ 8774 C9           	ret
 151+ 8775
 152+ 8775              ;ReadWriteTrackSector
 153+ 8775              ;A=command: 0, 1, 2, 4
 154+ 8775              RWTS:
 155+ 8775 32 23 8A     	ld (RWTSCmd), a
 156+ 8778 21 18 8A     	ld hl, RWTSParams
 157+ 877B 22 ED 5C     	ld (HD11), hl
 158+ 877E CF           	rst 08
 159+ 877F 3A           	DEFB 58
 160+ 8780 C9           	ret
 161+ 8781
 162+ 8781
 163+ 8781              ;D = sector, E = track
 164+ 8781              ;HL = dma
 165+ 8781              ReadOneDiskSector:
 166+ 8781 22 1D 8A     	ld (RWTSDMA), hl
 167+ 8784 ED 53 1B 8A  	ld (RWTSTrack), de
 168+ 8788              	;ld (RWTSDrive), a
 169+ 8788 3E 01        	ld a, RWTS_CMD_READ
 170+ 878A 18 E9        	jr	RWTS
 171+ 878C
 172+ 878C              ;D = sector, E = track
 173+ 878C              ;HL = dma
 174+ 878C              WriteOneDiskSector:
 175+ 878C 22 1D 8A     	ld (RWTSDMA), hl
 176+ 878F ED 53 1B 8A  	ld (RWTSTrack), de
 177+ 8793              	;ld (RWTSDrive), a
 178+ 8793 3E 02        	ld a, RWTS_CMD_WRITE
 179+ 8795 18 DE        	jr	RWTS
 180+ 8797
 181+ 8797              FormatDisk:
 182+ 8797 21 2A AF     	ld		hl, DataBuf
 183+ 879A 36 E5        	ld		(hl), DEL_MARKER
 184+ 879C 22 1D 8A     	ld 		(RWTSDMA), hl
 185+ 879F 3E 04        	ld 		a, RWTS_CMD_FMT
 186+ 87A1 CD 75 87     	call	RWTS
 187+ 87A4 3A 24 8A     	ld		a, (RWTSRes)
 188+ 87A7 C9           	ret
 189+ 87A8
 190+ 87A8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 191+ 87A8
 192+ 87A8              ;Allocation unit no. to track/sector
 193+ 87A8              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 194+ 87A8              ;IN:  HL=alloc. unit no.
 195+ 87A8              ;OUT: B=sector; C=track (head is determined by the sector number)
 196+ 87A8              AU2TS:
 197+ 87A8 0E 02        	ld c, SPT/SPAL
 198+ 87AA CD 3E 87     	call Div					;A = sector
 199+ 87AD F5           	push af
 200+ 87AE ~            		/*
 201+ 87AE ~            		ld c, HEAD_CNT
 202+ 87AE ~            		call Div				;L = track, A = head (0 or 1)
 203+ 87AE ~            		*/
 204+ 87AE AF           		xor a
 205+ 87AF CB 1C        		rr h
 206+ 87B1 CB 1D        		rr l
 207+ 87B3 CB 1F        		rr a
 208+ 87B5
 209+ 87B5 4D           		ld c, l
 210+ 87B6 06 00        		ld b, 0
 211+ 87B8 B7           		or a
 212+ 87B9 28 02        		jr z, Track0
 213+ 87BB 06 10        		ld b, SPT
 214+ 87BD              Track0:
 215+ 87BD F1           	pop af
 216+ 87BE B7           	or a
 217+ 87BF 28 02        	jr z, FirstAU
 218+ 87C1 3E 08        	ld a, SPAL
 219+ 87C3              FirstAU:
 220+ 87C3 80           	add a, b
 221+ 87C4 47           	ld  b, a
 222+ 87C5 C9           	ret
 223+ 87C6
 224+ 87C6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 225+ 87C6
 226+ 87C6              ;Checks the allocation units number used in extension
 227+ 87C6              ;IN:	IX = extension addr
 228+ 87C6              ;OUT:	B = no. of allocation units used
 229+ 87C6              ;		C = no. of records used in ext.
 230+ 87C6              ;		HL = first alloc. unit no.
 231+ 87C6              ;		DE = last alloc. unit no.
 232+ 87C6              CheckExtAlloc:
 233+ 87C6 DD E5        	push ix
 234+ 87C8 01 0F 00     		ld bc, EXT_RC
 235+ 87CB DD 09        		add ix, bc
 236+ 87CD DD 4E 00     		ld c, (ix)			;save rec. no.
 237+ 87D0 DD 23        		inc ix
 238+ 87D2 DD 6E 00     		ld l, (ix)
 239+ 87D5 DD 66 01     		ld h, (ix + 1)
 240+ 87D8 06 08        		ld b, EXT_AU_CNT
 241+ 87DA              CheckAU:
 242+ 87DA DD 7E 00     		ld a, (ix)
 243+ 87DD DD B6 01     		or (ix + 1)
 244+ 87E0 28 0C        		jr z, CheckAUEnd
 245+ 87E2 DD 5E 00     		ld e, (ix)
 246+ 87E5 DD 56 01     		ld d, (ix + 1)
 247+ 87E8 DD 23        		inc ix
 248+ 87EA DD 23        		inc ix
 249+ 87EC 10 EC        		djnz CheckAU
 250+ 87EE              CheckAUEnd:
 251+ 87EE 3E 08        		ld a, EXT_AU_CNT
 252+ 87F0 90           		sub b
 253+ 87F1 47           		ld b, a
 254+ 87F2 DD E1        	pop ix
 255+ 87F4 C9           	ret
 256+ 87F5
 257+ 87F5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 258+ 87F5
 259+ 87F5              ;Input: TrackBuffer
 260+ 87F5              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 261+ 87F5              ReadUsedBlocksList:
 262+ 87F5 DD 21 2A 9F  	ld		ix, TrackBuf			;source buffer
 263+ 87F9 21 2A AF     	ld		hl, UsedBlockListCnt 	;destination buffer
 264+ 87FC 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 265+ 87FF 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 266+ 8802 73           	ld		(hl), e
 267+ 8803 23           	inc		hl
 268+ 8804 72           	ld		(hl), d
 269+ 8805 23           	inc		hl
 270+ 8806
 271+ 8806              	;Add blocks 0 and 1 for directory
 272+ 8806 11 00 00     	ld		de, 0
 273+ 8809 73           	ld		(hl), e
 274+ 880A 23           	inc		hl
 275+ 880B 72           	ld		(hl), d
 276+ 880C 23           	inc		hl
 277+ 880D
 278+ 880D 13           	inc		de
 279+ 880E 73           	ld		(hl), e
 280+ 880F 23           	inc		hl
 281+ 8810 72           	ld		(hl), d
 282+ 8811 23           	inc		hl
 283+ 8812
 284+ 8812              ReadUsedBlocksLoop:
 285+ 8812 AF           	xor		a
 286+ 8813 DD BE 00     	cp		(ix)
 287+ 8816 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 288+ 8818
 289+ 8818 DD E5        	push	ix
 290+ 881A C5           	push	bc
 291+ 881B 06 08        		ld		b, EXT_AU_CNT
 292+ 881D 11 10 00     		ld		de, EXT_AU0
 293+ 8820 DD 19        		add		ix, de
 294+ 8822
 295+ 8822              ReadUsedBlocksLoop2:
 296+ 8822 DD 5E 00     		ld		e, (ix)
 297+ 8825 DD 56 01     		ld		d, (ix+1)
 298+ 8828 7B           		ld		a, e
 299+ 8829 B2           		or		d
 300+ 882A 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 301+ 882C
 302+ 882C 73           		ld		(hl), e
 303+ 882D 23           		inc		hl
 304+ 882E 72           		ld		(hl), d
 305+ 882F 23           		inc		hl
 306+ 8830
 307+ 8830 DD 23        		inc		ix
 308+ 8832 DD 23        		inc		ix
 309+ 8834
 310+ 8834 ED 5B 2A AF  		ld		de, (UsedBlockListCnt)
 311+ 8838 13           		inc		de
 312+ 8839 ED 53 2A AF  		ld		(UsedBlockListCnt), de
 313+ 883D
 314+ 883D 10 E3        		djnz	ReadUsedBlocksLoop2
 315+ 883F
 316+ 883F
 317+ 883F              ReadUsedBlocksSkip:
 318+ 883F C1           	pop		bc
 319+ 8840 DD E1        	pop		ix
 320+ 8842              ReadUsedBlocksSkip2:
 321+ 8842 11 20 00     	ld		de, EXT_SZ
 322+ 8845 DD 19        	add		ix, de
 323+ 8847
 324+ 8847 0B           	dec		bc
 325+ 8848 78           	ld		a, b
 326+ 8849 B1           	or		c
 327+ 884A 20 C6        	jr		nz, ReadUsedBlocksLoop
 328+ 884C
 329+ 884C C9           	ret
 330+ 884D
 331+ 884D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 332+ 884D              ;Reads 8 sectors for an AU
 333+ 884D              ;HL = block number, DE = destination buffer
 334+ 884D              ReadFSBlock:
 335+ 884D D5           	push	de
 336+ 884E CD A8 87     		call	AU2TS		;B=sector, C=track
 337+ 8851 E1           	pop		hl				;HL=dest
 338+ 8852
 339+ 8852 50           	ld		d, b
 340+ 8853 59           	ld		e, c
 341+ 8854 06 08        	ld		b, SPAL
 342+ 8856
 343+ 8856              ReadFSBlockLoop:
 344+ 8856 CD 43 89     	call	ReadDiskSectors
 345+ 8859 C9           	ret
 346+ 885A
 347+ 885A
 348+ 885A              ;Write 8 sectors for an AU
 349+ 885A              ;HL = block number, DE = source buffer
 350+ 885A              WriteFSBlock:
 351+ 885A D5           	push	de
 352+ 885B CD A8 87     		call	AU2TS		;B=sector, C=track
 353+ 885E E1           	pop		hl				;HL=dest
 354+ 885F
 355+ 885F 50           	ld		d, b
 356+ 8860 59           	ld		e, c
 357+ 8861 06 08        	ld		b, SPAL
 358+ 8863
 359+ 8863              WriteFSBlockLoop:
 360+ 8863 CD 56 89     	call	WriteDiskSectors
 361+ 8866 C9           	ret
 362+ 8867
 363+ 8867              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364+ 8867              ;Copies the allocated blocks from one disk to another.
 365+ 8867              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366+ 8867              CopyDisk:
 367+ 8867              	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 368+ 8867 CD F5 87     	call	ReadUsedBlocksList
 369+ 886A DD 21 2C AF  	ld		ix, UsedBlockListBlk
 370+ 886E
 371+ 886E              CopyDiskLoop:
 372+ 886E 2A 2A AF     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373+ 8871 11 AE 92     	ld		de, MsgBlocksLeft
 374+ 8874 CD 02 87     	call	Byte2Txt
 375+ 8877 21 AE 92     	ld		hl, MsgBlocksLeft
 376+ 887A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 377+ 887D 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 378+ 887F CD C1 8B     	call	PrintStrClr
 379+ 8882
 380+ 8882              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381+ 8882 21 07 00     	ld		hl, MAX_AU_RAM
 382+ 8885 ED 4B 2A AF  	ld		bc, (UsedBlockListCnt)
 383+ 8889 B7           	or		a
 384+ 888A ED 42        	sbc		hl, bc
 385+ 888C 30 03        	jr		nc, CopyDiskLoopRead
 386+ 888E 01 07 00     	ld		bc, MAX_AU_RAM
 387+ 8891
 388+ 8891              CopyDiskLoopRead:
 389+ 8891 41           	ld		b, c
 390+ 8892 11 AC B1     	ld		de, CopyDiskBuf
 391+ 8895              	;save initial counter and initial block number array position
 392+ 8895 C5           	push	bc
 393+ 8896 DD E5        	push	ix
 394+ 8898
 395+ 8898              CopyDiskLoopReadLoop:
 396+ 8898 DD 6E 00     		ld		l, (ix)
 397+ 889B DD 66 01     		ld		h, (ix+1)
 398+ 889E DD 23        		inc		ix
 399+ 88A0 DD 23        		inc		ix
 400+ 88A2
 401+ 88A2 D5           		push	de
 402+ 88A3 C5           		push	bc
 403+ 88A4 CD 4D 88     			call	ReadFSBlock			;Stop on error or continue?
 404+ 88A7 C1           		pop		bc
 405+ 88A8 D1           		pop		de
 406+ 88A9
 407+ 88A9              		;+2048
 408+ 88A9 7A           		ld		a, d
 409+ 88AA C6 08        		add		8
 410+ 88AC 57           		ld		d, a
 411+ 88AD
 412+ 88AD 10 E9        		djnz	CopyDiskLoopReadLoop
 413+ 88AF
 414+ 88AF              		;alternate drive
 415+ 88AF 3A 19 8A     		ld		a, (RWTSDrive)
 416+ 88B2 EE 03        		xor		%11
 417+ 88B4 32 19 8A     		ld		(RWTSDrive), a
 418+ 88B7
 419+ 88B7              	;restore initial counter and initial block number array position
 420+ 88B7 DD E1        	pop		ix
 421+ 88B9 C1           	pop		bc
 422+ 88BA 11 AC B1     	ld		de, CopyDiskBuf
 423+ 88BD C5           	push	bc
 424+ 88BE
 425+ 88BE              CopyDiskLoopWriteLoop:
 426+ 88BE DD 6E 00     		ld		l, (ix)
 427+ 88C1 DD 66 01     		ld		h, (ix+1)
 428+ 88C4 DD 23        		inc		ix
 429+ 88C6 DD 23        		inc		ix
 430+ 88C8
 431+ 88C8 D5           		push	de
 432+ 88C9 C5           		push	bc
 433+ 88CA CD 5A 88     			call	WriteFSBlock		;Stop on error or continue?
 434+ 88CD C1           		pop		bc
 435+ 88CE D1           		pop		de
 436+ 88CF
 437+ 88CF              		;+2048
 438+ 88CF 7A           		ld		a, d
 439+ 88D0 C6 08        		add		8
 440+ 88D2 57           		ld		d, a
 441+ 88D3
 442+ 88D3 10 E9        		djnz	CopyDiskLoopWriteLoop
 443+ 88D5
 444+ 88D5              		;alternate drive again
 445+ 88D5 3A 19 8A     		ld		a, (RWTSDrive)
 446+ 88D8 EE 03        		xor		%11
 447+ 88DA 32 19 8A     		ld		(RWTSDrive), a
 448+ 88DD
 449+ 88DD C1           	pop		bc
 450+ 88DE 48           	ld		c, b
 451+ 88DF 06 00        	ld		b, 0
 452+ 88E1
 453+ 88E1              	;Decrease number of blocks read by now.
 454+ 88E1 2A 2A AF     	ld		hl, (UsedBlockListCnt)
 455+ 88E4 B7           	or		a
 456+ 88E5 ED 42        	sbc		hl, bc
 457+ 88E7 22 2A AF     	ld		(UsedBlockListCnt), hl
 458+ 88EA
 459+ 88EA 7D           	ld		a, l
 460+ 88EB B4           	or		h
 461+ 88EC C2 6E 88     	jp		nz, CopyDiskLoop
 462+ 88EF
 463+ 88EF C9           	ret
 464+ 88F0
 465+ 88F0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 466+ 88F0
 467+ 88F0              ;Compare string at HL with the one at DE, max length B
 468+ 88F0              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 469+ 88F0              ;OUT: z flag, set = match, reset = mismatch
 470+ 88F0              StrCmp:
 471+ 88F0 E5           	push hl
 472+ 88F1 D5           	push de
 473+ 88F2              Compare:
 474+ 88F2 1A           		ld a, (de)
 475+ 88F3 BE           		cp (hl)
 476+ 88F4 20 04        		jr nz, MisMatch
 477+ 88F6 23           		inc hl
 478+ 88F7 13           		inc de
 479+ 88F8 10 F8        		djnz Compare
 480+ 88FA              MisMatch:
 481+ 88FA D1           	pop de
 482+ 88FB E1           	pop hl
 483+ 88FC C9           	ret
 484+ 88FD
 485+ 88FD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 486+ 88FD
 487+ 88FD              ;Read a file into a buffer, sector by sector.
 488+ 88FD              ;It's relocatable, to moved and be used when loading a CODE block.
 489+ 88FD              ;It's not using BDOS, but using similar calls provided by IF1.
 490+ 88FD              ;In: HL = Name address, DE = buffer
 491+ 88FD              IF1FileLoad:
 492+ 88FD D5           	push	de
 493+ 88FE 22 DC 5C     		ld (FSTR1), hl
 494+ 8901 26 00        		ld h, 0
 495+ 8903 3A 19 8A     		ld a, (RWTSDrive)
 496+ 8906 3C           		inc  a			;CP/M drive number to BASIC drive number
 497+ 8907 6F           		ld	l, a
 498+ 8908 22 D6 5C     		ld (DSTR1), hl
 499+ 890B 2E 0B        		ld l,NAMELEN
 500+ 890D 22 DA 5C     		ld (NSTR1), hl
 501+ 8910 CF           		rst 08
 502+ 8911 33           		DEFB 51			;open disk channel
 503+ 8912
 504+ 8912 CF           		rst		8
 505+ 8913 35           		defb	53		;read sector
 506+ 8914 D1           	pop		de
 507+ 8915 30 27        	jr		nc, FileFree
 508+ 8917
 509+ 8917 DD 7E 32     	ld		a, (ix + CH_DATA)
 510+ 891A FE 04        	cp		TEXT_TYPE
 511+ 891C 30 12        	jr		nc, FileLoadNoHeader
 512+ 891E
 513+ 891E              FileLoadHeader:
 514+ 891E DD E5        	push	ix
 515+ 8920 E1           	pop		hl
 516+ 8921 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 517+ 8924 09           	add		hl, bc
 518+ 8925 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 519+ 8928 ED B0        	ldir
 520+ 892A
 521+ 892A              FileReadLoop:
 522+ 892A D5           	push	de
 523+ 892B CF           		rst		8
 524+ 892C 35           		defb	53		;read sector
 525+ 892D D1           	pop		de
 526+ 892E 30 0E        	jr		nc, FileFree
 527+ 8930
 528+ 8930              FileLoadNoHeader:
 529+ 8930 DD E5        	push	ix
 530+ 8932 E1           	pop		hl
 531+ 8933 01 32 00     	ld		bc, CH_DATA
 532+ 8936 09           	add		hl, bc
 533+ 8937 01 00 01     	ld		bc, SECT_SZ
 534+ 893A ED B0        	ldir
 535+ 893C 18 EC        	jr		FileReadLoop
 536+ 893E              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 537+ 893E              IF1FileLoadEnd:
 538+ 893E
 539+ 893E              FileFree:
 540+ 893E D5           	push	de
 541+ 893F CF           	rst		8
 542+ 8940 38           	defb	56			;close channel (52) or detroy channel (56)
 543+ 8941 D1           	pop		de
 544+ 8942 C9           	ret
 545+ 8943
 546+ 8943
 547+ 8943              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 548+ 8943              ;HL = destination buffer, B = count of sectors, DE = track/sector
 549+ 8943              ;Out: A = error code, 0=OK
 550+ 8943              ReadDiskSectors:
 551+ 8943 C5           	push bc
 552+ 8944 E5           		push hl
 553+ 8945 D5           			push de
 554+ 8946 CD 81 87     				call ReadOneDiskSector
 555+ 8949 D1           			pop de
 556+ 894A E1           		pop hl
 557+ 894B
 558+ 894B 14           		inc d
 559+ 894C 24           		inc h
 560+ 894D C1           	pop bc
 561+ 894E
 562+ 894E 3A 24 8A     	ld	a, (RWTSRes)
 563+ 8951 B7           	or	a
 564+ 8952 C0           	ret nz
 565+ 8953
 566+ 8953 10 EE        	djnz ReadDiskSectors
 567+ 8955 C9           	ret
 568+ 8956
 569+ 8956              ;HL = source buffer, B = count of sectors, DE = track/sector
 570+ 8956              ;Out: A = error code, 0=OK
 571+ 8956              WriteDiskSectors:
 572+ 8956 C5           	push bc
 573+ 8957 E5           		push hl
 574+ 8958 D5           			push de
 575+ 8959 CD 8C 87     				call WriteOneDiskSector
 576+ 895C D1           			pop de
 577+ 895D E1           		pop hl
 578+ 895E
 579+ 895E 14           		inc d
 580+ 895F 24           		inc h
 581+ 8960 C1           	pop bc
 582+ 8961
 583+ 8961 3A 24 8A     	ld	a, (RWTSRes)
 584+ 8964 B7           	or	a
 585+ 8965 C0           	ret nz
 586+ 8966
 587+ 8966 10 EE        	djnz WriteDiskSectors
 588+ 8968 C9           	ret
 589+ 8969
 590+ 8969
 591+ 8969              ;Reads disk catalog
 592+ 8969              ReadCatalogTrack:
 593+ 8969 21 2A 9F     	ld hl, TrackBuf
 594+ 896C 11 00 00     	ld de, 0
 595+ 896F 06 10        	ld b, SPT
 596+ 8971
 597+ 8971 CD 43 89     	call ReadDiskSectors
 598+ 8974 B7           	or   a
 599+ 8975 C0           	ret  nz
 600+ 8976
 601+ 8976              	;Sync with BDOS, to avoid disk R/O error on disk change
 602+ 8976 F5           	push  af
 603+ 8977 3A 19 8A     		ld  a, (RWTSDrive)
 604+ 897A CD 2E 8A     		call BDOSSelectDisk
 605+ 897D CD 2B 8A     		call BDOSInit
 606+ 8980 F1           	pop   af
 607+ 8981 C9           	ret
 608+ 8982
 609+ 8982
 610+ 8982
 611+ 8982              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612+ 8982
 613+ 8982              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 614+ 8982              FindCache:
 615+ 8982 06 0B        	ld		b, NAMELEN
 616+ 8984 CD F0 88     	call	StrCmp			;find the file to wich this extension belongs
 617+ 8987 C8           	ret		z
 618+ 8988
 619+ 8988 0D           	dec		c
 620+ 8989 20 02        	jr		nz, CacheNotFinished
 621+ 898B B1           	or		c
 622+ 898C C9           	ret
 623+ 898D
 624+ 898D              CacheNotFinished:
 625+ 898D 01 19 00     	ld		bc, CACHE_SZ
 626+ 8990 09           	add		hl, bc			;to the next cache line
 627+ 8991 18 EF        	jr		FindCache
 628+ 8993
 629+ 8993              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 630+ 8993
 631+ 8993              	;ld		ix, (SelFileCache)
 632+ 8993              ReadFileHeader:
 633+ 8993 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 634+ 8996 B7           	or		a
 635+ 8997 C0           	ret		nz				;return if already read
 636+ 8998
 637+ 8998 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 638+ 899B DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 639+ 899E 7C           	ld		a, h
 640+ 899F B5           	or		l
 641+ 89A0 28 1F        	jr		z, ReadHeaderEnd
 642+ 89A2 CD A8 87     	call	AU2TS
 643+ 89A5 50           	ld		d, b
 644+ 89A6 59           	ld		e, c
 645+ 89A7 21 2A AF     	ld		hl, DataBuf
 646+ 89AA DD E5        	push	ix
 647+ 89AC DD E5        	push	ix
 648+ 89AE CD 81 87     		call	ReadOneDiskSector
 649+ 89B1 E1           	pop		hl
 650+ 89B2 DD E1        	pop		ix
 651+ 89B4 01 10 00     	ld		bc, CACHE_HDR
 652+ 89B7 09           	add		hl, bc
 653+ 89B8 EB           	ex		hl, de
 654+ 89B9 21 2A AF     	ld		hl, DataBuf
 655+ 89BC 01 09 00     	ld		bc, HDR_SZ
 656+ 89BF ED B0        	ldir
 657+ 89C1              ReadHeaderEnd:
 658+ 89C1 DD 34 0F     	inc		(ix + CACHE_FLAG)
 659+ 89C4 C9           	ret
 660+ 89C5
 661+ 89C5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 662+ 89C5
 663+ 89C5              ;IN: HL = address from IF1 to call
 664+ 89C5              IF1Call:
 665+ 89C5 22 ED 5C     	LD   (HD11), HL
 666+ 89C8 CF           	RST  8
 667+ 89C9 32           	DEFB 50
 668+ 89CA C9           	RET
 669+ 89CB
 670+ 89CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 671+ 89CB
 672+ 89CB              ;Load a program from disk
 673+ 89CB              ;IN: HL = file name addr
 674+ 89CB              LoadProgram:
 675+ 89CB 22 DC 5C     	LD   (FSTR1), HL
 676+ 89CE 26 00        	LD   H, 0
 677+ 89D0 2E 0B        	LD   L, NAMELEN
 678+ 89D2 22 DA 5C     	LD   (NSTR1), HL
 679+ 89D5 3A 19 8A     	LD	 A, (RWTSDrive)
 680+ 89D8 3C           	INC  A					;Adapt for BASIC drive number
 681+ 89D9 6F           	LD   L, A
 682+ 89DA 22 D6 5C     	LD   (DSTR1), HL
 683+ 89DD 21 41 0A     	LD   HL, LOAD_ADDR
 684+ 89E0 CD C5 89     	CALL IF1Call
 685+ 89E3 C9           	RET
 686+ 89E4
 687+ 89E4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 688+ 89E4
 689+ 89E4              SetFastKeys:
 690+ 89E4 21 09 5C     	ld		hl, REPDEL
 691+ 89E7 11 0F 01     	ld		de, (1 << 8) | 15
 692+ 89EA 73 23 72 2B  	ld		(hl), de
 693+ 89EE
 694+ 89EE C9           	ret
 695+ 89EF
 696+ 89EF
 697+ 89EF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 89EF              ;Reads the error message string from IF1 ROM.
 699+ 89EF              GetErrMsg:
 700+ 89EF 3C           	inc		a
 701+ 89F0 08           	ex		af, af'
 702+ 89F1
 703+ 89F1 21 FA 89     	ld		hl, IF1Paged			;page-in IF1
 704+ 89F4 22 ED 5C     	ld		(HD11), hl
 705+ 89F7 CF           	rst		8
 706+ 89F8 32           	defb	50
 707+ 89F9 C9           	ret								;return after accesing IF1
 708+ 89FA
 709+ 89FA              IF1Paged:
 710+ 89FA 21 60 02     	ld		hl, ERRMSG
 711+ 89FD 08           	ex		af, af'
 712+ 89FE B7           	or		a
 713+ 89FF 28 0B        	jr		z, SaveMsg
 714+ 8A01
 715+ 8A01 06 00        	ld		b, 0
 716+ 8A03              SearchMsgEnd:
 717+ 8A03 CB 7E        	bit		7, (hl)
 718+ 8A05 23           	inc		hl
 719+ 8A06 28 FB        	jr		z, SearchMsgEnd
 720+ 8A08
 721+ 8A08 04           	inc		b
 722+ 8A09 B8           	cp		b
 723+ 8A0A 20 F7        	jr		nz, SearchMsgEnd
 724+ 8A0C
 725+ 8A0C              SaveMsg:
 726+ 8A0C 11 2A AF     	ld		de, DataBuf
 727+ 8A0F              CopyMsg:
 728+ 8A0F 7E           	ld		a, (hl)
 729+ 8A10 CB 7F        	bit		7, a
 730+ 8A12 12           	ld		(de), a
 731+ 8A13 23           	inc		hl
 732+ 8A14 13           	inc		de
 733+ 8A15 28 F8        	jr		z, CopyMsg
 734+ 8A17
 735+ 8A17 C9           	ret
 736+ 8A18
 737+ 8A18              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738+ 8A18
 739+ 8A18              ;RWTS routine I/O block
 740+ 8A18              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 741+ 8A18              RWTSParams:
 742+ 8A18 01           RWTSBlockType	DEFB	1							;?
 743+ 8A19 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 744+ 8A1A 00           RWTSVolNo		DEFB	0							;?
 745+ 8A1B 00           RWTSTrack		DEFB	0
 746+ 8A1C 00           RWTSSector		DEFB	0
 747+ 8A1D 00 00        RWTSDMA			DEFW	0
 748+ 8A1F 32 29        RWTSExtBuf		DEFW	$2932
 749+ 8A21 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 750+ 8A23 01           RWTSCmd			DEFB	RWTS_CMD_READ
 751+ 8A24              ;Results
 752+ 8A24 00           RWTSRes			DEFB	0
 753+ 8A25 00           RWTSResVolNo	DEFB	0
 754+ 8A26 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 754+ 8A2A 00
 755+ 8A2B
 756+ 8A2B              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 757+ 8A2B ~            /*
 758+ 8A2B ~            BasPrmTbl:
 759+ 8A2B ~            PrmDevType		DEFB	$01			;$01
 760+ 8A2B ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 761+ 8A2B ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 762+ 8A2B ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 763+ 8A2B ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 764+ 8A2B ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 765+ 8A2B ~            */
 766+ 8A2B
 767+ 8A2B              	endif
# file closed: disk.asm
1118  8A2B              	include "bdos.asm"
# file opened: bdos.asm
   1+ 8A2B              ;BDOS functions - similar to CP/M
   2+ 8A2B
   3+ 8A2B              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 8A2B              ;0 OK,
   5+ 8A2B              ;1 directory full,
   6+ 8A2B              ;2 disc full,
   7+ 8A2B              ;9 invalid FCB,
   8+ 8A2B              ;10(CP/M) media changed;
   9+ 8A2B              ;0FFh hardware error.
  10+ 8A2B
  11+ 8A2B              	ifndef	_BDOS_
  12+ 8A2B              	define	_BDOS_
  13+ 8A2B
  14+ 8A2B              	include "disk.asm"
# file opened: disk.asm
   1++8A2B              ;HC IF1 routines and constants
   2++8A2B
   3++8A2B              ;IF1 routines error codes, also returned by BASIC commands
   4++8A2B              ;12 = Writing to a 'read' file
   5++8A2B              ;13 = Reading a 'write' file
   6++8A2B              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++8A2B              ;15 = Disk full (disk or catalog full)
   8++8A2B              ;16 = Disk error (hardware error)
   9++8A2B              ;17 = File not found
  10++8A2B              ;23 = Disk R/O (disk change detected, software R/O)
  11++8A2B              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++8A2B
  13++8A2B              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++8A2B              ;00h = OK
  15++8A2B              ;08h = cannot format disk
  16++8A2B              ;10h = disk protected (read-only?)
  17++8A2B              ;20h = volume error
  18++8A2B              ;40h = drive error
  19++8A2B              ;80h = reading error
  20++8A2B              ;Codes I encountered:
  21++8A2B              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++8A2B
  23++8A2B
  24++8A2B              	ifndef	_DISK_
  25++8A2B ~            	define	_DISK_
  26++8A2B ~
  27++8A2B ~            	include	"math.asm"
  28++8A2B ~
  29++8A2B ~            DRIVE_CUR_BAS	EQU 0
  30++8A2B ~            DRIVE_A_BAS		EQU	1
  31++8A2B ~            DRIVE_B_BAS		EQU	2
  32++8A2B ~            DRIVE_A_CPM		EQU	0
  33++8A2B ~            DRIVE_B_CPM		EQU	1
  34++8A2B ~            ;Disk geometry stuff
  35++8A2B ~            SPT				EQU	16			;sectors per track
  36++8A2B ~            SECT_SZ			EQU	256			;sector size in bytes
  37++8A2B ~            TRACK_CNT		EQU	80			;track count
  38++8A2B ~            HEAD_CNT		EQU	2			;disk face count
  39++8A2B ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++8A2B ~            EXT_SZ			EQU	32			;directory entry size
  41++8A2B ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++8A2B ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++8A2B ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++8A2B ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++8A2B ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++8A2B ~            REC_SZ			EQU 128			;cp/m record size
  47++8A2B ~            DEL_MARKER		EQU	$E5
  48++8A2B ~            EOF_MARKER		EQU	$1B
  49++8A2B ~
  50++8A2B ~
  51++8A2B ~            ;Extension structure (directory entry)
  52++8A2B ~            EXT_DEL_FLAG	EQU	0
  53++8A2B ~            EXT_NAME		EQU 1
  54++8A2B ~            EXT_IDX			EQU 12
  55++8A2B ~            EXT_S1			EQU 13
  56++8A2B ~            EXT_S2			EQU 14
  57++8A2B ~            EXT_RC			EQU	15
  58++8A2B ~            EXT_AU0			EQU	16
  59++8A2B ~            EXT_AU1			EQU	18
  60++8A2B ~            EXT_AU2			EQU	20
  61++8A2B ~            EXT_AU3			EQU	22
  62++8A2B ~            EXT_AU4			EQU	24
  63++8A2B ~            EXT_AU5			EQU	26
  64++8A2B ~            EXT_AU6			EQU	28
  65++8A2B ~            EXT_AU7			EQU	30
  66++8A2B ~            EXT_SIZE		EQU 32
  67++8A2B ~
  68++8A2B ~            ;FCB structure
  69++8A2B ~            FCB_DRIVE		EQU 0
  70++8A2B ~            FCB_NAME		EQU EXT_NAME
  71++8A2B ~            FCB_EX_IDX		EQU EXT_IDX
  72++8A2B ~            FCB_S1			EQU EXT_S1
  73++8A2B ~            FCB_S2			EQU EXT_S2
  74++8A2B ~            FCB_RC			EQU	EXT_RC
  75++8A2B ~            FCB_AU			EQU	EXT_AU0
  76++8A2B ~            FCB_CR			EQU	32
  77++8A2B ~            FCB_R0			EQU 33
  78++8A2B ~            FCB_R1			EQU 34
  79++8A2B ~            FCB_R2			EQU 35
  80++8A2B ~            FCB_SIZE		EQU 36
  81++8A2B ~
  82++8A2B ~
  83++8A2B ~
  84++8A2B ~            ;System variables for disk
  85++8A2B ~            DSTR1			EQU	$5CD6		;drive
  86++8A2B ~            FSTR1			EQU	$5CDC		;file name
  87++8A2B ~            NSTR1			EQU	$5CDA		;name length
  88++8A2B ~            HD11			EQU	$5CED		;BDOS argument
  89++8A2B ~            COPIES			EQU	$5CEF		;BDOS function
  90++8A2B ~
  91++8A2B ~            ERRSP			EQU $5C3D
  92++8A2B ~            ERRNR			EQU $5C3A
  93++8A2B ~            ERRMSG			EQU	$0260
  94++8A2B ~
  95++8A2B ~            PRN_BUF			EQU	23296
  96++8A2B ~
  97++8A2B ~            ;STR_COPYRIGHT	EQU	$1539
  98++8A2B ~
  99++8A2B ~            REPDEL			EQU	23561
 100++8A2B ~            REPPER			EQU	23562
 101++8A2B ~            PIP				EQU	23609
 102++8A2B ~
 103++8A2B ~
 104++8A2B ~            ;RWTS routine commands
 105++8A2B ~            RWTS_CMD_POS	EQU	0			;position head
 106++8A2B ~            RWTS_CMD_READ	EQU	1			;read sector
 107++8A2B ~            RWTS_CMD_WRITE	EQU	2			;write sector
 108++8A2B ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 109++8A2B ~
 110++8A2B ~
 111++8A2B ~            ;File name stuff
 112++8A2B ~            NAMELEN			EQU	11			;name length
 113++8A2B ~            RO_POS			EQU	8			;read-only attribute position in name
 114++8A2B ~            SYS_POS			EQU	9			;system attribute position in name
 115++8A2B ~
 116++8A2B ~            ;File types (first byte in header)
 117++8A2B ~            PROG_TYPE		EQU	0			;program
 118++8A2B ~            NUMB_TYPE		EQU	1			;number array
 119++8A2B ~            CHAR_TYPE		EQU	2			;char array
 120++8A2B ~            BYTE_TYPE		EQU	3			;bytes
 121++8A2B ~            TEXT_TYPE		EQU	4			;text, >= 4
 122++8A2B ~
 123++8A2B ~            ;File header offsets
 124++8A2B ~            HDR_TYPE		EQU	0
 125++8A2B ~            HDR_LEN			EQU 1
 126++8A2B ~            HDR_ADDR		EQU 3
 127++8A2B ~            HDR_PLEN		EQU	5
 128++8A2B ~            HDR_LINE		EQU 7
 129++8A2B ~            HDR_SZ			EQU	9
 130++8A2B ~
 131++8A2B ~            ;BASIC disk channel structure
 132++8A2B ~            CH_RW_FLAG		EQU 11
 133++8A2B ~            CH_FCB			EQU	12
 134++8A2B ~            CH_DATA			EQU	50
 135++8A2B ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 136++8A2B ~
 137++8A2B ~            CACHE_NAME		EQU	0					;11B
 138++8A2B ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 139++8A2B ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 140++8A2B ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 141++8A2B ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 142++8A2B ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 143++8A2B ~
 144++8A2B ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 145++8A2B ~
 146++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147++8A2B ~            IF1Init:
 148++8A2B ~            	rst		08
 149++8A2B ~            	defb	49		;create system variables
 150++8A2B ~            	ret
 151++8A2B ~
 152++8A2B ~            ;ReadWriteTrackSector
 153++8A2B ~            ;A=command: 0, 1, 2, 4
 154++8A2B ~            RWTS:
 155++8A2B ~            	ld (RWTSCmd), a
 156++8A2B ~            	ld hl, RWTSParams
 157++8A2B ~            	ld (HD11), hl
 158++8A2B ~            	rst 08
 159++8A2B ~            	DEFB 58
 160++8A2B ~            	ret
 161++8A2B ~
 162++8A2B ~
 163++8A2B ~            ;D = sector, E = track
 164++8A2B ~            ;HL = dma
 165++8A2B ~            ReadOneDiskSector:
 166++8A2B ~            	ld (RWTSDMA), hl
 167++8A2B ~            	ld (RWTSTrack), de
 168++8A2B ~            	;ld (RWTSDrive), a
 169++8A2B ~            	ld a, RWTS_CMD_READ
 170++8A2B ~            	jr	RWTS
 171++8A2B ~
 172++8A2B ~            ;D = sector, E = track
 173++8A2B ~            ;HL = dma
 174++8A2B ~            WriteOneDiskSector:
 175++8A2B ~            	ld (RWTSDMA), hl
 176++8A2B ~            	ld (RWTSTrack), de
 177++8A2B ~            	;ld (RWTSDrive), a
 178++8A2B ~            	ld a, RWTS_CMD_WRITE
 179++8A2B ~            	jr	RWTS
 180++8A2B ~
 181++8A2B ~            FormatDisk:
 182++8A2B ~            	ld		hl, DataBuf
 183++8A2B ~            	ld		(hl), DEL_MARKER
 184++8A2B ~            	ld 		(RWTSDMA), hl
 185++8A2B ~            	ld 		a, RWTS_CMD_FMT
 186++8A2B ~            	call	RWTS
 187++8A2B ~            	ld		a, (RWTSRes)
 188++8A2B ~            	ret
 189++8A2B ~
 190++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 191++8A2B ~
 192++8A2B ~            ;Allocation unit no. to track/sector
 193++8A2B ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 194++8A2B ~            ;IN:  HL=alloc. unit no.
 195++8A2B ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 196++8A2B ~            AU2TS:
 197++8A2B ~            	ld c, SPT/SPAL
 198++8A2B ~            	call Div					;A = sector
 199++8A2B ~            	push af
 200++8A2B ~            		/*
 201++8A2B ~            		ld c, HEAD_CNT
 202++8A2B ~            		call Div				;L = track, A = head (0 or 1)
 203++8A2B ~            		*/
 204++8A2B ~            		xor a
 205++8A2B ~            		rr h
 206++8A2B ~            		rr l
 207++8A2B ~            		rr a
 208++8A2B ~
 209++8A2B ~            		ld c, l
 210++8A2B ~            		ld b, 0
 211++8A2B ~            		or a
 212++8A2B ~            		jr z, Track0
 213++8A2B ~            		ld b, SPT
 214++8A2B ~            Track0:
 215++8A2B ~            	pop af
 216++8A2B ~            	or a
 217++8A2B ~            	jr z, FirstAU
 218++8A2B ~            	ld a, SPAL
 219++8A2B ~            FirstAU:
 220++8A2B ~            	add a, b
 221++8A2B ~            	ld  b, a
 222++8A2B ~            	ret
 223++8A2B ~
 224++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 225++8A2B ~
 226++8A2B ~            ;Checks the allocation units number used in extension
 227++8A2B ~            ;IN:	IX = extension addr
 228++8A2B ~            ;OUT:	B = no. of allocation units used
 229++8A2B ~            ;		C = no. of records used in ext.
 230++8A2B ~            ;		HL = first alloc. unit no.
 231++8A2B ~            ;		DE = last alloc. unit no.
 232++8A2B ~            CheckExtAlloc:
 233++8A2B ~            	push ix
 234++8A2B ~            		ld bc, EXT_RC
 235++8A2B ~            		add ix, bc
 236++8A2B ~            		ld c, (ix)			;save rec. no.
 237++8A2B ~            		inc ix
 238++8A2B ~            		ld l, (ix)
 239++8A2B ~            		ld h, (ix + 1)
 240++8A2B ~            		ld b, EXT_AU_CNT
 241++8A2B ~            CheckAU:
 242++8A2B ~            		ld a, (ix)
 243++8A2B ~            		or (ix + 1)
 244++8A2B ~            		jr z, CheckAUEnd
 245++8A2B ~            		ld e, (ix)
 246++8A2B ~            		ld d, (ix + 1)
 247++8A2B ~            		inc ix
 248++8A2B ~            		inc ix
 249++8A2B ~            		djnz CheckAU
 250++8A2B ~            CheckAUEnd:
 251++8A2B ~            		ld a, EXT_AU_CNT
 252++8A2B ~            		sub b
 253++8A2B ~            		ld b, a
 254++8A2B ~            	pop ix
 255++8A2B ~            	ret
 256++8A2B ~
 257++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 258++8A2B ~
 259++8A2B ~            ;Input: TrackBuffer
 260++8A2B ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 261++8A2B ~            ReadUsedBlocksList:
 262++8A2B ~            	ld		ix, TrackBuf			;source buffer
 263++8A2B ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 264++8A2B ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 265++8A2B ~            	ld		de, 2					;counter of used blocks, start with 2
 266++8A2B ~            	ld		(hl), e
 267++8A2B ~            	inc		hl
 268++8A2B ~            	ld		(hl), d
 269++8A2B ~            	inc		hl
 270++8A2B ~
 271++8A2B ~            	;Add blocks 0 and 1 for directory
 272++8A2B ~            	ld		de, 0
 273++8A2B ~            	ld		(hl), e
 274++8A2B ~            	inc		hl
 275++8A2B ~            	ld		(hl), d
 276++8A2B ~            	inc		hl
 277++8A2B ~
 278++8A2B ~            	inc		de
 279++8A2B ~            	ld		(hl), e
 280++8A2B ~            	inc		hl
 281++8A2B ~            	ld		(hl), d
 282++8A2B ~            	inc		hl
 283++8A2B ~
 284++8A2B ~            ReadUsedBlocksLoop:
 285++8A2B ~            	xor		a
 286++8A2B ~            	cp		(ix)
 287++8A2B ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 288++8A2B ~
 289++8A2B ~            	push	ix
 290++8A2B ~            	push	bc
 291++8A2B ~            		ld		b, EXT_AU_CNT
 292++8A2B ~            		ld		de, EXT_AU0
 293++8A2B ~            		add		ix, de
 294++8A2B ~
 295++8A2B ~            ReadUsedBlocksLoop2:
 296++8A2B ~            		ld		e, (ix)
 297++8A2B ~            		ld		d, (ix+1)
 298++8A2B ~            		ld		a, e
 299++8A2B ~            		or		d
 300++8A2B ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 301++8A2B ~
 302++8A2B ~            		ld		(hl), e
 303++8A2B ~            		inc		hl
 304++8A2B ~            		ld		(hl), d
 305++8A2B ~            		inc		hl
 306++8A2B ~
 307++8A2B ~            		inc		ix
 308++8A2B ~            		inc		ix
 309++8A2B ~
 310++8A2B ~            		ld		de, (UsedBlockListCnt)
 311++8A2B ~            		inc		de
 312++8A2B ~            		ld		(UsedBlockListCnt), de
 313++8A2B ~
 314++8A2B ~            		djnz	ReadUsedBlocksLoop2
 315++8A2B ~
 316++8A2B ~
 317++8A2B ~            ReadUsedBlocksSkip:
 318++8A2B ~            	pop		bc
 319++8A2B ~            	pop		ix
 320++8A2B ~            ReadUsedBlocksSkip2:
 321++8A2B ~            	ld		de, EXT_SZ
 322++8A2B ~            	add		ix, de
 323++8A2B ~
 324++8A2B ~            	dec		bc
 325++8A2B ~            	ld		a, b
 326++8A2B ~            	or		c
 327++8A2B ~            	jr		nz, ReadUsedBlocksLoop
 328++8A2B ~
 329++8A2B ~            	ret
 330++8A2B ~
 331++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 332++8A2B ~            ;Reads 8 sectors for an AU
 333++8A2B ~            ;HL = block number, DE = destination buffer
 334++8A2B ~            ReadFSBlock:
 335++8A2B ~            	push	de
 336++8A2B ~            		call	AU2TS		;B=sector, C=track
 337++8A2B ~            	pop		hl				;HL=dest
 338++8A2B ~
 339++8A2B ~            	ld		d, b
 340++8A2B ~            	ld		e, c
 341++8A2B ~            	ld		b, SPAL
 342++8A2B ~
 343++8A2B ~            ReadFSBlockLoop:
 344++8A2B ~            	call	ReadDiskSectors
 345++8A2B ~            	ret
 346++8A2B ~
 347++8A2B ~
 348++8A2B ~            ;Write 8 sectors for an AU
 349++8A2B ~            ;HL = block number, DE = source buffer
 350++8A2B ~            WriteFSBlock:
 351++8A2B ~            	push	de
 352++8A2B ~            		call	AU2TS		;B=sector, C=track
 353++8A2B ~            	pop		hl				;HL=dest
 354++8A2B ~
 355++8A2B ~            	ld		d, b
 356++8A2B ~            	ld		e, c
 357++8A2B ~            	ld		b, SPAL
 358++8A2B ~
 359++8A2B ~            WriteFSBlockLoop:
 360++8A2B ~            	call	WriteDiskSectors
 361++8A2B ~            	ret
 362++8A2B ~
 363++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364++8A2B ~            ;Copies the allocated blocks from one disk to another.
 365++8A2B ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366++8A2B ~            CopyDisk:
 367++8A2B ~            	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 368++8A2B ~            	call	ReadUsedBlocksList
 369++8A2B ~            	ld		ix, UsedBlockListBlk
 370++8A2B ~
 371++8A2B ~            CopyDiskLoop:
 372++8A2B ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373++8A2B ~            	ld		de, MsgBlocksLeft
 374++8A2B ~            	call	Byte2Txt
 375++8A2B ~            	ld		hl, MsgBlocksLeft
 376++8A2B ~            	ld		de, LST_LINE_MSG + 1 << 8
 377++8A2B ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 378++8A2B ~            	call	PrintStrClr
 379++8A2B ~
 380++8A2B ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381++8A2B ~            	ld		hl, MAX_AU_RAM
 382++8A2B ~            	ld		bc, (UsedBlockListCnt)
 383++8A2B ~            	or		a
 384++8A2B ~            	sbc		hl, bc
 385++8A2B ~            	jr		nc, CopyDiskLoopRead
 386++8A2B ~            	ld		bc, MAX_AU_RAM
 387++8A2B ~
 388++8A2B ~            CopyDiskLoopRead:
 389++8A2B ~            	ld		b, c
 390++8A2B ~            	ld		de, CopyDiskBuf
 391++8A2B ~            	;save initial counter and initial block number array position
 392++8A2B ~            	push	bc
 393++8A2B ~            	push	ix
 394++8A2B ~
 395++8A2B ~            CopyDiskLoopReadLoop:
 396++8A2B ~            		ld		l, (ix)
 397++8A2B ~            		ld		h, (ix+1)
 398++8A2B ~            		inc		ix
 399++8A2B ~            		inc		ix
 400++8A2B ~
 401++8A2B ~            		push	de
 402++8A2B ~            		push	bc
 403++8A2B ~            			call	ReadFSBlock			;Stop on error or continue?
 404++8A2B ~            		pop		bc
 405++8A2B ~            		pop		de
 406++8A2B ~
 407++8A2B ~            		;+2048
 408++8A2B ~            		ld		a, d
 409++8A2B ~            		add		8
 410++8A2B ~            		ld		d, a
 411++8A2B ~
 412++8A2B ~            		djnz	CopyDiskLoopReadLoop
 413++8A2B ~
 414++8A2B ~            		;alternate drive
 415++8A2B ~            		ld		a, (RWTSDrive)
 416++8A2B ~            		xor		%11
 417++8A2B ~            		ld		(RWTSDrive), a
 418++8A2B ~
 419++8A2B ~            	;restore initial counter and initial block number array position
 420++8A2B ~            	pop		ix
 421++8A2B ~            	pop		bc
 422++8A2B ~            	ld		de, CopyDiskBuf
 423++8A2B ~            	push	bc
 424++8A2B ~
 425++8A2B ~            CopyDiskLoopWriteLoop:
 426++8A2B ~            		ld		l, (ix)
 427++8A2B ~            		ld		h, (ix+1)
 428++8A2B ~            		inc		ix
 429++8A2B ~            		inc		ix
 430++8A2B ~
 431++8A2B ~            		push	de
 432++8A2B ~            		push	bc
 433++8A2B ~            			call	WriteFSBlock		;Stop on error or continue?
 434++8A2B ~            		pop		bc
 435++8A2B ~            		pop		de
 436++8A2B ~
 437++8A2B ~            		;+2048
 438++8A2B ~            		ld		a, d
 439++8A2B ~            		add		8
 440++8A2B ~            		ld		d, a
 441++8A2B ~
 442++8A2B ~            		djnz	CopyDiskLoopWriteLoop
 443++8A2B ~
 444++8A2B ~            		;alternate drive again
 445++8A2B ~            		ld		a, (RWTSDrive)
 446++8A2B ~            		xor		%11
 447++8A2B ~            		ld		(RWTSDrive), a
 448++8A2B ~
 449++8A2B ~            	pop		bc
 450++8A2B ~            	ld		c, b
 451++8A2B ~            	ld		b, 0
 452++8A2B ~
 453++8A2B ~            	;Decrease number of blocks read by now.
 454++8A2B ~            	ld		hl, (UsedBlockListCnt)
 455++8A2B ~            	or		a
 456++8A2B ~            	sbc		hl, bc
 457++8A2B ~            	ld		(UsedBlockListCnt), hl
 458++8A2B ~
 459++8A2B ~            	ld		a, l
 460++8A2B ~            	or		h
 461++8A2B ~            	jp		nz, CopyDiskLoop
 462++8A2B ~
 463++8A2B ~            	ret
 464++8A2B ~
 465++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 466++8A2B ~
 467++8A2B ~            ;Compare string at HL with the one at DE, max length B
 468++8A2B ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 469++8A2B ~            ;OUT: z flag, set = match, reset = mismatch
 470++8A2B ~            StrCmp:
 471++8A2B ~            	push hl
 472++8A2B ~            	push de
 473++8A2B ~            Compare:
 474++8A2B ~            		ld a, (de)
 475++8A2B ~            		cp (hl)
 476++8A2B ~            		jr nz, MisMatch
 477++8A2B ~            		inc hl
 478++8A2B ~            		inc de
 479++8A2B ~            		djnz Compare
 480++8A2B ~            MisMatch:
 481++8A2B ~            	pop de
 482++8A2B ~            	pop hl
 483++8A2B ~            	ret
 484++8A2B ~
 485++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 486++8A2B ~
 487++8A2B ~            ;Read a file into a buffer, sector by sector.
 488++8A2B ~            ;It's relocatable, to moved and be used when loading a CODE block.
 489++8A2B ~            ;It's not using BDOS, but using similar calls provided by IF1.
 490++8A2B ~            ;In: HL = Name address, DE = buffer
 491++8A2B ~            IF1FileLoad:
 492++8A2B ~            	push	de
 493++8A2B ~            		ld (FSTR1), hl
 494++8A2B ~            		ld h, 0
 495++8A2B ~            		ld a, (RWTSDrive)
 496++8A2B ~            		inc  a			;CP/M drive number to BASIC drive number
 497++8A2B ~            		ld	l, a
 498++8A2B ~            		ld (DSTR1), hl
 499++8A2B ~            		ld l,NAMELEN
 500++8A2B ~            		ld (NSTR1), hl
 501++8A2B ~            		rst 08
 502++8A2B ~            		DEFB 51			;open disk channel
 503++8A2B ~
 504++8A2B ~            		rst		8
 505++8A2B ~            		defb	53		;read sector
 506++8A2B ~            	pop		de
 507++8A2B ~            	jr		nc, FileFree
 508++8A2B ~
 509++8A2B ~            	ld		a, (ix + CH_DATA)
 510++8A2B ~            	cp		TEXT_TYPE
 511++8A2B ~            	jr		nc, FileLoadNoHeader
 512++8A2B ~
 513++8A2B ~            FileLoadHeader:
 514++8A2B ~            	push	ix
 515++8A2B ~            	pop		hl
 516++8A2B ~            	ld		bc, CH_DATA + HDR_SZ
 517++8A2B ~            	add		hl, bc
 518++8A2B ~            	ld		bc, SECT_SZ - HDR_SZ
 519++8A2B ~            	ldir
 520++8A2B ~
 521++8A2B ~            FileReadLoop:
 522++8A2B ~            	push	de
 523++8A2B ~            		rst		8
 524++8A2B ~            		defb	53		;read sector
 525++8A2B ~            	pop		de
 526++8A2B ~            	jr		nc, FileFree
 527++8A2B ~
 528++8A2B ~            FileLoadNoHeader:
 529++8A2B ~            	push	ix
 530++8A2B ~            	pop		hl
 531++8A2B ~            	ld		bc, CH_DATA
 532++8A2B ~            	add		hl, bc
 533++8A2B ~            	ld		bc, SECT_SZ
 534++8A2B ~            	ldir
 535++8A2B ~            	jr		FileReadLoop
 536++8A2B ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 537++8A2B ~            IF1FileLoadEnd:
 538++8A2B ~
 539++8A2B ~            FileFree:
 540++8A2B ~            	push	de
 541++8A2B ~            	rst		8
 542++8A2B ~            	defb	56			;close channel (52) or detroy channel (56)
 543++8A2B ~            	pop		de
 544++8A2B ~            	ret
 545++8A2B ~
 546++8A2B ~
 547++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 548++8A2B ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 549++8A2B ~            ;Out: A = error code, 0=OK
 550++8A2B ~            ReadDiskSectors:
 551++8A2B ~            	push bc
 552++8A2B ~            		push hl
 553++8A2B ~            			push de
 554++8A2B ~            				call ReadOneDiskSector
 555++8A2B ~            			pop de
 556++8A2B ~            		pop hl
 557++8A2B ~
 558++8A2B ~            		inc d
 559++8A2B ~            		inc h
 560++8A2B ~            	pop bc
 561++8A2B ~
 562++8A2B ~            	ld	a, (RWTSRes)
 563++8A2B ~            	or	a
 564++8A2B ~            	ret nz
 565++8A2B ~
 566++8A2B ~            	djnz ReadDiskSectors
 567++8A2B ~            	ret
 568++8A2B ~
 569++8A2B ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 570++8A2B ~            ;Out: A = error code, 0=OK
 571++8A2B ~            WriteDiskSectors:
 572++8A2B ~            	push bc
 573++8A2B ~            		push hl
 574++8A2B ~            			push de
 575++8A2B ~            				call WriteOneDiskSector
 576++8A2B ~            			pop de
 577++8A2B ~            		pop hl
 578++8A2B ~
 579++8A2B ~            		inc d
 580++8A2B ~            		inc h
 581++8A2B ~            	pop bc
 582++8A2B ~
 583++8A2B ~            	ld	a, (RWTSRes)
 584++8A2B ~            	or	a
 585++8A2B ~            	ret nz
 586++8A2B ~
 587++8A2B ~            	djnz WriteDiskSectors
 588++8A2B ~            	ret
 589++8A2B ~
 590++8A2B ~
 591++8A2B ~            ;Reads disk catalog
 592++8A2B ~            ReadCatalogTrack:
 593++8A2B ~            	ld hl, TrackBuf
 594++8A2B ~            	ld de, 0
 595++8A2B ~            	ld b, SPT
 596++8A2B ~
 597++8A2B ~            	call ReadDiskSectors
 598++8A2B ~            	or   a
 599++8A2B ~            	ret  nz
 600++8A2B ~
 601++8A2B ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 602++8A2B ~            	push  af
 603++8A2B ~            		ld  a, (RWTSDrive)
 604++8A2B ~            		call BDOSSelectDisk
 605++8A2B ~            		call BDOSInit
 606++8A2B ~            	pop   af
 607++8A2B ~            	ret
 608++8A2B ~
 609++8A2B ~
 610++8A2B ~
 611++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612++8A2B ~
 613++8A2B ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 614++8A2B ~            FindCache:
 615++8A2B ~            	ld		b, NAMELEN
 616++8A2B ~            	call	StrCmp			;find the file to wich this extension belongs
 617++8A2B ~            	ret		z
 618++8A2B ~
 619++8A2B ~            	dec		c
 620++8A2B ~            	jr		nz, CacheNotFinished
 621++8A2B ~            	or		c
 622++8A2B ~            	ret
 623++8A2B ~
 624++8A2B ~            CacheNotFinished:
 625++8A2B ~            	ld		bc, CACHE_SZ
 626++8A2B ~            	add		hl, bc			;to the next cache line
 627++8A2B ~            	jr		FindCache
 628++8A2B ~
 629++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 630++8A2B ~
 631++8A2B ~            	;ld		ix, (SelFileCache)
 632++8A2B ~            ReadFileHeader:
 633++8A2B ~            	ld		a, (ix + CACHE_FLAG)
 634++8A2B ~            	or		a
 635++8A2B ~            	ret		nz				;return if already read
 636++8A2B ~
 637++8A2B ~            	ld		l, (ix + CACHE_FIRST_AU)
 638++8A2B ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 639++8A2B ~            	ld		a, h
 640++8A2B ~            	or		l
 641++8A2B ~            	jr		z, ReadHeaderEnd
 642++8A2B ~            	call	AU2TS
 643++8A2B ~            	ld		d, b
 644++8A2B ~            	ld		e, c
 645++8A2B ~            	ld		hl, DataBuf
 646++8A2B ~            	push	ix
 647++8A2B ~            	push	ix
 648++8A2B ~            		call	ReadOneDiskSector
 649++8A2B ~            	pop		hl
 650++8A2B ~            	pop		ix
 651++8A2B ~            	ld		bc, CACHE_HDR
 652++8A2B ~            	add		hl, bc
 653++8A2B ~            	ex		hl, de
 654++8A2B ~            	ld		hl, DataBuf
 655++8A2B ~            	ld		bc, HDR_SZ
 656++8A2B ~            	ldir
 657++8A2B ~            ReadHeaderEnd:
 658++8A2B ~            	inc		(ix + CACHE_FLAG)
 659++8A2B ~            	ret
 660++8A2B ~
 661++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 662++8A2B ~
 663++8A2B ~            ;IN: HL = address from IF1 to call
 664++8A2B ~            IF1Call:
 665++8A2B ~            	LD   (HD11), HL
 666++8A2B ~            	RST  8
 667++8A2B ~            	DEFB 50
 668++8A2B ~            	RET
 669++8A2B ~
 670++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 671++8A2B ~
 672++8A2B ~            ;Load a program from disk
 673++8A2B ~            ;IN: HL = file name addr
 674++8A2B ~            LoadProgram:
 675++8A2B ~            	LD   (FSTR1), HL
 676++8A2B ~            	LD   H, 0
 677++8A2B ~            	LD   L, NAMELEN
 678++8A2B ~            	LD   (NSTR1), HL
 679++8A2B ~            	LD	 A, (RWTSDrive)
 680++8A2B ~            	INC  A					;Adapt for BASIC drive number
 681++8A2B ~            	LD   L, A
 682++8A2B ~            	LD   (DSTR1), HL
 683++8A2B ~            	LD   HL, LOAD_ADDR
 684++8A2B ~            	CALL IF1Call
 685++8A2B ~            	RET
 686++8A2B ~
 687++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 688++8A2B ~
 689++8A2B ~            SetFastKeys:
 690++8A2B ~            	ld		hl, REPDEL
 691++8A2B ~            	ld		de, (1 << 8) | 15
 692++8A2B ~            	ld		(hl), de
 693++8A2B ~
 694++8A2B ~            	ret
 695++8A2B ~
 696++8A2B ~
 697++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++8A2B ~            ;Reads the error message string from IF1 ROM.
 699++8A2B ~            GetErrMsg:
 700++8A2B ~            	inc		a
 701++8A2B ~            	ex		af, af'
 702++8A2B ~
 703++8A2B ~            	ld		hl, IF1Paged			;page-in IF1
 704++8A2B ~            	ld		(HD11), hl
 705++8A2B ~            	rst		8
 706++8A2B ~            	defb	50
 707++8A2B ~            	ret								;return after accesing IF1
 708++8A2B ~
 709++8A2B ~            IF1Paged:
 710++8A2B ~            	ld		hl, ERRMSG
 711++8A2B ~            	ex		af, af'
 712++8A2B ~            	or		a
 713++8A2B ~            	jr		z, SaveMsg
 714++8A2B ~
 715++8A2B ~            	ld		b, 0
 716++8A2B ~            SearchMsgEnd:
 717++8A2B ~            	bit		7, (hl)
 718++8A2B ~            	inc		hl
 719++8A2B ~            	jr		z, SearchMsgEnd
 720++8A2B ~
 721++8A2B ~            	inc		b
 722++8A2B ~            	cp		b
 723++8A2B ~            	jr		nz, SearchMsgEnd
 724++8A2B ~
 725++8A2B ~            SaveMsg:
 726++8A2B ~            	ld		de, DataBuf
 727++8A2B ~            CopyMsg:
 728++8A2B ~            	ld		a, (hl)
 729++8A2B ~            	bit		7, a
 730++8A2B ~            	ld		(de), a
 731++8A2B ~            	inc		hl
 732++8A2B ~            	inc		de
 733++8A2B ~            	jr		z, CopyMsg
 734++8A2B ~
 735++8A2B ~            	ret
 736++8A2B ~
 737++8A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738++8A2B ~
 739++8A2B ~            ;RWTS routine I/O block
 740++8A2B ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 741++8A2B ~            RWTSParams:
 742++8A2B ~            RWTSBlockType	DEFB	1							;?
 743++8A2B ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 744++8A2B ~            RWTSVolNo		DEFB	0							;?
 745++8A2B ~            RWTSTrack		DEFB	0
 746++8A2B ~            RWTSSector		DEFB	0
 747++8A2B ~            RWTSDMA			DEFW	0
 748++8A2B ~            RWTSExtBuf		DEFW	$2932
 749++8A2B ~            RWTSPrmTbl		DEFW	$1f2a
 750++8A2B ~            RWTSCmd			DEFB	RWTS_CMD_READ
 751++8A2B ~            ;Results
 752++8A2B ~            RWTSRes			DEFB	0
 753++8A2B ~            RWTSResVolNo	DEFB	0
 754++8A2B ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 755++8A2B ~
 756++8A2B ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 757++8A2B ~            /*
 758++8A2B ~            BasPrmTbl:
 759++8A2B ~            PrmDevType		DEFB	$01			;$01
 760++8A2B ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 761++8A2B ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 762++8A2B ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 763++8A2B ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 764++8A2B ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 765++8A2B ~            */
 766++8A2B ~
 767++8A2B              	endif
# file closed: disk.asm
  15+ 8A2B
  16+ 8A2B              BDOSInit:
  17+ 8A2B AF           	xor		a
  18+ 8A2C 18 3D        	jr		BDOS
  19+ 8A2E
  20+ 8A2E
  21+ 8A2E              ;IN: A = Drive to select
  22+ 8A2E              BDOSSelectDisk:
  23+ 8A2E              	IFUSED
  24+ 8A2E DD 6F        	ld		ixl, a
  25+ 8A30 DD 26 00     	ld		ixh, 0
  26+ 8A33 3E 01        	ld		a, 1
  27+ 8A35 18 34        	jr		BDOS
  28+ 8A37              	ENDIF
  29+ 8A37
  30+ 8A37
  31+ 8A37              BDOSMakeDiskRO:
  32+ 8A37              	IFUSED
  33+ 8A37 ~            	ld		a, 15
  34+ 8A37 ~            	jr		BDOS
  35+ 8A37              	ENDIF
  36+ 8A37
  37+ 8A37              ;Get Read Only flag
  38+ 8A37              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 8A37              BDOSGetDiskRO:
  40+ 8A37              	IFUSED
  41+ 8A37 ~            	ld	a, 16
  42+ 8A37 ~            	jr	BDOS
  43+ 8A37              	ENDIF
  44+ 8A37
  45+ 8A37              BDOSGetCurrentDisk:
  46+ 8A37              	IFUSED
  47+ 8A37 ~            	ld		a, 12
  48+ 8A37 ~            	jr		BDOS
  49+ 8A37              	ENDIF
  50+ 8A37
  51+ 8A37
  52+ 8A37              ;Create a disk channel for BDOS access (does not open the file)
  53+ 8A37              ;IN: HL=name addr, A=drive
  54+ 8A37              ;OUT: IX=FCB
  55+ 8A37              CreateChannel:
  56+ 8A37 22 DC 5C     	ld (FSTR1), hl
  57+ 8A3A 26 00        	ld h,0
  58+ 8A3C 6F           	ld l,a
  59+ 8A3D 22 D6 5C     	ld (DSTR1), hl
  60+ 8A40 2E 0B        	ld l,NAMELEN
  61+ 8A42 22 DA 5C     	ld (NSTR1), hl
  62+ 8A45 CF           	rst 08
  63+ 8A46 37           	DEFB 55
  64+ 8A47 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 8A4A DD 09        	add ix, bc
  66+ 8A4C C9           	ret
  67+ 8A4D
  68+ 8A4D
  69+ 8A4D              ;Destroy a BDOS channel
  70+ 8A4D              ;IN: IX=FCB
  71+ 8A4D              DestroyChannel:
  72+ 8A4D C5           	push bc
  73+ 8A4E 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 8A51 DD 09        	add ix, bc
  75+ 8A53 CF           	rst 08
  76+ 8A54 38           	DEFB 56
  77+ 8A55 C1           	pop bc
  78+ 8A56 C9           	ret
  79+ 8A57
  80+ 8A57
  81+ 8A57              ;Input: IX=FCB
  82+ 8A57              CreateFile:
  83+ 8A57 3E 09        	ld	a, 9
  84+ 8A59 18 10        	jr	BDOS
  85+ 8A5B
  86+ 8A5B              ;Input: IX=FCB
  87+ 8A5B              OpenFile:
  88+ 8A5B 3E 02        	ld	a, 2
  89+ 8A5D 18 0C        	jr	BDOS
  90+ 8A5F
  91+ 8A5F              ;IN: IX=FCB
  92+ 8A5F              CloseFile:
  93+ 8A5F 3E 03        	ld	a, 3
  94+ 8A61 18 08        	jr	BDOS
  95+ 8A63
  96+ 8A63              ;IN: IX=FCB
  97+ 8A63              ReadFileBlock:
  98+ 8A63 3E 07        	ld	a, 7
  99+ 8A65 18 04        	jr	BDOS
 100+ 8A67
 101+ 8A67              ;IN: IX=FCB
 102+ 8A67              WriteFileBlock:
 103+ 8A67 3E 08        	ld	a, 8
 104+ 8A69 18 00        	jr	BDOS
 105+ 8A6B
 106+ 8A6B              ;Generic BDOS call
 107+ 8A6B              ;IX=arg, A=function
 108+ 8A6B              BDOS:
 109+ 8A6B DD 22 ED 5C  	ld (HD11), ix
 110+ 8A6F 32 EF 5C     	ld (COPIES), a
 111+ 8A72 CF           	rst 08
 112+ 8A73 39           	DEFB 57
 113+ 8A74 C9           	ret
 114+ 8A75
 115+ 8A75              ;FindFirst
 116+ 8A75              ;IX=fcb
 117+ 8A75              BDOSFindFirst:
 118+ 8A75              	IFUSED
 119+ 8A75 ~            	ld a, 4
 120+ 8A75 ~            	jr BDOS
 121+ 8A75              	ENDIF
 122+ 8A75
 123+ 8A75              ;FindNext
 124+ 8A75              ;IX=fcb
 125+ 8A75              BDOSFindNext:
 126+ 8A75              	IFUSED
 127+ 8A75 ~            	ld a, 5
 128+ 8A75 ~            	jr BDOS
 129+ 8A75              	ENDIF
 130+ 8A75
 131+ 8A75
 132+ 8A75              ;Set DMA address for BDOS
 133+ 8A75              ;IX=DMA
 134+ 8A75              BDOSSetDMA:
 135+ 8A75 3E 0D        	ld a, 13
 136+ 8A77 18 F2        	jr BDOS
 137+ 8A79
 138+ 8A79              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 139+ 8A79              ;HL=file name, A=drive
 140+ 8A79              DeleteFile:
 141+ 8A79 CD 37 8A     	call	CreateChannel
 142+ 8A7C
 143+ 8A7C 3E 06        	ld		a, 6
 144+ 8A7E CD 6B 8A     	call	BDOS
 145+ 8A81
 146+ 8A81 CD 4D 8A     	call	DestroyChannel
 147+ 8A84 C9           	ret
 148+ 8A85
 149+ 8A85              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 150+ 8A85              ;IN: E0 = RO, E1 = SYS, HL=filename
 151+ 8A85              ChangeFileAttrib:
 152+ 8A85 3A 19 8A     	ld 		a, (RWTSDrive)
 153+ 8A88 3C           	inc		a					;Convert to BASIC drive number: 1,2
 154+ 8A89 D5           	push	de
 155+ 8A8A CD 37 8A     	call	CreateChannel
 156+ 8A8D D1           	pop		de
 157+ 8A8E
 158+ 8A8E DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 159+ 8A91 CB 27        	sla		a								;reset existing attribute flag
 160+ 8A93 CB 1B        	rr		e								;put wanted flag in Carry flag
 161+ 8A95 CB 1F        	rr		a								;put Carry flag in register L
 162+ 8A97 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 163+ 8A9A
 164+ 8A9A DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 165+ 8A9D CB 27        	sla		a
 166+ 8A9F CB 1B        	rr		e
 167+ 8AA1 CB 1F        	rr		a
 168+ 8AA3 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 169+ 8AA6
 170+ 8AA6              FileAttribSet:
 171+ 8AA6 3E 11        	ld		a, 17
 172+ 8AA8 CD 6B 8A     	call	BDOS
 173+ 8AAB
 174+ 8AAB CD 4D 8A     	call	DestroyChannel
 175+ 8AAE C9           	ret
 176+ 8AAF
 177+ 8AAF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 178+ 8AAF
 179+ 8AAF              ;HL=original name, DE = new name
 180+ 8AAF              ;Works only on the same drive.
 181+ 8AAF              RenameFile:
 182+ 8AAF 3A 19 8A     	ld 		a, (RWTSDrive)
 183+ 8AB2 3C           	inc		a					;Convert to BASIC drive number: 1,2
 184+ 8AB3 D5           	push	de
 185+ 8AB4 CD 37 8A     	call	CreateChannel
 186+ 8AB7 D1           	pop		de
 187+ 8AB8
 188+ 8AB8 DD E5        	push	ix					;IX == FCB
 189+ 8ABA E1           	pop		hl
 190+ 8ABB 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 191+ 8ABE 09           	add		hl, bc
 192+ 8ABF EB           	ex		de, hl
 193+ 8AC0 3A 19 8A     	ld		a, (RWTSDrive)
 194+ 8AC3 12           	ld		(de), a
 195+ 8AC4 01 0B 00     	ld		bc, NAMELEN
 196+ 8AC7 ED B0        	ldir
 197+ 8AC9
 198+ 8AC9 3E 0A        	ld		a, 10
 199+ 8ACB CD 6B 8A     	call	BDOS
 200+ 8ACE
 201+ 8ACE CD 4D 8A     	call	DestroyChannel
 202+ 8AD1 C9           	ret
 203+ 8AD2
 204+ 8AD2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205+ 8AD2
 206+ 8AD2              ;Will copy a file from A: to B: or vice versa.
 207+ 8AD2              ;HL=source file name
 208+ 8AD2              CopyFile:
 209+ 8AD2              	;Prepare source file
 210+ 8AD2 E5           	push hl
 211+ 8AD3 3A 19 8A     		ld 		a, (RWTSDrive)
 212+ 8AD6 3C           		inc		a					;Convert to BASIC drive number: 1,2
 213+ 8AD7 CD 37 8A     		call	CreateChannel
 214+ 8ADA CD 5B 8A     		call 	OpenFile
 215+ 8ADD DD 22 2A AF  		ld		(CopyFileFCBSrc), ix
 216+ 8AE1 E1           	pop hl
 217+ 8AE2 3C           	inc  	a						;Cancel if A==$FF
 218+ 8AE3 28 73        	jr   	z, CopyFileEnd
 219+ 8AE5
 220+ 8AE5              	;Create destination file
 221+ 8AE5 DD 7E 00     	ld		a, (ix)
 222+ 8AE8 EE 03        	xor		%11						;Alternate drive, A->B, B-A
 223+ 8AEA F5           	push	af
 224+ 8AEB E5           	push	hl
 225+ 8AEC CD 79 8A     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 226+ 8AEF E1           	pop		hl
 227+ 8AF0 F1           	pop		af
 228+ 8AF1 CD 37 8A     	call	CreateChannel
 229+ 8AF4 CD 57 8A     	call 	CreateFile
 230+ 8AF7 DD 22 2C AF  	ld		(CopyFileFCBDst), ix
 231+ 8AFB 3C           	inc  	a						;Cancel if A==$FF
 232+ 8AFC 28 5A        	jr   	z, CopyFileEnd
 233+ 8AFE
 234+ 8AFE              FileCopyLoop:
 235+ 8AFE 06 3C        	ld		b, MAX_SECT_RAM
 236+ 8B00 DD 21 30 AF  	ld		ix, CopyFileDMAAddr
 237+ 8B04 DD 36 00 E1  	ld		(ix), CopyFileDMA % $FF
 238+ 8B08 DD 36 01 AF  	ld		(ix+1), CopyFileDMA / $FF
 239+ 8B0C              FileCopyReadLoop:
 240+ 8B0C C5           	push	bc
 241+ 8B0D DD 2A 30 AF  		ld		ix, (CopyFileDMAAddr)
 242+ 8B11 CD 75 8A     		call 	BDOSSetDMA
 243+ 8B14 DD 24        		inc		ixh
 244+ 8B16 DD 22 30 AF  		ld		(CopyFileDMAAddr), ix
 245+ 8B1A
 246+ 8B1A DD 2A 2A AF  		ld		ix, (CopyFileFCBSrc)
 247+ 8B1E CD 63 8A     		call 	ReadFileBlock
 248+ 8B21 B7           		or		a
 249+ 8B22 32 2E AF     		ld		(CopyFileResRead), a
 250+ 8B25 C1           	pop		bc
 251+ 8B26 20 02        	jr		nz, FileCopyWrite
 252+ 8B28 10 E2        	djnz	FileCopyReadLoop
 253+ 8B2A
 254+ 8B2A              FileCopyWrite:
 255+ 8B2A DD 21 30 AF  	ld		ix, CopyFileDMAAddr
 256+ 8B2E DD 36 00 E1  	ld		(ix), CopyFileDMA % $FF
 257+ 8B32 DD 36 01 AF  	ld		(ix+1), CopyFileDMA / $FF
 258+ 8B36
 259+ 8B36              	;Calculate how many sectors were read.
 260+ 8B36 3E 3C        	ld		a, MAX_SECT_RAM
 261+ 8B38 90           	sub		b
 262+ 8B39 47           	ld		b, a
 263+ 8B3A
 264+ 8B3A              FileCopyWriteLoop:
 265+ 8B3A C5           	push	bc
 266+ 8B3B DD 2A 30 AF  		ld		ix, (CopyFileDMAAddr)
 267+ 8B3F CD 75 8A     		call 	BDOSSetDMA
 268+ 8B42 DD 24        		inc		ixh
 269+ 8B44 DD 22 30 AF  		ld		(CopyFileDMAAddr), ix
 270+ 8B48
 271+ 8B48 DD 2A 2C AF  		ld		ix, (CopyFileFCBDst)
 272+ 8B4C CD 67 8A     		call	WriteFileBlock
 273+ 8B4F B7           		or		a
 274+ 8B50 32 2F AF     		ld		(CopyFileResWrite), a
 275+ 8B53 C1           	pop		bc
 276+ 8B54 20 02        	jr		nz, CopyFileEnd
 277+ 8B56 10 E2        	djnz	FileCopyWriteLoop
 278+ 8B58
 279+ 8B58              CopyFileEnd:
 280+ 8B58              	;Check if copy loop was stopped because buffer ran out, continue copy in that case. Otherwise, it's file end.
 281+ 8B58 3A 2E AF     	ld		a, (CopyFileResRead)
 282+ 8B5B B7           	or		a
 283+ 8B5C 28 A0        	jr		z, FileCopyLoop
 284+ 8B5E
 285+ 8B5E DD 2A 2C AF  	ld		ix, (CopyFileFCBDst)
 286+ 8B62 CD 5F 8A     	call 	CloseFile				;close destination file
 287+ 8B65 CD 4D 8A     	call 	DestroyChannel
 288+ 8B68
 289+ 8B68              	;Don't need to close source file, but must free channel
 290+ 8B68 DD 2A 2A AF  	ld		ix, (CopyFileFCBSrc)
 291+ 8B6C CD 4D 8A     	call 	DestroyChannel
 292+ 8B6F
 293+ 8B6F 3A 2F AF     	ld		a, (CopyFileResWrite)
 294+ 8B72
 295+ 8B72 C9           	ret
 296+ 8B73
 297+ 8B73              	endif
 298+ 8B73
# file closed: bdos.asm
1119  8B73              	include "ui.asm"
# file opened: ui.asm
   1+ 8B73              ;UI related functions
   2+ 8B73
   3+ 8B73              	ifndef	_UI_
   4+ 8B73              	define	_UI_
   5+ 8B73
   6+ 8B73              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++8B73              	ifndef	_HCCFG_
   2++8B73 ~            	define	_HCCFG_
   3++8B73 ~
   4++8B73 ~            ;HC specific code, for configuration
   5++8B73 ~
   6++8B73 ~            HC_CFG_PORT			EQU	$7E
   7++8B73 ~
   8++8B73 ~            ;BASIC/CPM ROM selection
   9++8B73 ~            HC_CFG_ROM_BAS		EQU	%0
  10++8B73 ~            HC_CFG_ROM_CPM		EQU	%1
  11++8B73 ~
  12++8B73 ~            ;Address for ROM paging: 0 or $E000
  13++8B73 ~            HC_CFG_ROM_0000		EQU %00
  14++8B73 ~            HC_CFG_ROM_E000		EQU %10
  15++8B73 ~
  16++8B73 ~            ;Cfg. port Enable/Disable
  17++8B73 ~            HC_CFG_PORT_DIS		EQU %000
  18++8B73 ~            HC_CFG_PORT_EN		EQU	%100
  19++8B73 ~
  20++8B73 ~            ;Video memory bank: $4000 or $C000
  21++8B73 ~            HC_CFG_VID_4000		EQU	%0000
  22++8B73 ~            HC_CFG_VID_C000		EQU	%1000
  23++8B73 ~
  24++8B73 ~
  25++8B73 ~            ;Standar BASIC config
  26++8B73 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++8B73 ~            ;Standar CP/M config
  28++8B73 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++8B73 ~
  30++8B73 ~
  31++8B73 ~            HC_VID_BANK0		EQU	$4000
  32++8B73 ~            HC_VID_BANK1		EQU	$C000
  33++8B73 ~
  34++8B73              	endif
# file closed: hccfg.asm
   7+ 8B73
   8+ 8B73              COL             EQU 23728
   9+ 8B73              LINE            EQU 23729               ;Coordinates
  10+ 8B73              LineCol			EQU	COL
  11+ 8B73              CODE			EQU 23681               ;Char to print
  12+ 8B73
  13+ 8B73              CPM_FNT         EQU $25AB
  14+ 8B73
  15+ 8B73              PORT_ZX			EQU	$FE
  16+ 8B73
  17+ 8B73              ;COLORS
  18+ 8B73              CLR_BLACK		EQU 0
  19+ 8B73              CLR_BLUE		EQU 1
  20+ 8B73              CLR_RED			EQU 2
  21+ 8B73              CLR_MAGENTA		EQU 3
  22+ 8B73              CLR_GREEN		EQU 4
  23+ 8B73              CLR_CYAN		EQU	5
  24+ 8B73              CLR_YELLOW		EQU	6
  25+ 8B73              CLR_WHITE		EQU	7
  26+ 8B73              CLR_BRIGHT		EQU	%01000000
  27+ 8B73              CLR_FLASH		EQU	%10000000
  28+ 8B73
  29+ 8B73              ;PAPER
  30+ 8B73              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 8B73              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 8B73              PAPER_RED		EQU (CLR_RED << 3)
  33+ 8B73              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 8B73              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 8B73              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 8B73              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 8B73              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 8B73
  39+ 8B73              ;INK
  40+ 8B73              INK_BLACK		EQU CLR_BLACK
  41+ 8B73              INK_BLUE		EQU CLR_BLUE
  42+ 8B73              INK_RED			EQU CLR_RED
  43+ 8B73              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 8B73              INK_GREEN		EQU CLR_GREEN
  45+ 8B73              INK_CYAN		EQU	CLR_CYAN
  46+ 8B73              INK_YELLOW		EQU	CLR_YELLOW
  47+ 8B73              INK_WHITE		EQU	CLR_WHITE
  48+ 8B73
  49+ 8B73
  50+ 8B73              ;SCR_ATTR_ADDR	EQU 22528
  51+ 8B73              SCR_PIX_LEN		EQU	6144
  52+ 8B73              SCR_ATTR_LEN	EQU	768
  53+ 8B73              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 8B73              SCR_BYTES_PER_LINE	EQU	32
  55+ 8B73
  56+ 8B73              SCR_COLS		EQU	64
  57+ 8B73              SCR_LINES		EQU 24
  58+ 8B73
  59+ 8B73              ;used for file names list positioning
  60+ 8B73              LST_LINES_CNT	EQU	23
  61+ 8B73              LST_FIRST_LINE	EQU	0
  62+ 8B73              LST_DISK_INFO	EQU 3
  63+ 8B73              LST_FILE_INFO	EQU 7
  64+ 8B73              LST_LINE_MSG	EQU 13
  65+ 8B73              LST_FIRST_COL	EQU	16
  66+ 8B73              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  67+ 8B73
  68+ 8B73              ;key codes
  69+ 8B73              KEY_ESC			EQU	7
  70+ 8B73              KEY_LEFT		EQU	8
  71+ 8B73              KEY_RIGHT		EQU	9
  72+ 8B73              KEY_DOWN		EQU	10
  73+ 8B73              KEY_UP			EQU	11
  74+ 8B73              KEY_BACKSP		EQU 12
  75+ 8B73              KEY_ENTER		EQU	13
  76+ 8B73              KEY_CTRL		EQU	14
  77+ 8B73
  78+ 8B73              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  79+ 8B73              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  80+ 8B73              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  81+ 8B73
  82+ 8B73              ;Special formating chars
  83+ 8B73              CHR_CR			EQU	13
  84+ 8B73              CHR_LF			EQU	10
  85+ 8B73              CHR_TAB			EQU	09
  86+ 8B73              CHR_EOF			EQU $1A
  87+ 8B73
  88+ 8B73
  89+ 8B73              ;Semi-graphical chars
  90+ 8B73              ;           UC
  91+ 8B73              ;     UL +H-+--+UR
  92+ 8B73              ;        |  |  |
  93+ 8B73              ;     ML +--+--+MR
  94+ 8B73              ;        V C|  |
  95+ 8B73              ;     LL +--+--+LR
  96+ 8B73              ;           DC
  97+ 8B73              CHR_GRID        EQU 127
  98+ 8B73              CHR_V           EQU	128
  99+ 8B73              CHR_MR          EQU	129
 100+ 8B73              CHR_UR          EQU 130
 101+ 8B73              CHR_DL          EQU 131
 102+ 8B73              CHR_DC          EQU 132
 103+ 8B73              CHR_UC          EQU 133
 104+ 8B73              CHR_ML          EQU 134
 105+ 8B73              CHR_H           EQU 135
 106+ 8B73              CHR_C           EQU 136
 107+ 8B73              CHR_LR          EQU 137
 108+ 8B73              CHR_UL          EQU 138
 109+ 8B73              CHR_FULL        EQU 139
 110+ 8B73              CHR_HALF        EQU 140
 111+ 8B73
 112+ 8B73              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 113+ 8B73
 114+ 8B73              ;Return read char in A
 115+ 8B73              ReadChar:
 116+ 8B73 CF           	rst 08
 117+ 8B74 1B           	DEFB 27
 118+ 8B75 C9           	ret
 119+ 8B76
 120+ 8B76              ;Checks if a key is pressed
 121+ 8B76              ;Cy=1 if key is pressed
 122+ 8B76              KbdHit:
 123+ 8B76 CF           	rst 08
 124+ 8B77 20           	DEFB 32
 125+ 8B78 C9           	ret
 126+ 8B79              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 127+ 8B79
 128+ 8B79              	ifdef _ROM_FNT_
 129+ 8B79 ~            InitFonts:
 130+ 8B79 ~                ;page-in CPM ROM to get fonts
 131+ 8B79 ~                di
 132+ 8B79 ~                ld a, HC_CFG_ROM_CPM
 133+ 8B79 ~                out	(HC_CFG_PORT), a
 134+ 8B79 ~
 135+ 8B79 ~            	ld		hl, CPM_FNT
 136+ 8B79 ~            	ld		de, FontTable
 137+ 8B79 ~            	ld		bc, 872
 138+ 8B79 ~            	ldir
 139+ 8B79 ~
 140+ 8B79 ~                ;restore BASIC ROM
 141+ 8B79 ~                ld a, HC_CFG_ROM_BAS
 142+ 8B79 ~                out	(HC_CFG_PORT), a
 143+ 8B79 ~                ei
 144+ 8B79 ~
 145+ 8B79 ~            	ret
 146+ 8B79              	endif
 147+ 8B79
 148+ 8B79              ClrScr:
 149+ 8B79 2A 1C 8D     	ld		hl, (CurrScrAddr)
 150+ 8B7C 54           	ld		d, h
 151+ 8B7D 5D           	ld		e, l
 152+ 8B7E 13           	inc		de
 153+ 8B7F 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 154+ 8B82 36 00        	ld		(hl), 0
 155+ 8B84 ED B0        	ldir
 156+ 8B86
 157+ 8B86 23           	inc 	hl
 158+ 8B87 13           	inc		de
 159+ 8B88
 160+ 8B88 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 161+ 8B8B 36 0F        	ld		(hl), SCR_DEF_CLR
 162+ 8B8D ED B0        	ldir
 163+ 8B8F
 164+ 8B8F              	;also set border color
 165+ 8B8F 3E 01        	ld		a, SCR_DEF_CLR >> 3
 166+ 8B91 D3 FE        	out		(PORT_ZX), a
 167+ 8B93
 168+ 8B93 3E 0F        	ld		a, SCR_DEF_CLR
 169+ 8B95 32 48 5C     	ld		(23624), a
 170+ 8B98 C9           	ret
 171+ 8B99
 172+ 8B99              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 173+ 8B99              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 174+ 8B99              PrintStr:
 175+ 8B99 7E           	ld		a, (hl)
 176+ 8B9A FE 20        	cp		' '
 177+ 8B9C 30 02        	jr		nc, GoodChar
 178+ 8B9E 3E 3F        	ld		a, '?'
 179+ 8BA0              GoodChar:
 180+ 8BA0 CB 7F        	bit		7, a
 181+ 8BA2 CB BF        	res		7, a
 182+ 8BA4 32 81 5C     	ld		(CODE), a
 183+ 8BA7 ED 53 B0 5C  	ld		(LineCol), de
 184+ 8BAB 08           	ex		af, af'
 185+ 8BAC D9           	exx
 186+ 8BAD E5           	push	hl
 187+ 8BAE CD 9C 8C     	call 	PrintChar
 188+ 8BB1 E1           	pop		hl
 189+ 8BB2 D9           	exx
 190+ 8BB3 08           	ex		af, af'
 191+ 8BB4 C0           	ret		nz
 192+ 8BB5
 193+ 8BB5 1C           	inc		e
 194+ 8BB6 23           	inc		hl
 195+ 8BB7
 196+ 8BB7 7B           	ld		a, e
 197+ 8BB8 FE 40        	cp		64
 198+ 8BBA 38 DD        	jr		c, PrintStr
 199+ 8BBC 1E 00        	ld		e, 0
 200+ 8BBE 14           	inc		d
 201+ 8BBF
 202+ 8BBF 18 D8        	jr		PrintStr
 203+ 8BC1
 204+ 8BC1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205+ 8BC1
 206+ 8BC1              ;IN: HL = string, DE = coords, A = color
 207+ 8BC1              PrintStrClr:
 208+ 8BC1 32 ED 8B     	ld		(StrClr), a
 209+ 8BC4 D5           	push	de
 210+ 8BC5 CD 99 8B     		call	PrintStr
 211+ 8BC8 E1           	pop		hl
 212+ 8BC9              	;get string len.
 213+ 8BC9 7B           	ld		a, e
 214+ 8BCA 95           	sub		l
 215+ 8BCB 1F           	rra
 216+ 8BCC 08           	ex		af, af'
 217+ 8BCD              		;line * 32
 218+ 8BCD 7C           		ld		a, h
 219+ 8BCE 17           		rla
 220+ 8BCF 17           		rla
 221+ 8BD0 11 00 00     		ld	de, 0
 222+ 8BD3 17           		rla
 223+ 8BD4 CB 12        		rl	d
 224+ 8BD6 17           		rla
 225+ 8BD7 CB 12        		rl	d
 226+ 8BD9 17           		rla
 227+ 8BDA CB 12        		rl	d
 228+ 8BDC 5F           		ld	e, a
 229+ 8BDD
 230+ 8BDD 26 00        		ld		h, 0
 231+ 8BDF 19           		add		hl, de
 232+ 8BE0 ED 5B 1E 8D  		ld		de, (CurrScrAttrAddr)
 233+ 8BE4 19           		add		hl, de
 234+ 8BE5 08           	ex		af, af'
 235+ 8BE6 4F           	ld		c, a
 236+ 8BE7 06 00        	ld		b, 0
 237+ 8BE9 54           	ld		d, h
 238+ 8BEA 5D           	ld		e, l
 239+ 8BEB 13           	inc 	de
 240+ 8BEC              StrClr	EQU	$ + 1
 241+ 8BEC 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 242+ 8BEE ED B0        	ldir
 243+ 8BF0 C9           	ret
 244+ 8BF1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 8BF1
 246+ 8BF1              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 247+ 8BF1              DrawLine:
 248+ 8BF1 32 81 5C     	ld		(CODE), a
 249+ 8BF4
 250+ 8BF4 38 04        	jr		c, VertDir
 251+ 8BF6 3E 1C        	ld		a, $1C
 252+ 8BF8 18 02        	jr		StoreDir
 253+ 8BFA              VertDir:
 254+ 8BFA 3E 14        	ld		a, $14
 255+ 8BFC              StoreDir:
 256+ 8BFC 32 0C 8C     	ld		(LineDir), a
 257+ 8BFF
 258+ 8BFF              DrawLineLoop:
 259+ 8BFF ED 53 B0 5C  	ld		(LineCol), de
 260+ 8C03 D5           	push	de
 261+ 8C04 D9           		exx
 262+ 8C05 E5           		push	hl
 263+ 8C06 CD 9C 8C     		call 	PrintChar
 264+ 8C09 E1           		pop		hl
 265+ 8C0A D9           		exx
 266+ 8C0B D1           	pop		de
 267+ 8C0C              LineDir:
 268+ 8C0C 1C           	inc		e
 269+ 8C0D 10 F0        	djnz	DrawLineLoop
 270+ 8C0F
 271+ 8C0F C9           	ret
 272+ 8C10
 273+ 8C10              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 274+ 8C10
 275+ 8C10              DrawHLine:
 276+ 8C10 32 1F 8C     	ld		(ChrParam), a
 277+ 8C13
 278+ 8C13 06 10        	ld		b, 16
 279+ 8C15 3E 87        	ld		a, CHR_H
 280+ 8C17 B7           	or		a
 281+ 8C18 CD F1 8B     	call	DrawLine
 282+ 8C1B
 283+ 8C1B 06 04        	ld		b, 4
 284+ 8C1D              DrawUpLine:
 285+ 8C1D C5           	push	bc
 286+ 8C1E              ChrParam	EQU		$ + 1
 287+ 8C1E 3E 85        		ld		a, CHR_UC
 288+ 8C20 D5           		push	de
 289+ 8C21 CD 52 8C     			call	PrintChar2
 290+ 8C24 D1           		pop		de
 291+ 8C25 13           		inc		de
 292+ 8C26
 293+ 8C26 06 0B        		ld		b, NAMELEN
 294+ 8C28 3E 87        		ld		a, CHR_H
 295+ 8C2A B7           		or		a
 296+ 8C2B CD F1 8B     		call	DrawLine
 297+ 8C2E C1           	pop		bc
 298+ 8C2F 10 EC        	djnz	DrawUpLine
 299+ 8C31
 300+ 8C31 06 04        	ld		b, 4
 301+ 8C33 3E 87        	ld		a, CHR_H
 302+ 8C35 B7           	or		a
 303+ 8C36 CD F1 8B     	call	DrawLine
 304+ 8C39 C9           	ret
 305+ 8C3A
 306+ 8C3A
 307+ 8C3A              DrawVLines:
 308+ 8C3A 06 04        	ld		b, 4
 309+ 8C3C 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 310+ 8C3F              DrawVLinesLoop:
 311+ 8C3F C5           	push 	bc
 312+ 8C40 D5           	push	de
 313+ 8C41 06 17        		ld		b, LST_LINES_CNT
 314+ 8C43 3E 80        		ld		a, CHR_V
 315+ 8C45 37           		scf
 316+ 8C46 CD F1 8B     		call	DrawLine
 317+ 8C49 D1           	pop		de
 318+ 8C4A C1           	pop	bc
 319+ 8C4B 7B           	ld		a, e
 320+ 8C4C C6 0C        	add		NAMELEN+1
 321+ 8C4E 5F           	ld		e, a
 322+ 8C4F 10 EE        	djnz	DrawVLinesLoop
 323+ 8C51 C9           	ret
 324+ 8C52
 325+ 8C52              PrintChar2:
 326+ 8C52 32 81 5C     	ld		(CODE), a
 327+ 8C55 ED 53 B0 5C  	ld		(LineCol), de
 328+ 8C59
 329+ 8C59              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 330+ 8C59
 331+ 8C59              ;IN: A = color mask
 332+ 8C59              DrawCursor:
 333+ 8C59 ED 5B 28 96  	ld	de, (CursorAddr)
 334+ 8C5D 06 06        	ld	b, 	(NAMELEN + 1)/2
 335+ 8C5F              DrawCursorLoop:
 336+ 8C5F 12           	ld	(de), a
 337+ 8C60 13           	inc de
 338+ 8C61 10 FC        	djnz DrawCursorLoop
 339+ 8C63 C9           	ret
 340+ 8C64
 341+ 8C64              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 342+ 8C64
 343+ 8C64              ;IN:	A = file idx.
 344+ 8C64              MoveCursor:
 345+ 8C64              	;File idx / SCR_LINES => cursor line & column
 346+ 8C64 6F           	ld		l, a
 347+ 8C65 26 00        	ld		h, 0
 348+ 8C67 0E 17        	ld		c, LST_LINES_CNT
 349+ 8C69 CD 3E 87     	call	Div					;HL = file column, A = line
 350+ 8C6C
 351+ 8C6C              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 352+ 8C6C C6 00        	add		LST_FIRST_LINE
 353+ 8C6E
 354+ 8C6E
 355+ 8C6E 54           	ld d, h
 356+ 8C6F 5D           	ld e, l
 357+ 8C70 21 00 00     	ld	hl, 0
 358+ 8C73
 359+ 8C73              	;line*32
 360+ 8C73 17           	rla
 361+ 8C74 17           	rla
 362+ 8C75 17           	rla
 363+ 8C76 17           	rla
 364+ 8C77 CB 14        	rl h
 365+ 8C79 17           	rla
 366+ 8C7A CB 14        	rl h
 367+ 8C7C 6F           	ld l, a
 368+ 8C7D
 369+ 8C7D
 370+ 8C7D              	;col * 6
 371+ 8C7D E5           	push	hl					;save line * 32
 372+ 8C7E 3E 06        		ld		a, (NAMELEN + 1)/2
 373+ 8C80 CD 5E 87     		call	Mul				;HL = column * 12/2
 374+ 8C83 D1           	pop		de
 375+ 8C84 19           	add		hl, de
 376+ 8C85
 377+ 8C85 11 08 00     	ld		de, LST_FIRST_COL/2
 378+ 8C88 ED 4B 1E 8D  	ld		bc, (CurrScrAttrAddr)
 379+ 8C8C 19           	add		hl, de
 380+ 8C8D 09           	add		hl, bc
 381+ 8C8E
 382+ 8C8E              	;clear old cursor
 383+ 8C8E 3E 0F        	ld		a, SCR_DEF_CLR
 384+ 8C90 CD 59 8C     	call	DrawCursor
 385+ 8C93
 386+ 8C93              	;draw new one
 387+ 8C93 22 28 96     	ld		(CursorAddr), hl
 388+ 8C96 3E 28        	ld		a, SCR_SEL_CLR
 389+ 8C98 CD 59 8C     	call	DrawCursor
 390+ 8C9B
 391+ 8C9B C9           	ret
 392+ 8C9C
 393+ 8C9C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 394+ 8C9C
 395+ 8C9C              PrintChar:
 396+ 8C9C ED 5B B0 5C      ld		de, (LineCol)
 397+ 8CA0
 398+ 8CA0                  ;calculate 64 column screen address
 399+ 8CA0              	;IN: D = line, E = col
 400+ 8CA0              	;OUT: HL = screen address
 401+ 8CA0
 402+ 8CA0 CB 3B            SRL     E                                       ;col = col/2
 403+ 8CA2 CB 19            RR      C                                       ;mark odd/even column
 404+ 8CA4 7A               LD      A, D                            ;A = line
 405+ 8CA5 E6 18            AND 24                                  ;keep only %00011000
 406+ 8CA7 2A 1C 8D         ld		hl, (CurrScrAddr)
 407+ 8CAA B4               OR      h								;add screen start address
 408+ 8CAB 67               LD      H, A                            ;save H
 409+ 8CAC 7A               LD      A, D                            ;A = line
 410+ 8CAD E6 07            AND 7                                   ;keep only %00000111
 411+ 8CAF 0F               RRCA                                    ;%10000011
 412+ 8CB0 0F               RRCA                                    ;%11000001
 413+ 8CB1 0F               RRCA                                    ;%11100000
 414+ 8CB2 B3               OR      E                                       ;add column
 415+ 8CB3 6F               LD      L, A                            ;HL = screen address
 416+ 8CB4
 417+ 8CB4              PrintChar3:
 418+ 8CB4                  ;get font address
 419+ 8CB4 E5               PUSH HL
 420+ 8CB5 AF                   XOR A
 421+ 8CB6 67                   LD  H, A
 422+ 8CB7 3A 81 5C             LD  A, (CODE)
 423+ 8CBA D6 20                SUB ' '
 424+ 8CBC 6F                   LD  L, A
 425+ 8CBD 29                   ADD     HL, HL                  ;char code = char code * 8
 426+ 8CBE 29                   ADD     HL, HL                  ;i.e. offset into font table
 427+ 8CBF 29                   ADD     HL, HL
 428+ 8CC0 11 BD 92             LD      DE, FontTable             ;get font table
 429+ 8CC3 19                   ADD     HL, DE
 430+ 8CC4 EB                   EX      DE, HL                  ;DE = our char font address
 431+ 8CC5 E1               POP     HL
 432+ 8CC6
 433+ 8CC6
 434+ 8CC6                  ;print a char
 435+ 8CC6 06 08            LD      B, 8                            ;char height is 8 lines
 436+ 8CC8              PrintCharLine:
 437+ 8CC8 1A                   LD      A, (DE)                         ;load char line in A
 438+ 8CC9
 439+ 8CC9 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 440+ 8CCB 20 06                JR  	NZ, NoTurn
 441+ 8CCD
 442+ 8CCD 07                   RLCA
 443+ 8CCE 07                   RLCA
 444+ 8CCF 07                   RLCA
 445+ 8CD0 07                   RLCA
 446+ 8CD1 18 01                JR      Store
 447+ 8CD3              NoTurn:
 448+ 8CD3 B6                   OR (HL)
 449+ 8CD4              Store:
 450+ 8CD4 77                   LD (HL), A
 451+ 8CD5
 452+ 8CD5 13                   INC     DE                                      ;next char line in font table
 453+ 8CD6 24                   INC     H                                       ;next char line on screen
 454+ 8CD7 10 EF            DJNZ PrintCharLine                  ;last line of char?
 455+ 8CD9
 456+ 8CD9 C9               ret
 457+ 8CDA
 458+ 8CDA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 459+ 8CDA
 460+ 8CDA              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 461+ 8CDA              ReadString:
 462+ 8CDA 21 2A AF     	ld		hl, DataBuf
 463+ 8CDD D5           	push	de
 464+ 8CDE DD E1        	pop		ix
 465+ 8CE0
 466+ 8CE0              ReadStringLoop:
 467+ 8CE0 D5           	push	de
 468+ 8CE1 E5           	push	hl
 469+ 8CE2 CD 73 8B     		call ReadChar
 470+ 8CE5 E1           	pop		hl
 471+ 8CE6 D1           	pop		de
 472+ 8CE7
 473+ 8CE7 FE 0D        	cp	KEY_ENTER
 474+ 8CE9 C8           	ret z
 475+ 8CEA
 476+ 8CEA FE 0C        	cp  KEY_BACKSP
 477+ 8CEC 20 0F        	jr	nz, ReadStrChar
 478+ 8CEE
 479+ 8CEE E5           	push hl
 480+ 8CEF 01 2B AF     	ld   bc, DataBuf+1
 481+ 8CF2 ED 42        	sbc	 hl, bc
 482+ 8CF4 E1           	pop  hl
 483+ 8CF5 38 16        	jr   c, ReadStrPrint
 484+ 8CF7
 485+ 8CF7 1B           	dec	de
 486+ 8CF8 2B           	dec	hl
 487+ 8CF9 36 20        	ld	(hl), ' '
 488+ 8CFB 18 10        	jr	ReadStrPrint
 489+ 8CFD
 490+ 8CFD              ReadStrChar:
 491+ 8CFD FE 20        	cp	' '
 492+ 8CFF 38 DF        	jr	c, ReadStringLoop
 493+ 8D01 FE 7F        	cp  127
 494+ 8D03 30 DB        	jr	nc, ReadStringLoop
 495+ 8D05
 496+ 8D05              	;Check end of string and go back if found.
 497+ 8D05 46           	ld	b, (hl)
 498+ 8D06 CB 78        	bit 7, b
 499+ 8D08 20 03        	jr	nz, ReadStrPrint
 500+ 8D0A
 501+ 8D0A 77           	ld	(hl), a
 502+ 8D0B 23           	inc	hl
 503+ 8D0C 13           	inc	de
 504+ 8D0D
 505+ 8D0D              ReadStrPrint:
 506+ 8D0D E5           	push	hl
 507+ 8D0E D5           	push	de
 508+ 8D0F 21 2A AF     	ld		hl, DataBuf
 509+ 8D12 DD E5        	push	ix
 510+ 8D14 D1           	pop		de
 511+ 8D15 CD 99 8B     	call	PrintStr
 512+ 8D18 D1           	pop		de
 513+ 8D19 E1           	pop		hl
 514+ 8D1A
 515+ 8D1A 18 C4        	jr		ReadStringLoop
 516+ 8D1C
 517+ 8D1C 00 40        CurrScrAddr		DEFW	16384
 518+ 8D1E 00 58        CurrScrAttrAddr	DEFW	22528
 519+ 8D20
 520+ 8D20                 	endif
# file closed: ui.asm
1120  8D20              	include "math.asm"
# file opened: math.asm
   1+ 8D20              	ifndef	_MATH_
   2+ 8D20 ~            	define	_MATH_
   3+ 8D20 ~
   4+ 8D20 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 8D20 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 8D20 ~
   7+ 8D20 ~
   8+ 8D20 ~            Word2Txt:
   9+ 8D20 ~            	IFUSED
  10+ 8D20 ~            	push	de
  11+ 8D20 ~            		call	Word2Txt_
  12+ 8D20 ~            	pop		de
  13+ 8D20 ~
  14+ 8D20 ~            	ld		b, 4
  15+ 8D20 ~            	call	StrippLeading0
  16+ 8D20 ~            	ret
  17+ 8D20 ~
  18+ 8D20 ~            Byte2Txt:
  19+ 8D20 ~            	push	de
  20+ 8D20 ~            		call	Byte2Txt_
  21+ 8D20 ~            	pop		de
  22+ 8D20 ~
  23+ 8D20 ~            	ld		b, 2
  24+ 8D20 ~            	call	StrippLeading0
  25+ 8D20 ~            	ret
  26+ 8D20 ~            	ENDIF
  27+ 8D20 ~
  28+ 8D20 ~
  29+ 8D20 ~            StrippLeading0:
  30+ 8D20 ~            	ld		a, (de)
  31+ 8D20 ~            	cp		'1'
  32+ 8D20 ~            	ret		nc
  33+ 8D20 ~
  34+ 8D20 ~            	ld		a, ' '
  35+ 8D20 ~            	ld		(de), a
  36+ 8D20 ~            	inc		de
  37+ 8D20 ~            	djnz	StrippLeading0
  38+ 8D20 ~            	ret
  39+ 8D20 ~
  40+ 8D20 ~
  41+ 8D20 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 8D20 ~            Word2Txt_:
  43+ 8D20 ~            	ld bc, -10000
  44+ 8D20 ~            	call DigitLoop
  45+ 8D20 ~            	ld bc, -1000
  46+ 8D20 ~            	call DigitLoop
  47+ 8D20 ~            Byte2Txt_:
  48+ 8D20 ~            	ld bc, -100
  49+ 8D20 ~            	call DigitLoop
  50+ 8D20 ~            	ld bc, -10
  51+ 8D20 ~            	call DigitLoop
  52+ 8D20 ~            	ld bc, -1
  53+ 8D20 ~
  54+ 8D20 ~            DigitLoop:
  55+ 8D20 ~            	ld	a, '0' - 1
  56+ 8D20 ~            DivNrLoop:
  57+ 8D20 ~            	inc	a			;increase reminder
  58+ 8D20 ~            	add	hl, bc		;substract divizor
  59+ 8D20 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 8D20 ~            	sbc	hl, bc		;nope, restore
  61+ 8D20 ~
  62+ 8D20 ~            	ld (de), a
  63+ 8D20 ~            	inc de
  64+ 8D20 ~            	ret
  65+ 8D20 ~
  66+ 8D20 ~
  67+ 8D20 ~            ;Input: HL = Dividend, C = Divisor
  68+ 8D20 ~            ;Output: HL = Quotient, A = Remainder
  69+ 8D20 ~            ;Warning: doesn't work with divisor >= $80
  70+ 8D20 ~            Div:
  71+ 8D20 ~            	IFUSED
  72+ 8D20 ~            	xor a
  73+ 8D20 ~            	ld b, 16
  74+ 8D20 ~
  75+ 8D20 ~            DivLoop:
  76+ 8D20 ~            	add	hl,hl
  77+ 8D20 ~            	rla
  78+ 8D20 ~            	cp	c
  79+ 8D20 ~            	jr	c, NoSub
  80+ 8D20 ~            	sub	c
  81+ 8D20 ~            	inc	l
  82+ 8D20 ~            NoSub:
  83+ 8D20 ~            	djnz DivLoop
  84+ 8D20 ~
  85+ 8D20 ~            	ret
  86+ 8D20 ~            	ENDIF
  87+ 8D20 ~
  88+ 8D20 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 8D20 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 8D20 ~            Div2:
  91+ 8D20 ~            	ld hl, 0
  92+ 8D20 ~            	ld b, 16
  93+ 8D20 ~            Div2Loop:
  94+ 8D20 ~            	sll c		; unroll 16 times
  95+ 8D20 ~            	rla			; ...
  96+ 8D20 ~            	adc	hl,hl		; ...
  97+ 8D20 ~            	sbc	hl,de		; ...
  98+ 8D20 ~            	jr	nc,$+4		; ...
  99+ 8D20 ~            	add	hl,de		; ...
 100+ 8D20 ~            	dec	c		; ...
 101+ 8D20 ~            	djnz Div2Loop
 102+ 8D20 ~            	ret
 103+ 8D20 ~
 104+ 8D20 ~
 105+ 8D20 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 8D20 ~            ;Output: A:HL = Product
 107+ 8D20 ~            Mul:
 108+ 8D20 ~            	IFUSED
 109+ 8D20 ~            	ld hl, 0
 110+ 8D20 ~            	ld bc, $0700
 111+ 8D20 ~
 112+ 8D20 ~            	add	a, a		; optimised 1st iteration
 113+ 8D20 ~            	jr	nc, MulLoop
 114+ 8D20 ~            	ld	h, d
 115+ 8D20 ~            	ld	l, e
 116+ 8D20 ~
 117+ 8D20 ~            MulLoop:
 118+ 8D20 ~            	add	hl,hl
 119+ 8D20 ~            	rla
 120+ 8D20 ~            	jr	nc, NoAdd
 121+ 8D20 ~            	add	hl,de
 122+ 8D20 ~            	adc	a,c
 123+ 8D20 ~            NoAdd:
 124+ 8D20 ~            	djnz MulLoop
 125+ 8D20 ~
 126+ 8D20 ~            	ret
 127+ 8D20 ~            	ENDIF
 128+ 8D20 ~
 129+ 8D20              	endif
# file closed: math.asm
1121  8D20              	include "txtview.asm"
# file opened: txtview.asm
   1+ 8D20              ; 	DEVICE ZXSPECTRUM48
   2+ 8D20
   3+ 8D20              LINE_CNT	EQU	23
   4+ 8D20              COL_CNT		EQU	64
   5+ 8D20
   6+ 8D20              CHAR_CR		EQU	$0D
   7+ 8D20              CHAR_LF		EQU	$0A
   8+ 8D20              CHAR_TAB	EQU	$09
   9+ 8D20
  10+ 8D20              COORDS		EQU	23728		;Coordinates
  11+ 8D20
  12+ 8D20
  13+ 8D20              InitViewer:
  14+ 8D20 22 6C 90     	ld		 (FileBegin), hl
  15+ 8D23 09           	add		hl, bc
  16+ 8D24              	;must filter any EOF chars, max 256 of them.
  17+ 8D24 25           	dec		h
  18+ 8D25 3E 1A        	ld		a, 0x1A
  19+ 8D27 ED B1        	cpir
  20+ 8D29 2B           	dec		hl
  21+ 8D2A 22 70 90     	ld		(FileEnd), hl
  22+ 8D2D ED 5B 6C 90  	ld		de, (FileBegin)
  23+ 8D31 B7           	or		a
  24+ 8D32 ED 52        	sbc		hl, de
  25+ 8D34 22 6E 90     	ld		(FileLen), hl
  26+ 8D37
  27+ 8D37 3E 0D        	ld		a, 0x0D
  28+ 8D39 77           	ld		(hl), a
  29+ 8D3A
  30+ 8D3A
  31+ 8D3A 21 04 02     	ld		hl, (2 << 8) | 4
  32+ 8D3D 22 09 5C     	ld		(23561), hl
  33+ 8D40
  34+ 8D40 21 00 00     	ld		hl, 0
  35+ 8D43 22 B0 5C     	ld		(COORDS), hl
  36+ 8D46
  37+ 8D46 21 00 58     	ld		hl, 16384 + 6144
  38+ 8D49 54           	ld		d, h
  39+ 8D4A 5D           	ld		e, l
  40+ 8D4B 13           	inc		de
  41+ 8D4C 01 FF 02     	ld		bc, 767
  42+ 8D4F 36 0F        	ld		(hl), (1 << 3) | 7
  43+ 8D51 ED B0        	ldir
  44+ 8D53
  45+ 8D53 CD 72 8F     	call	ScrollInit
  46+ 8D56
  47+ 8D56 11 00 00     	ld		de, 0
  48+ 8D59 ED 53 67 90  	ld		(CurLine), de
  49+ 8D5D
  50+ 8D5D              	;prepare file progress %
  51+ 8D5D 2A 6E 90     	ld		hl, (FileLen)
  52+ 8D60 7C           	ld		a, h
  53+ 8D61 4D           	ld		c, l
  54+ 8D62 11 64 00     	ld		de, 100
  55+ 8D65 CD 4B 87     	call	Div2
  56+ 8D68 67           	ld		h, a
  57+ 8D69 69           	ld		l, c
  58+ 8D6A 22 72 90     	ld		(PROGR_PERC), hl
  59+ 8D6D
  60+ 8D6D CD 01 8F     	call	PrintMsg
  61+ 8D70
  62+ 8D70 DD 21 28 AF  	ld		ix, FileIdx	- 2
  63+ 8D74 06 17        	ld		b, LINE_CNT
  64+ 8D76 2A 6C 90     	ld		hl, (FileBegin)
  65+ 8D79
  66+ 8D79 C9           	ret
  67+ 8D7A
  68+ 8D7A              PrintLoop:
  69+ 8D7A C5           	push	bc
  70+ 8D7B DD 23        		inc		ix
  71+ 8D7D DD 23        		inc		ix
  72+ 8D7F DD 75 00     		ld		(ix), l
  73+ 8D82 DD 74 01     		ld		(ix + 1), h
  74+ 8D85
  75+ 8D85 CD 9C 8E     		call	GetLine
  76+ 8D88 CD 6E 8E     		call	PrintLine
  77+ 8D8B
  78+ 8D8B ED 5B 67 90  		ld		de, (CurLine)
  79+ 8D8F 13           		inc		de
  80+ 8D90 ED 53 67 90  		ld		(CurLine), de
  81+ 8D94 C1           	pop		bc
  82+ 8D95 CD 63 8E     	call	CheckEnd
  83+ 8D98 28 13        	jr		z, EOF
  84+ 8D9A
  85+ 8D9A 10 DE        	djnz	PrintLoop
  86+ 8D9C 18 17        	jr		PrintLoop2
  87+ 8D9E
  88+ 8D9E              GetKey:
  89+ 8D9E 76           	halt
  90+ 8D9F FD CB 01 6E  	bit		5, (iy + 1);
  91+ 8DA3 28 F9        	jr		z, GetKey
  92+ 8DA5 FD CB 01 AE  	res		5, (iy + 1)
  93+ 8DA9 FD 7E CE     	ld		a, (iy - $32)
  94+ 8DAC C9           	ret
  95+ 8DAD
  96+ 8DAD              EOF:
  97+ 8DAD CD 9E 8D     	call	GetKey
  98+ 8DB0 FE 30        	cp		'0'
  99+ 8DB2 20 F9        	jr		nz, EOF
 100+ 8DB4 C9           	ret
 101+ 8DB5
 102+ 8DB5              PrintLoop2:
 103+ 8DB5 CD 01 8F     	call	PrintMsg
 104+ 8DB8
 105+ 8DB8 CD 9E 8D     	call	GetKey
 106+ 8DBB FE 30        	cp		'0'					;Exit on 0
 107+ 8DBD C8           	ret		z
 108+ 8DBE
 109+ 8DBE FE 0A        	cp		KEY_DOWN
 110+ 8DC0 28 5C        	jr		z, Down
 111+ 8DC2
 112+ 8DC2 FE 0B        	cp		KEY_UP
 113+ 8DC4 28 2D        	jr		z, Up
 114+ 8DC6
 115+ 8DC6 FE 32        	cp		'2'
 116+ 8DC8 20 EB        	jr		nz, PrintLoop2
 117+ 8DCA
 118+ 8DCA 3A 6B 90     	ld		a, (WrapFlag)
 119+ 8DCD EE 01        	xor		1
 120+ 8DCF 32 6B 90     	ld		(WrapFlag), a
 121+ 8DD2 B7           	or		a
 122+ 8DD3 28 0F        	jr		z, NoWrap
 123+ 8DD5
 124+ 8DD5 11 4F 6E     	ld		de, 'nO'
 125+ 8DD8 ED 53 1D 90  	ld		(MsgLineWrF), de
 126+ 8DDC 3E 20        	ld		a, ' '
 127+ 8DDE 32 1F 90     	ld		(MsgLineWrF + 2), a
 128+ 8DE1 C3 B5 8D     	jp		PrintLoop2
 129+ 8DE4
 130+ 8DE4              NoWrap:
 131+ 8DE4 11 4F 66     	ld		de, 'fO'
 132+ 8DE7 ED 53 1D 90  	ld		(MsgLineWrF), de
 133+ 8DEB 3E 66        	ld		a, 'f'
 134+ 8DED 32 1F 90     	ld		(MsgLineWrF + 2), a
 135+ 8DF0
 136+ 8DF0 C3 B5 8D     	jp		PrintLoop2
 137+ 8DF3
 138+ 8DF3
 139+ 8DF3              Up:
 140+ 8DF3 CD 53 8E     	call	CheckBegin
 141+ 8DF6 28 BD        	jr		z, PrintLoop2
 142+ 8DF8
 143+ 8DF8 CD A0 8F     	call	ScrollUp
 144+ 8DFB
 145+ 8DFB DD 2B        	dec		ix
 146+ 8DFD DD 2B        	dec		ix
 147+ 8DFF DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 148+ 8E02 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 149+ 8E05 CD 9C 8E     	call	GetLine						;extract previous line to display
 150+ 8E08
 151+ 8E08 11 00 00     	ld		de, 0
 152+ 8E0B ED 53 B0 5C  	ld		(COORDS), de
 153+ 8E0F CD 6E 8E     	call	PrintLine
 154+ 8E12
 155+ 8E12 2A 67 90     	ld		hl, (CurLine)
 156+ 8E15 2B           	dec		hl
 157+ 8E16 22 67 90     	ld		(CurLine), hl
 158+ 8E19 CD 01 8F     	call	PrintMsg
 159+ 8E1C 18 97        	jr		PrintLoop2
 160+ 8E1E
 161+ 8E1E
 162+ 8E1E              Down:
 163+ 8E1E DD 6E 00     	ld		l, (ix)
 164+ 8E21 DD 66 01     	ld		h, (ix + 1)
 165+ 8E24 CD 9C 8E     	call	GetLine						;get next line pointer
 166+ 8E27
 167+ 8E27 CD 63 8E     	call	CheckEnd					;check if HL == file end
 168+ 8E2A 38 89        	jr		c, PrintLoop2
 169+ 8E2C
 170+ 8E2C DD 23        	inc		ix								;save next line pointer
 171+ 8E2E DD 23        	inc		ix
 172+ 8E30 DD 75 00     	ld		(ix), l
 173+ 8E33 DD 74 01     	ld		(ix + 1), h
 174+ 8E36
 175+ 8E36 CD 9C 8E     	call	GetLine						;extract next line in buffer for display
 176+ 8E39
 177+ 8E39 CD A5 8F     	call	ScrollDown
 178+ 8E3C
 179+ 8E3C 11 00 16     	ld		de, (LINE_CNT-1) << 8
 180+ 8E3F ED 53 B0 5C  	ld		(COORDS), de
 181+ 8E43 CD 6E 8E     	call	PrintLine
 182+ 8E46
 183+ 8E46 2A 67 90     	ld		hl, (CurLine)
 184+ 8E49 23           	inc		hl
 185+ 8E4A 22 67 90     	ld		(CurLine), hl
 186+ 8E4D CD 01 8F     	call	PrintMsg
 187+ 8E50
 188+ 8E50 C3 B5 8D     	jp		PrintLoop2
 189+ 8E53
 190+ 8E53
 191+ 8E53              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 8E53              ;check begining of buffer
 193+ 8E53              CheckBegin:
 194+ 8E53 E5           	push	hl
 195+ 8E54 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 196+ 8E57 DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 197+ 8E5A ED 5B 6C 90  		ld		de, (FileBegin)
 198+ 8E5E B7           		or		a
 199+ 8E5F ED 52        		sbc		hl, de
 200+ 8E61 E1           	pop		hl
 201+ 8E62 C9           	ret
 202+ 8E63
 203+ 8E63              ;check end of buffer
 204+ 8E63              CheckEnd:
 205+ 8E63 E5           	push	hl
 206+ 8E64 ED 5B 70 90  		ld		de, (FileEnd)
 207+ 8E68 EB           		ex		de, hl
 208+ 8E69 B7           		or		a
 209+ 8E6A ED 52        		sbc		hl, de
 210+ 8E6C E1           	pop		hl
 211+ 8E6D C9           	ret
 212+ 8E6E
 213+ 8E6E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214+ 8E6E              ;Print a line
 215+ 8E6E              PrintLine:
 216+ 8E6E 11 27 90     	ld		de, LineBuf
 217+ 8E71 06 40        	ld		b, COL_CNT
 218+ 8E73
 219+ 8E73 CD 82 8E     	call	PrintStrTxt
 220+ 8E76
 221+ 8E76              	;go to the next screen line
 222+ 8E76 ED 5B B0 5C  	ld		de, (COORDS)
 223+ 8E7A 14           	inc		d
 224+ 8E7B 1E 00        	ld		e, 0
 225+ 8E7D ED 53 B0 5C  	ld		(COORDS), de
 226+ 8E81 C9           	ret
 227+ 8E82
 228+ 8E82              PrintStrTxt:
 229+ 8E82 1A           	ld		a, (de)
 230+ 8E83 13           	inc		de
 231+ 8E84 D5           	push	de
 232+ 8E85 32 81 5C     		ld		(CODE), a
 233+ 8E88 C5           		push	bc
 234+ 8E89 E5           			push	hl
 235+ 8E8A CD 9C 8C     				call	PrintChar
 236+ 8E8D E1           			pop		hl
 237+ 8E8E C1           		pop		bc
 238+ 8E8F
 239+ 8E8F ED 5B B0 5C  		ld		de, (COORDS)
 240+ 8E93 1C           		inc		e
 241+ 8E94 ED 53 B0 5C  		ld		(COORDS), de
 242+ 8E98 D1           	pop		de
 243+ 8E99 10 E7        	djnz	PrintStrTxt
 244+ 8E9B C9           	ret
 245+ 8E9C
 246+ 8E9C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 8E9C              ;Extract a line of text to fit exactly on a 64 screen line
 248+ 8E9C              ;IN:	HL = current file pointer
 249+ 8E9C              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 250+ 8E9C              GetLine:
 251+ 8E9C 11 27 90     	ld		de, LineBuf
 252+ 8E9F 06 40        	ld		b, COL_CNT
 253+ 8EA1              GetLineLoop:
 254+ 8EA1 7E           	ld		a, (hl)
 255+ 8EA2 23           	inc		hl
 256+ 8EA3
 257+ 8EA3 FE 0D        	cp		CHAR_CR
 258+ 8EA5 28 29        	jr		z, GetLineSkip0A
 259+ 8EA7
 260+ 8EA7 FE 0A        	cp		CHAR_LF
 261+ 8EA9 28 25        	jr		z, GetLineSkip0A
 262+ 8EAB
 263+ 8EAB FE 09        	cp		CHAR_TAB
 264+ 8EAD 20 07        	jr		nz, GetLineNext
 265+ 8EAF
 266+ 8EAF 3E 20        	ld		a, ' '
 267+ 8EB1 12           	ld		(de), a
 268+ 8EB2 13           	inc		de
 269+ 8EB3 05           	dec		b
 270+ 8EB4 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 271+ 8EB6
 272+ 8EB6              GetLineNext:
 273+ 8EB6 FE 20        	cp		' '
 274+ 8EB8 38 06        	jr		c, NotValid
 275+ 8EBA
 276+ 8EBA FE 80        	cp		128
 277+ 8EBC 30 02        	jr		nc, NotValid
 278+ 8EBE 18 03        	jr		Valid
 279+ 8EC0
 280+ 8EC0              NotValid:
 281+ 8EC0 CD 50 8F     	call	ReplaceChars
 282+ 8EC3
 283+ 8EC3              Valid:
 284+ 8EC3 12           	ld		(de), a
 285+ 8EC4 13           	inc		de
 286+ 8EC5 10 DA        	djnz	GetLineLoop
 287+ 8EC7
 288+ 8EC7              ;if line is exactly 64 char long, must skip the new line char(s)
 289+ 8EC7              GetLineSkip0D:
 290+ 8EC7 0E 00        	ld		c, 0
 291+ 8EC9 3E 0D        	ld		a, CHAR_CR						;skip 0D
 292+ 8ECB BE           	cp		(hl)
 293+ 8ECC 20 02        	jr		nz, GetLineSkip0A
 294+ 8ECE 23           	inc		hl
 295+ 8ECF 0C           	inc		c
 296+ 8ED0
 297+ 8ED0              GetLineSkip0A:						;skip 0A
 298+ 8ED0 3E 0A        	ld		a, CHAR_LF
 299+ 8ED2 BE           	cp		(hl)
 300+ 8ED3 20 02        	jr		nz, GetLineFill
 301+ 8ED5 23           	inc		hl
 302+ 8ED6 0C           	inc		c
 303+ 8ED7
 304+ 8ED7              GetLineFill:
 305+ 8ED7 78           	ld		a, b
 306+ 8ED8 B7           	or		a
 307+ 8ED9 20 1F        	jr		nz, GetLineFillLoop
 308+ 8EDB
 309+ 8EDB 79           	ld		a, c
 310+ 8EDC B7           	or		a
 311+ 8EDD C0           	ret		nz
 312+ 8EDE
 313+ 8EDE              	;wrap or not
 314+ 8EDE 3A 6B 90     	ld		a, (WrapFlag)
 315+ 8EE1 B7           	or		a
 316+ 8EE2 C0           	ret		nz
 317+ 8EE3
 318+ 8EE3 ED 5B 70 90  	ld		de, (FileEnd)
 319+ 8EE7 E5           	push	hl
 320+ 8EE8 EB           	ex		de, hl
 321+ 8EE9 B7           	or		a
 322+ 8EEA ED 52        	sbc		hl, de
 323+ 8EEC 44           	ld		b, h
 324+ 8EED 4D           	ld		c, l
 325+ 8EEE 3E 0D        	ld		a, CHAR_CR
 326+ 8EF0 E1           	pop		hl
 327+ 8EF1 ED B1        	cpir
 328+ 8EF3 C0           	ret		nz
 329+ 8EF4 3E 0A        	ld		a, CHAR_LF
 330+ 8EF6 BE           	cp		(hl)
 331+ 8EF7 C0           	ret		nz
 332+ 8EF8 23           	inc		hl
 333+ 8EF9
 334+ 8EF9 C9           	ret
 335+ 8EFA
 336+ 8EFA              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 337+ 8EFA 3E 20        	ld		a, ' '
 338+ 8EFC 12           	ld		(de), a
 339+ 8EFD 13           	inc		de
 340+ 8EFE 10 FA        	djnz	GetLineFillLoop
 341+ 8F00 C9           	ret
 342+ 8F01
 343+ 8F01              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 344+ 8F01              PrintMsg:
 345+ 8F01 ED 5B B0 5C  	ld		de, (COORDS)
 346+ 8F05 D5           	push	de
 347+ 8F06 11 00 17     	ld		de, LINE_CNT<<8
 348+ 8F09 ED 53 B0 5C  	ld		(COORDS), de
 349+ 8F0D
 350+ 8F0D              	;Get current file pointer
 351+ 8F0D DD 6E 00     	ld		l, (ix)
 352+ 8F10 DD 66 01     	ld		h, (ix + 1)
 353+ 8F13 ED 4B 6C 90  	ld		bc, (FileBegin)
 354+ 8F17 B7           	or		a
 355+ 8F18 ED 42        	sbc		hl, bc
 356+ 8F1A
 357+ 8F1A              	;Divide by one percent length
 358+ 8F1A 7C           	ld		a, h
 359+ 8F1B 4D           	ld		c, l
 360+ 8F1C ED 5B 72 90  	ld		de, (PROGR_PERC)
 361+ 8F20 CD 4B 87     	call	Div2
 362+ 8F23
 363+ 8F23              	;Display %
 364+ 8F23 11 03 90     	ld		de, MsgLinePr
 365+ 8F26 67           	ld		h, a
 366+ 8F27 69           	ld		l, c
 367+ 8F28 CD 02 87     	call	Byte2Txt
 368+ 8F2B
 369+ 8F2B
 370+ 8F2B 2A 67 90     	ld		hl, (CurLine)
 371+ 8F2E 11 0F 90     	ld		de, MsgLineNo
 372+ 8F31 CD F7 86     	call	Word2Txt
 373+ 8F34
 374+ 8F34 11 FA 8F     	ld		de, MsgLine
 375+ 8F37 06 2D        	ld		b, MsgLineLen
 376+ 8F39 CD 82 8E     	call	PrintStrTxt
 377+ 8F3C D1           	pop		de
 378+ 8F3D ED 53 B0 5C  	ld		(COORDS), DE
 379+ 8F41
 380+ 8F41 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 381+ 8F44 54           	ld		d, h
 382+ 8F45 5D           	ld		e, l
 383+ 8F46 13           	inc		de
 384+ 8F47 3E 28        	ld		a, (5 << 3) | 0
 385+ 8F49 77           	ld		(hl), a
 386+ 8F4A 01 1F 00     	ld		bc, 31
 387+ 8F4D ED B0        	ldir
 388+ 8F4F C9           	ret
 389+ 8F50
 390+ 8F50
 391+ 8F50              ReplaceChars:
 392+ 8F50 E5           	push	hl
 393+ 8F51 C5           	push	bc
 394+ 8F52 21 E0 8F     		ld		hl, CharReplaceTbl
 395+ 8F55 06 0D        		ld		b, CharReplTblLen
 396+ 8F57              ReplaceSGCLoop:
 397+ 8F57 BE           		cp		(hl)
 398+ 8F58 28 09        		jr		z, ReplaceMatch
 399+ 8F5A 23           		inc		hl
 400+ 8F5B 23           		inc		hl
 401+ 8F5C 10 F9        		djnz	ReplaceSGCLoop
 402+ 8F5E
 403+ 8F5E 3E 3F        		ld		a, '?'
 404+ 8F60 C1           		pop		bc
 405+ 8F61 E1           		pop		hl
 406+ 8F62 C9           	ret
 407+ 8F63
 408+ 8F63              ReplaceMatch:
 409+ 8F63 23           		inc		hl
 410+ 8F64 7E           		ld		a, (hl)
 411+ 8F65 C1           	pop		bc
 412+ 8F66 E1           	pop		hl
 413+ 8F67 C9           	ret
 414+ 8F68              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 415+ 8F68
 416+ 8F68              	include	"scroll.asm"
# file opened: scroll.asm
   1++8F68              ;Scrolling routines for UP/DOWN
   2++8F68              ;They use 2 tables of pointers of screen cell rows.
   3++8F68              ;One table has addresses in increasing order, for scroll down,
   4++8F68              ;the other in decreasing order, for scroll up, so the same
   5++8F68              ;scroll routine is used in both cases.
   6++8F68              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++8F68
   8++8F68              ; Char Down
   9++8F68              ; Adjusts screen address HL to move eight pixels down on the display.
  10++8F68              ; enter: HL = valid screen address
  11++8F68              ; exit : HL = moves one character down
  12++8F68              ; used : AF, HL
  13++8F68              GetCellDown:
  14++8F68 7D           	ld a,l
  15++8F69 C6 20        	add a,$20
  16++8F6B 6F           	ld l,a
  17++8F6C D0           	ret nc
  18++8F6D 7C           	ld a,h
  19++8F6E C6 08        	add a,$08
  20++8F70 67           	ld h,a
  21++8F71 C9           	ret
  22++8F72
  23++8F72              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++8F72              ;Fills the two tables with pointers.
  25++8F72              ScrollInit:
  26++8F72 21 00 40     	ld		hl, 16384
  27++8F75 06 17        	ld		b, LINE_CNT
  28++8F77              FillScrLinesLoop:
  29++8F77              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++8F77 22 00 5B     	ld		(SCRLinesDown), hl
  31++8F7A              	;inc. pointer in destination table (of pointers to lines)
  32++8F7A ED 5B 78 8F  	ld		de, (FillScrLinesPtr)
  33++8F7E 13           	inc		de
  34++8F7F 13           	inc		de
  35++8F80 ED 53 78 8F  	ld		(FillScrLinesPtr), de
  36++8F84 CD 68 8F     	call	GetCellDown
  37++8F87 10 EE        	djnz	FillScrLinesLoop
  38++8F89
  39++8F89              	;now fill the table in reverse
  40++8F89 ED 73 9D 8F  	ld		(FillScrLinesSPStore), sp
  41++8F8D 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++8F90 06 17        	ld		b, LINE_CNT
  43++8F92 21 00 5B     	ld		hl, SCRLinesDown
  44++8F95              FillScrLinesRev:
  45++8F95 5E           	ld		e, (hl)
  46++8F96 23           	inc		hl
  47++8F97 56           	ld		d, (hl)
  48++8F98 23           	inc		hl
  49++8F99 D5           	push	de
  50++8F9A 10 F9        	djnz	FillScrLinesRev
  51++8F9C              FillScrLinesSPStore	EQU	$ + 1
  52++8F9C 31 00 00     	ld		sp, 0
  53++8F9F C9           	ret
  54++8FA0
  55++8FA0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++8FA0              ScrollUp:
  57++8FA0 21 2E 5B     	ld		hl, SCRLinesUp
  58++8FA3 18 03        	jr		Scroll
  59++8FA5
  60++8FA5              ScrollDown:
  61++8FA5 21 00 5B     	ld		hl, SCRLinesDown
  62++8FA8
  63++8FA8              Scroll:
  64++8FA8 22 B6 8F     	ld		(ScrollDownPtrDest), hl
  65++8FAB 23           	inc		hl
  66++8FAC 23           	inc		hl
  67++8FAD 22 B9 8F     	ld		(ScrollDownPtrSrc), hl
  68++8FB0 0E 16        	ld		c, LINE_CNT - 1
  69++8FB2
  70++8FB2              ScrollDownLoop2:
  71++8FB2 06 04        	ld		b, 4
  72++8FB4              ScrollDownPtrDest	EQU	$ + 2
  73++8FB4 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++8FB8              ScrollDownPtrSrc	EQU	$ + 1
  75++8FB8 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++8FBB
  77++8FBB              ScrollDownLoop:					;copy a single char line
  78++8FBB C5           	push	bc
  79++8FBC 01 20 00     	ld		bc, 32
  80++8FBF ED B0        	ldir
  81++8FC1 2B           	dec		hl
  82++8FC2 1B           	dec		de
  83++8FC3 24           	inc		h
  84++8FC4 14           	inc		d
  85++8FC5 01 20 00     	ld		bc, 32
  86++8FC8 ED B8        	lddr
  87++8FCA 23           	inc		hl
  88++8FCB 13           	inc		de
  89++8FCC 24           	inc		h
  90++8FCD 14           	inc		d
  91++8FCE C1           	pop		bc
  92++8FCF 10 EA        	djnz	ScrollDownLoop
  93++8FD1
  94++8FD1 0D           	dec		c
  95++8FD2 C8           	ret		z
  96++8FD3
  97++8FD3 2A B9 8F     	ld		hl, (ScrollDownPtrSrc)
  98++8FD6 22 B6 8F     	ld		(ScrollDownPtrDest), hl
  99++8FD9 23           	inc		hl
 100++8FDA 23           	inc		hl
 101++8FDB 22 B9 8F     	ld		(ScrollDownPtrSrc), hl
 102++8FDE 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 417+ 8FE0
 418+ 8FE0              CharReplaceTbl:
 419+ 8FE0 B3 80        	defb	179, 128
 420+ 8FE2 B4 81        	defb	180, 129
 421+ 8FE4 BF 82        	defb	191, 130
 422+ 8FE6 C0 83        	defb	192, 131
 423+ 8FE8 C1 84        	defb	193, 132
 424+ 8FEA C2 85        	defb	194, 133
 425+ 8FEC C3 86        	defb	195, 134
 426+ 8FEE C4 87        	defb	196, 135
 427+ 8FF0 C5 88        	defb	197, 136
 428+ 8FF2 D9 89        	defb	217, 137
 429+ 8FF4 DA 8A        	defb	218, 138
 430+ 8FF6 DB 8B        	defb	219, 139
 431+ 8FF8 DC 8C        	defb	220, 140
 432+ 8FFA              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 433+ 8FFA
 434+ 8FFA 50 72 6F 67  MsgLine		defb	'Progress:'
 434+ 8FFE 72 65 73 73
 434+ 9002 3A
 435+ 9003 20 20 20 25  MsgLinePr	defb	'   %; '
 435+ 9007 3B 20
 436+ 9009 4C 69 6E 65  			defb	'Line: '
 436+ 900D 3A 20
 437+ 900F 20 20 20 20  MsgLineNo	defb	'     ; '
 437+ 9013 20 3B 20
 438+ 9016 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 438+ 901A 61 70 20
 439+ 901D 20 4F 6E     MsgLineWrF	defb	' On'
 440+ 9020 20 30 2D 45  			defb	' 0-Exit'
 440+ 9024 78 69 74
 441+ 9027              MsgLineLen	EQU		$ - MsgLine
 442+ 9027
 443+ 9027 20 20 20 20  LineBuf		defb	'                                                                '
 443+ 902B 20 20 20 20
 443+ 902F 20 20 20 20
 443+ 9033 20 20 20 20
 443+ 9037 20 20 20 20
 443+ 903B 20 20 20 20
 443+ 903F 20 20 20 20
 443+ 9043 20 20 20 20
 443+ 9047 20 20 20 20
 443+ 904B 20 20 20 20
 443+ 904F 20 20 20 20
 443+ 9053 20 20 20 20
 443+ 9057 20 20 20 20
 443+ 905B 20 20 20 20
 443+ 905F 20 20 20 20
 443+ 9063 20 20 20 20
 444+ 9067 00 00        CurLine		defw	0
 445+ 9069 00 00        MaxLine		defw	0
 446+ 906B 01           WrapFlag	defb	1
 447+ 906C 00 00        FileBegin	defw	0
 448+ 906E 00 00        FileLen		defw	0
 449+ 9070 00 00        FileEnd		defw	0
 450+ 9072 00 00        PROGR_PERC	defw	0
 451+ 9074
 452+ 9074              SCRLinesDown	EQU $5b00
 453+ 9074              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 454+ 9074              End:
 455+ 9074
# file closed: txtview.asm
1122  9074
1123  9074              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1124  9074 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1124  9078 6F 6D 6D 61
1124  907C 6E 64 65 72
1124  9080 20 31 2E B0
1125  9084 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1125  9088 67 65 2E 63
1125  908C 68 69 72 74
1125  9090 6F 61 63 E1
1126  9094 40 67 6D 61  VerMsg3			DEFM	'@gmail.com, 202', '3' + $80
1126  9098 69 6C 2E 63
1126  909C 6F 6D 2C 20
1126  90A0 32 30 32 B3
1127  90A4 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1127  90A8 20 49 6E 66
1127  90AC 6F 20 20 20
1127  90B0 20 20 20 A0
1128  90B4 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1128  90B8 20 49 6E 66
1128  90BC 6F 20 20 20
1128  90C0 20 20 20 A0
1129  90C4 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1129  90C8 61 67 65 73
1129  90CC 20 20 20 20
1129  90D0 20 20 20 A0
1130  90D4 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1130  90D8 20 32 2D 42
1130  90DC 3A 20 33 2D
1130  90E0 56 69 65 77
1130  90E4 20 34 2D 50
1130  90E8 72 6F 70 20
1130  90EC 35 2D 43 6F
1130  90F0 70 79 20 36
1130  90F4 2D 52 65 6E
1130  90F8 20 37 2D 41
1130  90FC 74 74 72 20
1130  9100 38 2D 44 65
1130  9104 6C 20 39 2D
1130  9108 44 69 73 6B
1130  910C 20 30 2D 45
1130  9110 78 69 F4
1131  9113 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1131  9117 65 20 20 20
1131  911B 3A 20 20 20
1131  911F 20 20 20
1132  9122 C1           MsgDriveLet		DEFM	'A' + $80
1133  9123 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1133  9127 73 20 20 20
1133  912B 3A
1134  912C 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1134  9130 31 32 B8
1135  9133 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1135  9137 20 4B 42 20
1135  913B 3A
1136  913C 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1136  9140 36 33 B6
1137  9143 45 72 72 6F  MsgErr			DEFM	'Error code '
1137  9147 72 20 63 6F
1137  914B 64 65 20
1138  914E 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1138  9152 A0
1139  9153 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1139  9157 69 6E 67 20
1139  915B 50 72 6F 67
1139  915F 72 61 ED
1140  9162 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1140  9166 69 6E 67 20
1140  916A 53 43 52 45
1140  916E 45 4E A4
1141  9171 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1141  9175 69 6E 67 20
1141  9179 43 4F 44 45
1141  917D 20 28 21 A9
1142  9181 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1142  9185 20 4C 65 6E
1142  9189 3A
1143  918A 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'B' + $80
1143  918E 30 20 C2
1144  9191 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1144  9195 69 62 20 20
1144  9199 3A
1145  919A 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1145  919E 48 49 C4
1146  91A1 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1146  91A5 54 79 70 65
1146  91A9 3A
1147  91AA 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1147  91AE 20 20 20 20
1147  91B2 20 A0
1148  91B4 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1148  91B8 72 61 ED
1149  91BB 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1149  91BF 73 20 A0
1150  91C2 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1150  91C6 45 4E A4
1151  91C9 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1151  91CD 41 72 F2
1152  91D0 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1152  91D4 41 72 F2
1153  91D7 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1153  91DB 20 20 A0
1154  91DE 4E 2F 41 20  MsgFileTypeUnkn	DEFM	'N/A   ', ' ' + $80
1154  91E2 20 20 A0
1155  91E5 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1155  91E9 74 68 20 20
1155  91ED 3A
1156  91EE 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1156  91F2 35 20 C2
1157  91F5 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1157  91F9 74 20 20 20
1157  91FD 3A
1158  91FE 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1158  9202 35 20 A0
1159  9205 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1159  9209 69 6E 67 20
1159  920D 68 65 61 64
1159  9211 65 F2
1160  9213 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1160  9217 20 20 20 20
1160  921B 20 20 20 20
1160  921F 20 20 20 A0
1161  9223 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1161  9227 66 69 6C 65
1161  922B 20 28 79 2F
1161  922F 6E 29 BF
1162  9232 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1162  9236 52 2F 4F 20
1162  923A 28 79 2F 6E
1162  923E 29 BF
1163  9240 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1163  9244 48 49 44 20
1163  9248 28 79 2F 6E
1163  924C 29 BF
1164  924E 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1164  9252 2C 6E 6F 6E
1164  9256 65 3D 61 62
1164  925A 6F 72 74 BA
1165  925E 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1165  9262 69 6E 67 20
1165  9266 74 6F 20
1166  9269 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1167  926B 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1167  926F 20 6F 70 74
1167  9273 69 6F 6E 73
1167  9277 BA
1168  9278 31 2E 46 6F  MsgMenu1		DEFM	'1.Format disk '
1168  927C 72 6D 61 74
1168  9280 20 64 69 73
1168  9284 6B 20
1169  9286 41 BA        MsgMenu1Drv		DEFM	'A', ':' | $80
1170  9288 32 2E 43 6F  MsgMenu2		DEFM	'2.Copy disk '
1170  928C 70 79 20 64
1170  9290 69 73 6B 20
1171  9294 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1172  9296 33 2E 45 78  MsgMenu3		DEFM	'3.Exit men', 'u' | $80
1172  929A 69 74 20 6D
1172  929E 65 6E F5
1173  92A1 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1173  92A5 61 74 74 69
1173  92A9 6E 67 20
1174  92AC 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1175  92AE 30 30 30 20  MsgBlocksLeft	DEFB	'000 blocks lef', 't' | $80
1175  92B2 62 6C 6F 63
1175  92B6 6B 73 20 6C
1175  92BA 65 66 F4
1176  92BD
1177  92BD              	ifndef	_ROM_FNT_
1178  92BD              FontTable:
1179  92BD              	incbin "cpmfnt.bin"
1180  92BD              	endif
1181  9625              EndCode:
1182  9625
1183  9625              ;Unalocated variables
1184  9625              UnallocStart	EQU		$
1185  9625              FileCnt			EQU		$						;File counter, 1B
1186  9625              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1187  9625              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1188  9625              CursorAddr		EQU		SelFile + 1				;2 B
1189  9625              AUCnt			EQU		CursorAddr + 2			;2 B
1190  9625              SelFileCache	EQU		AUCnt + 2				;2 B
1191  9625
1192  9625
1193  9625              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1194  9625              	IFDEF	_ROM_FNT_
1195  9625 ~            FontTable		EQU		FileCache + LST_MAX_FILES*CACHE_SZ
1196  9625 ~            TrackBuf		EQU		FontTable + 872						;size = 16 * 256 = 4096
1197  9625              	ELSE
1198  9625              TrackBuf		EQU		FileCache + LST_MAX_FILES*CACHE_SZ	;size = 16 * 256 = 4096
1199  9625              	ENDIF
1200  9625              DataBuf			EQU		TrackBuf + SPT*SECT_SZ
1201  9625
1202  9625              CopyFileFCBSrc	EQU	DataBuf
1203  9625              CopyFileFCBDst	EQU	DataBuf + 2
1204  9625              CopyFileResRead	EQU DataBuf + 4
1205  9625              CopyFileResWrite EQU DataBuf + 5
1206  9625              CopyFileDMAAddr	EQU	DataBuf + 6
1207  9625              CopyFileDMA		EQU	DataBuf + 8
1208  9625
1209  9625              TheEnd			EQU		DataBuf
1210  9625              FileIdx			EQU		DataBuf
1211  9625              FileData		EQU		DataBuf + 2048
1212  9625
1213  9625              ;Copy buffer size
1214  9625              ;We can use up to about 30KB free space if we load at address 24000.
1215  9625              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1216  9625              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1217  9625              MAX_KB_FREE		EQU		15 * 1024
1218  9625              MAX_AU_RAM		EQU		MAX_KB_FREE/AU_SZ
1219  9625              MAX_SECT_RAM	EQU		MAX_KB_FREE/SECT_SZ
1220  9625
1221  9625              UsedBlockListCnt	EQU	DataBuf
1222  9625              UsedBlockListBlk	EQU	DataBuf + 2
1223  9625              UsedBlockListSz		EQU 320 * 2
1224  9625              CopyDiskBuf			EQU DataBuf + 2 + UsedBlockListSz
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x8748   NoSub
0x8741   DivLoop
0x0280   UsedBlockListSz
0x3C00   MAX_KB_FREE
0xAF2A X TheEnd
0x9074 X End
0x9069 X MaxLine
0x9016 X MsgLineWrap
0x8FBB   ScrollDownLoop
0x8FB2   ScrollDownLoop2
0x8FB9   ScrollDownPtrSrc
0x8FB6   ScrollDownPtrDest
0x8FA8   Scroll
0x8F95   FillScrLinesRev
0x5B2E   SCRLinesUp
0x8F9D   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x8F78   FillScrLinesPtr
0x8F77   FillScrLinesLoop
0x8F68   GetCellDown
0x8F63   ReplaceMatch
0x8F57   ReplaceSGCLoop
0x000D   CharReplTblLen
0x8FE0   CharReplaceTbl
0x002D   MsgLineLen
0x8FFA   MsgLine
0x900F   MsgLineNo
0x9003   MsgLinePr
0x8EFA   GetLineFillLoop
0x8ED7   GetLineFill
0x8F50   ReplaceChars
0x8EC3   Valid
0x8EC0   NotValid
0x8EC7   GetLineSkip0D
0x8EB6   GetLineNext
0x8ED0   GetLineSkip0A
0x8EA1   GetLineLoop
0x8E82   PrintStrTxt
0x9027   LineBuf
0x8FA5   ScrollDown
0x8FA0   ScrollUp
0x8E53   CheckBegin
0x901D   MsgLineWrF
0x8DE4   NoWrap
0x906B   WrapFlag
0x8DF3   Up
0x8E1E   Down
0x8D9E   GetKey
0x8DB5   PrintLoop2
0x8DAD   EOF
0x8E63   CheckEnd
0x8E6E   PrintLine
0x8E9C   GetLine
0xAF2A   FileIdx
0x8F01   PrintMsg
0x9072   PROGR_PERC
0x9067   CurLine
0x8F72   ScrollInit
0x906E   FileLen
0x9070   FileEnd
0x906C   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x8D0D   ReadStrPrint
0x8CFD   ReadStrChar
0x8CE0   ReadStringLoop
0x8CD4   Store
0x8CD3   NoTurn
0x8CC8   PrintCharLine
0x92BD   FontTable
0x8CB4 X PrintChar3
0x8C5F   DrawCursorLoop
0x8C3F   DrawVLinesLoop
0x8C52   PrintChar2
0x8C1D   DrawUpLine
0x8C1F   ChrParam
0x8C10 X DrawHLine
0x8BFF   DrawLineLoop
0x8C0C   LineDir
0x8BFC   StoreDir
0x8BFA   VertDir
0x8BF1   DrawLine
0x8BED   StrClr
0x8BA0   GoodChar
0x8D1C   CurrScrAddr
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB X CPM_FNT
0xAF2F   CopyFileResWrite
0x8B3A   FileCopyWriteLoop
0x8B2A   FileCopyWrite
0xAF2E   CopyFileResRead
0x8B0C   FileCopyReadLoop
0xAF32   CopyFileDMA
0xAF30   CopyFileDMAAddr
0x003C   MAX_SECT_RAM
0x8AFE   FileCopyLoop
0xAF2C   CopyFileFCBDst
0x8B58   CopyFileEnd
0xAF2A   CopyFileFCBSrc
0x8AA6 X FileAttribSet
0x8A75   BDOSSetDMA
0x8A75 X BDOSFindNext
0x8A75 X BDOSFindFirst
0x8A67   WriteFileBlock
0x8A63   ReadFileBlock
0x8A5F   CloseFile
0x8A5B   OpenFile
0x8A57   CreateFile
0x8A4D   DestroyChannel
0x8A37   CreateChannel
0x8A37 X BDOSGetCurrentDisk
0x8A37 X BDOSGetDiskRO
0x8A37 X BDOSMakeDiskRO
0x8A6B   BDOS
0x8A26 X RWTSResTmp
0x8A25 X RWTSResVolNo
0x8A21 X RWTSPrmTbl
0x8A1F X RWTSExtBuf
0x8A1C X RWTSSector
0x8A1A X RWTSVolNo
0x8A18 X RWTSBlockType
0x8A0F   CopyMsg
0x8A03   SearchMsgEnd
0x8A0C   SaveMsg
0x89FA   IF1Paged
0x89C5   IF1Call
0x89C1   ReadHeaderEnd
0x898D   CacheNotFinished
0x8A2B   BDOSInit
0x8A2E   BDOSSelectDisk
0x892A   FileReadLoop
0x891E X FileLoadHeader
0x8930   FileLoadNoHeader
0x893E   FileFree
0x88FA   MisMatch
0x88F2   Compare
0x88F0   StrCmp
0x88BE   CopyDiskLoopWriteLoop
0x8898   CopyDiskLoopReadLoop
0xB1AC   CopyDiskBuf
0x8891   CopyDiskLoopRead
0x0007   MAX_AU_RAM
0x92AE   MsgBlocksLeft
0x886E   CopyDiskLoop
0xAF2C   UsedBlockListBlk
0x8956   WriteDiskSectors
0x8863 X WriteFSBlockLoop
0x885A   WriteFSBlock
0x8943   ReadDiskSectors
0x8856 X ReadFSBlockLoop
0x884D   ReadFSBlock
0x883F   ReadUsedBlocksSkip
0x8822   ReadUsedBlocksLoop2
0x8842   ReadUsedBlocksSkip2
0x8812   ReadUsedBlocksLoop
0xAF2A   UsedBlockListCnt
0x87F5   ReadUsedBlocksList
0x87EE   CheckAUEnd
0x87DA   CheckAU
0x87C3   FirstAU
0x87BD   Track0
0x87A8   AU2TS
0x8A24   RWTSRes
0x878C   WriteOneDiskSector
0x8A1B   RWTSTrack
0x8A1D   RWTSDMA
0x8781   ReadOneDiskSector
0x8A18   RWTSParams
0x8A23   RWTSCmd
0x8775   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022 X FCB_R1
0x0021 X FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x001B X EOF_MARKER
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x876F   NoAdd
0x8769   MulLoop
0x8750   Div2Loop
0x874B   Div2
0x873E   Div
0x8735   DivNrLoop
0x8733   DigitLoop
0x8724   Byte2Txt_
0x870D   StrippLeading0
0x8718   Word2Txt_
0xC000 X HC_VID_BANK1
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0008   HC_CFG_VID_C000
0x0000   HC_CFG_VID_4000
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x007E X HC_CFG_PORT
0x86F4   DontInc
0x86E8   ReadAllHeadersEnd
0x86D3   AKey
0x8B76   KbdHit
0x86B8   NextFile
0x91E5   MsgFileLen
0x91A1   MsgFileType
0x91F5   MsgFileStart
0x8677   PrintStartStr
0x91FE   MsgFileStartN
0x91DE   MsgFileTypeUnkn
0x8669   PrintStart
0x0007   HDR_LINE
0x8644   PrintByteStart
0x863C   PrintProgStart
0x91EE   MsgFileLenN
0x8655   NoHeader
0x91D7   MsgFileTypeText
0x91BB   MsgFileTypeByte
0x91C2   MsgFileTypeSCR
0x8606   NotScr
0x8611   CheckText
0x91C9   MsgFileTypeChrA
0x85E9   CheckByte
0x0002   CHAR_TYPE
0x91D0   MsgFileTypeNoA
0x85DA   CheckChrArr
0x0001   NUMB_TYPE
0x861C   PrepFileLen
0x8695   MoveMsg
0x91AA   MsgFileTypeN
0x91B4   MsgFileTypePrg
0x85CB   CheckNoArr
0x000B   CACHE_FIRST_AU
0x864C   HeadNotRead
0x9191   MsgFileAttr
0x859C   AttrEnd
0x8590   NotSYS
0x857C   CheckSys
0x856A   NotRO
0x919A   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x865E   PrintStartNotRead
0x9181   MsgFileSzDsk
0x8538   MultKb
0x918A   MsgFileSzDskN
0x8D7A   PrintLoop
0x8D20   InitViewer
0xB72A   FileData
0x89CB   LoadProgram
0x9153   MsgLoadingPrg
0x4000   HC_VID_BANK0
0x9162   MsgLoadingSCR
0x0003   HDR_ADDR
0x893E   IF1FileLoadEnd
0x5B00   PRN_BUF
0x88FD   IF1FileLoad
0x9171   MsgLoadingCODE
0x84B9 X HandleFileCODE
0x84E2   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x8508   HandleFileText
0x0003   BYTE_TYPE
0x84F8   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x8483   FindExtEnd
0x8982   FindCache
0x8492   GetFileNamesEnd
0x005C   LST_MAX_FILES
0x0009   HDR_SZ
0x845E   FindExt
0x000C   EXT_IDX
0x87C6   CheckExtAlloc
0x8485   NextExt
0x0000   EXT_DEL_FLAG
0x8405   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x83EC   DisplayFilenamesLoop
0x83E5 X DisplayFilenames
0x83DB   LineOK
0x5CB1   LINE
0x5CB0   COL
0x8C9C   PrintChar
0x5C81   CODE
0x83B5   DispLoop
0x83B3   DisplayFilename
0x8C64   MoveCursor
0x8867   CopyDisk
0x8797   FormatDisk
0x92A1   MsgFormat
0x8399   CheckExtra2
0x83A2   ExtraMenuExit
0x9296   MsgMenu3
0x9288   MsgMenu2
0x9278   MsgMenu1
0x832A   CheckKeyExtraMenu
0x9294   MsgMenu2Drv
0x92AC   MsgFormatDrv
0x9286   MsgMenu1Drv
0x926B   MsgMenu0
0x83A5   CheckKeyExit
0x8A85   ChangeFileAttrib
0x82FD   AttrChange
0x9240   MsgSetSYS
0x82E5   CheckSYS
0x9232   MsgSetRO
0x830C   CheckKeyExtra
0x8A79   DeleteFile
0x82BE   DoFileDelete
0x9223   MsgDelete
0x82CB   CheckKeyAttrib
0x8AAF   RenameFile
0x828C   RenameCanceled
0x8CDA   ReadString
0x000B   NAMELEN
0x924E   MsgNewFileName
0x829A   CheckKeyDel
0x8509   ViewFile
0x824B   CheckKeyRename
0x0001   DRIVE_B_CPM
0x8241   CheckKeyView
0x8306   SelectDrive
0x8238   CheckKeyDriveB
0x869B   ReadAllHeaders
0x822F   CheckKeyDriveA
0x8222   CopyFileOK
0x8AD2   CopyFile
0x925E   MsgCopyFile
0x9269   MsgCopyFileDrv
0x8225   CheckKeyFileInfo
0x9213   MsgClear
0x8993   ReadFileHeader
0x9205   MsgReadingExt
0x81E8   CheckKeyCopy
0x8493   HandleFile
0x81C4   CheckKeyInfo
0x000D   KEY_ENTER
0x81B9   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x81A8   CheckLeft
0x0009   KEY_RIGHT
0x8192   CheckRight
0x000B   KEY_UP
0x83AD   MoveIt
0x8181   CheckUp
0x000A   KEY_DOWN
0x8526   DisplayFileInfo
0x962C   SelFileCache
0x962E   FileCache
0x875E   Mul
0x0019   CACHE_SZ
0x8152   CalcFileCache
0x9133   MsgFreeSpace
0x86F7   Word2Txt
0x913C   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x9123   MsgFilesCnt
0x912C   MsgFilesCntNo
0x9113   MsgDrive
0x9122   MsgDriveLet
0x89E4   SetFastKeys
0x8C59   DrawCursor
0x0028   SCR_SEL_CLR
0x962A   AUCnt
0x5CB0   LineCol
0x90C4   MsgMessages
0x0007   LST_FILE_INFO
0x90B4   MsgFileInf
0x0003   LST_DISK_INFO
0x90A4   MsgDskInf
0x9094   VerMsg3
0x9084   VerMsg2
0x8B99   PrintStr
0x9074   VerMsg1
0x90D4   BtnBar
0x0028   SCR_LBL_CLR
0x8C3A   DrawVLines
0x0084   CHR_DC
0x8B79   ClrScr
0x9628   CursorAddr
0x8D1E   CurrScrAttrAddr
0x0000   LST_FIRST_LINE
0x0020   SCR_BYTES_PER_LINE
0x9626   NameCol
0x0010   LST_FIRST_COL
0x9625   FileCnt
0x9627   SelFile
0xAF2A   DataBuf
0x89EF   GetErrMsg
0x5C3A   ERRNR
0x8051   HCRunEnd
0x8163   ReadKeyLoop
0x8109   DisplayDiskInfo
0x83FC   GetFileNames
0x8089   InitUI
0x8A19   RWTSDrive
0x0000   DRIVE_A_CPM
0x8B73   ReadChar
0x8BC1   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x9143   MsgErr
0x8702   Byte2Txt
0x914E   MsgErrCode
0x8045   HCRunMain
0x8969   ReadCatalogTrack
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x9F2A   TrackBuf
0x9625   UnallocStart
0x800F   HCRunInitDisk
0x8057   ErrorHandler
0x5C3D   ERRSP
0x8772   IF1Init
0x9625   EndCode
0x7FF1   Mover
0x8000   Start
