# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 25000
  12  61A8
  13  61A8              Start:
  14  61A8              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  61A8 CD E2 71     		call InitFonts
  16  61AB              	ENDIF
  17  61AB CD 03 6A     	call IF1Init
  18  61AE
  19  61AE              	;install error handler
  20  61AE 2A 3D 5C     	ld		hl, (ERRSP)
  21  61B1 E5           	push	hl
  22  61B2 21 0D 62     	ld		hl, ErrorHandler
  23  61B5 E5           	push	hl
  24  61B6 ED 73 3D 5C  	ld		(ERRSP), sp
  25  61BA
  26  61BA              HCRunInitDisk:
  27  61BA              	;Set track buffer to del marker
  28  61BA 21 CB 88     	ld		hl, TrackBuf
  29  61BD 54           	ld		d, h
  30  61BE 5D           	ld		e, l
  31  61BF 13           	inc		de
  32  61C0 01 00 10     	ld		bc, SPT*SECT_SZ
  33  61C3 36 E5        	ld		(hl), DEL_MARKER
  34  61C5 ED B0        	ldir
  35  61C7
  36  61C7              	;Invalidate file cache
  37  61C7 21 AD 7A     	ld		hl, FileCache
  38  61CA 54           	ld		d, h
  39  61CB 5D           	ld		e, l
  40  61CC 13           	inc		de
  41  61CD 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  61D0 36 00        	ld		(hl), 0
  43  61D2 ED B0        	ldir
  44  61D4
  45  61D4              	;main program
  46  61D4 CD F0 6C     	call 	ReadCatalogTrack
  47  61D7 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  61D8 28 1E        	jr		z, HCRunCacheFiles
  49  61DA
  50  61DA 6F           	ld		l, a
  51  61DB 26 00        	ld		h, 0
  52  61DD 11 CB 78     	ld		de, MsgErrCode
  53  61E0 CD 93 69     	call	Byte2Txt
  54  61E3 21 C0 78     	ld		hl, MsgErr
  55  61E6 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  56  61E9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  61EB CD 40 72     	call	PrintStrClr
  58  61EE CD DC 71     	call	ReadChar
  59  61F1 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  61F3 32 CC 6D     	ld		(RWTSDrive), a
  61  61F6 18 C2        	jr		HCRunInitDisk
  62  61F8
  63  61F8              HCRunCacheFiles:
  64  61F8 CD 74 66     	call 	GetFileNames
  65  61FB
  66  61FB              HCRunMain:
  67  61FB CD 3F 62     	call 	InitUI
  68  61FE CD 54 66     	call	DisplayFilenames
  69  6201 CD BD 62     	call	DisplayDiskInfo
  70  6204 C3 17 63     	jp		ReadKeyLoop
  71  6207
  72  6207              HCRunEnd:
  73  6207              	;restore error handler
  74  6207 E1           	pop		hl
  75  6208 E1           	pop		hl
  76  6209 22 3D 5C     	ld		(ERRSP), hl
  77  620C
  78  620C C9           	ret
  79  620D
  80  620D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  81  620D
  82  620D              ErrorHandler:
  83  620D E1           	pop		hl
  84  620E 22 3D 5C     	ld		(ERRSP), hl
  85  6211
  86  6211 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  87  6214 6F           	ld		l, a
  88  6215 26 00        	ld		h, 0
  89  6217 11 CB 78     	ld		de, MsgErrCode
  90  621A CD 93 69     	call	Byte2Txt
  91  621D 21 C0 78     	ld		hl, MsgErr
  92  6220 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  93  6223 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  94  6225 CD 40 72     	call	PrintStrClr
  95  6228
  96  6228 3A 3A 5C     	ld		a, (ERRNR)
  97  622B CD A5 6D     	call	GetErrMsg
  98  622E
  99  622E 21 CB 88     	ld		hl, DataBuf
 100  6231 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 101  6234 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 102  6236 CD 40 72     	call	PrintStrClr
 103  6239
 104  6239 CD DC 71     	call	ReadChar
 105  623C C3 A8 61     	jp	Start
 106  623F
 107  623F
 108  623F
 109  623F
 110  623F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 111  623F
 112  623F              InitUI:
 113  623F AF           	xor		a
 114  6240 32 A6 7A     	ld		(SelFile), A
 115  6243 3E 11        	ld		a, LST_FIRST_COL + 1
 116  6245 32 A5 7A     	ld		(NameCol), A
 117  6248 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 118  624B ED 53 B0 5C  	ld		(LineCol), de
 119  624F
 120  624F CD F8 71     	call	ClrScr
 121  6252
 122  6252 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 123  6255 ED 4B EF 73  	ld		bc, (CurrScrAttrAddr)
 124  6259 09           	add		hl, bc
 125  625A 22 A7 7A     	ld		(CursorAddr), hl
 126  625D
 127  625D CD FF 72     	call	DrawVLines
 128  6260
 129  6260 CD 8F 72     	call	DrawHLines
 130  6263
 131  6263 21 F1 77     	ld		hl, VerMsg1
 132  6266 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 133  6269 3A 00 78     	ld		a, (VerMsg1 + 15)
 134  626C F6 80        	or		$80
 135  626E 32 00 78     	ld		(VerMsg1 + 15), a
 136  6271 CD 18 72     	call	PrintStr
 137  6274 21 01 78     	ld		hl, VerMsg2
 138  6277 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 139  627A CD 18 72     	call	PrintStr
 140  627D
 141  627D 3E 20        	ld		a, SCR_LBL_CLR
 142  627F 11 00 17     	ld		de, 23 << 8
 143  6282 21 51 78     	ld		hl, BtnBar
 144  6285 CD 40 72     	call	PrintStrClr
 145  6288
 146  6288 3E 20        	ld		a, SCR_LBL_CLR
 147  628A 21 11 78     	ld		hl, MsgSysInf
 148  628D 11 00 01     	ld		de, LST_PROG_INFO << 8
 149  6290 CD 40 72     	call	PrintStrClr
 150  6293
 151  6293 3E 20        	ld		a, SCR_LBL_CLR
 152  6295 21 21 78     	ld		hl, MsgDskInf
 153  6298 11 00 04     	ld		de, LST_DISK_INFO << 8
 154  629B CD 40 72     	call	PrintStrClr
 155  629E
 156  629E 3E 20        	ld		a, SCR_LBL_CLR
 157  62A0 21 31 78     	ld		hl, MsgFileInf
 158  62A3 11 00 08     	ld		de, LST_FILE_INFO << 8
 159  62A6 CD 40 72     	call	PrintStrClr
 160  62A9
 161  62A9 3E 20        	ld		a, SCR_LBL_CLR
 162  62AB 21 41 78     	ld		hl, MsgMessages
 163  62AE 11 00 0E     	ld		de, LST_LINE_MSG << 8
 164  62B1 CD 40 72     	call	PrintStrClr
 165  62B4
 166  62B4 3E 20        	ld		a, SCR_SEL_CLR
 167  62B6 CD 17 73     	call	DrawCursor
 168  62B9
 169  62B9 CD 9A 6D     	call	SetFastKeys
 170  62BC
 171  62BC C9           	ret
 172  62BD
 173  62BD
 174  62BD              DisplayDiskInfo:
 175  62BD 3A CC 6D     	ld		a, (RWTSDrive)
 176  62C0 C6 C1        	add		'A' + $80
 177  62C2 32 9F 78     	ld		(MsgDriveLet), a
 178  62C5 21 90 78     	ld		hl, MsgDrive
 179  62C8 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 180  62CB CD 18 72     	call	PrintStr
 181  62CE
 182  62CE 3A A4 7A     	ld		a, (FileCnt)
 183  62D1 6F           	ld		l, a
 184  62D2 26 00        	ld		h, 0
 185  62D4 11 A9 78     	ld		de, MsgFilesCntNo
 186  62D7 CD 93 69     	call	Byte2Txt
 187  62DA 21 A0 78     	ld		hl, MsgFilesCnt
 188  62DD 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 189  62E0 CD 18 72     	call	PrintStr
 190  62E3
 191  62E3 ED 5B A9 7A  	ld		de, (AUCnt)
 192  62E7 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 193  62EA B7           	or		a
 194  62EB ED 52        	sbc		hl, de
 195  62ED CB 15        	rl		l								;*2, 2K/AU
 196  62EF CB 14        	rl		h
 197  62F1 11 B7 78     	ld		de, MsgFreeSpaceNo - 2
 198  62F4 CD 88 69     	call	Word2Txt
 199  62F7 3E 3A        	ld		a, ':'
 200  62F9 32 B8 78     	ld		(MsgFreeSpaceNo -1), a
 201  62FC 21 B0 78     	ld		hl, MsgFreeSpace
 202  62FF 11 00 07     	ld		de, LST_DISK_INFO + 3 << 8
 203  6302 CD 18 72     	call	PrintStr
 204  6305
 205  6305 C9           	ret
 206  6306
 207  6306              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 208  6306
 209  6306              CalcFileCache:
 210  6306 3A A6 7A     	ld		a, (SelFile)
 211  6309 11 19 00     	ld		de, CACHE_SZ
 212  630C CD EF 69     	call	Mul
 213  630F 01 AD 7A     	ld		bc, FileCache
 214  6312 09           	add		hl, bc					;HL = file AU cnt
 215  6313 22 AB 7A     	ld		(SelFileCache), hl
 216  6316 C9           	ret
 217  6317
 218  6317              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 219  6317
 220  6317
 221  6317              ReadKeyLoop:
 222  6317 CD 06 63     	call	CalcFileCache
 223  631A CD BA 67     	call	DisplayFileInfo
 224  631D
 225  631D CD DC 71     	call	ReadChar
 226  6320
 227  6320 FE 0A        	cp		KEY_DOWN
 228  6322 28 04        	jr		z,  DoKeyDown
 229  6324 FE 61        	cp 		'a'
 230  6326 20 11        	jr		nz, CheckUp
 231  6328
 232  6328              DoKeyDown:
 233  6328 3A A4 7A     	ld		a, (FileCnt)
 234  632B 47           	ld		b, a
 235  632C 3A A6 7A     	ld		a, (SelFile)
 236  632F 3C           	inc		a
 237  6330 B8           	cp		b
 238  6331 30 E4        	jr		nc, ReadKeyLoop
 239  6333 32 A6 7A     	ld		(SelFile), a
 240  6336 C3 1C 66     	jp		MoveIt
 241  6339
 242  6339              CheckUp:
 243  6339 FE 0B        	cp		KEY_UP
 244  633B 28 04        	jr		z, DoKeyUp
 245  633D FE 71        	cp 		'q'
 246  633F 20 0D        	jr		nz, CheckRight
 247  6341
 248  6341              DoKeyUp:
 249  6341 3A A6 7A     	ld		a, (SelFile)
 250  6344 B7           	or		a
 251  6345 28 D0        	jr		z, ReadKeyLoop
 252  6347
 253  6347 3D           	dec		a
 254  6348 32 A6 7A     	ld		(SelFile), a
 255  634B C3 1C 66     	jp		MoveIt
 256  634E
 257  634E              CheckRight:
 258  634E FE 09        	cp		KEY_RIGHT
 259  6350 28 04        	jr		z, DoKeyRight
 260  6352 FE 70        	cp 		'p'
 261  6354 20 12        	jr		nz, CheckLeft
 262  6356
 263  6356              DoKeyRight:
 264  6356 3A A4 7A     	ld		a, (FileCnt)
 265  6359 47           	ld		b, a
 266  635A 3A A6 7A     	ld		a, (SelFile)
 267  635D C6 15        	add		LST_LINES_CNT
 268  635F B8           	cp		b
 269  6360 30 B5        	jr		nc, ReadKeyLoop
 270  6362
 271  6362 32 A6 7A     	ld		(SelFile), a
 272  6365 C3 1C 66     	jp		MoveIt
 273  6368
 274  6368              CheckLeft:
 275  6368 FE 08        	cp		KEY_LEFT
 276  636A 28 04        	jr		z, DoKeyLeft
 277  636C FE 6F        	cp		'o'
 278  636E 20 0D        	jr		nz, CheckEnter
 279  6370
 280  6370              DoKeyLeft:
 281  6370 3A A6 7A     	ld		a, (SelFile)
 282  6373 D6 15        	sub		LST_LINES_CNT
 283  6375 38 A0        	jr		c, ReadKeyLoop
 284  6377
 285  6377 32 A6 7A     	ld		(SelFile), a
 286  637A C3 1C 66     	jp		MoveIt
 287  637D
 288  637D              CheckEnter:
 289  637D FE 0D        	cp		KEY_ENTER
 290  637F 28 05        	jr		z, DoKeyEnter
 291  6381 FE 6D        	cp		'm'
 292  6383 C2 8C 63     	jp		nz, CheckKeyInfo
 293  6386
 294  6386              DoKeyEnter:
 295  6386 CD 0D 67     	call	HandleFile
 296  6389 C3 FB 61     	jp		HCRunMain
 297  638C
 298  638C              CheckKeyInfo:
 299  638C FE 34        	cp		'4'
 300  638E 20 27        	jr		nz, CheckKeyCopy
 301  6390
 302  6390 3A A4 7A     	ld		a, (FileCnt)
 303  6393 B7           	or		a
 304  6394 CA 17 63     	jp		z, ReadKeyLoop
 305  6397
 306  6397 DD 2A AB 7A  	ld		ix, (SelFileCache)
 307  639B 21 81 79     	ld		hl, MsgReadingExt
 308  639E 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 309  63A1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 310  63A3 CD 40 72     	call	PrintStrClr
 311  63A6 CD 1A 6D     	call	ReadFileHeader
 312  63A9 21 8F 79     	ld		hl, MsgClear
 313  63AC 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
 314  63AF 3E 45        	ld		a, SCR_DEF_CLR
 315  63B1 CD 40 72     	call	PrintStrClr
 316  63B4 C3 17 63     	jp		ReadKeyLoop
 317  63B7
 318  63B7              CheckKeyCopy:
 319  63B7 FE 35        	cp		'5'
 320  63B9 C2 00 64     	jp		nz, CheckKeyFileInfo
 321  63BC
 322  63BC 3A A4 7A     	ld		a, (FileCnt)
 323  63BF B7           	or		a
 324  63C0 CA 17 63     	jp		z, ReadKeyLoop
 325  63C3
 326  63C3 2A AB 7A     	ld		hl, (SelFileCache)
 327  63C6 CD 13 6F     	call	CopyFile
 328  63C9 3A CD 88     	ld		a, (CopyFileRes)
 329  63CC B7           	or		a
 330  63CD 28 1A        	jr		z, CopyFileOK
 331  63CF
 332  63CF 6F           	ld		l, a
 333  63D0 26 00        	ld		h, 0
 334  63D2 11 CB 78     	ld		de, MsgErrCode
 335  63D5 CD 93 69     	call	Byte2Txt
 336  63D8 21 C0 78     	ld		hl, MsgErr
 337  63DB 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 338  63DE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 339  63E0 CD 40 72     	call	PrintStrClr
 340  63E3 CD DC 71     	call	ReadChar
 341  63E6 C3 17 63     	jp		ReadKeyLoop
 342  63E9
 343  63E9              CopyFileOK:
 344  63E9 06 02        	ld		b, 2
 345  63EB CD DA 73     	call	ClearNMsgLines
 346  63EE              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 347  63EE 3A AD 7A     	ld		a, (CopySelOption)
 348  63F1 FE 33        	cp		'3'
 349  63F3 CA 17 63     	jp		z, ReadKeyLoop
 350  63F6 3A E6 88     	ld		a, (CopyFileDst)
 351  63F9 3D           	dec		a
 352  63FA 32 CC 6D     	ld		(RWTSDrive), a
 353  63FD C3 BA 61     	jp		HCRunInitDisk
 354  6400
 355  6400              CheckKeyFileInfo:
 356  6400 FE 20        	cp		' '
 357  6402 20 0D        	jr		nz, CheckKeyDriveA
 358  6404
 359  6404 3A A4 7A     	ld		a, (FileCnt)
 360  6407 B7           	or		a
 361  6408 CA 17 63     	jp		z, ReadKeyLoop
 362  640B
 363  640B CD 2C 69     	call	ReadAllHeaders
 364  640E C3 17 63     	jp		ReadKeyLoop
 365  6411
 366  6411              CheckKeyDriveA:
 367  6411 FE 31        	cp		'1'
 368  6413 20 05        	jr		nz, CheckKeyDriveB
 369  6415 3E 00        	ld		a, DRIVE_A_CPM
 370  6417 C3 2F 65     	jp		SelectDrive
 371  641A
 372  641A              CheckKeyDriveB:
 373  641A FE 32        	cp		'2'
 374  641C 20 05        	jr		nz, CheckKeyView
 375  641E 3E 01        	ld		a, DRIVE_B_CPM
 376  6420 C3 2F 65     	jp		SelectDrive
 377  6423
 378  6423              CheckKeyView:
 379  6423 FE 33        	cp		'3'
 380  6425 20 0D        	jr		nz, CheckKeyRename
 381  6427
 382  6427 3A A4 7A     	ld		a, (FileCnt)
 383  642A B7           	or		a
 384  642B CA 17 63     	jp		z, ReadKeyLoop
 385  642E
 386  642E CD 8B 67     	call	ViewFile
 387  6431 C3 FB 61     	jp		HCRunMain
 388  6434
 389  6434              CheckKeyRename:
 390  6434 FE 36        	cp		'6'
 391  6436 20 7D        	jr		nz, CheckKeyDel
 392  6438
 393  6438 3A A4 7A     	ld		a, (FileCnt)
 394  643B B7           	or		a
 395  643C CA 17 63     	jp		z, ReadKeyLoop
 396  643F
 397  643F 21 C4 79     	ld		hl, MsgNewFileName
 398  6442 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 399  6445 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 400  6447 CD 40 72     	call	PrintStrClr
 401  644A
 402  644A 21 8F 79     	ld		hl, MsgClear
 403  644D 11 CB 89     	ld		de, FileData
 404  6450 01 0B 00     	ld		bc, NAMELEN
 405  6453 ED B0        	ldir
 406  6455 3E A0        	ld		a, $80 | ' '
 407  6457 12           	ld		(de), a
 408  6458 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 409  645B 21 CB 89     	ld		hl, FileData
 410  645E CD 18 72     	call	PrintStr
 411  6461
 412  6461 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 413  6464 01 0B 00     	ld		bc, NAMELEN
 414  6467 CD 98 73     	call	ReadString
 415  646A
 416  646A 11 CB 89     	ld		de, FileData
 417  646D 1A           	ld		a, (de)
 418  646E FE 20        	cp		' '					;If starting with space, input was canceled.
 419  6470 CA 9C 64     	jp		z, RenameCanceled
 420  6473
 421  6473              	;Check if new name doesn't exist already. Cancel if so.
 422  6473 21 CB 89     	ld		hl, FileData
 423  6476 3A CC 6D     	ld 		a, (RWTSDrive)
 424  6479 3C           	inc		a
 425  647A CD 84 6E     	call	DoesFileExist
 426  647D 3C           	inc		a
 427  647E 28 10        	jr		z, RenameFileNotExist
 428  6480
 429  6480 21 69 7A     	ld		hl, MsgFileExists
 430  6483 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 431  6486 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 432  6488 CD 40 72     	call	PrintStrClr
 433  648B CD DC 71     	call	ReadChar
 434  648E 18 0C        	jr		RenameCanceled
 435  6490
 436  6490              RenameFileNotExist:
 437  6490 11 CB 89     	ld		de, FileData
 438  6493 2A AB 7A     	ld		hl, (SelFileCache)
 439  6496 CD BC 6E     	call	RenameFile
 440  6499 C3 BA 61     	jp		HCRunInitDisk
 441  649C
 442  649C              RenameCanceled:
 443  649C 21 8F 79     	ld		hl, MsgClear
 444  649F 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 445  64A2 3E 45        	ld		a, SCR_DEF_CLR
 446  64A4 CD 40 72     	call	PrintStrClr
 447  64A7 21 8F 79     	ld		hl, MsgClear
 448  64AA 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 449  64AD 3E 45        	ld		a, SCR_DEF_CLR
 450  64AF CD 40 72     	call	PrintStrClr
 451  64B2 C3 17 63     	jp		ReadKeyLoop
 452  64B5
 453  64B5              CheckKeyDel:
 454  64B5 FE 38        	cp		'8'
 455  64B7 20 34        	jr		nz, CheckKeyAttrib
 456  64B9
 457  64B9 3A A4 7A     	ld		a, (FileCnt)
 458  64BC B7           	or		a
 459  64BD CA 17 63     	jp		z, ReadKeyLoop
 460  64C0
 461  64C0 21 9F 79     	ld		hl, MsgDelete
 462  64C3 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 463  64C6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 464  64C8 CD 40 72     	call	PrintStrClr
 465  64CB CD DC 71     	call	ReadChar
 466  64CE FE 79        	cp		'y'
 467  64D0 28 0E        	jr		z, DoFileDelete
 468  64D2 21 8F 79     	ld		hl, MsgClear
 469  64D5 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 470  64D8 3E 45        	ld		a, SCR_DEF_CLR
 471  64DA CD 40 72     	call	PrintStrClr
 472  64DD C3 17 63     	jp		ReadKeyLoop
 473  64E0              DoFileDelete:
 474  64E0 2A AB 7A     	ld		hl, (SelFileCache)
 475  64E3 3A CC 6D     	ld 		a, (RWTSDrive)
 476  64E6 3C           	inc		a					;Convert to BASIC drive number: 1,2
 477  64E7 CD 78 6E     	call	DeleteFile
 478  64EA C3 BA 61     	jp		HCRunInitDisk
 479  64ED
 480  64ED              CheckKeyAttrib:
 481  64ED FE 37        	cp		'7'
 482  64EF 20 44        	jr		nz, CheckKeyDiskMenu
 483  64F1
 484  64F1 3A A4 7A     	ld		a, (FileCnt)
 485  64F4 B7           	or		a
 486  64F5 CA 17 63     	jp		z, ReadKeyLoop
 487  64F8
 488  64F8 21 AC 79     	ld		hl, MsgSetRO
 489  64FB 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 490  64FE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 491  6500 CD 40 72     	call	PrintStrClr
 492  6503 CD DC 71     	call	ReadChar
 493  6506 1E 00        	ld		e, 0
 494  6508 FE 79        	cp		'y'
 495  650A 20 02        	jr		nz, CheckSYS
 496  650C 1E 01        	ld		e, 1
 497  650E
 498  650E              CheckSYS:
 499  650E D5           	push	de
 500  650F 21 B8 79     		ld		hl, MsgSetSYS
 501  6512 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 502  6515 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 503  6517 CD 40 72     		call	PrintStrClr
 504  651A CD DC 71     		call	ReadChar
 505  651D FE 79        		cp		'y'
 506  651F D1           	pop		de
 507  6520 20 04        	jr		nz, AttrChange
 508  6522 3E 02        	ld		a, %10
 509  6524 B3           	or		e
 510  6525 5F           	ld		e, a
 511  6526
 512  6526              AttrChange:
 513  6526 2A AB 7A     	ld		hl, (SelFileCache)
 514  6529 CD 92 6E     	call	ChangeFileAttrib
 515  652C C3 BA 61     	jp		HCRunInitDisk
 516  652F
 517  652F              SelectDrive:
 518  652F 32 CC 6D     	ld 		(RWTSDrive), a
 519  6532 C3 BA 61     	jp		HCRunInitDisk
 520  6535
 521  6535              CheckKeyDiskMenu:
 522  6535 FE 39        	cp		'9'
 523  6537 C2 14 66     	jp		nz, CheckKeyExit
 524  653A
 525  653A 3A CC 6D     	ld		a, (RWTSDrive)
 526  653D C6 41        	add		'A'
 527  653F              	;Update menu messages with current drive.
 528  653F 32 01 7A     	ld		(MsgMenuSingleDrv1), a
 529  6542 32 05 7A     	ld		(MsgMenuSingleDrv2), a
 530  6545 32 0F 7A     	ld		(MsgMenuDualDrv1), a
 531  6548 32 1D 7A     	ld		(MsgMenuToComDrv), a
 532  654B 32 31 7A     	ld		(MsgMenuFromCOMDrv), a
 533  654E 32 3D 7A     	ld		(MsgMenuFmtDrv), a
 534  6551 32 4A 7A     	ld		(MsgFormatDrv), a
 535  6554              	;Update menu messages with the alternate drive.
 536  6554 3A CC 6D     	ld		a, (RWTSDrive)
 537  6557 3C           	inc		a
 538  6558 EE 03        	xor		%11
 539  655A C6 40        	add		'A'-1
 540  655C 32 13 7A     	ld		(MsgMenuDualDrv2), a
 541  655F
 542  655F 21 D4 79     	ld		hl, MsgMenuDiskCopy
 543  6562 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 544  6565 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 545  6567 CD 40 72     	call	PrintStrClr
 546  656A 21 ED 79     	ld		hl, MsgMenuBack
 547  656D 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 548  6570 CD 18 72     	call	PrintStr
 549  6573 21 F9 79     	ld		hl, MsgMenuSingle
 550  6576 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 551  6579 CD 18 72     	call	PrintStr
 552  657C 21 07 7A     	ld		hl, MsgMenuDual
 553  657F 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 554  6582 CD 18 72     	call	PrintStr
 555  6585 21 15 7A     	ld		hl, MsgMenuToCOM
 556  6588 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 557  658B CD 18 72     	call	PrintStr
 558  658E 21 24 7A     	ld		hl, MsgMenuFromCOM
 559  6591 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 560  6594 CD 18 72     	call	PrintStr
 561  6597 21 33 7A     	ld		hl, MsgMenuFmt
 562  659A 11 00 15     	ld		de, LST_LINE_MSG + 7 << 8
 563  659D CD 18 72     	call	PrintStr
 564  65A0
 565  65A0 CD DC 71     	call	ReadChar
 566  65A3 F5           	push	af
 567  65A4 06 07        		ld		b, 7
 568  65A6 CD DA 73     		call	ClearNMsgLines
 569  65A9 F1           	pop		af
 570  65AA 32 AD 7A     	ld		(CopySelOption), a
 571  65AD
 572  65AD              CheckKeyDiskMenuLoop:
 573  65AD FE 30        	cp		'0'
 574  65AF 28 60        	jr		z, DiskMenuExit
 575  65B1
 576  65B1              	;Single drive copy
 577  65B1 FE 31        	cp		'1'
 578  65B3 20 0A        	jr		nz, CheckDiskMenuDualDrive
 579  65B5 CD F8 6A     	call	CopyDisk
 580  65B8 06 02        	ld		b, 2
 581  65BA CD DA 73     	call	ClearNMsgLines
 582  65BD 18 52        	jr		DiskMenuExit
 583  65BF
 584  65BF              	;Dual drive copy
 585  65BF              CheckDiskMenuDualDrive:
 586  65BF FE 32        	cp		'2'
 587  65C1 20 0A        	jr		nz, CheckDiskMenuToCOM
 588  65C3 CD F8 6A     	call	CopyDisk
 589  65C6 06 02        	ld		b, 2
 590  65C8 CD DA 73     	call	ClearNMsgLines
 591  65CB 18 44        	jr		DiskMenuExit
 592  65CD
 593  65CD              CheckDiskMenuToCOM:
 594  65CD FE 33        	cp		'3'
 595  65CF 20 05        	jr		nz, CheckDiskMenuFromCOM
 596  65D1 CD B5 6B     	call	CopyDiskToCOM
 597  65D4 18 3B        	jr		DiskMenuExit
 598  65D6
 599  65D6              CheckDiskMenuFromCOM:
 600  65D6 FE 34        	cp		'4'
 601  65D8 20 06        	jr		nz, CheckDiskMenuFormat
 602  65DA CD 11 6C     	call	CopyDiskFromCOM
 603  65DD C3 BA 61     	jp		HCRunInitDisk
 604  65E0
 605  65E0              CheckDiskMenuFormat:
 606  65E0 FE 35        	cp		'5'
 607  65E2 C2 FB 61     	jp		nz, HCRunMain
 608  65E5
 609  65E5 21 3F 7A     	ld		hl, MsgFormat
 610  65E8 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 611  65EB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 612  65ED CD 40 72     	call	PrintStrClr
 613  65F0
 614  65F0 CD 28 6A     	call	FormatDisk
 615  65F3 B7           	or		a
 616  65F4 CA BA 61     	jp		z, HCRunInitDisk
 617  65F7
 618  65F7              	;Display error for format
 619  65F7 6F           	ld		l, a
 620  65F8 26 00        	ld		h, 0
 621  65FA 11 CB 78     	ld		de, MsgErrCode
 622  65FD CD 93 69     	call	Byte2Txt
 623  6600 21 C0 78     	ld		hl, MsgErr
 624  6603 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 625  6606 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 626  6608 CD 40 72     	call	PrintStrClr
 627  660B CD DC 71     	call	ReadChar
 628  660E C3 BA 61     	jp		HCRunInitDisk
 629  6611
 630  6611              DiskMenuExit:
 631  6611 C3 17 63     	jp		ReadKeyLoop
 632  6614
 633  6614              CheckKeyExit:
 634  6614 FE 30        	cp		'0'
 635  6616 C2 17 63     	jp		nz, ReadKeyLoop
 636  6619              	;jp		HCRunEnd
 637  6619 C3 00 00     	jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 638  661C
 639  661C              MoveIt:
 640  661C CD 22 73     	call 	MoveCursor
 641  661F C3 17 63     	jp		ReadKeyLoop
 642  6622
 643  6622              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 644  6622
 645  6622
 646  6622              DisplayFilename:
 647  6622 06 0B        	LD		B, NAMELEN
 648  6624              DispLoop:
 649  6624 1A           	LD		A, (DE)
 650  6625
 651  6625              	;clear bit 7
 652  6625 CB BF        	RES 	7, A
 653  6627 32 81 5C     	LD		(CODE), A
 654  662A
 655  662A 13           	INC		DE
 656  662B D5           	PUSH	DE
 657  662C C5           	PUSH	BC
 658  662D CD 5A 73     		CALL	PrintChar
 659  6630 C1           	POP		BC
 660  6631 D1           	POP 	DE
 661  6632
 662  6632 21 B0 5C     	LD		HL, COL
 663  6635 34           	INC		(HL)
 664  6636 10 EC        	DJNZ	DispLoop
 665  6638              	;now a name is displayed
 666  6638
 667  6638              	;check bounds
 668  6638 3A B1 5C     	LD		A, (LINE)
 669  663B 3C           	INC		A
 670  663C FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 671  663E 38 0A        	JR		C, LineOK
 672  6640
 673  6640              	;set names column to the next one
 674  6640 3A A5 7A     	LD		A, (NameCol)
 675  6643 C6 0C        	ADD		NAMELEN + 1
 676  6645 32 A5 7A     	LD		(NameCol), A
 677  6648
 678  6648 3E 01        	LD		A, LST_FIRST_LINE
 679  664A              LineOK:
 680  664A 32 B1 5C     	LD		(LINE), A
 681  664D
 682  664D 3A A5 7A     	LD		A, (NameCol)
 683  6650 32 B0 5C     	LD		(COL), A
 684  6653
 685  6653 C9           	RET
 686  6654
 687  6654
 688  6654              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 689  6654
 690  6654              DisplayFilenames:
 691  6654 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 692  6657 ED 53 B0 5C  	ld		(LineCol), de
 693  665B
 694  665B 11 AD 7A     	ld		de, FileCache
 695  665E 3A A4 7A     	ld		a, (FileCnt)
 696  6661 B7           	or		a
 697  6662 C8           	ret		z
 698  6663
 699  6663 47           	ld		b,	a
 700  6664
 701  6664              DisplayFilenamesLoop:
 702  6664 C5           	push	bc
 703  6665 D5           		push	de
 704  6666 CD 22 66     			call	DisplayFilename
 705  6669 D1           		pop		de
 706  666A EB           		ex		de, hl
 707  666B 01 19 00     		ld		bc, CACHE_SZ
 708  666E 09           		add		hl, bc
 709  666F EB           		ex		de, hl
 710  6670 C1           	pop		bc
 711  6671 10 F1        	djnz	DisplayFilenamesLoop
 712  6673
 713  6673 C9           	ret
 714  6674
 715  6674
 716  6674              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 717  6674              ;Selects only valid filenames (not deleted and only from first extension)
 718  6674              GetFileNames:
 719  6674 DD 21 CB 88  	ld		ix, TrackBuf
 720  6678 11 AD 7A     	ld		de, FileCache
 721  667B 06 80        	ld		b, MAX_EXT_CNT
 722  667D AF           	xor		a
 723  667E 32 A4 7A     	ld		(FileCnt), a
 724  6681 21 A9 7A     	ld		hl, AUCnt
 725  6684 77           	ld		(hl), a
 726  6685 23           	inc		hl
 727  6686 77           	ld		(hl), a
 728  6687
 729  6687              StoreFilenamesLoop:
 730  6687 AF           	xor a
 731  6688 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 732  668B C2 FF 66     	jp nz, NextExt
 733  668E
 734  668E              	;count AU
 735  668E D9           	exx
 736  668F E5           	push hl
 737  6690 CD 57 6A     		call CheckExtAlloc
 738  6693 EB           		ex de, hl			;save first AU no.
 739  6694
 740  6694              		;store disk alocated AU count
 741  6694 2A A9 7A     		ld hl, (AUCnt)
 742  6697 48           		ld c, b
 743  6698 06 00        		ld b, 0
 744  669A 09           		add hl, bc
 745  669B 22 A9 7A     		ld (AUCnt), hl
 746  669E E1           	pop hl
 747  669F D9           	exx
 748  66A0
 749  66A0 AF           	xor	a
 750  66A1 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 751  66A4 20 32        	jr nz, FindExt
 752  66A6
 753  66A6 DD E5        	push ix
 754  66A8 E1           	pop hl
 755  66A9 23           	inc hl					;skip del flag
 756  66AA
 757  66AA C5           	push bc
 758  66AB ~            		/*
 759  66AB ~            		push de
 760  66AB ~            			push hl
 761  66AB ~            				ex de, hl
 762  66AB ~            				call DisplayFilename
 763  66AB ~            			pop hl
 764  66AB ~            		pop de
 765  66AB ~            		*/
 766  66AB 01 0B 00     		ld bc, NAMELEN
 767  66AE ED B0        		ldir				;save file name
 768  66B0
 769  66B0 D9           		exx
 770  66B1 D5           		push 	de			;de = first AU
 771  66B2 D9           		exx
 772  66B3 E1           		pop		hl
 773  66B4 EB           		ex		de, hl
 774  66B5 73 23 72 2B  		ld		(hl), de	;save first AU
 775  66B9
 776  66B9 23           		inc		hl
 777  66BA 23           		inc		hl
 778  66BB
 779  66BB D9           		exx					;save AU cnt for file
 780  66BC C5           		push	bc
 781  66BD D9           		exx
 782  66BE C1           		pop		bc
 783  66BF 71 23 70 2B  		ld		(hl), bc
 784  66C3
 785  66C3 23           		inc		hl
 786  66C4 23           		inc		hl
 787  66C5
 788  66C5              		;xor		a			;make flag 0 to signal that header is not read yet
 789  66C5              		;ld		(hl), a
 790  66C5
 791  66C5 01 0A 00     		ld		bc, HDR_SZ + 1
 792  66C8 09           		add		hl, bc
 793  66C9
 794  66C9 EB           		ex		de, hl
 795  66CA C1           	pop bc
 796  66CB
 797  66CB
 798  66CB 3A A4 7A     	ld 		a, (FileCnt)			;inc file counter
 799  66CE 3C           	inc		a
 800  66CF 32 A4 7A     	ld 		(FileCnt), a
 801  66D2 FE 54        	cp		LST_MAX_FILES
 802  66D4 38 29        	jr		c, NextExt
 803  66D6 18 34        	jr		GetFileNamesEnd
 804  66D8
 805  66D8
 806  66D8              FindExt:					;BC' = AU cnt for this ext
 807  66D8 C5           	push	bc
 808  66D9 D5           		push 	de
 809  66DA DD E5        			push	ix
 810  66DC D1           			pop		de
 811  66DD 13           			inc		de				;DE = name to find
 812  66DE
 813  66DE 21 AD 7A     			ld		hl, FileCache
 814  66E1 3A A4 7A     			ld		a, (FileCnt)
 815  66E4 4F           			ld		c, a
 816  66E5 CD 09 6D     			call	FindCache
 817  66E8 20 13        			jr		nz, FindExtEnd
 818  66EA
 819  66EA 01 0D 00     			ld		bc, CACHE_AU_CNT
 820  66ED 09           			add		hl, bc
 821  66EE D9           			exx
 822  66EF C5           			push	bc
 823  66F0 D9           			exx
 824  66F1 C1           			pop		bc
 825  66F2
 826  66F2 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 827  66F6 EB           			ex		de, hl
 828  66F7 09           			add		hl, bc
 829  66F8 EB           			ex		de, hl
 830  66F9 73 23 72 2B  			ld		(hl), de
 831  66FD              FindExtEnd:
 832  66FD D1           		pop		de
 833  66FE C1           	pop		bc
 834  66FF
 835  66FF              NextExt:
 836  66FF C5           	push bc
 837  6700 01 20 00     		ld bc, EXT_SZ
 838  6703 DD 09        		add ix, bc
 839  6705 C1           	pop	bc
 840  6706
 841  6706 05           	dec	b
 842  6707 78           	ld	a, b
 843  6708 B7           	or	a
 844  6709 C2 87 66     	jp	nz, StoreFilenamesLoop
 845  670C              GetFileNamesEnd:
 846  670C C9           	ret
 847  670D
 848  670D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 849  670D
 850  670D              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 851  670D              ;IN: HL = file name
 852  670D              HandleFile:
 853  670D              	;Make HL point to the selected file
 854  670D DD 2A AB 7A  	ld		ix, (SelFileCache)
 855  6711 DD E5        	push	ix
 856  6713 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 857  6716 B7           		or		a
 858  6717 CC 1A 6D     		call	z, ReadFileHeader
 859  671A
 860  671A DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 861  671D FE 00        		cp		PROG_TYPE
 862  671F 28 59        		jr		z, HandleFileProg
 863  6721
 864  6721 FE 03        		cp		BYTE_TYPE
 865  6723 20 65        		jr		nz, HandleFileText
 866  6725
 867  6725 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 867  6729 66 12
 868  672B 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 869  672E 19           		add		hl, de
 870  672F 7C           		ld		a, h
 871  6730 B5           		or		l
 872  6731 28 29        		jr		z, HandleFileSCR
 873  6733
 874  6733
 875  6733              HandleFileCODE:
 876  6733 21 ED 78     		ld		hl, MsgLoadingCODE
 877  6736 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 878  6739 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 879  673B CD 40 72     		call	PrintStrClr
 880  673E
 881  673E              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 882  673E 21 84 6C     		ld		hl, IF1FileLoad
 883  6741 11 00 5B     		ld		de, PRN_BUF
 884  6744 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 885  6747 ED B0        		ldir
 886  6749 3E C9        		ld		a, $C9
 887  674B 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 888  674C
 889  674C E1           	pop		hl
 890  674D ED 5B CE 88  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 891  6751 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 892  6752 C1           	pop		bc						;2nd, 3rd call for error handler
 893  6753 C1           	pop		bc
 894  6754 ED 43 3D 5C  	ld		(ERRSP), bc
 895  6758 D5           	push	de						;push CODE address to return to = start of CODE block
 896  6759 C3 00 5B     	jp		PRN_BUF
 897  675C
 898  675C
 899  675C
 900  675C
 901  675C              HandleFileSCR:
 902  675C 21 DE 78     		ld		hl, MsgLoadingSCR
 903  675F 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 904  6762 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 905  6764 CD 40 72     		call	PrintStrClr
 906  6767
 907  6767 E1           	pop		hl
 908  6768
 909  6768              	IFDEF _REAL_HW_
 910  6768              		;Load to alternate SCREEN$ memory
 911  6768 11 00 C0     		ld		de, HC_VID_BANK1
 912  676B CD 84 6C     		call	IF1FileLoad
 913  676E
 914  676E              		;Set display to alternate SCREEN$ memory
 915  676E 3E 08        		ld		a, HC_CFG_VID_C000
 916  6770 D3 7E        		out 	(HC_CFG_PORT), a
 917  6772 CD DC 71     		call	ReadChar
 918  6775
 919  6775              		;Set back to regular SCREEN$ memory
 920  6775 3E 00        		ld		a, HC_CFG_VID_4000
 921  6777 D3 7E        		out 	(HC_CFG_PORT), a
 922  6779              	ELSE
 923  6779 ~            		ld		de, HC_VID_BANK0
 924  6779 ~            		call	IF1FileLoad
 925  6779 ~            		call	ReadChar
 926  6779              	ENDIF
 927  6779
 928  6779 C9           	ret
 929  677A
 930  677A              HandleFileProg:
 931  677A 21 CF 78     		ld		hl, MsgLoadingPrg
 932  677D 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 933  6780 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 934  6782 CD 40 72     		call	PrintStrClr
 935  6785 E1           	pop		hl
 936  6786 CD 81 6D     	call	LoadProgram
 937  6789 C9           	ret
 938  678A
 939  678A
 940  678A              HandleFileText:
 941  678A E1           	pop		hl
 942  678B
 943  678B
 944  678B              ViewFile:
 945  678B CD F8 71     	call	ClrScr
 946  678E 21 00 00     	ld		hl, 0
 947  6791 22 D4 88     	ld		(FilePosRead), hl
 948  6794              ViewFileLoop:
 949  6794 2A AB 7A     	ld		hl, (SelFileCache)
 950  6797 3A CC 6D     	ld 		a, (RWTSDrive)
 951  679A 3C           	inc		a
 952  679B CD 29 71     	call	ReadFileSection					;DE = last address read
 953  679E 21 CB 89     	ld		hl, FileData
 954  67A1              	;Calculate size of read buffer
 955  67A1 E5           	push	hl
 956  67A2 EB           		ex	de, hl
 957  67A3 B7           		or	a
 958  67A4 ED 52        		sbc	hl, de
 959  67A6 44           		ld	b, h
 960  67A7 4B           		ld	c, e
 961  67A8 E1           	pop		hl
 962  67A9 CD F1 73     	call	InitViewer
 963  67AC CD 4F 74     	call	PrintLoop
 964  67AF              	;Check if exited viewer because user wanted to.
 965  67AF C8           	ret		z
 966  67B0
 967  67B0              	;Check if file ended -> we need to load the next file segment.
 968  67B0 3A CD 88     	ld		a, (CopyFileRes)
 969  67B3 B7           	or		a
 970  67B4 28 DE        	jr		z, ViewFileLoop
 971  67B6 C3 8A 74     	jp		PrintLoop2
 972  67B9 C9           	ret
 973  67BA
 974  67BA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 975  67BA
 976  67BA
 977  67BA              DisplayFileInfo:
 978  67BA 2A AB 7A     	ld		hl, (SelFileCache)
 979  67BD E5           	push	hl
 980  67BE              		;disk size - at least 2KB ==1  AU
 981  67BE 01 0D 00     		ld		bc, CACHE_AU_CNT
 982  67C1 09           		add		hl, bc
 983  67C2 5E 23 56 2B  		ld		de, (hl)
 984  67C6 EB           		ex		de, hl
 985  67C7              		;*2, since one block (AU) is 2KB.
 986  67C7 CB 15        		rl	l
 987  67C9 CB 14        		rl	h
 988  67CB
 989  67CB 11 06 79     		ld		de, MsgFileSzDskN
 990  67CE CD 88 69     		call	Word2Txt
 991  67D1 21 FD 78     		ld		hl, MsgFileSzDsk
 992  67D4 11 00 09     		ld		de, LST_FILE_INFO + 1 << 8
 993  67D7 CD 18 72     		call	PrintStr
 994  67DA E1           	pop		hl
 995  67DB E5           	push	hl
 996  67DC              		;attributes
 997  67DC 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 998  67DF 09           		add		hl, bc
 999  67E0 EB           		ex		de, hl
1000  67E1 21 16 79     		ld		hl, MsgFileAttrN
1001  67E4 1A           		ld		a, (de)
1002  67E5 E6 80        		and		%10000000
1003  67E7 28 14        		jr		z, NotRO
1004  67E9
1005  67E9 01 52 2F     		ld		bc, '/R'
1006  67EC 71 23 70 2B  		ld		(hl), bc
1007  67F0 23           		inc		hl
1008  67F1 23           		inc		hl
1009  67F2 01 4F 2C     		ld		bc, ',O'
1010  67F5 71 23 70 2B  		ld		(hl), bc
1011  67F9 23           		inc		hl
1012  67FA 23           		inc		hl
1013  67FB 18 12        		jr		CheckSys
1014  67FD              NotRO:
1015  67FD 01 2D 2D     		ld		bc, '--'
1016  6800 71 23 70 2B  		ld		(hl), bc
1017  6804 23           		inc		hl
1018  6805 23           		inc		hl
1019  6806 01 2D 2C     		ld		bc, ',-'
1020  6809 71 23 70 2B  		ld		(hl), bc
1021  680D 23           		inc		hl
1022  680E 23           		inc		hl
1023  680F
1024  680F              CheckSys:
1025  680F 13           		inc		de
1026  6810 1A           		ld		a, (de)
1027  6811 E6 80        		and		%10000000
1028  6813 28 0E        		jr		z, NotSYS
1029  6815
1030  6815 01 48 49     		ld		bc, 'IH'
1031  6818 71 23 70 2B  		ld		(hl), bc
1032  681C 23           		inc		hl
1033  681D 23           		inc		hl
1034  681E 3E C4        		ld		a, 'D' + $80
1035  6820 77           		ld		(hl), a
1036  6821 18 0C        		jr		AttrEnd
1037  6823              NotSYS:
1038  6823 01 2D 2D     		ld		bc, '--'
1039  6826 71 23 70 2B  		ld		(hl), bc
1040  682A 23           		inc		hl
1041  682B 23           		inc		hl
1042  682C 3E AD        		ld		a, '-' + $80
1043  682E 77           		ld		(hl), a
1044  682F              AttrEnd:
1045  682F 11 00 0A     		ld		de, LST_FILE_INFO + 2 << 8
1046  6832 21 0D 79     		ld		hl, MsgFileAttr
1047  6835 CD 18 72     		call	PrintStr
1048  6838 DD E1        	pop		ix
1049  683A DD E5        	push	ix
1050  683C DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1051  683F B7           		or		a
1052  6840 CA DD 68             jp		z, HeadNotRead
1053  6843
1054  6843 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1055  6846 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1056  6849 CA DD 68             jp		z, HeadNotRead
1057  684C
1058  684C DD 7E 10     		ld		a, (ix + CACHE_HDR)
1059  684F FE 00        		cp		PROG_TYPE
1060  6851 20 0B        		jr		nz, CheckNoArr
1061  6853
1062  6853 21 30 79     		ld		hl, MsgFileTypePrg
1063  6856 11 26 79     		ld		de, MsgFileTypeN
1064  6859 CD 26 69     		call	MoveMsg
1065  685C 18 4F        		jr		PrepFileLen
1066  685E
1067  685E              CheckNoArr:
1068  685E FE 01        		cp		NUMB_TYPE
1069  6860 20 0B        		jr		nz, CheckChrArr
1070  6862
1071  6862 21 4C 79     		ld		hl, MsgFileTypeNoA
1072  6865 11 26 79     		ld		de, MsgFileTypeN
1073  6868 CD 26 69     		call	MoveMsg
1074  686B 18 40        		jr		PrepFileLen
1075  686D
1076  686D              CheckChrArr:
1077  686D FE 02        		cp		CHAR_TYPE
1078  686F 20 0B        		jr		nz, CheckByte
1079  6871
1080  6871 21 45 79     		ld		hl, MsgFileTypeChrA
1081  6874 11 26 79     		ld		de, MsgFileTypeN
1082  6877 CD 26 69     		call	MoveMsg
1083  687A 18 31        		jr		PrepFileLen
1084  687C
1085  687C              CheckByte:
1086  687C FE 03        		cp		BYTE_TYPE
1087  687E 20 24        		jr		nz, CheckText
1088  6880
1089  6880 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1089  6884 66 12
1090  6886 01 00 E5     		ld		bc, -SCR_LEN
1091  6889 09           		add		hl, bc
1092  688A 7C           		ld		a, h
1093  688B B5           		or		l
1094  688C 20 0B        		jr		nz, NotScr
1095  688E
1096  688E 21 3E 79     		ld		hl, MsgFileTypeSCR
1097  6891 11 26 79     		ld		de, MsgFileTypeN
1098  6894 CD 26 69     		call	MoveMsg
1099  6897 18 14        		jr		PrepFileLen
1100  6899              NotScr:
1101  6899 21 37 79     		ld		hl, MsgFileTypeByte
1102  689C 11 26 79     		ld		de, MsgFileTypeN
1103  689F CD 26 69     		call	MoveMsg
1104  68A2 18 09        		jr		PrepFileLen
1105  68A4
1106  68A4              CheckText:
1107  68A4 21 53 79     		ld		hl, MsgFileTypeText
1108  68A7 11 26 79     		ld		de, MsgFileTypeN
1109  68AA CD 26 69     		call	MoveMsg
1110  68AD
1111  68AD              PrepFileLen:
1112  68AD              		;File len
1113  68AD DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1114  68B0 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1115  68B3              PrepFileLenText:
1116  68B3 11 6A 79     		ld		de, MsgFileLenN
1117  68B6 CD 88 69     		call	Word2Txt
1118  68B9 26 C2        		ld		h, 'B' | $80
1119  68BB 2E 20        		ld		l, ' '
1120  68BD 22 6F 79     		ld		(MsgFileLenN + 5), hl
1121  68C0
1122  68C0 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1123  68C3 FE 00        		cp		PROG_TYPE
1124  68C5 28 06        		jr		z, PrintProgStart
1125  68C7
1126  68C7 FE 03        		cp		BYTE_TYPE
1127  68C9 28 0A        		jr		z, PrintByteStart
1128  68CB
1129  68CB 18 22        		jr		PrintStartNotRead
1130  68CD
1131  68CD              PrintProgStart:
1132  68CD DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1133  68D0 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1134  68D3 18 25        		jr		PrintStart
1135  68D5
1136  68D5              PrintByteStart:
1137  68D5 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1138  68D8 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1139  68DB 18 1D        		jr		PrintStart
1140  68DD
1141  68DD              HeadNotRead:
1142  68DD 21 5A 79             ld        hl, MsgNA
1143  68E0 11 26 79             ld        de, MsgFileTypeN
1144  68E3 CD 26 69             call    MoveMsg
1145  68E6
1146  68E6 21 5A 79     		ld		hl, MsgNA
1147  68E9 11 6A 79     		ld		de, MsgFileLenN
1148  68EC CD 26 69     		call	MoveMsg
1149  68EF
1150  68EF              PrintStartNotRead:
1151  68EF 21 5A 79     		ld		hl, MsgNA
1152  68F2 11 7A 79     		ld		de, MsgFileStartN
1153  68F5 CD 26 69     		call	MoveMsg
1154  68F8 18 0E        		jr		PrintStartStr
1155  68FA
1156  68FA              PrintStart:
1157  68FA 1E 20        	ld		e, ' '
1158  68FC 16 A0        	ld		d, ' ' | $80
1159  68FE ED 53 7F 79  	ld		(MsgFileStartN + 5), de
1160  6902 11 7A 79     	ld		de, MsgFileStartN
1161  6905 CD 88 69     	call	Word2Txt
1162  6908              PrintStartStr:
1163  6908 11 00 0C     	ld		de, LST_FILE_INFO + 4 << 8
1164  690B 21 71 79     	ld		hl, MsgFileStart
1165  690E CD 18 72     	call	PrintStr
1166  6911
1167  6911 DD E1        	pop		ix
1168  6913 11 00 0B     	ld		de, LST_FILE_INFO + 3 << 8
1169  6916 21 1D 79     	ld		hl, MsgFileType
1170  6919 CD 18 72     	call	PrintStr
1171  691C
1172  691C 11 00 0D     	ld		de, LST_FILE_INFO + 5 << 8
1173  691F 21 61 79     	ld		hl, MsgFileLen
1174  6922 CD 18 72     	call	PrintStr
1175  6925
1176  6925 C9           	ret
1177  6926
1178  6926              MoveMsg:
1179  6926 01 07 00     	ld		bc, 7
1180  6929 ED B0        	ldir
1181  692B C9           	ret
1182  692C
1183  692C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1184  692C
1185  692C              ReadAllHeaders:
1186  692C 21 81 79     	ld		hl, MsgReadingExt
1187  692F 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1188  6932 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1189  6934 CD 40 72     	call	PrintStrClr
1190  6937
1191  6937 CD 06 63     	call	CalcFileCache
1192  693A
1193  693A 3A A6 7A     	ld		a, (SelFile)
1194  693D 47           	ld		b, a
1195  693E 3A A4 7A     	ld		a, (FileCnt)
1196  6941 90           	sub		b
1197  6942 B7           	or		a
1198  6943 C8           	ret		z
1199  6944
1200  6944 47           	ld		b, a
1201  6945
1202  6945 DD 2A AB 7A  	ld		ix, (SelFileCache)
1203  6949              NextFile:
1204  6949 C5           	push	bc
1205  694A CD 1A 6D     		call	ReadFileHeader
1206  694D 01 19 00     		ld		bc, CACHE_SZ
1207  6950 DD 09        		add		ix, bc
1208  6952 DD E5        		push	ix
1209  6954 CD 06 63     			call	CalcFileCache
1210  6957 CD BA 67     			call	DisplayFileInfo
1211  695A DD E1        		pop		ix
1212  695C
1213  695C CD DF 71     		call	KbdHit
1214  695F 38 03        		jr		c, AKey
1215  6961 C1           	pop		bc
1216  6962 18 15        	jr		ReadAllHeadersEnd
1217  6964
1218  6964              AKey:
1219  6964 3A A6 7A     		ld		a, (SelFile)
1220  6967 3C           		inc		a
1221  6968 47           		ld		b, a
1222  6969 3A A4 7A     		ld		a, (FileCnt)
1223  696C B8           		cp		b
1224  696D 28 16        		jr		z, DontInc
1225  696F 78           		ld		a, b
1226  6970 32 A6 7A     		ld		(SelFile), a
1227  6973 CD 22 73     		call	MoveCursor
1228  6976 C1           	pop		bc
1229  6977 10 D0        	djnz	NextFile
1230  6979
1231  6979              ReadAllHeadersEnd:
1232  6979 21 8F 79     	ld		hl, MsgClear
1233  697C 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1234  697F 3E 45        	ld		a, SCR_DEF_CLR
1235  6981 CD 40 72     	call	PrintStrClr
1236  6984 C9           	ret
1237  6985
1238  6985              DontInc:
1239  6985 C1           	pop		bc
1240  6986 18 F1        	jr		ReadAllHeadersEnd
1241  6988
1242  6988
1243  6988              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1244  6988
1245  6988              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6988              	ifndef	_HCCFG_
   2+ 6988              	define	_HCCFG_
   3+ 6988
   4+ 6988              ;HC specific code, for configuration
   5+ 6988
   6+ 6988              HC_CFG_PORT			EQU	$7E
   7+ 6988
   8+ 6988              ;BASIC/CPM ROM selection
   9+ 6988              HC_CFG_ROM_BAS		EQU	%0
  10+ 6988              HC_CFG_ROM_CPM		EQU	%1
  11+ 6988
  12+ 6988              ;Address for ROM paging: 0 or $E000
  13+ 6988              HC_CFG_ROM_0000		EQU %00
  14+ 6988              HC_CFG_ROM_E000		EQU %10
  15+ 6988
  16+ 6988              ;Cfg. port Enable/Disable
  17+ 6988              HC_CFG_PORT_DIS		EQU %000
  18+ 6988              HC_CFG_PORT_EN		EQU	%100
  19+ 6988
  20+ 6988              ;Video memory bank: $4000 or $C000
  21+ 6988              HC_CFG_VID_4000		EQU	%0000
  22+ 6988              HC_CFG_VID_C000		EQU	%1000
  23+ 6988
  24+ 6988
  25+ 6988              ;Standar BASIC config
  26+ 6988              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 6988              ;Standar CP/M config
  28+ 6988              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 6988
  30+ 6988
  31+ 6988              HC_VID_BANK0		EQU	$4000
  32+ 6988              HC_VID_BANK1		EQU	$C000
  33+ 6988
  34+ 6988              	endif
# file closed: hccfg.asm
1246  6988              	include "if1.asm"
# file opened: if1.asm
   1+ 6988              ;HC IF1 routines and constants
   2+ 6988
   3+ 6988              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6988              ;12 = Writing to a 'read' file
   5+ 6988              ;13 = Reading a 'write' file
   6+ 6988              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6988              ;15 = Disk full (disk or catalog full)
   8+ 6988              ;16 = Disk error (hardware error)
   9+ 6988              ;17 = File not found
  10+ 6988              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6988              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6988
  13+ 6988              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6988              ;00h = OK
  15+ 6988              ;08h = cannot format disk
  16+ 6988              ;10h = disk protected (read-only?)
  17+ 6988              ;20h = volume error
  18+ 6988              ;40h = drive error
  19+ 6988              ;80h = reading error
  20+ 6988              ;Codes I encountered:
  21+ 6988              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6988
  23+ 6988
  24+ 6988              	ifndef	_DISK_
  25+ 6988              	define	_DISK_
  26+ 6988
  27+ 6988              	include	"math.asm"
# file opened: math.asm
   1++6988              	ifndef	_MATH_
   2++6988              	define	_MATH_
   3++6988
   4++6988              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6988              ;http://map.tni.nl/sources/external/z80bits.html
   6++6988
   7++6988
   8++6988              Word2Txt:
   9++6988              	IFUSED
  10++6988 D5           	push	de
  11++6989 CD A9 69     		call	Word2Txt_
  12++698C D1           	pop		de
  13++698D
  14++698D 06 04        	ld		b, 4
  15++698F CD 9E 69     	call	StrippLeading0
  16++6992 C9           	ret
  17++6993
  18++6993              Byte2Txt:
  19++6993 D5           	push	de
  20++6994 CD B5 69     		call	Byte2Txt_
  21++6997 D1           	pop		de
  22++6998
  23++6998 06 02        	ld		b, 2
  24++699A CD 9E 69     	call	StrippLeading0
  25++699D C9           	ret
  26++699E              	ENDIF
  27++699E
  28++699E
  29++699E              StrippLeading0:
  30++699E 1A           	ld		a, (de)
  31++699F FE 31        	cp		'1'
  32++69A1 D0           	ret		nc
  33++69A2
  34++69A2 3E 20        	ld		a, ' '
  35++69A4 12           	ld		(de), a
  36++69A5 13           	inc		de
  37++69A6 10 F6        	djnz	StrippLeading0
  38++69A8 C9           	ret
  39++69A9
  40++69A9
  41++69A9              ;Converts the number in HL to ASCII in decimal string at DE
  42++69A9              Word2Txt_:
  43++69A9 01 F0 D8     	ld bc, -10000
  44++69AC CD C4 69     	call DigitLoop
  45++69AF 01 18 FC     	ld bc, -1000
  46++69B2 CD C4 69     	call DigitLoop
  47++69B5              Byte2Txt_:
  48++69B5 01 9C FF     	ld bc, -100
  49++69B8 CD C4 69     	call DigitLoop
  50++69BB 01 F6 FF     	ld bc, -10
  51++69BE CD C4 69     	call DigitLoop
  52++69C1 01 FF FF     	ld bc, -1
  53++69C4
  54++69C4              DigitLoop:
  55++69C4 3E 2F        	ld	a, '0' - 1
  56++69C6              DivNrLoop:
  57++69C6 3C           	inc	a			;increase reminder
  58++69C7 09           	add	hl, bc		;substract divizor
  59++69C8 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++69CA ED 42        	sbc	hl, bc		;nope, restore
  61++69CC
  62++69CC 12           	ld (de), a
  63++69CD 13           	inc de
  64++69CE C9           	ret
  65++69CF
  66++69CF
  67++69CF              ;Input: HL = Dividend, C = Divisor
  68++69CF              ;Output: HL = Quotient, A = Remainder
  69++69CF              ;Warning: doesn't work with divisor >= $80
  70++69CF              Div:
  71++69CF              	IFUSED
  72++69CF AF           	xor a
  73++69D0 06 10        	ld b, 16
  74++69D2
  75++69D2              DivLoop:
  76++69D2 29           	add	hl,hl
  77++69D3 17           	rla
  78++69D4 B9           	cp	c
  79++69D5 38 02        	jr	c, NoSub
  80++69D7 91           	sub	c
  81++69D8 2C           	inc	l
  82++69D9              NoSub:
  83++69D9 10 F7        	djnz DivLoop
  84++69DB
  85++69DB C9           	ret
  86++69DC              	ENDIF
  87++69DC
  88++69DC              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++69DC              ;Output: A:C = Quotient, HL = Remainder
  90++69DC              Div2:
  91++69DC 21 00 00     	ld hl, 0
  92++69DF 06 10        	ld b, 16
  93++69E1              Div2Loop:
  94++69E1 CB 31        	sll c		; unroll 16 times
  95++69E3 17           	rla			; ...
  96++69E4 ED 6A        	adc	hl,hl		; ...
  97++69E6 ED 52        	sbc	hl,de		; ...
  98++69E8 30 02        	jr	nc,$+4		; ...
  99++69EA 19           	add	hl,de		; ...
 100++69EB 0D           	dec	c		; ...
 101++69EC 10 F3        	djnz Div2Loop
 102++69EE C9           	ret
 103++69EF
 104++69EF
 105++69EF              ;Input: A = Multiplier, DE = Multiplicand
 106++69EF              ;Output: A:HL = Product
 107++69EF              Mul:
 108++69EF              	IFUSED
 109++69EF 21 00 00     	ld hl, 0
 110++69F2 01 00 07     	ld bc, $0700
 111++69F5
 112++69F5 87           	add	a, a		; optimised 1st iteration
 113++69F6 30 02        	jr	nc, MulLoop
 114++69F8 62           	ld	h, d
 115++69F9 6B           	ld	l, e
 116++69FA
 117++69FA              MulLoop:
 118++69FA 29           	add	hl,hl
 119++69FB 17           	rla
 120++69FC 30 02        	jr	nc, NoAdd
 121++69FE 19           	add	hl,de
 122++69FF 89           	adc	a,c
 123++6A00              NoAdd:
 124++6A00 10 F8        	djnz MulLoop
 125++6A02
 126++6A02 C9           	ret
 127++6A03              	ENDIF
 128++6A03
 129++6A03              	endif
# file closed: math.asm
  28+ 6A03
  29+ 6A03              DRIVE_CUR_BAS	EQU 0
  30+ 6A03              DRIVE_A_BAS		EQU	1
  31+ 6A03              DRIVE_B_BAS		EQU	2
  32+ 6A03              DRIVE_A_CPM		EQU	0
  33+ 6A03              DRIVE_B_CPM		EQU	1
  34+ 6A03              ;Disk geometry stuff
  35+ 6A03              SPT				EQU	16			;sectors per track
  36+ 6A03              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6A03              TRACK_CNT		EQU	80			;track count
  38+ 6A03              HEAD_CNT		EQU	2			;disk face count
  39+ 6A03              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6A03              EXT_SZ			EQU	32			;directory entry size
  41+ 6A03              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6A03              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6A03              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6A03              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6A03              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6A03              REC_SZ			EQU 128			;cp/m record size
  47+ 6A03              DEL_MARKER		EQU	$E5
  48+ 6A03
  49+ 6A03
  50+ 6A03              ;Extension structure (directory entry)
  51+ 6A03              EXT_DEL_FLAG	EQU	0
  52+ 6A03              EXT_NAME		EQU 1
  53+ 6A03              EXT_IDX			EQU 12
  54+ 6A03              EXT_S1			EQU 13
  55+ 6A03              EXT_S2			EQU 14
  56+ 6A03              EXT_RC			EQU	15
  57+ 6A03              EXT_AU0			EQU	16
  58+ 6A03              EXT_AU1			EQU	18
  59+ 6A03              EXT_AU2			EQU	20
  60+ 6A03              EXT_AU3			EQU	22
  61+ 6A03              EXT_AU4			EQU	24
  62+ 6A03              EXT_AU5			EQU	26
  63+ 6A03              EXT_AU6			EQU	28
  64+ 6A03              EXT_AU7			EQU	30
  65+ 6A03              EXT_SIZE		EQU 32
  66+ 6A03
  67+ 6A03              ;FCB structure
  68+ 6A03              FCB_DRIVE		EQU 0
  69+ 6A03              FCB_NAME		EQU EXT_NAME
  70+ 6A03              FCB_EX_IDX		EQU EXT_IDX
  71+ 6A03              FCB_S1			EQU EXT_S1
  72+ 6A03              FCB_S2			EQU EXT_S2
  73+ 6A03              FCB_RC			EQU	EXT_RC
  74+ 6A03              FCB_AU			EQU	EXT_AU0
  75+ 6A03              FCB_CR			EQU	32
  76+ 6A03              FCB_R0			EQU 33
  77+ 6A03              FCB_R1			EQU 34
  78+ 6A03              FCB_R2			EQU 35
  79+ 6A03              FCB_SIZE		EQU 36
  80+ 6A03
  81+ 6A03
  82+ 6A03
  83+ 6A03              ;System variables for disk
  84+ 6A03              DSTR1			EQU	$5CD6		;drive
  85+ 6A03              FSTR1			EQU	$5CDC		;file name
  86+ 6A03              NSTR1			EQU	$5CDA		;name length
  87+ 6A03              HD11			EQU	$5CED		;BDOS argument
  88+ 6A03              COPIES			EQU	$5CEF		;BDOS function
  89+ 6A03
  90+ 6A03              ERRSP			EQU $5C3D
  91+ 6A03              ERRNR			EQU $5C3A
  92+ 6A03              ERRMSG			EQU	$0260
  93+ 6A03
  94+ 6A03              PROG			EQU $5C53
  95+ 6A03              VARS			EQU	$5C4B
  96+ 6A03              STKEND			EQU	$5C65
  97+ 6A03
  98+ 6A03              PRN_BUF			EQU	23296
  99+ 6A03
 100+ 6A03              STR_MSG_BASIC	EQU	$1539
 101+ 6A03              STR_MSG_BASIC_LEN EQU 32
 102+ 6A03              STR_MSG_IF1_2000	EQU $27F0
 103+ 6A03              STR_MSG_IF1_91		EQU $23F0
 104+ 6A03              STR_MSG_IF1_LEN EQU 31
 105+ 6A03
 106+ 6A03              REPDEL			EQU	23561
 107+ 6A03              REPPER			EQU	23562
 108+ 6A03              PIP				EQU	23609
 109+ 6A03
 110+ 6A03
 111+ 6A03              ;RWTS routine commands
 112+ 6A03              RWTS_CMD_POS	EQU	0			;position head
 113+ 6A03              RWTS_CMD_READ	EQU	1			;read sector
 114+ 6A03              RWTS_CMD_WRITE	EQU	2			;write sector
 115+ 6A03              RWTS_CMD_FMT	EQU	4			;format all tracks
 116+ 6A03
 117+ 6A03
 118+ 6A03              ;File name stuff
 119+ 6A03              NAMELEN			EQU	11			;name length
 120+ 6A03              RO_POS			EQU	8			;read-only attribute position in name
 121+ 6A03              SYS_POS			EQU	9			;system attribute position in name
 122+ 6A03
 123+ 6A03              ;File types (first byte in header)
 124+ 6A03              PROG_TYPE		EQU	0			;program
 125+ 6A03              NUMB_TYPE		EQU	1			;number array
 126+ 6A03              CHAR_TYPE		EQU	2			;char array
 127+ 6A03              BYTE_TYPE		EQU	3			;bytes
 128+ 6A03              TEXT_TYPE		EQU	4			;text, >= 4
 129+ 6A03
 130+ 6A03              ;File header offsets
 131+ 6A03              HDR_TYPE		EQU	0
 132+ 6A03              HDR_LEN			EQU 1
 133+ 6A03              HDR_ADDR		EQU 3
 134+ 6A03              HDR_PLEN		EQU	5
 135+ 6A03              HDR_LINE		EQU 7
 136+ 6A03              HDR_SZ			EQU	9
 137+ 6A03
 138+ 6A03              ;BASIC disk channel structure
 139+ 6A03              CH_RW_FLAG		EQU 11
 140+ 6A03              CH_FCB			EQU	12
 141+ 6A03              CH_DATA			EQU	50
 142+ 6A03              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143+ 6A03
 144+ 6A03              CACHE_NAME		EQU	0					;11B
 145+ 6A03              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146+ 6A03              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147+ 6A03              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148+ 6A03              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149+ 6A03              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150+ 6A03
 151+ 6A03              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152+ 6A03
 153+ 6A03              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154+ 6A03              IF1Init:
 155+ 6A03 CF           	rst		08
 156+ 6A04 31           	defb	49		;create system variables
 157+ 6A05 C9           	ret
 158+ 6A06
 159+ 6A06              ;ReadWriteTrackSector
 160+ 6A06              ;A=command: 0, 1, 2, 4
 161+ 6A06              RWTS:
 162+ 6A06 32 D6 6D     	ld (RWTSCmd), a
 163+ 6A09 21 CB 6D     	ld hl, RWTSParams
 164+ 6A0C 22 ED 5C     	ld (HD11), hl
 165+ 6A0F CF           	rst 08
 166+ 6A10 3A           	DEFB 58
 167+ 6A11 C9           	ret
 168+ 6A12
 169+ 6A12
 170+ 6A12              ;D = sector, E = track
 171+ 6A12              ;HL = dma
 172+ 6A12              ReadOneDiskSector:
 173+ 6A12 22 D0 6D     	ld (RWTSDMA), hl
 174+ 6A15 ED 53 CE 6D  	ld (RWTSTrack), de
 175+ 6A19              	;ld (RWTSDrive), a
 176+ 6A19 3E 01        	ld a, RWTS_CMD_READ
 177+ 6A1B 18 E9        	jr	RWTS
 178+ 6A1D
 179+ 6A1D              ;D = sector, E = track
 180+ 6A1D              ;HL = dma
 181+ 6A1D              WriteOneDiskSector:
 182+ 6A1D 22 D0 6D     	ld (RWTSDMA), hl
 183+ 6A20 ED 53 CE 6D  	ld (RWTSTrack), de
 184+ 6A24              	;ld (RWTSDrive), a
 185+ 6A24 3E 02        	ld a, RWTS_CMD_WRITE
 186+ 6A26 18 DE        	jr	RWTS
 187+ 6A28
 188+ 6A28              FormatDisk:
 189+ 6A28 21 CB 88     	ld		hl, DataBuf
 190+ 6A2B 36 E5        	ld		(hl), DEL_MARKER
 191+ 6A2D 22 D0 6D     	ld 		(RWTSDMA), hl
 192+ 6A30 3E 04        	ld 		a, RWTS_CMD_FMT
 193+ 6A32 CD 06 6A     	call	RWTS
 194+ 6A35 3A D7 6D     	ld		a, (RWTSRes)
 195+ 6A38 C9           	ret
 196+ 6A39
 197+ 6A39              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198+ 6A39
 199+ 6A39              ;Allocation unit no. to track/sector
 200+ 6A39              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201+ 6A39              ;IN:  HL=alloc. unit no.
 202+ 6A39              ;OUT: B=sector; C=track (head is determined by the sector number)
 203+ 6A39              AU2TS:
 204+ 6A39 0E 02        	ld c, SPT/SPAL
 205+ 6A3B CD CF 69     	call Div					;A = sector
 206+ 6A3E F5           	push af
 207+ 6A3F ~            		/*
 208+ 6A3F ~            		ld c, HEAD_CNT
 209+ 6A3F ~            		call Div				;L = track, A = head (0 or 1)
 210+ 6A3F ~            		*/
 211+ 6A3F AF           		xor a
 212+ 6A40 CB 1C        		rr h
 213+ 6A42 CB 1D        		rr l
 214+ 6A44 CB 1F        		rr a
 215+ 6A46
 216+ 6A46 4D           		ld c, l
 217+ 6A47 06 00        		ld b, 0
 218+ 6A49 B7           		or a
 219+ 6A4A 28 02        		jr z, Track0
 220+ 6A4C 06 10        		ld b, SPT
 221+ 6A4E              Track0:
 222+ 6A4E F1           	pop af
 223+ 6A4F B7           	or a
 224+ 6A50 28 02        	jr z, FirstAU
 225+ 6A52 3E 08        	ld a, SPAL
 226+ 6A54              FirstAU:
 227+ 6A54 80           	add a, b
 228+ 6A55 47           	ld  b, a
 229+ 6A56 C9           	ret
 230+ 6A57
 231+ 6A57              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232+ 6A57
 233+ 6A57              ;Checks the allocation units number used in extension
 234+ 6A57              ;IN:	IX = extension addr
 235+ 6A57              ;OUT:	B = no. of allocation units used
 236+ 6A57              ;		C = no. of records used in ext.
 237+ 6A57              ;		HL = first alloc. unit no.
 238+ 6A57              ;		DE = last alloc. unit no.
 239+ 6A57              CheckExtAlloc:
 240+ 6A57 DD E5        	push ix
 241+ 6A59 01 0F 00     		ld bc, EXT_RC
 242+ 6A5C DD 09        		add ix, bc
 243+ 6A5E DD 4E 00     		ld c, (ix)			;save rec. no.
 244+ 6A61 DD 23        		inc ix
 245+ 6A63 DD 6E 00     		ld l, (ix)
 246+ 6A66 DD 66 01     		ld h, (ix + 1)
 247+ 6A69 06 08        		ld b, EXT_AU_CNT
 248+ 6A6B              CheckAU:
 249+ 6A6B DD 7E 00     		ld a, (ix)
 250+ 6A6E DD B6 01     		or (ix + 1)
 251+ 6A71 28 0C        		jr z, CheckAUEnd
 252+ 6A73 DD 5E 00     		ld e, (ix)
 253+ 6A76 DD 56 01     		ld d, (ix + 1)
 254+ 6A79 DD 23        		inc ix
 255+ 6A7B DD 23        		inc ix
 256+ 6A7D 10 EC        		djnz CheckAU
 257+ 6A7F              CheckAUEnd:
 258+ 6A7F 3E 08        		ld a, EXT_AU_CNT
 259+ 6A81 90           		sub b
 260+ 6A82 47           		ld b, a
 261+ 6A83 DD E1        	pop ix
 262+ 6A85 C9           	ret
 263+ 6A86
 264+ 6A86              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265+ 6A86
 266+ 6A86              ;Input: TrackBuffer
 267+ 6A86              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268+ 6A86              ReadUsedBlocksList:
 269+ 6A86 DD 21 CB 88  	ld		ix, TrackBuf			;source buffer
 270+ 6A8A 21 E1 82     	ld		hl, UsedBlockListCnt 	;destination buffer
 271+ 6A8D 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272+ 6A90 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 273+ 6A93 73           	ld		(hl), e
 274+ 6A94 23           	inc		hl
 275+ 6A95 72           	ld		(hl), d
 276+ 6A96 23           	inc		hl
 277+ 6A97
 278+ 6A97              	;Add blocks 0 and 1 for directory
 279+ 6A97 11 00 00     	ld		de, 0
 280+ 6A9A 73           	ld		(hl), e
 281+ 6A9B 23           	inc		hl
 282+ 6A9C 72           	ld		(hl), d
 283+ 6A9D 23           	inc		hl
 284+ 6A9E
 285+ 6A9E 13           	inc		de
 286+ 6A9F 73           	ld		(hl), e
 287+ 6AA0 23           	inc		hl
 288+ 6AA1 72           	ld		(hl), d
 289+ 6AA2 23           	inc		hl
 290+ 6AA3
 291+ 6AA3              ReadUsedBlocksLoop:
 292+ 6AA3 AF           	xor		a
 293+ 6AA4 DD BE 00     	cp		(ix)
 294+ 6AA7 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295+ 6AA9
 296+ 6AA9 DD E5        	push	ix
 297+ 6AAB C5           	push	bc
 298+ 6AAC 06 08        		ld		b, EXT_AU_CNT
 299+ 6AAE 11 10 00     		ld		de, EXT_AU0
 300+ 6AB1 DD 19        		add		ix, de
 301+ 6AB3
 302+ 6AB3              ReadUsedBlocksLoop2:
 303+ 6AB3 DD 5E 00     		ld		e, (ix)
 304+ 6AB6 DD 56 01     		ld		d, (ix+1)
 305+ 6AB9 7B           		ld		a, e
 306+ 6ABA B2           		or		d
 307+ 6ABB 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308+ 6ABD
 309+ 6ABD 73           		ld		(hl), e
 310+ 6ABE 23           		inc		hl
 311+ 6ABF 72           		ld		(hl), d
 312+ 6AC0 23           		inc		hl
 313+ 6AC1
 314+ 6AC1 DD 23        		inc		ix
 315+ 6AC3 DD 23        		inc		ix
 316+ 6AC5
 317+ 6AC5 ED 5B E1 82  		ld		de, (UsedBlockListCnt)
 318+ 6AC9 13           		inc		de
 319+ 6ACA ED 53 E1 82  		ld		(UsedBlockListCnt), de
 320+ 6ACE
 321+ 6ACE 10 E3        		djnz	ReadUsedBlocksLoop2
 322+ 6AD0
 323+ 6AD0
 324+ 6AD0              ReadUsedBlocksSkip:
 325+ 6AD0 C1           	pop		bc
 326+ 6AD1 DD E1        	pop		ix
 327+ 6AD3              ReadUsedBlocksSkip2:
 328+ 6AD3 11 20 00     	ld		de, EXT_SZ
 329+ 6AD6 DD 19        	add		ix, de
 330+ 6AD8
 331+ 6AD8 0B           	dec		bc
 332+ 6AD9 78           	ld		a, b
 333+ 6ADA B1           	or		c
 334+ 6ADB 20 C6        	jr		nz, ReadUsedBlocksLoop
 335+ 6ADD
 336+ 6ADD C9           	ret
 337+ 6ADE
 338+ 6ADE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339+ 6ADE              ;Reads 8 sectors for an AU
 340+ 6ADE              ;HL = block number, DE = destination buffer
 341+ 6ADE              ReadFSBlock:
 342+ 6ADE D5           	push	de
 343+ 6ADF CD 39 6A     		call	AU2TS		;B=sector, C=track
 344+ 6AE2 E1           	pop		hl				;HL=dest
 345+ 6AE3
 346+ 6AE3 50           	ld		d, b
 347+ 6AE4 59           	ld		e, c
 348+ 6AE5 06 08        	ld		b, SPAL
 349+ 6AE7
 350+ 6AE7              ReadFSBlockLoop:
 351+ 6AE7 CD CA 6C     	call	ReadDiskSectors
 352+ 6AEA C9           	ret
 353+ 6AEB
 354+ 6AEB
 355+ 6AEB              ;Write 8 sectors for an AU
 356+ 6AEB              ;HL = block number, DE = source buffer
 357+ 6AEB              WriteFSBlock:
 358+ 6AEB D5           	push	de
 359+ 6AEC CD 39 6A     		call	AU2TS		;B=sector, C=track
 360+ 6AEF E1           	pop		hl				;HL=dest
 361+ 6AF0
 362+ 6AF0 50           	ld		d, b
 363+ 6AF1 59           	ld		e, c
 364+ 6AF2 06 08        	ld		b, SPAL
 365+ 6AF4
 366+ 6AF4              WriteFSBlockLoop:
 367+ 6AF4 CD DD 6C     	call	WriteDiskSectors
 368+ 6AF7 C9           	ret
 369+ 6AF8
 370+ 6AF8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371+ 6AF8              ;Copies the allocated blocks from one disk to another, dual drive.
 372+ 6AF8              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373+ 6AF8              CopyDisk:
 374+ 6AF8              	;Get list of used blocks in current disk, max 632 bytes
 375+ 6AF8 CD 86 6A     	call	ReadUsedBlocksList
 376+ 6AFB DD 21 E3 82  	ld		ix, UsedBlockListBlk
 377+ 6AFF
 378+ 6AFF              CopyDiskLoop:
 379+ 6AFF 2A E1 82     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380+ 6B02 11 4C 7A     	ld		de, MsgBlocksLeft
 381+ 6B05 CD 93 69     	call	Byte2Txt
 382+ 6B08 21 4C 7A     	ld		hl, MsgBlocksLeft
 383+ 6B0B 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 384+ 6B0E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 385+ 6B10 CD 40 72     	call	PrintStrClr
 386+ 6B13 21 8F 79     	ld		hl, MsgClear
 387+ 6B16 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 388+ 6B19 3E 45        	ld		a, SCR_DEF_CLR
 389+ 6B1B CD 40 72     	call	PrintStrClr
 390+ 6B1E
 391+ 6B1E              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 392+ 6B1E 21 0E 00     	ld		hl, MAX_AU_RAM
 393+ 6B21 ED 4B E1 82  	ld		bc, (UsedBlockListCnt)
 394+ 6B25 B7           	or		a
 395+ 6B26 ED 42        	sbc		hl, bc
 396+ 6B28 30 03        	jr		nc, CopyDiskLoopRead
 397+ 6B2A 01 0E 00     	ld		bc, MAX_AU_RAM
 398+ 6B2D
 399+ 6B2D              CopyDiskLoopRead:
 400+ 6B2D 41           	ld		b, c
 401+ 6B2E 11 CB 88     	ld		de, CopyDiskBuf
 402+ 6B31              	;save initial counter and initial block number array position
 403+ 6B31 C5           	push	bc
 404+ 6B32 DD E5        	push	ix
 405+ 6B34
 406+ 6B34              CopyDiskLoopReadLoop:
 407+ 6B34 DD 6E 00     		ld		l, (ix)
 408+ 6B37 DD 66 01     		ld		h, (ix+1)
 409+ 6B3A DD 23        		inc		ix
 410+ 6B3C DD 23        		inc		ix
 411+ 6B3E
 412+ 6B3E D5           		push	de
 413+ 6B3F C5           		push	bc
 414+ 6B40 CD DE 6A     			call	ReadFSBlock			;Stop on error or continue?
 415+ 6B43 C1           		pop		bc
 416+ 6B44 D1           		pop		de
 417+ 6B45
 418+ 6B45              		;+2048
 419+ 6B45 7A           		ld		a, d
 420+ 6B46 C6 08        		add		8
 421+ 6B48 57           		ld		d, a
 422+ 6B49
 423+ 6B49 10 E9        		djnz	CopyDiskLoopReadLoop
 424+ 6B4B
 425+ 6B4B              		;Check if selection is 1=single drive or 2=dual drive
 426+ 6B4B 3A AD 7A     		ld		a, (CopySelOption)
 427+ 6B4E FE 31        		cp		'1'
 428+ 6B50 20 0B        		jr		nz, CopyDiskDualDrive1
 429+ 6B52
 430+ 6B52              		;Prompt for disk change
 431+ 6B52 CD DF 6E     		call	PromptDiskChangeDst
 432+ 6B55 3A CC 6D     		ld		a, (RWTSDrive)
 433+ 6B58 CD F4 6D     		call	BDOSInit
 434+ 6B5B 18 0A        		jr		CopyDiskReadEnd
 435+ 6B5D
 436+ 6B5D              CopyDiskDualDrive1:
 437+ 6B5D              		;alternate drive
 438+ 6B5D 3A CC 6D     		ld		a, (RWTSDrive)
 439+ 6B60 3C           		inc 	a
 440+ 6B61 EE 03        		xor		%11
 441+ 6B63 3D           		dec		a
 442+ 6B64 32 CC 6D     		ld		(RWTSDrive), a
 443+ 6B67
 444+ 6B67              CopyDiskReadEnd:
 445+ 6B67              	;restore initial counter and initial block number array position
 446+ 6B67 DD E1        	pop		ix
 447+ 6B69 C1           	pop		bc
 448+ 6B6A 11 CB 88     	ld		de, CopyDiskBuf
 449+ 6B6D C5           	push	bc
 450+ 6B6E
 451+ 6B6E              CopyDiskLoopWriteLoop:
 452+ 6B6E DD 6E 00     		ld		l, (ix)
 453+ 6B71 DD 66 01     		ld		h, (ix+1)
 454+ 6B74 DD 23        		inc		ix
 455+ 6B76 DD 23        		inc		ix
 456+ 6B78
 457+ 6B78 D5           		push	de
 458+ 6B79 C5           		push	bc
 459+ 6B7A CD EB 6A     			call	WriteFSBlock		;Stop on error or continue?
 460+ 6B7D C1           		pop		bc
 461+ 6B7E D1           		pop		de
 462+ 6B7F
 463+ 6B7F              		;+2048
 464+ 6B7F 7A           		ld		a, d
 465+ 6B80 C6 08        		add		8
 466+ 6B82 57           		ld		d, a
 467+ 6B83
 468+ 6B83 10 E9        		djnz	CopyDiskLoopWriteLoop
 469+ 6B85
 470+ 6B85              CopyDiskWriteEnd:
 471+ 6B85 C1           	pop		bc
 472+ 6B86 48           	ld		c, b
 473+ 6B87 06 00        	ld		b, 0
 474+ 6B89
 475+ 6B89              	;Decrease number of blocks read by now.
 476+ 6B89 2A E1 82     	ld		hl, (UsedBlockListCnt)
 477+ 6B8C B7           	or		a
 478+ 6B8D ED 42        	sbc		hl, bc
 479+ 6B8F 22 E1 82     	ld		(UsedBlockListCnt), hl
 480+ 6B92
 481+ 6B92 7D           	ld		a, l
 482+ 6B93 B4           	or		h
 483+ 6B94 C8           	ret		z						;Exit if finished all blocks.
 484+ 6B95
 485+ 6B95              	;Check if selection is 1=single drive or 2=dual drive
 486+ 6B95 3A AD 7A     	ld		a, (CopySelOption)
 487+ 6B98 FE 31        	cp		'1'
 488+ 6B9A 20 0C        	jr		nz, CopyDiskDualDrive2
 489+ 6B9C
 490+ 6B9C              	;Prompt for disk change
 491+ 6B9C CD F9 6E     	call	PromptDiskChangeSrc
 492+ 6B9F 3A CC 6D     	ld		a, (RWTSDrive)
 493+ 6BA2 CD F4 6D     	call	BDOSInit
 494+ 6BA5 C3 FF 6A     	jp		CopyDiskLoop
 495+ 6BA8
 496+ 6BA8              CopyDiskDualDrive2:
 497+ 6BA8              	;alternate drive again
 498+ 6BA8 3A CC 6D     	ld		a, (RWTSDrive)
 499+ 6BAB 3C           	inc		a
 500+ 6BAC EE 03        	xor		%11
 501+ 6BAE 3D           	dec		a
 502+ 6BAF 32 CC 6D     	ld		(RWTSDrive), a
 503+ 6BB2 C3 FF 6A     	jp		CopyDiskLoop
 504+ 6BB5
 505+ 6BB5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 506+ 6BB5              ;Copies the current disk blocks to COM port.
 507+ 6BB5              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 508+ 6BB5              CopyDiskToCOM:
 509+ 6BB5              	;Get list of used blocks in current disk, max 632 bytes
 510+ 6BB5 CD 86 6A     	call	ReadUsedBlocksList
 511+ 6BB8
 512+ 6BB8              	;Send block count and block indexes
 513+ 6BB8 2A E1 82     	ld		hl, (UsedBlockListCnt)
 514+ 6BBB 29           	add		hl, hl
 515+ 6BBC 23           	inc		hl
 516+ 6BBD 23           	inc		hl
 517+ 6BBE 44           	ld		b, h
 518+ 6BBF 4D           	ld		c, l
 519+ 6BC0 21 E1 82     	ld		hl, UsedBlockListCnt
 520+ 6BC3 CD BB 77     	call	SERTB
 521+ 6BC6
 522+ 6BC6 DD 21 E3 82  	ld		ix, UsedBlockListBlk
 523+ 6BCA
 524+ 6BCA              CopyDiskToCOMLoop:
 525+ 6BCA              	;Print block count left
 526+ 6BCA 2A E1 82     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 527+ 6BCD 11 4C 7A     	ld		de, MsgBlocksLeft
 528+ 6BD0 CD 93 69     	call	Byte2Txt
 529+ 6BD3 21 4C 7A     	ld		hl, MsgBlocksLeft
 530+ 6BD6 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 531+ 6BD9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 532+ 6BDB CD 40 72     	call	PrintStrClr
 533+ 6BDE
 534+ 6BDE              	;Read block into buffer
 535+ 6BDE DD 6E 00     	ld		l, (ix)
 536+ 6BE1 DD 66 01     	ld		h, (ix+1)
 537+ 6BE4 11 CB 88     	ld		de, CopyDiskBuf
 538+ 6BE7 DD E5        	push	ix
 539+ 6BE9 CD DE 6A     		call	ReadFSBlock
 540+ 6BEC DD E1        	pop		ix
 541+ 6BEE DD 23        	inc		ix
 542+ 6BF0 DD 23        	inc		ix
 543+ 6BF2
 544+ 6BF2              	;Send block buffer
 545+ 6BF2 21 CB 88     	ld		hl, CopyDiskBuf
 546+ 6BF5 01 00 08     	ld		bc, AU_SZ
 547+ 6BF8 CD BB 77     	call	SERTB
 548+ 6BFB
 549+ 6BFB ED 4B E1 82  	ld		bc, (UsedBlockListCnt)
 550+ 6BFF 0B           	dec		bc
 551+ 6C00 ED 43 E1 82  	ld		(UsedBlockListCnt), bc
 552+ 6C04
 553+ 6C04 DD E5        	push	ix
 554+ 6C06 CD DF 71     		call	KbdHit
 555+ 6C09 DD E1        	pop		ix
 556+ 6C0B D8           	ret		c
 557+ 6C0C
 558+ 6C0C 78           	ld		a, b
 559+ 6C0D B1           	or		c
 560+ 6C0E 20 BA        	jr		nz, CopyDiskToCOMLoop
 561+ 6C10
 562+ 6C10 C9           	ret
 563+ 6C11
 564+ 6C11              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 565+ 6C11              CopyDiskFromCOM:
 566+ 6C11              	;Receive block count.
 567+ 6C11 21 E1 82     	ld		hl, UsedBlockListCnt
 568+ 6C14 01 02 00     	ld		bc, 2
 569+ 6C17 1E 00        	ld		e, 0
 570+ 6C19 CD 88 77     	call	SERRB
 571+ 6C1C
 572+ 6C1C              	;Receive block indexes.
 573+ 6C1C 2A E1 82     	ld		hl, (UsedBlockListCnt)
 574+ 6C1F 29           	add		hl, hl
 575+ 6C20 44           	ld		b, h
 576+ 6C21 4D           	ld		c, l
 577+ 6C22 21 E3 82     	ld		hl, UsedBlockListBlk
 578+ 6C25 1E 00        	ld		e, 0
 579+ 6C27 CD 88 77     	call	SERRB
 580+ 6C2A
 581+ 6C2A              	;Read each block by index and write to disk
 582+ 6C2A DD 21 E3 82  	ld		ix, UsedBlockListBlk
 583+ 6C2E
 584+ 6C2E              CopyDiskFromCOMLoop:
 585+ 6C2E              	;Print block count left
 586+ 6C2E 2A E1 82     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 587+ 6C31 11 4C 7A     	ld		de, MsgBlocksLeft
 588+ 6C34 CD 93 69     	call	Byte2Txt
 589+ 6C37 21 4C 7A     	ld		hl, MsgBlocksLeft
 590+ 6C3A 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 591+ 6C3D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 592+ 6C3F CD 40 72     	call	PrintStrClr
 593+ 6C42
 594+ 6C42              	;Read block buffer
 595+ 6C42 21 CB 88     	ld		hl, CopyDiskBuf
 596+ 6C45 01 00 08     	ld		bc, AU_SZ
 597+ 6C48 1E 00        	ld		e, 0
 598+ 6C4A CD 88 77     	call	SERRB
 599+ 6C4D
 600+ 6C4D              	;Write block to disk
 601+ 6C4D DD 6E 00     	ld		l, (ix)
 602+ 6C50 DD 66 01     	ld		h, (ix+1)
 603+ 6C53 11 CB 88     	ld		de, CopyDiskBuf
 604+ 6C56 DD E5        	push	ix
 605+ 6C58 CD EB 6A     		call	WriteFSBlock			;Stop on error or continue?
 606+ 6C5B DD E1        	pop		ix
 607+ 6C5D DD 23        	inc		ix
 608+ 6C5F DD 23        	inc		ix
 609+ 6C61
 610+ 6C61 ED 4B E1 82  	ld		bc, (UsedBlockListCnt)
 611+ 6C65 0B           	dec		bc
 612+ 6C66 ED 43 E1 82  	ld		(UsedBlockListCnt), bc
 613+ 6C6A
 614+ 6C6A DD E5        	push	ix
 615+ 6C6C CD DF 71     		call	KbdHit
 616+ 6C6F DD E1        	pop		ix
 617+ 6C71 D8           	ret		c
 618+ 6C72
 619+ 6C72 78           	ld		a, b
 620+ 6C73 B1           	or		c
 621+ 6C74 20 B8        	jr		nz, CopyDiskFromCOMLoop
 622+ 6C76 C9           	ret
 623+ 6C77
 624+ 6C77              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 625+ 6C77
 626+ 6C77              ;Compare string at HL with the one at DE, max length B
 627+ 6C77              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 628+ 6C77              ;OUT: z flag, set = match, reset = mismatch
 629+ 6C77              StrCmp:
 630+ 6C77 E5           	push hl
 631+ 6C78 D5           	push de
 632+ 6C79              Compare:
 633+ 6C79 1A           		ld a, (de)
 634+ 6C7A BE           		cp (hl)
 635+ 6C7B 20 04        		jr nz, MisMatch
 636+ 6C7D 23           		inc hl
 637+ 6C7E 13           		inc de
 638+ 6C7F 10 F8        		djnz Compare
 639+ 6C81              MisMatch:
 640+ 6C81 D1           	pop de
 641+ 6C82 E1           	pop hl
 642+ 6C83 C9           	ret
 643+ 6C84
 644+ 6C84              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 645+ 6C84
 646+ 6C84              ;Read a file into a buffer, sector by sector.
 647+ 6C84              ;It's relocatable, to moved and be used when loading a CODE block.
 648+ 6C84              ;It's not using BDOS, but using similar calls provided by IF1.
 649+ 6C84              ;In: HL = Name address, DE = buffer
 650+ 6C84              IF1FileLoad:
 651+ 6C84 D5           	push	de
 652+ 6C85 22 DC 5C     		ld (FSTR1), hl
 653+ 6C88 26 00        		ld h, 0
 654+ 6C8A 3A CC 6D     		ld a, (RWTSDrive)
 655+ 6C8D 3C           		inc  a			;CP/M drive number to BASIC drive number
 656+ 6C8E 6F           		ld	l, a
 657+ 6C8F 22 D6 5C     		ld (DSTR1), hl
 658+ 6C92 2E 0B        		ld l,NAMELEN
 659+ 6C94 22 DA 5C     		ld (NSTR1), hl
 660+ 6C97 CF           		rst 08
 661+ 6C98 33           		DEFB 51			;open disk channel
 662+ 6C99
 663+ 6C99 CF           		rst		8
 664+ 6C9A 35           		defb	53		;read sector
 665+ 6C9B D1           	pop		de
 666+ 6C9C 30 27        	jr		nc, FileFree
 667+ 6C9E
 668+ 6C9E DD 7E 32     	ld		a, (ix + CH_DATA)
 669+ 6CA1 FE 04        	cp		TEXT_TYPE
 670+ 6CA3 30 12        	jr		nc, FileLoadNoHeader
 671+ 6CA5
 672+ 6CA5              FileLoadHeader:
 673+ 6CA5 DD E5        	push	ix
 674+ 6CA7 E1           	pop		hl
 675+ 6CA8 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 676+ 6CAB 09           	add		hl, bc
 677+ 6CAC 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 678+ 6CAF ED B0        	ldir
 679+ 6CB1
 680+ 6CB1              FileReadLoop:
 681+ 6CB1 D5           	push	de
 682+ 6CB2 CF           		rst		8
 683+ 6CB3 35           		defb	53		;read sector
 684+ 6CB4 D1           	pop		de
 685+ 6CB5 30 0E        	jr		nc, FileFree
 686+ 6CB7
 687+ 6CB7              FileLoadNoHeader:
 688+ 6CB7 DD E5        	push	ix
 689+ 6CB9 E1           	pop		hl
 690+ 6CBA 01 32 00     	ld		bc, CH_DATA
 691+ 6CBD 09           	add		hl, bc
 692+ 6CBE 01 00 01     	ld		bc, SECT_SZ
 693+ 6CC1 ED B0        	ldir
 694+ 6CC3 18 EC        	jr		FileReadLoop
 695+ 6CC5              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 696+ 6CC5              IF1FileLoadEnd:
 697+ 6CC5
 698+ 6CC5              FileFree:
 699+ 6CC5 D5           	push	de
 700+ 6CC6 CF           	rst		8
 701+ 6CC7 38           	defb	56			;close channel (52) or detroy channel (56)
 702+ 6CC8 D1           	pop		de
 703+ 6CC9 C9           	ret
 704+ 6CCA
 705+ 6CCA
 706+ 6CCA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 6CCA              ;HL = destination buffer, B = count of sectors, DE = track/sector
 708+ 6CCA              ;Out: A = error code, 0=OK
 709+ 6CCA              ReadDiskSectors:
 710+ 6CCA C5           	push bc
 711+ 6CCB E5           		push hl
 712+ 6CCC D5           			push de
 713+ 6CCD CD 12 6A     				call ReadOneDiskSector
 714+ 6CD0 D1           			pop de
 715+ 6CD1 E1           		pop hl
 716+ 6CD2
 717+ 6CD2 14           		inc d
 718+ 6CD3 24           		inc h
 719+ 6CD4 C1           	pop bc
 720+ 6CD5
 721+ 6CD5 3A D7 6D     	ld	a, (RWTSRes)
 722+ 6CD8 B7           	or	a
 723+ 6CD9 C0           	ret nz
 724+ 6CDA
 725+ 6CDA 10 EE        	djnz ReadDiskSectors
 726+ 6CDC C9           	ret
 727+ 6CDD
 728+ 6CDD              ;HL = source buffer, B = count of sectors, DE = track/sector
 729+ 6CDD              ;Out: A = error code, 0=OK
 730+ 6CDD              WriteDiskSectors:
 731+ 6CDD C5           	push bc
 732+ 6CDE E5           		push hl
 733+ 6CDF D5           			push de
 734+ 6CE0 CD 1D 6A     				call WriteOneDiskSector
 735+ 6CE3 D1           			pop de
 736+ 6CE4 E1           		pop hl
 737+ 6CE5
 738+ 6CE5 14           		inc d
 739+ 6CE6 24           		inc h
 740+ 6CE7 C1           	pop bc
 741+ 6CE8
 742+ 6CE8 3A D7 6D     	ld	a, (RWTSRes)
 743+ 6CEB B7           	or	a
 744+ 6CEC C0           	ret nz
 745+ 6CED
 746+ 6CED 10 EE        	djnz WriteDiskSectors
 747+ 6CEF C9           	ret
 748+ 6CF0
 749+ 6CF0
 750+ 6CF0              ;Reads disk catalog
 751+ 6CF0              ReadCatalogTrack:
 752+ 6CF0 21 CB 88     	ld hl, TrackBuf
 753+ 6CF3 11 00 00     	ld de, 0
 754+ 6CF6 06 10        	ld b, SPT
 755+ 6CF8
 756+ 6CF8 CD CA 6C     	call ReadDiskSectors
 757+ 6CFB B7           	or   a
 758+ 6CFC C0           	ret  nz
 759+ 6CFD
 760+ 6CFD              	;Sync with BDOS, to avoid disk R/O error on disk change
 761+ 6CFD F5           	push  af
 762+ 6CFE 3A CC 6D     		ld  a, (RWTSDrive)
 763+ 6D01 CD F7 6D     		call BDOSSelectDisk
 764+ 6D04 CD F4 6D     		call BDOSInit
 765+ 6D07 F1           	pop   af
 766+ 6D08 C9           	ret
 767+ 6D09
 768+ 6D09
 769+ 6D09
 770+ 6D09              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 771+ 6D09
 772+ 6D09              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 773+ 6D09              FindCache:
 774+ 6D09 06 0B        	ld		b, NAMELEN
 775+ 6D0B CD 77 6C     	call	StrCmp			;find the file to wich this extension belongs
 776+ 6D0E C8           	ret		z
 777+ 6D0F
 778+ 6D0F 0D           	dec		c
 779+ 6D10 20 02        	jr		nz, CacheNotFinished
 780+ 6D12 B1           	or		c
 781+ 6D13 C9           	ret
 782+ 6D14
 783+ 6D14              CacheNotFinished:
 784+ 6D14 01 19 00     	ld		bc, CACHE_SZ
 785+ 6D17 09           	add		hl, bc			;to the next cache line
 786+ 6D18 18 EF        	jr		FindCache
 787+ 6D1A
 788+ 6D1A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 789+ 6D1A
 790+ 6D1A              	;ld		ix, (SelFileCache)
 791+ 6D1A              ReadFileHeader:
 792+ 6D1A DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 793+ 6D1D B7           	or		a
 794+ 6D1E C0           	ret		nz				;return if already read
 795+ 6D1F
 796+ 6D1F DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 797+ 6D22 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 798+ 6D25 7C           	ld		a, h
 799+ 6D26 B5           	or		l
 800+ 6D27 28 46        	jr		z, ReadHeaderEnd
 801+ 6D29
 802+ 6D29 CD 39 6A     	call	AU2TS
 803+ 6D2C 50           	ld		d, b
 804+ 6D2D 59           	ld		e, c
 805+ 6D2E 21 CB 88     	ld		hl, DataBuf
 806+ 6D31 DD E5        	push	ix
 807+ 6D33 DD E5        	push	ix
 808+ 6D35 CD 12 6A     		call	ReadOneDiskSector
 809+ 6D38 E1           	pop		hl
 810+ 6D39 DD E1        	pop		ix
 811+ 6D3B
 812+ 6D3B E5           	push	hl
 813+ 6D3C 21 CB 88     		ld		hl, DataBuf
 814+ 6D3F CD 73 6D     		call	IsFileHeaderValid
 815+ 6D42 E1           	pop		hl
 816+ 6D43 B7           	or		a
 817+ 6D44 28 14        	jr		z, ReadFileHeaderIsTextFile
 818+ 6D46
 819+ 6D46 01 10 00     	ld		bc, CACHE_HDR
 820+ 6D49 09           	add		hl, bc
 821+ 6D4A EB           	ex		hl, de
 822+ 6D4B 21 CB 88     	ld		hl, DataBuf
 823+ 6D4E 01 09 00     	ld		bc, HDR_SZ
 824+ 6D51 ED B0        	ldir
 825+ 6D53
 826+ 6D53              	;For text files, read file size as reported by BDOS, since we don't have a header.
 827+ 6D53 3E 03        	ld		a, BYTE_TYPE
 828+ 6D55 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 829+ 6D58 30 15        	jr		nc, ReadHeaderEnd
 830+ 6D5A
 831+ 6D5A              ReadFileHeaderIsTextFile:
 832+ 6D5A DD E5        	push	ix
 833+ 6D5C DD E5        	push	ix
 834+ 6D5E E1           	pop		hl
 835+ 6D5F CD 4E 6E     		call	GetFileSize
 836+ 6D62 DD E1        	pop		ix
 837+ 6D64 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 838+ 6D67 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 839+ 6D6A 3E 04        	ld		a, TEXT_TYPE
 840+ 6D6C DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 841+ 6D6F
 842+ 6D6F              ReadHeaderEnd:
 843+ 6D6F DD 34 0F     	inc		(ix + CACHE_FLAG)
 844+ 6D72 C9           	ret
 845+ 6D73
 846+ 6D73              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 847+ 6D73              ;Checks if the file header is valid. For now it checks to not have all 0s.
 848+ 6D73              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 849+ 6D73              ;In: HL = header
 850+ 6D73              ;Out: A > 0 if valid
 851+ 6D73              IsFileHeaderValid:
 852+ 6D73              	IFUSED
 853+ 6D73 AF           	xor		a
 854+ 6D74 06 09        	ld		b, HDR_SZ
 855+ 6D76              IsFileHeaderValidLoop:
 856+ 6D76 B6           	or		(hl)
 857+ 6D77 23           	inc		hl
 858+ 6D78 10 FC        	djnz	IsFileHeaderValidLoop
 859+ 6D7A
 860+ 6D7A C9           	ret
 861+ 6D7B              	ENDIF
 862+ 6D7B
 863+ 6D7B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864+ 6D7B
 865+ 6D7B              ;IN: HL = address from IF1 to call
 866+ 6D7B              IF1Call:
 867+ 6D7B 22 ED 5C     	LD   (HD11), HL
 868+ 6D7E CF           	RST  8
 869+ 6D7F 32           	DEFB 50
 870+ 6D80 C9           	RET
 871+ 6D81
 872+ 6D81              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 873+ 6D81
 874+ 6D81              ;Load a program from disk
 875+ 6D81              ;IN: HL = file name addr
 876+ 6D81              LoadProgram:
 877+ 6D81 22 DC 5C     	LD   (FSTR1), HL
 878+ 6D84 26 00        	LD   H, 0
 879+ 6D86 2E 0B        	LD   L, NAMELEN
 880+ 6D88 22 DA 5C     	LD   (NSTR1), HL
 881+ 6D8B 3A CC 6D     	LD	 A, (RWTSDrive)
 882+ 6D8E 3C           	INC  A					;Adapt for BASIC drive number
 883+ 6D8F 6F           	LD   L, A
 884+ 6D90 22 D6 5C     	LD   (DSTR1), HL
 885+ 6D93 21 41 0A     	LD   HL, LOAD_ADDR
 886+ 6D96 CD 7B 6D     	CALL IF1Call
 887+ 6D99 C9           	RET
 888+ 6D9A
 889+ 6D9A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890+ 6D9A
 891+ 6D9A              SetFastKeys:
 892+ 6D9A 21 09 5C     	ld		hl, REPDEL
 893+ 6D9D 11 0F 01     	ld		de, (1 << 8) | 15
 894+ 6DA0 73 23 72 2B  	ld		(hl), de
 895+ 6DA4
 896+ 6DA4 C9           	ret
 897+ 6DA5
 898+ 6DA5
 899+ 6DA5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 900+ 6DA5              ;Reads the error message string from IF1 ROM.
 901+ 6DA5              GetErrMsg:
 902+ 6DA5 3C           	inc		a
 903+ 6DA6 08           	ex		af, af'
 904+ 6DA7
 905+ 6DA7 21 AD 6D     	ld		hl, IF1Paged			;page-in IF1
 906+ 6DAA C3 7B 6D     	jp		IF1Call
 907+ 6DAD
 908+ 6DAD              IF1Paged:
 909+ 6DAD 21 60 02     	ld		hl, ERRMSG
 910+ 6DB0 08           	ex		af, af'
 911+ 6DB1 B7           	or		a
 912+ 6DB2 28 0B        	jr		z, SaveMsg
 913+ 6DB4
 914+ 6DB4 06 00        	ld		b, 0
 915+ 6DB6              SearchMsgEnd:
 916+ 6DB6 CB 7E        	bit		7, (hl)
 917+ 6DB8 23           	inc		hl
 918+ 6DB9 28 FB        	jr		z, SearchMsgEnd
 919+ 6DBB
 920+ 6DBB 04           	inc		b
 921+ 6DBC B8           	cp		b
 922+ 6DBD 20 F7        	jr		nz, SearchMsgEnd
 923+ 6DBF
 924+ 6DBF              SaveMsg:
 925+ 6DBF 11 CB 88     	ld		de, DataBuf
 926+ 6DC2              CopyMsg:
 927+ 6DC2 7E           	ld		a, (hl)
 928+ 6DC3 CB 7F        	bit		7, a
 929+ 6DC5 12           	ld		(de), a
 930+ 6DC6 23           	inc		hl
 931+ 6DC7 13           	inc		de
 932+ 6DC8 28 F8        	jr		z, CopyMsg
 933+ 6DCA
 934+ 6DCA C9           	ret
 935+ 6DCB
 936+ 6DCB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 937+ 6DCB
 938+ 6DCB              ;RWTS routine I/O block
 939+ 6DCB              RWTSParams:
 940+ 6DCB 01           RWTSBlockType	DEFB	1							;?
 941+ 6DCC 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 942+ 6DCD 00           RWTSVolNo		DEFB	0							;?
 943+ 6DCE 00           RWTSTrack		DEFB	0
 944+ 6DCF 00           RWTSSector		DEFB	0
 945+ 6DD0 00 00        RWTSDMA			DEFW	0
 946+ 6DD2 32 29        RWTSExtBuf		DEFW	$2932
 947+ 6DD4              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 948+ 6DD4              	IFDEF _REAL_HW_
 949+ 6DD4 DE 6D        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 950+ 6DD6              	ELSE
 951+ 6DD6 ~            RWTSPrmTbl		DEFW	$1f2a
 952+ 6DD6              	ENDIF
 953+ 6DD6 01           RWTSCmd			DEFB	RWTS_CMD_READ
 954+ 6DD7              ;Results
 955+ 6DD7 00           RWTSRes			DEFB	0
 956+ 6DD8 00           RWTSResVolNo	DEFB	0
 957+ 6DD9 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 957+ 6DDD 00
 958+ 6DDE
 959+ 6DDE              ;Param. table, usualy found in ROM.
 960+ 6DDE              	IFDEF _REAL_HW_
 961+ 6DDE              BasPrmTbl:
 962+ 6DDE 01           PrmDevType		DEFB	$01		;$01
 963+ 6DDF 01           PrmStepRate		DEFB	$01		;$0D	(milisec)
 964+ 6DE0 01           PrmHeadLoad		DEFB	$01		;$23	(milisec)
 965+ 6DE1 01           PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 966+ 6DE2 E4 6D        PrmIntrlvTbl	DEFW	InterleaveTbl
 967+ 6DE4 01 03 05 07  InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 967+ 6DE8 09 0B 0D 0F
 967+ 6DEC 02 04 06 08
 967+ 6DF0 0A 0C 0E 10
 968+ 6DF4              	ENDIF
 969+ 6DF4
 970+ 6DF4              	endif
# file closed: if1.asm
1247  6DF4              	include "bdos.asm"
# file opened: bdos.asm
   1+ 6DF4              ;BDOS functions - similar to CP/M
   2+ 6DF4
   3+ 6DF4              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 6DF4              ;0 OK,
   5+ 6DF4              ;1 directory full,
   6+ 6DF4              ;2 disc full,
   7+ 6DF4              ;9 invalid FCB,
   8+ 6DF4              ;10(CP/M) media changed;
   9+ 6DF4              ;0FFh hardware error.
  10+ 6DF4
  11+ 6DF4              	IFNDEF	_BDOS_
  12+ 6DF4              	DEFINE	_BDOS_
  13+ 6DF4
  14+ 6DF4              	include "if1.asm"
# file opened: if1.asm
   1++6DF4              ;HC IF1 routines and constants
   2++6DF4
   3++6DF4              ;IF1 routines error codes, also returned by BASIC commands
   4++6DF4              ;12 = Writing to a 'read' file
   5++6DF4              ;13 = Reading a 'write' file
   6++6DF4              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++6DF4              ;15 = Disk full (disk or catalog full)
   8++6DF4              ;16 = Disk error (hardware error)
   9++6DF4              ;17 = File not found
  10++6DF4              ;23 = Disk R/O (disk change detected, software R/O)
  11++6DF4              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++6DF4
  13++6DF4              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++6DF4              ;00h = OK
  15++6DF4              ;08h = cannot format disk
  16++6DF4              ;10h = disk protected (read-only?)
  17++6DF4              ;20h = volume error
  18++6DF4              ;40h = drive error
  19++6DF4              ;80h = reading error
  20++6DF4              ;Codes I encountered:
  21++6DF4              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++6DF4
  23++6DF4
  24++6DF4              	ifndef	_DISK_
  25++6DF4 ~            	define	_DISK_
  26++6DF4 ~
  27++6DF4 ~            	include	"math.asm"
  28++6DF4 ~
  29++6DF4 ~            DRIVE_CUR_BAS	EQU 0
  30++6DF4 ~            DRIVE_A_BAS		EQU	1
  31++6DF4 ~            DRIVE_B_BAS		EQU	2
  32++6DF4 ~            DRIVE_A_CPM		EQU	0
  33++6DF4 ~            DRIVE_B_CPM		EQU	1
  34++6DF4 ~            ;Disk geometry stuff
  35++6DF4 ~            SPT				EQU	16			;sectors per track
  36++6DF4 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++6DF4 ~            TRACK_CNT		EQU	80			;track count
  38++6DF4 ~            HEAD_CNT		EQU	2			;disk face count
  39++6DF4 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++6DF4 ~            EXT_SZ			EQU	32			;directory entry size
  41++6DF4 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++6DF4 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++6DF4 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++6DF4 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++6DF4 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++6DF4 ~            REC_SZ			EQU 128			;cp/m record size
  47++6DF4 ~            DEL_MARKER		EQU	$E5
  48++6DF4 ~
  49++6DF4 ~
  50++6DF4 ~            ;Extension structure (directory entry)
  51++6DF4 ~            EXT_DEL_FLAG	EQU	0
  52++6DF4 ~            EXT_NAME		EQU 1
  53++6DF4 ~            EXT_IDX			EQU 12
  54++6DF4 ~            EXT_S1			EQU 13
  55++6DF4 ~            EXT_S2			EQU 14
  56++6DF4 ~            EXT_RC			EQU	15
  57++6DF4 ~            EXT_AU0			EQU	16
  58++6DF4 ~            EXT_AU1			EQU	18
  59++6DF4 ~            EXT_AU2			EQU	20
  60++6DF4 ~            EXT_AU3			EQU	22
  61++6DF4 ~            EXT_AU4			EQU	24
  62++6DF4 ~            EXT_AU5			EQU	26
  63++6DF4 ~            EXT_AU6			EQU	28
  64++6DF4 ~            EXT_AU7			EQU	30
  65++6DF4 ~            EXT_SIZE		EQU 32
  66++6DF4 ~
  67++6DF4 ~            ;FCB structure
  68++6DF4 ~            FCB_DRIVE		EQU 0
  69++6DF4 ~            FCB_NAME		EQU EXT_NAME
  70++6DF4 ~            FCB_EX_IDX		EQU EXT_IDX
  71++6DF4 ~            FCB_S1			EQU EXT_S1
  72++6DF4 ~            FCB_S2			EQU EXT_S2
  73++6DF4 ~            FCB_RC			EQU	EXT_RC
  74++6DF4 ~            FCB_AU			EQU	EXT_AU0
  75++6DF4 ~            FCB_CR			EQU	32
  76++6DF4 ~            FCB_R0			EQU 33
  77++6DF4 ~            FCB_R1			EQU 34
  78++6DF4 ~            FCB_R2			EQU 35
  79++6DF4 ~            FCB_SIZE		EQU 36
  80++6DF4 ~
  81++6DF4 ~
  82++6DF4 ~
  83++6DF4 ~            ;System variables for disk
  84++6DF4 ~            DSTR1			EQU	$5CD6		;drive
  85++6DF4 ~            FSTR1			EQU	$5CDC		;file name
  86++6DF4 ~            NSTR1			EQU	$5CDA		;name length
  87++6DF4 ~            HD11			EQU	$5CED		;BDOS argument
  88++6DF4 ~            COPIES			EQU	$5CEF		;BDOS function
  89++6DF4 ~
  90++6DF4 ~            ERRSP			EQU $5C3D
  91++6DF4 ~            ERRNR			EQU $5C3A
  92++6DF4 ~            ERRMSG			EQU	$0260
  93++6DF4 ~
  94++6DF4 ~            PROG			EQU $5C53
  95++6DF4 ~            VARS			EQU	$5C4B
  96++6DF4 ~            STKEND			EQU	$5C65
  97++6DF4 ~
  98++6DF4 ~            PRN_BUF			EQU	23296
  99++6DF4 ~
 100++6DF4 ~            STR_MSG_BASIC	EQU	$1539
 101++6DF4 ~            STR_MSG_BASIC_LEN EQU 32
 102++6DF4 ~            STR_MSG_IF1_2000	EQU $27F0
 103++6DF4 ~            STR_MSG_IF1_91		EQU $23F0
 104++6DF4 ~            STR_MSG_IF1_LEN EQU 31
 105++6DF4 ~
 106++6DF4 ~            REPDEL			EQU	23561
 107++6DF4 ~            REPPER			EQU	23562
 108++6DF4 ~            PIP				EQU	23609
 109++6DF4 ~
 110++6DF4 ~
 111++6DF4 ~            ;RWTS routine commands
 112++6DF4 ~            RWTS_CMD_POS	EQU	0			;position head
 113++6DF4 ~            RWTS_CMD_READ	EQU	1			;read sector
 114++6DF4 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 115++6DF4 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 116++6DF4 ~
 117++6DF4 ~
 118++6DF4 ~            ;File name stuff
 119++6DF4 ~            NAMELEN			EQU	11			;name length
 120++6DF4 ~            RO_POS			EQU	8			;read-only attribute position in name
 121++6DF4 ~            SYS_POS			EQU	9			;system attribute position in name
 122++6DF4 ~
 123++6DF4 ~            ;File types (first byte in header)
 124++6DF4 ~            PROG_TYPE		EQU	0			;program
 125++6DF4 ~            NUMB_TYPE		EQU	1			;number array
 126++6DF4 ~            CHAR_TYPE		EQU	2			;char array
 127++6DF4 ~            BYTE_TYPE		EQU	3			;bytes
 128++6DF4 ~            TEXT_TYPE		EQU	4			;text, >= 4
 129++6DF4 ~
 130++6DF4 ~            ;File header offsets
 131++6DF4 ~            HDR_TYPE		EQU	0
 132++6DF4 ~            HDR_LEN			EQU 1
 133++6DF4 ~            HDR_ADDR		EQU 3
 134++6DF4 ~            HDR_PLEN		EQU	5
 135++6DF4 ~            HDR_LINE		EQU 7
 136++6DF4 ~            HDR_SZ			EQU	9
 137++6DF4 ~
 138++6DF4 ~            ;BASIC disk channel structure
 139++6DF4 ~            CH_RW_FLAG		EQU 11
 140++6DF4 ~            CH_FCB			EQU	12
 141++6DF4 ~            CH_DATA			EQU	50
 142++6DF4 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143++6DF4 ~
 144++6DF4 ~            CACHE_NAME		EQU	0					;11B
 145++6DF4 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146++6DF4 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147++6DF4 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148++6DF4 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149++6DF4 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150++6DF4 ~
 151++6DF4 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152++6DF4 ~
 153++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154++6DF4 ~            IF1Init:
 155++6DF4 ~            	rst		08
 156++6DF4 ~            	defb	49		;create system variables
 157++6DF4 ~            	ret
 158++6DF4 ~
 159++6DF4 ~            ;ReadWriteTrackSector
 160++6DF4 ~            ;A=command: 0, 1, 2, 4
 161++6DF4 ~            RWTS:
 162++6DF4 ~            	ld (RWTSCmd), a
 163++6DF4 ~            	ld hl, RWTSParams
 164++6DF4 ~            	ld (HD11), hl
 165++6DF4 ~            	rst 08
 166++6DF4 ~            	DEFB 58
 167++6DF4 ~            	ret
 168++6DF4 ~
 169++6DF4 ~
 170++6DF4 ~            ;D = sector, E = track
 171++6DF4 ~            ;HL = dma
 172++6DF4 ~            ReadOneDiskSector:
 173++6DF4 ~            	ld (RWTSDMA), hl
 174++6DF4 ~            	ld (RWTSTrack), de
 175++6DF4 ~            	;ld (RWTSDrive), a
 176++6DF4 ~            	ld a, RWTS_CMD_READ
 177++6DF4 ~            	jr	RWTS
 178++6DF4 ~
 179++6DF4 ~            ;D = sector, E = track
 180++6DF4 ~            ;HL = dma
 181++6DF4 ~            WriteOneDiskSector:
 182++6DF4 ~            	ld (RWTSDMA), hl
 183++6DF4 ~            	ld (RWTSTrack), de
 184++6DF4 ~            	;ld (RWTSDrive), a
 185++6DF4 ~            	ld a, RWTS_CMD_WRITE
 186++6DF4 ~            	jr	RWTS
 187++6DF4 ~
 188++6DF4 ~            FormatDisk:
 189++6DF4 ~            	ld		hl, DataBuf
 190++6DF4 ~            	ld		(hl), DEL_MARKER
 191++6DF4 ~            	ld 		(RWTSDMA), hl
 192++6DF4 ~            	ld 		a, RWTS_CMD_FMT
 193++6DF4 ~            	call	RWTS
 194++6DF4 ~            	ld		a, (RWTSRes)
 195++6DF4 ~            	ret
 196++6DF4 ~
 197++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198++6DF4 ~
 199++6DF4 ~            ;Allocation unit no. to track/sector
 200++6DF4 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201++6DF4 ~            ;IN:  HL=alloc. unit no.
 202++6DF4 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 203++6DF4 ~            AU2TS:
 204++6DF4 ~            	ld c, SPT/SPAL
 205++6DF4 ~            	call Div					;A = sector
 206++6DF4 ~            	push af
 207++6DF4 ~            		/*
 208++6DF4 ~            		ld c, HEAD_CNT
 209++6DF4 ~            		call Div				;L = track, A = head (0 or 1)
 210++6DF4 ~            		*/
 211++6DF4 ~            		xor a
 212++6DF4 ~            		rr h
 213++6DF4 ~            		rr l
 214++6DF4 ~            		rr a
 215++6DF4 ~
 216++6DF4 ~            		ld c, l
 217++6DF4 ~            		ld b, 0
 218++6DF4 ~            		or a
 219++6DF4 ~            		jr z, Track0
 220++6DF4 ~            		ld b, SPT
 221++6DF4 ~            Track0:
 222++6DF4 ~            	pop af
 223++6DF4 ~            	or a
 224++6DF4 ~            	jr z, FirstAU
 225++6DF4 ~            	ld a, SPAL
 226++6DF4 ~            FirstAU:
 227++6DF4 ~            	add a, b
 228++6DF4 ~            	ld  b, a
 229++6DF4 ~            	ret
 230++6DF4 ~
 231++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232++6DF4 ~
 233++6DF4 ~            ;Checks the allocation units number used in extension
 234++6DF4 ~            ;IN:	IX = extension addr
 235++6DF4 ~            ;OUT:	B = no. of allocation units used
 236++6DF4 ~            ;		C = no. of records used in ext.
 237++6DF4 ~            ;		HL = first alloc. unit no.
 238++6DF4 ~            ;		DE = last alloc. unit no.
 239++6DF4 ~            CheckExtAlloc:
 240++6DF4 ~            	push ix
 241++6DF4 ~            		ld bc, EXT_RC
 242++6DF4 ~            		add ix, bc
 243++6DF4 ~            		ld c, (ix)			;save rec. no.
 244++6DF4 ~            		inc ix
 245++6DF4 ~            		ld l, (ix)
 246++6DF4 ~            		ld h, (ix + 1)
 247++6DF4 ~            		ld b, EXT_AU_CNT
 248++6DF4 ~            CheckAU:
 249++6DF4 ~            		ld a, (ix)
 250++6DF4 ~            		or (ix + 1)
 251++6DF4 ~            		jr z, CheckAUEnd
 252++6DF4 ~            		ld e, (ix)
 253++6DF4 ~            		ld d, (ix + 1)
 254++6DF4 ~            		inc ix
 255++6DF4 ~            		inc ix
 256++6DF4 ~            		djnz CheckAU
 257++6DF4 ~            CheckAUEnd:
 258++6DF4 ~            		ld a, EXT_AU_CNT
 259++6DF4 ~            		sub b
 260++6DF4 ~            		ld b, a
 261++6DF4 ~            	pop ix
 262++6DF4 ~            	ret
 263++6DF4 ~
 264++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265++6DF4 ~
 266++6DF4 ~            ;Input: TrackBuffer
 267++6DF4 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268++6DF4 ~            ReadUsedBlocksList:
 269++6DF4 ~            	ld		ix, TrackBuf			;source buffer
 270++6DF4 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 271++6DF4 ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272++6DF4 ~            	ld		de, 2					;counter of used blocks, start with 2
 273++6DF4 ~            	ld		(hl), e
 274++6DF4 ~            	inc		hl
 275++6DF4 ~            	ld		(hl), d
 276++6DF4 ~            	inc		hl
 277++6DF4 ~
 278++6DF4 ~            	;Add blocks 0 and 1 for directory
 279++6DF4 ~            	ld		de, 0
 280++6DF4 ~            	ld		(hl), e
 281++6DF4 ~            	inc		hl
 282++6DF4 ~            	ld		(hl), d
 283++6DF4 ~            	inc		hl
 284++6DF4 ~
 285++6DF4 ~            	inc		de
 286++6DF4 ~            	ld		(hl), e
 287++6DF4 ~            	inc		hl
 288++6DF4 ~            	ld		(hl), d
 289++6DF4 ~            	inc		hl
 290++6DF4 ~
 291++6DF4 ~            ReadUsedBlocksLoop:
 292++6DF4 ~            	xor		a
 293++6DF4 ~            	cp		(ix)
 294++6DF4 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295++6DF4 ~
 296++6DF4 ~            	push	ix
 297++6DF4 ~            	push	bc
 298++6DF4 ~            		ld		b, EXT_AU_CNT
 299++6DF4 ~            		ld		de, EXT_AU0
 300++6DF4 ~            		add		ix, de
 301++6DF4 ~
 302++6DF4 ~            ReadUsedBlocksLoop2:
 303++6DF4 ~            		ld		e, (ix)
 304++6DF4 ~            		ld		d, (ix+1)
 305++6DF4 ~            		ld		a, e
 306++6DF4 ~            		or		d
 307++6DF4 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308++6DF4 ~
 309++6DF4 ~            		ld		(hl), e
 310++6DF4 ~            		inc		hl
 311++6DF4 ~            		ld		(hl), d
 312++6DF4 ~            		inc		hl
 313++6DF4 ~
 314++6DF4 ~            		inc		ix
 315++6DF4 ~            		inc		ix
 316++6DF4 ~
 317++6DF4 ~            		ld		de, (UsedBlockListCnt)
 318++6DF4 ~            		inc		de
 319++6DF4 ~            		ld		(UsedBlockListCnt), de
 320++6DF4 ~
 321++6DF4 ~            		djnz	ReadUsedBlocksLoop2
 322++6DF4 ~
 323++6DF4 ~
 324++6DF4 ~            ReadUsedBlocksSkip:
 325++6DF4 ~            	pop		bc
 326++6DF4 ~            	pop		ix
 327++6DF4 ~            ReadUsedBlocksSkip2:
 328++6DF4 ~            	ld		de, EXT_SZ
 329++6DF4 ~            	add		ix, de
 330++6DF4 ~
 331++6DF4 ~            	dec		bc
 332++6DF4 ~            	ld		a, b
 333++6DF4 ~            	or		c
 334++6DF4 ~            	jr		nz, ReadUsedBlocksLoop
 335++6DF4 ~
 336++6DF4 ~            	ret
 337++6DF4 ~
 338++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339++6DF4 ~            ;Reads 8 sectors for an AU
 340++6DF4 ~            ;HL = block number, DE = destination buffer
 341++6DF4 ~            ReadFSBlock:
 342++6DF4 ~            	push	de
 343++6DF4 ~            		call	AU2TS		;B=sector, C=track
 344++6DF4 ~            	pop		hl				;HL=dest
 345++6DF4 ~
 346++6DF4 ~            	ld		d, b
 347++6DF4 ~            	ld		e, c
 348++6DF4 ~            	ld		b, SPAL
 349++6DF4 ~
 350++6DF4 ~            ReadFSBlockLoop:
 351++6DF4 ~            	call	ReadDiskSectors
 352++6DF4 ~            	ret
 353++6DF4 ~
 354++6DF4 ~
 355++6DF4 ~            ;Write 8 sectors for an AU
 356++6DF4 ~            ;HL = block number, DE = source buffer
 357++6DF4 ~            WriteFSBlock:
 358++6DF4 ~            	push	de
 359++6DF4 ~            		call	AU2TS		;B=sector, C=track
 360++6DF4 ~            	pop		hl				;HL=dest
 361++6DF4 ~
 362++6DF4 ~            	ld		d, b
 363++6DF4 ~            	ld		e, c
 364++6DF4 ~            	ld		b, SPAL
 365++6DF4 ~
 366++6DF4 ~            WriteFSBlockLoop:
 367++6DF4 ~            	call	WriteDiskSectors
 368++6DF4 ~            	ret
 369++6DF4 ~
 370++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371++6DF4 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 372++6DF4 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373++6DF4 ~            CopyDisk:
 374++6DF4 ~            	;Get list of used blocks in current disk, max 632 bytes
 375++6DF4 ~            	call	ReadUsedBlocksList
 376++6DF4 ~            	ld		ix, UsedBlockListBlk
 377++6DF4 ~
 378++6DF4 ~            CopyDiskLoop:
 379++6DF4 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380++6DF4 ~            	ld		de, MsgBlocksLeft
 381++6DF4 ~            	call	Byte2Txt
 382++6DF4 ~            	ld		hl, MsgBlocksLeft
 383++6DF4 ~            	ld		de, LST_LINE_MSG + 1 << 8
 384++6DF4 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 385++6DF4 ~            	call	PrintStrClr
 386++6DF4 ~            	ld		hl, MsgClear
 387++6DF4 ~            	ld		de, LST_LINE_MSG + 2 << 8
 388++6DF4 ~            	ld		a, SCR_DEF_CLR
 389++6DF4 ~            	call	PrintStrClr
 390++6DF4 ~
 391++6DF4 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 392++6DF4 ~            	ld		hl, MAX_AU_RAM
 393++6DF4 ~            	ld		bc, (UsedBlockListCnt)
 394++6DF4 ~            	or		a
 395++6DF4 ~            	sbc		hl, bc
 396++6DF4 ~            	jr		nc, CopyDiskLoopRead
 397++6DF4 ~            	ld		bc, MAX_AU_RAM
 398++6DF4 ~
 399++6DF4 ~            CopyDiskLoopRead:
 400++6DF4 ~            	ld		b, c
 401++6DF4 ~            	ld		de, CopyDiskBuf
 402++6DF4 ~            	;save initial counter and initial block number array position
 403++6DF4 ~            	push	bc
 404++6DF4 ~            	push	ix
 405++6DF4 ~
 406++6DF4 ~            CopyDiskLoopReadLoop:
 407++6DF4 ~            		ld		l, (ix)
 408++6DF4 ~            		ld		h, (ix+1)
 409++6DF4 ~            		inc		ix
 410++6DF4 ~            		inc		ix
 411++6DF4 ~
 412++6DF4 ~            		push	de
 413++6DF4 ~            		push	bc
 414++6DF4 ~            			call	ReadFSBlock			;Stop on error or continue?
 415++6DF4 ~            		pop		bc
 416++6DF4 ~            		pop		de
 417++6DF4 ~
 418++6DF4 ~            		;+2048
 419++6DF4 ~            		ld		a, d
 420++6DF4 ~            		add		8
 421++6DF4 ~            		ld		d, a
 422++6DF4 ~
 423++6DF4 ~            		djnz	CopyDiskLoopReadLoop
 424++6DF4 ~
 425++6DF4 ~            		;Check if selection is 1=single drive or 2=dual drive
 426++6DF4 ~            		ld		a, (CopySelOption)
 427++6DF4 ~            		cp		'1'
 428++6DF4 ~            		jr		nz, CopyDiskDualDrive1
 429++6DF4 ~
 430++6DF4 ~            		;Prompt for disk change
 431++6DF4 ~            		call	PromptDiskChangeDst
 432++6DF4 ~            		ld		a, (RWTSDrive)
 433++6DF4 ~            		call	BDOSInit
 434++6DF4 ~            		jr		CopyDiskReadEnd
 435++6DF4 ~
 436++6DF4 ~            CopyDiskDualDrive1:
 437++6DF4 ~            		;alternate drive
 438++6DF4 ~            		ld		a, (RWTSDrive)
 439++6DF4 ~            		inc 	a
 440++6DF4 ~            		xor		%11
 441++6DF4 ~            		dec		a
 442++6DF4 ~            		ld		(RWTSDrive), a
 443++6DF4 ~
 444++6DF4 ~            CopyDiskReadEnd:
 445++6DF4 ~            	;restore initial counter and initial block number array position
 446++6DF4 ~            	pop		ix
 447++6DF4 ~            	pop		bc
 448++6DF4 ~            	ld		de, CopyDiskBuf
 449++6DF4 ~            	push	bc
 450++6DF4 ~
 451++6DF4 ~            CopyDiskLoopWriteLoop:
 452++6DF4 ~            		ld		l, (ix)
 453++6DF4 ~            		ld		h, (ix+1)
 454++6DF4 ~            		inc		ix
 455++6DF4 ~            		inc		ix
 456++6DF4 ~
 457++6DF4 ~            		push	de
 458++6DF4 ~            		push	bc
 459++6DF4 ~            			call	WriteFSBlock		;Stop on error or continue?
 460++6DF4 ~            		pop		bc
 461++6DF4 ~            		pop		de
 462++6DF4 ~
 463++6DF4 ~            		;+2048
 464++6DF4 ~            		ld		a, d
 465++6DF4 ~            		add		8
 466++6DF4 ~            		ld		d, a
 467++6DF4 ~
 468++6DF4 ~            		djnz	CopyDiskLoopWriteLoop
 469++6DF4 ~
 470++6DF4 ~            CopyDiskWriteEnd:
 471++6DF4 ~            	pop		bc
 472++6DF4 ~            	ld		c, b
 473++6DF4 ~            	ld		b, 0
 474++6DF4 ~
 475++6DF4 ~            	;Decrease number of blocks read by now.
 476++6DF4 ~            	ld		hl, (UsedBlockListCnt)
 477++6DF4 ~            	or		a
 478++6DF4 ~            	sbc		hl, bc
 479++6DF4 ~            	ld		(UsedBlockListCnt), hl
 480++6DF4 ~
 481++6DF4 ~            	ld		a, l
 482++6DF4 ~            	or		h
 483++6DF4 ~            	ret		z						;Exit if finished all blocks.
 484++6DF4 ~
 485++6DF4 ~            	;Check if selection is 1=single drive or 2=dual drive
 486++6DF4 ~            	ld		a, (CopySelOption)
 487++6DF4 ~            	cp		'1'
 488++6DF4 ~            	jr		nz, CopyDiskDualDrive2
 489++6DF4 ~
 490++6DF4 ~            	;Prompt for disk change
 491++6DF4 ~            	call	PromptDiskChangeSrc
 492++6DF4 ~            	ld		a, (RWTSDrive)
 493++6DF4 ~            	call	BDOSInit
 494++6DF4 ~            	jp		CopyDiskLoop
 495++6DF4 ~
 496++6DF4 ~            CopyDiskDualDrive2:
 497++6DF4 ~            	;alternate drive again
 498++6DF4 ~            	ld		a, (RWTSDrive)
 499++6DF4 ~            	inc		a
 500++6DF4 ~            	xor		%11
 501++6DF4 ~            	dec		a
 502++6DF4 ~            	ld		(RWTSDrive), a
 503++6DF4 ~            	jp		CopyDiskLoop
 504++6DF4 ~
 505++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 506++6DF4 ~            ;Copies the current disk blocks to COM port.
 507++6DF4 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 508++6DF4 ~            CopyDiskToCOM:
 509++6DF4 ~            	;Get list of used blocks in current disk, max 632 bytes
 510++6DF4 ~            	call	ReadUsedBlocksList
 511++6DF4 ~
 512++6DF4 ~            	;Send block count and block indexes
 513++6DF4 ~            	ld		hl, (UsedBlockListCnt)
 514++6DF4 ~            	add		hl, hl
 515++6DF4 ~            	inc		hl
 516++6DF4 ~            	inc		hl
 517++6DF4 ~            	ld		b, h
 518++6DF4 ~            	ld		c, l
 519++6DF4 ~            	ld		hl, UsedBlockListCnt
 520++6DF4 ~            	call	SERTB
 521++6DF4 ~
 522++6DF4 ~            	ld		ix, UsedBlockListBlk
 523++6DF4 ~
 524++6DF4 ~            CopyDiskToCOMLoop:
 525++6DF4 ~            	;Print block count left
 526++6DF4 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 527++6DF4 ~            	ld		de, MsgBlocksLeft
 528++6DF4 ~            	call	Byte2Txt
 529++6DF4 ~            	ld		hl, MsgBlocksLeft
 530++6DF4 ~            	ld		de, LST_LINE_MSG + 1 << 8
 531++6DF4 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 532++6DF4 ~            	call	PrintStrClr
 533++6DF4 ~
 534++6DF4 ~            	;Read block into buffer
 535++6DF4 ~            	ld		l, (ix)
 536++6DF4 ~            	ld		h, (ix+1)
 537++6DF4 ~            	ld		de, CopyDiskBuf
 538++6DF4 ~            	push	ix
 539++6DF4 ~            		call	ReadFSBlock
 540++6DF4 ~            	pop		ix
 541++6DF4 ~            	inc		ix
 542++6DF4 ~            	inc		ix
 543++6DF4 ~
 544++6DF4 ~            	;Send block buffer
 545++6DF4 ~            	ld		hl, CopyDiskBuf
 546++6DF4 ~            	ld		bc, AU_SZ
 547++6DF4 ~            	call	SERTB
 548++6DF4 ~
 549++6DF4 ~            	ld		bc, (UsedBlockListCnt)
 550++6DF4 ~            	dec		bc
 551++6DF4 ~            	ld		(UsedBlockListCnt), bc
 552++6DF4 ~
 553++6DF4 ~            	push	ix
 554++6DF4 ~            		call	KbdHit
 555++6DF4 ~            	pop		ix
 556++6DF4 ~            	ret		c
 557++6DF4 ~
 558++6DF4 ~            	ld		a, b
 559++6DF4 ~            	or		c
 560++6DF4 ~            	jr		nz, CopyDiskToCOMLoop
 561++6DF4 ~
 562++6DF4 ~            	ret
 563++6DF4 ~
 564++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 565++6DF4 ~            CopyDiskFromCOM:
 566++6DF4 ~            	;Receive block count.
 567++6DF4 ~            	ld		hl, UsedBlockListCnt
 568++6DF4 ~            	ld		bc, 2
 569++6DF4 ~            	ld		e, 0
 570++6DF4 ~            	call	SERRB
 571++6DF4 ~
 572++6DF4 ~            	;Receive block indexes.
 573++6DF4 ~            	ld		hl, (UsedBlockListCnt)
 574++6DF4 ~            	add		hl, hl
 575++6DF4 ~            	ld		b, h
 576++6DF4 ~            	ld		c, l
 577++6DF4 ~            	ld		hl, UsedBlockListBlk
 578++6DF4 ~            	ld		e, 0
 579++6DF4 ~            	call	SERRB
 580++6DF4 ~
 581++6DF4 ~            	;Read each block by index and write to disk
 582++6DF4 ~            	ld		ix, UsedBlockListBlk
 583++6DF4 ~
 584++6DF4 ~            CopyDiskFromCOMLoop:
 585++6DF4 ~            	;Print block count left
 586++6DF4 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 587++6DF4 ~            	ld		de, MsgBlocksLeft
 588++6DF4 ~            	call	Byte2Txt
 589++6DF4 ~            	ld		hl, MsgBlocksLeft
 590++6DF4 ~            	ld		de, LST_LINE_MSG + 1 << 8
 591++6DF4 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 592++6DF4 ~            	call	PrintStrClr
 593++6DF4 ~
 594++6DF4 ~            	;Read block buffer
 595++6DF4 ~            	ld		hl, CopyDiskBuf
 596++6DF4 ~            	ld		bc, AU_SZ
 597++6DF4 ~            	ld		e, 0
 598++6DF4 ~            	call	SERRB
 599++6DF4 ~
 600++6DF4 ~            	;Write block to disk
 601++6DF4 ~            	ld		l, (ix)
 602++6DF4 ~            	ld		h, (ix+1)
 603++6DF4 ~            	ld		de, CopyDiskBuf
 604++6DF4 ~            	push	ix
 605++6DF4 ~            		call	WriteFSBlock			;Stop on error or continue?
 606++6DF4 ~            	pop		ix
 607++6DF4 ~            	inc		ix
 608++6DF4 ~            	inc		ix
 609++6DF4 ~
 610++6DF4 ~            	ld		bc, (UsedBlockListCnt)
 611++6DF4 ~            	dec		bc
 612++6DF4 ~            	ld		(UsedBlockListCnt), bc
 613++6DF4 ~
 614++6DF4 ~            	push	ix
 615++6DF4 ~            		call	KbdHit
 616++6DF4 ~            	pop		ix
 617++6DF4 ~            	ret		c
 618++6DF4 ~
 619++6DF4 ~            	ld		a, b
 620++6DF4 ~            	or		c
 621++6DF4 ~            	jr		nz, CopyDiskFromCOMLoop
 622++6DF4 ~            	ret
 623++6DF4 ~
 624++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 625++6DF4 ~
 626++6DF4 ~            ;Compare string at HL with the one at DE, max length B
 627++6DF4 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 628++6DF4 ~            ;OUT: z flag, set = match, reset = mismatch
 629++6DF4 ~            StrCmp:
 630++6DF4 ~            	push hl
 631++6DF4 ~            	push de
 632++6DF4 ~            Compare:
 633++6DF4 ~            		ld a, (de)
 634++6DF4 ~            		cp (hl)
 635++6DF4 ~            		jr nz, MisMatch
 636++6DF4 ~            		inc hl
 637++6DF4 ~            		inc de
 638++6DF4 ~            		djnz Compare
 639++6DF4 ~            MisMatch:
 640++6DF4 ~            	pop de
 641++6DF4 ~            	pop hl
 642++6DF4 ~            	ret
 643++6DF4 ~
 644++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 645++6DF4 ~
 646++6DF4 ~            ;Read a file into a buffer, sector by sector.
 647++6DF4 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 648++6DF4 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 649++6DF4 ~            ;In: HL = Name address, DE = buffer
 650++6DF4 ~            IF1FileLoad:
 651++6DF4 ~            	push	de
 652++6DF4 ~            		ld (FSTR1), hl
 653++6DF4 ~            		ld h, 0
 654++6DF4 ~            		ld a, (RWTSDrive)
 655++6DF4 ~            		inc  a			;CP/M drive number to BASIC drive number
 656++6DF4 ~            		ld	l, a
 657++6DF4 ~            		ld (DSTR1), hl
 658++6DF4 ~            		ld l,NAMELEN
 659++6DF4 ~            		ld (NSTR1), hl
 660++6DF4 ~            		rst 08
 661++6DF4 ~            		DEFB 51			;open disk channel
 662++6DF4 ~
 663++6DF4 ~            		rst		8
 664++6DF4 ~            		defb	53		;read sector
 665++6DF4 ~            	pop		de
 666++6DF4 ~            	jr		nc, FileFree
 667++6DF4 ~
 668++6DF4 ~            	ld		a, (ix + CH_DATA)
 669++6DF4 ~            	cp		TEXT_TYPE
 670++6DF4 ~            	jr		nc, FileLoadNoHeader
 671++6DF4 ~
 672++6DF4 ~            FileLoadHeader:
 673++6DF4 ~            	push	ix
 674++6DF4 ~            	pop		hl
 675++6DF4 ~            	ld		bc, CH_DATA + HDR_SZ
 676++6DF4 ~            	add		hl, bc
 677++6DF4 ~            	ld		bc, SECT_SZ - HDR_SZ
 678++6DF4 ~            	ldir
 679++6DF4 ~
 680++6DF4 ~            FileReadLoop:
 681++6DF4 ~            	push	de
 682++6DF4 ~            		rst		8
 683++6DF4 ~            		defb	53		;read sector
 684++6DF4 ~            	pop		de
 685++6DF4 ~            	jr		nc, FileFree
 686++6DF4 ~
 687++6DF4 ~            FileLoadNoHeader:
 688++6DF4 ~            	push	ix
 689++6DF4 ~            	pop		hl
 690++6DF4 ~            	ld		bc, CH_DATA
 691++6DF4 ~            	add		hl, bc
 692++6DF4 ~            	ld		bc, SECT_SZ
 693++6DF4 ~            	ldir
 694++6DF4 ~            	jr		FileReadLoop
 695++6DF4 ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 696++6DF4 ~            IF1FileLoadEnd:
 697++6DF4 ~
 698++6DF4 ~            FileFree:
 699++6DF4 ~            	push	de
 700++6DF4 ~            	rst		8
 701++6DF4 ~            	defb	56			;close channel (52) or detroy channel (56)
 702++6DF4 ~            	pop		de
 703++6DF4 ~            	ret
 704++6DF4 ~
 705++6DF4 ~
 706++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707++6DF4 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 708++6DF4 ~            ;Out: A = error code, 0=OK
 709++6DF4 ~            ReadDiskSectors:
 710++6DF4 ~            	push bc
 711++6DF4 ~            		push hl
 712++6DF4 ~            			push de
 713++6DF4 ~            				call ReadOneDiskSector
 714++6DF4 ~            			pop de
 715++6DF4 ~            		pop hl
 716++6DF4 ~
 717++6DF4 ~            		inc d
 718++6DF4 ~            		inc h
 719++6DF4 ~            	pop bc
 720++6DF4 ~
 721++6DF4 ~            	ld	a, (RWTSRes)
 722++6DF4 ~            	or	a
 723++6DF4 ~            	ret nz
 724++6DF4 ~
 725++6DF4 ~            	djnz ReadDiskSectors
 726++6DF4 ~            	ret
 727++6DF4 ~
 728++6DF4 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 729++6DF4 ~            ;Out: A = error code, 0=OK
 730++6DF4 ~            WriteDiskSectors:
 731++6DF4 ~            	push bc
 732++6DF4 ~            		push hl
 733++6DF4 ~            			push de
 734++6DF4 ~            				call WriteOneDiskSector
 735++6DF4 ~            			pop de
 736++6DF4 ~            		pop hl
 737++6DF4 ~
 738++6DF4 ~            		inc d
 739++6DF4 ~            		inc h
 740++6DF4 ~            	pop bc
 741++6DF4 ~
 742++6DF4 ~            	ld	a, (RWTSRes)
 743++6DF4 ~            	or	a
 744++6DF4 ~            	ret nz
 745++6DF4 ~
 746++6DF4 ~            	djnz WriteDiskSectors
 747++6DF4 ~            	ret
 748++6DF4 ~
 749++6DF4 ~
 750++6DF4 ~            ;Reads disk catalog
 751++6DF4 ~            ReadCatalogTrack:
 752++6DF4 ~            	ld hl, TrackBuf
 753++6DF4 ~            	ld de, 0
 754++6DF4 ~            	ld b, SPT
 755++6DF4 ~
 756++6DF4 ~            	call ReadDiskSectors
 757++6DF4 ~            	or   a
 758++6DF4 ~            	ret  nz
 759++6DF4 ~
 760++6DF4 ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 761++6DF4 ~            	push  af
 762++6DF4 ~            		ld  a, (RWTSDrive)
 763++6DF4 ~            		call BDOSSelectDisk
 764++6DF4 ~            		call BDOSInit
 765++6DF4 ~            	pop   af
 766++6DF4 ~            	ret
 767++6DF4 ~
 768++6DF4 ~
 769++6DF4 ~
 770++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 771++6DF4 ~
 772++6DF4 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 773++6DF4 ~            FindCache:
 774++6DF4 ~            	ld		b, NAMELEN
 775++6DF4 ~            	call	StrCmp			;find the file to wich this extension belongs
 776++6DF4 ~            	ret		z
 777++6DF4 ~
 778++6DF4 ~            	dec		c
 779++6DF4 ~            	jr		nz, CacheNotFinished
 780++6DF4 ~            	or		c
 781++6DF4 ~            	ret
 782++6DF4 ~
 783++6DF4 ~            CacheNotFinished:
 784++6DF4 ~            	ld		bc, CACHE_SZ
 785++6DF4 ~            	add		hl, bc			;to the next cache line
 786++6DF4 ~            	jr		FindCache
 787++6DF4 ~
 788++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 789++6DF4 ~
 790++6DF4 ~            	;ld		ix, (SelFileCache)
 791++6DF4 ~            ReadFileHeader:
 792++6DF4 ~            	ld		a, (ix + CACHE_FLAG)
 793++6DF4 ~            	or		a
 794++6DF4 ~            	ret		nz				;return if already read
 795++6DF4 ~
 796++6DF4 ~            	ld		l, (ix + CACHE_FIRST_AU)
 797++6DF4 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 798++6DF4 ~            	ld		a, h
 799++6DF4 ~            	or		l
 800++6DF4 ~            	jr		z, ReadHeaderEnd
 801++6DF4 ~
 802++6DF4 ~            	call	AU2TS
 803++6DF4 ~            	ld		d, b
 804++6DF4 ~            	ld		e, c
 805++6DF4 ~            	ld		hl, DataBuf
 806++6DF4 ~            	push	ix
 807++6DF4 ~            	push	ix
 808++6DF4 ~            		call	ReadOneDiskSector
 809++6DF4 ~            	pop		hl
 810++6DF4 ~            	pop		ix
 811++6DF4 ~
 812++6DF4 ~            	push	hl
 813++6DF4 ~            		ld		hl, DataBuf
 814++6DF4 ~            		call	IsFileHeaderValid
 815++6DF4 ~            	pop		hl
 816++6DF4 ~            	or		a
 817++6DF4 ~            	jr		z, ReadFileHeaderIsTextFile
 818++6DF4 ~
 819++6DF4 ~            	ld		bc, CACHE_HDR
 820++6DF4 ~            	add		hl, bc
 821++6DF4 ~            	ex		hl, de
 822++6DF4 ~            	ld		hl, DataBuf
 823++6DF4 ~            	ld		bc, HDR_SZ
 824++6DF4 ~            	ldir
 825++6DF4 ~
 826++6DF4 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 827++6DF4 ~            	ld		a, BYTE_TYPE
 828++6DF4 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 829++6DF4 ~            	jr		nc, ReadHeaderEnd
 830++6DF4 ~
 831++6DF4 ~            ReadFileHeaderIsTextFile:
 832++6DF4 ~            	push	ix
 833++6DF4 ~            	push	ix
 834++6DF4 ~            	pop		hl
 835++6DF4 ~            		call	GetFileSize
 836++6DF4 ~            	pop		ix
 837++6DF4 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 838++6DF4 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 839++6DF4 ~            	ld		a, TEXT_TYPE
 840++6DF4 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 841++6DF4 ~
 842++6DF4 ~            ReadHeaderEnd:
 843++6DF4 ~            	inc		(ix + CACHE_FLAG)
 844++6DF4 ~            	ret
 845++6DF4 ~
 846++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 847++6DF4 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 848++6DF4 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 849++6DF4 ~            ;In: HL = header
 850++6DF4 ~            ;Out: A > 0 if valid
 851++6DF4 ~            IsFileHeaderValid:
 852++6DF4 ~            	IFUSED
 853++6DF4 ~            	xor		a
 854++6DF4 ~            	ld		b, HDR_SZ
 855++6DF4 ~            IsFileHeaderValidLoop:
 856++6DF4 ~            	or		(hl)
 857++6DF4 ~            	inc		hl
 858++6DF4 ~            	djnz	IsFileHeaderValidLoop
 859++6DF4 ~
 860++6DF4 ~            	ret
 861++6DF4 ~            	ENDIF
 862++6DF4 ~
 863++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864++6DF4 ~
 865++6DF4 ~            ;IN: HL = address from IF1 to call
 866++6DF4 ~            IF1Call:
 867++6DF4 ~            	LD   (HD11), HL
 868++6DF4 ~            	RST  8
 869++6DF4 ~            	DEFB 50
 870++6DF4 ~            	RET
 871++6DF4 ~
 872++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 873++6DF4 ~
 874++6DF4 ~            ;Load a program from disk
 875++6DF4 ~            ;IN: HL = file name addr
 876++6DF4 ~            LoadProgram:
 877++6DF4 ~            	LD   (FSTR1), HL
 878++6DF4 ~            	LD   H, 0
 879++6DF4 ~            	LD   L, NAMELEN
 880++6DF4 ~            	LD   (NSTR1), HL
 881++6DF4 ~            	LD	 A, (RWTSDrive)
 882++6DF4 ~            	INC  A					;Adapt for BASIC drive number
 883++6DF4 ~            	LD   L, A
 884++6DF4 ~            	LD   (DSTR1), HL
 885++6DF4 ~            	LD   HL, LOAD_ADDR
 886++6DF4 ~            	CALL IF1Call
 887++6DF4 ~            	RET
 888++6DF4 ~
 889++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890++6DF4 ~
 891++6DF4 ~            SetFastKeys:
 892++6DF4 ~            	ld		hl, REPDEL
 893++6DF4 ~            	ld		de, (1 << 8) | 15
 894++6DF4 ~            	ld		(hl), de
 895++6DF4 ~
 896++6DF4 ~            	ret
 897++6DF4 ~
 898++6DF4 ~
 899++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 900++6DF4 ~            ;Reads the error message string from IF1 ROM.
 901++6DF4 ~            GetErrMsg:
 902++6DF4 ~            	inc		a
 903++6DF4 ~            	ex		af, af'
 904++6DF4 ~
 905++6DF4 ~            	ld		hl, IF1Paged			;page-in IF1
 906++6DF4 ~            	jp		IF1Call
 907++6DF4 ~
 908++6DF4 ~            IF1Paged:
 909++6DF4 ~            	ld		hl, ERRMSG
 910++6DF4 ~            	ex		af, af'
 911++6DF4 ~            	or		a
 912++6DF4 ~            	jr		z, SaveMsg
 913++6DF4 ~
 914++6DF4 ~            	ld		b, 0
 915++6DF4 ~            SearchMsgEnd:
 916++6DF4 ~            	bit		7, (hl)
 917++6DF4 ~            	inc		hl
 918++6DF4 ~            	jr		z, SearchMsgEnd
 919++6DF4 ~
 920++6DF4 ~            	inc		b
 921++6DF4 ~            	cp		b
 922++6DF4 ~            	jr		nz, SearchMsgEnd
 923++6DF4 ~
 924++6DF4 ~            SaveMsg:
 925++6DF4 ~            	ld		de, DataBuf
 926++6DF4 ~            CopyMsg:
 927++6DF4 ~            	ld		a, (hl)
 928++6DF4 ~            	bit		7, a
 929++6DF4 ~            	ld		(de), a
 930++6DF4 ~            	inc		hl
 931++6DF4 ~            	inc		de
 932++6DF4 ~            	jr		z, CopyMsg
 933++6DF4 ~
 934++6DF4 ~            	ret
 935++6DF4 ~
 936++6DF4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 937++6DF4 ~
 938++6DF4 ~            ;RWTS routine I/O block
 939++6DF4 ~            RWTSParams:
 940++6DF4 ~            RWTSBlockType	DEFB	1							;?
 941++6DF4 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 942++6DF4 ~            RWTSVolNo		DEFB	0							;?
 943++6DF4 ~            RWTSTrack		DEFB	0
 944++6DF4 ~            RWTSSector		DEFB	0
 945++6DF4 ~            RWTSDMA			DEFW	0
 946++6DF4 ~            RWTSExtBuf		DEFW	$2932
 947++6DF4 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 948++6DF4 ~            	IFDEF _REAL_HW_
 949++6DF4 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 950++6DF4 ~            	ELSE
 951++6DF4 ~            RWTSPrmTbl		DEFW	$1f2a
 952++6DF4 ~            	ENDIF
 953++6DF4 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 954++6DF4 ~            ;Results
 955++6DF4 ~            RWTSRes			DEFB	0
 956++6DF4 ~            RWTSResVolNo	DEFB	0
 957++6DF4 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 958++6DF4 ~
 959++6DF4 ~            ;Param. table, usualy found in ROM.
 960++6DF4 ~            	IFDEF _REAL_HW_
 961++6DF4 ~            BasPrmTbl:
 962++6DF4 ~            PrmDevType		DEFB	$01		;$01
 963++6DF4 ~            PrmStepRate		DEFB	$01		;$0D	(milisec)
 964++6DF4 ~            PrmHeadLoad		DEFB	$01		;$23	(milisec)
 965++6DF4 ~            PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 966++6DF4 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 967++6DF4 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 968++6DF4 ~            	ENDIF
 969++6DF4 ~
 970++6DF4              	endif
# file closed: if1.asm
  15+ 6DF4
  16+ 6DF4              BDOSInit:
  17+ 6DF4 AF           	xor		a
  18+ 6DF5 18 45        	jr		BDOS
  19+ 6DF7
  20+ 6DF7
  21+ 6DF7              ;IN: A = Drive to select
  22+ 6DF7              BDOSSelectDisk:
  23+ 6DF7              	IFUSED
  24+ 6DF7 DD 6F        	ld		ixl, a
  25+ 6DF9 DD 26 00     	ld		ixh, 0
  26+ 6DFC 3E 01        	ld		a, 1
  27+ 6DFE 18 3C        	jr		BDOS
  28+ 6E00              	ENDIF
  29+ 6E00
  30+ 6E00
  31+ 6E00              BDOSMakeDiskRO:
  32+ 6E00              	IFUSED
  33+ 6E00 ~            	ld		a, 15
  34+ 6E00 ~            	jr		BDOS
  35+ 6E00              	ENDIF
  36+ 6E00
  37+ 6E00              ;Get Read Only flag
  38+ 6E00              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 6E00              BDOSGetDiskRO:
  40+ 6E00              	IFUSED
  41+ 6E00 ~            	ld	a, 16
  42+ 6E00 ~            	jr	BDOS
  43+ 6E00              	ENDIF
  44+ 6E00
  45+ 6E00              BDOSGetCurrentDisk:
  46+ 6E00              	IFUSED
  47+ 6E00 ~            	ld		a, 12
  48+ 6E00 ~            	jr		BDOS
  49+ 6E00              	ENDIF
  50+ 6E00
  51+ 6E00
  52+ 6E00              ;Create a disk channel for BDOS access (does not open the file)
  53+ 6E00              ;IN: HL=name addr, A=drive
  54+ 6E00              ;OUT: IX=FCB
  55+ 6E00              CreateChannel:
  56+ 6E00 22 DC 5C     	ld (FSTR1), hl
  57+ 6E03 26 00        	ld h,0
  58+ 6E05 6F           	ld l,a
  59+ 6E06 22 D6 5C     	ld (DSTR1), hl
  60+ 6E09 2E 0B        	ld l,NAMELEN
  61+ 6E0B 22 DA 5C     	ld (NSTR1), hl
  62+ 6E0E CF           	rst 08
  63+ 6E0F 37           	DEFB 55
  64+ 6E10 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 6E13 DD 09        	add ix, bc
  66+ 6E15 C9           	ret
  67+ 6E16
  68+ 6E16
  69+ 6E16              ;Destroy a BDOS channel
  70+ 6E16              ;IN: IX=FCB
  71+ 6E16              DestroyChannel:
  72+ 6E16 C5           	push bc
  73+ 6E17 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 6E1A DD 09        	add ix, bc
  75+ 6E1C CF           	rst 08
  76+ 6E1D 38           	DEFB 56
  77+ 6E1E C1           	pop bc
  78+ 6E1F C9           	ret
  79+ 6E20
  80+ 6E20
  81+ 6E20              ;Input: IX=FCB
  82+ 6E20              BDOSCreateFile:
  83+ 6E20 3E 09        	ld	a, 9
  84+ 6E22 18 18        	jr	BDOS
  85+ 6E24
  86+ 6E24              ;Input: IX=FCB
  87+ 6E24              BDOSOpenFile:
  88+ 6E24 3E 02        	ld	a, 2
  89+ 6E26 18 14        	jr	BDOS
  90+ 6E28
  91+ 6E28              ;IN: IX=FCB
  92+ 6E28              BDOSCloseFile:
  93+ 6E28 3E 03        	ld	a, 3
  94+ 6E2A 18 10        	jr	BDOS
  95+ 6E2C
  96+ 6E2C
  97+ 6E2C              ;0 OK,
  98+ 6E2C              ;1 end of file,
  99+ 6E2C              ;9 invalid FCB,
 100+ 6E2C              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 101+ 6E2C              ;11 (MP/M) unlocked file verification error,
 102+ 6E2C              ;0FFh hardware error.
 103+ 6E2C
 104+ 6E2C              ;IN: IX=FCB
 105+ 6E2C              BDOSReadFileBlockSeq:
 106+ 6E2C 3E 07        	ld	a, 7
 107+ 6E2E 18 0C        	jr	BDOS
 108+ 6E30
 109+ 6E30
 110+ 6E30              ;0 OK,
 111+ 6E30              ;1 directory full,
 112+ 6E30              ;2 disc full,
 113+ 6E30              ;8 (MP/M) record locked by another process,
 114+ 6E30              ;9 invalid FCB,
 115+ 6E30              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 116+ 6E30              ;11 (MP/M) unlocked file verification error,
 117+ 6E30              ;0FFh hardware error.
 118+ 6E30
 119+ 6E30              ;IN: IX=FCB
 120+ 6E30              BDOSWriteFileBlockSeq:
 121+ 6E30 3E 08        	ld	a, 8
 122+ 6E32 18 08        	jr	BDOS
 123+ 6E34
 124+ 6E34
 125+ 6E34              ;0 OK
 126+ 6E34              ;1 Reading unwritten data
 127+ 6E34              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 128+ 6E34              ;6 Record number out of range
 129+ 6E34              ;9 Invalid FCB
 130+ 6E34              BDOSReadFileBlockRandom:
 131+ 6E34 3E 12        	ld	a, 18
 132+ 6E36 18 04        	jr	BDOS
 133+ 6E38
 134+ 6E38              ;0 OK
 135+ 6E38              ;2 Disc full
 136+ 6E38              ;3 Cannot close extent
 137+ 6E38              ;5 Directory full
 138+ 6E38              ;6 Record number out of range
 139+ 6E38              ;8 Record is locked by another process (MP/M)
 140+ 6E38              ;9 Invalid FCB
 141+ 6E38              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 142+ 6E38              BDOSWriteFileBlockRandom:
 143+ 6E38 3E 13        	ld	a, 19
 144+ 6E3A 18 00        	jr	BDOS
 145+ 6E3C
 146+ 6E3C
 147+ 6E3C              ;Generic BDOS call
 148+ 6E3C              ;IX=arg, A=function
 149+ 6E3C              BDOS:
 150+ 6E3C DD 22 ED 5C  	ld (HD11), ix
 151+ 6E40 32 EF 5C     	ld (COPIES), a
 152+ 6E43 CF           	rst 08
 153+ 6E44 39           	DEFB 57
 154+ 6E45 C9           	ret
 155+ 6E46
 156+ 6E46              ;Set DMA address for BDOS
 157+ 6E46              ;IX=DMA
 158+ 6E46              BDOSSetDMA:
 159+ 6E46 3E 0D        	ld a, 13
 160+ 6E48 18 F2        	jr BDOS
 161+ 6E4A
 162+ 6E4A              ;In: IX=FCB
 163+ 6E4A              BDOSSetRandFilePtr:
 164+ 6E4A 3E 15        	ld	a, 21
 165+ 6E4C 18 EE        	jr	BDOS
 166+ 6E4E
 167+ 6E4E              ;In: HL=filename
 168+ 6E4E              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 169+ 6E4E              GetFileSize:
 170+ 6E4E              	IFUSED
 171+ 6E4E
 172+ 6E4E 3A CC 6D     	ld 		a, (RWTSDrive)
 173+ 6E51 3C           	inc		a					;Convert to BASIC drive number: 1,2
 174+ 6E52 CD 00 6E     	call	CreateChannel
 175+ 6E55
 176+ 6E55 3E 14        	ld		a, 20
 177+ 6E57 CD 3C 6E     	call	BDOS
 178+ 6E5A              	;inc		a
 179+ 6E5A              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 180+ 6E5A
 181+ 6E5A DD 6E 21     	ld		l, (ix + FCB_R0)
 182+ 6E5D DD 66 22     	ld		h, (ix + FCB_R1)
 183+ 6E60
 184+ 6E60              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 185+ 6E60 3E 01        	ld		a, 1
 186+ 6E62 BC           	cp		h
 187+ 6E63 30 05        	jr		nc, GetFileSizeOK
 188+ 6E65 21 00 00     	ld		hl, 0
 189+ 6E68 18 08        	jr		GetFileSizeEnd
 190+ 6E6A
 191+ 6E6A              GetFileSizeOK:
 192+ 6E6A              	;*128 == 2^7
 193+ 6E6A 06 07        	ld		b, 7
 194+ 6E6C              GetFileSizeMul:
 195+ 6E6C CB 15        	rl		l
 196+ 6E6E CB 14        	rl		h
 197+ 6E70 10 FA        	djnz	GetFileSizeMul
 198+ 6E72
 199+ 6E72              GetFileSizeEnd:
 200+ 6E72 E5           	push	hl
 201+ 6E73 CD 16 6E     		call	DestroyChannel
 202+ 6E76 E1           	pop		hl
 203+ 6E77
 204+ 6E77 C9           	ret
 205+ 6E78              	ENDIF
 206+ 6E78
 207+ 6E78              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 208+ 6E78              ;HL=file name, A=drive
 209+ 6E78              DeleteFile:
 210+ 6E78 CD 00 6E     	call	CreateChannel
 211+ 6E7B
 212+ 6E7B 3E 06        	ld		a, 6
 213+ 6E7D CD 3C 6E     	call	BDOS
 214+ 6E80
 215+ 6E80 CD 16 6E     	call	DestroyChannel
 216+ 6E83 C9           	ret
 217+ 6E84
 218+ 6E84              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 219+ 6E84              ;Returns A > 0 if the file exists
 220+ 6E84              ;HL=file name, A=drive
 221+ 6E84              DoesFileExist:
 222+ 6E84              	IFUSED
 223+ 6E84 CD 00 6E     	call	CreateChannel
 224+ 6E87
 225+ 6E87 3E 04        	ld		a, 4
 226+ 6E89 CD 3C 6E     	call	BDOS
 227+ 6E8C
 228+ 6E8C F5           	push	af
 229+ 6E8D CD 16 6E     		call	DestroyChannel
 230+ 6E90 F1           	pop		af
 231+ 6E91 C9           	ret
 232+ 6E92              	ENDIF
 233+ 6E92
 234+ 6E92              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 235+ 6E92              ;IN: E0 = RO, E1 = SYS, HL=filename
 236+ 6E92              ChangeFileAttrib:
 237+ 6E92 3A CC 6D     	ld 		a, (RWTSDrive)
 238+ 6E95 3C           	inc		a					;Convert to BASIC drive number: 1,2
 239+ 6E96 D5           	push	de
 240+ 6E97 CD 00 6E     	call	CreateChannel
 241+ 6E9A D1           	pop		de
 242+ 6E9B
 243+ 6E9B DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 244+ 6E9E CB 27        	sla		a								;reset existing attribute flag
 245+ 6EA0 CB 1B        	rr		e								;put wanted flag in Carry flag
 246+ 6EA2 CB 1F        	rr		a								;put Carry flag in register L
 247+ 6EA4 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 248+ 6EA7
 249+ 6EA7 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 250+ 6EAA CB 27        	sla		a
 251+ 6EAC CB 1B        	rr		e
 252+ 6EAE CB 1F        	rr		a
 253+ 6EB0 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 254+ 6EB3
 255+ 6EB3              FileAttribSet:
 256+ 6EB3 3E 11        	ld		a, 17
 257+ 6EB5 CD 3C 6E     	call	BDOS
 258+ 6EB8
 259+ 6EB8 CD 16 6E     	call	DestroyChannel
 260+ 6EBB C9           	ret
 261+ 6EBC
 262+ 6EBC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 263+ 6EBC
 264+ 6EBC              ;HL=original name, DE = new name
 265+ 6EBC              ;Works only on the same drive.
 266+ 6EBC              RenameFile:
 267+ 6EBC 3A CC 6D     	ld 		a, (RWTSDrive)
 268+ 6EBF 3C           	inc		a					;Convert to BASIC drive number: 1,2
 269+ 6EC0 D5           	push	de
 270+ 6EC1 CD 00 6E     	call	CreateChannel
 271+ 6EC4 D1           	pop		de
 272+ 6EC5
 273+ 6EC5 DD E5        	push	ix					;IX == FCB
 274+ 6EC7 E1           	pop		hl
 275+ 6EC8 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 276+ 6ECB 09           	add		hl, bc
 277+ 6ECC EB           	ex		de, hl
 278+ 6ECD 3A CC 6D     	ld		a, (RWTSDrive)
 279+ 6ED0 12           	ld		(de), a
 280+ 6ED1 01 0B 00     	ld		bc, NAMELEN
 281+ 6ED4 ED B0        	ldir
 282+ 6ED6
 283+ 6ED6 3E 0A        	ld		a, 10
 284+ 6ED8 CD 3C 6E     	call	BDOS
 285+ 6EDB
 286+ 6EDB CD 16 6E     	call	DestroyChannel
 287+ 6EDE C9           	ret
 288+ 6EDF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 289+ 6EDF              PromptDiskChangeDst:
 290+ 6EDF 21 88 7A     	ld		hl, MsgInsertDstDsk
 291+ 6EE2 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 292+ 6EE5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 293+ 6EE7 CD 40 72     	call	PrintStrClr
 294+ 6EEA 21 97 7A     	ld		hl, MsgPressAnyKey
 295+ 6EED 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 296+ 6EF0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 297+ 6EF2 CD 40 72     	call	PrintStrClr
 298+ 6EF5 CD DC 71     	call	ReadChar
 299+ 6EF8 C9           	ret
 300+ 6EF9
 301+ 6EF9              PromptDiskChangeSrc:
 302+ 6EF9 21 79 7A     	ld		hl, MsgInsertSrcDsk
 303+ 6EFC 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 304+ 6EFF 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 305+ 6F01 CD 40 72     	call	PrintStrClr
 306+ 6F04 21 97 7A     	ld		hl, MsgPressAnyKey
 307+ 6F07 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 308+ 6F0A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 309+ 6F0C CD 40 72     	call	PrintStrClr
 310+ 6F0F CD DC 71     	call	ReadChar
 311+ 6F12 C9           	ret
 312+ 6F13              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 313+ 6F13
 314+ 6F13              ;Will copy a file from A: to B: or vice versa.
 315+ 6F13              ;HL = source file name, A = source drive
 316+ 6F13              ;TODO:
 317+ 6F13              ;Use cases:
 318+ 6F13              ;1. Copy from A: to B: or B: to A:.
 319+ 6F13              ;2. Copy from A: to A:, with alternating disks (single drive) - ask for disk change.
 320+ 6F13              ;3. Copy from A:/B: to COM.
 321+ 6F13              ;4. Copy from COM to A:/B:.
 322+ 6F13              ;Validations:
 323+ 6F13              ;1. Ask for destination: to A:/to B:/to COM/from COM.
 324+ 6F13              ;2. Ask for new name (except to COM), default to current name, allow changing.
 325+ 6F13              ;3. Check if destination file name exists for A:/B:/from COM. Allow overwrite for different drives, don't allow for same drive.
 326+ 6F13              CopyFile:
 327+ 6F13 3A CC 6D     	ld 		a, (RWTSDrive)
 328+ 6F16 3C           	inc		a					;Convert to BASIC drive number: 1,2
 329+ 6F17 32 DA 88     	ld		(CopyFileSrc), a
 330+ 6F1A 32 E6 88     	ld		(CopyFileDst), a
 331+ 6F1D 11 DB 88     	ld		de, CopyFileSrc+1
 332+ 6F20 01 0B 00     	ld		bc, NAMELEN
 333+ 6F23 E5           	push	hl
 334+ 6F24 C5           	push	bc
 335+ 6F25 ED B0        	ldir
 336+ 6F27 C1           	pop		bc
 337+ 6F28 E1           	pop		hl
 338+ 6F29 11 E7 88     	ld		de, CopyFileDst+1
 339+ 6F2C ED B0        	ldir
 340+ 6F2E
 341+ 6F2E AF           	xor		a
 342+ 6F2F 32 CD 88     	ld		(CopyFileRes), a
 343+ 6F32
 344+ 6F32 3A DA 88     	ld		a, (CopyFileSrc)
 345+ 6F35 C6 40        	add		'A'-1
 346+ 6F37              	;Update menu messages with current drive.
 347+ 6F37 32 01 7A     	ld		(MsgMenuSingleDrv1), a
 348+ 6F3A 32 05 7A     	ld		(MsgMenuSingleDrv2), a
 349+ 6F3D 32 0F 7A     	ld		(MsgMenuDualDrv1), a
 350+ 6F40 32 1D 7A     	ld		(MsgMenuToComDrv), a
 351+ 6F43 32 31 7A     	ld		(MsgMenuFromCOMDrv), a
 352+ 6F46              	;Update menu messages with the alternate drive.
 353+ 6F46 3A DA 88     	ld		a, (CopyFileSrc)
 354+ 6F49 EE 03        	xor		%11
 355+ 6F4B C6 40        	add		'A'-1
 356+ 6F4D 32 13 7A     	ld		(MsgMenuDualDrv2), a
 357+ 6F50
 358+ 6F50 21 DE 79     	ld		hl, MsgMenuFileCopy
 359+ 6F53 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 360+ 6F56 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 361+ 6F58 CD 40 72     	call	PrintStrClr
 362+ 6F5B 21 ED 79     	ld		hl, MsgMenuBack
 363+ 6F5E 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 364+ 6F61 CD 18 72     	call	PrintStr
 365+ 6F64 21 F9 79     	ld		hl, MsgMenuSingle
 366+ 6F67 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 367+ 6F6A CD 18 72     	call	PrintStr
 368+ 6F6D 21 07 7A     	ld		hl, MsgMenuDual
 369+ 6F70 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 370+ 6F73 CD 18 72     	call	PrintStr
 371+ 6F76 21 15 7A     	ld		hl, MsgMenuToCOM
 372+ 6F79 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 373+ 6F7C CD 18 72     	call	PrintStr
 374+ 6F7F 21 24 7A     	ld		hl, MsgMenuFromCOM
 375+ 6F82 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 376+ 6F85 CD 18 72     	call	PrintStr
 377+ 6F88
 378+ 6F88 CD DC 71     	call	ReadChar
 379+ 6F8B 32 AD 7A     	ld		(CopySelOption), a
 380+ 6F8E
 381+ 6F8E F5           	push	af
 382+ 6F8F 06 06        		ld		b, 6
 383+ 6F91 CD DA 73     		call	ClearNMsgLines
 384+ 6F94 F1           	pop		af
 385+ 6F95
 386+ 6F95              	;TODO: Implement new file copy menu.
 387+ 6F95              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 388+ 6F95 FE 30        	cp		'0'
 389+ 6F97 20 04        	jr		nz, CopyFileNotExit
 390+ 6F99 E1           	pop		hl
 391+ 6F9A C3 17 63     	jp		ReadKeyLoop
 392+ 6F9D
 393+ 6F9D              CopyFileNotExit:
 394+ 6F9D FE 31        	cp		'1'
 395+ 6F9F 28 1C        	jr		z, CopyFileSameDrive
 396+ 6FA1
 397+ 6FA1 FE 32        	cp		'2'
 398+ 6FA3 28 0E        	jr		z, CopyFileDualDrive
 399+ 6FA5
 400+ 6FA5 FE 33        	cp		'3'
 401+ 6FA7 CA 51 70     	jp		z, CopyFileToCOM
 402+ 6FAA
 403+ 6FAA FE 34        	cp		'4'
 404+ 6FAC CA 82 70     	jp		z, CopyFileFromCOM
 405+ 6FAF
 406+ 6FAF E1           	pop		hl
 407+ 6FB0 C3 17 63     	jp		ReadKeyLoop
 408+ 6FB3
 409+ 6FB3              CopyFileDualDrive:
 410+ 6FB3 3A DA 88     	ld		a, (CopyFileSrc)
 411+ 6FB6 EE 03        	xor		%11
 412+ 6FB8 32 E6 88     	ld		(CopyFileDst), a
 413+ 6FBB 18 09        	jr		CopyFileCheckOverwrite
 414+ 6FBD
 415+ 6FBD              CopyFileSameDrive:
 416+ 6FBD CD DF 6E     	call	PromptDiskChangeDst
 417+ 6FC0 3A CC 6D     	ld		a, (RWTSDrive)
 418+ 6FC3 CD F4 6D     	call	BDOSInit
 419+ 6FC6
 420+ 6FC6              CopyFileCheckOverwrite:
 421+ 6FC6              	;Check if destination file exists.
 422+ 6FC6 3A E6 88     	ld		a, (CopyFileDst)
 423+ 6FC9 21 E7 88     	ld		hl, CopyFileDst+1
 424+ 6FCC CD 84 6E     	call	DoesFileExist
 425+ 6FCF 3C           	inc		a
 426+ 6FD0 28 11        	jr		z, CopyFileDestNotExist
 427+ 6FD2
 428+ 6FD2              	;Ask overwrite confirmation.
 429+ 6FD2 21 5B 7A     	ld		hl, MsgFileOverwrite
 430+ 6FD5 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 431+ 6FD8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 432+ 6FDA CD 40 72     	call	PrintStrClr
 433+ 6FDD CD DC 71     	call	ReadChar
 434+ 6FE0 FE 79        	cp		'y'
 435+ 6FE2 C0           	ret		nz
 436+ 6FE3
 437+ 6FE3              CopyFileDestNotExist:
 438+ 6FE3              	;Delete and re-create empty destination file
 439+ 6FE3 3A E6 88     	ld		a, (CopyFileDst)
 440+ 6FE6 21 E7 88     	ld		hl, CopyFileDst+1
 441+ 6FE9 F5           	push	af
 442+ 6FEA E5           	push	hl
 443+ 6FEB CD 78 6E     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 444+ 6FEE E1           	pop		hl
 445+ 6FEF F1           	pop		af
 446+ 6FF0 CD 00 6E     	call	CreateChannel
 447+ 6FF3 CD 20 6E     	call 	BDOSCreateFile
 448+ 6FF6 3C           	inc  	a						;Cancel if A==$FF
 449+ 6FF7 C8           	ret		z
 450+ 6FF8
 451+ 6FF8              	;Close dest file once created.
 452+ 6FF8 CD 28 6E     	call	BDOSCloseFile
 453+ 6FFB CD 16 6E     	call	DestroyChannel
 454+ 6FFE
 455+ 6FFE 11 00 00     	ld		de, 0
 456+ 7001 ED 53 D4 88  	ld		(FilePosRead), de
 457+ 7005 ED 53 D6 88  	ld		(FilePosWrite), de
 458+ 7009
 459+ 7009              CopyFileLoop:
 460+ 7009              	;If copying on different drives, don't prompt for disk change.
 461+ 7009 3A AD 7A     	ld		a, (CopySelOption)
 462+ 700C FE 31        	cp		'1'
 463+ 700E 20 09        	jr		nz, CopyFileNotSameDrive1
 464+ 7010
 465+ 7010 CD F9 6E     	call	PromptDiskChangeSrc
 466+ 7013
 467+ 7013 3A CC 6D     	ld		a, (RWTSDrive)
 468+ 7016 CD F4 6D     	call	BDOSInit
 469+ 7019
 470+ 7019              CopyFileNotSameDrive1:
 471+ 7019 3A DA 88     	ld		a, (CopyFileSrc)
 472+ 701C 21 DB 88     	ld		hl, CopyFileSrc+1
 473+ 701F CD 29 71     	call	ReadFileSection
 474+ 7022 3A CD 88     	ld		a, (CopyFileRes)
 475+ 7025 F5           	push	af
 476+ 7026
 477+ 7026              		;If copying on different drives, don't prompt for disk change.
 478+ 7026 3A AD 7A     		ld		a, (CopySelOption)
 479+ 7029 FE 31        		cp		'1'
 480+ 702B 20 09        		jr		nz, CopyFileNotSameDrive2
 481+ 702D
 482+ 702D CD DF 6E     		call	PromptDiskChangeDst
 483+ 7030
 484+ 7030 3A CC 6D     		ld		a, (RWTSDrive)
 485+ 7033 CD F4 6D     		call	BDOSInit
 486+ 7036
 487+ 7036              CopyFileNotSameDrive2:
 488+ 7036 3A E6 88     		ld		a, (CopyFileDst)
 489+ 7039 21 E7 88     		ld		hl, CopyFileDst+1
 490+ 703C CD 4B 71     		call	WriteFileSection
 491+ 703F 3A CD 88     		ld		a, (CopyFileRes)
 492+ 7042 47           		ld		b, a
 493+ 7043 F1           	pop		af
 494+ 7044 B0           	or		b
 495+ 7045 C0           	ret		nz
 496+ 7046
 497+ 7046              	;Check if file ended, if not, continue copying.
 498+ 7046
 499+ 7046 3A D8 88     	ld		a, (CopyFileSectCnt)
 500+ 7049 3D           	dec		a
 501+ 704A 32 D8 88     	ld		(CopyFileSectCnt), a
 502+ 704D B7           	or		a
 503+ 704E 20 B9        	jr		nz, CopyFileLoop
 504+ 7050
 505+ 7050 C9           	ret
 506+ 7051
 507+ 7051
 508+ 7051              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 509+ 7051              CopyFileToCOM:
 510+ 7051 AF           	xor		a
 511+ 7052 32 CD 88     	ld		(CopyFileRes), a
 512+ 7055 32 D8 88     	ld		(CopyFileSectCnt), a
 513+ 7058 11 00 00     	ld		de, 0
 514+ 705B ED 53 D4 88  	ld		(FilePosRead), de
 515+ 705F
 516+ 705F              CopyFileToCOMLoop:
 517+ 705F 3A DA 88     	ld		a, (CopyFileSrc)
 518+ 7062 21 DB 88     	ld		hl, CopyFileSrc+1
 519+ 7065 CD 29 71     	call	ReadFileSection
 520+ 7068
 521+ 7068 3A D8 88     	ld		a, (CopyFileSectCnt)
 522+ 706B B7           	or		a
 523+ 706C 28 0F        	jr		z, CopyFileToCOMEnd
 524+ 706E
 525+ 706E              	;Send buffer to COM port.
 526+ 706E 21 CB 89     	ld		hl, FileData
 527+ 7071 47           	ld		b, a					;Sector size is 256.
 528+ 7072 0E 00        	ld		c, 0
 529+ 7074 CD BB 77     	call	SERTB
 530+ 7077
 531+ 7077 3A CD 88     	ld		a, (CopyFileRes)
 532+ 707A B7           	or		a
 533+ 707B 28 E2        	jr		z, CopyFileToCOMLoop
 534+ 707D
 535+ 707D              CopyFileToCOMEnd:
 536+ 707D              	;Reset read error code, as 1 is returned when file is finished reading.
 537+ 707D AF           	xor		a
 538+ 707E 32 CD 88     	ld		(CopyFileRes), a
 539+ 7081
 540+ 7081 C9           	ret
 541+ 7082
 542+ 7082              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 543+ 7082              CopyFileFromCOM:
 544+ 7082 AF           	xor		a
 545+ 7083 32 CD 88     	ld		(CopyFileRes), a
 546+ 7086 11 00 00     	ld		de, 0
 547+ 7089 ED 53 D6 88  	ld		(FilePosWrite), de
 548+ 708D
 549+ 708D              	;Must ask for the new file name and check to not exist.
 550+ 708D 21 C4 79     	ld		hl, MsgNewFileName
 551+ 7090 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 552+ 7093 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 553+ 7095 CD 40 72     	call	PrintStrClr
 554+ 7098
 555+ 7098 21 8F 79     	ld		hl, MsgClear
 556+ 709B 11 CB 89     	ld		de, FileData
 557+ 709E 01 0B 00     	ld		bc, NAMELEN
 558+ 70A1 ED B0        	ldir
 559+ 70A3 3E A0        	ld		a, $80 | ' '
 560+ 70A5 12           	ld		(de), a
 561+ 70A6 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 562+ 70A9 21 CB 89     	ld		hl, FileData
 563+ 70AC CD 18 72     	call	PrintStr
 564+ 70AF
 565+ 70AF 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 566+ 70B2 01 0B 00     	ld		bc, NAMELEN
 567+ 70B5 CD 98 73     	call	ReadString
 568+ 70B8
 569+ 70B8 11 CB 89     	ld		de, FileData
 570+ 70BB 1A           	ld		a, (de)
 571+ 70BC FE 20        	cp		' '					;If starting with space, input was canceled.
 572+ 70BE C8           	ret		z
 573+ 70BF
 574+ 70BF              	;Check if new name doesn't exist already.
 575+ 70BF 21 CB 89     	ld		hl, FileData
 576+ 70C2 3A E6 88     	ld 		a, (CopyFileDst)
 577+ 70C5 CD 84 6E     	call	DoesFileExist
 578+ 70C8 3C           	inc		a
 579+ 70C9 28 11        	jr		z, CopyFileFromCOMNameOK
 580+ 70CB
 581+ 70CB              	;Ask overwrite confirmation.
 582+ 70CB 21 5B 7A     	ld		hl, MsgFileOverwrite
 583+ 70CE 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 70D1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 70D3 CD 40 72     	call	PrintStrClr
 586+ 70D6 CD DC 71     	call	ReadChar
 587+ 70D9 FE 79        	cp		'y'
 588+ 70DB C0           	ret		nz
 589+ 70DC
 590+ 70DC              CopyFileFromCOMNameOK:
 591+ 70DC              	;Copy new file name
 592+ 70DC 21 CB 89     	ld		hl, FileData
 593+ 70DF 11 E7 88     	ld		de, CopyFileDst+1
 594+ 70E2 01 0B 00     	ld		bc, NAMELEN
 595+ 70E5 ED B0        	ldir
 596+ 70E7
 597+ 70E7              	;Delete and re-create empty destination file
 598+ 70E7 3A E6 88     	ld		a, (CopyFileDst)
 599+ 70EA 21 E7 88     	ld		hl, CopyFileDst+1
 600+ 70ED F5           	push	af
 601+ 70EE E5           	push	hl
 602+ 70EF CD 78 6E     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 603+ 70F2 E1           	pop		hl
 604+ 70F3 F1           	pop		af
 605+ 70F4 CD 00 6E     	call	CreateChannel
 606+ 70F7 CD 20 6E     	call 	BDOSCreateFile
 607+ 70FA 3C           	inc  	a						;Cancel if A==$FF
 608+ 70FB C8           	ret		z
 609+ 70FC              	;Close dest file once created.
 610+ 70FC CD 28 6E     	call	BDOSCloseFile
 611+ 70FF CD 16 6E     	call	DestroyChannel
 612+ 7102
 613+ 7102              CopyFileFromCOMLoop:
 614+ 7102 21 CB 89     	ld		hl, FileData
 615+ 7105 01 00 6A     	ld		bc, FileDataSize
 616+ 7108 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 617+ 710A CD 88 77     	call	SERRB				;BC = Number of bytes read from COM
 618+ 710D 79           	ld		a, c
 619+ 710E B0           	or		b
 620+ 710F C8           	ret		z
 621+ 7110
 622+ 7110              	;If C is not 0, add one more sector.
 623+ 7110 79           	ld 		a, c
 624+ 7111 B7           	or		a
 625+ 7112 28 01        	jr		z, CopyFileFromCOMDontInc
 626+ 7114 04           	inc		b
 627+ 7115              CopyFileFromCOMDontInc:
 628+ 7115 78           	ld		a, b				;Sector size is 256
 629+ 7116 32 D8 88     	ld		(CopyFileSectCnt), a
 630+ 7119 3A E6 88     	ld		a, (CopyFileDst)
 631+ 711C 21 E7 88     	ld		hl, CopyFileDst+1
 632+ 711F CD 4B 71     	call	WriteFileSection
 633+ 7122
 634+ 7122 3A CD 88     	ld		a, (CopyFileRes)
 635+ 7125 B7           	or		a
 636+ 7126 28 DA        	jr		z, CopyFileFromCOMLoop
 637+ 7128
 638+ 7128 C9           	ret
 639+ 7129
 640+ 7129              ;Reads/Writes disk file portion to/from memory.
 641+ 7129              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 642+ 7129              ;This should work with single-drive file copy from one disk to another.
 643+ 7129              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records
 644+ 7129              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 645+ 7129              ;
 646+ 7129              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 647+ 7129              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 648+ 7129              ;Must use sequential read/write. But for the first operation must use random read/write.
 649+ 7129              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 650+ 7129              ReadFileSection:
 651+ 7129 11 34 6E     	ld		de, BDOSReadFileBlockRandom
 652+ 712C ED 53 93 71  	ld		(CopyFileOperAddr1), de
 653+ 7130 11 2C 6E     	ld		de, BDOSReadFileBlockSeq
 654+ 7133 ED 53 B2 71  	ld		(CopyFileOperAddr2), de
 655+ 7137 11 D4 88     	ld		de, FilePosRead
 656+ 713A ED 53 8A 71  	ld		(CopyFilePtr), de
 657+ 713E ED 53 CE 71  	ld		(CopyFilePtr2), de
 658+ 7142
 659+ 7142              	;Limit max sectors to read to leave space for the index too.
 660+ 7142 F5           	push	af
 661+ 7143 3E 6A        		ld		a, FileDataSize/SECT_SZ
 662+ 7145 32 D8 88     		ld		(CopyFileSectCnt), a
 663+ 7148 F1           	pop		af
 664+ 7149 18 19        	jr		ReadWriteFileSection
 665+ 714B
 666+ 714B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 667+ 714B
 668+ 714B              WriteFileSection:
 669+ 714B 11 38 6E     	ld		de, BDOSWriteFileBlockRandom
 670+ 714E ED 53 93 71  	ld		(CopyFileOperAddr1), de
 671+ 7152 11 30 6E     	ld		de, BDOSWriteFileBlockSeq
 672+ 7155 ED 53 B2 71  	ld		(CopyFileOperAddr2), de
 673+ 7159 11 D6 88     	ld		de, FilePosWrite
 674+ 715C ED 53 8A 71  	ld		(CopyFilePtr), de
 675+ 7160 ED 53 CE 71  	ld		(CopyFilePtr2), de
 676+ 7164
 677+ 7164
 678+ 7164              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 679+ 7164              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 680+ 7164              ReadWriteFileSection:
 681+ 7164 CD 00 6E     	call	CreateChannel
 682+ 7167 DD 22 CB 88  	ld		(CopyFileFCB), ix
 683+ 716B CD 24 6E     	call 	BDOSOpenFile
 684+ 716E 3C           	inc  	a						;Cancel if A==$FF
 685+ 716F C8           	ret		z
 686+ 7170
 687+ 7170              	;Set DMA initial pointer = FileData
 688+ 7170 DD E5        	push	ix
 689+ 7172 21 CB 89     		ld		hl, FileData
 690+ 7175 DD 21 CE 88  		ld		ix, CopyFileDMAAddr
 691+ 7179 DD 75 00     		ld		(ix), l
 692+ 717C DD 74 01     		ld		(ix+1), h
 693+ 717F DD 21 CB 89  		ld		ix, FileData
 694+ 7183 CD 46 6E     		call 	BDOSSetDMA
 695+ 7186 DD E1        	pop		ix
 696+ 7188
 697+ 7188              CopyFilePtr EQU $+2
 698+ 7188              	;Update file pointer using read/write random call.
 699+ 7188 ED 5B D4 88  	ld		de, (FilePosRead)
 700+ 718C DD 73 21     	ld		(ix + FCB_R0), e
 701+ 718F DD 72 22     	ld		(ix + FCB_R1), d
 702+ 7192              CopyFileOperAddr1 EQU $ + 1
 703+ 7192 CD 34 6E     	call 	BDOSReadFileBlockRandom
 704+ 7195
 705+ 7195 32 CD 88     	ld		(CopyFileRes), a
 706+ 7198 B7           	or		a
 707+ 7199 20 22        	jr		nz, ReadWriteFileSectionEnd
 708+ 719B
 709+ 719B 3A D8 88     	ld		a, (CopyFileSectCnt)
 710+ 719E 47           	ld		b, a
 711+ 719F
 712+ 719F              ReadWriteFileSectionLoop:
 713+ 719F C5           	push	bc
 714+ 71A0 DD 2A CE 88  		ld		ix, (CopyFileDMAAddr)
 715+ 71A4 CD 46 6E     		call 	BDOSSetDMA
 716+ 71A7 DD 24        		inc		ixh
 717+ 71A9 DD 22 CE 88  		ld		(CopyFileDMAAddr), ix
 718+ 71AD
 719+ 71AD DD 2A CB 88  		ld		ix, (CopyFileFCB)
 720+ 71B1              CopyFileOperAddr2 EQU $ + 1
 721+ 71B1 CD 2C 6E     		call 	BDOSReadFileBlockSeq
 722+ 71B4
 723+ 71B4 32 CD 88     		ld		(CopyFileRes), a
 724+ 71B7 B7           		or		a
 725+ 71B8 C1           	pop		bc
 726+ 71B9 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 727+ 71BB 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 728+ 71BD
 729+ 71BD              ReadWriteFileSectionEnd:
 730+ 71BD              	;Update sector count variable with how many sectors were transfered.
 731+ 71BD 3E 6A        	ld 		a, FileDataSize/SECT_SZ
 732+ 71BF 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 733+ 71C0 32 D8 88     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 734+ 71C3
 735+ 71C3              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 736+ 71C3 CD 4A 6E     	call	BDOSSetRandFilePtr
 737+ 71C6 DD 5E 21     	ld		e, (ix + FCB_R0)
 738+ 71C9 DD 56 22     	ld		d, (ix + FCB_R1)
 739+ 71CC              CopyFilePtr2 EQU $+2
 740+ 71CC ED 53 D4 88  	ld		(FilePosRead), de
 741+ 71D0
 742+ 71D0 CD 28 6E     	call 	BDOSCloseFile
 743+ 71D3 CD 16 6E     	call 	DestroyChannel
 744+ 71D6
 745+ 71D6 ED 5B CE 88  	ld		de, (CopyFileDMAAddr)
 746+ 71DA 15           	dec		d
 747+ 71DB C9           	ret
 748+ 71DC
 749+ 71DC              	ENDIF
 750+ 71DC
# file closed: bdos.asm
1248  71DC              	include "ui.asm"
# file opened: ui.asm
   1+ 71DC              ;UI related functions
   2+ 71DC
   3+ 71DC              	ifndef	_UI_
   4+ 71DC              	define	_UI_
   5+ 71DC
   6+ 71DC              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++71DC              	ifndef	_HCCFG_
   2++71DC ~            	define	_HCCFG_
   3++71DC ~
   4++71DC ~            ;HC specific code, for configuration
   5++71DC ~
   6++71DC ~            HC_CFG_PORT			EQU	$7E
   7++71DC ~
   8++71DC ~            ;BASIC/CPM ROM selection
   9++71DC ~            HC_CFG_ROM_BAS		EQU	%0
  10++71DC ~            HC_CFG_ROM_CPM		EQU	%1
  11++71DC ~
  12++71DC ~            ;Address for ROM paging: 0 or $E000
  13++71DC ~            HC_CFG_ROM_0000		EQU %00
  14++71DC ~            HC_CFG_ROM_E000		EQU %10
  15++71DC ~
  16++71DC ~            ;Cfg. port Enable/Disable
  17++71DC ~            HC_CFG_PORT_DIS		EQU %000
  18++71DC ~            HC_CFG_PORT_EN		EQU	%100
  19++71DC ~
  20++71DC ~            ;Video memory bank: $4000 or $C000
  21++71DC ~            HC_CFG_VID_4000		EQU	%0000
  22++71DC ~            HC_CFG_VID_C000		EQU	%1000
  23++71DC ~
  24++71DC ~
  25++71DC ~            ;Standar BASIC config
  26++71DC ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++71DC ~            ;Standar CP/M config
  28++71DC ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++71DC ~
  30++71DC ~
  31++71DC ~            HC_VID_BANK0		EQU	$4000
  32++71DC ~            HC_VID_BANK1		EQU	$C000
  33++71DC ~
  34++71DC              	endif
# file closed: hccfg.asm
   7+ 71DC
   8+ 71DC              COL             EQU 23728
   9+ 71DC              LINE            EQU 23729               ;Coordinates
  10+ 71DC              LineCol			EQU	COL
  11+ 71DC              CODE			EQU 23681               ;Char to print
  12+ 71DC
  13+ 71DC              CPM_FNT         EQU $25AB
  14+ 71DC
  15+ 71DC              PORT_ZX			EQU	$FE
  16+ 71DC
  17+ 71DC              ;COLORS
  18+ 71DC              CLR_BLACK		EQU 0
  19+ 71DC              CLR_BLUE		EQU 1
  20+ 71DC              CLR_RED			EQU 2
  21+ 71DC              CLR_MAGENTA		EQU 3
  22+ 71DC              CLR_GREEN		EQU 4
  23+ 71DC              CLR_CYAN		EQU	5
  24+ 71DC              CLR_YELLOW		EQU	6
  25+ 71DC              CLR_WHITE		EQU	7
  26+ 71DC              CLR_BRIGHT		EQU	%01000000
  27+ 71DC              CLR_FLASH		EQU	%10000000
  28+ 71DC
  29+ 71DC              ;PAPER
  30+ 71DC              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 71DC              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 71DC              PAPER_RED		EQU (CLR_RED << 3)
  33+ 71DC              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 71DC              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 71DC              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 71DC              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 71DC              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 71DC
  39+ 71DC              ;INK
  40+ 71DC              INK_BLACK		EQU CLR_BLACK
  41+ 71DC              INK_BLUE		EQU CLR_BLUE
  42+ 71DC              INK_RED			EQU CLR_RED
  43+ 71DC              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 71DC              INK_GREEN		EQU CLR_GREEN
  45+ 71DC              INK_CYAN		EQU	CLR_CYAN
  46+ 71DC              INK_YELLOW		EQU	CLR_YELLOW
  47+ 71DC              INK_WHITE		EQU	CLR_WHITE
  48+ 71DC
  49+ 71DC
  50+ 71DC              SCR_ATTR_ADDR	EQU 22528
  51+ 71DC              SCR_ADDR		EQU 16384
  52+ 71DC              SCR_PIX_LEN		EQU	6144
  53+ 71DC              SCR_ATTR_LEN	EQU	768
  54+ 71DC              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 71DC              SCR_BYTES_PER_LINE	EQU	32
  56+ 71DC
  57+ 71DC              SCR_COLS		EQU	64
  58+ 71DC              SCR_LINES		EQU 24
  59+ 71DC
  60+ 71DC              ;used for file names list positioning
  61+ 71DC              LST_LINES_CNT	EQU	21
  62+ 71DC              LST_FIRST_LINE	EQU	1
  63+ 71DC              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 71DC              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 71DC              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 71DC              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  67+ 71DC              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 71DC              LST_FIRST_COL	EQU	16
  69+ 71DC              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 71DC
  71+ 71DC              ;key codes
  72+ 71DC              KEY_ESC			EQU	7
  73+ 71DC              KEY_LEFT		EQU	8
  74+ 71DC              KEY_RIGHT		EQU	9
  75+ 71DC              KEY_DOWN		EQU	10
  76+ 71DC              KEY_UP			EQU	11
  77+ 71DC              KEY_BACKSP		EQU 12
  78+ 71DC              KEY_ENTER		EQU	13
  79+ 71DC              KEY_CTRL		EQU	14
  80+ 71DC
  81+ 71DC              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 71DC              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN
  83+ 71DC              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 71DC
  85+ 71DC              ;Special formating chars
  86+ 71DC              CHR_CR			EQU	13
  87+ 71DC              CHR_LF			EQU	10
  88+ 71DC              CHR_TAB			EQU	09
  89+ 71DC
  90+ 71DC
  91+ 71DC              ;Semi-graphical chars
  92+ 71DC              ;           UC
  93+ 71DC              ;     UL +H-+--+UR
  94+ 71DC              ;        |  |  |
  95+ 71DC              ;     ML +--+--+MR
  96+ 71DC              ;        V C|  |
  97+ 71DC              ;     LL +--+--+LR
  98+ 71DC              ;           DC
  99+ 71DC              CHR_GRID        EQU 127
 100+ 71DC              CHR_V           EQU	128
 101+ 71DC              CHR_MR          EQU	129
 102+ 71DC              CHR_UR          EQU 130
 103+ 71DC              CHR_DL          EQU 131
 104+ 71DC              CHR_DC          EQU 132
 105+ 71DC              CHR_UC          EQU 133
 106+ 71DC              CHR_ML          EQU 134
 107+ 71DC              CHR_H           EQU 135
 108+ 71DC              CHR_C           EQU 136
 109+ 71DC              CHR_LR          EQU 137
 110+ 71DC              CHR_UL          EQU 138
 111+ 71DC              CHR_FULL        EQU 139
 112+ 71DC              CHR_HALF        EQU 140
 113+ 71DC
 114+ 71DC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 71DC
 116+ 71DC              ;Return read char in A
 117+ 71DC              ReadChar:
 118+ 71DC CF           	rst 08
 119+ 71DD 1B           	DEFB 27
 120+ 71DE C9           	ret
 121+ 71DF
 122+ 71DF              ;Checks if a key is pressed
 123+ 71DF              ;Cy=1 if key is pressed
 124+ 71DF              KbdHit:
 125+ 71DF CF           	rst 08
 126+ 71E0 20           	DEFB 32
 127+ 71E1 C9           	ret
 128+ 71E2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 71E2
 130+ 71E2              InitFonts:
 131+ 71E2              	IFUSED
 132+ 71E2                  ;page-in CPM ROM to get fonts
 133+ 71E2 F3               di
 134+ 71E3 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 71E5 D3 7E            out	(HC_CFG_PORT), a
 136+ 71E7
 137+ 71E7 21 AB 25     	ld		hl, CPM_FNT
 138+ 71EA 11 63 85     	ld		de, FontTable
 139+ 71ED 01 68 03     	ld		bc, 872
 140+ 71F0 ED B0        	ldir
 141+ 71F2
 142+ 71F2                  ;restore BASIC ROM
 143+ 71F2 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 71F4 D3 7E            out	(HC_CFG_PORT), a
 145+ 71F6 FB               ei
 146+ 71F7
 147+ 71F7 C9           	ret
 148+ 71F8              	ENDIF
 149+ 71F8
 150+ 71F8              ClrScr:
 151+ 71F8 2A ED 73     	ld		hl, (CurrScrAddr)
 152+ 71FB 54           	ld		d, h
 153+ 71FC 5D           	ld		e, l
 154+ 71FD 13           	inc		de
 155+ 71FE 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 7201 36 00        	ld		(hl), 0
 157+ 7203 ED B0        	ldir
 158+ 7205
 159+ 7205 23           	inc 	hl
 160+ 7206 13           	inc		de
 161+ 7207
 162+ 7207 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 720A 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 720C ED B0        	ldir
 165+ 720E
 166+ 720E              	;also set border color
 167+ 720E 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 7210 D3 FE        	out		(PORT_ZX), a
 169+ 7212
 170+ 7212 3E 45        	ld		a, SCR_DEF_CLR
 171+ 7214 32 48 5C     	ld		(23624), a
 172+ 7217 C9           	ret
 173+ 7218
 174+ 7218              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 7218              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 7218              PrintStr:
 177+ 7218 7E           	ld		a, (hl)
 178+ 7219 FE 20        	cp		' '
 179+ 721B 30 02        	jr		nc, GoodChar
 180+ 721D 3E 3F        	ld		a, '?'
 181+ 721F              GoodChar:
 182+ 721F CB 7F        	bit		7, a
 183+ 7221 CB BF        	res		7, a
 184+ 7223 32 81 5C     	ld		(CODE), a
 185+ 7226 ED 53 B0 5C  	ld		(LineCol), de
 186+ 722A 08           	ex		af, af'
 187+ 722B D9           	exx
 188+ 722C E5           	push	hl
 189+ 722D CD 5A 73     	call 	PrintChar
 190+ 7230 E1           	pop		hl
 191+ 7231 D9           	exx
 192+ 7232 08           	ex		af, af'
 193+ 7233 C0           	ret		nz
 194+ 7234
 195+ 7234 1C           	inc		e
 196+ 7235 23           	inc		hl
 197+ 7236
 198+ 7236 7B           	ld		a, e
 199+ 7237 FE 40        	cp		64
 200+ 7239 38 DD        	jr		c, PrintStr
 201+ 723B 1E 00        	ld		e, 0
 202+ 723D 14           	inc		d
 203+ 723E
 204+ 723E 18 D8        	jr		PrintStr
 205+ 7240
 206+ 7240              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 7240
 208+ 7240              ;IN: HL = string, DE = coords, A = color
 209+ 7240              PrintStrClr:
 210+ 7240 32 6C 72     	ld		(StrClr), a
 211+ 7243 D5           	push	de
 212+ 7244 CD 18 72     		call	PrintStr
 213+ 7247 E1           	pop		hl
 214+ 7248              	;get string len.
 215+ 7248 7B           	ld		a, e
 216+ 7249 95           	sub		l
 217+ 724A 1F           	rra
 218+ 724B 08           	ex		af, af'
 219+ 724C              		;line * 32
 220+ 724C 7C           		ld		a, h
 221+ 724D 17           		rla
 222+ 724E 17           		rla
 223+ 724F 11 00 00     		ld	de, 0
 224+ 7252 17           		rla
 225+ 7253 CB 12        		rl	d
 226+ 7255 17           		rla
 227+ 7256 CB 12        		rl	d
 228+ 7258 17           		rla
 229+ 7259 CB 12        		rl	d
 230+ 725B 5F           		ld	e, a
 231+ 725C
 232+ 725C 26 00        		ld		h, 0
 233+ 725E 19           		add		hl, de
 234+ 725F ED 5B EF 73  		ld		de, (CurrScrAttrAddr)
 235+ 7263 19           		add		hl, de
 236+ 7264 08           	ex		af, af'
 237+ 7265 4F           	ld		c, a
 238+ 7266 06 00        	ld		b, 0
 239+ 7268 54           	ld		d, h
 240+ 7269 5D           	ld		e, l
 241+ 726A 13           	inc 	de
 242+ 726B              StrClr	EQU	$ + 1
 243+ 726B 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 726D ED B0        	ldir
 245+ 726F C9           	ret
 246+ 7270              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 7270
 248+ 7270              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 7270              DrawLine:
 250+ 7270 32 81 5C     	ld		(CODE), a
 251+ 7273
 252+ 7273 38 04        	jr		c, VertDir
 253+ 7275 3E 1C        	ld		a, $1C
 254+ 7277 18 02        	jr		StoreDir
 255+ 7279              VertDir:
 256+ 7279 3E 14        	ld		a, $14
 257+ 727B              StoreDir:
 258+ 727B 32 8B 72     	ld		(LineDir), a
 259+ 727E
 260+ 727E              DrawLineLoop:
 261+ 727E ED 53 B0 5C  	ld		(LineCol), de
 262+ 7282 D5           	push	de
 263+ 7283 D9           		exx
 264+ 7284 E5           		push	hl
 265+ 7285 CD 5A 73     		call 	PrintChar
 266+ 7288 E1           		pop		hl
 267+ 7289 D9           		exx
 268+ 728A D1           	pop		de
 269+ 728B              LineDir:
 270+ 728B 1C           	inc		e
 271+ 728C 10 F0        	djnz	DrawLineLoop
 272+ 728E
 273+ 728E C9           	ret
 274+ 728F
 275+ 728F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 728F
 277+ 728F              DrawHLines:
 278+ 728F 11 00 00     	ld		de, 0
 279+ 7292 06 40        	ld		b, 64
 280+ 7294 3E 87        	ld		a, CHR_H
 281+ 7296 B7           	or		a
 282+ 7297 CD 70 72     	call	DrawLine
 283+ 729A
 284+ 729A 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 729D 06 40        	ld		b, 64
 286+ 729F 3E 87        	ld		a, CHR_H
 287+ 72A1 B7           	or		a
 288+ 72A2 CD 70 72     	call	DrawLine
 289+ 72A5
 290+ 72A5 11 10 00     	ld		de, LST_FIRST_COL
 291+ 72A8 3E 85        	ld		a, CHR_UC
 292+ 72AA CD E6 72     	call	DrawIntersect
 293+ 72AD
 294+ 72AD 11 1C 00     	ld		de, LST_FIRST_COL + NAMELEN+1
 295+ 72B0 3E 85        	ld		a, CHR_UC
 296+ 72B2 CD E6 72     	call	DrawIntersect
 297+ 72B5
 298+ 72B5 11 28 00     	ld		de, LST_FIRST_COL + (NAMELEN+1)*2
 299+ 72B8 3E 85        	ld		a, CHR_UC
 300+ 72BA CD E6 72     	call	DrawIntersect
 301+ 72BD
 302+ 72BD 11 34 00     	ld		de, LST_FIRST_COL + (NAMELEN+1)*3
 303+ 72C0 3E 85        	ld		a, CHR_UC
 304+ 72C2 CD E6 72     	call	DrawIntersect
 305+ 72C5
 306+ 72C5 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 307+ 72C8 3E 84        	ld		a, CHR_DC
 308+ 72CA CD E6 72     	call	DrawIntersect
 309+ 72CD
 310+ 72CD 11 1C 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL + (NAMELEN+1)
 311+ 72D0 3E 84        	ld		a, CHR_DC
 312+ 72D2 CD E6 72     	call	DrawIntersect
 313+ 72D5
 314+ 72D5 11 28 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL + (NAMELEN+1)*2
 315+ 72D8 3E 84        	ld		a, CHR_DC
 316+ 72DA CD E6 72     	call	DrawIntersect
 317+ 72DD
 318+ 72DD 11 34 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL + (NAMELEN+1)*3
 319+ 72E0 3E 84        	ld		a, CHR_DC
 320+ 72E2 CD E6 72     	call	DrawIntersect
 321+ 72E5
 322+ 72E5
 323+ 72E5
 324+ 72E5 C9           	ret
 325+ 72E6
 326+ 72E6
 327+ 72E6              DrawIntersect:
 328+ 72E6 21 B0 5C     	ld		hl, LineCol
 329+ 72E9 73 23 72 2B  	ld		(hl), de
 330+ 72ED 32 81 5C     	ld		(CODE), a
 331+ 72F0 E5           	push	hl
 332+ 72F1 CD 5A 73     	call	PrintChar
 333+ 72F4 E1           	pop		hl
 334+ 72F5 34           	inc		(hl)
 335+ 72F6 3E 87        	ld		a, CHR_H
 336+ 72F8 32 81 5C     	ld		(CODE), a
 337+ 72FB CD 5A 73     	call	PrintChar
 338+ 72FE C9           	ret
 339+ 72FF
 340+ 72FF
 341+ 72FF              DrawVLines:
 342+ 72FF 06 04        	ld		b, 4
 343+ 7301 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 344+ 7304              DrawVLinesLoop:
 345+ 7304 C5           	push 	bc
 346+ 7305 D5           	push	de
 347+ 7306 06 15        		ld		b, LST_LINES_CNT
 348+ 7308 3E 80        		ld		a, CHR_V
 349+ 730A 37           		scf
 350+ 730B CD 70 72     		call	DrawLine
 351+ 730E D1           	pop		de
 352+ 730F C1           	pop	bc
 353+ 7310 7B           	ld		a, e
 354+ 7311 C6 0C        	add		NAMELEN+1
 355+ 7313 5F           	ld		e, a
 356+ 7314 10 EE        	djnz	DrawVLinesLoop
 357+ 7316 C9           	ret
 358+ 7317
 359+ 7317              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 360+ 7317
 361+ 7317              ;IN: A = color mask
 362+ 7317              DrawCursor:
 363+ 7317 ED 5B A7 7A  	ld	de, (CursorAddr)
 364+ 731B 06 06        	ld	b, 	(NAMELEN + 1)/2
 365+ 731D              DrawCursorLoop:
 366+ 731D 12           	ld	(de), a
 367+ 731E 13           	inc de
 368+ 731F 10 FC        	djnz DrawCursorLoop
 369+ 7321 C9           	ret
 370+ 7322
 371+ 7322              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 372+ 7322
 373+ 7322              ;IN:	A = file idx.
 374+ 7322              MoveCursor:
 375+ 7322              	;File idx / SCR_LINES => cursor line & column
 376+ 7322 6F           	ld		l, a
 377+ 7323 26 00        	ld		h, 0
 378+ 7325 0E 15        	ld		c, LST_LINES_CNT
 379+ 7327 CD CF 69     	call	Div					;HL = file column, A = line
 380+ 732A
 381+ 732A              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 382+ 732A C6 01        	add		LST_FIRST_LINE
 383+ 732C
 384+ 732C
 385+ 732C 54           	ld d, h
 386+ 732D 5D           	ld e, l
 387+ 732E 21 00 00     	ld	hl, 0
 388+ 7331
 389+ 7331              	;line*32
 390+ 7331 17           	rla
 391+ 7332 17           	rla
 392+ 7333 17           	rla
 393+ 7334 17           	rla
 394+ 7335 CB 14        	rl h
 395+ 7337 17           	rla
 396+ 7338 CB 14        	rl h
 397+ 733A 6F           	ld l, a
 398+ 733B
 399+ 733B
 400+ 733B              	;col * 6
 401+ 733B E5           	push	hl					;save line * 32
 402+ 733C 3E 06        		ld		a, (NAMELEN + 1)/2
 403+ 733E CD EF 69     		call	Mul				;HL = column * 12/2
 404+ 7341 D1           	pop		de
 405+ 7342 19           	add		hl, de
 406+ 7343
 407+ 7343 11 08 00     	ld		de, LST_FIRST_COL/2
 408+ 7346 ED 4B EF 73  	ld		bc, (CurrScrAttrAddr)
 409+ 734A 19           	add		hl, de
 410+ 734B 09           	add		hl, bc
 411+ 734C
 412+ 734C              	;clear old cursor
 413+ 734C 3E 45        	ld		a, SCR_DEF_CLR
 414+ 734E CD 17 73     	call	DrawCursor
 415+ 7351
 416+ 7351              	;draw new one
 417+ 7351 22 A7 7A     	ld		(CursorAddr), hl
 418+ 7354 3E 20        	ld		a, SCR_SEL_CLR
 419+ 7356 CD 17 73     	call	DrawCursor
 420+ 7359
 421+ 7359 C9           	ret
 422+ 735A
 423+ 735A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 424+ 735A
 425+ 735A              PrintChar:
 426+ 735A ED 5B B0 5C      ld		de, (LineCol)
 427+ 735E
 428+ 735E                  ;calculate 64 column screen address
 429+ 735E              	;IN: D = line, E = col
 430+ 735E              	;OUT: HL = screen address
 431+ 735E
 432+ 735E CB 3B            SRL     E                                       ;col = col/2
 433+ 7360 CB 19            RR      C                                       ;mark odd/even column
 434+ 7362 7A               LD      A, D                            ;A = line
 435+ 7363 E6 18            AND 24                                  ;keep only %00011000
 436+ 7365 2A ED 73         ld		hl, (CurrScrAddr)
 437+ 7368 B4               OR      h								;add screen start address
 438+ 7369 67               LD      H, A                            ;save H
 439+ 736A 7A               LD      A, D                            ;A = line
 440+ 736B E6 07            AND 7                                   ;keep only %00000111
 441+ 736D 0F               RRCA                                    ;%10000011
 442+ 736E 0F               RRCA                                    ;%11000001
 443+ 736F 0F               RRCA                                    ;%11100000
 444+ 7370 B3               OR      E                                       ;add column
 445+ 7371 6F               LD      L, A                            ;HL = screen address
 446+ 7372
 447+ 7372              PrintChar3:
 448+ 7372                  ;get font address
 449+ 7372 E5               PUSH HL
 450+ 7373 AF                   XOR A
 451+ 7374 67                   LD  H, A
 452+ 7375 3A 81 5C             LD  A, (CODE)
 453+ 7378 D6 20                SUB ' '
 454+ 737A 6F                   LD  L, A
 455+ 737B 29                   ADD     HL, HL                  ;char code = char code * 8
 456+ 737C 29                   ADD     HL, HL                  ;i.e. offset into font table
 457+ 737D 29                   ADD     HL, HL
 458+ 737E 11 63 85             LD      DE, FontTable             ;get font table
 459+ 7381 19                   ADD     HL, DE
 460+ 7382 EB                   EX      DE, HL                  ;DE = our char font address
 461+ 7383 E1               POP     HL
 462+ 7384
 463+ 7384
 464+ 7384                  ;print a char
 465+ 7384 06 08            LD      B, 8                            ;char height is 8 lines
 466+ 7386              PrintCharLine:
 467+ 7386 1A                   LD      A, (DE)                         ;load char line in A
 468+ 7387
 469+ 7387 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 470+ 7389 20 06                JR  	NZ, NoTurn
 471+ 738B
 472+ 738B 07                   RLCA
 473+ 738C 07                   RLCA
 474+ 738D 07                   RLCA
 475+ 738E 07                   RLCA
 476+ 738F 18 01                JR      Store
 477+ 7391              NoTurn:
 478+ 7391 B6                   OR (HL)
 479+ 7392              Store:
 480+ 7392 77                   LD (HL), A
 481+ 7393
 482+ 7393 13                   INC     DE                                      ;next char line in font table
 483+ 7394 24                   INC     H                                       ;next char line on screen
 484+ 7395 10 EF            DJNZ PrintCharLine                  ;last line of char?
 485+ 7397
 486+ 7397 C9               ret
 487+ 7398
 488+ 7398              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 489+ 7398
 490+ 7398              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 491+ 7398              ReadString:
 492+ 7398 21 CB 89     	ld		hl, FileData
 493+ 739B D5           	push	de
 494+ 739C DD E1        	pop		ix
 495+ 739E
 496+ 739E              ReadStringLoop:
 497+ 739E D5           	push	de
 498+ 739F E5           	push	hl
 499+ 73A0 CD DC 71     		call ReadChar
 500+ 73A3 E1           	pop		hl
 501+ 73A4 D1           	pop		de
 502+ 73A5
 503+ 73A5 FE 0D        	cp	KEY_ENTER
 504+ 73A7 C8           	ret z
 505+ 73A8
 506+ 73A8 FE 0C        	cp  KEY_BACKSP
 507+ 73AA 20 0F        	jr	nz, ReadStrChar
 508+ 73AC
 509+ 73AC E5           	push hl
 510+ 73AD 01 CC 89     	ld   bc, FileData+1
 511+ 73B0 ED 42        	sbc	 hl, bc
 512+ 73B2 E1           	pop  hl
 513+ 73B3 38 16        	jr   c, ReadStrPrint
 514+ 73B5
 515+ 73B5 1B           	dec	de
 516+ 73B6 2B           	dec	hl
 517+ 73B7 36 20        	ld	(hl), ' '
 518+ 73B9 18 10        	jr	ReadStrPrint
 519+ 73BB
 520+ 73BB              ReadStrChar:
 521+ 73BB FE 20        	cp	' '
 522+ 73BD 38 DF        	jr	c, ReadStringLoop
 523+ 73BF FE 7F        	cp  127
 524+ 73C1 30 DB        	jr	nc, ReadStringLoop
 525+ 73C3
 526+ 73C3              	;Check end of string and go back if found.
 527+ 73C3 46           	ld	b, (hl)
 528+ 73C4 CB 78        	bit 7, b
 529+ 73C6 20 03        	jr	nz, ReadStrPrint
 530+ 73C8
 531+ 73C8 77           	ld	(hl), a
 532+ 73C9 23           	inc	hl
 533+ 73CA 13           	inc	de
 534+ 73CB
 535+ 73CB              ReadStrPrint:
 536+ 73CB E5           	push	hl
 537+ 73CC D5           	push	de
 538+ 73CD 21 CB 89     	ld		hl, FileData
 539+ 73D0 DD E5        	push	ix
 540+ 73D2 D1           	pop		de
 541+ 73D3 CD 18 72     	call	PrintStr
 542+ 73D6 D1           	pop		de
 543+ 73D7 E1           	pop		hl
 544+ 73D8
 545+ 73D8 18 C4        	jr		ReadStringLoop
 546+ 73DA
 547+ 73DA              ClearNMsgLines:
 548+ 73DA 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 549+ 73DD              ClearNMsgLinesLoop:
 550+ 73DD D5           	push	de
 551+ 73DE C5           	push	bc
 552+ 73DF 21 8F 79     	ld		hl, MsgClear
 553+ 73E2 3E 45        	ld		a, SCR_DEF_CLR
 554+ 73E4 CD 40 72     	call	PrintStrClr
 555+ 73E7 C1           	pop		bc
 556+ 73E8 D1           	pop		de
 557+ 73E9 14           	inc		d
 558+ 73EA 10 F1        	djnz	ClearNMsgLinesLoop
 559+ 73EC
 560+ 73EC C9           	ret
 561+ 73ED
 562+ 73ED 00 40        CurrScrAddr		DEFW	SCR_ADDR
 563+ 73EF 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 564+ 73F1
 565+ 73F1                 	endif
# file closed: ui.asm
1249  73F1              	include "math.asm"
# file opened: math.asm
   1+ 73F1              	ifndef	_MATH_
   2+ 73F1 ~            	define	_MATH_
   3+ 73F1 ~
   4+ 73F1 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 73F1 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 73F1 ~
   7+ 73F1 ~
   8+ 73F1 ~            Word2Txt:
   9+ 73F1 ~            	IFUSED
  10+ 73F1 ~            	push	de
  11+ 73F1 ~            		call	Word2Txt_
  12+ 73F1 ~            	pop		de
  13+ 73F1 ~
  14+ 73F1 ~            	ld		b, 4
  15+ 73F1 ~            	call	StrippLeading0
  16+ 73F1 ~            	ret
  17+ 73F1 ~
  18+ 73F1 ~            Byte2Txt:
  19+ 73F1 ~            	push	de
  20+ 73F1 ~            		call	Byte2Txt_
  21+ 73F1 ~            	pop		de
  22+ 73F1 ~
  23+ 73F1 ~            	ld		b, 2
  24+ 73F1 ~            	call	StrippLeading0
  25+ 73F1 ~            	ret
  26+ 73F1 ~            	ENDIF
  27+ 73F1 ~
  28+ 73F1 ~
  29+ 73F1 ~            StrippLeading0:
  30+ 73F1 ~            	ld		a, (de)
  31+ 73F1 ~            	cp		'1'
  32+ 73F1 ~            	ret		nc
  33+ 73F1 ~
  34+ 73F1 ~            	ld		a, ' '
  35+ 73F1 ~            	ld		(de), a
  36+ 73F1 ~            	inc		de
  37+ 73F1 ~            	djnz	StrippLeading0
  38+ 73F1 ~            	ret
  39+ 73F1 ~
  40+ 73F1 ~
  41+ 73F1 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 73F1 ~            Word2Txt_:
  43+ 73F1 ~            	ld bc, -10000
  44+ 73F1 ~            	call DigitLoop
  45+ 73F1 ~            	ld bc, -1000
  46+ 73F1 ~            	call DigitLoop
  47+ 73F1 ~            Byte2Txt_:
  48+ 73F1 ~            	ld bc, -100
  49+ 73F1 ~            	call DigitLoop
  50+ 73F1 ~            	ld bc, -10
  51+ 73F1 ~            	call DigitLoop
  52+ 73F1 ~            	ld bc, -1
  53+ 73F1 ~
  54+ 73F1 ~            DigitLoop:
  55+ 73F1 ~            	ld	a, '0' - 1
  56+ 73F1 ~            DivNrLoop:
  57+ 73F1 ~            	inc	a			;increase reminder
  58+ 73F1 ~            	add	hl, bc		;substract divizor
  59+ 73F1 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 73F1 ~            	sbc	hl, bc		;nope, restore
  61+ 73F1 ~
  62+ 73F1 ~            	ld (de), a
  63+ 73F1 ~            	inc de
  64+ 73F1 ~            	ret
  65+ 73F1 ~
  66+ 73F1 ~
  67+ 73F1 ~            ;Input: HL = Dividend, C = Divisor
  68+ 73F1 ~            ;Output: HL = Quotient, A = Remainder
  69+ 73F1 ~            ;Warning: doesn't work with divisor >= $80
  70+ 73F1 ~            Div:
  71+ 73F1 ~            	IFUSED
  72+ 73F1 ~            	xor a
  73+ 73F1 ~            	ld b, 16
  74+ 73F1 ~
  75+ 73F1 ~            DivLoop:
  76+ 73F1 ~            	add	hl,hl
  77+ 73F1 ~            	rla
  78+ 73F1 ~            	cp	c
  79+ 73F1 ~            	jr	c, NoSub
  80+ 73F1 ~            	sub	c
  81+ 73F1 ~            	inc	l
  82+ 73F1 ~            NoSub:
  83+ 73F1 ~            	djnz DivLoop
  84+ 73F1 ~
  85+ 73F1 ~            	ret
  86+ 73F1 ~            	ENDIF
  87+ 73F1 ~
  88+ 73F1 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 73F1 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 73F1 ~            Div2:
  91+ 73F1 ~            	ld hl, 0
  92+ 73F1 ~            	ld b, 16
  93+ 73F1 ~            Div2Loop:
  94+ 73F1 ~            	sll c		; unroll 16 times
  95+ 73F1 ~            	rla			; ...
  96+ 73F1 ~            	adc	hl,hl		; ...
  97+ 73F1 ~            	sbc	hl,de		; ...
  98+ 73F1 ~            	jr	nc,$+4		; ...
  99+ 73F1 ~            	add	hl,de		; ...
 100+ 73F1 ~            	dec	c		; ...
 101+ 73F1 ~            	djnz Div2Loop
 102+ 73F1 ~            	ret
 103+ 73F1 ~
 104+ 73F1 ~
 105+ 73F1 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 73F1 ~            ;Output: A:HL = Product
 107+ 73F1 ~            Mul:
 108+ 73F1 ~            	IFUSED
 109+ 73F1 ~            	ld hl, 0
 110+ 73F1 ~            	ld bc, $0700
 111+ 73F1 ~
 112+ 73F1 ~            	add	a, a		; optimised 1st iteration
 113+ 73F1 ~            	jr	nc, MulLoop
 114+ 73F1 ~            	ld	h, d
 115+ 73F1 ~            	ld	l, e
 116+ 73F1 ~
 117+ 73F1 ~            MulLoop:
 118+ 73F1 ~            	add	hl,hl
 119+ 73F1 ~            	rla
 120+ 73F1 ~            	jr	nc, NoAdd
 121+ 73F1 ~            	add	hl,de
 122+ 73F1 ~            	adc	a,c
 123+ 73F1 ~            NoAdd:
 124+ 73F1 ~            	djnz MulLoop
 125+ 73F1 ~
 126+ 73F1 ~            	ret
 127+ 73F1 ~            	ENDIF
 128+ 73F1 ~
 129+ 73F1              	endif
# file closed: math.asm
1250  73F1              	include "txtview.asm"
# file opened: txtview.asm
   1+ 73F1              ; 	DEVICE ZXSPECTRUM48
   2+ 73F1
   3+ 73F1              LINE_CNT	EQU	23
   4+ 73F1              COL_CNT		EQU	64
   5+ 73F1
   6+ 73F1              CHAR_CR		EQU	$0D
   7+ 73F1              CHAR_LF		EQU	$0A
   8+ 73F1              CHAR_TAB	EQU	$09
   9+ 73F1              CHAR_EOF	EQU	$1A
  10+ 73F1
  11+ 73F1              COORDS		EQU	23728		;Coordinates
  12+ 73F1
  13+ 73F1
  14+ 73F1              InitViewer:
  15+ 73F1 22 3E 77     	ld		 (FileBegin), hl
  16+ 73F4 09           	add		hl, bc
  17+ 73F5              	;must filter any EOF chars.
  18+ 73F5 3E 1A        	ld		a, CHAR_EOF
  19+ 73F7 25           	dec		h
  20+ 73F8 25           	dec		h
  21+ 73F9 01 00 04     	ld		bc, SECT_SZ	* 4
  22+ 73FC ED B1        	cpir
  23+ 73FE 2B           	dec		hl
  24+ 73FF 22 42 77     	ld		(FileEnd), hl
  25+ 7402 ED 5B 3E 77  	ld		de, (FileBegin)
  26+ 7406 B7           	or		a
  27+ 7407 ED 52        	sbc		hl, de
  28+ 7409 22 40 77     	ld		(FileLen), hl
  29+ 740C
  30+ 740C 3E 0D        	ld		a, CHAR_CR
  31+ 740E 77           	ld		(hl), a
  32+ 740F
  33+ 740F
  34+ 740F 21 04 02     	ld		hl, (2 << 8) | 4
  35+ 7412 22 09 5C     	ld		(REPDEL), hl
  36+ 7415
  37+ 7415 21 00 00     	ld		hl, 0
  38+ 7418 22 B0 5C     	ld		(COORDS), hl
  39+ 741B
  40+ 741B 21 00 58     	ld		hl, SCR_ADDR + SCR_PIX_LEN
  41+ 741E 54           	ld		d, h
  42+ 741F 5D           	ld		e, l
  43+ 7420 13           	inc		de
  44+ 7421 01 FF 02     	ld		bc, 767
  45+ 7424 36 45        	ld		(hl), SCR_DEF_CLR
  46+ 7426 ED B0        	ldir
  47+ 7428
  48+ 7428 CD 43 76     	call	ScrollInit
  49+ 742B
  50+ 742B 11 00 00     	ld		de, 0
  51+ 742E ED 53 39 77  	ld		(CurLine), de
  52+ 7432
  53+ 7432              	;prepare file progress %
  54+ 7432 2A 40 77     	ld		hl, (FileLen)
  55+ 7435 7C           	ld		a, h
  56+ 7436 4D           	ld		c, l
  57+ 7437 11 64 00     	ld		de, 100
  58+ 743A CD DC 69     	call	Div2
  59+ 743D 67           	ld		h, a
  60+ 743E 69           	ld		l, c
  61+ 743F 22 44 77     	ld		(PROGR_PERC), hl
  62+ 7442
  63+ 7442 CD D2 75     	call	PrintMsg
  64+ 7445
  65+ 7445 DD 21 C9 F3  	ld		ix, FileIdx	- 2
  66+ 7449 06 17        	ld		b, LINE_CNT
  67+ 744B 2A 3E 77     	ld		hl, (FileBegin)
  68+ 744E
  69+ 744E C9           	ret
  70+ 744F
  71+ 744F
  72+ 744F              PrintLoop:
  73+ 744F C5           	push	bc
  74+ 7450 DD 23        		inc		ix
  75+ 7452 DD 23        		inc		ix
  76+ 7454 DD 75 00     		ld		(ix), l
  77+ 7457 DD 74 01     		ld		(ix + 1), h
  78+ 745A
  79+ 745A CD 70 75     		call	GetLine
  80+ 745D CD 42 75     		call	PrintLine
  81+ 7460
  82+ 7460 ED 5B 39 77  		ld		de, (CurLine)
  83+ 7464 13           		inc		de
  84+ 7465 ED 53 39 77  		ld		(CurLine), de
  85+ 7469 C1           	pop		bc
  86+ 746A CD 37 75     	call	CheckEnd
  87+ 746D 38 13        	jr		c, ViewFileEOF
  88+ 746F
  89+ 746F 10 DE        	djnz	PrintLoop
  90+ 7471 18 17        	jr		PrintLoop2
  91+ 7473
  92+ 7473              GetKey:
  93+ 7473 76           	halt
  94+ 7474 FD CB 01 6E  	bit		5, (iy + 1);
  95+ 7478 28 F9        	jr		z, GetKey
  96+ 747A FD CB 01 AE  	res		5, (iy + 1)
  97+ 747E FD 7E CE     	ld		a, (iy - $32)
  98+ 7481 C9           	ret
  99+ 7482
 100+ 7482              ViewFileEOF:
 101+ 7482 CD 73 74     	call	GetKey
 102+ 7485 FE 30        	cp		'0'
 103+ 7487 20 F9        	jr		nz, ViewFileEOF
 104+ 7489 C9           	ret
 105+ 748A
 106+ 748A              PrintLoop2:
 107+ 748A CD D2 75     	call	PrintMsg
 108+ 748D
 109+ 748D CD 73 74     	call	GetKey
 110+ 7490 FE 30        	cp		'0'					;Exit on 0
 111+ 7492 C8           	ret		z
 112+ 7493
 113+ 7493 FE 0A        	cp		KEY_DOWN
 114+ 7495 28 5C        	jr		z, Down
 115+ 7497
 116+ 7497 FE 0B        	cp		KEY_UP
 117+ 7499 28 2D        	jr		z, Up
 118+ 749B
 119+ 749B FE 32        	cp		'2'
 120+ 749D 20 EB        	jr		nz, PrintLoop2
 121+ 749F
 122+ 749F 3A 3D 77     	ld		a, (WrapFlag)
 123+ 74A2 EE 01        	xor		1
 124+ 74A4 32 3D 77     	ld		(WrapFlag), a
 125+ 74A7 B7           	or		a
 126+ 74A8 28 0F        	jr		z, NoWrap
 127+ 74AA
 128+ 74AA 11 4F 6E     	ld		de, 'nO'
 129+ 74AD ED 53 EE 76  	ld		(MsgLineWrF), de
 130+ 74B1 3E 20        	ld		a, ' '
 131+ 74B3 32 F0 76     	ld		(MsgLineWrF + 2), a
 132+ 74B6 C3 8A 74     	jp		PrintLoop2
 133+ 74B9
 134+ 74B9              NoWrap:
 135+ 74B9 11 4F 66     	ld		de, 'fO'
 136+ 74BC ED 53 EE 76  	ld		(MsgLineWrF), de
 137+ 74C0 3E 66        	ld		a, 'f'
 138+ 74C2 32 F0 76     	ld		(MsgLineWrF + 2), a
 139+ 74C5
 140+ 74C5 C3 8A 74     	jp		PrintLoop2
 141+ 74C8
 142+ 74C8
 143+ 74C8              Up:
 144+ 74C8 CD 27 75     	call	CheckBegin
 145+ 74CB 28 BD        	jr		z, PrintLoop2
 146+ 74CD
 147+ 74CD CD 71 76     	call	ScrollUp
 148+ 74D0
 149+ 74D0 DD 2B        	dec		ix
 150+ 74D2 DD 2B        	dec		ix
 151+ 74D4 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 152+ 74D7 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 153+ 74DA CD 70 75     	call	GetLine						;extract previous line to display
 154+ 74DD
 155+ 74DD 11 00 00     	ld		de, 0
 156+ 74E0 ED 53 B0 5C  	ld		(COORDS), de
 157+ 74E4 CD 42 75     	call	PrintLine
 158+ 74E7
 159+ 74E7 2A 39 77     	ld		hl, (CurLine)
 160+ 74EA 2B           	dec		hl
 161+ 74EB 22 39 77     	ld		(CurLine), hl
 162+ 74EE CD D2 75     	call	PrintMsg
 163+ 74F1 18 97        	jr		PrintLoop2
 164+ 74F3
 165+ 74F3
 166+ 74F3              Down:
 167+ 74F3 DD 6E 00     	ld		l, (ix)
 168+ 74F6 DD 66 01     	ld		h, (ix + 1)
 169+ 74F9 CD 70 75     	call	GetLine						;get next line pointer
 170+ 74FC
 171+ 74FC CD 37 75     	call	CheckEnd					;check if HL == file end
 172+ 74FF D8           	ret		c
 173+ 7500
 174+ 7500 DD 23        	inc		ix								;save next line pointer
 175+ 7502 DD 23        	inc		ix
 176+ 7504 DD 75 00     	ld		(ix), l
 177+ 7507 DD 74 01     	ld		(ix + 1), h
 178+ 750A
 179+ 750A CD 70 75     	call	GetLine						;extract next line in buffer for display
 180+ 750D
 181+ 750D CD 76 76     	call	ScrollDown
 182+ 7510
 183+ 7510 11 00 16     	ld		de, (LINE_CNT-1) << 8
 184+ 7513 ED 53 B0 5C  	ld		(COORDS), de
 185+ 7517 CD 42 75     	call	PrintLine
 186+ 751A
 187+ 751A 2A 39 77     	ld		hl, (CurLine)
 188+ 751D 23           	inc		hl
 189+ 751E 22 39 77     	ld		(CurLine), hl
 190+ 7521 CD D2 75     	call	PrintMsg
 191+ 7524
 192+ 7524 C3 8A 74     	jp		PrintLoop2
 193+ 7527
 194+ 7527
 195+ 7527              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 196+ 7527              ;check begining of buffer
 197+ 7527              CheckBegin:
 198+ 7527 E5           	push	hl
 199+ 7528 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 200+ 752B DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 201+ 752E ED 5B 3E 77  		ld		de, (FileBegin)
 202+ 7532 B7           		or		a
 203+ 7533 ED 52        		sbc		hl, de
 204+ 7535 E1           	pop		hl
 205+ 7536 C9           	ret
 206+ 7537
 207+ 7537              ;check end of buffer
 208+ 7537              CheckEnd:
 209+ 7537 E5           	push	hl
 210+ 7538 ED 5B 42 77  		ld		de, (FileEnd)
 211+ 753C EB           		ex		de, hl
 212+ 753D B7           		or		a
 213+ 753E ED 52        		sbc		hl, de
 214+ 7540 E1           	pop		hl
 215+ 7541 C9           	ret
 216+ 7542
 217+ 7542              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 7542              ;Print a line
 219+ 7542              PrintLine:
 220+ 7542 11 F9 76     	ld		de, LineBuf
 221+ 7545 06 40        	ld		b, COL_CNT
 222+ 7547
 223+ 7547 CD 56 75     	call	PrintStrTxt
 224+ 754A
 225+ 754A              	;go to the next screen line
 226+ 754A ED 5B B0 5C  	ld		de, (COORDS)
 227+ 754E 14           	inc		d
 228+ 754F 1E 00        	ld		e, 0
 229+ 7551 ED 53 B0 5C  	ld		(COORDS), de
 230+ 7555 C9           	ret
 231+ 7556
 232+ 7556              PrintStrTxt:
 233+ 7556 1A           	ld		a, (de)
 234+ 7557 13           	inc		de
 235+ 7558 D5           	push	de
 236+ 7559 32 81 5C     		ld		(CODE), a
 237+ 755C C5           		push	bc
 238+ 755D E5           			push	hl
 239+ 755E CD 5A 73     				call	PrintChar
 240+ 7561 E1           			pop		hl
 241+ 7562 C1           		pop		bc
 242+ 7563
 243+ 7563 ED 5B B0 5C  		ld		de, (COORDS)
 244+ 7567 1C           		inc		e
 245+ 7568 ED 53 B0 5C  		ld		(COORDS), de
 246+ 756C D1           	pop		de
 247+ 756D 10 E7        	djnz	PrintStrTxt
 248+ 756F C9           	ret
 249+ 7570
 250+ 7570              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 251+ 7570              ;Extract a line of text to fit exactly on a 64 screen line
 252+ 7570              ;IN:	HL = current file pointer
 253+ 7570              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 254+ 7570              GetLine:
 255+ 7570 11 F9 76     	ld		de, LineBuf
 256+ 7573 06 40        	ld		b, COL_CNT
 257+ 7575              GetLineLoop:
 258+ 7575 7E           	ld		a, (hl)
 259+ 7576 23           	inc		hl
 260+ 7577
 261+ 7577 FE 0D        	cp		CHAR_CR
 262+ 7579 28 2F        	jr		z, GetLineSkip0A
 263+ 757B
 264+ 757B FE 0A        	cp		CHAR_LF
 265+ 757D 28 2B        	jr		z, GetLineSkip0A
 266+ 757F
 267+ 757F FE 09        	cp		CHAR_TAB
 268+ 7581 28 06        	jr		z, GetLineTab
 269+ 7583
 270+ 7583 FE 1A        	cp		CHAR_EOF
 271+ 7585 28 44        	jr		z, GetLineFillLoop
 272+ 7587
 273+ 7587 18 07        	jr		GetLineNext
 274+ 7589
 275+ 7589              GetLineTab:
 276+ 7589              	;1 space tab
 277+ 7589 3E 20        	ld		a, ' '
 278+ 758B 12           	ld		(de), a
 279+ 758C 13           	inc		de
 280+ 758D 05           	dec		b
 281+ 758E 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 282+ 7590
 283+ 7590              GetLineNext:
 284+ 7590 FE 20        	cp		' '
 285+ 7592 38 06        	jr		c, NotValid
 286+ 7594
 287+ 7594 FE 80        	cp		128
 288+ 7596 30 02        	jr		nc, NotValid
 289+ 7598 18 03        	jr		Valid
 290+ 759A
 291+ 759A              NotValid:
 292+ 759A CD 21 76     	call	ReplaceChars
 293+ 759D
 294+ 759D              Valid:
 295+ 759D 12           	ld		(de), a
 296+ 759E 13           	inc		de
 297+ 759F 10 D4        	djnz	GetLineLoop
 298+ 75A1
 299+ 75A1              ;if line is exactly 64 char long, must skip the new line char(s)
 300+ 75A1              GetLineSkip0D:
 301+ 75A1 0E 00        	ld		c, 0
 302+ 75A3 3E 0D        	ld		a, CHAR_CR						;skip 0D
 303+ 75A5 BE           	cp		(hl)
 304+ 75A6 20 02        	jr		nz, GetLineSkip0A
 305+ 75A8 23           	inc		hl
 306+ 75A9 0C           	inc		c
 307+ 75AA
 308+ 75AA              GetLineSkip0A:						;skip 0A
 309+ 75AA 3E 0A        	ld		a, CHAR_LF
 310+ 75AC BE           	cp		(hl)
 311+ 75AD 20 02        	jr		nz, GetLineFill
 312+ 75AF 23           	inc		hl
 313+ 75B0 0C           	inc		c
 314+ 75B1
 315+ 75B1              GetLineFill:
 316+ 75B1 78           	ld		a, b
 317+ 75B2 B7           	or		a
 318+ 75B3 20 16        	jr		nz, GetLineFillLoop
 319+ 75B5
 320+ 75B5 79           	ld		a, c
 321+ 75B6 B7           	or		a
 322+ 75B7 C0           	ret		nz
 323+ 75B8
 324+ 75B8              	;wrap or not
 325+ 75B8 3A 3D 77     	ld		a, (WrapFlag)
 326+ 75BB B7           	or		a
 327+ 75BC C0           	ret		nz
 328+ 75BD
 329+ 75BD ~            	/*
 330+ 75BD ~            	ld		de, (FileEnd)
 331+ 75BD ~            	push	hl
 332+ 75BD ~            		ex		de, hl
 333+ 75BD ~            		or		a
 334+ 75BD ~            		sbc		hl, de
 335+ 75BD ~            		ld		b, h
 336+ 75BD ~            		ld		c, l
 337+ 75BD ~            	pop		hl
 338+ 75BD ~            	*/
 339+ 75BD
 340+ 75BD 3E 0D        	ld		a, CHAR_CR
 341+ 75BF 01 40 00     	ld		bc, COL_CNT
 342+ 75C2 ED B1        	cpir
 343+ 75C4 C0           	ret		nz
 344+ 75C5 3E 0A        	ld		a, CHAR_LF
 345+ 75C7 BE           	cp		(hl)
 346+ 75C8 C0           	ret		nz
 347+ 75C9 23           	inc		hl
 348+ 75CA
 349+ 75CA C9           	ret
 350+ 75CB
 351+ 75CB              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 352+ 75CB 3E 20        	ld		a, ' '
 353+ 75CD 12           	ld		(de), a
 354+ 75CE 13           	inc		de
 355+ 75CF 10 FA        	djnz	GetLineFillLoop
 356+ 75D1 C9           	ret
 357+ 75D2
 358+ 75D2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 359+ 75D2              PrintMsg:
 360+ 75D2 ED 5B B0 5C  	ld		de, (COORDS)
 361+ 75D6 D5           	push	de
 362+ 75D7 11 00 17     	ld		de, LINE_CNT<<8
 363+ 75DA ED 53 B0 5C  	ld		(COORDS), de
 364+ 75DE
 365+ 75DE              	;Get current file pointer
 366+ 75DE DD 6E 00     	ld		l, (ix)
 367+ 75E1 DD 66 01     	ld		h, (ix + 1)
 368+ 75E4 ED 4B 3E 77  	ld		bc, (FileBegin)
 369+ 75E8 B7           	or		a
 370+ 75E9 ED 42        	sbc		hl, bc
 371+ 75EB
 372+ 75EB              	;Divide by one percent length
 373+ 75EB 7C           	ld		a, h
 374+ 75EC 4D           	ld		c, l
 375+ 75ED ED 5B 44 77  	ld		de, (PROGR_PERC)
 376+ 75F1 CD DC 69     	call	Div2
 377+ 75F4
 378+ 75F4              	;Display %
 379+ 75F4 11 D4 76     	ld		de, MsgLinePr
 380+ 75F7 67           	ld		h, a
 381+ 75F8 69           	ld		l, c
 382+ 75F9 CD 93 69     	call	Byte2Txt
 383+ 75FC
 384+ 75FC
 385+ 75FC 2A 39 77     	ld		hl, (CurLine)
 386+ 75FF 11 E0 76     	ld		de, MsgLineNo
 387+ 7602 CD 88 69     	call	Word2Txt
 388+ 7605
 389+ 7605 11 CB 76     	ld		de, MsgLine
 390+ 7608 06 2E        	ld		b, MsgLineLen
 391+ 760A CD 56 75     	call	PrintStrTxt
 392+ 760D D1           	pop		de
 393+ 760E ED 53 B0 5C  	ld		(COORDS), DE
 394+ 7612
 395+ 7612 21 E0 5A     	ld		hl, SCR_ADDR + SCR_PIX_LEN + LINE_CNT*32
 396+ 7615 54           	ld		d, h
 397+ 7616 5D           	ld		e, l
 398+ 7617 13           	inc		de
 399+ 7618 3E 20        	ld		a, SCR_LBL_CLR
 400+ 761A 77           	ld		(hl), a
 401+ 761B 01 1F 00     	ld		bc, SCR_BYTES_PER_LINE-1
 402+ 761E ED B0        	ldir
 403+ 7620 C9           	ret
 404+ 7621
 405+ 7621
 406+ 7621              ReplaceChars:
 407+ 7621 E5           	push	hl
 408+ 7622 C5           	push	bc
 409+ 7623 21 B1 76     		ld		hl, CharReplaceTbl
 410+ 7626 06 0D        		ld		b, CharReplTblLen
 411+ 7628              ReplaceSGCLoop:
 412+ 7628 BE           		cp		(hl)
 413+ 7629 28 09        		jr		z, ReplaceMatch
 414+ 762B 23           		inc		hl
 415+ 762C 23           		inc		hl
 416+ 762D 10 F9        		djnz	ReplaceSGCLoop
 417+ 762F
 418+ 762F 3E 3F        		ld		a, '?'
 419+ 7631 C1           		pop		bc
 420+ 7632 E1           		pop		hl
 421+ 7633 C9           	ret
 422+ 7634
 423+ 7634              ReplaceMatch:
 424+ 7634 23           		inc		hl
 425+ 7635 7E           		ld		a, (hl)
 426+ 7636 C1           	pop		bc
 427+ 7637 E1           	pop		hl
 428+ 7638 C9           	ret
 429+ 7639              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 430+ 7639
 431+ 7639              	include	"scroll.asm"
# file opened: scroll.asm
   1++7639              ;Scrolling routines for UP/DOWN
   2++7639              ;They use 2 tables of pointers of screen cell rows.
   3++7639              ;One table has addresses in increasing order, for scroll down,
   4++7639              ;the other in decreasing order, for scroll up, so the same
   5++7639              ;scroll routine is used in both cases.
   6++7639              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++7639
   8++7639              ; Char Down
   9++7639              ; Adjusts screen address HL to move eight pixels down on the display.
  10++7639              ; enter: HL = valid screen address
  11++7639              ; exit : HL = moves one character down
  12++7639              ; used : AF, HL
  13++7639              GetCellDown:
  14++7639 7D           	ld a,l
  15++763A C6 20        	add a,$20
  16++763C 6F           	ld l,a
  17++763D D0           	ret nc
  18++763E 7C           	ld a,h
  19++763F C6 08        	add a,$08
  20++7641 67           	ld h,a
  21++7642 C9           	ret
  22++7643
  23++7643              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++7643              ;Fills the two tables with pointers.
  25++7643              ScrollInit:
  26++7643 21 00 40     	ld		hl, SCR_ADDR
  27++7646 06 17        	ld		b, LINE_CNT
  28++7648              FillScrLinesLoop:
  29++7648              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++7648 22 00 5B     	ld		(SCRLinesDown), hl
  31++764B              	;inc. pointer in destination table (of pointers to lines)
  32++764B ED 5B 49 76  	ld		de, (FillScrLinesPtr)
  33++764F 13           	inc		de
  34++7650 13           	inc		de
  35++7651 ED 53 49 76  	ld		(FillScrLinesPtr), de
  36++7655 CD 39 76     	call	GetCellDown
  37++7658 10 EE        	djnz	FillScrLinesLoop
  38++765A
  39++765A              	;now fill the table in reverse
  40++765A ED 73 6E 76  	ld		(FillScrLinesSPStore), sp
  41++765E 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++7661 06 17        	ld		b, LINE_CNT
  43++7663 21 00 5B     	ld		hl, SCRLinesDown
  44++7666              FillScrLinesRev:
  45++7666 5E           	ld		e, (hl)
  46++7667 23           	inc		hl
  47++7668 56           	ld		d, (hl)
  48++7669 23           	inc		hl
  49++766A D5           	push	de
  50++766B 10 F9        	djnz	FillScrLinesRev
  51++766D              FillScrLinesSPStore	EQU	$ + 1
  52++766D 31 00 00     	ld		sp, 0
  53++7670 C9           	ret
  54++7671
  55++7671              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++7671              ScrollUp:
  57++7671 21 2E 5B     	ld		hl, SCRLinesUp
  58++7674 18 03        	jr		Scroll
  59++7676
  60++7676              ScrollDown:
  61++7676 21 00 5B     	ld		hl, SCRLinesDown
  62++7679
  63++7679              Scroll:
  64++7679 22 87 76     	ld		(ScrollDownPtrDest), hl
  65++767C 23           	inc		hl
  66++767D 23           	inc		hl
  67++767E 22 8A 76     	ld		(ScrollDownPtrSrc), hl
  68++7681 0E 16        	ld		c, LINE_CNT - 1
  69++7683
  70++7683              ScrollDownLoop2:
  71++7683 06 04        	ld		b, 4
  72++7685              ScrollDownPtrDest	EQU	$ + 2
  73++7685 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++7689              ScrollDownPtrSrc	EQU	$ + 1
  75++7689 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++768C
  77++768C              ScrollDownLoop:					;copy a single char line
  78++768C C5           	push	bc
  79++768D 01 20 00     	ld		bc, 32
  80++7690 ED B0        	ldir
  81++7692 2B           	dec		hl
  82++7693 1B           	dec		de
  83++7694 24           	inc		h
  84++7695 14           	inc		d
  85++7696 01 20 00     	ld		bc, 32
  86++7699 ED B8        	lddr
  87++769B 23           	inc		hl
  88++769C 13           	inc		de
  89++769D 24           	inc		h
  90++769E 14           	inc		d
  91++769F C1           	pop		bc
  92++76A0 10 EA        	djnz	ScrollDownLoop
  93++76A2
  94++76A2 0D           	dec		c
  95++76A3 C8           	ret		z
  96++76A4
  97++76A4 2A 8A 76     	ld		hl, (ScrollDownPtrSrc)
  98++76A7 22 87 76     	ld		(ScrollDownPtrDest), hl
  99++76AA 23           	inc		hl
 100++76AB 23           	inc		hl
 101++76AC 22 8A 76     	ld		(ScrollDownPtrSrc), hl
 102++76AF 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 432+ 76B1
 433+ 76B1              CharReplaceTbl:
 434+ 76B1 B3 80        	defb	179, 128
 435+ 76B3 B4 81        	defb	180, 129
 436+ 76B5 BF 82        	defb	191, 130
 437+ 76B7 C0 83        	defb	192, 131
 438+ 76B9 C1 84        	defb	193, 132
 439+ 76BB C2 85        	defb	194, 133
 440+ 76BD C3 86        	defb	195, 134
 441+ 76BF C4 87        	defb	196, 135
 442+ 76C1 C5 88        	defb	197, 136
 443+ 76C3 D9 89        	defb	217, 137
 444+ 76C5 DA 8A        	defb	218, 138
 445+ 76C7 DB 8B        	defb	219, 139
 446+ 76C9 DC 8C        	defb	220, 140
 447+ 76CB              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 448+ 76CB
 449+ 76CB 50 72 6F 67  MsgLine		defb	'Progress:'
 449+ 76CF 72 65 73 73
 449+ 76D3 3A
 450+ 76D4 20 20 20 25  MsgLinePr	defb	'   %; '
 450+ 76D8 3B 20
 451+ 76DA 4C 69 6E 65  			defb	'Line: '
 451+ 76DE 3A 20
 452+ 76E0 20 20 20 20  MsgLineNo	defb	'     ; '
 452+ 76E4 20 3B 20
 453+ 76E7 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 453+ 76EB 61 70 20
 454+ 76EE 20 4F 6E     MsgLineWrF	defb	' On'
 455+ 76F1 3B 20 30 2D  			defb	'; 0-Exit'
 455+ 76F5 45 78 69 74
 456+ 76F9              MsgLineLen	EQU		$ - MsgLine
 457+ 76F9
 458+ 76F9 20 20 20 20  LineBuf		defb	'                                                                '
 458+ 76FD 20 20 20 20
 458+ 7701 20 20 20 20
 458+ 7705 20 20 20 20
 458+ 7709 20 20 20 20
 458+ 770D 20 20 20 20
 458+ 7711 20 20 20 20
 458+ 7715 20 20 20 20
 458+ 7719 20 20 20 20
 458+ 771D 20 20 20 20
 458+ 7721 20 20 20 20
 458+ 7725 20 20 20 20
 458+ 7729 20 20 20 20
 458+ 772D 20 20 20 20
 458+ 7731 20 20 20 20
 458+ 7735 20 20 20 20
 459+ 7739 00 00        CurLine		defw	0
 460+ 773B 00 00        MaxLine		defw	0
 461+ 773D 01           WrapFlag	defb	1
 462+ 773E 00 00        FileBegin	defw	0
 463+ 7740 00 00        FileLen		defw	0
 464+ 7742 00 00        FileEnd		defw	0
 465+ 7744 00 00        PROGR_PERC	defw	0
 466+ 7746
 467+ 7746              SCRLinesDown	EQU PRN_BUF
 468+ 7746              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 469+ 7746              End:
 470+ 7746
# file closed: txtview.asm
1251  7746              	include "serial.asm"
# file opened: serial.asm
   1+ 7746              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7746              ;They work with 19200 theoretical speed.
   3+ 7746              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7746
   5+ 7746              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7746              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7746
   8+ 7746
   9+ 7746              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7746              ; A=1 IF FRAMING ERROR
  11+ 7746              ; USES BC,D _DOES NOT USE E!_
  12+ 7746              SERRXI:
  12+ 7746
  13+ 7746 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7749 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 774B D3 EF        	OUT	(0EFH),A
  16+ 774D
  17+ 774D              	; WAIT FOR START
  18+ 774D              SERWSL:
  19+ 774D 0B           	DEC	BC
  20+ 774E AF           	XOR	A
  21+ 774F B8           	CP	B
  22+ 7750 20 03        	JR	NZ,SERWS
  23+ 7752 B9           	CP	C
  24+ 7753 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7755 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7757 CB 7F        	BIT	7,A
  27+ 7759 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 775B
  29+ 775B              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 775B              ; OF BIT 0
  31+ 775B 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 775D 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 775F
  34+ 775F              ; GET AND SHIFT BITS
  35+ 775F              SERRL:
  36+ 775F 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7761 00           	NOP			; 4 (TIMING)
  38+ 7762 00           	NOP			; 4 (TIMING)
  39+ 7763 00           	NOP			; 4 (TIMING)
  40+ 7764 DB F7        	IN	A,(0F7H)	; 11
  41+ 7766 17           	RLA			; 4
  42+ 7767 CB 1A        	RR	D		; 8
  43+ 7769 06 0A        	LD	B,CBAUD		; 7
  44+ 776B 0D           	DEC	C		; 4
  45+ 776C 20 F1        	JR	NZ,SERRL	; 12
  46+ 776E
  47+ 776E              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 776E              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 776E              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 776E              ; IDLE UNTIL NEXT START BIT
  51+ 776E 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7770 D3 EF        	OUT	(0EFH),A
  53+ 7772
  54+ 7772 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7774              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7774              SERWIL:
  57+ 7774 05           	DEC	B
  58+ 7775 28 0E        	JR	Z,SERRTF
  59+ 7777 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7779 CB 7F        	BIT	7,A
  61+ 777B 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 777D
  63+ 777D              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 777D 7A           	LD	A,D
  65+ 777E 2F           	CPL			; INVERT BITS
  66+ 777F 57           	LD	D,A
  67+ 7780 AF           	XOR	A		; 0 = SUCCESS
  68+ 7781 C9           	RET
  69+ 7782
  70+ 7782              ; TIMEOUT
  71+ 7782              SERRTO:
  72+ 7782 3E FF        	LD	A,0FFH
  73+ 7784 C9           	RET
  74+ 7785
  75+ 7785              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7785              SERRTF:
  77+ 7785 3E 01        	LD	A,01H
  78+ 7787 C9           	RET
  79+ 7788
  80+ 7788
  81+ 7788
  82+ 7788              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7788              SERRB:
  83+ 7788
  84+ 7788              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7788              ; BITMAPPED OPTIONS IN E:
  86+ 7788              ; XXXXXXIT
  87+ 7788              ; I SET = leave Interrupts disabled at exit
  88+ 7788              ; T SET = return after Timeout
  89+ 7788              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7788              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7788              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7788 F3           	DI
  93+ 7789 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 778A              				; OF RECEIVED BYTES
  95+ 778A
  96+ 778A              SERRBL:
  97+ 778A C5           	PUSH	BC
  98+ 778B CD 46 77     	CALL	SERRXI
  99+ 778E C1           	POP	BC
 100+ 778F B7           	OR	A
 101+ 7790 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7792 72           	LD	(HL),D
 103+ 7793 23           	INC	HL
 104+ 7794 0B           	DEC	BC
 105+ 7795 AF           	XOR	A
 106+ 7796 B8           	CP	B
 107+ 7797 20 F1        	JR	NZ,SERRBL
 108+ 7799 B9           	CP	C
 109+ 779A 20 EE        	JR	NZ,SERRBL
 110+ 779C              ; FULL RECEIVE
 111+ 779C C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 779D
 113+ 779D              SERRBX:				; EXIT
 114+ 779D CB 4B        	BIT	1,E
 115+ 779F C0           	RET	NZ
 116+ 77A0 FB           	EI
 117+ 77A1 C9           	RET
 118+ 77A2
 119+ 77A2              SERRBT:
 120+ 77A2 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 77A4 28 04        	JR	Z,SERRBC
 122+ 77A6 CB 43        	BIT	0,E
 123+ 77A8 28 E0        	JR	Z,SERRBL
 124+ 77AA
 125+ 77AA              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 77AA EB           	EX	DE,HL		; PRESERVE HL
 127+ 77AB E1           	POP	HL		; GET INITIAL COUNT
 128+ 77AC 37           	SCF
 129+ 77AD 3F           	CCF
 130+ 77AE ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 77B0 44           	LD	B,H
 132+ 77B1 4D           	LD	C,L		; BC = COUNT
 133+ 77B2 EB           	EX	DE,HL		; RESTORE HL
 134+ 77B3
 135+ 77B3 18 E8        	JR	SERRBX
 136+ 77B5
 137+ 77B5              SERRX:
 137+ 77B5
 138+ 77B5              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 77B5              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 77B5              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 77B5 F3           	DI
 142+ 77B6 CD 46 77     	CALL	SERRXI
 143+ 77B9 FB           	EI
 144+ 77BA C9           	RET
 145+ 77BB
 146+ 77BB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 77BB              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 77BB              SERTB:
 148+ 77BB
 149+ 77BB 7E           	LD	A,(HL)
 150+ 77BC C5           	PUSH	BC
 151+ 77BD CD C8 77     		CALL	SERTX
 152+ 77C0 C1           	POP	BC
 153+ 77C1 23           	INC	HL
 154+ 77C2 0B           	DEC BC
 155+ 77C3 78           	LD	A, B
 156+ 77C4 B1           	OR	C
 157+ 77C5 20 F4        	JR	NZ, SERTB
 158+ 77C7 C9           	RET
 159+ 77C8
 160+ 77C8              ; SEND CHAR ROUTINE
 161+ 77C8              SERTX:
 161+ 77C8
 162+ 77C8 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 77C9 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 77CA F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 77CB 3E 01        	LD	A,01H
 166+ 77CD D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 77CF 1E 20        	LD	E,20H	; PORT MASK
 168+ 77D1 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 77D3 3E 01        	LD	A,1
 170+ 77D5 C3 DC 77     	JP	SBIT
 171+ 77D8
 172+ 77D8 AF           SHLOOP:	XOR	A		; 4
 173+ 77D9 CB 3A        	SRL	D		; 8
 174+ 77DB 17           	RLA			; 4
 175+ 77DC              SBIT:
 176+ 77DC B3           	OR	E		; 4
 177+ 77DD D3 EF        	OUT	(0EFH),A	; 11
 178+ 77DF 06 0A        	LD	B,CBAUD		; 7
 179+ 77E1              SBITDL:
 180+ 77E1 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 77E3 00           	NOP			; 4 (TIMING)
 182+ 77E4 0D           	DEC	C		; 4
 183+ 77E5 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 77E7              ; STOP BIT
 185+ 77E7 3E 20        	LD	A,20H
 186+ 77E9 D3 EF        	OUT	(0EFH),A
 187+ 77EB 06 0A        	LD	B,CBAUD
 188+ 77ED 10 FE        STOPL:	DJNZ	STOPL
 189+ 77EF FB           	EI
 190+ 77F0 C9           	RET
# file closed: serial.asm
1252  77F1
1253  77F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1254  77F1 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-06-21"
1254  77F5 64 20 32 30
1254  77F9 32 33 2D 30
1254  77FD 36 2D 32 31
1255  7801 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1255  7805 67 65 20 43
1255  7809 68 69 72 74
1255  780D 6F 61 63 E1
1256  7811 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1256  7815 72 61 6D 20
1256  7819 49 6E 66 6F
1256  781D 20 20 20 A0
1257  7821 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1257  7825 20 49 6E 66
1257  7829 6F 20 20 20
1257  782D 20 20 20 A0
1258  7831 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1258  7835 20 49 6E 66
1258  7839 6F 20 20 20
1258  783D 20 20 20 A0
1259  7841 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1259  7845 61 67 65 73
1259  7849 20 20 20 20
1259  784D 20 20 20 A0
1260  7851 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1260  7855 20 32 2D 42
1260  7859 3A 20 33 2D
1260  785D 56 69 65 77
1260  7861 20 34 2D 50
1260  7865 72 6F 70 20
1260  7869 35 2D 43 6F
1260  786D 70 79 20 36
1260  7871 2D 52 65 6E
1260  7875 20 37 2D 41
1260  7879 74 74 72 20
1260  787D 38 2D 44 65
1260  7881 6C 20 39 2D
1260  7885 44 69 73 6B
1260  7889 20 30 2D 45
1260  788D 78 69 F4
1261  7890 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1261  7894 65 20 20 20
1261  7898 3A 20 20 20
1261  789C 20 20 20
1262  789F C1           MsgDriveLet		DEFM	'A' | $80
1263  78A0 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1263  78A4 73 20 20 20
1263  78A8 3A
1264  78A9 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1264  78AD 31 32 B8
1265  78B0 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1265  78B4 20 4B 42 20
1265  78B8 3A
1266  78B9 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1266  78BD 36 33 B6
1267  78C0 45 72 72 6F  MsgErr			DEFM	'Error code '
1267  78C4 72 20 63 6F
1267  78C8 64 65 20
1268  78CB 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1269  78CF 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1269  78D3 69 6E 67 20
1269  78D7 50 72 6F 67
1269  78DB 72 61 ED
1270  78DE 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1270  78E2 69 6E 67 20
1270  78E6 53 43 52 45
1270  78EA 45 4E A4
1271  78ED 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1271  78F1 69 6E 67 20
1271  78F5 43 4F 44 45
1271  78F9 20 28 21 A9
1272  78FD 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1272  7901 20 4C 65 6E
1272  7905 3A
1273  7906 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1273  790A 30 20 CB
1274  790D 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1274  7911 69 62 20 20
1274  7915 3A
1275  7916 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1275  791A 48 49 C4
1276  791D 54 79 70 65  MsgFileType		DEFM	'Type    :'
1276  7921 20 20 20 20
1276  7925 3A
1277  7926 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1277  792A 20 20 20 20
1277  792E 20 A0
1278  7930 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1278  7934 72 61 ED
1279  7937 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1279  793B 73 20 A0
1280  793E 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1280  7942 45 4E A4
1281  7945 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1281  7949 41 72 F2
1282  794C 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1282  7950 41 72 F2
1283  7953 4E 6F 6E 65  MsgFileTypeText	DEFM	'None  ', ' ' + $80
1283  7957 20 20 A0
1284  795A 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1284  795E 20 20 A0
1285  7961 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1285  7965 74 68 20 20
1285  7969 3A
1286  796A 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1286  796E 35 20 C2
1287  7971 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1287  7975 74 20 20 20
1287  7979 3A
1288  797A 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1288  797E 35 20 A0
1289  7981 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1289  7985 69 6E 67 20
1289  7989 68 65 61 64
1289  798D 65 F2
1290  798F 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1290  7993 20 20 20 20
1290  7997 20 20 20 20
1290  799B 20 20 20 A0
1291  799F 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1291  79A3 66 69 6C 65
1291  79A7 3F 20 79 2F
1291  79AB EE
1292  79AC 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1292  79B0 52 2F 4F 3F
1292  79B4 20 79 2F EE
1293  79B8 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1293  79BC 48 49 44 3F
1293  79C0 20 79 2F EE
1294  79C4 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1294  79C8 3F 6E 6F 6E
1294  79CC 65 3D 61 62
1294  79D0 6F 72 74 BA
1295  79D4 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1295  79D8 20 6D 65 6E
1295  79DC 75 BA
1296  79DE 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1296  79E2 20 63 6F 70
1296  79E6 79 20 6D 65
1296  79EA 6E 75 BA
1297  79ED 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1297  79F1 78 69 74 20
1297  79F5 6D 65 6E F5
1298  79F9
1299  79F9 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1299  79FD 6F 70 79 20
1300  7A01 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1301  7A05 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1302  7A07
1303  7A07 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1303  7A0B 6F 70 79 20
1304  7A0F 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1305  7A13 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1306  7A15
1307  7A15 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1307  7A19 6F 70 79 20
1308  7A1D 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1308  7A21 43 4F CD
1309  7A24
1310  7A24 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1310  7A28 6F 70 79 20
1310  7A2C 43 4F 4D 2D
1310  7A30 3E
1311  7A31 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1312  7A33
1313  7A33 35 2E 20 46  MsgMenuFmt		DEFM	'5. Format '
1313  7A37 6F 72 6D 61
1313  7A3B 74 20
1314  7A3D 41 BA        MsgMenuFmtDrv	DEFM	'A', ':' | $80
1315  7A3F
1316  7A3F 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1316  7A43 61 74 74 69
1316  7A47 6E 67 20
1317  7A4A 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1318  7A4C
1319  7A4C 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1319  7A50 62 6C 6F 63
1319  7A54 6B 73 20 6C
1319  7A58 65 66 F4
1320  7A5B 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1320  7A5F 77 72 69 74
1320  7A63 65 3F 20 79
1320  7A67 2F EE
1321  7A69 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1321  7A6D 20 6E 61 6D
1321  7A71 65 20 65 78
1321  7A75 69 73 74 F3
1322  7A79 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1322  7A7D 53 4F 55 52
1322  7A81 43 45 20 64
1322  7A85 69 73 EB
1323  7A88 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1323  7A8C 44 45 53 54
1323  7A90 2E 20 64 69
1323  7A94 73 6B A0
1324  7A97 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1324  7A9B 73 20 61 6E
1324  7A9F 79 20 6B 65
1324  7AA3 F9
1325  7AA4
1326  7AA4              	IFNDEF	_REAL_HW_
1327  7AA4 ~            FontTable:
1328  7AA4 ~            	incbin "cpmfnt.bin"
1329  7AA4              	ENDIF
1330  7AA4              EndCode:
1331  7AA4
1332  7AA4              ;Unalocated variables
1333  7AA4              UnallocStart	EQU		EndCode
1334  7AA4              FileCnt			EQU		UnallocStart			;File counter, 1B
1335  7AA4              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1336  7AA4              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1337  7AA4              CursorAddr		EQU		SelFile + 1				;2 B
1338  7AA4              AUCnt			EQU		CursorAddr + 2			;2 B
1339  7AA4              SelFileCache	EQU		AUCnt + 2				;2 B
1340  7AA4              CopySelOption	EQU		SelFileCache+2			;1 B
1341  7AA4
1342  7AA4              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1343  7AA4              ;FS block list constants
1344  7AA4              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1345  7AA4              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1346  7AA4              UsedBlockListSz		EQU 320 * 2 + 2							;640
1347  7AA4
1348  7AA4              	IFDEF	_REAL_HW_
1349  7AA4              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1350  7AA4              DataBuf			EQU		FontTable + 872
1351  7AA4              	ELSE
1352  7AA4 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1353  7AA4              	ENDIF
1354  7AA4
1355  7AA4              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1356  7AA4
1357  7AA4              CopyFileFCB		EQU	DataBuf
1358  7AA4              CopyFileRes		EQU DataBuf + 2
1359  7AA4              CopyFileDMAAddr	EQU	DataBuf + 3
1360  7AA4              CopyFileRCExtRead	EQU	DataBuf + 5
1361  7AA4              CopyFileRCExtWrite	EQU	DataBuf + 7
1362  7AA4              FilePosRead		EQU	DataBuf + 9
1363  7AA4              FilePosWrite	EQU	DataBuf + 11
1364  7AA4              CopyFileSectCnt EQU DataBuf + 13
1365  7AA4              CopyFileSrc		EQU DataBuf + 15				;drive 1B + name 11B
1366  7AA4              CopyFileDst		EQU DataBuf + 27
1367  7AA4
1368  7AA4              ;File viewer constants
1369  7AA4              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1370  7AA4              ;File buffer size, without index
1371  7AA4              FileIdxSize		EQU		3 * 1024
1372  7AA4              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1373  7AA4              ;Set a few KB aside for file indexing
1374  7AA4              FileIdx			EQU		FileData + FileDataSize
1375  7AA4
1376  7AA4
1377  7AA4              ;Copy buffer size, follows
1378  7AA4              CopyDiskBuf			EQU DataBuf
1379  7AA4
1380  7AA4              ;We can use up to about 30KB free space if we load at address 24000.
1381  7AA4              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1382  7AA4              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1383  7AA4              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1384  7AA4              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1385  7AA4              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1386  7AA4
1387  7AA4              	DISPLAY "DataBuf: ", /D,DataBuf
1388  7AA4              	DISPLAY "BinSize: ", /D, EndCode - Start
1389  7AA4              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1390  7AA4              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x69D9   NoSub
0x69D2   DivLoop
0x7635   MAX_RAM_FREE
0x0076   MAX_SECT_RAM
0x0C00   FileIdxSize
0x88D2 X CopyFileRCExtWrite
0x88D0 X CopyFileRCExtRead
0x0282   UsedBlockListSz
0x7AA4   UnallocStart
0x7AA4   EndCode
0x77ED   STOPL
0x77D8   SHLOOP
0x77DC   SBIT
0x77E1   SBITDL
0x77C8   SERTX
0x77B5 X SERRX
0x77AA   SERRBC
0x779D   SERRBX
0x77A2   SERRBT
0x778A   SERRBL
0x7777 X SERWI
0x7785   SERRTF
0x7774   SERWIL
0x775F   SERRL
0x7782   SERRTO
0x7755   SERWS
0x774D   SERWSL
0x7746   SERRXI
0x000A   CBAUD
0x7746 X End
0x773B X MaxLine
0x76E7 X MsgLineWrap
0x768C   ScrollDownLoop
0x7683   ScrollDownLoop2
0x768A   ScrollDownPtrSrc
0x7687   ScrollDownPtrDest
0x7679   Scroll
0x7666   FillScrLinesRev
0x5B2E   SCRLinesUp
0x766E   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x7649   FillScrLinesPtr
0x7648   FillScrLinesLoop
0x7639   GetCellDown
0x7634   ReplaceMatch
0x7628   ReplaceSGCLoop
0x000D   CharReplTblLen
0x76B1   CharReplaceTbl
0x002E   MsgLineLen
0x76CB   MsgLine
0x76E0   MsgLineNo
0x76D4   MsgLinePr
0x75B1   GetLineFill
0x7621   ReplaceChars
0x759D   Valid
0x759A   NotValid
0x75A1   GetLineSkip0D
0x7590   GetLineNext
0x75CB   GetLineFillLoop
0x7589   GetLineTab
0x75AA   GetLineSkip0A
0x7575   GetLineLoop
0x7556   PrintStrTxt
0x76F9   LineBuf
0x7676   ScrollDown
0x7671   ScrollUp
0x7527   CheckBegin
0x76EE   MsgLineWrF
0x74B9   NoWrap
0x773D   WrapFlag
0x74C8   Up
0x74F3   Down
0x7473   GetKey
0x7482   ViewFileEOF
0x7537   CheckEnd
0x7542   PrintLine
0x7570   GetLine
0xF3CB   FileIdx
0x75D2   PrintMsg
0x7744   PROGR_PERC
0x7739   CurLine
0x7643   ScrollInit
0x7740   FileLen
0x7742   FileEnd
0x773E   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x73DD   ClearNMsgLinesLoop
0x73CB   ReadStrPrint
0x73BB   ReadStrChar
0x739E   ReadStringLoop
0x7392   Store
0x7391   NoTurn
0x7386   PrintCharLine
0x7372 X PrintChar3
0x731D   DrawCursorLoop
0x7304   DrawVLinesLoop
0x72E6   DrawIntersect
0x727E   DrawLineLoop
0x728B   LineDir
0x727B   StoreDir
0x7279   VertDir
0x7270   DrawLine
0x726C   StrClr
0x721F   GoodChar
0x73ED   CurrScrAddr
0x8563   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x719F   ReadWriteFileSectionLoop
0x71BD   ReadWriteFileSectionEnd
0x88CE   CopyFileDMAAddr
0x88CB   CopyFileFCB
0x7164   ReadWriteFileSection
0x71CE   CopyFilePtr2
0x718A   CopyFilePtr
0x71B2   CopyFileOperAddr2
0x7193   CopyFileOperAddr1
0x7115   CopyFileFromCOMDontInc
0x6A00   FileDataSize
0x7102   CopyFileFromCOMLoop
0x70DC   CopyFileFromCOMNameOK
0x707D   CopyFileToCOMEnd
0x705F   CopyFileToCOMLoop
0x88D8   CopyFileSectCnt
0x714B   WriteFileSection
0x7036   CopyFileNotSameDrive2
0x7019   CopyFileNotSameDrive1
0x7009   CopyFileLoop
0x88D6   FilePosWrite
0x7A5B   MsgFileOverwrite
0x6FE3   CopyFileDestNotExist
0x6FC6   CopyFileCheckOverwrite
0x7082   CopyFileFromCOM
0x7051   CopyFileToCOM
0x6FB3   CopyFileDualDrive
0x6FBD   CopyFileSameDrive
0x6F9D   CopyFileNotExit
0x79DE   MsgMenuFileCopy
0x88DA   CopyFileSrc
0x7A79   MsgInsertSrcDsk
0x7A97   MsgPressAnyKey
0x7A88   MsgInsertDstDsk
0x6EB3 X FileAttribSet
0x6E6C   GetFileSizeMul
0x6E72   GetFileSizeEnd
0x6E6A   GetFileSizeOK
0x6E4A   BDOSSetRandFilePtr
0x6E46   BDOSSetDMA
0x6E38   BDOSWriteFileBlockRandom
0x6E34   BDOSReadFileBlockRandom
0x6E30   BDOSWriteFileBlockSeq
0x6E2C   BDOSReadFileBlockSeq
0x6E28   BDOSCloseFile
0x6E24   BDOSOpenFile
0x6E20   BDOSCreateFile
0x6E16   DestroyChannel
0x6E00   CreateChannel
0x6E00 X BDOSGetCurrentDisk
0x6E00 X BDOSGetDiskRO
0x6E00 X BDOSMakeDiskRO
0x6E3C   BDOS
0x6DE4   InterleaveTbl
0x6DE2 X PrmIntrlvTbl
0x6DE1 X PrmSpinUp
0x6DE0 X PrmHeadLoad
0x6DDE X PrmDevType
0x6DD9 X RWTSResTmp
0x6DD8 X RWTSResVolNo
0x6DDE   BasPrmTbl
0x6DD4 X RWTSPrmTbl
0x6DD2 X RWTSExtBuf
0x6DCF X RWTSSector
0x6DCD X RWTSVolNo
0x6DCB X RWTSBlockType
0x6DC2   CopyMsg
0x6DB6   SearchMsgEnd
0x6DBF   SaveMsg
0x6DAD   IF1Paged
0x6D7B   IF1Call
0x6D76   IsFileHeaderValidLoop
0x6E4E   GetFileSize
0x6D5A   ReadFileHeaderIsTextFile
0x6D73   IsFileHeaderValid
0x6D6F   ReadHeaderEnd
0x6D14   CacheNotFinished
0x6DF7   BDOSSelectDisk
0x6CB1   FileReadLoop
0x6CA5 X FileLoadHeader
0x6CB7   FileLoadNoHeader
0x6CC5   FileFree
0x6C81   MisMatch
0x6C79   Compare
0x6C77   StrCmp
0x6C2E   CopyDiskFromCOMLoop
0x7788   SERRB
0x6BCA   CopyDiskToCOMLoop
0x77BB   SERTB
0x6EF9   PromptDiskChangeSrc
0x6BA8   CopyDiskDualDrive2
0x6B85 X CopyDiskWriteEnd
0x6B6E   CopyDiskLoopWriteLoop
0x6B67   CopyDiskReadEnd
0x6DF4   BDOSInit
0x6EDF   PromptDiskChangeDst
0x6B5D   CopyDiskDualDrive1
0x6B34   CopyDiskLoopReadLoop
0x88CB   CopyDiskBuf
0x6B2D   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7A4C   MsgBlocksLeft
0x6AFF   CopyDiskLoop
0x82E3   UsedBlockListBlk
0x6CDD   WriteDiskSectors
0x6AF4 X WriteFSBlockLoop
0x6AEB   WriteFSBlock
0x6CCA   ReadDiskSectors
0x6AE7 X ReadFSBlockLoop
0x6ADE   ReadFSBlock
0x6AD0   ReadUsedBlocksSkip
0x6AB3   ReadUsedBlocksLoop2
0x6AD3   ReadUsedBlocksSkip2
0x6AA3   ReadUsedBlocksLoop
0x82E1   UsedBlockListCnt
0x6A86   ReadUsedBlocksList
0x6A7F   CheckAUEnd
0x6A6B   CheckAU
0x6A54   FirstAU
0x6A4E   Track0
0x6A39   AU2TS
0x6DD7   RWTSRes
0x6A1D   WriteOneDiskSector
0x6DCE   RWTSTrack
0x6DD0   RWTSDMA
0x6A12   ReadOneDiskSector
0x6DCB   RWTSParams
0x6DD6   RWTSCmd
0x6A06   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x001F X STR_MSG_IF1_LEN
0x23F0 X STR_MSG_IF1_91
0x27F0 X STR_MSG_IF1_2000
0x0020 X STR_MSG_BASIC_LEN
0x1539 X STR_MSG_BASIC
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x001A   CHAR_EOF
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6A00   NoAdd
0x69FA   MulLoop
0x69E1   Div2Loop
0x69DC   Div2
0x69CF   Div
0x69C6   DivNrLoop
0x69C4   DigitLoop
0x69B5   Byte2Txt_
0x699E   StrippLeading0
0x69A9   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x6985   DontInc
0x6979   ReadAllHeadersEnd
0x6964   AKey
0x71DF   KbdHit
0x6949   NextFile
0x7961   MsgFileLen
0x791D   MsgFileType
0x7971   MsgFileStart
0x6908   PrintStartStr
0x797A   MsgFileStartN
0x795A   MsgNA
0x68FA   PrintStart
0x0007   HDR_LINE
0x68D5   PrintByteStart
0x68CD   PrintProgStart
0x796A   MsgFileLenN
0x68B3 X PrepFileLenText
0x7953   MsgFileTypeText
0x7937   MsgFileTypeByte
0x793E   MsgFileTypeSCR
0x6899   NotScr
0x68A4   CheckText
0x7945   MsgFileTypeChrA
0x687C   CheckByte
0x0002   CHAR_TYPE
0x794C   MsgFileTypeNoA
0x686D   CheckChrArr
0x0001   NUMB_TYPE
0x68AD   PrepFileLen
0x6DDF X PrmStepRate
0x6926   MoveMsg
0x7926   MsgFileTypeN
0x7930   MsgFileTypePrg
0x685E   CheckNoArr
0x000B   CACHE_FIRST_AU
0x68DD   HeadNotRead
0x790D   MsgFileAttr
0x682F   AttrEnd
0x6823   NotSYS
0x680F   CheckSys
0x67FD   NotRO
0x7916   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x68EF   PrintStartNotRead
0x78FD   MsgFileSzDsk
0x7906   MsgFileSzDskN
0x748A   PrintLoop2
0x744F   PrintLoop
0x73F1   InitViewer
0x7129   ReadFileSection
0x6794   ViewFileLoop
0x88D4   FilePosRead
0x6D81   LoadProgram
0x78CF   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x78DE   MsgLoadingSCR
0x0003   HDR_ADDR
0x6CC5   IF1FileLoadEnd
0x5B00   PRN_BUF
0x6C84   IF1FileLoad
0x78ED   MsgLoadingCODE
0x6733 X HandleFileCODE
0x675C   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x678A   HandleFileText
0x0003   BYTE_TYPE
0x677A   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x66FD   FindExtEnd
0x6D09   FindCache
0x670C   GetFileNamesEnd
0x0009   HDR_SZ
0x66D8   FindExt
0x000C   EXT_IDX
0x6A57   CheckExtAlloc
0x66FF   NextExt
0x0000   EXT_DEL_FLAG
0x6687   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6664   DisplayFilenamesLoop
0x664A   LineOK
0x5CB1   LINE
0x5CB0   COL
0x735A   PrintChar
0x5C81   CODE
0x6624   DispLoop
0x6622   DisplayFilename
0x7322   MoveCursor
0x6A28   FormatDisk
0x7A3F   MsgFormat
0x6C11   CopyDiskFromCOM
0x65E0   CheckDiskMenuFormat
0x6BB5   CopyDiskToCOM
0x65D6   CheckDiskMenuFromCOM
0x65CD   CheckDiskMenuToCOM
0x6AF8   CopyDisk
0x65BF   CheckDiskMenuDualDrive
0x6611   DiskMenuExit
0x65AD X CheckKeyDiskMenuLoop
0x7A33   MsgMenuFmt
0x7A24   MsgMenuFromCOM
0x7A15   MsgMenuToCOM
0x7A07   MsgMenuDual
0x79F9   MsgMenuSingle
0x79ED   MsgMenuBack
0x79D4   MsgMenuDiskCopy
0x7A13   MsgMenuDualDrv2
0x7A4A   MsgFormatDrv
0x7A3D   MsgMenuFmtDrv
0x7A31   MsgMenuFromCOMDrv
0x7A1D   MsgMenuToComDrv
0x7A0F   MsgMenuDualDrv1
0x7A05   MsgMenuSingleDrv2
0x7A01   MsgMenuSingleDrv1
0x6614   CheckKeyExit
0x6E92   ChangeFileAttrib
0x6526   AttrChange
0x79B8   MsgSetSYS
0x650E   CheckSYS
0x79AC   MsgSetRO
0x6535   CheckKeyDiskMenu
0x6E78   DeleteFile
0x64E0   DoFileDelete
0x799F   MsgDelete
0x64ED   CheckKeyAttrib
0x6EBC   RenameFile
0x7A69   MsgFileExists
0x6490   RenameFileNotExist
0x6E84   DoesFileExist
0x649C   RenameCanceled
0x7398   ReadString
0x000B   NAMELEN
0x89CB   FileData
0x79C4   MsgNewFileName
0x64B5   CheckKeyDel
0x678B   ViewFile
0x6434   CheckKeyRename
0x0001   DRIVE_B_CPM
0x6423   CheckKeyView
0x652F   SelectDrive
0x641A   CheckKeyDriveB
0x692C   ReadAllHeaders
0x6411   CheckKeyDriveA
0x88E6   CopyFileDst
0x7AAD   CopySelOption
0x73DA   ClearNMsgLines
0x63E9   CopyFileOK
0x88CD   CopyFileRes
0x6F13   CopyFile
0x6400   CheckKeyFileInfo
0x798F   MsgClear
0x6D1A   ReadFileHeader
0x7981   MsgReadingExt
0x63B7   CheckKeyCopy
0x670D   HandleFile
0x638C   CheckKeyInfo
0x6386   DoKeyEnter
0x000D   KEY_ENTER
0x637D   CheckEnter
0x6370   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6368   CheckLeft
0x6356   DoKeyRight
0x0009   KEY_RIGHT
0x634E   CheckRight
0x6341   DoKeyUp
0x000B   KEY_UP
0x661C   MoveIt
0x6339   CheckUp
0x6328   DoKeyDown
0x000A   KEY_DOWN
0x67BA   DisplayFileInfo
0x7AAB   SelFileCache
0x69EF   Mul
0x6306   CalcFileCache
0x78B0   MsgFreeSpace
0x6988   Word2Txt
0x78B9   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x7AA9   AUCnt
0x78A0   MsgFilesCnt
0x78A9   MsgFilesCntNo
0x7AA4   FileCnt
0x7890   MsgDrive
0x789F   MsgDriveLet
0x6D9A   SetFastKeys
0x7317   DrawCursor
0x0020   SCR_SEL_CLR
0x7841   MsgMessages
0x0008   LST_FILE_INFO
0x7831   MsgFileInf
0x0004   LST_DISK_INFO
0x7821   MsgDskInf
0x7811   MsgSysInf
0x7851   BtnBar
0x0020   SCR_LBL_CLR
0x7801   VerMsg2
0x7218   PrintStr
0x0001   LST_PROG_INFO
0x77F1   VerMsg1
0x728F   DrawHLines
0x72FF   DrawVLines
0x7AA7   CursorAddr
0x73EF   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x71F8   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x7AA5   NameCol
0x0010   LST_FIRST_COL
0x7AA6   SelFile
0x88CB   DataBuf
0x6DA5   GetErrMsg
0x5C3A   ERRNR
0x6207 X HCRunEnd
0x6317   ReadKeyLoop
0x62BD   DisplayDiskInfo
0x6654   DisplayFilenames
0x623F   InitUI
0x61FB   HCRunMain
0x6674   GetFileNames
0x6DCC   RWTSDrive
0x0000   DRIVE_A_CPM
0x71DC   ReadChar
0x7240   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000E   LST_LINE_MSG
0x78C0   MsgErr
0x6993   Byte2Txt
0x78CB   MsgErrCode
0x61F8   HCRunCacheFiles
0x6CF0   ReadCatalogTrack
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x7AAD   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x88CB   TrackBuf
0x61BA   HCRunInitDisk
0x620D   ErrorHandler
0x5C3D   ERRSP
0x6A03   IF1Init
0x71E2   InitFonts
0x61A8   Start
