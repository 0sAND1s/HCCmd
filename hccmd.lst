# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 24500
  12  5FB4
  13  5FB4              Start:
  14  5FB4              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  5FB4 CD 51 70     		call InitFonts
  16  5FB7              	ENDIF
  17  5FB7 CD 34 68     	call IF1Init
  18  5FBA
  19  5FBA              	;install error handler
  20  5FBA 2A 3D 5C     	ld		hl, (ERRSP)
  21  5FBD E5           	push	hl
  22  5FBE 21 42 60     	ld		hl, ErrorHandler
  23  5FC1 E5           	push	hl
  24  5FC2 ED 73 3D 5C  	ld		(ERRSP), sp
  25  5FC6
  26  5FC6              HCRunInitDisk:
  27  5FC6              	;Set track buffer to del marker
  28  5FC6 21 47 87     	ld		hl, TrackBuf
  29  5FC9 54           	ld		d, h
  30  5FCA 5D           	ld		e, l
  31  5FCB 13           	inc		de
  32  5FCC 01 00 10     	ld		bc, SPT*SECT_SZ
  33  5FCF 36 E5        	ld		(hl), DEL_MARKER
  34  5FD1 ED B0        	ldir
  35  5FD3
  36  5FD3              	;Invalidate file cache
  37  5FD3 21 29 79     	ld		hl, FileCache
  38  5FD6 54           	ld		d, h
  39  5FD7 5D           	ld		e, l
  40  5FD8 13           	inc		de
  41  5FD9 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  5FDC 36 00        	ld		(hl), 0
  43  5FDE ED B0        	ldir
  44  5FE0
  45  5FE0              	;main program
  46  5FE0 CD 11 6C     	call	BDOSGetCurrentDrive
  47  5FE3 FE FF        	cp		$FF
  48  5FE5 20 02        	jr		nz, DetectTrackCount
  49  5FE7
  50  5FE7 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  51  5FE9
  52  5FE9              DetectTrackCount:
  53  5FE9 F5           	push	af
  54  5FEA CD 05 6C     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  55  5FED F1           	pop		af
  56  5FEE 32 ED 6B     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  57  5FF1 CD 08 6C     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  58  5FF4
  59  5FF4              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  60  5FF4 1E 28        	ld		e, TRACK_CNT/2
  61  5FF6 21 47 87     	ld		hl, FileData
  62  5FF9 CD 43 68     	call	ReadOneDiskSector
  63  5FFC 3A F8 6B     	ld		a, (RWTSRes)
  64  5FFF B7           	or		a
  65  6000 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  66  6003 28 03        	jr		z, DriveIs80Tracks
  67  6005 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  68  6008              DriveIs80Tracks:
  69  6008 22 02 79     	ld		(AUCntMaxFree), hl
  70  600B
  71  600B CD 1E 6B     	call 	ReadCatalogTrack
  72  600E B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  73  600F 28 1A        	jr		z, HCRunCacheFiles
  74  6011
  75  6011 6F           	ld		l, a
  76  6012 26 00        	ld		h, 0
  77  6014 11 12 77     	ld		de, MsgErrCode
  78  6017 CD C4 67     	call	Byte2Txt
  79  601A 21 07 77     	ld		hl, MsgErr
  80  601D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  81  6020 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  82  6022 CD AF 70     	call	PrintStrClr
  83  6025 CD 05 6C     	call	BDOSInit
  84  6028 C3 C6 5F     	jp		HCRunInitDisk
  85  602B
  86  602B
  87  602B              HCRunCacheFiles:
  88  602B CD AE 64     	call 	GetFileNames
  89  602E
  90  602E              HCRunMain:
  91  602E CD 77 60     	call 	InitUI
  92  6031 CD 8E 64     	call	DisplayFilenames
  93  6034 CD F5 60     	call	DisplayDiskInfo
  94  6037 C3 68 61     	jp		ReadKeyLoop
  95  603A
  96  603A              HCRunEnd:
  97  603A              	;restore error handler
  98  603A E1           	pop		hl
  99  603B E1           	pop		hl
 100  603C 22 3D 5C     	ld		(ERRSP), hl
 101  603F
 102  603F              	;ret
 103  603F C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 104  6042
 105  6042              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 106  6042
 107  6042              ErrorHandler:
 108  6042 E1           	pop		hl
 109  6043 22 3D 5C     	ld		(ERRSP), hl
 110  6046
 111  6046 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 112  6049 6F           	ld		l, a
 113  604A 26 00        	ld		h, 0
 114  604C 11 12 77     	ld		de, MsgErrCode
 115  604F CD C4 67     	call	Byte2Txt
 116  6052 21 07 77     	ld		hl, MsgErr
 117  6055 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 118  6058 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 119  605A CD AF 70     	call	PrintStrClr
 120  605D
 121  605D 3A 3A 5C     	ld		a, (ERRNR)
 122  6060 CD C6 6B     	call	GetErrMsg
 123  6063
 124  6063 21 47 87     	ld		hl, DataBuf
 125  6066 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 126  6069 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 127  606B CD AF 70     	call	PrintStrClr
 128  606E
 129  606E CD 4B 70     	call	ReadChar
 130  6071 CD 05 6C     	call	BDOSInit
 131  6074 C3 B4 5F     	jp		Start
 132  6077
 133  6077
 134  6077
 135  6077
 136  6077              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 137  6077
 138  6077              InitUI:
 139  6077 AF           	xor		a
 140  6078 32 FD 78     	ld		(SelFile), A
 141  607B 3E 11        	ld		a, LST_FIRST_COL + 1
 142  607D 32 FC 78     	ld		(NameCol), A
 143  6080 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 144  6083 ED 53 B0 5C  	ld		(LineCol), de
 145  6087
 146  6087 CD 67 70     	call	ClrScr
 147  608A
 148  608A 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 149  608D ED 4B 48 72  	ld		bc, (CurrScrAttrAddr)
 150  6091 09           	add		hl, bc
 151  6092 22 FE 78     	ld		(CursorAddr), hl
 152  6095
 153  6095 CD 58 71     	call	DrawVLines
 154  6098
 155  6098 CD FE 70     	call	DrawHLines
 156  609B
 157  609B 21 48 76     	ld		hl, VerMsg1
 158  609E 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 159  60A1 3A 57 76     	ld		a, (VerMsg1 + 15)
 160  60A4 F6 80        	or		$80
 161  60A6 32 57 76     	ld		(VerMsg1 + 15), a
 162  60A9 CD 87 70     	call	PrintStr
 163  60AC 21 58 76     	ld		hl, VerMsg2
 164  60AF 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 165  60B2 CD 87 70     	call	PrintStr
 166  60B5
 167  60B5 3E 60        	ld		a, SCR_LBL_CLR
 168  60B7 11 00 17     	ld		de, 23 << 8
 169  60BA 21 A8 76     	ld		hl, BtnBar
 170  60BD CD AF 70     	call	PrintStrClr
 171  60C0
 172  60C0 3E 60        	ld		a, SCR_LBL_CLR
 173  60C2 21 68 76     	ld		hl, MsgSysInf
 174  60C5 11 00 01     	ld		de, LST_PROG_INFO << 8
 175  60C8 CD AF 70     	call	PrintStrClr
 176  60CB
 177  60CB 3E 60        	ld		a, SCR_LBL_CLR
 178  60CD 21 78 76     	ld		hl, MsgDskInf
 179  60D0 11 00 04     	ld		de, LST_DISK_INFO << 8
 180  60D3 CD AF 70     	call	PrintStrClr
 181  60D6
 182  60D6 3E 60        	ld		a, SCR_LBL_CLR
 183  60D8 21 88 76     	ld		hl, MsgFileInf
 184  60DB 11 00 07     	ld		de, LST_FILE_INFO << 8
 185  60DE CD AF 70     	call	PrintStrClr
 186  60E1
 187  60E1 3E 60        	ld		a, SCR_LBL_CLR
 188  60E3 21 98 76     	ld		hl, MsgMessages
 189  60E6 11 00 0D     	ld		de, LST_LINE_MSG << 8
 190  60E9 CD AF 70     	call	PrintStrClr
 191  60EC
 192  60EC 3E 60        	ld		a, SCR_SEL_CLR
 193  60EE CD 70 71     	call	DrawCursor
 194  60F1
 195  60F1 CD BB 6B     	call	SetFastKeys
 196  60F4
 197  60F4 C9           	ret
 198  60F5
 199  60F5
 200  60F5              DisplayDiskInfo:
 201  60F5 2A 02 79     	ld		hl, (AUCntMaxFree)
 202  60F8 ED 5B 00 79  	ld		de, (AUCntUsed)
 203  60FC B7           	or		a
 204  60FD ED 52        	sbc		hl, de
 205  60FF CB 15        	rl		l								;*2, 2K/AU
 206  6101 CB 14        	rl		h
 207  6103
 208  6103 11 F2 76     	ld		de, MsgDriveLet
 209  6106 CD B9 67     	call	Word2Txt
 210  6109 3A F6 76     	ld		a, (MsgDriveLet+4)
 211  610C F6 80        	or		$80
 212  610E 32 F6 76     	ld		(MsgDriveLet+4), a
 213  6111
 214  6111 3A ED 6B     	ld		a, (RWTSDrive)
 215  6114 C6 41        	add		'A'
 216  6116 32 F2 76     	ld		(MsgDriveLet), a
 217  6119 3E 2F        	ld		a, '/'
 218  611B 32 F3 76     	ld		(MsgDriveLet+1), a
 219  611E
 220  611E 21 E7 76     	ld		hl, MsgDrive
 221  6121 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 222  6124 CD 87 70     	call	PrintStr
 223  6127
 224  6127 2A 00 79     	ld		hl, (AUCntUsed)
 225  612A CB 15        	rl		l								;*2, 2K/AU
 226  612C CB 14        	rl		h
 227  612E 11 02 77     	ld		de, MsgFilesCntNo+2
 228  6131 CD B9 67     	call	Word2Txt
 229  6134 3A 06 77     	ld		a, (MsgFilesCntNo+6)
 230  6137 F6 80        	or		$80
 231  6139 32 06 77     	ld		(MsgFilesCntNo+6), a
 232  613C 3E 2F        	ld		a, '/'
 233  613E 32 03 77     	ld		(MsgFilesCntNo+3), a
 234  6141
 235  6141 3A FB 78     	ld		a, (FileCnt)
 236  6144 6F           	ld		l, a
 237  6145 26 00        	ld		h, 0
 238  6147 11 00 77     	ld		de, MsgFilesCntNo
 239  614A CD C4 67     	call	Byte2Txt
 240  614D 21 F7 76     	ld		hl, MsgFilesCnt
 241  6150 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 242  6153 CD 87 70     	call	PrintStr
 243  6156
 244  6156 C9           	ret
 245  6157
 246  6157              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247  6157
 248  6157              CalcFileCache:
 249  6157 3A FD 78     	ld		a, (SelFile)
 250  615A 11 19 00     	ld		de, CACHE_SZ
 251  615D CD 20 68     	call	Mul
 252  6160 01 29 79     	ld		bc, FileCache
 253  6163 09           	add		hl, bc					;HL = file AU cnt
 254  6164 22 04 79     	ld		(SelFileCache), hl
 255  6167 C9           	ret
 256  6168
 257  6168              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 258  6168
 259  6168
 260  6168              ReadKeyLoop:
 261  6168 CD 57 61     	call	CalcFileCache
 262  616B CD F1 65     	call	DisplayFileInfo
 263  616E
 264  616E CD 4B 70     	call	ReadChar
 265  6171
 266  6171 FE 0A        	cp		KEY_DOWN
 267  6173 28 04        	jr		z,  DoKeyDown
 268  6175 FE 61        	cp 		'a'
 269  6177 20 11        	jr		nz, CheckUp
 270  6179
 271  6179              DoKeyDown:
 272  6179 3A FB 78     	ld		a, (FileCnt)
 273  617C 47           	ld		b, a
 274  617D 3A FD 78     	ld		a, (SelFile)
 275  6180 3C           	inc		a
 276  6181 B8           	cp		b
 277  6182 30 E4        	jr		nc, ReadKeyLoop
 278  6184 32 FD 78     	ld		(SelFile), a
 279  6187 C3 56 64     	jp		MoveIt
 280  618A
 281  618A              CheckUp:
 282  618A FE 0B        	cp		KEY_UP
 283  618C 28 04        	jr		z, DoKeyUp
 284  618E FE 71        	cp 		'q'
 285  6190 20 0D        	jr		nz, CheckRight
 286  6192
 287  6192              DoKeyUp:
 288  6192 3A FD 78     	ld		a, (SelFile)
 289  6195 B7           	or		a
 290  6196 28 D0        	jr		z, ReadKeyLoop
 291  6198
 292  6198 3D           	dec		a
 293  6199 32 FD 78     	ld		(SelFile), a
 294  619C C3 56 64     	jp		MoveIt
 295  619F
 296  619F              CheckRight:
 297  619F FE 09        	cp		KEY_RIGHT
 298  61A1 28 04        	jr		z, DoKeyRight
 299  61A3 FE 70        	cp 		'p'
 300  61A5 20 12        	jr		nz, CheckLeft
 301  61A7
 302  61A7              DoKeyRight:
 303  61A7 3A FB 78     	ld		a, (FileCnt)
 304  61AA 47           	ld		b, a
 305  61AB 3A FD 78     	ld		a, (SelFile)
 306  61AE C6 15        	add		LST_LINES_CNT
 307  61B0 B8           	cp		b
 308  61B1 30 B5        	jr		nc, ReadKeyLoop
 309  61B3
 310  61B3 32 FD 78     	ld		(SelFile), a
 311  61B6 C3 56 64     	jp		MoveIt
 312  61B9
 313  61B9              CheckLeft:
 314  61B9 FE 08        	cp		KEY_LEFT
 315  61BB 28 04        	jr		z, DoKeyLeft
 316  61BD FE 6F        	cp		'o'
 317  61BF 20 0D        	jr		nz, CheckEnter
 318  61C1
 319  61C1              DoKeyLeft:
 320  61C1 3A FD 78     	ld		a, (SelFile)
 321  61C4 D6 15        	sub		LST_LINES_CNT
 322  61C6 38 A0        	jr		c, ReadKeyLoop
 323  61C8
 324  61C8 32 FD 78     	ld		(SelFile), a
 325  61CB C3 56 64     	jp		MoveIt
 326  61CE
 327  61CE              CheckEnter:
 328  61CE FE 0D        	cp		KEY_ENTER
 329  61D0 28 05        	jr		z, DoKeyEnter
 330  61D2 FE 6D        	cp		'm'
 331  61D4 C2 DD 61     	jp		nz, CheckKeyInfo
 332  61D7
 333  61D7              DoKeyEnter:
 334  61D7 CD 47 65     	call	HandleFile
 335  61DA C3 2E 60     	jp		HCRunMain
 336  61DD
 337  61DD              CheckKeyInfo:
 338  61DD FE 34        	cp		'4'
 339  61DF 20 21        	jr		nz, CheckKeyCopy
 340  61E1
 341  61E1 3A FB 78     	ld		a, (FileCnt)
 342  61E4 B7           	or		a
 343  61E5 CA 68 61     	jp		z, ReadKeyLoop
 344  61E8
 345  61E8 DD 2A 04 79  	ld		ix, (SelFileCache)
 346  61EC 21 C8 77     	ld		hl, MsgReadingExt
 347  61EF 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 348  61F2 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 349  61F4 CD AF 70     	call	PrintStrClr
 350  61F7 CD 3B 6B     	call	ReadFileHeader
 351  61FA 06 01        	ld		b, 1
 352  61FC CD 33 72     	call	ClearNMsgLines
 353  61FF C3 68 61     	jp		ReadKeyLoop
 354  6202
 355  6202              CheckKeyCopy:
 356  6202 FE 35        	cp		'5'
 357  6204 C2 4E 62     	jp		nz, CheckKeyFileInfo
 358  6207
 359  6207 3A FB 78     	ld		a, (FileCnt)
 360  620A B7           	or		a
 361  620B CA 68 61     	jp		z, ReadKeyLoop
 362  620E
 363  620E 2A 04 79     	ld		hl, (SelFileCache)
 364  6211 CD 33 6D     	call	CopyFile
 365  6214 3A 09 79     	ld		a, (CopyFileRes)
 366  6217 B7           	or		a
 367  6218 28 1A        	jr		z, CopyFileOK
 368  621A
 369  621A 6F           	ld		l, a
 370  621B 26 00        	ld		h, 0
 371  621D 11 12 77     	ld		de, MsgErrCode
 372  6220 CD C4 67     	call	Byte2Txt
 373  6223 21 07 77     	ld		hl, MsgErr
 374  6226 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 375  6229 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 376  622B CD AF 70     	call	PrintStrClr
 377  622E CD 4B 70     	call	ReadChar
 378  6231 C3 68 61     	jp		ReadKeyLoop
 379  6234
 380  6234              CopyFileOK:
 381  6234 06 02        	ld		b, 2
 382  6236 CD 33 72     	call	ClearNMsgLines
 383  6239              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 384  6239 3A 06 79     	ld		a, (CopySelOption)
 385  623C FE 33        	cp		'3'
 386  623E CA 68 61     	jp		z, ReadKeyLoop
 387  6241 3A 1D 79     	ld		a, (CopyFileDstDrv)
 388  6244 3D           	dec		a
 389  6245 32 ED 6B     	ld		(RWTSDrive), a
 390  6248 CD 08 6C     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 391  624B C3 C6 5F     	jp		HCRunInitDisk
 392  624E
 393  624E              CheckKeyFileInfo:
 394  624E FE 20        	cp		' '
 395  6250 20 0D        	jr		nz, CheckKeyDriveA
 396  6252
 397  6252 3A FB 78     	ld		a, (FileCnt)
 398  6255 B7           	or		a
 399  6256 CA 68 61     	jp		z, ReadKeyLoop
 400  6259
 401  6259 CD 63 67     	call	ReadAllHeaders
 402  625C C3 68 61     	jp		ReadKeyLoop
 403  625F
 404  625F              CheckKeyDriveA:
 405  625F FE 31        	cp		'1'
 406  6261 20 05        	jr		nz, CheckKeyDriveB
 407  6263 3E 00        	ld		a, DRIVE_A_CPM
 408  6265 C3 66 63     	jp		SelectDrive
 409  6268
 410  6268              CheckKeyDriveB:
 411  6268 FE 32        	cp		'2'
 412  626A 20 05        	jr		nz, CheckKeyView
 413  626C 3E 01        	ld		a, DRIVE_B_CPM
 414  626E C3 66 63     	jp		SelectDrive
 415  6271
 416  6271              CheckKeyView:
 417  6271 FE 33        	cp		'3'
 418  6273 20 0D        	jr		nz, CheckKeyRename
 419  6275
 420  6275 3A FB 78     	ld		a, (FileCnt)
 421  6278 B7           	or		a
 422  6279 CA 68 61     	jp		z, ReadKeyLoop
 423  627C
 424  627C CD C2 65     	call	ViewFile
 425  627F C3 2E 60     	jp		HCRunMain
 426  6282
 427  6282              CheckKeyRename:
 428  6282 FE 36        	cp		'6'
 429  6284 20 6C        	jr		nz, CheckKeyDel
 430  6286
 431  6286 3A FB 78     	ld		a, (FileCnt)
 432  6289 B7           	or		a
 433  628A CA 68 61     	jp		z, ReadKeyLoop
 434  628D
 435  628D 21 0B 78     	ld		hl, MsgNewFileName
 436  6290 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 437  6293 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 438  6295 CD AF 70     	call	PrintStrClr
 439  6298
 440  6298 21 D6 77     	ld		hl, MsgClear
 441  629B 11 47 87     	ld		de, FileData
 442  629E 01 0B 00     	ld		bc, NAMELEN
 443  62A1 ED B0        	ldir
 444  62A3 3E A0        	ld		a, $80 | ' '
 445  62A5 12           	ld		(de), a
 446  62A6 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 447  62A9 21 47 87     	ld		hl, FileData
 448  62AC CD 87 70     	call	PrintStr
 449  62AF
 450  62AF 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 451  62B2 01 0B 00     	ld		bc, NAMELEN
 452  62B5 CD F1 71     	call	ReadString
 453  62B8
 454  62B8 11 47 87     	ld		de, FileData
 455  62BB 1A           	ld		a, (de)
 456  62BC FE 20        	cp		' '					;If starting with space, input was canceled.
 457  62BE CA EA 62     	jp		z, RenameCanceled
 458  62C1
 459  62C1              	;Check if new name doesn't exist already. Cancel if so.
 460  62C1 21 47 87     	ld		hl, FileData
 461  62C4 3A ED 6B     	ld 		a, (RWTSDrive)
 462  62C7 3C           	inc		a
 463  62C8 CD 99 6C     	call	DoesFileExist
 464  62CB 3C           	inc		a
 465  62CC 28 10        	jr		z, RenameFileNotExist
 466  62CE
 467  62CE 21 B0 78     	ld		hl, MsgFileExists
 468  62D1 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 469  62D4 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 470  62D6 CD AF 70     	call	PrintStrClr
 471  62D9 CD 4B 70     	call	ReadChar
 472  62DC 18 0C        	jr		RenameCanceled
 473  62DE
 474  62DE              RenameFileNotExist:
 475  62DE 11 47 87     	ld		de, FileData
 476  62E1 2A 04 79     	ld		hl, (SelFileCache)
 477  62E4 CD DC 6C     	call	RenameFile
 478  62E7 C3 C6 5F     	jp		HCRunInitDisk
 479  62EA
 480  62EA              RenameCanceled:
 481  62EA 06 02        	ld		b, 2
 482  62EC CD 33 72     	call	ClearNMsgLines
 483  62EF C3 68 61     	jp		ReadKeyLoop
 484  62F2
 485  62F2              CheckKeyDel:
 486  62F2 FE 38        	cp		'8'
 487  62F4 20 2E        	jr		nz, CheckKeyAttrib
 488  62F6
 489  62F6 3A FB 78     	ld		a, (FileCnt)
 490  62F9 B7           	or		a
 491  62FA CA 68 61     	jp		z, ReadKeyLoop
 492  62FD
 493  62FD 21 E6 77     	ld		hl, MsgDelete
 494  6300 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 495  6303 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 496  6305 CD AF 70     	call	PrintStrClr
 497  6308 CD 4B 70     	call	ReadChar
 498  630B FE 79        	cp		'y'
 499  630D 28 08        	jr		z, DoFileDelete
 500  630F 06 01        	ld		b, 1
 501  6311 CD 33 72     	call	ClearNMsgLines
 502  6314 C3 68 61     	jp		ReadKeyLoop
 503  6317              DoFileDelete:
 504  6317 2A 04 79     	ld		hl, (SelFileCache)
 505  631A 3A ED 6B     	ld 		a, (RWTSDrive)
 506  631D 3C           	inc		a					;Convert to BASIC drive number: 1,2
 507  631E CD 8D 6C     	call	DeleteFile
 508  6321 C3 C6 5F     	jp		HCRunInitDisk
 509  6324
 510  6324              CheckKeyAttrib:
 511  6324 FE 37        	cp		'7'
 512  6326 20 47        	jr		nz, CheckKeyDiskMenu
 513  6328
 514  6328 3A FB 78     	ld		a, (FileCnt)
 515  632B B7           	or		a
 516  632C CA 68 61     	jp		z, ReadKeyLoop
 517  632F
 518  632F 21 F3 77     	ld		hl, MsgSetRO
 519  6332 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 520  6335 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 521  6337 CD AF 70     	call	PrintStrClr
 522  633A CD 4B 70     	call	ReadChar
 523  633D 1E 00        	ld		e, 0
 524  633F FE 79        	cp		'y'
 525  6341 20 02        	jr		nz, CheckSYS
 526  6343 1E 01        	ld		e, 1
 527  6345
 528  6345              CheckSYS:
 529  6345 D5           	push	de
 530  6346 21 FF 77     		ld		hl, MsgSetSYS
 531  6349 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 532  634C 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 533  634E CD AF 70     		call	PrintStrClr
 534  6351 CD 4B 70     		call	ReadChar
 535  6354 FE 79        		cp		'y'
 536  6356 D1           	pop		de
 537  6357 20 04        	jr		nz, AttrChange
 538  6359 3E 02        	ld		a, %10
 539  635B B3           	or		e
 540  635C 5F           	ld		e, a
 541  635D
 542  635D              AttrChange:
 543  635D 2A 04 79     	ld		hl, (SelFileCache)
 544  6360 CD B2 6C     	call	ChangeFileAttrib
 545  6363 C3 C6 5F     	jp		HCRunInitDisk
 546  6366
 547  6366              SelectDrive:
 548  6366 32 ED 6B     	ld 		(RWTSDrive), a
 549  6369 CD 08 6C     	call	BDOSSelectDisk
 550  636C              	;call	BDOSInit
 551  636C C3 C6 5F     	jp		HCRunInitDisk
 552  636F
 553  636F              CheckKeyDiskMenu:
 554  636F FE 39        	cp		'9'
 555  6371 C2 4E 64     	jp		nz, CheckKeyExit
 556  6374
 557  6374 3A ED 6B     	ld		a, (RWTSDrive)
 558  6377 C6 41        	add		'A'
 559  6379              	;Update menu messages with current drive.
 560  6379 32 48 78     	ld		(MsgMenuSingleDrv1), a
 561  637C 32 4C 78     	ld		(MsgMenuSingleDrv2), a
 562  637F 32 56 78     	ld		(MsgMenuDualDrv1), a
 563  6382 32 64 78     	ld		(MsgMenuToComDrv), a
 564  6385 32 78 78     	ld		(MsgMenuFromCOMDrv), a
 565  6388 32 84 78     	ld		(MsgMenuFmtDrv), a
 566  638B 32 91 78     	ld		(MsgFormatDrv), a
 567  638E              	;Update menu messages with the alternate drive.
 568  638E 3A ED 6B     	ld		a, (RWTSDrive)
 569  6391 3C           	inc		a
 570  6392 EE 03        	xor		%11
 571  6394 C6 40        	add		'A'-1
 572  6396 32 5A 78     	ld		(MsgMenuDualDrv2), a
 573  6399
 574  6399 21 1B 78     	ld		hl, MsgMenuDiskCopy
 575  639C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 576  639F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 577  63A1 CD AF 70     	call	PrintStrClr
 578  63A4 21 34 78     	ld		hl, MsgMenuBack
 579  63A7 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 580  63AA CD 87 70     	call	PrintStr
 581  63AD 21 40 78     	ld		hl, MsgMenuSingle
 582  63B0 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 583  63B3 CD 87 70     	call	PrintStr
 584  63B6 21 4E 78     	ld		hl, MsgMenuDual
 585  63B9 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 586  63BC CD 87 70     	call	PrintStr
 587  63BF 21 5C 78     	ld		hl, MsgMenuToCOM
 588  63C2 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 589  63C5 CD 87 70     	call	PrintStr
 590  63C8 21 6B 78     	ld		hl, MsgMenuFromCOM
 591  63CB 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 592  63CE CD 87 70     	call	PrintStr
 593  63D1 21 7A 78     	ld		hl, MsgMenuFmt
 594  63D4 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 595  63D7 CD 87 70     	call	PrintStr
 596  63DA
 597  63DA CD 4B 70     	call	ReadChar
 598  63DD F5           	push	af
 599  63DE 06 07        		ld		b, 7
 600  63E0 CD 33 72     		call	ClearNMsgLines
 601  63E3 F1           	pop		af
 602  63E4 32 06 79     	ld		(CopySelOption), a
 603  63E7
 604  63E7              CheckKeyDiskMenuLoop:
 605  63E7 FE 30        	cp		'0'
 606  63E9 28 60        	jr		z, DiskMenuExit
 607  63EB
 608  63EB              	;Single drive copy
 609  63EB FE 31        	cp		'1'
 610  63ED 20 0A        	jr		nz, CheckDiskMenuDualDrive
 611  63EF CD 2A 69     	call	CopyDisk
 612  63F2 06 02        	ld		b, 2
 613  63F4 CD 33 72     	call	ClearNMsgLines
 614  63F7 18 52        	jr		DiskMenuExit
 615  63F9
 616  63F9              	;Dual drive copy
 617  63F9              CheckDiskMenuDualDrive:
 618  63F9 FE 32        	cp		'2'
 619  63FB 20 0A        	jr		nz, CheckDiskMenuToCOM
 620  63FD CD 2A 69     	call	CopyDisk
 621  6400 06 02        	ld		b, 2
 622  6402 CD 33 72     	call	ClearNMsgLines
 623  6405 18 44        	jr		DiskMenuExit
 624  6407
 625  6407              CheckDiskMenuToCOM:
 626  6407 FE 33        	cp		'3'
 627  6409 20 05        	jr		nz, CheckDiskMenuFromCOM
 628  640B CD E3 69     	call	CopyDiskToCOM
 629  640E 18 3B        	jr		DiskMenuExit
 630  6410
 631  6410              CheckDiskMenuFromCOM:
 632  6410 FE 34        	cp		'4'
 633  6412 20 06        	jr		nz, CheckDiskMenuFormat
 634  6414 CD 3F 6A     	call	CopyDiskFromCOM
 635  6417 C3 C6 5F     	jp		HCRunInitDisk
 636  641A
 637  641A              CheckDiskMenuFormat:
 638  641A FE 35        	cp		'5'
 639  641C C2 2E 60     	jp		nz, HCRunMain
 640  641F
 641  641F 21 86 78     	ld		hl, MsgFormat
 642  6422 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 643  6425 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 644  6427 CD AF 70     	call	PrintStrClr
 645  642A
 646  642A CD 59 68     	call	FormatDisk
 647  642D B7           	or		a
 648  642E CA C6 5F     	jp		z, HCRunInitDisk
 649  6431
 650  6431              	;Display error for format
 651  6431 6F           	ld		l, a
 652  6432 26 00        	ld		h, 0
 653  6434 11 12 77     	ld		de, MsgErrCode
 654  6437 CD C4 67     	call	Byte2Txt
 655  643A 21 07 77     	ld		hl, MsgErr
 656  643D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 657  6440 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 658  6442 CD AF 70     	call	PrintStrClr
 659  6445 CD 4B 70     	call	ReadChar
 660  6448 C3 C6 5F     	jp		HCRunInitDisk
 661  644B
 662  644B              DiskMenuExit:
 663  644B C3 68 61     	jp		ReadKeyLoop
 664  644E
 665  644E              CheckKeyExit:
 666  644E FE 30        	cp		'0'
 667  6450 C2 68 61     	jp		nz, ReadKeyLoop
 668  6453 C3 3A 60     	jp		HCRunEnd
 669  6456              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 670  6456
 671  6456              MoveIt:
 672  6456 CD 7B 71     	call 	MoveCursor
 673  6459 C3 68 61     	jp		ReadKeyLoop
 674  645C
 675  645C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 676  645C
 677  645C
 678  645C              DisplayFilename:
 679  645C 06 0B        	LD		B, NAMELEN
 680  645E              DispLoop:
 681  645E 1A           	LD		A, (DE)
 682  645F
 683  645F              	;clear bit 7
 684  645F CB BF        	RES 	7, A
 685  6461 32 81 5C     	LD		(CODE), A
 686  6464
 687  6464 13           	INC		DE
 688  6465 D5           	PUSH	DE
 689  6466 C5           	PUSH	BC
 690  6467 CD B3 71     		CALL	PrintChar
 691  646A C1           	POP		BC
 692  646B D1           	POP 	DE
 693  646C
 694  646C 21 B0 5C     	LD		HL, COL
 695  646F 34           	INC		(HL)
 696  6470 10 EC        	DJNZ	DispLoop
 697  6472              	;now a name is displayed
 698  6472
 699  6472              	;check bounds
 700  6472 3A B1 5C     	LD		A, (LINE)
 701  6475 3C           	INC		A
 702  6476 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 703  6478 38 0A        	JR		C, LineOK
 704  647A
 705  647A              	;set names column to the next one
 706  647A 3A FC 78     	LD		A, (NameCol)
 707  647D C6 0C        	ADD		NAMELEN + 1
 708  647F 32 FC 78     	LD		(NameCol), A
 709  6482
 710  6482 3E 01        	LD		A, LST_FIRST_LINE
 711  6484              LineOK:
 712  6484 32 B1 5C     	LD		(LINE), A
 713  6487
 714  6487 3A FC 78     	LD		A, (NameCol)
 715  648A 32 B0 5C     	LD		(COL), A
 716  648D
 717  648D C9           	RET
 718  648E
 719  648E
 720  648E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 721  648E
 722  648E              DisplayFilenames:
 723  648E 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 724  6491 ED 53 B0 5C  	ld		(LineCol), de
 725  6495
 726  6495 11 29 79     	ld		de, FileCache
 727  6498 3A FB 78     	ld		a, (FileCnt)
 728  649B B7           	or		a
 729  649C C8           	ret		z
 730  649D
 731  649D 47           	ld		b,	a
 732  649E
 733  649E              DisplayFilenamesLoop:
 734  649E C5           	push	bc
 735  649F D5           		push	de
 736  64A0 CD 5C 64     			call	DisplayFilename
 737  64A3 D1           		pop		de
 738  64A4 EB           		ex		de, hl
 739  64A5 01 19 00     		ld		bc, CACHE_SZ
 740  64A8 09           		add		hl, bc
 741  64A9 EB           		ex		de, hl
 742  64AA C1           	pop		bc
 743  64AB 10 F1        	djnz	DisplayFilenamesLoop
 744  64AD
 745  64AD C9           	ret
 746  64AE
 747  64AE
 748  64AE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 749  64AE              ;Selects only valid filenames (not deleted and only from first extension)
 750  64AE              GetFileNames:
 751  64AE DD 21 47 87  	ld		ix, TrackBuf
 752  64B2 11 29 79     	ld		de, FileCache
 753  64B5 06 80        	ld		b, MAX_EXT_CNT
 754  64B7 AF           	xor		a
 755  64B8 32 FB 78     	ld		(FileCnt), a
 756  64BB 21 00 79     	ld		hl, AUCntUsed
 757  64BE 77           	ld		(hl), a
 758  64BF 23           	inc		hl
 759  64C0 77           	ld		(hl), a
 760  64C1
 761  64C1              StoreFilenamesLoop:
 762  64C1 AF           	xor a
 763  64C2 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 764  64C5 C2 39 65     	jp nz, NextExt
 765  64C8
 766  64C8              	;count AU
 767  64C8 D9           	exx
 768  64C9 E5           	push hl
 769  64CA CD 88 68     		call CheckExtAlloc
 770  64CD EB           		ex de, hl			;save first AU no.
 771  64CE
 772  64CE              		;store disk alocated AU count
 773  64CE 2A 00 79     		ld hl, (AUCntUsed)
 774  64D1 48           		ld c, b
 775  64D2 06 00        		ld b, 0
 776  64D4 09           		add hl, bc
 777  64D5 22 00 79     		ld (AUCntUsed), hl
 778  64D8 E1           	pop hl
 779  64D9 D9           	exx
 780  64DA
 781  64DA AF           	xor	a
 782  64DB DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 783  64DE 20 32        	jr nz, FindExt
 784  64E0
 785  64E0 DD E5        	push ix
 786  64E2 E1           	pop hl
 787  64E3 23           	inc hl					;skip del flag
 788  64E4
 789  64E4 C5           	push bc
 790  64E5 ~            		/*
 791  64E5 ~            		push de
 792  64E5 ~            			push hl
 793  64E5 ~            				ex de, hl
 794  64E5 ~            				call DisplayFilename
 795  64E5 ~            			pop hl
 796  64E5 ~            		pop de
 797  64E5 ~            		*/
 798  64E5 01 0B 00     		ld bc, NAMELEN
 799  64E8 ED B0        		ldir				;save file name
 800  64EA
 801  64EA D9           		exx
 802  64EB D5           		push 	de			;de = first AU
 803  64EC D9           		exx
 804  64ED E1           		pop		hl
 805  64EE EB           		ex		de, hl
 806  64EF 73 23 72 2B  		ld		(hl), de	;save first AU
 807  64F3
 808  64F3 23           		inc		hl
 809  64F4 23           		inc		hl
 810  64F5
 811  64F5 D9           		exx					;save AU cnt for file
 812  64F6 C5           		push	bc
 813  64F7 D9           		exx
 814  64F8 C1           		pop		bc
 815  64F9 71 23 70 2B  		ld		(hl), bc
 816  64FD
 817  64FD 23           		inc		hl
 818  64FE 23           		inc		hl
 819  64FF
 820  64FF              		;xor		a			;make flag 0 to signal that header is not read yet
 821  64FF              		;ld		(hl), a
 822  64FF
 823  64FF 01 0A 00     		ld		bc, HDR_SZ + 1
 824  6502 09           		add		hl, bc
 825  6503
 826  6503 EB           		ex		de, hl
 827  6504 C1           	pop bc
 828  6505
 829  6505
 830  6505 3A FB 78     	ld 		a, (FileCnt)			;inc file counter
 831  6508 3C           	inc		a
 832  6509 32 FB 78     	ld 		(FileCnt), a
 833  650C FE 54        	cp		LST_MAX_FILES
 834  650E 38 29        	jr		c, NextExt
 835  6510 18 34        	jr		GetFileNamesEnd
 836  6512
 837  6512
 838  6512              FindExt:					;BC' = AU cnt for this ext
 839  6512 C5           	push	bc
 840  6513 D5           		push 	de
 841  6514 DD E5        			push	ix
 842  6516 D1           			pop		de
 843  6517 13           			inc		de				;DE = name to find
 844  6518
 845  6518 21 29 79     			ld		hl, FileCache
 846  651B 3A FB 78     			ld		a, (FileCnt)
 847  651E 4F           			ld		c, a
 848  651F CD 2A 6B     			call	FindCache
 849  6522 20 13        			jr		nz, FindExtEnd
 850  6524
 851  6524 01 0D 00     			ld		bc, CACHE_AU_CNT
 852  6527 09           			add		hl, bc
 853  6528 D9           			exx
 854  6529 C5           			push	bc
 855  652A D9           			exx
 856  652B C1           			pop		bc
 857  652C
 858  652C 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 859  6530 EB           			ex		de, hl
 860  6531 09           			add		hl, bc
 861  6532 EB           			ex		de, hl
 862  6533 73 23 72 2B  			ld		(hl), de
 863  6537              FindExtEnd:
 864  6537 D1           		pop		de
 865  6538 C1           	pop		bc
 866  6539
 867  6539              NextExt:
 868  6539 C5           	push bc
 869  653A 01 20 00     		ld bc, EXT_SZ
 870  653D DD 09        		add ix, bc
 871  653F C1           	pop	bc
 872  6540
 873  6540 05           	dec	b
 874  6541 78           	ld	a, b
 875  6542 B7           	or	a
 876  6543 C2 C1 64     	jp	nz, StoreFilenamesLoop
 877  6546              GetFileNamesEnd:
 878  6546 C9           	ret
 879  6547
 880  6547              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 881  6547
 882  6547              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 883  6547              ;IN: HL = file name
 884  6547              HandleFile:
 885  6547              	;Make HL point to the selected file
 886  6547 DD 2A 04 79  	ld		ix, (SelFileCache)
 887  654B DD E5        	push	ix
 888  654D DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 889  6550 B7           		or		a
 890  6551 CC 3B 6B     		call	z, ReadFileHeader
 891  6554
 892  6554 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 893  6557 FE 00        		cp		PROG_TYPE
 894  6559 28 56        		jr		z, HandleFileProg
 895  655B
 896  655B FE 03        		cp		BYTE_TYPE
 897  655D 20 62        		jr		nz, HandleFileText
 898  655F
 899  655F DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 899  6563 66 12
 900  6565 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 901  6568 19           		add		hl, de
 902  6569 7C           		ld		a, h
 903  656A B5           		or		l
 904  656B 28 26        		jr		z, HandleFileSCR
 905  656D
 906  656D
 907  656D              HandleFileCODE:
 908  656D 21 34 77     		ld		hl, MsgLoadingCODE
 909  6570 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 910  6573 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 911  6575 CD AF 70     		call	PrintStrClr
 912  6578
 913  6578              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 914  6578 21 B2 6A     		ld		hl, IF1FileLoad
 915  657B 11 00 5B     		ld		de, PRN_BUF
 916  657E 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 917  6581 ED B0        		ldir
 918  6583              		;ld		a, $C9
 919  6583              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 920  6583
 921  6583 E1           	pop		hl
 922  6584 ED 5B 4A 87  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 923  6588 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 924  6589 C1           	pop		bc						;2nd, 3rd call for error handler
 925  658A C1           	pop		bc
 926  658B ED 43 3D 5C  	ld		(ERRSP), bc
 927  658F D5           	push	de						;push CODE address to return to = start of CODE block
 928  6590 C3 00 5B     	jp		PRN_BUF
 929  6593
 930  6593
 931  6593
 932  6593
 933  6593              HandleFileSCR:
 934  6593 21 25 77     		ld		hl, MsgLoadingSCR
 935  6596 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 936  6599 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 937  659B CD AF 70     		call	PrintStrClr
 938  659E
 939  659E E1           	pop		hl
 940  659F
 941  659F              	IFDEF _REAL_HW_
 942  659F              		;Load to alternate SCREEN$ memory
 943  659F 11 00 C0     		ld		de, HC_VID_BANK1
 944  65A2 CD B2 6A     		call	IF1FileLoad
 945  65A5
 946  65A5              		;Set display to alternate SCREEN$ memory
 947  65A5 3E 08        		ld		a, HC_CFG_VID_C000
 948  65A7 D3 7E        		out 	(HC_CFG_PORT), a
 949  65A9 CD 4B 70     		call	ReadChar
 950  65AC
 951  65AC              		;Set back to regular SCREEN$ memory
 952  65AC 3E 00        		ld		a, HC_CFG_VID_4000
 953  65AE D3 7E        		out 	(HC_CFG_PORT), a
 954  65B0              	ELSE
 955  65B0 ~            		ld		de, HC_VID_BANK0
 956  65B0 ~            		call	IF1FileLoad
 957  65B0 ~            		call	ReadChar
 958  65B0              	ENDIF
 959  65B0
 960  65B0 C9           	ret
 961  65B1
 962  65B1              HandleFileProg:
 963  65B1 21 16 77     		ld		hl, MsgLoadingPrg
 964  65B4 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 965  65B7 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 966  65B9 CD AF 70     		call	PrintStrClr
 967  65BC E1           	pop		hl
 968  65BD CD A2 6B     	call	LoadProgram
 969  65C0 C9           	ret
 970  65C1
 971  65C1
 972  65C1              HandleFileText:
 973  65C1 E1           	pop		hl
 974  65C2
 975  65C2
 976  65C2              ViewFile:
 977  65C2 CD 67 70     	call	ClrScr
 978  65C5 21 00 00     	ld		hl, 0
 979  65C8 22 0C 79     	ld		(FilePosRead), hl
 980  65CB              ViewFileLoop:
 981  65CB 2A 04 79     	ld		hl, (SelFileCache)
 982  65CE 3A ED 6B     	ld 		a, (RWTSDrive)
 983  65D1 3C           	inc		a
 984  65D2 CD 98 6F     	call	ReadFileSection					;DE = last address read
 985  65D5 21 47 87     	ld		hl, FileData
 986  65D8              	;Calculate size of read buffer
 987  65D8 E5           	push	hl
 988  65D9 EB           		ex	de, hl
 989  65DA B7           		or	a
 990  65DB ED 52        		sbc	hl, de
 991  65DD 44           		ld	b, h
 992  65DE 4B           		ld	c, e
 993  65DF E1           	pop		hl
 994  65E0 CD 4A 72     	call	InitViewer
 995  65E3 CD A8 72     	call	PrintLoop
 996  65E6              	;Check if exited viewer because user wanted to.
 997  65E6 C8           	ret		z
 998  65E7
 999  65E7              	;Check if file ended -> we need to load the next file segment.
1000  65E7 3A 09 79     	ld		a, (CopyFileRes)
1001  65EA B7           	or		a
1002  65EB 28 DE        	jr		z, ViewFileLoop
1003  65ED C3 E3 72     	jp		PrintLoop2
1004  65F0 C9           	ret
1005  65F1
1006  65F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1007  65F1
1008  65F1
1009  65F1              DisplayFileInfo:
1010  65F1 2A 04 79     	ld		hl, (SelFileCache)
1011  65F4 E5           	push	hl
1012  65F5              		;disk size - at least 2KB ==1  AU
1013  65F5 01 0D 00     		ld		bc, CACHE_AU_CNT
1014  65F8 09           		add		hl, bc
1015  65F9 5E 23 56 2B  		ld		de, (hl)
1016  65FD EB           		ex		de, hl
1017  65FE              		;*2, since one block (AU) is 2KB.
1018  65FE CB 15        		rl	l
1019  6600 CB 14        		rl	h
1020  6602
1021  6602 11 4D 77     		ld		de, MsgFileSzDskN
1022  6605 CD B9 67     		call	Word2Txt
1023  6608 21 44 77     		ld		hl, MsgFileSzDsk
1024  660B 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1025  660E CD 87 70     		call	PrintStr
1026  6611 E1           	pop		hl
1027  6612 E5           	push	hl
1028  6613              		;attributes
1029  6613 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1030  6616 09           		add		hl, bc
1031  6617 EB           		ex		de, hl
1032  6618 21 5D 77     		ld		hl, MsgFileAttrN
1033  661B 1A           		ld		a, (de)
1034  661C E6 80        		and		%10000000
1035  661E 28 14        		jr		z, NotRO
1036  6620
1037  6620 01 52 2F     		ld		bc, '/R'
1038  6623 71 23 70 2B  		ld		(hl), bc
1039  6627 23           		inc		hl
1040  6628 23           		inc		hl
1041  6629 01 4F 2C     		ld		bc, ',O'
1042  662C 71 23 70 2B  		ld		(hl), bc
1043  6630 23           		inc		hl
1044  6631 23           		inc		hl
1045  6632 18 12        		jr		CheckSys
1046  6634              NotRO:
1047  6634 01 2D 2D     		ld		bc, '--'
1048  6637 71 23 70 2B  		ld		(hl), bc
1049  663B 23           		inc		hl
1050  663C 23           		inc		hl
1051  663D 01 2D 2C     		ld		bc, ',-'
1052  6640 71 23 70 2B  		ld		(hl), bc
1053  6644 23           		inc		hl
1054  6645 23           		inc		hl
1055  6646
1056  6646              CheckSys:
1057  6646 13           		inc		de
1058  6647 1A           		ld		a, (de)
1059  6648 E6 80        		and		%10000000
1060  664A 28 0E        		jr		z, NotSYS
1061  664C
1062  664C 01 48 49     		ld		bc, 'IH'
1063  664F 71 23 70 2B  		ld		(hl), bc
1064  6653 23           		inc		hl
1065  6654 23           		inc		hl
1066  6655 3E C4        		ld		a, 'D' + $80
1067  6657 77           		ld		(hl), a
1068  6658 18 0C        		jr		AttrEnd
1069  665A              NotSYS:
1070  665A 01 2D 2D     		ld		bc, '--'
1071  665D 71 23 70 2B  		ld		(hl), bc
1072  6661 23           		inc		hl
1073  6662 23           		inc		hl
1074  6663 3E AD        		ld		a, '-' + $80
1075  6665 77           		ld		(hl), a
1076  6666              AttrEnd:
1077  6666 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1078  6669 21 54 77     		ld		hl, MsgFileAttr
1079  666C CD 87 70     		call	PrintStr
1080  666F DD E1        	pop		ix
1081  6671 DD E5        	push	ix
1082  6673 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1083  6676 B7           		or		a
1084  6677 CA 14 67             jp		z, HeadNotRead
1085  667A
1086  667A DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1087  667D DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1088  6680 CA 14 67             jp		z, HeadNotRead
1089  6683
1090  6683 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1091  6686 FE 00        		cp		PROG_TYPE
1092  6688 20 0B        		jr		nz, CheckNoArr
1093  668A
1094  668A 21 77 77     		ld		hl, MsgFileTypePrg
1095  668D 11 6D 77     		ld		de, MsgFileTypeN
1096  6690 CD 5D 67     		call	MoveMsg
1097  6693 18 4F        		jr		PrepFileLen
1098  6695
1099  6695              CheckNoArr:
1100  6695 FE 01        		cp		NUMB_TYPE
1101  6697 20 0B        		jr		nz, CheckChrArr
1102  6699
1103  6699 21 93 77     		ld		hl, MsgFileTypeNoA
1104  669C 11 6D 77     		ld		de, MsgFileTypeN
1105  669F CD 5D 67     		call	MoveMsg
1106  66A2 18 40        		jr		PrepFileLen
1107  66A4
1108  66A4              CheckChrArr:
1109  66A4 FE 02        		cp		CHAR_TYPE
1110  66A6 20 0B        		jr		nz, CheckByte
1111  66A8
1112  66A8 21 8C 77     		ld		hl, MsgFileTypeChrA
1113  66AB 11 6D 77     		ld		de, MsgFileTypeN
1114  66AE CD 5D 67     		call	MoveMsg
1115  66B1 18 31        		jr		PrepFileLen
1116  66B3
1117  66B3              CheckByte:
1118  66B3 FE 03        		cp		BYTE_TYPE
1119  66B5 20 24        		jr		nz, CheckText
1120  66B7
1121  66B7 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1121  66BB 66 12
1122  66BD 01 00 E5     		ld		bc, -SCR_LEN
1123  66C0 09           		add		hl, bc
1124  66C1 7C           		ld		a, h
1125  66C2 B5           		or		l
1126  66C3 20 0B        		jr		nz, NotScr
1127  66C5
1128  66C5 21 85 77     		ld		hl, MsgFileTypeSCR
1129  66C8 11 6D 77     		ld		de, MsgFileTypeN
1130  66CB CD 5D 67     		call	MoveMsg
1131  66CE 18 14        		jr		PrepFileLen
1132  66D0              NotScr:
1133  66D0 21 7E 77     		ld		hl, MsgFileTypeByte
1134  66D3 11 6D 77     		ld		de, MsgFileTypeN
1135  66D6 CD 5D 67     		call	MoveMsg
1136  66D9 18 09        		jr		PrepFileLen
1137  66DB
1138  66DB              CheckText:
1139  66DB 21 9A 77     		ld		hl, MsgFileTypeText
1140  66DE 11 6D 77     		ld		de, MsgFileTypeN
1141  66E1 CD 5D 67     		call	MoveMsg
1142  66E4
1143  66E4              PrepFileLen:
1144  66E4              		;File len
1145  66E4 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1146  66E7 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1147  66EA              PrepFileLenText:
1148  66EA 11 B1 77     		ld		de, MsgFileLenN
1149  66ED CD B9 67     		call	Word2Txt
1150  66F0 26 C2        		ld		h, 'B' | $80
1151  66F2 2E 20        		ld		l, ' '
1152  66F4 22 B6 77     		ld		(MsgFileLenN + 5), hl
1153  66F7
1154  66F7 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1155  66FA FE 00        		cp		PROG_TYPE
1156  66FC 28 06        		jr		z, PrintProgStart
1157  66FE
1158  66FE FE 03        		cp		BYTE_TYPE
1159  6700 28 0A        		jr		z, PrintByteStart
1160  6702
1161  6702 18 22        		jr		PrintStartNotRead
1162  6704
1163  6704              PrintProgStart:
1164  6704 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1165  6707 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1166  670A 18 25        		jr		PrintStart
1167  670C
1168  670C              PrintByteStart:
1169  670C DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1170  670F DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1171  6712 18 1D        		jr		PrintStart
1172  6714
1173  6714              HeadNotRead:
1174  6714 21 A1 77             ld        hl, MsgNA
1175  6717 11 6D 77             ld        de, MsgFileTypeN
1176  671A CD 5D 67             call    MoveMsg
1177  671D
1178  671D 21 A1 77     		ld		hl, MsgNA
1179  6720 11 B1 77     		ld		de, MsgFileLenN
1180  6723 CD 5D 67     		call	MoveMsg
1181  6726
1182  6726              PrintStartNotRead:
1183  6726 21 A1 77     		ld		hl, MsgNA
1184  6729 11 C1 77     		ld		de, MsgFileStartN
1185  672C CD 5D 67     		call	MoveMsg
1186  672F 18 0E        		jr		PrintStartStr
1187  6731
1188  6731              PrintStart:
1189  6731 1E 20        	ld		e, ' '
1190  6733 16 A0        	ld		d, ' ' | $80
1191  6735 ED 53 C6 77  	ld		(MsgFileStartN + 5), de
1192  6739 11 C1 77     	ld		de, MsgFileStartN
1193  673C CD B9 67     	call	Word2Txt
1194  673F              PrintStartStr:
1195  673F 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1196  6742 21 B8 77     	ld		hl, MsgFileStart
1197  6745 CD 87 70     	call	PrintStr
1198  6748
1199  6748 DD E1        	pop		ix
1200  674A 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1201  674D 21 64 77     	ld		hl, MsgFileType
1202  6750 CD 87 70     	call	PrintStr
1203  6753
1204  6753 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1205  6756 21 A8 77     	ld		hl, MsgFileLen
1206  6759 CD 87 70     	call	PrintStr
1207  675C
1208  675C C9           	ret
1209  675D
1210  675D              MoveMsg:
1211  675D 01 07 00     	ld		bc, 7
1212  6760 ED B0        	ldir
1213  6762 C9           	ret
1214  6763
1215  6763              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1216  6763
1217  6763              ReadAllHeaders:
1218  6763 21 C8 77     	ld		hl, MsgReadingExt
1219  6766 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1220  6769 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1221  676B CD AF 70     	call	PrintStrClr
1222  676E
1223  676E CD 57 61     	call	CalcFileCache
1224  6771
1225  6771 3A FD 78     	ld		a, (SelFile)
1226  6774 47           	ld		b, a
1227  6775 3A FB 78     	ld		a, (FileCnt)
1228  6778 90           	sub		b
1229  6779 B7           	or		a
1230  677A C8           	ret		z
1231  677B
1232  677B 47           	ld		b, a
1233  677C
1234  677C DD 2A 04 79  	ld		ix, (SelFileCache)
1235  6780              NextFile:
1236  6780 C5           	push	bc
1237  6781 CD 3B 6B     		call	ReadFileHeader
1238  6784 01 19 00     		ld		bc, CACHE_SZ
1239  6787 DD 09        		add		ix, bc
1240  6789 DD E5        		push	ix
1241  678B CD 57 61     			call	CalcFileCache
1242  678E CD F1 65     			call	DisplayFileInfo
1243  6791 DD E1        		pop		ix
1244  6793
1245  6793 CD 4E 70     		call	KbdHit
1246  6796 38 03        		jr		c, AKey
1247  6798 C1           	pop		bc
1248  6799 18 15        	jr		ReadAllHeadersEnd
1249  679B
1250  679B              AKey:
1251  679B 3A FD 78     		ld		a, (SelFile)
1252  679E 3C           		inc		a
1253  679F 47           		ld		b, a
1254  67A0 3A FB 78     		ld		a, (FileCnt)
1255  67A3 B8           		cp		b
1256  67A4 28 10        		jr		z, DontInc
1257  67A6 78           		ld		a, b
1258  67A7 32 FD 78     		ld		(SelFile), a
1259  67AA CD 7B 71     		call	MoveCursor
1260  67AD C1           	pop		bc
1261  67AE 10 D0        	djnz	NextFile
1262  67B0
1263  67B0              ReadAllHeadersEnd:
1264  67B0 06 01        	ld		b, 1
1265  67B2 CD 33 72     	call	ClearNMsgLines
1266  67B5 C9           	ret
1267  67B6
1268  67B6              DontInc:
1269  67B6 C1           	pop		bc
1270  67B7 18 F7        	jr		ReadAllHeadersEnd
1271  67B9
1272  67B9
1273  67B9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1274  67B9
1275  67B9              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 67B9              	ifndef	_HCCFG_
   2+ 67B9              	define	_HCCFG_
   3+ 67B9
   4+ 67B9              ;HC specific code, for configuration
   5+ 67B9
   6+ 67B9              HC_CFG_PORT			EQU	$7E
   7+ 67B9              HC_FLOPPY_PORT		EQU 7
   8+ 67B9
   9+ 67B9              ;BASIC/CPM ROM selection
  10+ 67B9              HC_CFG_ROM_BAS		EQU	%0
  11+ 67B9              HC_CFG_ROM_CPM		EQU	%1
  12+ 67B9
  13+ 67B9              ;Address for ROM paging: 0 or $E000
  14+ 67B9              HC_CFG_ROM_0000		EQU %00
  15+ 67B9              HC_CFG_ROM_E000		EQU %10
  16+ 67B9
  17+ 67B9              ;Cfg. port Enable/Disable
  18+ 67B9              HC_CFG_PORT_DIS		EQU %000
  19+ 67B9              HC_CFG_PORT_EN		EQU	%100
  20+ 67B9
  21+ 67B9              ;Video memory bank: $4000 or $C000
  22+ 67B9              HC_CFG_VID_4000		EQU	%0000
  23+ 67B9              HC_CFG_VID_C000		EQU	%1000
  24+ 67B9
  25+ 67B9
  26+ 67B9              ;Standar BASIC config
  27+ 67B9              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 67B9              ;Standar CP/M config
  29+ 67B9              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 67B9
  31+ 67B9
  32+ 67B9              HC_VID_BANK0		EQU	$4000
  33+ 67B9              HC_VID_BANK1		EQU	$C000
  34+ 67B9
  35+ 67B9              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 67B9              ;Info from Rares Atodiresei.
  37+ 67B9              IsDrive2_80Tracks:
  38+ 67B9              	IFUSED
  39+ 67B9 ~            	in	a, (HC_FLOPPY_PORT)
  40+ 67B9 ~            	and %10
  41+ 67B9 ~            	ret
  42+ 67B9              	ENDIF
  43+ 67B9
  44+ 67B9              	endif
# file closed: hccfg.asm
1276  67B9              	include "if1.asm"
# file opened: if1.asm
   1+ 67B9              ;HC IF1 routines and constants
   2+ 67B9
   3+ 67B9              ;IF1 routines error codes, also returned by BASIC commands
   4+ 67B9              ;12 = Writing to a 'read' file
   5+ 67B9              ;13 = Reading a 'write' file
   6+ 67B9              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 67B9              ;15 = Disk full (disk or catalog full)
   8+ 67B9              ;16 = Disk error (hardware error)
   9+ 67B9              ;17 = File not found
  10+ 67B9              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 67B9              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 67B9
  13+ 67B9              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 67B9              ;00h = OK
  15+ 67B9              ;08h = cannot format disk
  16+ 67B9              ;10h = disk protected (read-only?)
  17+ 67B9              ;20h = volume error
  18+ 67B9              ;40h = drive error
  19+ 67B9              ;80h = reading error
  20+ 67B9              ;Codes I encountered:
  21+ 67B9              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 67B9
  23+ 67B9
  24+ 67B9              	ifndef	_DISK_
  25+ 67B9              	define	_DISK_
  26+ 67B9
  27+ 67B9              	include	"math.asm"
# file opened: math.asm
   1++67B9              	ifndef	_MATH_
   2++67B9              	define	_MATH_
   3++67B9
   4++67B9              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++67B9              ;http://map.tni.nl/sources/external/z80bits.html
   6++67B9
   7++67B9
   8++67B9              Word2Txt:
   9++67B9              	IFUSED
  10++67B9 D5           	push	de
  11++67BA CD DA 67     		call	Word2Txt_
  12++67BD D1           	pop		de
  13++67BE
  14++67BE 06 04        	ld		b, 4
  15++67C0 CD CF 67     	call	StrippLeading0
  16++67C3 C9           	ret
  17++67C4
  18++67C4              Byte2Txt:
  19++67C4 D5           	push	de
  20++67C5 CD E6 67     		call	Byte2Txt_
  21++67C8 D1           	pop		de
  22++67C9
  23++67C9 06 02        	ld		b, 2
  24++67CB CD CF 67     	call	StrippLeading0
  25++67CE C9           	ret
  26++67CF              	ENDIF
  27++67CF
  28++67CF
  29++67CF              StrippLeading0:
  30++67CF 1A           	ld		a, (de)
  31++67D0 FE 31        	cp		'1'
  32++67D2 D0           	ret		nc
  33++67D3
  34++67D3 3E 20        	ld		a, ' '
  35++67D5 12           	ld		(de), a
  36++67D6 13           	inc		de
  37++67D7 10 F6        	djnz	StrippLeading0
  38++67D9 C9           	ret
  39++67DA
  40++67DA
  41++67DA              ;Converts the number in HL to ASCII in decimal string at DE
  42++67DA              Word2Txt_:
  43++67DA 01 F0 D8     	ld bc, -10000
  44++67DD CD F5 67     	call DigitLoop
  45++67E0 01 18 FC     	ld bc, -1000
  46++67E3 CD F5 67     	call DigitLoop
  47++67E6              Byte2Txt_:
  48++67E6 01 9C FF     	ld bc, -100
  49++67E9 CD F5 67     	call DigitLoop
  50++67EC 01 F6 FF     	ld bc, -10
  51++67EF CD F5 67     	call DigitLoop
  52++67F2 01 FF FF     	ld bc, -1
  53++67F5
  54++67F5              DigitLoop:
  55++67F5 3E 2F        	ld	a, '0' - 1
  56++67F7              DivNrLoop:
  57++67F7 3C           	inc	a			;increase reminder
  58++67F8 09           	add	hl, bc		;substract divizor
  59++67F9 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++67FB ED 42        	sbc	hl, bc		;nope, restore
  61++67FD
  62++67FD 12           	ld (de), a
  63++67FE 13           	inc de
  64++67FF C9           	ret
  65++6800
  66++6800
  67++6800              ;Input: HL = Dividend, C = Divisor
  68++6800              ;Output: HL = Quotient, A = Remainder
  69++6800              ;Warning: doesn't work with divisor >= $80
  70++6800              Div:
  71++6800              	IFUSED
  72++6800 AF           	xor a
  73++6801 06 10        	ld b, 16
  74++6803
  75++6803              DivLoop:
  76++6803 29           	add	hl,hl
  77++6804 17           	rla
  78++6805 B9           	cp	c
  79++6806 38 02        	jr	c, NoSub
  80++6808 91           	sub	c
  81++6809 2C           	inc	l
  82++680A              NoSub:
  83++680A 10 F7        	djnz DivLoop
  84++680C
  85++680C C9           	ret
  86++680D              	ENDIF
  87++680D
  88++680D              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++680D              ;Output: A:C = Quotient, HL = Remainder
  90++680D              Div2:
  91++680D 21 00 00     	ld hl, 0
  92++6810 06 10        	ld b, 16
  93++6812              Div2Loop:
  94++6812 CB 31        	sll c		; unroll 16 times
  95++6814 17           	rla			; ...
  96++6815 ED 6A        	adc	hl,hl		; ...
  97++6817 ED 52        	sbc	hl,de		; ...
  98++6819 30 02        	jr	nc,$+4		; ...
  99++681B 19           	add	hl,de		; ...
 100++681C 0D           	dec	c		; ...
 101++681D 10 F3        	djnz Div2Loop
 102++681F C9           	ret
 103++6820
 104++6820
 105++6820              ;Input: A = Multiplier, DE = Multiplicand
 106++6820              ;Output: A:HL = Product
 107++6820              Mul:
 108++6820              	IFUSED
 109++6820 21 00 00     	ld hl, 0
 110++6823 01 00 07     	ld bc, $0700
 111++6826
 112++6826 87           	add	a, a		; optimised 1st iteration
 113++6827 30 02        	jr	nc, MulLoop
 114++6829 62           	ld	h, d
 115++682A 6B           	ld	l, e
 116++682B
 117++682B              MulLoop:
 118++682B 29           	add	hl,hl
 119++682C 17           	rla
 120++682D 30 02        	jr	nc, NoAdd
 121++682F 19           	add	hl,de
 122++6830 89           	adc	a,c
 123++6831              NoAdd:
 124++6831 10 F8        	djnz MulLoop
 125++6833
 126++6833 C9           	ret
 127++6834              	ENDIF
 128++6834
 129++6834              	endif
# file closed: math.asm
  28+ 6834
  29+ 6834              DRIVE_CUR_BAS	EQU 0
  30+ 6834              DRIVE_A_BAS		EQU	1
  31+ 6834              DRIVE_B_BAS		EQU	2
  32+ 6834              DRIVE_A_CPM		EQU	0
  33+ 6834              DRIVE_B_CPM		EQU	1
  34+ 6834              ;Disk geometry stuff
  35+ 6834              SPT				EQU	16			;sectors per track
  36+ 6834              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6834              TRACK_CNT		EQU	80			;track count
  38+ 6834              HEAD_CNT		EQU	2			;disk face count
  39+ 6834              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6834              EXT_SZ			EQU	32			;directory entry size
  41+ 6834              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6834              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6834              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6834              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6834              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6834              REC_SZ			EQU 128			;cp/m record size
  47+ 6834              DEL_MARKER		EQU	$E5
  48+ 6834
  49+ 6834
  50+ 6834              ;Extension structure (directory entry)
  51+ 6834              EXT_DEL_FLAG	EQU	0
  52+ 6834              EXT_NAME		EQU 1
  53+ 6834              EXT_IDX			EQU 12
  54+ 6834              EXT_S1			EQU 13
  55+ 6834              EXT_S2			EQU 14
  56+ 6834              EXT_RC			EQU	15
  57+ 6834              EXT_AU0			EQU	16
  58+ 6834              EXT_AU1			EQU	18
  59+ 6834              EXT_AU2			EQU	20
  60+ 6834              EXT_AU3			EQU	22
  61+ 6834              EXT_AU4			EQU	24
  62+ 6834              EXT_AU5			EQU	26
  63+ 6834              EXT_AU6			EQU	28
  64+ 6834              EXT_AU7			EQU	30
  65+ 6834              EXT_SIZE		EQU 32
  66+ 6834
  67+ 6834              ;FCB structure
  68+ 6834              FCB_DRIVE		EQU 0
  69+ 6834              FCB_NAME		EQU EXT_NAME
  70+ 6834              FCB_EX_IDX		EQU EXT_IDX
  71+ 6834              FCB_S1			EQU EXT_S1
  72+ 6834              FCB_S2			EQU EXT_S2
  73+ 6834              FCB_RC			EQU	EXT_RC
  74+ 6834              FCB_AU			EQU	EXT_AU0
  75+ 6834              FCB_CR			EQU	32
  76+ 6834              FCB_R0			EQU 33
  77+ 6834              FCB_R1			EQU 34
  78+ 6834              FCB_R2			EQU 35
  79+ 6834              FCB_SIZE		EQU 36
  80+ 6834
  81+ 6834
  82+ 6834
  83+ 6834              ;System variables for disk
  84+ 6834              DSTR1			EQU	$5CD6		;drive
  85+ 6834              FSTR1			EQU	$5CDC		;file name
  86+ 6834              NSTR1			EQU	$5CDA		;name length
  87+ 6834              HD11			EQU	$5CED		;BDOS argument
  88+ 6834              COPIES			EQU	$5CEF		;BDOS function
  89+ 6834
  90+ 6834              ERRSP			EQU $5C3D
  91+ 6834              ERRNR			EQU $5C3A
  92+ 6834              ERRMSG			EQU	$0260
  93+ 6834
  94+ 6834              PROG			EQU $5C53
  95+ 6834              VARS			EQU	$5C4B
  96+ 6834              STKEND			EQU	$5C65
  97+ 6834
  98+ 6834              PRN_BUF			EQU	23296
  99+ 6834
 100+ 6834              REPDEL			EQU	23561
 101+ 6834              REPPER			EQU	23562
 102+ 6834              PIP				EQU	23609
 103+ 6834
 104+ 6834
 105+ 6834              ;RWTS routine commands
 106+ 6834              RWTS_CMD_SEEK	EQU	0			;position head
 107+ 6834              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6834              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6834              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6834
 111+ 6834
 112+ 6834              ;File name stuff
 113+ 6834              NAMELEN			EQU	11			;name length
 114+ 6834              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6834              SYS_POS			EQU	9			;system attribute position in name
 116+ 6834
 117+ 6834              ;File types (first byte in header)
 118+ 6834              PROG_TYPE		EQU	0			;program
 119+ 6834              NUMB_TYPE		EQU	1			;number array
 120+ 6834              CHAR_TYPE		EQU	2			;char array
 121+ 6834              BYTE_TYPE		EQU	3			;bytes
 122+ 6834              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6834
 124+ 6834              ;File header offsets
 125+ 6834              HDR_TYPE		EQU	0
 126+ 6834              HDR_LEN			EQU 1
 127+ 6834              HDR_ADDR		EQU 3
 128+ 6834              HDR_PLEN		EQU	5
 129+ 6834              HDR_LINE		EQU 7
 130+ 6834              HDR_SZ			EQU	9
 131+ 6834
 132+ 6834              ;BASIC disk channel structure
 133+ 6834              CH_RW_FLAG		EQU 11
 134+ 6834              CH_FCB			EQU	12
 135+ 6834              CH_DATA			EQU	50
 136+ 6834              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6834
 138+ 6834              CACHE_NAME		EQU	0					;11B
 139+ 6834              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6834              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6834              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6834              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6834              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6834
 145+ 6834              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6834
 147+ 6834              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6834              IF1Init:
 149+ 6834 CF           	rst		08
 150+ 6835 31           	defb	49		;create system variables
 151+ 6836 C9           	ret
 152+ 6837
 153+ 6837              ;ReadWriteTrackSector
 154+ 6837              ;A=command: 0, 1, 2, 4
 155+ 6837              RWTS:
 156+ 6837 32 F7 6B     	ld (RWTSCmd), a
 157+ 683A 21 EC 6B     	ld hl, RWTSParams
 158+ 683D 22 ED 5C     	ld (HD11), hl
 159+ 6840 CF           	rst 08
 160+ 6841 3A           	DEFB 58
 161+ 6842 C9           	ret
 162+ 6843
 163+ 6843
 164+ 6843              ;D = sector, E = track
 165+ 6843              ;HL = dma
 166+ 6843              ReadOneDiskSector:
 167+ 6843 22 F1 6B     	ld (RWTSDMA), hl
 168+ 6846 ED 53 EF 6B  	ld (RWTSTrack), de
 169+ 684A              	;ld (RWTSDrive), a
 170+ 684A 3E 01        	ld a, RWTS_CMD_READ
 171+ 684C 18 E9        	jr	RWTS
 172+ 684E
 173+ 684E              ;D = sector, E = track
 174+ 684E              ;HL = dma
 175+ 684E              WriteOneDiskSector:
 176+ 684E 22 F1 6B     	ld (RWTSDMA), hl
 177+ 6851 ED 53 EF 6B  	ld (RWTSTrack), de
 178+ 6855              	;ld (RWTSDrive), a
 179+ 6855 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6857 18 DE        	jr	RWTS
 181+ 6859
 182+ 6859              FormatDisk:
 183+ 6859 21 47 87     	ld		hl, DataBuf
 184+ 685C 36 E5        	ld		(hl), DEL_MARKER
 185+ 685E 22 F1 6B     	ld 		(RWTSDMA), hl
 186+ 6861 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 6863 CD 37 68     	call	RWTS
 188+ 6866 3A F8 6B     	ld		a, (RWTSRes)
 189+ 6869 C9           	ret
 190+ 686A
 191+ 686A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 686A
 193+ 686A              ;Allocation unit no. to track/sector
 194+ 686A              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 686A              ;IN:  HL=alloc. unit no.
 196+ 686A              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 686A              AU2TS:
 198+ 686A 0E 02        	ld c, SPT/SPAL
 199+ 686C CD 00 68     	call Div					;A = sector
 200+ 686F F5           	push af
 201+ 6870 ~            		/*
 202+ 6870 ~            		ld c, HEAD_CNT
 203+ 6870 ~            		call Div				;L = track, A = head (0 or 1)
 204+ 6870 ~            		*/
 205+ 6870 AF           		xor a
 206+ 6871 CB 1C        		rr h
 207+ 6873 CB 1D        		rr l
 208+ 6875 CB 1F        		rr a
 209+ 6877
 210+ 6877 4D           		ld c, l
 211+ 6878 06 00        		ld b, 0
 212+ 687A B7           		or a
 213+ 687B 28 02        		jr z, Track0
 214+ 687D 06 10        		ld b, SPT
 215+ 687F              Track0:
 216+ 687F F1           	pop af
 217+ 6880 B7           	or a
 218+ 6881 28 02        	jr z, FirstAU
 219+ 6883 3E 08        	ld a, SPAL
 220+ 6885              FirstAU:
 221+ 6885 80           	add a, b
 222+ 6886 47           	ld  b, a
 223+ 6887 C9           	ret
 224+ 6888
 225+ 6888              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 6888
 227+ 6888              ;Checks the allocation units number used in extension
 228+ 6888              ;IN:	IX = extension addr
 229+ 6888              ;OUT:	B = no. of allocation units used
 230+ 6888              ;		C = no. of records used in ext.
 231+ 6888              ;		HL = first alloc. unit no.
 232+ 6888              ;		DE = last alloc. unit no.
 233+ 6888              CheckExtAlloc:
 234+ 6888 DD E5        	push ix
 235+ 688A 01 0F 00     		ld bc, EXT_RC
 236+ 688D DD 09        		add ix, bc
 237+ 688F DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 6892 DD 23        		inc ix
 239+ 6894 DD 6E 00     		ld l, (ix)
 240+ 6897 DD 66 01     		ld h, (ix + 1)
 241+ 689A 06 08        		ld b, EXT_AU_CNT
 242+ 689C              CheckAU:
 243+ 689C DD 7E 00     		ld a, (ix)
 244+ 689F DD B6 01     		or (ix + 1)
 245+ 68A2 28 0C        		jr z, CheckAUEnd
 246+ 68A4 DD 5E 00     		ld e, (ix)
 247+ 68A7 DD 56 01     		ld d, (ix + 1)
 248+ 68AA DD 23        		inc ix
 249+ 68AC DD 23        		inc ix
 250+ 68AE 10 EC        		djnz CheckAU
 251+ 68B0              CheckAUEnd:
 252+ 68B0 3E 08        		ld a, EXT_AU_CNT
 253+ 68B2 90           		sub b
 254+ 68B3 47           		ld b, a
 255+ 68B4 DD E1        	pop ix
 256+ 68B6 C9           	ret
 257+ 68B7
 258+ 68B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 68B7
 260+ 68B7              ;Input: TrackBuffer
 261+ 68B7              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 68B7              ReadUsedBlocksList:
 263+ 68B7 DD 21 47 87  	ld		ix, TrackBuf			;source buffer
 264+ 68BB 21 5D 81     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 68BE ED 4B 02 79  	ld		bc, (AUCntMaxFree)		;loop counter
 266+ 68C2 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 68C5 73           	ld		(hl), e
 268+ 68C6 23           	inc		hl
 269+ 68C7 72           	ld		(hl), d
 270+ 68C8 23           	inc		hl
 271+ 68C9
 272+ 68C9              	;Add blocks 0 and 1 for directory
 273+ 68C9 11 00 00     	ld		de, 0
 274+ 68CC 73           	ld		(hl), e
 275+ 68CD 23           	inc		hl
 276+ 68CE 72           	ld		(hl), d
 277+ 68CF 23           	inc		hl
 278+ 68D0
 279+ 68D0 13           	inc		de
 280+ 68D1 73           	ld		(hl), e
 281+ 68D2 23           	inc		hl
 282+ 68D3 72           	ld		(hl), d
 283+ 68D4 23           	inc		hl
 284+ 68D5
 285+ 68D5              ReadUsedBlocksLoop:
 286+ 68D5 AF           	xor		a
 287+ 68D6 DD BE 00     	cp		(ix)
 288+ 68D9 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 68DB
 290+ 68DB DD E5        	push	ix
 291+ 68DD C5           	push	bc
 292+ 68DE 06 08        		ld		b, EXT_AU_CNT
 293+ 68E0 11 10 00     		ld		de, EXT_AU0
 294+ 68E3 DD 19        		add		ix, de
 295+ 68E5
 296+ 68E5              ReadUsedBlocksLoop2:
 297+ 68E5 DD 5E 00     		ld		e, (ix)
 298+ 68E8 DD 56 01     		ld		d, (ix+1)
 299+ 68EB 7B           		ld		a, e
 300+ 68EC B2           		or		d
 301+ 68ED 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 68EF
 303+ 68EF 73           		ld		(hl), e
 304+ 68F0 23           		inc		hl
 305+ 68F1 72           		ld		(hl), d
 306+ 68F2 23           		inc		hl
 307+ 68F3
 308+ 68F3 DD 23        		inc		ix
 309+ 68F5 DD 23        		inc		ix
 310+ 68F7
 311+ 68F7 ED 5B 5D 81  		ld		de, (UsedBlockListCnt)
 312+ 68FB 13           		inc		de
 313+ 68FC ED 53 5D 81  		ld		(UsedBlockListCnt), de
 314+ 6900
 315+ 6900 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 6902
 317+ 6902
 318+ 6902              ReadUsedBlocksSkip:
 319+ 6902 C1           	pop		bc
 320+ 6903 DD E1        	pop		ix
 321+ 6905              ReadUsedBlocksSkip2:
 322+ 6905 11 20 00     	ld		de, EXT_SZ
 323+ 6908 DD 19        	add		ix, de
 324+ 690A
 325+ 690A 0B           	dec		bc
 326+ 690B 78           	ld		a, b
 327+ 690C B1           	or		c
 328+ 690D 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 690F
 330+ 690F C9           	ret
 331+ 6910
 332+ 6910              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 6910              ;Reads 8 sectors for an AU
 334+ 6910              ;HL = block number, DE = destination buffer
 335+ 6910              ReadFSBlock:
 336+ 6910 D5           	push	de
 337+ 6911 CD 6A 68     		call	AU2TS		;B=sector, C=track
 338+ 6914 E1           	pop		hl				;HL=dest
 339+ 6915
 340+ 6915 50           	ld		d, b
 341+ 6916 59           	ld		e, c
 342+ 6917 06 08        	ld		b, SPAL
 343+ 6919
 344+ 6919 CD F8 6A     	call	ReadDiskSectors
 345+ 691C C9           	ret
 346+ 691D
 347+ 691D
 348+ 691D              ;Write 8 sectors for an AU
 349+ 691D              ;HL = block number, DE = source buffer
 350+ 691D              WriteFSBlock:
 351+ 691D D5           	push	de
 352+ 691E CD 6A 68     		call	AU2TS		;B=sector, C=track
 353+ 6921 E1           	pop		hl				;HL=dest
 354+ 6922
 355+ 6922 50           	ld		d, b
 356+ 6923 59           	ld		e, c
 357+ 6924 06 08        	ld		b, SPAL
 358+ 6926
 359+ 6926 CD 0B 6B     	call	WriteDiskSectors
 360+ 6929 C9           	ret
 361+ 692A
 362+ 692A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 692A              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 692A              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 692A              CopyDisk:
 366+ 692A              	;Get list of used blocks in current disk, max 632 bytes
 367+ 692A CD B7 68     	call	ReadUsedBlocksList
 368+ 692D DD 21 5F 81  	ld		ix, UsedBlockListBlk
 369+ 6931
 370+ 6931              CopyDiskLoop:
 371+ 6931 2A 5D 81     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 6934 11 93 78     	ld		de, MsgBlocksLeft
 373+ 6937 CD C4 67     	call	Byte2Txt
 374+ 693A 21 93 78     	ld		hl, MsgBlocksLeft
 375+ 693D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 6940 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 6942 CD AF 70     	call	PrintStrClr
 378+ 6945
 379+ 6945              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 6945 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 6948 ED 4B 5D 81  	ld		bc, (UsedBlockListCnt)
 382+ 694C B7           	or		a
 383+ 694D ED 42        	sbc		hl, bc
 384+ 694F 30 03        	jr		nc, CopyDiskLoopRead
 385+ 6951 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 6954
 387+ 6954              CopyDiskLoopRead:
 388+ 6954 41           	ld		b, c
 389+ 6955 11 47 87     	ld		de, CopyDiskBuf
 390+ 6958              	;save initial counter and initial block number array position
 391+ 6958 C5           	push	bc
 392+ 6959 DD E5        	push	ix
 393+ 695B
 394+ 695B              CopyDiskLoopReadLoop:
 395+ 695B DD 6E 00     		ld		l, (ix)
 396+ 695E DD 66 01     		ld		h, (ix+1)
 397+ 6961 DD 23        		inc		ix
 398+ 6963 DD 23        		inc		ix
 399+ 6965
 400+ 6965 D5           		push	de
 401+ 6966 C5           		push	bc
 402+ 6967 CD 10 69     			call	ReadFSBlock			;Stop on error or continue?
 403+ 696A C1           		pop		bc
 404+ 696B D1           		pop		de
 405+ 696C
 406+ 696C              		;+2048
 407+ 696C 7A           		ld		a, d
 408+ 696D C6 08        		add		8
 409+ 696F 57           		ld		d, a
 410+ 6970
 411+ 6970 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 6972
 413+ 6972              		;Check if selection is 1=single drive or 2=dual drive
 414+ 6972 3A 06 79     		ld		a, (CopySelOption)
 415+ 6975 FE 31        		cp		'1'
 416+ 6977 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 6979
 418+ 6979              		;Prompt for disk change
 419+ 6979 CD FF 6C     		call	PromptDiskChangeDst
 420+ 697C 3A ED 6B     		ld		a, (RWTSDrive)
 421+ 697F CD 05 6C     		call	BDOSInit
 422+ 6982 18 0A        		jr		CopyDiskReadEnd
 423+ 6984
 424+ 6984              CopyDiskDualDrive1:
 425+ 6984              		;alternate drive
 426+ 6984 3A ED 6B     		ld		a, (RWTSDrive)
 427+ 6987 3C           		inc 	a
 428+ 6988 EE 03        		xor		%11
 429+ 698A 3D           		dec		a
 430+ 698B 32 ED 6B     		ld		(RWTSDrive), a
 431+ 698E
 432+ 698E              CopyDiskReadEnd:
 433+ 698E              	;restore initial counter and initial block number array position
 434+ 698E DD E1        	pop		ix
 435+ 6990 C1           	pop		bc
 436+ 6991 11 47 87     	ld		de, CopyDiskBuf
 437+ 6994 C5           	push	bc
 438+ 6995
 439+ 6995              CopyDiskLoopWriteLoop:
 440+ 6995 DD 6E 00     		ld		l, (ix)
 441+ 6998 DD 66 01     		ld		h, (ix+1)
 442+ 699B DD 23        		inc		ix
 443+ 699D DD 23        		inc		ix
 444+ 699F
 445+ 699F D5           		push	de
 446+ 69A0 C5           		push	bc
 447+ 69A1 CD 1D 69     			call	WriteFSBlock		;Stop on error or continue?
 448+ 69A4 C1           		pop		bc
 449+ 69A5 D1           		pop		de
 450+ 69A6
 451+ 69A6              		;+2048
 452+ 69A6 7A           		ld		a, d
 453+ 69A7 C6 08        		add		8
 454+ 69A9 57           		ld		d, a
 455+ 69AA
 456+ 69AA 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 69AC
 458+ 69AC              CopyDiskWriteEnd:
 459+ 69AC C1           	pop		bc
 460+ 69AD 48           	ld		c, b
 461+ 69AE 06 00        	ld		b, 0
 462+ 69B0
 463+ 69B0              	;Decrease number of blocks read by now.
 464+ 69B0 2A 5D 81     	ld		hl, (UsedBlockListCnt)
 465+ 69B3 B7           	or		a
 466+ 69B4 ED 42        	sbc		hl, bc
 467+ 69B6 22 5D 81     	ld		(UsedBlockListCnt), hl
 468+ 69B9
 469+ 69B9 7D           	ld		a, l
 470+ 69BA B4           	or		h
 471+ 69BB 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 69BD
 473+ 69BD              	;Check if selection is 1=single drive or 2=dual drive
 474+ 69BD 3A 06 79     	ld		a, (CopySelOption)
 475+ 69C0 FE 31        	cp		'1'
 476+ 69C2 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 69C4
 478+ 69C4              	;Prompt for disk change
 479+ 69C4 CD 19 6D     	call	PromptDiskChangeSrc
 480+ 69C7 3A ED 6B     	ld		a, (RWTSDrive)
 481+ 69CA CD 05 6C     	call	BDOSInit
 482+ 69CD C3 31 69     	jp		CopyDiskLoop
 483+ 69D0
 484+ 69D0              CopyDiskDualDrive2:
 485+ 69D0              	;alternate drive again
 486+ 69D0 3A ED 6B     	ld		a, (RWTSDrive)
 487+ 69D3 3C           	inc		a
 488+ 69D4 EE 03        	xor		%11
 489+ 69D6 3D           	dec		a
 490+ 69D7 32 ED 6B     	ld		(RWTSDrive), a
 491+ 69DA C3 31 69     	jp		CopyDiskLoop
 492+ 69DD
 493+ 69DD              CopyDiskEnd:
 494+ 69DD 06 01        	ld		b, 1
 495+ 69DF CD 33 72     	call	ClearNMsgLines
 496+ 69E2 C9           	ret
 497+ 69E3
 498+ 69E3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 69E3              ;Copies the current disk blocks to COM port.
 500+ 69E3              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 69E3              CopyDiskToCOM:
 502+ 69E3              	;Get list of used blocks in current disk, max 632 bytes
 503+ 69E3 CD B7 68     	call	ReadUsedBlocksList
 504+ 69E6
 505+ 69E6              	;Send block count and block indexes
 506+ 69E6 2A 5D 81     	ld		hl, (UsedBlockListCnt)
 507+ 69E9 29           	add		hl, hl
 508+ 69EA 23           	inc		hl
 509+ 69EB 23           	inc		hl
 510+ 69EC 44           	ld		b, h
 511+ 69ED 4D           	ld		c, l
 512+ 69EE 21 5D 81     	ld		hl, UsedBlockListCnt
 513+ 69F1 CD 12 76     	call	SERTB
 514+ 69F4
 515+ 69F4 DD 21 5F 81  	ld		ix, UsedBlockListBlk
 516+ 69F8
 517+ 69F8              CopyDiskToCOMLoop:
 518+ 69F8              	;Print block count left
 519+ 69F8 2A 5D 81     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 69FB 11 93 78     	ld		de, MsgBlocksLeft
 521+ 69FE CD C4 67     	call	Byte2Txt
 522+ 6A01 21 93 78     	ld		hl, MsgBlocksLeft
 523+ 6A04 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 6A07 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 6A09 CD AF 70     	call	PrintStrClr
 526+ 6A0C
 527+ 6A0C              	;Read block into buffer
 528+ 6A0C DD 6E 00     	ld		l, (ix)
 529+ 6A0F DD 66 01     	ld		h, (ix+1)
 530+ 6A12 11 47 87     	ld		de, CopyDiskBuf
 531+ 6A15 DD E5        	push	ix
 532+ 6A17 CD 10 69     		call	ReadFSBlock
 533+ 6A1A DD E1        	pop		ix
 534+ 6A1C DD 23        	inc		ix
 535+ 6A1E DD 23        	inc		ix
 536+ 6A20
 537+ 6A20              	;Send block buffer
 538+ 6A20 21 47 87     	ld		hl, CopyDiskBuf
 539+ 6A23 01 00 08     	ld		bc, AU_SZ
 540+ 6A26 CD 12 76     	call	SERTB
 541+ 6A29
 542+ 6A29 ED 4B 5D 81  	ld		bc, (UsedBlockListCnt)
 543+ 6A2D 0B           	dec		bc
 544+ 6A2E ED 43 5D 81  	ld		(UsedBlockListCnt), bc
 545+ 6A32
 546+ 6A32 DD E5        	push	ix
 547+ 6A34 CD 4E 70     		call	KbdHit
 548+ 6A37 DD E1        	pop		ix
 549+ 6A39 D8           	ret		c
 550+ 6A3A
 551+ 6A3A 78           	ld		a, b
 552+ 6A3B B1           	or		c
 553+ 6A3C 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 6A3E
 555+ 6A3E C9           	ret
 556+ 6A3F
 557+ 6A3F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 6A3F              CopyDiskFromCOM:
 559+ 6A3F              	;Receive block count.
 560+ 6A3F 21 5D 81     	ld		hl, UsedBlockListCnt
 561+ 6A42 01 02 00     	ld		bc, 2
 562+ 6A45 1E 00        	ld		e, 0
 563+ 6A47 CD DF 75     	call	SERRB
 564+ 6A4A
 565+ 6A4A              	;Receive block indexes.
 566+ 6A4A 2A 5D 81     	ld		hl, (UsedBlockListCnt)
 567+ 6A4D 29           	add		hl, hl
 568+ 6A4E 44           	ld		b, h
 569+ 6A4F 4D           	ld		c, l
 570+ 6A50 21 5F 81     	ld		hl, UsedBlockListBlk
 571+ 6A53 1E 00        	ld		e, 0
 572+ 6A55 CD DF 75     	call	SERRB
 573+ 6A58
 574+ 6A58              	;Read each block by index and write to disk
 575+ 6A58 DD 21 5F 81  	ld		ix, UsedBlockListBlk
 576+ 6A5C
 577+ 6A5C              CopyDiskFromCOMLoop:
 578+ 6A5C              	;Print block count left
 579+ 6A5C 2A 5D 81     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 6A5F 11 93 78     	ld		de, MsgBlocksLeft
 581+ 6A62 CD C4 67     	call	Byte2Txt
 582+ 6A65 21 93 78     	ld		hl, MsgBlocksLeft
 583+ 6A68 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 6A6B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 6A6D CD AF 70     	call	PrintStrClr
 586+ 6A70
 587+ 6A70              	;Read block buffer
 588+ 6A70 21 47 87     	ld		hl, CopyDiskBuf
 589+ 6A73 01 00 08     	ld		bc, AU_SZ
 590+ 6A76 1E 00        	ld		e, 0
 591+ 6A78 CD DF 75     	call	SERRB
 592+ 6A7B
 593+ 6A7B              	;Write block to disk
 594+ 6A7B DD 6E 00     	ld		l, (ix)
 595+ 6A7E DD 66 01     	ld		h, (ix+1)
 596+ 6A81 11 47 87     	ld		de, CopyDiskBuf
 597+ 6A84 DD E5        	push	ix
 598+ 6A86 CD 1D 69     		call	WriteFSBlock			;Stop on error or continue?
 599+ 6A89 DD E1        	pop		ix
 600+ 6A8B DD 23        	inc		ix
 601+ 6A8D DD 23        	inc		ix
 602+ 6A8F
 603+ 6A8F ED 4B 5D 81  	ld		bc, (UsedBlockListCnt)
 604+ 6A93 0B           	dec		bc
 605+ 6A94 ED 43 5D 81  	ld		(UsedBlockListCnt), bc
 606+ 6A98
 607+ 6A98 DD E5        	push	ix
 608+ 6A9A CD 4E 70     		call	KbdHit
 609+ 6A9D DD E1        	pop		ix
 610+ 6A9F D8           	ret		c
 611+ 6AA0
 612+ 6AA0 78           	ld		a, b
 613+ 6AA1 B1           	or		c
 614+ 6AA2 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 6AA4 C9           	ret
 616+ 6AA5
 617+ 6AA5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 6AA5
 619+ 6AA5              ;Compare string at HL with the one at DE, max length B
 620+ 6AA5              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 6AA5              ;OUT: z flag, set = match, reset = mismatch
 622+ 6AA5              StrCmp:
 623+ 6AA5 E5           	push hl
 624+ 6AA6 D5           	push de
 625+ 6AA7              Compare:
 626+ 6AA7 1A           		ld a, (de)
 627+ 6AA8 BE           		cp (hl)
 628+ 6AA9 20 04        		jr nz, MisMatch
 629+ 6AAB 23           		inc hl
 630+ 6AAC 13           		inc de
 631+ 6AAD 10 F8        		djnz Compare
 632+ 6AAF              MisMatch:
 633+ 6AAF D1           	pop de
 634+ 6AB0 E1           	pop hl
 635+ 6AB1 C9           	ret
 636+ 6AB2
 637+ 6AB2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 6AB2
 639+ 6AB2              ;Read a file into a buffer, sector by sector.
 640+ 6AB2              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 6AB2              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 6AB2              ;In: HL = Name address, DE = buffer
 643+ 6AB2              IF1FileLoad:
 644+ 6AB2 D5           	push	de
 645+ 6AB3 22 DC 5C     		ld (FSTR1), hl
 646+ 6AB6 26 00        		ld h, 0
 647+ 6AB8 3A ED 6B     		ld a, (RWTSDrive)
 648+ 6ABB 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 6ABC 6F           		ld	l, a
 650+ 6ABD 22 D6 5C     		ld (DSTR1), hl
 651+ 6AC0 2E 0B        		ld l,NAMELEN
 652+ 6AC2 22 DA 5C     		ld (NSTR1), hl
 653+ 6AC5 CF           		rst 08
 654+ 6AC6 33           		DEFB 51			;open disk channel
 655+ 6AC7
 656+ 6AC7 CF           		rst		8
 657+ 6AC8 35           		defb	53		;read sector
 658+ 6AC9 D1           	pop		de
 659+ 6ACA 30 27        	jr		nc, FileFree
 660+ 6ACC
 661+ 6ACC DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 6ACF FE 04        	cp		TEXT_TYPE
 663+ 6AD1 30 12        	jr		nc, FileLoadNoHeader
 664+ 6AD3
 665+ 6AD3              FileLoadHeader:
 666+ 6AD3 DD E5        	push	ix
 667+ 6AD5 E1           	pop		hl
 668+ 6AD6 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 6AD9 09           	add		hl, bc
 670+ 6ADA 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 6ADD ED B0        	ldir
 672+ 6ADF
 673+ 6ADF              FileReadLoop:
 674+ 6ADF D5           	push	de
 675+ 6AE0 CF           		rst		8
 676+ 6AE1 35           		defb	53		;read sector
 677+ 6AE2 D1           	pop		de
 678+ 6AE3 30 0E        	jr		nc, FileFree
 679+ 6AE5
 680+ 6AE5              FileLoadNoHeader:
 681+ 6AE5 DD E5        	push	ix
 682+ 6AE7 E1           	pop		hl
 683+ 6AE8 01 32 00     	ld		bc, CH_DATA
 684+ 6AEB 09           	add		hl, bc
 685+ 6AEC 01 00 01     	ld		bc, SECT_SZ
 686+ 6AEF ED B0        	ldir
 687+ 6AF1 18 EC        	jr		FileReadLoop
 688+ 6AF3
 689+ 6AF3              FileFree:
 690+ 6AF3 D5           	push	de
 691+ 6AF4 CF           	rst		8
 692+ 6AF5 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 6AF6 D1           	pop		de
 694+ 6AF7 C9           	ret
 695+ 6AF8              IF1FileLoadEnd:
 696+ 6AF8
 697+ 6AF8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 6AF8              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 6AF8              ;Out: A = error code, 0=OK
 700+ 6AF8              ReadDiskSectors:
 701+ 6AF8 C5           	push bc
 702+ 6AF9 E5           		push hl
 703+ 6AFA D5           			push de
 704+ 6AFB CD 43 68     				call ReadOneDiskSector
 705+ 6AFE D1           			pop de
 706+ 6AFF E1           		pop hl
 707+ 6B00
 708+ 6B00 14           		inc d
 709+ 6B01 24           		inc h
 710+ 6B02 C1           	pop bc
 711+ 6B03
 712+ 6B03 3A F8 6B     	ld	a, (RWTSRes)
 713+ 6B06 B7           	or	a
 714+ 6B07 C0           	ret nz
 715+ 6B08
 716+ 6B08 10 EE        	djnz ReadDiskSectors
 717+ 6B0A C9           	ret
 718+ 6B0B
 719+ 6B0B              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 6B0B              ;Out: A = error code, 0=OK
 721+ 6B0B              WriteDiskSectors:
 722+ 6B0B C5           	push bc
 723+ 6B0C E5           		push hl
 724+ 6B0D D5           			push de
 725+ 6B0E CD 4E 68     				call WriteOneDiskSector
 726+ 6B11 D1           			pop de
 727+ 6B12 E1           		pop hl
 728+ 6B13
 729+ 6B13 14           		inc d
 730+ 6B14 24           		inc h
 731+ 6B15 C1           	pop bc
 732+ 6B16
 733+ 6B16 3A F8 6B     	ld	a, (RWTSRes)
 734+ 6B19 B7           	or	a
 735+ 6B1A C0           	ret nz
 736+ 6B1B
 737+ 6B1B 10 EE        	djnz WriteDiskSectors
 738+ 6B1D C9           	ret
 739+ 6B1E
 740+ 6B1E
 741+ 6B1E              ;Reads disk catalog
 742+ 6B1E              ReadCatalogTrack:
 743+ 6B1E 21 47 87     	ld hl, TrackBuf
 744+ 6B21 11 00 00     	ld de, 0
 745+ 6B24 06 10        	ld b, SPT
 746+ 6B26
 747+ 6B26 CD F8 6A     	call ReadDiskSectors
 748+ 6B29 C9           	ret
 749+ 6B2A
 750+ 6B2A              ;A = track
 751+ 6B2A              SeekTrack:
 752+ 6B2A              	IFUSED
 753+ 6B2A ~            	ld	(RWTSTrack), a
 754+ 6B2A ~            	ld 	a, RWTS_CMD_SEEK
 755+ 6B2A ~            	jp	RWTS
 756+ 6B2A              	ENDIF
 757+ 6B2A
 758+ 6B2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759+ 6B2A
 760+ 6B2A              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761+ 6B2A              FindCache:
 762+ 6B2A 06 0B        	ld		b, NAMELEN
 763+ 6B2C CD A5 6A     	call	StrCmp			;find the file to wich this extension belongs
 764+ 6B2F C8           	ret		z
 765+ 6B30
 766+ 6B30 0D           	dec		c
 767+ 6B31 20 02        	jr		nz, CacheNotFinished
 768+ 6B33 B1           	or		c
 769+ 6B34 C9           	ret
 770+ 6B35
 771+ 6B35              CacheNotFinished:
 772+ 6B35 01 19 00     	ld		bc, CACHE_SZ
 773+ 6B38 09           	add		hl, bc			;to the next cache line
 774+ 6B39 18 EF        	jr		FindCache
 775+ 6B3B
 776+ 6B3B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777+ 6B3B
 778+ 6B3B              	;ld		ix, (SelFileCache)
 779+ 6B3B              ReadFileHeader:
 780+ 6B3B DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 781+ 6B3E B7           	or		a
 782+ 6B3F C0           	ret		nz				;return if already read
 783+ 6B40
 784+ 6B40 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 785+ 6B43 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 786+ 6B46 7C           	ld		a, h
 787+ 6B47 B5           	or		l
 788+ 6B48 28 46        	jr		z, ReadHeaderEnd
 789+ 6B4A
 790+ 6B4A CD 6A 68     	call	AU2TS
 791+ 6B4D 50           	ld		d, b
 792+ 6B4E 59           	ld		e, c
 793+ 6B4F 21 47 87     	ld		hl, DataBuf
 794+ 6B52 DD E5        	push	ix
 795+ 6B54 DD E5        	push	ix
 796+ 6B56 CD 43 68     		call	ReadOneDiskSector
 797+ 6B59 E1           	pop		hl
 798+ 6B5A DD E1        	pop		ix
 799+ 6B5C
 800+ 6B5C E5           	push	hl
 801+ 6B5D 21 47 87     		ld		hl, DataBuf
 802+ 6B60 CD 94 6B     		call	IsFileHeaderValid
 803+ 6B63 E1           	pop		hl
 804+ 6B64 B7           	or		a
 805+ 6B65 28 14        	jr		z, ReadFileHeaderIsTextFile
 806+ 6B67
 807+ 6B67 01 10 00     	ld		bc, CACHE_HDR
 808+ 6B6A 09           	add		hl, bc
 809+ 6B6B EB           	ex		hl, de
 810+ 6B6C 21 47 87     	ld		hl, DataBuf
 811+ 6B6F 01 09 00     	ld		bc, HDR_SZ
 812+ 6B72 ED B0        	ldir
 813+ 6B74
 814+ 6B74              	;For text files, read file size as reported by BDOS, since we don't have a header.
 815+ 6B74 3E 03        	ld		a, BYTE_TYPE
 816+ 6B76 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 817+ 6B79 30 15        	jr		nc, ReadHeaderEnd
 818+ 6B7B
 819+ 6B7B              ReadFileHeaderIsTextFile:
 820+ 6B7B DD E5        	push	ix
 821+ 6B7D DD E5        	push	ix
 822+ 6B7F E1           	pop		hl
 823+ 6B80 CD 63 6C     		call	GetFileSize
 824+ 6B83 DD E1        	pop		ix
 825+ 6B85 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 826+ 6B88 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827+ 6B8B 3E 04        	ld		a, TEXT_TYPE
 828+ 6B8D DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829+ 6B90
 830+ 6B90              ReadHeaderEnd:
 831+ 6B90 DD 34 0F     	inc		(ix + CACHE_FLAG)
 832+ 6B93 C9           	ret
 833+ 6B94
 834+ 6B94              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835+ 6B94              ;Checks if the file header is valid. For now it checks to not have all 0s.
 836+ 6B94              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837+ 6B94              ;In: HL = header
 838+ 6B94              ;Out: A > 0 if valid
 839+ 6B94              IsFileHeaderValid:
 840+ 6B94              	IFUSED
 841+ 6B94 AF           	xor		a
 842+ 6B95 06 09        	ld		b, HDR_SZ
 843+ 6B97              IsFileHeaderValidLoop:
 844+ 6B97 B6           	or		(hl)
 845+ 6B98 23           	inc		hl
 846+ 6B99 10 FC        	djnz	IsFileHeaderValidLoop
 847+ 6B9B
 848+ 6B9B C9           	ret
 849+ 6B9C              	ENDIF
 850+ 6B9C
 851+ 6B9C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852+ 6B9C
 853+ 6B9C              ;IN: HL = address from IF1 to call
 854+ 6B9C              IF1Call:
 855+ 6B9C 22 ED 5C     	LD   (HD11), HL
 856+ 6B9F CF           	RST  8
 857+ 6BA0 32           	DEFB 50
 858+ 6BA1 C9           	RET
 859+ 6BA2
 860+ 6BA2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861+ 6BA2
 862+ 6BA2              ;Load a program from disk
 863+ 6BA2              ;IN: HL = file name addr
 864+ 6BA2              LoadProgram:
 865+ 6BA2 22 DC 5C     	LD   (FSTR1), HL
 866+ 6BA5 26 00        	LD   H, 0
 867+ 6BA7 2E 0B        	LD   L, NAMELEN
 868+ 6BA9 22 DA 5C     	LD   (NSTR1), HL
 869+ 6BAC 3A ED 6B     	LD	 A, (RWTSDrive)
 870+ 6BAF 3C           	INC  A					;Adapt for BASIC drive number
 871+ 6BB0 6F           	LD   L, A
 872+ 6BB1 22 D6 5C     	LD   (DSTR1), HL
 873+ 6BB4 21 41 0A     	LD   HL, LOAD_ADDR
 874+ 6BB7 CD 9C 6B     	CALL IF1Call
 875+ 6BBA C9           	RET
 876+ 6BBB
 877+ 6BBB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878+ 6BBB
 879+ 6BBB              SetFastKeys:
 880+ 6BBB 21 09 5C     	ld		hl, REPDEL
 881+ 6BBE 11 0F 01     	ld		de, (1 << 8) | 15
 882+ 6BC1 73 23 72 2B  	ld		(hl), de
 883+ 6BC5
 884+ 6BC5 C9           	ret
 885+ 6BC6
 886+ 6BC6
 887+ 6BC6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 888+ 6BC6              ;Reads the error message string from IF1 ROM.
 889+ 6BC6              GetErrMsg:
 890+ 6BC6 3C           	inc		a
 891+ 6BC7 08           	ex		af, af'
 892+ 6BC8
 893+ 6BC8 21 CE 6B     	ld		hl, IF1Paged			;page-in IF1
 894+ 6BCB C3 9C 6B     	jp		IF1Call
 895+ 6BCE
 896+ 6BCE              IF1Paged:
 897+ 6BCE 21 60 02     	ld		hl, ERRMSG
 898+ 6BD1 08           	ex		af, af'
 899+ 6BD2 B7           	or		a
 900+ 6BD3 28 0B        	jr		z, SaveMsg
 901+ 6BD5
 902+ 6BD5 06 00        	ld		b, 0
 903+ 6BD7              SearchMsgEnd:
 904+ 6BD7 CB 7E        	bit		7, (hl)
 905+ 6BD9 23           	inc		hl
 906+ 6BDA 28 FB        	jr		z, SearchMsgEnd
 907+ 6BDC
 908+ 6BDC 04           	inc		b
 909+ 6BDD B8           	cp		b
 910+ 6BDE 20 F7        	jr		nz, SearchMsgEnd
 911+ 6BE0
 912+ 6BE0              SaveMsg:
 913+ 6BE0 11 47 87     	ld		de, DataBuf
 914+ 6BE3              CopyMsg:
 915+ 6BE3 7E           	ld		a, (hl)
 916+ 6BE4 CB 7F        	bit		7, a
 917+ 6BE6 12           	ld		(de), a
 918+ 6BE7 23           	inc		hl
 919+ 6BE8 13           	inc		de
 920+ 6BE9 28 F8        	jr		z, CopyMsg
 921+ 6BEB
 922+ 6BEB C9           	ret
 923+ 6BEC
 924+ 6BEC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 925+ 6BEC
 926+ 6BEC              ;RWTS routine I/O block
 927+ 6BEC              RWTSParams:
 928+ 6BEC 01           RWTSBlockType	DEFB	1							;?
 929+ 6BED 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 930+ 6BEE 00           RWTSVolNo		DEFB	0							;?
 931+ 6BEF 00           RWTSTrack		DEFB	0
 932+ 6BF0 00           RWTSSector		DEFB	0
 933+ 6BF1 00 00        RWTSDMA			DEFW	0
 934+ 6BF3 32 29        RWTSExtBuf		DEFW	$2932
 935+ 6BF5              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 936+ 6BF5              	IFDEF _REAL_HW_
 937+ 6BF5 FF 6B        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 938+ 6BF7              	ELSE
 939+ 6BF7 ~            RWTSPrmTbl		DEFW	$1f2a
 940+ 6BF7              	ENDIF
 941+ 6BF7 01           RWTSCmd			DEFB	RWTS_CMD_READ
 942+ 6BF8              ;Results
 943+ 6BF8 00           RWTSRes			DEFB	0
 944+ 6BF9 00           RWTSResVolNo	DEFB	0
 945+ 6BFA 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 945+ 6BFE 00
 946+ 6BFF
 947+ 6BFF              ;Param. table, usualy found in ROM.
 948+ 6BFF              	IFDEF _REAL_HW_
 949+ 6BFF              BasPrmTbl:
 950+ 6BFF
 951+ 6BFF              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 952+ 6BFF              	;DEFINE _STANDARD_DRIVE_PARAM_
 953+ 6BFF              	IFDEF _STANDARD_DRIVE_PARAM_
 954+ 6BFF ~            PrmDevType		DEFB	$01
 955+ 6BFF ~            PrmStepRate		DEFB	$0D		;(milisec)
 956+ 6BFF ~            PrmHeadLoad		DEFB	$23		;(milisec)
 957+ 6BFF ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 958+ 6BFF              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 959+ 6BFF 01           PrmDevType		DEFB	$01
 960+ 6C00 04           PrmStepRate		DEFB	$0D/3		;(milisec)
 961+ 6C01 0B           PrmHeadLoad		DEFB	$23/3		;(milisec)
 962+ 6C02 21           PrmSpinUp		DEFB	$64/3		;(1/100 sec)
 963+ 6C03              	ENDIF
 964+ 6C03
 965+ 6C03 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 966+ 6C05              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 967+ 6C05              	ENDIF
 968+ 6C05
 969+ 6C05              	endif
# file closed: if1.asm
1277  6C05              	include "bdos.asm"
# file opened: bdos.asm
   1+ 6C05              ;BDOS functions - similar to CP/M
   2+ 6C05
   3+ 6C05              	IFNDEF	_BDOS_
   4+ 6C05              	DEFINE	_BDOS_
   5+ 6C05
   6+ 6C05              	include "if1.asm"
# file opened: if1.asm
   1++6C05              ;HC IF1 routines and constants
   2++6C05
   3++6C05              ;IF1 routines error codes, also returned by BASIC commands
   4++6C05              ;12 = Writing to a 'read' file
   5++6C05              ;13 = Reading a 'write' file
   6++6C05              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++6C05              ;15 = Disk full (disk or catalog full)
   8++6C05              ;16 = Disk error (hardware error)
   9++6C05              ;17 = File not found
  10++6C05              ;23 = Disk R/O (disk change detected, software R/O)
  11++6C05              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++6C05
  13++6C05              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++6C05              ;00h = OK
  15++6C05              ;08h = cannot format disk
  16++6C05              ;10h = disk protected (read-only?)
  17++6C05              ;20h = volume error
  18++6C05              ;40h = drive error
  19++6C05              ;80h = reading error
  20++6C05              ;Codes I encountered:
  21++6C05              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++6C05
  23++6C05
  24++6C05              	ifndef	_DISK_
  25++6C05 ~            	define	_DISK_
  26++6C05 ~
  27++6C05 ~            	include	"math.asm"
  28++6C05 ~
  29++6C05 ~            DRIVE_CUR_BAS	EQU 0
  30++6C05 ~            DRIVE_A_BAS		EQU	1
  31++6C05 ~            DRIVE_B_BAS		EQU	2
  32++6C05 ~            DRIVE_A_CPM		EQU	0
  33++6C05 ~            DRIVE_B_CPM		EQU	1
  34++6C05 ~            ;Disk geometry stuff
  35++6C05 ~            SPT				EQU	16			;sectors per track
  36++6C05 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++6C05 ~            TRACK_CNT		EQU	80			;track count
  38++6C05 ~            HEAD_CNT		EQU	2			;disk face count
  39++6C05 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++6C05 ~            EXT_SZ			EQU	32			;directory entry size
  41++6C05 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++6C05 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++6C05 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++6C05 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++6C05 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++6C05 ~            REC_SZ			EQU 128			;cp/m record size
  47++6C05 ~            DEL_MARKER		EQU	$E5
  48++6C05 ~
  49++6C05 ~
  50++6C05 ~            ;Extension structure (directory entry)
  51++6C05 ~            EXT_DEL_FLAG	EQU	0
  52++6C05 ~            EXT_NAME		EQU 1
  53++6C05 ~            EXT_IDX			EQU 12
  54++6C05 ~            EXT_S1			EQU 13
  55++6C05 ~            EXT_S2			EQU 14
  56++6C05 ~            EXT_RC			EQU	15
  57++6C05 ~            EXT_AU0			EQU	16
  58++6C05 ~            EXT_AU1			EQU	18
  59++6C05 ~            EXT_AU2			EQU	20
  60++6C05 ~            EXT_AU3			EQU	22
  61++6C05 ~            EXT_AU4			EQU	24
  62++6C05 ~            EXT_AU5			EQU	26
  63++6C05 ~            EXT_AU6			EQU	28
  64++6C05 ~            EXT_AU7			EQU	30
  65++6C05 ~            EXT_SIZE		EQU 32
  66++6C05 ~
  67++6C05 ~            ;FCB structure
  68++6C05 ~            FCB_DRIVE		EQU 0
  69++6C05 ~            FCB_NAME		EQU EXT_NAME
  70++6C05 ~            FCB_EX_IDX		EQU EXT_IDX
  71++6C05 ~            FCB_S1			EQU EXT_S1
  72++6C05 ~            FCB_S2			EQU EXT_S2
  73++6C05 ~            FCB_RC			EQU	EXT_RC
  74++6C05 ~            FCB_AU			EQU	EXT_AU0
  75++6C05 ~            FCB_CR			EQU	32
  76++6C05 ~            FCB_R0			EQU 33
  77++6C05 ~            FCB_R1			EQU 34
  78++6C05 ~            FCB_R2			EQU 35
  79++6C05 ~            FCB_SIZE		EQU 36
  80++6C05 ~
  81++6C05 ~
  82++6C05 ~
  83++6C05 ~            ;System variables for disk
  84++6C05 ~            DSTR1			EQU	$5CD6		;drive
  85++6C05 ~            FSTR1			EQU	$5CDC		;file name
  86++6C05 ~            NSTR1			EQU	$5CDA		;name length
  87++6C05 ~            HD11			EQU	$5CED		;BDOS argument
  88++6C05 ~            COPIES			EQU	$5CEF		;BDOS function
  89++6C05 ~
  90++6C05 ~            ERRSP			EQU $5C3D
  91++6C05 ~            ERRNR			EQU $5C3A
  92++6C05 ~            ERRMSG			EQU	$0260
  93++6C05 ~
  94++6C05 ~            PROG			EQU $5C53
  95++6C05 ~            VARS			EQU	$5C4B
  96++6C05 ~            STKEND			EQU	$5C65
  97++6C05 ~
  98++6C05 ~            PRN_BUF			EQU	23296
  99++6C05 ~
 100++6C05 ~            REPDEL			EQU	23561
 101++6C05 ~            REPPER			EQU	23562
 102++6C05 ~            PIP				EQU	23609
 103++6C05 ~
 104++6C05 ~
 105++6C05 ~            ;RWTS routine commands
 106++6C05 ~            RWTS_CMD_SEEK	EQU	0			;position head
 107++6C05 ~            RWTS_CMD_READ	EQU	1			;read sector
 108++6C05 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++6C05 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++6C05 ~
 111++6C05 ~
 112++6C05 ~            ;File name stuff
 113++6C05 ~            NAMELEN			EQU	11			;name length
 114++6C05 ~            RO_POS			EQU	8			;read-only attribute position in name
 115++6C05 ~            SYS_POS			EQU	9			;system attribute position in name
 116++6C05 ~
 117++6C05 ~            ;File types (first byte in header)
 118++6C05 ~            PROG_TYPE		EQU	0			;program
 119++6C05 ~            NUMB_TYPE		EQU	1			;number array
 120++6C05 ~            CHAR_TYPE		EQU	2			;char array
 121++6C05 ~            BYTE_TYPE		EQU	3			;bytes
 122++6C05 ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++6C05 ~
 124++6C05 ~            ;File header offsets
 125++6C05 ~            HDR_TYPE		EQU	0
 126++6C05 ~            HDR_LEN			EQU 1
 127++6C05 ~            HDR_ADDR		EQU 3
 128++6C05 ~            HDR_PLEN		EQU	5
 129++6C05 ~            HDR_LINE		EQU 7
 130++6C05 ~            HDR_SZ			EQU	9
 131++6C05 ~
 132++6C05 ~            ;BASIC disk channel structure
 133++6C05 ~            CH_RW_FLAG		EQU 11
 134++6C05 ~            CH_FCB			EQU	12
 135++6C05 ~            CH_DATA			EQU	50
 136++6C05 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++6C05 ~
 138++6C05 ~            CACHE_NAME		EQU	0					;11B
 139++6C05 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++6C05 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++6C05 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++6C05 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++6C05 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++6C05 ~
 145++6C05 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++6C05 ~
 147++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++6C05 ~            IF1Init:
 149++6C05 ~            	rst		08
 150++6C05 ~            	defb	49		;create system variables
 151++6C05 ~            	ret
 152++6C05 ~
 153++6C05 ~            ;ReadWriteTrackSector
 154++6C05 ~            ;A=command: 0, 1, 2, 4
 155++6C05 ~            RWTS:
 156++6C05 ~            	ld (RWTSCmd), a
 157++6C05 ~            	ld hl, RWTSParams
 158++6C05 ~            	ld (HD11), hl
 159++6C05 ~            	rst 08
 160++6C05 ~            	DEFB 58
 161++6C05 ~            	ret
 162++6C05 ~
 163++6C05 ~
 164++6C05 ~            ;D = sector, E = track
 165++6C05 ~            ;HL = dma
 166++6C05 ~            ReadOneDiskSector:
 167++6C05 ~            	ld (RWTSDMA), hl
 168++6C05 ~            	ld (RWTSTrack), de
 169++6C05 ~            	;ld (RWTSDrive), a
 170++6C05 ~            	ld a, RWTS_CMD_READ
 171++6C05 ~            	jr	RWTS
 172++6C05 ~
 173++6C05 ~            ;D = sector, E = track
 174++6C05 ~            ;HL = dma
 175++6C05 ~            WriteOneDiskSector:
 176++6C05 ~            	ld (RWTSDMA), hl
 177++6C05 ~            	ld (RWTSTrack), de
 178++6C05 ~            	;ld (RWTSDrive), a
 179++6C05 ~            	ld a, RWTS_CMD_WRITE
 180++6C05 ~            	jr	RWTS
 181++6C05 ~
 182++6C05 ~            FormatDisk:
 183++6C05 ~            	ld		hl, DataBuf
 184++6C05 ~            	ld		(hl), DEL_MARKER
 185++6C05 ~            	ld 		(RWTSDMA), hl
 186++6C05 ~            	ld 		a, RWTS_CMD_FMT
 187++6C05 ~            	call	RWTS
 188++6C05 ~            	ld		a, (RWTSRes)
 189++6C05 ~            	ret
 190++6C05 ~
 191++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++6C05 ~
 193++6C05 ~            ;Allocation unit no. to track/sector
 194++6C05 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++6C05 ~            ;IN:  HL=alloc. unit no.
 196++6C05 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++6C05 ~            AU2TS:
 198++6C05 ~            	ld c, SPT/SPAL
 199++6C05 ~            	call Div					;A = sector
 200++6C05 ~            	push af
 201++6C05 ~            		/*
 202++6C05 ~            		ld c, HEAD_CNT
 203++6C05 ~            		call Div				;L = track, A = head (0 or 1)
 204++6C05 ~            		*/
 205++6C05 ~            		xor a
 206++6C05 ~            		rr h
 207++6C05 ~            		rr l
 208++6C05 ~            		rr a
 209++6C05 ~
 210++6C05 ~            		ld c, l
 211++6C05 ~            		ld b, 0
 212++6C05 ~            		or a
 213++6C05 ~            		jr z, Track0
 214++6C05 ~            		ld b, SPT
 215++6C05 ~            Track0:
 216++6C05 ~            	pop af
 217++6C05 ~            	or a
 218++6C05 ~            	jr z, FirstAU
 219++6C05 ~            	ld a, SPAL
 220++6C05 ~            FirstAU:
 221++6C05 ~            	add a, b
 222++6C05 ~            	ld  b, a
 223++6C05 ~            	ret
 224++6C05 ~
 225++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++6C05 ~
 227++6C05 ~            ;Checks the allocation units number used in extension
 228++6C05 ~            ;IN:	IX = extension addr
 229++6C05 ~            ;OUT:	B = no. of allocation units used
 230++6C05 ~            ;		C = no. of records used in ext.
 231++6C05 ~            ;		HL = first alloc. unit no.
 232++6C05 ~            ;		DE = last alloc. unit no.
 233++6C05 ~            CheckExtAlloc:
 234++6C05 ~            	push ix
 235++6C05 ~            		ld bc, EXT_RC
 236++6C05 ~            		add ix, bc
 237++6C05 ~            		ld c, (ix)			;save rec. no.
 238++6C05 ~            		inc ix
 239++6C05 ~            		ld l, (ix)
 240++6C05 ~            		ld h, (ix + 1)
 241++6C05 ~            		ld b, EXT_AU_CNT
 242++6C05 ~            CheckAU:
 243++6C05 ~            		ld a, (ix)
 244++6C05 ~            		or (ix + 1)
 245++6C05 ~            		jr z, CheckAUEnd
 246++6C05 ~            		ld e, (ix)
 247++6C05 ~            		ld d, (ix + 1)
 248++6C05 ~            		inc ix
 249++6C05 ~            		inc ix
 250++6C05 ~            		djnz CheckAU
 251++6C05 ~            CheckAUEnd:
 252++6C05 ~            		ld a, EXT_AU_CNT
 253++6C05 ~            		sub b
 254++6C05 ~            		ld b, a
 255++6C05 ~            	pop ix
 256++6C05 ~            	ret
 257++6C05 ~
 258++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++6C05 ~
 260++6C05 ~            ;Input: TrackBuffer
 261++6C05 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++6C05 ~            ReadUsedBlocksList:
 263++6C05 ~            	ld		ix, TrackBuf			;source buffer
 264++6C05 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++6C05 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 266++6C05 ~            	ld		de, 2					;counter of used blocks, start with 2
 267++6C05 ~            	ld		(hl), e
 268++6C05 ~            	inc		hl
 269++6C05 ~            	ld		(hl), d
 270++6C05 ~            	inc		hl
 271++6C05 ~
 272++6C05 ~            	;Add blocks 0 and 1 for directory
 273++6C05 ~            	ld		de, 0
 274++6C05 ~            	ld		(hl), e
 275++6C05 ~            	inc		hl
 276++6C05 ~            	ld		(hl), d
 277++6C05 ~            	inc		hl
 278++6C05 ~
 279++6C05 ~            	inc		de
 280++6C05 ~            	ld		(hl), e
 281++6C05 ~            	inc		hl
 282++6C05 ~            	ld		(hl), d
 283++6C05 ~            	inc		hl
 284++6C05 ~
 285++6C05 ~            ReadUsedBlocksLoop:
 286++6C05 ~            	xor		a
 287++6C05 ~            	cp		(ix)
 288++6C05 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++6C05 ~
 290++6C05 ~            	push	ix
 291++6C05 ~            	push	bc
 292++6C05 ~            		ld		b, EXT_AU_CNT
 293++6C05 ~            		ld		de, EXT_AU0
 294++6C05 ~            		add		ix, de
 295++6C05 ~
 296++6C05 ~            ReadUsedBlocksLoop2:
 297++6C05 ~            		ld		e, (ix)
 298++6C05 ~            		ld		d, (ix+1)
 299++6C05 ~            		ld		a, e
 300++6C05 ~            		or		d
 301++6C05 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++6C05 ~
 303++6C05 ~            		ld		(hl), e
 304++6C05 ~            		inc		hl
 305++6C05 ~            		ld		(hl), d
 306++6C05 ~            		inc		hl
 307++6C05 ~
 308++6C05 ~            		inc		ix
 309++6C05 ~            		inc		ix
 310++6C05 ~
 311++6C05 ~            		ld		de, (UsedBlockListCnt)
 312++6C05 ~            		inc		de
 313++6C05 ~            		ld		(UsedBlockListCnt), de
 314++6C05 ~
 315++6C05 ~            		djnz	ReadUsedBlocksLoop2
 316++6C05 ~
 317++6C05 ~
 318++6C05 ~            ReadUsedBlocksSkip:
 319++6C05 ~            	pop		bc
 320++6C05 ~            	pop		ix
 321++6C05 ~            ReadUsedBlocksSkip2:
 322++6C05 ~            	ld		de, EXT_SZ
 323++6C05 ~            	add		ix, de
 324++6C05 ~
 325++6C05 ~            	dec		bc
 326++6C05 ~            	ld		a, b
 327++6C05 ~            	or		c
 328++6C05 ~            	jr		nz, ReadUsedBlocksLoop
 329++6C05 ~
 330++6C05 ~            	ret
 331++6C05 ~
 332++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++6C05 ~            ;Reads 8 sectors for an AU
 334++6C05 ~            ;HL = block number, DE = destination buffer
 335++6C05 ~            ReadFSBlock:
 336++6C05 ~            	push	de
 337++6C05 ~            		call	AU2TS		;B=sector, C=track
 338++6C05 ~            	pop		hl				;HL=dest
 339++6C05 ~
 340++6C05 ~            	ld		d, b
 341++6C05 ~            	ld		e, c
 342++6C05 ~            	ld		b, SPAL
 343++6C05 ~
 344++6C05 ~            	call	ReadDiskSectors
 345++6C05 ~            	ret
 346++6C05 ~
 347++6C05 ~
 348++6C05 ~            ;Write 8 sectors for an AU
 349++6C05 ~            ;HL = block number, DE = source buffer
 350++6C05 ~            WriteFSBlock:
 351++6C05 ~            	push	de
 352++6C05 ~            		call	AU2TS		;B=sector, C=track
 353++6C05 ~            	pop		hl				;HL=dest
 354++6C05 ~
 355++6C05 ~            	ld		d, b
 356++6C05 ~            	ld		e, c
 357++6C05 ~            	ld		b, SPAL
 358++6C05 ~
 359++6C05 ~            	call	WriteDiskSectors
 360++6C05 ~            	ret
 361++6C05 ~
 362++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++6C05 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++6C05 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++6C05 ~            CopyDisk:
 366++6C05 ~            	;Get list of used blocks in current disk, max 632 bytes
 367++6C05 ~            	call	ReadUsedBlocksList
 368++6C05 ~            	ld		ix, UsedBlockListBlk
 369++6C05 ~
 370++6C05 ~            CopyDiskLoop:
 371++6C05 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++6C05 ~            	ld		de, MsgBlocksLeft
 373++6C05 ~            	call	Byte2Txt
 374++6C05 ~            	ld		hl, MsgBlocksLeft
 375++6C05 ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++6C05 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++6C05 ~            	call	PrintStrClr
 378++6C05 ~
 379++6C05 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++6C05 ~            	ld		hl, MAX_AU_RAM
 381++6C05 ~            	ld		bc, (UsedBlockListCnt)
 382++6C05 ~            	or		a
 383++6C05 ~            	sbc		hl, bc
 384++6C05 ~            	jr		nc, CopyDiskLoopRead
 385++6C05 ~            	ld		bc, MAX_AU_RAM
 386++6C05 ~
 387++6C05 ~            CopyDiskLoopRead:
 388++6C05 ~            	ld		b, c
 389++6C05 ~            	ld		de, CopyDiskBuf
 390++6C05 ~            	;save initial counter and initial block number array position
 391++6C05 ~            	push	bc
 392++6C05 ~            	push	ix
 393++6C05 ~
 394++6C05 ~            CopyDiskLoopReadLoop:
 395++6C05 ~            		ld		l, (ix)
 396++6C05 ~            		ld		h, (ix+1)
 397++6C05 ~            		inc		ix
 398++6C05 ~            		inc		ix
 399++6C05 ~
 400++6C05 ~            		push	de
 401++6C05 ~            		push	bc
 402++6C05 ~            			call	ReadFSBlock			;Stop on error or continue?
 403++6C05 ~            		pop		bc
 404++6C05 ~            		pop		de
 405++6C05 ~
 406++6C05 ~            		;+2048
 407++6C05 ~            		ld		a, d
 408++6C05 ~            		add		8
 409++6C05 ~            		ld		d, a
 410++6C05 ~
 411++6C05 ~            		djnz	CopyDiskLoopReadLoop
 412++6C05 ~
 413++6C05 ~            		;Check if selection is 1=single drive or 2=dual drive
 414++6C05 ~            		ld		a, (CopySelOption)
 415++6C05 ~            		cp		'1'
 416++6C05 ~            		jr		nz, CopyDiskDualDrive1
 417++6C05 ~
 418++6C05 ~            		;Prompt for disk change
 419++6C05 ~            		call	PromptDiskChangeDst
 420++6C05 ~            		ld		a, (RWTSDrive)
 421++6C05 ~            		call	BDOSInit
 422++6C05 ~            		jr		CopyDiskReadEnd
 423++6C05 ~
 424++6C05 ~            CopyDiskDualDrive1:
 425++6C05 ~            		;alternate drive
 426++6C05 ~            		ld		a, (RWTSDrive)
 427++6C05 ~            		inc 	a
 428++6C05 ~            		xor		%11
 429++6C05 ~            		dec		a
 430++6C05 ~            		ld		(RWTSDrive), a
 431++6C05 ~
 432++6C05 ~            CopyDiskReadEnd:
 433++6C05 ~            	;restore initial counter and initial block number array position
 434++6C05 ~            	pop		ix
 435++6C05 ~            	pop		bc
 436++6C05 ~            	ld		de, CopyDiskBuf
 437++6C05 ~            	push	bc
 438++6C05 ~
 439++6C05 ~            CopyDiskLoopWriteLoop:
 440++6C05 ~            		ld		l, (ix)
 441++6C05 ~            		ld		h, (ix+1)
 442++6C05 ~            		inc		ix
 443++6C05 ~            		inc		ix
 444++6C05 ~
 445++6C05 ~            		push	de
 446++6C05 ~            		push	bc
 447++6C05 ~            			call	WriteFSBlock		;Stop on error or continue?
 448++6C05 ~            		pop		bc
 449++6C05 ~            		pop		de
 450++6C05 ~
 451++6C05 ~            		;+2048
 452++6C05 ~            		ld		a, d
 453++6C05 ~            		add		8
 454++6C05 ~            		ld		d, a
 455++6C05 ~
 456++6C05 ~            		djnz	CopyDiskLoopWriteLoop
 457++6C05 ~
 458++6C05 ~            CopyDiskWriteEnd:
 459++6C05 ~            	pop		bc
 460++6C05 ~            	ld		c, b
 461++6C05 ~            	ld		b, 0
 462++6C05 ~
 463++6C05 ~            	;Decrease number of blocks read by now.
 464++6C05 ~            	ld		hl, (UsedBlockListCnt)
 465++6C05 ~            	or		a
 466++6C05 ~            	sbc		hl, bc
 467++6C05 ~            	ld		(UsedBlockListCnt), hl
 468++6C05 ~
 469++6C05 ~            	ld		a, l
 470++6C05 ~            	or		h
 471++6C05 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++6C05 ~
 473++6C05 ~            	;Check if selection is 1=single drive or 2=dual drive
 474++6C05 ~            	ld		a, (CopySelOption)
 475++6C05 ~            	cp		'1'
 476++6C05 ~            	jr		nz, CopyDiskDualDrive2
 477++6C05 ~
 478++6C05 ~            	;Prompt for disk change
 479++6C05 ~            	call	PromptDiskChangeSrc
 480++6C05 ~            	ld		a, (RWTSDrive)
 481++6C05 ~            	call	BDOSInit
 482++6C05 ~            	jp		CopyDiskLoop
 483++6C05 ~
 484++6C05 ~            CopyDiskDualDrive2:
 485++6C05 ~            	;alternate drive again
 486++6C05 ~            	ld		a, (RWTSDrive)
 487++6C05 ~            	inc		a
 488++6C05 ~            	xor		%11
 489++6C05 ~            	dec		a
 490++6C05 ~            	ld		(RWTSDrive), a
 491++6C05 ~            	jp		CopyDiskLoop
 492++6C05 ~
 493++6C05 ~            CopyDiskEnd:
 494++6C05 ~            	ld		b, 1
 495++6C05 ~            	call	ClearNMsgLines
 496++6C05 ~            	ret
 497++6C05 ~
 498++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++6C05 ~            ;Copies the current disk blocks to COM port.
 500++6C05 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++6C05 ~            CopyDiskToCOM:
 502++6C05 ~            	;Get list of used blocks in current disk, max 632 bytes
 503++6C05 ~            	call	ReadUsedBlocksList
 504++6C05 ~
 505++6C05 ~            	;Send block count and block indexes
 506++6C05 ~            	ld		hl, (UsedBlockListCnt)
 507++6C05 ~            	add		hl, hl
 508++6C05 ~            	inc		hl
 509++6C05 ~            	inc		hl
 510++6C05 ~            	ld		b, h
 511++6C05 ~            	ld		c, l
 512++6C05 ~            	ld		hl, UsedBlockListCnt
 513++6C05 ~            	call	SERTB
 514++6C05 ~
 515++6C05 ~            	ld		ix, UsedBlockListBlk
 516++6C05 ~
 517++6C05 ~            CopyDiskToCOMLoop:
 518++6C05 ~            	;Print block count left
 519++6C05 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++6C05 ~            	ld		de, MsgBlocksLeft
 521++6C05 ~            	call	Byte2Txt
 522++6C05 ~            	ld		hl, MsgBlocksLeft
 523++6C05 ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++6C05 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++6C05 ~            	call	PrintStrClr
 526++6C05 ~
 527++6C05 ~            	;Read block into buffer
 528++6C05 ~            	ld		l, (ix)
 529++6C05 ~            	ld		h, (ix+1)
 530++6C05 ~            	ld		de, CopyDiskBuf
 531++6C05 ~            	push	ix
 532++6C05 ~            		call	ReadFSBlock
 533++6C05 ~            	pop		ix
 534++6C05 ~            	inc		ix
 535++6C05 ~            	inc		ix
 536++6C05 ~
 537++6C05 ~            	;Send block buffer
 538++6C05 ~            	ld		hl, CopyDiskBuf
 539++6C05 ~            	ld		bc, AU_SZ
 540++6C05 ~            	call	SERTB
 541++6C05 ~
 542++6C05 ~            	ld		bc, (UsedBlockListCnt)
 543++6C05 ~            	dec		bc
 544++6C05 ~            	ld		(UsedBlockListCnt), bc
 545++6C05 ~
 546++6C05 ~            	push	ix
 547++6C05 ~            		call	KbdHit
 548++6C05 ~            	pop		ix
 549++6C05 ~            	ret		c
 550++6C05 ~
 551++6C05 ~            	ld		a, b
 552++6C05 ~            	or		c
 553++6C05 ~            	jr		nz, CopyDiskToCOMLoop
 554++6C05 ~
 555++6C05 ~            	ret
 556++6C05 ~
 557++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++6C05 ~            CopyDiskFromCOM:
 559++6C05 ~            	;Receive block count.
 560++6C05 ~            	ld		hl, UsedBlockListCnt
 561++6C05 ~            	ld		bc, 2
 562++6C05 ~            	ld		e, 0
 563++6C05 ~            	call	SERRB
 564++6C05 ~
 565++6C05 ~            	;Receive block indexes.
 566++6C05 ~            	ld		hl, (UsedBlockListCnt)
 567++6C05 ~            	add		hl, hl
 568++6C05 ~            	ld		b, h
 569++6C05 ~            	ld		c, l
 570++6C05 ~            	ld		hl, UsedBlockListBlk
 571++6C05 ~            	ld		e, 0
 572++6C05 ~            	call	SERRB
 573++6C05 ~
 574++6C05 ~            	;Read each block by index and write to disk
 575++6C05 ~            	ld		ix, UsedBlockListBlk
 576++6C05 ~
 577++6C05 ~            CopyDiskFromCOMLoop:
 578++6C05 ~            	;Print block count left
 579++6C05 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++6C05 ~            	ld		de, MsgBlocksLeft
 581++6C05 ~            	call	Byte2Txt
 582++6C05 ~            	ld		hl, MsgBlocksLeft
 583++6C05 ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++6C05 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++6C05 ~            	call	PrintStrClr
 586++6C05 ~
 587++6C05 ~            	;Read block buffer
 588++6C05 ~            	ld		hl, CopyDiskBuf
 589++6C05 ~            	ld		bc, AU_SZ
 590++6C05 ~            	ld		e, 0
 591++6C05 ~            	call	SERRB
 592++6C05 ~
 593++6C05 ~            	;Write block to disk
 594++6C05 ~            	ld		l, (ix)
 595++6C05 ~            	ld		h, (ix+1)
 596++6C05 ~            	ld		de, CopyDiskBuf
 597++6C05 ~            	push	ix
 598++6C05 ~            		call	WriteFSBlock			;Stop on error or continue?
 599++6C05 ~            	pop		ix
 600++6C05 ~            	inc		ix
 601++6C05 ~            	inc		ix
 602++6C05 ~
 603++6C05 ~            	ld		bc, (UsedBlockListCnt)
 604++6C05 ~            	dec		bc
 605++6C05 ~            	ld		(UsedBlockListCnt), bc
 606++6C05 ~
 607++6C05 ~            	push	ix
 608++6C05 ~            		call	KbdHit
 609++6C05 ~            	pop		ix
 610++6C05 ~            	ret		c
 611++6C05 ~
 612++6C05 ~            	ld		a, b
 613++6C05 ~            	or		c
 614++6C05 ~            	jr		nz, CopyDiskFromCOMLoop
 615++6C05 ~            	ret
 616++6C05 ~
 617++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++6C05 ~
 619++6C05 ~            ;Compare string at HL with the one at DE, max length B
 620++6C05 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++6C05 ~            ;OUT: z flag, set = match, reset = mismatch
 622++6C05 ~            StrCmp:
 623++6C05 ~            	push hl
 624++6C05 ~            	push de
 625++6C05 ~            Compare:
 626++6C05 ~            		ld a, (de)
 627++6C05 ~            		cp (hl)
 628++6C05 ~            		jr nz, MisMatch
 629++6C05 ~            		inc hl
 630++6C05 ~            		inc de
 631++6C05 ~            		djnz Compare
 632++6C05 ~            MisMatch:
 633++6C05 ~            	pop de
 634++6C05 ~            	pop hl
 635++6C05 ~            	ret
 636++6C05 ~
 637++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++6C05 ~
 639++6C05 ~            ;Read a file into a buffer, sector by sector.
 640++6C05 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++6C05 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++6C05 ~            ;In: HL = Name address, DE = buffer
 643++6C05 ~            IF1FileLoad:
 644++6C05 ~            	push	de
 645++6C05 ~            		ld (FSTR1), hl
 646++6C05 ~            		ld h, 0
 647++6C05 ~            		ld a, (RWTSDrive)
 648++6C05 ~            		inc  a			;CP/M drive number to BASIC drive number
 649++6C05 ~            		ld	l, a
 650++6C05 ~            		ld (DSTR1), hl
 651++6C05 ~            		ld l,NAMELEN
 652++6C05 ~            		ld (NSTR1), hl
 653++6C05 ~            		rst 08
 654++6C05 ~            		DEFB 51			;open disk channel
 655++6C05 ~
 656++6C05 ~            		rst		8
 657++6C05 ~            		defb	53		;read sector
 658++6C05 ~            	pop		de
 659++6C05 ~            	jr		nc, FileFree
 660++6C05 ~
 661++6C05 ~            	ld		a, (ix + CH_DATA)
 662++6C05 ~            	cp		TEXT_TYPE
 663++6C05 ~            	jr		nc, FileLoadNoHeader
 664++6C05 ~
 665++6C05 ~            FileLoadHeader:
 666++6C05 ~            	push	ix
 667++6C05 ~            	pop		hl
 668++6C05 ~            	ld		bc, CH_DATA + HDR_SZ
 669++6C05 ~            	add		hl, bc
 670++6C05 ~            	ld		bc, SECT_SZ - HDR_SZ
 671++6C05 ~            	ldir
 672++6C05 ~
 673++6C05 ~            FileReadLoop:
 674++6C05 ~            	push	de
 675++6C05 ~            		rst		8
 676++6C05 ~            		defb	53		;read sector
 677++6C05 ~            	pop		de
 678++6C05 ~            	jr		nc, FileFree
 679++6C05 ~
 680++6C05 ~            FileLoadNoHeader:
 681++6C05 ~            	push	ix
 682++6C05 ~            	pop		hl
 683++6C05 ~            	ld		bc, CH_DATA
 684++6C05 ~            	add		hl, bc
 685++6C05 ~            	ld		bc, SECT_SZ
 686++6C05 ~            	ldir
 687++6C05 ~            	jr		FileReadLoop
 688++6C05 ~
 689++6C05 ~            FileFree:
 690++6C05 ~            	push	de
 691++6C05 ~            	rst		8
 692++6C05 ~            	defb	56			;close channel (52) or detroy channel (56)
 693++6C05 ~            	pop		de
 694++6C05 ~            	ret
 695++6C05 ~            IF1FileLoadEnd:
 696++6C05 ~
 697++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++6C05 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++6C05 ~            ;Out: A = error code, 0=OK
 700++6C05 ~            ReadDiskSectors:
 701++6C05 ~            	push bc
 702++6C05 ~            		push hl
 703++6C05 ~            			push de
 704++6C05 ~            				call ReadOneDiskSector
 705++6C05 ~            			pop de
 706++6C05 ~            		pop hl
 707++6C05 ~
 708++6C05 ~            		inc d
 709++6C05 ~            		inc h
 710++6C05 ~            	pop bc
 711++6C05 ~
 712++6C05 ~            	ld	a, (RWTSRes)
 713++6C05 ~            	or	a
 714++6C05 ~            	ret nz
 715++6C05 ~
 716++6C05 ~            	djnz ReadDiskSectors
 717++6C05 ~            	ret
 718++6C05 ~
 719++6C05 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++6C05 ~            ;Out: A = error code, 0=OK
 721++6C05 ~            WriteDiskSectors:
 722++6C05 ~            	push bc
 723++6C05 ~            		push hl
 724++6C05 ~            			push de
 725++6C05 ~            				call WriteOneDiskSector
 726++6C05 ~            			pop de
 727++6C05 ~            		pop hl
 728++6C05 ~
 729++6C05 ~            		inc d
 730++6C05 ~            		inc h
 731++6C05 ~            	pop bc
 732++6C05 ~
 733++6C05 ~            	ld	a, (RWTSRes)
 734++6C05 ~            	or	a
 735++6C05 ~            	ret nz
 736++6C05 ~
 737++6C05 ~            	djnz WriteDiskSectors
 738++6C05 ~            	ret
 739++6C05 ~
 740++6C05 ~
 741++6C05 ~            ;Reads disk catalog
 742++6C05 ~            ReadCatalogTrack:
 743++6C05 ~            	ld hl, TrackBuf
 744++6C05 ~            	ld de, 0
 745++6C05 ~            	ld b, SPT
 746++6C05 ~
 747++6C05 ~            	call ReadDiskSectors
 748++6C05 ~            	ret
 749++6C05 ~
 750++6C05 ~            ;A = track
 751++6C05 ~            SeekTrack:
 752++6C05 ~            	IFUSED
 753++6C05 ~            	ld	(RWTSTrack), a
 754++6C05 ~            	ld 	a, RWTS_CMD_SEEK
 755++6C05 ~            	jp	RWTS
 756++6C05 ~            	ENDIF
 757++6C05 ~
 758++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759++6C05 ~
 760++6C05 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761++6C05 ~            FindCache:
 762++6C05 ~            	ld		b, NAMELEN
 763++6C05 ~            	call	StrCmp			;find the file to wich this extension belongs
 764++6C05 ~            	ret		z
 765++6C05 ~
 766++6C05 ~            	dec		c
 767++6C05 ~            	jr		nz, CacheNotFinished
 768++6C05 ~            	or		c
 769++6C05 ~            	ret
 770++6C05 ~
 771++6C05 ~            CacheNotFinished:
 772++6C05 ~            	ld		bc, CACHE_SZ
 773++6C05 ~            	add		hl, bc			;to the next cache line
 774++6C05 ~            	jr		FindCache
 775++6C05 ~
 776++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777++6C05 ~
 778++6C05 ~            	;ld		ix, (SelFileCache)
 779++6C05 ~            ReadFileHeader:
 780++6C05 ~            	ld		a, (ix + CACHE_FLAG)
 781++6C05 ~            	or		a
 782++6C05 ~            	ret		nz				;return if already read
 783++6C05 ~
 784++6C05 ~            	ld		l, (ix + CACHE_FIRST_AU)
 785++6C05 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 786++6C05 ~            	ld		a, h
 787++6C05 ~            	or		l
 788++6C05 ~            	jr		z, ReadHeaderEnd
 789++6C05 ~
 790++6C05 ~            	call	AU2TS
 791++6C05 ~            	ld		d, b
 792++6C05 ~            	ld		e, c
 793++6C05 ~            	ld		hl, DataBuf
 794++6C05 ~            	push	ix
 795++6C05 ~            	push	ix
 796++6C05 ~            		call	ReadOneDiskSector
 797++6C05 ~            	pop		hl
 798++6C05 ~            	pop		ix
 799++6C05 ~
 800++6C05 ~            	push	hl
 801++6C05 ~            		ld		hl, DataBuf
 802++6C05 ~            		call	IsFileHeaderValid
 803++6C05 ~            	pop		hl
 804++6C05 ~            	or		a
 805++6C05 ~            	jr		z, ReadFileHeaderIsTextFile
 806++6C05 ~
 807++6C05 ~            	ld		bc, CACHE_HDR
 808++6C05 ~            	add		hl, bc
 809++6C05 ~            	ex		hl, de
 810++6C05 ~            	ld		hl, DataBuf
 811++6C05 ~            	ld		bc, HDR_SZ
 812++6C05 ~            	ldir
 813++6C05 ~
 814++6C05 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 815++6C05 ~            	ld		a, BYTE_TYPE
 816++6C05 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 817++6C05 ~            	jr		nc, ReadHeaderEnd
 818++6C05 ~
 819++6C05 ~            ReadFileHeaderIsTextFile:
 820++6C05 ~            	push	ix
 821++6C05 ~            	push	ix
 822++6C05 ~            	pop		hl
 823++6C05 ~            		call	GetFileSize
 824++6C05 ~            	pop		ix
 825++6C05 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 826++6C05 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827++6C05 ~            	ld		a, TEXT_TYPE
 828++6C05 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829++6C05 ~
 830++6C05 ~            ReadHeaderEnd:
 831++6C05 ~            	inc		(ix + CACHE_FLAG)
 832++6C05 ~            	ret
 833++6C05 ~
 834++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835++6C05 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 836++6C05 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837++6C05 ~            ;In: HL = header
 838++6C05 ~            ;Out: A > 0 if valid
 839++6C05 ~            IsFileHeaderValid:
 840++6C05 ~            	IFUSED
 841++6C05 ~            	xor		a
 842++6C05 ~            	ld		b, HDR_SZ
 843++6C05 ~            IsFileHeaderValidLoop:
 844++6C05 ~            	or		(hl)
 845++6C05 ~            	inc		hl
 846++6C05 ~            	djnz	IsFileHeaderValidLoop
 847++6C05 ~
 848++6C05 ~            	ret
 849++6C05 ~            	ENDIF
 850++6C05 ~
 851++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852++6C05 ~
 853++6C05 ~            ;IN: HL = address from IF1 to call
 854++6C05 ~            IF1Call:
 855++6C05 ~            	LD   (HD11), HL
 856++6C05 ~            	RST  8
 857++6C05 ~            	DEFB 50
 858++6C05 ~            	RET
 859++6C05 ~
 860++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861++6C05 ~
 862++6C05 ~            ;Load a program from disk
 863++6C05 ~            ;IN: HL = file name addr
 864++6C05 ~            LoadProgram:
 865++6C05 ~            	LD   (FSTR1), HL
 866++6C05 ~            	LD   H, 0
 867++6C05 ~            	LD   L, NAMELEN
 868++6C05 ~            	LD   (NSTR1), HL
 869++6C05 ~            	LD	 A, (RWTSDrive)
 870++6C05 ~            	INC  A					;Adapt for BASIC drive number
 871++6C05 ~            	LD   L, A
 872++6C05 ~            	LD   (DSTR1), HL
 873++6C05 ~            	LD   HL, LOAD_ADDR
 874++6C05 ~            	CALL IF1Call
 875++6C05 ~            	RET
 876++6C05 ~
 877++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878++6C05 ~
 879++6C05 ~            SetFastKeys:
 880++6C05 ~            	ld		hl, REPDEL
 881++6C05 ~            	ld		de, (1 << 8) | 15
 882++6C05 ~            	ld		(hl), de
 883++6C05 ~
 884++6C05 ~            	ret
 885++6C05 ~
 886++6C05 ~
 887++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 888++6C05 ~            ;Reads the error message string from IF1 ROM.
 889++6C05 ~            GetErrMsg:
 890++6C05 ~            	inc		a
 891++6C05 ~            	ex		af, af'
 892++6C05 ~
 893++6C05 ~            	ld		hl, IF1Paged			;page-in IF1
 894++6C05 ~            	jp		IF1Call
 895++6C05 ~
 896++6C05 ~            IF1Paged:
 897++6C05 ~            	ld		hl, ERRMSG
 898++6C05 ~            	ex		af, af'
 899++6C05 ~            	or		a
 900++6C05 ~            	jr		z, SaveMsg
 901++6C05 ~
 902++6C05 ~            	ld		b, 0
 903++6C05 ~            SearchMsgEnd:
 904++6C05 ~            	bit		7, (hl)
 905++6C05 ~            	inc		hl
 906++6C05 ~            	jr		z, SearchMsgEnd
 907++6C05 ~
 908++6C05 ~            	inc		b
 909++6C05 ~            	cp		b
 910++6C05 ~            	jr		nz, SearchMsgEnd
 911++6C05 ~
 912++6C05 ~            SaveMsg:
 913++6C05 ~            	ld		de, DataBuf
 914++6C05 ~            CopyMsg:
 915++6C05 ~            	ld		a, (hl)
 916++6C05 ~            	bit		7, a
 917++6C05 ~            	ld		(de), a
 918++6C05 ~            	inc		hl
 919++6C05 ~            	inc		de
 920++6C05 ~            	jr		z, CopyMsg
 921++6C05 ~
 922++6C05 ~            	ret
 923++6C05 ~
 924++6C05 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 925++6C05 ~
 926++6C05 ~            ;RWTS routine I/O block
 927++6C05 ~            RWTSParams:
 928++6C05 ~            RWTSBlockType	DEFB	1							;?
 929++6C05 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 930++6C05 ~            RWTSVolNo		DEFB	0							;?
 931++6C05 ~            RWTSTrack		DEFB	0
 932++6C05 ~            RWTSSector		DEFB	0
 933++6C05 ~            RWTSDMA			DEFW	0
 934++6C05 ~            RWTSExtBuf		DEFW	$2932
 935++6C05 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 936++6C05 ~            	IFDEF _REAL_HW_
 937++6C05 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 938++6C05 ~            	ELSE
 939++6C05 ~            RWTSPrmTbl		DEFW	$1f2a
 940++6C05 ~            	ENDIF
 941++6C05 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 942++6C05 ~            ;Results
 943++6C05 ~            RWTSRes			DEFB	0
 944++6C05 ~            RWTSResVolNo	DEFB	0
 945++6C05 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 946++6C05 ~
 947++6C05 ~            ;Param. table, usualy found in ROM.
 948++6C05 ~            	IFDEF _REAL_HW_
 949++6C05 ~            BasPrmTbl:
 950++6C05 ~
 951++6C05 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 952++6C05 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 953++6C05 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 954++6C05 ~            PrmDevType		DEFB	$01
 955++6C05 ~            PrmStepRate		DEFB	$0D		;(milisec)
 956++6C05 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 957++6C05 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 958++6C05 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 959++6C05 ~            PrmDevType		DEFB	$01
 960++6C05 ~            PrmStepRate		DEFB	$0D/3		;(milisec)
 961++6C05 ~            PrmHeadLoad		DEFB	$23/3		;(milisec)
 962++6C05 ~            PrmSpinUp		DEFB	$64/3		;(1/100 sec)
 963++6C05 ~            	ENDIF
 964++6C05 ~
 965++6C05 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 966++6C05 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 967++6C05 ~            	ENDIF
 968++6C05 ~
 969++6C05              	endif
# file closed: if1.asm
   7+ 6C05
   8+ 6C05              BDOSInit:
   9+ 6C05 AF           	xor		a
  10+ 6C06 18 49        	jr		BDOS
  11+ 6C08
  12+ 6C08
  13+ 6C08              ;IN: A = Drive to select
  14+ 6C08              BDOSSelectDisk:
  15+ 6C08              	IFUSED
  16+ 6C08 DD 6F        	ld		ixl, a
  17+ 6C0A DD 26 00     	ld		ixh, 0
  18+ 6C0D 3E 01        	ld		a, 1
  19+ 6C0F 18 40        	jr		BDOS
  20+ 6C11              	ENDIF
  21+ 6C11
  22+ 6C11
  23+ 6C11              BDOSMakeDiskRO:
  24+ 6C11              	IFUSED
  25+ 6C11 ~            	ld		a, 15
  26+ 6C11 ~            	jr		BDOS
  27+ 6C11              	ENDIF
  28+ 6C11
  29+ 6C11              ;Get Read Only flag
  30+ 6C11              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 6C11              BDOSGetDiskRO:
  32+ 6C11              	IFUSED
  33+ 6C11 ~            	ld	a, 16
  34+ 6C11 ~            	jr	BDOS
  35+ 6C11              	ENDIF
  36+ 6C11
  37+ 6C11              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 6C11              BDOSGetCurrentDrive:
  39+ 6C11              	IFUSED
  40+ 6C11 3E 0C        	ld		a, 12
  41+ 6C13 18 3C        	jr		BDOS
  42+ 6C15              	ENDIF
  43+ 6C15
  44+ 6C15              ;Does log-off for all drives?
  45+ 6C15              BDOSCloseDrives:
  46+ 6C15              	IFUSED
  47+ 6C15 ~            	ld		ixl, a
  48+ 6C15 ~            	ld		ixh, 0
  49+ 6C15 ~            	ld		a, 22
  50+ 6C15 ~            	jr		BDOS
  51+ 6C15              	ENDIF
  52+ 6C15
  53+ 6C15              ;Create a disk channel for BDOS access (does not open the file)
  54+ 6C15              ;IN: HL=name addr, A=drive
  55+ 6C15              ;OUT: IX=FCB
  56+ 6C15              CreateChannel:
  57+ 6C15 22 DC 5C     	ld (FSTR1), hl
  58+ 6C18 26 00        	ld h,0
  59+ 6C1A 6F           	ld l,a
  60+ 6C1B 22 D6 5C     	ld (DSTR1), hl
  61+ 6C1E 2E 0B        	ld l,NAMELEN
  62+ 6C20 22 DA 5C     	ld (NSTR1), hl
  63+ 6C23 CF           	rst 08
  64+ 6C24 37           	DEFB 55
  65+ 6C25 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 6C28 DD 09        	add ix, bc
  67+ 6C2A C9           	ret
  68+ 6C2B
  69+ 6C2B
  70+ 6C2B              ;Destroy a BDOS channel
  71+ 6C2B              ;IN: IX=FCB
  72+ 6C2B              DestroyChannel:
  73+ 6C2B C5           	push bc
  74+ 6C2C 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 6C2F DD 09        	add ix, bc
  76+ 6C31 CF           	rst 08
  77+ 6C32 38           	DEFB 56
  78+ 6C33 C1           	pop bc
  79+ 6C34 C9           	ret
  80+ 6C35
  81+ 6C35
  82+ 6C35              ;Input: IX=FCB
  83+ 6C35              BDOSCreateFile:
  84+ 6C35 3E 09        	ld	a, 9
  85+ 6C37 18 18        	jr	BDOS
  86+ 6C39
  87+ 6C39              ;Input: IX=FCB
  88+ 6C39              BDOSOpenFile:
  89+ 6C39 3E 02        	ld	a, 2
  90+ 6C3B 18 14        	jr	BDOS
  91+ 6C3D
  92+ 6C3D              ;IN: IX=FCB
  93+ 6C3D              BDOSCloseFile:
  94+ 6C3D 3E 03        	ld	a, 3
  95+ 6C3F 18 10        	jr	BDOS
  96+ 6C41
  97+ 6C41
  98+ 6C41              ;0 OK,
  99+ 6C41              ;1 end of file,
 100+ 6C41              ;9 invalid FCB,
 101+ 6C41              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 6C41              ;11 (MP/M) unlocked file verification error,
 103+ 6C41              ;0FFh hardware error.
 104+ 6C41
 105+ 6C41              ;IN: IX=FCB
 106+ 6C41              BDOSReadFileBlockSeq:
 107+ 6C41 3E 07        	ld	a, 7
 108+ 6C43 18 0C        	jr	BDOS
 109+ 6C45
 110+ 6C45
 111+ 6C45              ;0 OK,
 112+ 6C45              ;1 directory full,
 113+ 6C45              ;2 disc full,
 114+ 6C45              ;8 (MP/M) record locked by another process,
 115+ 6C45              ;9 invalid FCB,
 116+ 6C45              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 6C45              ;11 (MP/M) unlocked file verification error,
 118+ 6C45              ;0FFh hardware error.
 119+ 6C45
 120+ 6C45              ;IN: IX=FCB
 121+ 6C45              BDOSWriteFileBlockSeq:
 122+ 6C45 3E 08        	ld	a, 8
 123+ 6C47 18 08        	jr	BDOS
 124+ 6C49
 125+ 6C49
 126+ 6C49              ;0 OK
 127+ 6C49              ;1 Reading unwritten data
 128+ 6C49              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 6C49              ;6 Record number out of range
 130+ 6C49              ;9 Invalid FCB
 131+ 6C49              BDOSReadFileBlockRandom:
 132+ 6C49 3E 12        	ld	a, 18
 133+ 6C4B 18 04        	jr	BDOS
 134+ 6C4D
 135+ 6C4D              ;0 OK
 136+ 6C4D              ;2 Disc full
 137+ 6C4D              ;3 Cannot close extent
 138+ 6C4D              ;5 Directory full
 139+ 6C4D              ;6 Record number out of range
 140+ 6C4D              ;8 Record is locked by another process (MP/M)
 141+ 6C4D              ;9 Invalid FCB
 142+ 6C4D              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 6C4D              BDOSWriteFileBlockRandom:
 144+ 6C4D 3E 13        	ld	a, 19
 145+ 6C4F 18 00        	jr	BDOS
 146+ 6C51
 147+ 6C51
 148+ 6C51              ;Generic BDOS call
 149+ 6C51              ;IX=arg, A=function
 150+ 6C51              BDOS:
 151+ 6C51 DD 22 ED 5C  	ld (HD11), ix
 152+ 6C55 32 EF 5C     	ld (COPIES), a
 153+ 6C58 CF           	rst 08
 154+ 6C59 39           	DEFB 57
 155+ 6C5A C9           	ret
 156+ 6C5B
 157+ 6C5B              ;Set DMA address for BDOS
 158+ 6C5B              ;IX=DMA
 159+ 6C5B              BDOSSetDMA:
 160+ 6C5B 3E 0D        	ld a, 13
 161+ 6C5D 18 F2        	jr BDOS
 162+ 6C5F
 163+ 6C5F              ;In: IX=FCB
 164+ 6C5F              BDOSSetRandFilePtr:
 165+ 6C5F 3E 15        	ld	a, 21
 166+ 6C61 18 EE        	jr	BDOS
 167+ 6C63
 168+ 6C63              ;In: HL=filename
 169+ 6C63              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 6C63              GetFileSize:
 171+ 6C63              	IFUSED
 172+ 6C63
 173+ 6C63 3A ED 6B     	ld 		a, (RWTSDrive)
 174+ 6C66 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 6C67 CD 15 6C     	call	CreateChannel
 176+ 6C6A
 177+ 6C6A 3E 14        	ld		a, 20
 178+ 6C6C CD 51 6C     	call	BDOS
 179+ 6C6F              	;inc		a
 180+ 6C6F              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 6C6F
 182+ 6C6F DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 6C72 DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 6C75
 185+ 6C75              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 6C75 3E 01        	ld		a, 1
 187+ 6C77 BC           	cp		h
 188+ 6C78 30 05        	jr		nc, GetFileSizeOK
 189+ 6C7A 21 00 00     	ld		hl, 0
 190+ 6C7D 18 08        	jr		GetFileSizeEnd
 191+ 6C7F
 192+ 6C7F              GetFileSizeOK:
 193+ 6C7F              	;*128 == 2^7
 194+ 6C7F 06 07        	ld		b, 7
 195+ 6C81              GetFileSizeMul:
 196+ 6C81 CB 15        	rl		l
 197+ 6C83 CB 14        	rl		h
 198+ 6C85 10 FA        	djnz	GetFileSizeMul
 199+ 6C87
 200+ 6C87              GetFileSizeEnd:
 201+ 6C87 E5           	push	hl
 202+ 6C88 CD 2B 6C     		call	DestroyChannel
 203+ 6C8B E1           	pop		hl
 204+ 6C8C
 205+ 6C8C C9           	ret
 206+ 6C8D              	ENDIF
 207+ 6C8D
 208+ 6C8D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 6C8D              ;HL=file name, A=drive
 210+ 6C8D              DeleteFile:
 211+ 6C8D CD 15 6C     	call	CreateChannel
 212+ 6C90
 213+ 6C90 3E 06        	ld		a, 6
 214+ 6C92 CD 51 6C     	call	BDOS
 215+ 6C95
 216+ 6C95 CD 2B 6C     	call	DestroyChannel
 217+ 6C98 C9           	ret
 218+ 6C99
 219+ 6C99              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 6C99              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 6C99              ;HL=file name, A=drive
 222+ 6C99              DoesFileExist:
 223+ 6C99              	IFUSED
 224+ 6C99              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 6C99 F5           	push	af
 226+ 6C9A E5           	push	hl
 227+ 6C9B DD 21 47 FA  		ld		ix, FileIdx
 228+ 6C9F CD 5B 6C     		call 	BDOSSetDMA
 229+ 6CA2 E1           	pop		hl
 230+ 6CA3 F1           	pop		af
 231+ 6CA4
 232+ 6CA4 CD 15 6C     	call	CreateChannel
 233+ 6CA7
 234+ 6CA7              	;Uses FindFirst system call.
 235+ 6CA7 3E 04        	ld		a, 4
 236+ 6CA9 CD 51 6C     	call	BDOS
 237+ 6CAC
 238+ 6CAC F5           	push	af
 239+ 6CAD CD 2B 6C     		call	DestroyChannel
 240+ 6CB0 F1           	pop		af
 241+ 6CB1 C9           	ret
 242+ 6CB2              	ENDIF
 243+ 6CB2
 244+ 6CB2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 6CB2              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 6CB2              ChangeFileAttrib:
 247+ 6CB2 3A ED 6B     	ld 		a, (RWTSDrive)
 248+ 6CB5 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 6CB6 D5           	push	de
 250+ 6CB7 CD 15 6C     	call	CreateChannel
 251+ 6CBA D1           	pop		de
 252+ 6CBB
 253+ 6CBB DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 6CBE CB 27        	sla		a								;reset existing attribute flag
 255+ 6CC0 CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 6CC2 CB 1F        	rr		a								;put Carry flag in register L
 257+ 6CC4 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 6CC7
 259+ 6CC7 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 6CCA CB 27        	sla		a
 261+ 6CCC CB 1B        	rr		e
 262+ 6CCE CB 1F        	rr		a
 263+ 6CD0 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 6CD3
 265+ 6CD3              FileAttribSet:
 266+ 6CD3 3E 11        	ld		a, 17
 267+ 6CD5 CD 51 6C     	call	BDOS
 268+ 6CD8
 269+ 6CD8 CD 2B 6C     	call	DestroyChannel
 270+ 6CDB C9           	ret
 271+ 6CDC
 272+ 6CDC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 6CDC
 274+ 6CDC              ;HL=original name, DE = new name
 275+ 6CDC              ;Works only on the same drive.
 276+ 6CDC              RenameFile:
 277+ 6CDC 3A ED 6B     	ld 		a, (RWTSDrive)
 278+ 6CDF 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 6CE0 D5           	push	de
 280+ 6CE1 CD 15 6C     	call	CreateChannel
 281+ 6CE4 D1           	pop		de
 282+ 6CE5
 283+ 6CE5 DD E5        	push	ix					;IX == FCB
 284+ 6CE7 E1           	pop		hl
 285+ 6CE8 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 6CEB 09           	add		hl, bc
 287+ 6CEC EB           	ex		de, hl
 288+ 6CED 3A ED 6B     	ld		a, (RWTSDrive)
 289+ 6CF0 12           	ld		(de), a
 290+ 6CF1 01 0B 00     	ld		bc, NAMELEN
 291+ 6CF4 ED B0        	ldir
 292+ 6CF6
 293+ 6CF6 3E 0A        	ld		a, 10
 294+ 6CF8 CD 51 6C     	call	BDOS
 295+ 6CFB
 296+ 6CFB CD 2B 6C     	call	DestroyChannel
 297+ 6CFE C9           	ret
 298+ 6CFF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 6CFF              PromptDiskChangeDst:
 300+ 6CFF 21 CF 78     	ld		hl, MsgInsertDstDsk
 301+ 6D02 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 6D05 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 6D07 CD AF 70     	call	PrintStrClr
 304+ 6D0A 21 DE 78     	ld		hl, MsgPressAnyKey
 305+ 6D0D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 6D10 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 6D12 CD AF 70     	call	PrintStrClr
 308+ 6D15 CD 4B 70     	call	ReadChar
 309+ 6D18 C9           	ret
 310+ 6D19
 311+ 6D19              PromptDiskChangeSrc:
 312+ 6D19 21 C0 78     	ld		hl, MsgInsertSrcDsk
 313+ 6D1C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 6D1F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 6D21 CD AF 70     	call	PrintStrClr
 316+ 6D24 21 DE 78     	ld		hl, MsgPressAnyKey
 317+ 6D27 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 6D2A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 6D2C CD AF 70     	call	PrintStrClr
 320+ 6D2F CD 4B 70     	call	ReadChar
 321+ 6D32 C9           	ret
 322+ 6D33              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 6D33
 324+ 6D33              ;HL = source file name, A = source drive
 325+ 6D33              ;Use cases:
 326+ 6D33              ;1. Copy from A: to B: or B: to A:.
 327+ 6D33              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 6D33              ;3. Copy from A:/B: to COM.
 329+ 6D33              ;4. Copy from COM to A:/B:.
 330+ 6D33              ;Single drive scenario:
 331+ 6D33              ;1. Read first file part,
 332+ 6D33              ;2. Ask for dest disk,
 333+ 6D33              ;3. check if file exists/ask for overwrite,
 334+ 6D33              ;4. create empty dest file,
 335+ 6D33              ;5. write first file part,
 336+ 6D33              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 6D33              CopyFile:
 338+ 6D33 3A ED 6B     	ld 		a, (RWTSDrive)
 339+ 6D36 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 6D37 32 11 79     	ld		(CopyFileSrcDrv), a
 341+ 6D3A 32 1D 79     	ld		(CopyFileDstDrv), a
 342+ 6D3D 11 12 79     	ld		de, CopyFileSrcName
 343+ 6D40 01 0B 00     	ld		bc, NAMELEN
 344+ 6D43 E5           	push	hl
 345+ 6D44 C5           	push	bc
 346+ 6D45 ED B0        	ldir
 347+ 6D47 C1           	pop		bc
 348+ 6D48 E1           	pop		hl
 349+ 6D49 11 1E 79     	ld		de, CopyFileDstName
 350+ 6D4C ED B0        	ldir
 351+ 6D4E
 352+ 6D4E              	;Reset R/O attribute for destination, to allow file write.
 353+ 6D4E 3A 26 79     	ld		a, (CopyFileDstName+RO_POS)
 354+ 6D51 CB BF        	res		7, a
 355+ 6D53 32 26 79     	ld		(CopyFileDstName+RO_POS), a
 356+ 6D56
 357+ 6D56 AF           	xor		a
 358+ 6D57 32 09 79     	ld		(CopyFileRes), a
 359+ 6D5A 11 00 00     	ld		de, 0
 360+ 6D5D ED 53 0C 79  	ld		(FilePosRead), de
 361+ 6D61 ED 53 0E 79  	ld		(FilePosWrite), de
 362+ 6D65
 363+ 6D65 3A 11 79     	ld		a, (CopyFileSrcDrv)
 364+ 6D68 C6 40        	add		'A'-1
 365+ 6D6A              	;Update menu messages with current drive.
 366+ 6D6A 32 48 78     	ld		(MsgMenuSingleDrv1), a
 367+ 6D6D 32 4C 78     	ld		(MsgMenuSingleDrv2), a
 368+ 6D70 32 56 78     	ld		(MsgMenuDualDrv1), a
 369+ 6D73 32 64 78     	ld		(MsgMenuToComDrv), a
 370+ 6D76 32 78 78     	ld		(MsgMenuFromCOMDrv), a
 371+ 6D79              	;Update menu messages with the alternate drive.
 372+ 6D79 3A 11 79     	ld		a, (CopyFileSrcDrv)
 373+ 6D7C EE 03        	xor		%11
 374+ 6D7E C6 40        	add		'A'-1
 375+ 6D80 32 5A 78     	ld		(MsgMenuDualDrv2), a
 376+ 6D83
 377+ 6D83 21 25 78     	ld		hl, MsgMenuFileCopy
 378+ 6D86 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 6D89 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 6D8B CD AF 70     	call	PrintStrClr
 381+ 6D8E 21 34 78     	ld		hl, MsgMenuBack
 382+ 6D91 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 6D94 CD 87 70     	call	PrintStr
 384+ 6D97 21 40 78     	ld		hl, MsgMenuSingle
 385+ 6D9A 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 6D9D CD 87 70     	call	PrintStr
 387+ 6DA0 21 4E 78     	ld		hl, MsgMenuDual
 388+ 6DA3 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 6DA6 CD 87 70     	call	PrintStr
 390+ 6DA9 21 5C 78     	ld		hl, MsgMenuToCOM
 391+ 6DAC 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 6DAF CD 87 70     	call	PrintStr
 393+ 6DB2 21 6B 78     	ld		hl, MsgMenuFromCOM
 394+ 6DB5 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 6DB8 CD 87 70     	call	PrintStr
 396+ 6DBB
 397+ 6DBB CD 4B 70     	call	ReadChar
 398+ 6DBE 32 06 79     	ld		(CopySelOption), a
 399+ 6DC1
 400+ 6DC1 F5           	push	af
 401+ 6DC2 06 06        		ld		b, 6
 402+ 6DC4 CD 33 72     		call	ClearNMsgLines
 403+ 6DC7 F1           	pop		af
 404+ 6DC8
 405+ 6DC8              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 6DC8 FE 30        	cp		'0'
 407+ 6DCA 20 04        	jr		nz, CopyFileNotExit
 408+ 6DCC E1           	pop		hl
 409+ 6DCD C3 68 61     	jp		ReadKeyLoop
 410+ 6DD0
 411+ 6DD0              CopyFileNotExit:
 412+ 6DD0 FE 31        	cp		'1'
 413+ 6DD2 28 4D        	jr		z, CopyFileSameDrive
 414+ 6DD4
 415+ 6DD4 FE 32        	cp		'2'
 416+ 6DD6 CA 9C 6E     	jp		z, CopyFileDualDrive
 417+ 6DD9
 418+ 6DD9 FE 33        	cp		'3'
 419+ 6DDB CA E4 6E     	jp		z, CopyFileToCOM
 420+ 6DDE
 421+ 6DDE FE 34        	cp		'4'
 422+ 6DE0 CA 15 6F     	jp		z, CopyFileFromCOM
 423+ 6DE3
 424+ 6DE3 E1           	pop		hl
 425+ 6DE4 C3 68 61     	jp		ReadKeyLoop
 426+ 6DE7
 427+ 6DE7
 428+ 6DE7              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 6DE7              CopyFileCheckOverwrite:
 430+ 6DE7              	;Check if destination file exists.
 431+ 6DE7 3A 1D 79     	ld		a, (CopyFileDstDrv)
 432+ 6DEA 21 1E 79     	ld		hl, CopyFileDstName
 433+ 6DED CD 99 6C     	call	DoesFileExist
 434+ 6DF0 3C           	inc		a
 435+ 6DF1 C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 6DF2
 437+ 6DF2              	;Ask overwrite confirmation.
 438+ 6DF2 21 A2 78     	ld		hl, MsgFileOverwrite
 439+ 6DF5 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 6DF8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 6DFA CD AF 70     	call	PrintStrClr
 442+ 6DFD CD 4B 70     	call	ReadChar
 443+ 6E00 FE 79        	cp		'y'
 444+ 6E02 C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 6E03
 446+ 6E03
 447+ 6E03              CopyFileCreateNewFile:
 448+ 6E03 3A 1D 79     	ld		a, (CopyFileDstDrv)
 449+ 6E06 21 1E 79     	ld		hl, CopyFileDstName
 450+ 6E09 F5           	push	af
 451+ 6E0A E5           	push	hl
 452+ 6E0B CD 8D 6C     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 6E0E E1           	pop		hl
 454+ 6E0F F1           	pop		af
 455+ 6E10 CD 15 6C     	call	CreateChannel
 456+ 6E13 CD 35 6C     	call 	BDOSCreateFile
 457+ 6E16 3C           	inc  	a						;Cancel if A==$FF
 458+ 6E17 C8           	ret		z
 459+ 6E18
 460+ 6E18              	;Close dest file once created.
 461+ 6E18 F5           	push	af
 462+ 6E19 CD 3D 6C     		call	BDOSCloseFile
 463+ 6E1C CD 2B 6C     		call	DestroyChannel
 464+ 6E1F F1           	pop		af
 465+ 6E20 C9           	ret
 466+ 6E21
 467+ 6E21              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 6E21              CopyFileSameDrive:
 469+ 6E21              	;Read first file section from SRC.
 470+ 6E21 3A 11 79     	ld		a, (CopyFileSrcDrv)
 471+ 6E24 21 12 79     	ld		hl, CopyFileSrcName
 472+ 6E27 CD 98 6F     	call	ReadFileSection
 473+ 6E2A 3A 10 79     	ld		a, (CopyFileSectCnt)
 474+ 6E2D B7           	or		a
 475+ 6E2E C8           	ret		z
 476+ 6E2F
 477+ 6E2F              	;Prompt for DST disk change.
 478+ 6E2F CD FF 6C     	call	PromptDiskChangeDst
 479+ 6E32 3A ED 6B     	ld		a, (RWTSDrive)
 480+ 6E35 CD 05 6C     	call	BDOSInit
 481+ 6E38
 482+ 6E38 06 02        	ld		b, 2
 483+ 6E3A CD 33 72     	call	ClearNMsgLines
 484+ 6E3D
 485+ 6E3D CD E7 6D     	call	CopyFileCheckOverwrite
 486+ 6E40 C0           	ret		nz
 487+ 6E41
 488+ 6E41 CD 03 6E     	call	CopyFileCreateNewFile
 489+ 6E44 C8           	ret		z
 490+ 6E45
 491+ 6E45              CopyFileSameDriveLoop:
 492+ 6E45 3A 10 79     	ld		a, (CopyFileSectCnt)
 493+ 6E48 6F           	ld		l, a
 494+ 6E49 26 00        	ld		h, 0
 495+ 6E4B 11 EB 78     	ld		de, MsgCopySectors
 496+ 6E4E CD C4 67     	call	Byte2Txt
 497+ 6E51 21 EB 78     	ld		hl, MsgCopySectors
 498+ 6E54 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 499+ 6E57 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 500+ 6E59 CD AF 70     	call	PrintStrClr
 501+ 6E5C
 502+ 6E5C 3A 09 79     	ld		a, (CopyFileRes)			;Save read status code.
 503+ 6E5F F5           	push	af
 504+ 6E60 3A 1D 79     		ld		a, (CopyFileDstDrv)
 505+ 6E63 21 1E 79     		ld		hl, CopyFileDstName
 506+ 6E66 CD BA 6F     		call	WriteFileSection
 507+ 6E69 3A 09 79     		ld		a, (CopyFileRes)
 508+ 6E6C 6F           		ld		l, a
 509+ 6E6D F1           	pop		af
 510+ 6E6E B5           	or		l
 511+ 6E6F C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 512+ 6E70
 513+ 6E70
 514+ 6E70              	;Prompt for SRC disk change.
 515+ 6E70 CD 19 6D     	call	PromptDiskChangeSrc
 516+ 6E73 3A ED 6B     	ld		a, (RWTSDrive)
 517+ 6E76 CD 05 6C     	call	BDOSInit
 518+ 6E79
 519+ 6E79 06 02        	ld		b, 2
 520+ 6E7B CD 33 72     	call	ClearNMsgLines
 521+ 6E7E
 522+ 6E7E 3A 11 79     	ld		a, (CopyFileSrcDrv)
 523+ 6E81 21 12 79     	ld		hl, CopyFileSrcName
 524+ 6E84 CD 98 6F     	call	ReadFileSection
 525+ 6E87 3A 10 79     	ld		a, (CopyFileSectCnt)
 526+ 6E8A B7           	or		a
 527+ 6E8B C8           	ret		z
 528+ 6E8C
 529+ 6E8C              	;Prompt for DST disk change.
 530+ 6E8C CD FF 6C     	call	PromptDiskChangeDst
 531+ 6E8F 3A ED 6B     	ld		a, (RWTSDrive)
 532+ 6E92 CD 05 6C     	call	BDOSInit
 533+ 6E95
 534+ 6E95 06 02        	ld		b, 2
 535+ 6E97 CD 33 72     	call	ClearNMsgLines
 536+ 6E9A
 537+ 6E9A 18 A9        	jr		CopyFileSameDriveLoop
 538+ 6E9C
 539+ 6E9C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 540+ 6E9C
 541+ 6E9C              CopyFileDualDrive:
 542+ 6E9C 3A 11 79     	ld		a, (CopyFileSrcDrv)
 543+ 6E9F EE 03        	xor		%11
 544+ 6EA1 32 1D 79     	ld		(CopyFileDstDrv), a
 545+ 6EA4
 546+ 6EA4 CD E7 6D     	call	CopyFileCheckOverwrite
 547+ 6EA7 C0           	ret		nz
 548+ 6EA8
 549+ 6EA8 CD 03 6E     	call	CopyFileCreateNewFile
 550+ 6EAB C8           	ret		z
 551+ 6EAC
 552+ 6EAC              CopyFileDualDriveLoop:
 553+ 6EAC 3A 11 79     	ld		a, (CopyFileSrcDrv)
 554+ 6EAF 21 12 79     	ld		hl, CopyFileSrcName
 555+ 6EB2 CD 98 6F     	call	ReadFileSection
 556+ 6EB5 3A 10 79     	ld		a, (CopyFileSectCnt)
 557+ 6EB8 B7           	or		a
 558+ 6EB9 C8           	ret		z
 559+ 6EBA
 560+ 6EBA 3A 10 79     	ld		a, (CopyFileSectCnt)
 561+ 6EBD 6F           	ld		l, a
 562+ 6EBE 26 00        	ld		h, 0
 563+ 6EC0 11 EB 78     	ld		de, MsgCopySectors
 564+ 6EC3 CD C4 67     	call	Byte2Txt
 565+ 6EC6 21 EB 78     	ld		hl, MsgCopySectors
 566+ 6EC9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 567+ 6ECC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 568+ 6ECE
 569+ 6ECE 3A 09 79     	ld		a, (CopyFileRes)
 570+ 6ED1 F5           	push	af
 571+ 6ED2 3A 1D 79     		ld		a, (CopyFileDstDrv)
 572+ 6ED5 21 1E 79     		ld		hl, CopyFileDstName
 573+ 6ED8 CD BA 6F     		call	WriteFileSection
 574+ 6EDB 3A 09 79     		ld		a, (CopyFileRes)
 575+ 6EDE 6F           		ld		l, a
 576+ 6EDF F1           	pop		af
 577+ 6EE0 B5           	or		l
 578+ 6EE1 C0           	ret		nz
 579+ 6EE2
 580+ 6EE2 18 C8        	jr		CopyFileDualDriveLoop
 581+ 6EE4
 582+ 6EE4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 583+ 6EE4              CopyFileToCOM:
 584+ 6EE4 AF           	xor		a
 585+ 6EE5 32 09 79     	ld		(CopyFileRes), a
 586+ 6EE8 32 10 79     	ld		(CopyFileSectCnt), a
 587+ 6EEB 11 00 00     	ld		de, 0
 588+ 6EEE ED 53 0C 79  	ld		(FilePosRead), de
 589+ 6EF2
 590+ 6EF2              CopyFileToCOMLoop:
 591+ 6EF2 3A 11 79     	ld		a, (CopyFileSrcDrv)
 592+ 6EF5 21 12 79     	ld		hl, CopyFileSrcName
 593+ 6EF8 CD 98 6F     	call	ReadFileSection
 594+ 6EFB
 595+ 6EFB 3A 10 79     	ld		a, (CopyFileSectCnt)
 596+ 6EFE B7           	or		a
 597+ 6EFF 28 0F        	jr		z, CopyFileToCOMEnd
 598+ 6F01
 599+ 6F01              	;Send buffer to COM port.
 600+ 6F01 21 47 87     	ld		hl, FileData
 601+ 6F04 47           	ld		b, a					;Sector size is 256.
 602+ 6F05 0E 00        	ld		c, 0
 603+ 6F07 CD 12 76     	call	SERTB
 604+ 6F0A
 605+ 6F0A 3A 09 79     	ld		a, (CopyFileRes)
 606+ 6F0D B7           	or		a
 607+ 6F0E 28 E2        	jr		z, CopyFileToCOMLoop
 608+ 6F10
 609+ 6F10              CopyFileToCOMEnd:
 610+ 6F10              	;Reset read error code, as 1 is returned when file is finished reading.
 611+ 6F10 AF           	xor		a
 612+ 6F11 32 09 79     	ld		(CopyFileRes), a
 613+ 6F14
 614+ 6F14 C9           	ret
 615+ 6F15
 616+ 6F15              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 617+ 6F15              CopyFileFromCOM:
 618+ 6F15 AF           	xor		a
 619+ 6F16 32 09 79     	ld		(CopyFileRes), a
 620+ 6F19 11 00 00     	ld		de, 0
 621+ 6F1C ED 53 0E 79  	ld		(FilePosWrite), de
 622+ 6F20
 623+ 6F20              	;Must ask for the new file name and check to not exist.
 624+ 6F20 21 0B 78     	ld		hl, MsgNewFileName
 625+ 6F23 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 626+ 6F26 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 627+ 6F28 CD AF 70     	call	PrintStrClr
 628+ 6F2B
 629+ 6F2B 21 D6 77     	ld		hl, MsgClear
 630+ 6F2E 11 47 87     	ld		de, FileData
 631+ 6F31 01 0B 00     	ld		bc, NAMELEN
 632+ 6F34 ED B0        	ldir
 633+ 6F36 3E A0        	ld		a, $80 | ' '
 634+ 6F38 12           	ld		(de), a
 635+ 6F39 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 636+ 6F3C 21 47 87     	ld		hl, FileData
 637+ 6F3F CD 87 70     	call	PrintStr
 638+ 6F42
 639+ 6F42 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 6F45 01 0B 00     	ld		bc, NAMELEN
 641+ 6F48 CD F1 71     	call	ReadString
 642+ 6F4B
 643+ 6F4B 11 47 87     	ld		de, FileData
 644+ 6F4E 1A           	ld		a, (de)
 645+ 6F4F FE 20        	cp		' '					;If starting with space, input was canceled.
 646+ 6F51 C8           	ret		z
 647+ 6F52
 648+ 6F52              	;Copy new file name
 649+ 6F52 21 47 87     	ld		hl, FileData
 650+ 6F55 11 1E 79     	ld		de, CopyFileDstName
 651+ 6F58 01 0B 00     	ld		bc, NAMELEN
 652+ 6F5B ED B0        	ldir
 653+ 6F5D
 654+ 6F5D              	;Check if new name doesn't exist already.
 655+ 6F5D 3A 11 79     	ld		a, (CopyFileSrcDrv)
 656+ 6F60 21 1E 79     	ld		hl, CopyFileDstName
 657+ 6F63 CD E7 6D     	call	CopyFileCheckOverwrite
 658+ 6F66 C0           	ret		nz
 659+ 6F67
 660+ 6F67              	;Delete and re-create empty destination file
 661+ 6F67 3A 11 79     	ld		a, (CopyFileSrcDrv)
 662+ 6F6A 21 1E 79     	ld		hl, CopyFileDstName
 663+ 6F6D CD 03 6E     	call	CopyFileCreateNewFile
 664+ 6F70 C8           	ret		z
 665+ 6F71
 666+ 6F71              CopyFileFromCOMLoop:
 667+ 6F71 21 47 87     	ld		hl, FileData
 668+ 6F74 01 00 73     	ld		bc, FileDataSize
 669+ 6F77 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 670+ 6F79 CD DF 75     	call	SERRB				;BC = Number of bytes read from COM
 671+ 6F7C 79           	ld		a, c
 672+ 6F7D B0           	or		b
 673+ 6F7E C8           	ret		z
 674+ 6F7F
 675+ 6F7F              	;If C is not 0, add one more sector.
 676+ 6F7F 79           	ld 		a, c
 677+ 6F80 B7           	or		a
 678+ 6F81 28 01        	jr		z, CopyFileFromCOMDontInc
 679+ 6F83 04           	inc		b
 680+ 6F84              CopyFileFromCOMDontInc:
 681+ 6F84 78           	ld		a, b				;Sector size is 256
 682+ 6F85 32 10 79     	ld		(CopyFileSectCnt), a
 683+ 6F88 3A 1D 79     	ld		a, (CopyFileDstDrv)
 684+ 6F8B 21 1E 79     	ld		hl, CopyFileDstName
 685+ 6F8E CD BA 6F     	call	WriteFileSection
 686+ 6F91
 687+ 6F91 3A 09 79     	ld		a, (CopyFileRes)
 688+ 6F94 B7           	or		a
 689+ 6F95 28 DA        	jr		z, CopyFileFromCOMLoop
 690+ 6F97
 691+ 6F97 C9           	ret
 692+ 6F98
 693+ 6F98              ;Reads/Writes disk file portion to/from memory.
 694+ 6F98              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 695+ 6F98              ;This should work with single-drive file copy from one disk to another.
 696+ 6F98              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records
 697+ 6F98              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 698+ 6F98              ;
 699+ 6F98              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 700+ 6F98              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 701+ 6F98              ;Must use sequential read/write. But for the first operation must use random read/write.
 702+ 6F98              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 703+ 6F98              ReadFileSection:
 704+ 6F98 11 49 6C     	ld		de, BDOSReadFileBlockRandom
 705+ 6F9B ED 53 02 70  	ld		(CopyFileOperAddr1), de
 706+ 6F9F 11 41 6C     	ld		de, BDOSReadFileBlockSeq
 707+ 6FA2 ED 53 21 70  	ld		(CopyFileOperAddr2), de
 708+ 6FA6 11 0C 79     	ld		de, FilePosRead
 709+ 6FA9 ED 53 F9 6F  	ld		(CopyFilePtr), de
 710+ 6FAD ED 53 3D 70  	ld		(CopyFilePtr2), de
 711+ 6FB1
 712+ 6FB1              	;Limit max sectors to read to leave space for the index too.
 713+ 6FB1 F5           	push	af
 714+ 6FB2 3E 73        		ld		a, MAX_SECT_BUF
 715+ 6FB4 32 10 79     		ld		(CopyFileSectCnt), a
 716+ 6FB7 F1           	pop		af
 717+ 6FB8 18 19        	jr		ReadWriteFileSection
 718+ 6FBA
 719+ 6FBA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 720+ 6FBA
 721+ 6FBA              WriteFileSection:
 722+ 6FBA 11 4D 6C     	ld		de, BDOSWriteFileBlockRandom
 723+ 6FBD ED 53 02 70  	ld		(CopyFileOperAddr1), de
 724+ 6FC1 11 45 6C     	ld		de, BDOSWriteFileBlockSeq
 725+ 6FC4 ED 53 21 70  	ld		(CopyFileOperAddr2), de
 726+ 6FC8 11 0E 79     	ld		de, FilePosWrite
 727+ 6FCB ED 53 F9 6F  	ld		(CopyFilePtr), de
 728+ 6FCF ED 53 3D 70  	ld		(CopyFilePtr2), de
 729+ 6FD3
 730+ 6FD3
 731+ 6FD3              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 732+ 6FD3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 733+ 6FD3              ReadWriteFileSection:
 734+ 6FD3 CD 15 6C     	call	CreateChannel
 735+ 6FD6 DD 22 07 79  	ld		(CopyFileFCB), ix
 736+ 6FDA CD 39 6C     	call 	BDOSOpenFile
 737+ 6FDD 3C           	inc  	a						;Cancel if A==$FF
 738+ 6FDE C8           	ret		z
 739+ 6FDF
 740+ 6FDF              	;Set DMA initial pointer = FileData
 741+ 6FDF DD E5        	push	ix
 742+ 6FE1 21 47 87     		ld		hl, FileData
 743+ 6FE4 DD 21 0A 79  		ld		ix, CopyFileDMAAddr
 744+ 6FE8 DD 75 00     		ld		(ix), l
 745+ 6FEB DD 74 01     		ld		(ix+1), h
 746+ 6FEE DD 21 47 87  		ld		ix, FileData
 747+ 6FF2 CD 5B 6C     		call 	BDOSSetDMA
 748+ 6FF5 DD E1        	pop		ix
 749+ 6FF7
 750+ 6FF7              CopyFilePtr EQU $+2
 751+ 6FF7              	;Update file pointer using read/write random call.
 752+ 6FF7 ED 5B 0C 79  	ld		de, (FilePosRead)
 753+ 6FFB DD 73 21     	ld		(ix + FCB_R0), e
 754+ 6FFE DD 72 22     	ld		(ix + FCB_R1), d
 755+ 7001              CopyFileOperAddr1 EQU $ + 1
 756+ 7001 CD 49 6C     	call 	BDOSReadFileBlockRandom
 757+ 7004
 758+ 7004 32 09 79     	ld		(CopyFileRes), a
 759+ 7007 B7           	or		a
 760+ 7008 20 22        	jr		nz, ReadWriteFileSectionEnd
 761+ 700A
 762+ 700A 3A 10 79     	ld		a, (CopyFileSectCnt)
 763+ 700D 47           	ld		b, a
 764+ 700E
 765+ 700E              ReadWriteFileSectionLoop:
 766+ 700E C5           	push	bc
 767+ 700F DD 2A 0A 79  		ld		ix, (CopyFileDMAAddr)
 768+ 7013 CD 5B 6C     		call 	BDOSSetDMA
 769+ 7016 DD 24        		inc		ixh
 770+ 7018 DD 22 0A 79  		ld		(CopyFileDMAAddr), ix
 771+ 701C
 772+ 701C DD 2A 07 79  		ld		ix, (CopyFileFCB)
 773+ 7020              CopyFileOperAddr2 EQU $ + 1
 774+ 7020 CD 41 6C     		call 	BDOSReadFileBlockSeq
 775+ 7023 32 09 79     		ld		(CopyFileRes), a
 776+ 7026 C1           	pop		bc
 777+ 7027 B7           	or		a
 778+ 7028 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 779+ 702A 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 780+ 702C
 781+ 702C              ReadWriteFileSectionEnd:
 782+ 702C              	;Update sector count variable with how many sectors were transfered.
 783+ 702C 3E 73        	ld 		a, MAX_SECT_BUF
 784+ 702E 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 785+ 702F 32 10 79     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 786+ 7032
 787+ 7032              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 788+ 7032 CD 5F 6C     	call	BDOSSetRandFilePtr
 789+ 7035 DD 5E 21     	ld		e, (ix + FCB_R0)
 790+ 7038 DD 56 22     	ld		d, (ix + FCB_R1)
 791+ 703B              CopyFilePtr2 EQU $+2
 792+ 703B ED 53 0C 79  	ld		(FilePosRead), de
 793+ 703F
 794+ 703F CD 3D 6C     	call 	BDOSCloseFile
 795+ 7042 CD 2B 6C     	call 	DestroyChannel
 796+ 7045
 797+ 7045 ED 5B 0A 79  	ld		de, (CopyFileDMAAddr)
 798+ 7049 15           	dec		d
 799+ 704A C9           	ret
 800+ 704B
 801+ 704B              	ENDIF
 802+ 704B
# file closed: bdos.asm
1278  704B              	include "ui.asm"
# file opened: ui.asm
   1+ 704B              ;UI related functions
   2+ 704B
   3+ 704B              	ifndef	_UI_
   4+ 704B              	define	_UI_
   5+ 704B
   6+ 704B              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++704B              	ifndef	_HCCFG_
   2++704B ~            	define	_HCCFG_
   3++704B ~
   4++704B ~            ;HC specific code, for configuration
   5++704B ~
   6++704B ~            HC_CFG_PORT			EQU	$7E
   7++704B ~            HC_FLOPPY_PORT		EQU 7
   8++704B ~
   9++704B ~            ;BASIC/CPM ROM selection
  10++704B ~            HC_CFG_ROM_BAS		EQU	%0
  11++704B ~            HC_CFG_ROM_CPM		EQU	%1
  12++704B ~
  13++704B ~            ;Address for ROM paging: 0 or $E000
  14++704B ~            HC_CFG_ROM_0000		EQU %00
  15++704B ~            HC_CFG_ROM_E000		EQU %10
  16++704B ~
  17++704B ~            ;Cfg. port Enable/Disable
  18++704B ~            HC_CFG_PORT_DIS		EQU %000
  19++704B ~            HC_CFG_PORT_EN		EQU	%100
  20++704B ~
  21++704B ~            ;Video memory bank: $4000 or $C000
  22++704B ~            HC_CFG_VID_4000		EQU	%0000
  23++704B ~            HC_CFG_VID_C000		EQU	%1000
  24++704B ~
  25++704B ~
  26++704B ~            ;Standar BASIC config
  27++704B ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++704B ~            ;Standar CP/M config
  29++704B ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++704B ~
  31++704B ~
  32++704B ~            HC_VID_BANK0		EQU	$4000
  33++704B ~            HC_VID_BANK1		EQU	$C000
  34++704B ~
  35++704B ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++704B ~            ;Info from Rares Atodiresei.
  37++704B ~            IsDrive2_80Tracks:
  38++704B ~            	IFUSED
  39++704B ~            	in	a, (HC_FLOPPY_PORT)
  40++704B ~            	and %10
  41++704B ~            	ret
  42++704B ~            	ENDIF
  43++704B ~
  44++704B              	endif
# file closed: hccfg.asm
   7+ 704B
   8+ 704B              COL             EQU 23728
   9+ 704B              LINE            EQU 23729               ;Coordinates
  10+ 704B              LineCol			EQU	COL
  11+ 704B              CODE			EQU 23681               ;Char to print
  12+ 704B
  13+ 704B              CPM_FNT         EQU $25AB
  14+ 704B
  15+ 704B              PORT_ZX			EQU	$FE
  16+ 704B
  17+ 704B              ;COLORS
  18+ 704B              CLR_BLACK		EQU 0
  19+ 704B              CLR_BLUE		EQU 1
  20+ 704B              CLR_RED			EQU 2
  21+ 704B              CLR_MAGENTA		EQU 3
  22+ 704B              CLR_GREEN		EQU 4
  23+ 704B              CLR_CYAN		EQU	5
  24+ 704B              CLR_YELLOW		EQU	6
  25+ 704B              CLR_WHITE		EQU	7
  26+ 704B              CLR_BRIGHT		EQU	%01000000
  27+ 704B              CLR_FLASH		EQU	%10000000
  28+ 704B
  29+ 704B              ;PAPER
  30+ 704B              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 704B              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 704B              PAPER_RED		EQU (CLR_RED << 3)
  33+ 704B              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 704B              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 704B              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 704B              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 704B              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 704B
  39+ 704B              ;INK
  40+ 704B              INK_BLACK		EQU CLR_BLACK
  41+ 704B              INK_BLUE		EQU CLR_BLUE
  42+ 704B              INK_RED			EQU CLR_RED
  43+ 704B              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 704B              INK_GREEN		EQU CLR_GREEN
  45+ 704B              INK_CYAN		EQU	CLR_CYAN
  46+ 704B              INK_YELLOW		EQU	CLR_YELLOW
  47+ 704B              INK_WHITE		EQU	CLR_WHITE
  48+ 704B
  49+ 704B
  50+ 704B              SCR_ATTR_ADDR	EQU 22528
  51+ 704B              SCR_ADDR		EQU 16384
  52+ 704B              SCR_PIX_LEN		EQU	6144
  53+ 704B              SCR_ATTR_LEN	EQU	768
  54+ 704B              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 704B              SCR_BYTES_PER_LINE	EQU	32
  56+ 704B
  57+ 704B              SCR_COLS		EQU	64
  58+ 704B              SCR_LINES		EQU 24
  59+ 704B
  60+ 704B              ;used for file names list positioning
  61+ 704B              LST_LINES_CNT	EQU	21
  62+ 704B              LST_FIRST_LINE	EQU	1
  63+ 704B              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 704B              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 704B              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 704B              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 704B              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 704B              LST_FIRST_COL	EQU	16
  69+ 704B              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 704B
  71+ 704B              ;key codes
  72+ 704B              KEY_ESC			EQU	7
  73+ 704B              KEY_LEFT		EQU	8
  74+ 704B              KEY_RIGHT		EQU	9
  75+ 704B              KEY_DOWN		EQU	10
  76+ 704B              KEY_UP			EQU	11
  77+ 704B              KEY_BACKSP		EQU 12
  78+ 704B              KEY_ENTER		EQU	13
  79+ 704B              KEY_CTRL		EQU	14
  80+ 704B
  81+ 704B              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 704B              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 704B              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 704B
  85+ 704B              ;Special formating chars
  86+ 704B              CHR_CR			EQU	13
  87+ 704B              CHR_LF			EQU	10
  88+ 704B              CHR_TAB			EQU	09
  89+ 704B
  90+ 704B
  91+ 704B              ;Semi-graphical chars
  92+ 704B              ;           UC
  93+ 704B              ;     UL +H-+--+UR
  94+ 704B              ;        |  |  |
  95+ 704B              ;     ML +--+--+MR
  96+ 704B              ;        V C|  |
  97+ 704B              ;     LL +--+--+LR
  98+ 704B              ;           DC
  99+ 704B              CHR_GRID        EQU 127
 100+ 704B              CHR_V           EQU	128
 101+ 704B              CHR_MR          EQU	129
 102+ 704B              CHR_UR          EQU 130
 103+ 704B              CHR_DL          EQU 131
 104+ 704B              CHR_DC          EQU 132
 105+ 704B              CHR_UC          EQU 133
 106+ 704B              CHR_ML          EQU 134
 107+ 704B              CHR_H           EQU 135
 108+ 704B              CHR_C           EQU 136
 109+ 704B              CHR_LR          EQU 137
 110+ 704B              CHR_UL          EQU 138
 111+ 704B              CHR_FULL        EQU 139
 112+ 704B              CHR_HALF        EQU 140
 113+ 704B
 114+ 704B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 704B
 116+ 704B              ;Return read char in A
 117+ 704B              ReadChar:
 118+ 704B CF           	rst 08
 119+ 704C 1B           	DEFB 27
 120+ 704D C9           	ret
 121+ 704E
 122+ 704E              ;Checks if a key is pressed
 123+ 704E              ;Cy=1 if key is pressed
 124+ 704E              KbdHit:
 125+ 704E CF           	rst 08
 126+ 704F 20           	DEFB 32
 127+ 7050 C9           	ret
 128+ 7051              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 7051
 130+ 7051              InitFonts:
 131+ 7051              	IFUSED
 132+ 7051                  ;page-in CPM ROM to get fonts
 133+ 7051 F3               di
 134+ 7052 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 7054 D3 7E            out	(HC_CFG_PORT), a
 136+ 7056
 137+ 7056 21 AB 25     	ld		hl, CPM_FNT
 138+ 7059 11 DF 83     	ld		de, FontTable
 139+ 705C 01 68 03     	ld		bc, 872
 140+ 705F ED B0        	ldir
 141+ 7061
 142+ 7061                  ;restore BASIC ROM
 143+ 7061 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 7063 D3 7E            out	(HC_CFG_PORT), a
 145+ 7065 FB               ei
 146+ 7066
 147+ 7066 C9           	ret
 148+ 7067              	ENDIF
 149+ 7067
 150+ 7067              ClrScr:
 151+ 7067 2A 46 72     	ld		hl, (CurrScrAddr)
 152+ 706A 54           	ld		d, h
 153+ 706B 5D           	ld		e, l
 154+ 706C 13           	inc		de
 155+ 706D 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 7070 36 00        	ld		(hl), 0
 157+ 7072 ED B0        	ldir
 158+ 7074
 159+ 7074 23           	inc 	hl
 160+ 7075 13           	inc		de
 161+ 7076
 162+ 7076 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 7079 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 707B ED B0        	ldir
 165+ 707D
 166+ 707D              	;also set border color
 167+ 707D 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 707F D3 FE        	out		(PORT_ZX), a
 169+ 7081
 170+ 7081 3E 45        	ld		a, SCR_DEF_CLR
 171+ 7083 32 48 5C     	ld		(23624), a
 172+ 7086 C9           	ret
 173+ 7087
 174+ 7087              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 7087              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 7087              PrintStr:
 177+ 7087 7E           	ld		a, (hl)
 178+ 7088 FE 20        	cp		' '
 179+ 708A 30 02        	jr		nc, GoodChar
 180+ 708C 3E 3F        	ld		a, '?'
 181+ 708E              GoodChar:
 182+ 708E CB 7F        	bit		7, a
 183+ 7090 CB BF        	res		7, a
 184+ 7092 32 81 5C     	ld		(CODE), a
 185+ 7095 ED 53 B0 5C  	ld		(LineCol), de
 186+ 7099 08           	ex		af, af'
 187+ 709A D9           	exx
 188+ 709B E5           	push	hl
 189+ 709C CD B3 71     	call 	PrintChar
 190+ 709F E1           	pop		hl
 191+ 70A0 D9           	exx
 192+ 70A1 08           	ex		af, af'
 193+ 70A2 C0           	ret		nz
 194+ 70A3
 195+ 70A3 1C           	inc		e
 196+ 70A4 23           	inc		hl
 197+ 70A5
 198+ 70A5 7B           	ld		a, e
 199+ 70A6 FE 40        	cp		64
 200+ 70A8 38 DD        	jr		c, PrintStr
 201+ 70AA 1E 00        	ld		e, 0
 202+ 70AC 14           	inc		d
 203+ 70AD
 204+ 70AD 18 D8        	jr		PrintStr
 205+ 70AF
 206+ 70AF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 70AF
 208+ 70AF              ;IN: HL = string, DE = coords, A = color
 209+ 70AF              PrintStrClr:
 210+ 70AF 32 DB 70     	ld		(StrClr), a
 211+ 70B2 D5           	push	de
 212+ 70B3 CD 87 70     		call	PrintStr
 213+ 70B6 E1           	pop		hl
 214+ 70B7              	;get string len.
 215+ 70B7 7B           	ld		a, e
 216+ 70B8 95           	sub		l
 217+ 70B9 1F           	rra
 218+ 70BA 08           	ex		af, af'
 219+ 70BB              		;line * 32
 220+ 70BB 7C           		ld		a, h
 221+ 70BC 17           		rla
 222+ 70BD 17           		rla
 223+ 70BE 11 00 00     		ld	de, 0
 224+ 70C1 17           		rla
 225+ 70C2 CB 12        		rl	d
 226+ 70C4 17           		rla
 227+ 70C5 CB 12        		rl	d
 228+ 70C7 17           		rla
 229+ 70C8 CB 12        		rl	d
 230+ 70CA 5F           		ld	e, a
 231+ 70CB
 232+ 70CB 26 00        		ld		h, 0
 233+ 70CD 19           		add		hl, de
 234+ 70CE ED 5B 48 72  		ld		de, (CurrScrAttrAddr)
 235+ 70D2 19           		add		hl, de
 236+ 70D3 08           	ex		af, af'
 237+ 70D4 4F           	ld		c, a
 238+ 70D5 06 00        	ld		b, 0
 239+ 70D7 54           	ld		d, h
 240+ 70D8 5D           	ld		e, l
 241+ 70D9 13           	inc 	de
 242+ 70DA              StrClr	EQU	$ + 1
 243+ 70DA 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 70DC ED B0        	ldir
 245+ 70DE C9           	ret
 246+ 70DF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 70DF
 248+ 70DF              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 70DF              DrawLine:
 250+ 70DF 32 81 5C     	ld		(CODE), a
 251+ 70E2
 252+ 70E2 38 04        	jr		c, VertDir
 253+ 70E4 3E 1C        	ld		a, $1C
 254+ 70E6 18 02        	jr		StoreDir
 255+ 70E8              VertDir:
 256+ 70E8 3E 14        	ld		a, $14
 257+ 70EA              StoreDir:
 258+ 70EA 32 FA 70     	ld		(LineDir), a
 259+ 70ED
 260+ 70ED              DrawLineLoop:
 261+ 70ED ED 53 B0 5C  	ld		(LineCol), de
 262+ 70F1 D5           	push	de
 263+ 70F2 D9           		exx
 264+ 70F3 E5           		push	hl
 265+ 70F4 CD B3 71     		call 	PrintChar
 266+ 70F7 E1           		pop		hl
 267+ 70F8 D9           		exx
 268+ 70F9 D1           	pop		de
 269+ 70FA              LineDir:
 270+ 70FA 1C           	inc		e
 271+ 70FB 10 F0        	djnz	DrawLineLoop
 272+ 70FD
 273+ 70FD C9           	ret
 274+ 70FE
 275+ 70FE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 70FE
 277+ 70FE              DrawHLines:
 278+ 70FE 11 00 00     	ld		de, 0
 279+ 7101 06 40        	ld		b, 64
 280+ 7103 3E 87        	ld		a, CHR_H
 281+ 7105 B7           	or		a
 282+ 7106 CD DF 70     	call	DrawLine
 283+ 7109
 284+ 7109 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 710C 06 40        	ld		b, 64
 286+ 710E 3E 87        	ld		a, CHR_H
 287+ 7110 B7           	or		a
 288+ 7111 CD DF 70     	call	DrawLine
 289+ 7114
 290+ 7114 06 04        	ld		b, 4
 291+ 7116 11 10 00     	ld		de, LST_FIRST_COL
 292+ 7119              DrawUpperIntersectLoop:
 293+ 7119 C5           	push	bc
 294+ 711A D5           	push	de
 295+ 711B 3E 85        		ld		a, CHR_UC
 296+ 711D CD 3F 71     		call	DrawIntersect
 297+ 7120 D1           	pop		de
 298+ 7121 C1           	pop		bc
 299+ 7122 21 0C 00     	ld		hl, NAMELEN+1
 300+ 7125 19           	add		hl, de
 301+ 7126 EB           	ex		de, hl
 302+ 7127 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 7129
 304+ 7129 06 04        	ld		b, 4
 305+ 712B 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 712E              DrawLowerIntersectLoop:
 307+ 712E C5           	push	bc
 308+ 712F D5           	push	de
 309+ 7130 3E 84        		ld		a, CHR_DC
 310+ 7132 CD 3F 71     		call	DrawIntersect
 311+ 7135 D1           	pop		de
 312+ 7136 C1           	pop		bc
 313+ 7137 21 0C 00     	ld		hl, NAMELEN+1
 314+ 713A 19           	add		hl, de
 315+ 713B EB           	ex		de, hl
 316+ 713C 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 713E
 318+ 713E C9           	ret
 319+ 713F
 320+ 713F
 321+ 713F              DrawIntersect:
 322+ 713F 21 B0 5C     	ld		hl, LineCol
 323+ 7142 73 23 72 2B  	ld		(hl), de
 324+ 7146 32 81 5C     	ld		(CODE), a
 325+ 7149 E5           	push	hl
 326+ 714A CD B3 71     	call	PrintChar
 327+ 714D E1           	pop		hl
 328+ 714E 34           	inc		(hl)
 329+ 714F 3E 87        	ld		a, CHR_H
 330+ 7151 32 81 5C     	ld		(CODE), a
 331+ 7154 CD B3 71     	call	PrintChar
 332+ 7157 C9           	ret
 333+ 7158
 334+ 7158
 335+ 7158              DrawVLines:
 336+ 7158 06 04        	ld		b, 4
 337+ 715A 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 338+ 715D              DrawVLinesLoop:
 339+ 715D C5           	push 	bc
 340+ 715E D5           	push	de
 341+ 715F 06 15        		ld		b, LST_LINES_CNT
 342+ 7161 3E 80        		ld		a, CHR_V
 343+ 7163 37           		scf
 344+ 7164 CD DF 70     		call	DrawLine
 345+ 7167 D1           	pop		de
 346+ 7168 C1           	pop	bc
 347+ 7169 7B           	ld		a, e
 348+ 716A C6 0C        	add		NAMELEN+1
 349+ 716C 5F           	ld		e, a
 350+ 716D 10 EE        	djnz	DrawVLinesLoop
 351+ 716F C9           	ret
 352+ 7170
 353+ 7170              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 354+ 7170
 355+ 7170              ;IN: A = color mask
 356+ 7170              DrawCursor:
 357+ 7170 ED 5B FE 78  	ld	de, (CursorAddr)
 358+ 7174 06 06        	ld	b, 	(NAMELEN + 1)/2
 359+ 7176              DrawCursorLoop:
 360+ 7176 12           	ld	(de), a
 361+ 7177 13           	inc de
 362+ 7178 10 FC        	djnz DrawCursorLoop
 363+ 717A C9           	ret
 364+ 717B
 365+ 717B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 366+ 717B
 367+ 717B              ;IN:	A = file idx.
 368+ 717B              MoveCursor:
 369+ 717B              	;File idx / SCR_LINES => cursor line & column
 370+ 717B 6F           	ld		l, a
 371+ 717C 26 00        	ld		h, 0
 372+ 717E 0E 15        	ld		c, LST_LINES_CNT
 373+ 7180 CD 00 68     	call	Div					;HL = file column, A = line
 374+ 7183
 375+ 7183              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 376+ 7183 C6 01        	add		LST_FIRST_LINE
 377+ 7185
 378+ 7185
 379+ 7185 54           	ld d, h
 380+ 7186 5D           	ld e, l
 381+ 7187 21 00 00     	ld	hl, 0
 382+ 718A
 383+ 718A              	;line*32
 384+ 718A 17           	rla
 385+ 718B 17           	rla
 386+ 718C 17           	rla
 387+ 718D 17           	rla
 388+ 718E CB 14        	rl h
 389+ 7190 17           	rla
 390+ 7191 CB 14        	rl h
 391+ 7193 6F           	ld l, a
 392+ 7194
 393+ 7194
 394+ 7194              	;col * 6
 395+ 7194 E5           	push	hl					;save line * 32
 396+ 7195 3E 06        		ld		a, (NAMELEN + 1)/2
 397+ 7197 CD 20 68     		call	Mul				;HL = column * 12/2
 398+ 719A D1           	pop		de
 399+ 719B 19           	add		hl, de
 400+ 719C
 401+ 719C 11 08 00     	ld		de, LST_FIRST_COL/2
 402+ 719F ED 4B 48 72  	ld		bc, (CurrScrAttrAddr)
 403+ 71A3 19           	add		hl, de
 404+ 71A4 09           	add		hl, bc
 405+ 71A5
 406+ 71A5              	;clear old cursor
 407+ 71A5 3E 45        	ld		a, SCR_DEF_CLR
 408+ 71A7 CD 70 71     	call	DrawCursor
 409+ 71AA
 410+ 71AA              	;draw new one
 411+ 71AA 22 FE 78     	ld		(CursorAddr), hl
 412+ 71AD 3E 60        	ld		a, SCR_SEL_CLR
 413+ 71AF CD 70 71     	call	DrawCursor
 414+ 71B2
 415+ 71B2 C9           	ret
 416+ 71B3
 417+ 71B3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 418+ 71B3
 419+ 71B3              PrintChar:
 420+ 71B3 ED 5B B0 5C      ld		de, (LineCol)
 421+ 71B7
 422+ 71B7                  ;calculate 64 column screen address
 423+ 71B7              	;IN: D = line, E = col
 424+ 71B7              	;OUT: HL = screen address
 425+ 71B7
 426+ 71B7 CB 3B            SRL     E                                       ;col = col/2
 427+ 71B9 CB 19            RR      C                                       ;mark odd/even column
 428+ 71BB 7A               LD      A, D                            ;A = line
 429+ 71BC E6 18            AND 24                                  ;keep only %00011000
 430+ 71BE 2A 46 72         ld		hl, (CurrScrAddr)
 431+ 71C1 B4               OR      h								;add screen start address
 432+ 71C2 67               LD      H, A                            ;save H
 433+ 71C3 7A               LD      A, D                            ;A = line
 434+ 71C4 E6 07            AND 7                                   ;keep only %00000111
 435+ 71C6 0F               RRCA                                    ;%10000011
 436+ 71C7 0F               RRCA                                    ;%11000001
 437+ 71C8 0F               RRCA                                    ;%11100000
 438+ 71C9 B3               OR      E                                       ;add column
 439+ 71CA 6F               LD      L, A                            ;HL = screen address
 440+ 71CB
 441+ 71CB              PrintChar3:
 442+ 71CB                  ;get font address
 443+ 71CB E5               PUSH HL
 444+ 71CC AF                   XOR A
 445+ 71CD 67                   LD  H, A
 446+ 71CE 3A 81 5C             LD  A, (CODE)
 447+ 71D1 D6 20                SUB ' '
 448+ 71D3 6F                   LD  L, A
 449+ 71D4 29                   ADD     HL, HL                  ;char code = char code * 8
 450+ 71D5 29                   ADD     HL, HL                  ;i.e. offset into font table
 451+ 71D6 29                   ADD     HL, HL
 452+ 71D7 11 DF 83             LD      DE, FontTable             ;get font table
 453+ 71DA 19                   ADD     HL, DE
 454+ 71DB EB                   EX      DE, HL                  ;DE = our char font address
 455+ 71DC E1               POP     HL
 456+ 71DD
 457+ 71DD
 458+ 71DD                  ;print a char
 459+ 71DD 06 08            LD      B, 8                            ;char height is 8 lines
 460+ 71DF              PrintCharLine:
 461+ 71DF 1A                   LD      A, (DE)                         ;load char line in A
 462+ 71E0
 463+ 71E0 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 464+ 71E2 20 06                JR  	NZ, NoTurn
 465+ 71E4
 466+ 71E4 07                   RLCA
 467+ 71E5 07                   RLCA
 468+ 71E6 07                   RLCA
 469+ 71E7 07                   RLCA
 470+ 71E8 18 01                JR      Store
 471+ 71EA              NoTurn:
 472+ 71EA B6                   OR (HL)
 473+ 71EB              Store:
 474+ 71EB 77                   LD (HL), A
 475+ 71EC
 476+ 71EC 13                   INC     DE                                      ;next char line in font table
 477+ 71ED 24                   INC     H                                       ;next char line on screen
 478+ 71EE 10 EF            DJNZ PrintCharLine                  ;last line of char?
 479+ 71F0
 480+ 71F0 C9               ret
 481+ 71F1
 482+ 71F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 483+ 71F1
 484+ 71F1              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 485+ 71F1              ReadString:
 486+ 71F1 21 47 87     	ld		hl, FileData
 487+ 71F4 D5           	push	de
 488+ 71F5 DD E1        	pop		ix
 489+ 71F7
 490+ 71F7              ReadStringLoop:
 491+ 71F7 D5           	push	de
 492+ 71F8 E5           	push	hl
 493+ 71F9 CD 4B 70     		call ReadChar
 494+ 71FC E1           	pop		hl
 495+ 71FD D1           	pop		de
 496+ 71FE
 497+ 71FE FE 0D        	cp	KEY_ENTER
 498+ 7200 C8           	ret z
 499+ 7201
 500+ 7201 FE 0C        	cp  KEY_BACKSP
 501+ 7203 20 0F        	jr	nz, ReadStrChar
 502+ 7205
 503+ 7205 E5           	push hl
 504+ 7206 01 48 87     	ld   bc, FileData+1
 505+ 7209 ED 42        	sbc	 hl, bc
 506+ 720B E1           	pop  hl
 507+ 720C 38 16        	jr   c, ReadStrPrint
 508+ 720E
 509+ 720E 1B           	dec	de
 510+ 720F 2B           	dec	hl
 511+ 7210 36 20        	ld	(hl), ' '
 512+ 7212 18 10        	jr	ReadStrPrint
 513+ 7214
 514+ 7214              ReadStrChar:
 515+ 7214 FE 20        	cp	' '
 516+ 7216 38 DF        	jr	c, ReadStringLoop
 517+ 7218 FE 7F        	cp  127
 518+ 721A 30 DB        	jr	nc, ReadStringLoop
 519+ 721C
 520+ 721C              	;Check end of string and go back if found.
 521+ 721C 46           	ld	b, (hl)
 522+ 721D CB 78        	bit 7, b
 523+ 721F 20 03        	jr	nz, ReadStrPrint
 524+ 7221
 525+ 7221 77           	ld	(hl), a
 526+ 7222 23           	inc	hl
 527+ 7223 13           	inc	de
 528+ 7224
 529+ 7224              ReadStrPrint:
 530+ 7224 E5           	push	hl
 531+ 7225 D5           	push	de
 532+ 7226 21 47 87     	ld		hl, FileData
 533+ 7229 DD E5        	push	ix
 534+ 722B D1           	pop		de
 535+ 722C CD 87 70     	call	PrintStr
 536+ 722F D1           	pop		de
 537+ 7230 E1           	pop		hl
 538+ 7231
 539+ 7231 18 C4        	jr		ReadStringLoop
 540+ 7233
 541+ 7233              ClearNMsgLines:
 542+ 7233 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 543+ 7236              ClearNMsgLinesLoop:
 544+ 7236 D5           	push	de
 545+ 7237 C5           	push	bc
 546+ 7238 21 D6 77     	ld		hl, MsgClear
 547+ 723B 3E 45        	ld		a, SCR_DEF_CLR
 548+ 723D CD AF 70     	call	PrintStrClr
 549+ 7240 C1           	pop		bc
 550+ 7241 D1           	pop		de
 551+ 7242 14           	inc		d
 552+ 7243 10 F1        	djnz	ClearNMsgLinesLoop
 553+ 7245
 554+ 7245 C9           	ret
 555+ 7246
 556+ 7246 00 40        CurrScrAddr		DEFW	SCR_ADDR
 557+ 7248 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 558+ 724A
 559+ 724A                 	endif
# file closed: ui.asm
1279  724A              	include "math.asm"
# file opened: math.asm
   1+ 724A              	ifndef	_MATH_
   2+ 724A ~            	define	_MATH_
   3+ 724A ~
   4+ 724A ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 724A ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 724A ~
   7+ 724A ~
   8+ 724A ~            Word2Txt:
   9+ 724A ~            	IFUSED
  10+ 724A ~            	push	de
  11+ 724A ~            		call	Word2Txt_
  12+ 724A ~            	pop		de
  13+ 724A ~
  14+ 724A ~            	ld		b, 4
  15+ 724A ~            	call	StrippLeading0
  16+ 724A ~            	ret
  17+ 724A ~
  18+ 724A ~            Byte2Txt:
  19+ 724A ~            	push	de
  20+ 724A ~            		call	Byte2Txt_
  21+ 724A ~            	pop		de
  22+ 724A ~
  23+ 724A ~            	ld		b, 2
  24+ 724A ~            	call	StrippLeading0
  25+ 724A ~            	ret
  26+ 724A ~            	ENDIF
  27+ 724A ~
  28+ 724A ~
  29+ 724A ~            StrippLeading0:
  30+ 724A ~            	ld		a, (de)
  31+ 724A ~            	cp		'1'
  32+ 724A ~            	ret		nc
  33+ 724A ~
  34+ 724A ~            	ld		a, ' '
  35+ 724A ~            	ld		(de), a
  36+ 724A ~            	inc		de
  37+ 724A ~            	djnz	StrippLeading0
  38+ 724A ~            	ret
  39+ 724A ~
  40+ 724A ~
  41+ 724A ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 724A ~            Word2Txt_:
  43+ 724A ~            	ld bc, -10000
  44+ 724A ~            	call DigitLoop
  45+ 724A ~            	ld bc, -1000
  46+ 724A ~            	call DigitLoop
  47+ 724A ~            Byte2Txt_:
  48+ 724A ~            	ld bc, -100
  49+ 724A ~            	call DigitLoop
  50+ 724A ~            	ld bc, -10
  51+ 724A ~            	call DigitLoop
  52+ 724A ~            	ld bc, -1
  53+ 724A ~
  54+ 724A ~            DigitLoop:
  55+ 724A ~            	ld	a, '0' - 1
  56+ 724A ~            DivNrLoop:
  57+ 724A ~            	inc	a			;increase reminder
  58+ 724A ~            	add	hl, bc		;substract divizor
  59+ 724A ~            	jr	c, DivNrLoop	;still dividing?
  60+ 724A ~            	sbc	hl, bc		;nope, restore
  61+ 724A ~
  62+ 724A ~            	ld (de), a
  63+ 724A ~            	inc de
  64+ 724A ~            	ret
  65+ 724A ~
  66+ 724A ~
  67+ 724A ~            ;Input: HL = Dividend, C = Divisor
  68+ 724A ~            ;Output: HL = Quotient, A = Remainder
  69+ 724A ~            ;Warning: doesn't work with divisor >= $80
  70+ 724A ~            Div:
  71+ 724A ~            	IFUSED
  72+ 724A ~            	xor a
  73+ 724A ~            	ld b, 16
  74+ 724A ~
  75+ 724A ~            DivLoop:
  76+ 724A ~            	add	hl,hl
  77+ 724A ~            	rla
  78+ 724A ~            	cp	c
  79+ 724A ~            	jr	c, NoSub
  80+ 724A ~            	sub	c
  81+ 724A ~            	inc	l
  82+ 724A ~            NoSub:
  83+ 724A ~            	djnz DivLoop
  84+ 724A ~
  85+ 724A ~            	ret
  86+ 724A ~            	ENDIF
  87+ 724A ~
  88+ 724A ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 724A ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 724A ~            Div2:
  91+ 724A ~            	ld hl, 0
  92+ 724A ~            	ld b, 16
  93+ 724A ~            Div2Loop:
  94+ 724A ~            	sll c		; unroll 16 times
  95+ 724A ~            	rla			; ...
  96+ 724A ~            	adc	hl,hl		; ...
  97+ 724A ~            	sbc	hl,de		; ...
  98+ 724A ~            	jr	nc,$+4		; ...
  99+ 724A ~            	add	hl,de		; ...
 100+ 724A ~            	dec	c		; ...
 101+ 724A ~            	djnz Div2Loop
 102+ 724A ~            	ret
 103+ 724A ~
 104+ 724A ~
 105+ 724A ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 724A ~            ;Output: A:HL = Product
 107+ 724A ~            Mul:
 108+ 724A ~            	IFUSED
 109+ 724A ~            	ld hl, 0
 110+ 724A ~            	ld bc, $0700
 111+ 724A ~
 112+ 724A ~            	add	a, a		; optimised 1st iteration
 113+ 724A ~            	jr	nc, MulLoop
 114+ 724A ~            	ld	h, d
 115+ 724A ~            	ld	l, e
 116+ 724A ~
 117+ 724A ~            MulLoop:
 118+ 724A ~            	add	hl,hl
 119+ 724A ~            	rla
 120+ 724A ~            	jr	nc, NoAdd
 121+ 724A ~            	add	hl,de
 122+ 724A ~            	adc	a,c
 123+ 724A ~            NoAdd:
 124+ 724A ~            	djnz MulLoop
 125+ 724A ~
 126+ 724A ~            	ret
 127+ 724A ~            	ENDIF
 128+ 724A ~
 129+ 724A              	endif
# file closed: math.asm
1280  724A              	include "txtview.asm"
# file opened: txtview.asm
   1+ 724A              ; 	DEVICE ZXSPECTRUM48
   2+ 724A
   3+ 724A              LINE_CNT	EQU	23
   4+ 724A              COL_CNT		EQU	64
   5+ 724A
   6+ 724A              CHAR_CR		EQU	$0D
   7+ 724A              CHAR_LF		EQU	$0A
   8+ 724A              CHAR_TAB	EQU	$09
   9+ 724A              CHAR_EOF	EQU	$1A
  10+ 724A
  11+ 724A              COORDS		EQU	23728		;Coordinates
  12+ 724A
  13+ 724A
  14+ 724A              InitViewer:
  15+ 724A 22 95 75     	ld		 (FileBegin), hl
  16+ 724D 09           	add		hl, bc
  17+ 724E              	;must filter any EOF chars.
  18+ 724E 3E 1A        	ld		a, CHAR_EOF
  19+ 7250 25           	dec		h
  20+ 7251 25           	dec		h
  21+ 7252 01 00 04     	ld		bc, SECT_SZ	* 4
  22+ 7255 ED B1        	cpir
  23+ 7257 2B           	dec		hl
  24+ 7258 22 99 75     	ld		(FileEnd), hl
  25+ 725B ED 5B 95 75  	ld		de, (FileBegin)
  26+ 725F B7           	or		a
  27+ 7260 ED 52        	sbc		hl, de
  28+ 7262 22 97 75     	ld		(FileLen), hl
  29+ 7265
  30+ 7265 3E 0D        	ld		a, CHAR_CR
  31+ 7267 77           	ld		(hl), a
  32+ 7268
  33+ 7268
  34+ 7268 21 04 02     	ld		hl, (2 << 8) | 4
  35+ 726B 22 09 5C     	ld		(REPDEL), hl
  36+ 726E
  37+ 726E 21 00 00     	ld		hl, 0
  38+ 7271 22 B0 5C     	ld		(COORDS), hl
  39+ 7274
  40+ 7274 21 00 58     	ld		hl, SCR_ADDR + SCR_PIX_LEN
  41+ 7277 54           	ld		d, h
  42+ 7278 5D           	ld		e, l
  43+ 7279 13           	inc		de
  44+ 727A 01 FF 02     	ld		bc, 767
  45+ 727D 36 45        	ld		(hl), SCR_DEF_CLR
  46+ 727F ED B0        	ldir
  47+ 7281
  48+ 7281 CD 9C 74     	call	ScrollInit
  49+ 7284
  50+ 7284 11 00 00     	ld		de, 0
  51+ 7287 ED 53 92 75  	ld		(CurLine), de
  52+ 728B
  53+ 728B              	;prepare file progress %
  54+ 728B 2A 97 75     	ld		hl, (FileLen)
  55+ 728E 7C           	ld		a, h
  56+ 728F 4D           	ld		c, l
  57+ 7290 11 64 00     	ld		de, 100
  58+ 7293 CD 0D 68     	call	Div2
  59+ 7296 67           	ld		h, a
  60+ 7297 69           	ld		l, c
  61+ 7298 22 9B 75     	ld		(PROGR_PERC), hl
  62+ 729B
  63+ 729B CD 2B 74     	call	PrintMsg
  64+ 729E
  65+ 729E DD 21 45 FA  	ld		ix, FileIdx	- 2
  66+ 72A2 06 17        	ld		b, LINE_CNT
  67+ 72A4 2A 95 75     	ld		hl, (FileBegin)
  68+ 72A7
  69+ 72A7 C9           	ret
  70+ 72A8
  71+ 72A8
  72+ 72A8              PrintLoop:
  73+ 72A8 C5           	push	bc
  74+ 72A9 DD 23        		inc		ix
  75+ 72AB DD 23        		inc		ix
  76+ 72AD DD 75 00     		ld		(ix), l
  77+ 72B0 DD 74 01     		ld		(ix + 1), h
  78+ 72B3
  79+ 72B3 CD C9 73     		call	GetLine
  80+ 72B6 CD 9B 73     		call	PrintLine
  81+ 72B9
  82+ 72B9 ED 5B 92 75  		ld		de, (CurLine)
  83+ 72BD 13           		inc		de
  84+ 72BE ED 53 92 75  		ld		(CurLine), de
  85+ 72C2 C1           	pop		bc
  86+ 72C3 CD 90 73     	call	CheckEnd
  87+ 72C6 38 13        	jr		c, ViewFileEOF
  88+ 72C8
  89+ 72C8 10 DE        	djnz	PrintLoop
  90+ 72CA 18 17        	jr		PrintLoop2
  91+ 72CC
  92+ 72CC              GetKey:
  93+ 72CC 76           	halt
  94+ 72CD FD CB 01 6E  	bit		5, (iy + 1);
  95+ 72D1 28 F9        	jr		z, GetKey
  96+ 72D3 FD CB 01 AE  	res		5, (iy + 1)
  97+ 72D7 FD 7E CE     	ld		a, (iy - $32)
  98+ 72DA C9           	ret
  99+ 72DB
 100+ 72DB              ViewFileEOF:
 101+ 72DB CD CC 72     	call	GetKey
 102+ 72DE FE 30        	cp		'0'
 103+ 72E0 20 F9        	jr		nz, ViewFileEOF
 104+ 72E2 C9           	ret
 105+ 72E3
 106+ 72E3              PrintLoop2:
 107+ 72E3 CD 2B 74     	call	PrintMsg
 108+ 72E6
 109+ 72E6 CD CC 72     	call	GetKey
 110+ 72E9 FE 30        	cp		'0'					;Exit on 0
 111+ 72EB C8           	ret		z
 112+ 72EC
 113+ 72EC FE 0A        	cp		KEY_DOWN
 114+ 72EE 28 5C        	jr		z, Down
 115+ 72F0
 116+ 72F0 FE 0B        	cp		KEY_UP
 117+ 72F2 28 2D        	jr		z, Up
 118+ 72F4
 119+ 72F4 FE 32        	cp		'2'
 120+ 72F6 20 EB        	jr		nz, PrintLoop2
 121+ 72F8
 122+ 72F8 3A 94 75     	ld		a, (WrapFlag)
 123+ 72FB EE 01        	xor		1
 124+ 72FD 32 94 75     	ld		(WrapFlag), a
 125+ 7300 B7           	or		a
 126+ 7301 28 0F        	jr		z, NoWrap
 127+ 7303
 128+ 7303 11 4F 6E     	ld		de, 'nO'
 129+ 7306 ED 53 47 75  	ld		(MsgLineWrF), de
 130+ 730A 3E 20        	ld		a, ' '
 131+ 730C 32 49 75     	ld		(MsgLineWrF + 2), a
 132+ 730F C3 E3 72     	jp		PrintLoop2
 133+ 7312
 134+ 7312              NoWrap:
 135+ 7312 11 4F 66     	ld		de, 'fO'
 136+ 7315 ED 53 47 75  	ld		(MsgLineWrF), de
 137+ 7319 3E 66        	ld		a, 'f'
 138+ 731B 32 49 75     	ld		(MsgLineWrF + 2), a
 139+ 731E
 140+ 731E C3 E3 72     	jp		PrintLoop2
 141+ 7321
 142+ 7321
 143+ 7321              Up:
 144+ 7321 CD 80 73     	call	CheckBegin
 145+ 7324 28 BD        	jr		z, PrintLoop2
 146+ 7326
 147+ 7326 CD CA 74     	call	ScrollUp
 148+ 7329
 149+ 7329 DD 2B        	dec		ix
 150+ 732B DD 2B        	dec		ix
 151+ 732D DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 152+ 7330 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 153+ 7333 CD C9 73     	call	GetLine						;extract previous line to display
 154+ 7336
 155+ 7336 11 00 00     	ld		de, 0
 156+ 7339 ED 53 B0 5C  	ld		(COORDS), de
 157+ 733D CD 9B 73     	call	PrintLine
 158+ 7340
 159+ 7340 2A 92 75     	ld		hl, (CurLine)
 160+ 7343 2B           	dec		hl
 161+ 7344 22 92 75     	ld		(CurLine), hl
 162+ 7347 CD 2B 74     	call	PrintMsg
 163+ 734A 18 97        	jr		PrintLoop2
 164+ 734C
 165+ 734C
 166+ 734C              Down:
 167+ 734C DD 6E 00     	ld		l, (ix)
 168+ 734F DD 66 01     	ld		h, (ix + 1)
 169+ 7352 CD C9 73     	call	GetLine						;get next line pointer
 170+ 7355
 171+ 7355 CD 90 73     	call	CheckEnd					;check if HL == file end
 172+ 7358 D8           	ret		c
 173+ 7359
 174+ 7359 DD 23        	inc		ix								;save next line pointer
 175+ 735B DD 23        	inc		ix
 176+ 735D DD 75 00     	ld		(ix), l
 177+ 7360 DD 74 01     	ld		(ix + 1), h
 178+ 7363
 179+ 7363 CD C9 73     	call	GetLine						;extract next line in buffer for display
 180+ 7366
 181+ 7366 CD CF 74     	call	ScrollDown
 182+ 7369
 183+ 7369 11 00 16     	ld		de, (LINE_CNT-1) << 8
 184+ 736C ED 53 B0 5C  	ld		(COORDS), de
 185+ 7370 CD 9B 73     	call	PrintLine
 186+ 7373
 187+ 7373 2A 92 75     	ld		hl, (CurLine)
 188+ 7376 23           	inc		hl
 189+ 7377 22 92 75     	ld		(CurLine), hl
 190+ 737A CD 2B 74     	call	PrintMsg
 191+ 737D
 192+ 737D C3 E3 72     	jp		PrintLoop2
 193+ 7380
 194+ 7380
 195+ 7380              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 196+ 7380              ;check begining of buffer
 197+ 7380              CheckBegin:
 198+ 7380 E5           	push	hl
 199+ 7381 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 200+ 7384 DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 201+ 7387 ED 5B 95 75  		ld		de, (FileBegin)
 202+ 738B B7           		or		a
 203+ 738C ED 52        		sbc		hl, de
 204+ 738E E1           	pop		hl
 205+ 738F C9           	ret
 206+ 7390
 207+ 7390              ;check end of buffer
 208+ 7390              CheckEnd:
 209+ 7390 E5           	push	hl
 210+ 7391 ED 5B 99 75  		ld		de, (FileEnd)
 211+ 7395 EB           		ex		de, hl
 212+ 7396 B7           		or		a
 213+ 7397 ED 52        		sbc		hl, de
 214+ 7399 E1           	pop		hl
 215+ 739A C9           	ret
 216+ 739B
 217+ 739B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 739B              ;Print a line
 219+ 739B              PrintLine:
 220+ 739B 11 52 75     	ld		de, LineBuf
 221+ 739E 06 40        	ld		b, COL_CNT
 222+ 73A0
 223+ 73A0 CD AF 73     	call	PrintStrTxt
 224+ 73A3
 225+ 73A3              	;go to the next screen line
 226+ 73A3 ED 5B B0 5C  	ld		de, (COORDS)
 227+ 73A7 14           	inc		d
 228+ 73A8 1E 00        	ld		e, 0
 229+ 73AA ED 53 B0 5C  	ld		(COORDS), de
 230+ 73AE C9           	ret
 231+ 73AF
 232+ 73AF              PrintStrTxt:
 233+ 73AF 1A           	ld		a, (de)
 234+ 73B0 13           	inc		de
 235+ 73B1 D5           	push	de
 236+ 73B2 32 81 5C     		ld		(CODE), a
 237+ 73B5 C5           		push	bc
 238+ 73B6 E5           			push	hl
 239+ 73B7 CD B3 71     				call	PrintChar
 240+ 73BA E1           			pop		hl
 241+ 73BB C1           		pop		bc
 242+ 73BC
 243+ 73BC ED 5B B0 5C  		ld		de, (COORDS)
 244+ 73C0 1C           		inc		e
 245+ 73C1 ED 53 B0 5C  		ld		(COORDS), de
 246+ 73C5 D1           	pop		de
 247+ 73C6 10 E7        	djnz	PrintStrTxt
 248+ 73C8 C9           	ret
 249+ 73C9
 250+ 73C9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 251+ 73C9              ;Extract a line of text to fit exactly on a 64 screen line
 252+ 73C9              ;IN:	HL = current file pointer
 253+ 73C9              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 254+ 73C9              GetLine:
 255+ 73C9 11 52 75     	ld		de, LineBuf
 256+ 73CC 06 40        	ld		b, COL_CNT
 257+ 73CE              GetLineLoop:
 258+ 73CE 7E           	ld		a, (hl)
 259+ 73CF 23           	inc		hl
 260+ 73D0
 261+ 73D0 FE 0D        	cp		CHAR_CR
 262+ 73D2 28 2F        	jr		z, GetLineSkip0A
 263+ 73D4
 264+ 73D4 FE 0A        	cp		CHAR_LF
 265+ 73D6 28 2B        	jr		z, GetLineSkip0A
 266+ 73D8
 267+ 73D8 FE 09        	cp		CHAR_TAB
 268+ 73DA 28 06        	jr		z, GetLineTab
 269+ 73DC
 270+ 73DC FE 1A        	cp		CHAR_EOF
 271+ 73DE 28 44        	jr		z, GetLineFillLoop
 272+ 73E0
 273+ 73E0 18 07        	jr		GetLineNext
 274+ 73E2
 275+ 73E2              GetLineTab:
 276+ 73E2              	;1 space tab
 277+ 73E2 3E 20        	ld		a, ' '
 278+ 73E4 12           	ld		(de), a
 279+ 73E5 13           	inc		de
 280+ 73E6 05           	dec		b
 281+ 73E7 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 282+ 73E9
 283+ 73E9              GetLineNext:
 284+ 73E9 FE 20        	cp		' '
 285+ 73EB 38 06        	jr		c, NotValid
 286+ 73ED
 287+ 73ED FE 80        	cp		128
 288+ 73EF 30 02        	jr		nc, NotValid
 289+ 73F1 18 03        	jr		Valid
 290+ 73F3
 291+ 73F3              NotValid:
 292+ 73F3 CD 7A 74     	call	ReplaceChars
 293+ 73F6
 294+ 73F6              Valid:
 295+ 73F6 12           	ld		(de), a
 296+ 73F7 13           	inc		de
 297+ 73F8 10 D4        	djnz	GetLineLoop
 298+ 73FA
 299+ 73FA              ;if line is exactly 64 char long, must skip the new line char(s)
 300+ 73FA              GetLineSkip0D:
 301+ 73FA 0E 00        	ld		c, 0
 302+ 73FC 3E 0D        	ld		a, CHAR_CR						;skip 0D
 303+ 73FE BE           	cp		(hl)
 304+ 73FF 20 02        	jr		nz, GetLineSkip0A
 305+ 7401 23           	inc		hl
 306+ 7402 0C           	inc		c
 307+ 7403
 308+ 7403              GetLineSkip0A:						;skip 0A
 309+ 7403 3E 0A        	ld		a, CHAR_LF
 310+ 7405 BE           	cp		(hl)
 311+ 7406 20 02        	jr		nz, GetLineFill
 312+ 7408 23           	inc		hl
 313+ 7409 0C           	inc		c
 314+ 740A
 315+ 740A              GetLineFill:
 316+ 740A 78           	ld		a, b
 317+ 740B B7           	or		a
 318+ 740C 20 16        	jr		nz, GetLineFillLoop
 319+ 740E
 320+ 740E 79           	ld		a, c
 321+ 740F B7           	or		a
 322+ 7410 C0           	ret		nz
 323+ 7411
 324+ 7411              	;wrap or not
 325+ 7411 3A 94 75     	ld		a, (WrapFlag)
 326+ 7414 B7           	or		a
 327+ 7415 C0           	ret		nz
 328+ 7416
 329+ 7416 ~            	/*
 330+ 7416 ~            	ld		de, (FileEnd)
 331+ 7416 ~            	push	hl
 332+ 7416 ~            		ex		de, hl
 333+ 7416 ~            		or		a
 334+ 7416 ~            		sbc		hl, de
 335+ 7416 ~            		ld		b, h
 336+ 7416 ~            		ld		c, l
 337+ 7416 ~            	pop		hl
 338+ 7416 ~            	*/
 339+ 7416
 340+ 7416 3E 0D        	ld		a, CHAR_CR
 341+ 7418 01 40 00     	ld		bc, COL_CNT
 342+ 741B ED B1        	cpir
 343+ 741D C0           	ret		nz
 344+ 741E 3E 0A        	ld		a, CHAR_LF
 345+ 7420 BE           	cp		(hl)
 346+ 7421 C0           	ret		nz
 347+ 7422 23           	inc		hl
 348+ 7423
 349+ 7423 C9           	ret
 350+ 7424
 351+ 7424              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 352+ 7424 3E 20        	ld		a, ' '
 353+ 7426 12           	ld		(de), a
 354+ 7427 13           	inc		de
 355+ 7428 10 FA        	djnz	GetLineFillLoop
 356+ 742A C9           	ret
 357+ 742B
 358+ 742B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 359+ 742B              PrintMsg:
 360+ 742B ED 5B B0 5C  	ld		de, (COORDS)
 361+ 742F D5           	push	de
 362+ 7430 11 00 17     	ld		de, LINE_CNT<<8
 363+ 7433 ED 53 B0 5C  	ld		(COORDS), de
 364+ 7437
 365+ 7437              	;Get current file pointer
 366+ 7437 DD 6E 00     	ld		l, (ix)
 367+ 743A DD 66 01     	ld		h, (ix + 1)
 368+ 743D ED 4B 95 75  	ld		bc, (FileBegin)
 369+ 7441 B7           	or		a
 370+ 7442 ED 42        	sbc		hl, bc
 371+ 7444
 372+ 7444              	;Divide by one percent length
 373+ 7444 7C           	ld		a, h
 374+ 7445 4D           	ld		c, l
 375+ 7446 ED 5B 9B 75  	ld		de, (PROGR_PERC)
 376+ 744A CD 0D 68     	call	Div2
 377+ 744D
 378+ 744D              	;Display %
 379+ 744D 11 2D 75     	ld		de, MsgLinePr
 380+ 7450 67           	ld		h, a
 381+ 7451 69           	ld		l, c
 382+ 7452 CD C4 67     	call	Byte2Txt
 383+ 7455
 384+ 7455
 385+ 7455 2A 92 75     	ld		hl, (CurLine)
 386+ 7458 11 39 75     	ld		de, MsgLineNo
 387+ 745B CD B9 67     	call	Word2Txt
 388+ 745E
 389+ 745E 11 24 75     	ld		de, MsgLine
 390+ 7461 06 2E        	ld		b, MsgLineLen
 391+ 7463 CD AF 73     	call	PrintStrTxt
 392+ 7466 D1           	pop		de
 393+ 7467 ED 53 B0 5C  	ld		(COORDS), DE
 394+ 746B
 395+ 746B 21 E0 5A     	ld		hl, SCR_ADDR + SCR_PIX_LEN + LINE_CNT*32
 396+ 746E 54           	ld		d, h
 397+ 746F 5D           	ld		e, l
 398+ 7470 13           	inc		de
 399+ 7471 3E 60        	ld		a, SCR_LBL_CLR
 400+ 7473 77           	ld		(hl), a
 401+ 7474 01 1F 00     	ld		bc, SCR_BYTES_PER_LINE-1
 402+ 7477 ED B0        	ldir
 403+ 7479 C9           	ret
 404+ 747A
 405+ 747A
 406+ 747A              ReplaceChars:
 407+ 747A E5           	push	hl
 408+ 747B C5           	push	bc
 409+ 747C 21 0A 75     		ld		hl, CharReplaceTbl
 410+ 747F 06 0D        		ld		b, CharReplTblLen
 411+ 7481              ReplaceSGCLoop:
 412+ 7481 BE           		cp		(hl)
 413+ 7482 28 09        		jr		z, ReplaceMatch
 414+ 7484 23           		inc		hl
 415+ 7485 23           		inc		hl
 416+ 7486 10 F9        		djnz	ReplaceSGCLoop
 417+ 7488
 418+ 7488 3E 3F        		ld		a, '?'
 419+ 748A C1           		pop		bc
 420+ 748B E1           		pop		hl
 421+ 748C C9           	ret
 422+ 748D
 423+ 748D              ReplaceMatch:
 424+ 748D 23           		inc		hl
 425+ 748E 7E           		ld		a, (hl)
 426+ 748F C1           	pop		bc
 427+ 7490 E1           	pop		hl
 428+ 7491 C9           	ret
 429+ 7492              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 430+ 7492
 431+ 7492              	include	"scroll.asm"
# file opened: scroll.asm
   1++7492              ;Scrolling routines for UP/DOWN
   2++7492              ;They use 2 tables of pointers of screen cell rows.
   3++7492              ;One table has addresses in increasing order, for scroll down,
   4++7492              ;the other in decreasing order, for scroll up, so the same
   5++7492              ;scroll routine is used in both cases.
   6++7492              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++7492
   8++7492              ; Char Down
   9++7492              ; Adjusts screen address HL to move eight pixels down on the display.
  10++7492              ; enter: HL = valid screen address
  11++7492              ; exit : HL = moves one character down
  12++7492              ; used : AF, HL
  13++7492              GetCellDown:
  14++7492 7D           	ld a,l
  15++7493 C6 20        	add a,$20
  16++7495 6F           	ld l,a
  17++7496 D0           	ret nc
  18++7497 7C           	ld a,h
  19++7498 C6 08        	add a,$08
  20++749A 67           	ld h,a
  21++749B C9           	ret
  22++749C
  23++749C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++749C              ;Fills the two tables with pointers.
  25++749C              ScrollInit:
  26++749C 21 00 40     	ld		hl, SCR_ADDR
  27++749F 06 17        	ld		b, LINE_CNT
  28++74A1              FillScrLinesLoop:
  29++74A1              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++74A1 22 00 5B     	ld		(SCRLinesDown), hl
  31++74A4              	;inc. pointer in destination table (of pointers to lines)
  32++74A4 ED 5B A2 74  	ld		de, (FillScrLinesPtr)
  33++74A8 13           	inc		de
  34++74A9 13           	inc		de
  35++74AA ED 53 A2 74  	ld		(FillScrLinesPtr), de
  36++74AE CD 92 74     	call	GetCellDown
  37++74B1 10 EE        	djnz	FillScrLinesLoop
  38++74B3
  39++74B3              	;now fill the table in reverse
  40++74B3 ED 73 C7 74  	ld		(FillScrLinesSPStore), sp
  41++74B7 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++74BA 06 17        	ld		b, LINE_CNT
  43++74BC 21 00 5B     	ld		hl, SCRLinesDown
  44++74BF              FillScrLinesRev:
  45++74BF 5E           	ld		e, (hl)
  46++74C0 23           	inc		hl
  47++74C1 56           	ld		d, (hl)
  48++74C2 23           	inc		hl
  49++74C3 D5           	push	de
  50++74C4 10 F9        	djnz	FillScrLinesRev
  51++74C6              FillScrLinesSPStore	EQU	$ + 1
  52++74C6 31 00 00     	ld		sp, 0
  53++74C9 C9           	ret
  54++74CA
  55++74CA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++74CA              ScrollUp:
  57++74CA 21 2E 5B     	ld		hl, SCRLinesUp
  58++74CD 18 03        	jr		Scroll
  59++74CF
  60++74CF              ScrollDown:
  61++74CF 21 00 5B     	ld		hl, SCRLinesDown
  62++74D2
  63++74D2              Scroll:
  64++74D2 22 E0 74     	ld		(ScrollDownPtrDest), hl
  65++74D5 23           	inc		hl
  66++74D6 23           	inc		hl
  67++74D7 22 E3 74     	ld		(ScrollDownPtrSrc), hl
  68++74DA 0E 16        	ld		c, LINE_CNT - 1
  69++74DC
  70++74DC              ScrollDownLoop2:
  71++74DC 06 04        	ld		b, 4
  72++74DE              ScrollDownPtrDest	EQU	$ + 2
  73++74DE ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++74E2              ScrollDownPtrSrc	EQU	$ + 1
  75++74E2 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++74E5
  77++74E5              ScrollDownLoop:					;copy a single char line
  78++74E5 C5           	push	bc
  79++74E6 01 20 00     	ld		bc, 32
  80++74E9 ED B0        	ldir
  81++74EB 2B           	dec		hl
  82++74EC 1B           	dec		de
  83++74ED 24           	inc		h
  84++74EE 14           	inc		d
  85++74EF 01 20 00     	ld		bc, 32
  86++74F2 ED B8        	lddr
  87++74F4 23           	inc		hl
  88++74F5 13           	inc		de
  89++74F6 24           	inc		h
  90++74F7 14           	inc		d
  91++74F8 C1           	pop		bc
  92++74F9 10 EA        	djnz	ScrollDownLoop
  93++74FB
  94++74FB 0D           	dec		c
  95++74FC C8           	ret		z
  96++74FD
  97++74FD 2A E3 74     	ld		hl, (ScrollDownPtrSrc)
  98++7500 22 E0 74     	ld		(ScrollDownPtrDest), hl
  99++7503 23           	inc		hl
 100++7504 23           	inc		hl
 101++7505 22 E3 74     	ld		(ScrollDownPtrSrc), hl
 102++7508 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 432+ 750A
 433+ 750A              CharReplaceTbl:
 434+ 750A B3 80        	defb	179, 128
 435+ 750C B4 81        	defb	180, 129
 436+ 750E BF 82        	defb	191, 130
 437+ 7510 C0 83        	defb	192, 131
 438+ 7512 C1 84        	defb	193, 132
 439+ 7514 C2 85        	defb	194, 133
 440+ 7516 C3 86        	defb	195, 134
 441+ 7518 C4 87        	defb	196, 135
 442+ 751A C5 88        	defb	197, 136
 443+ 751C D9 89        	defb	217, 137
 444+ 751E DA 8A        	defb	218, 138
 445+ 7520 DB 8B        	defb	219, 139
 446+ 7522 DC 8C        	defb	220, 140
 447+ 7524              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 448+ 7524
 449+ 7524 50 72 6F 67  MsgLine		defb	'Progress:'
 449+ 7528 72 65 73 73
 449+ 752C 3A
 450+ 752D 20 20 20 25  MsgLinePr	defb	'   %; '
 450+ 7531 3B 20
 451+ 7533 4C 69 6E 65  			defb	'Line: '
 451+ 7537 3A 20
 452+ 7539 20 20 20 20  MsgLineNo	defb	'     ; '
 452+ 753D 20 3B 20
 453+ 7540 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 453+ 7544 61 70 20
 454+ 7547 20 4F 6E     MsgLineWrF	defb	' On'
 455+ 754A 3B 20 30 2D  			defb	'; 0-Exit'
 455+ 754E 45 78 69 74
 456+ 7552              MsgLineLen	EQU		$ - MsgLine
 457+ 7552
 458+ 7552 20 20 20 20  LineBuf		defb	'                                                                '
 458+ 7556 20 20 20 20
 458+ 755A 20 20 20 20
 458+ 755E 20 20 20 20
 458+ 7562 20 20 20 20
 458+ 7566 20 20 20 20
 458+ 756A 20 20 20 20
 458+ 756E 20 20 20 20
 458+ 7572 20 20 20 20
 458+ 7576 20 20 20 20
 458+ 757A 20 20 20 20
 458+ 757E 20 20 20 20
 458+ 7582 20 20 20 20
 458+ 7586 20 20 20 20
 458+ 758A 20 20 20 20
 458+ 758E 20 20 20 20
 459+ 7592 00 00        CurLine		defw	0
 460+ 7594 01           WrapFlag	defb	1
 461+ 7595 00 00        FileBegin	defw	0
 462+ 7597 00 00        FileLen		defw	0
 463+ 7599 00 00        FileEnd		defw	0
 464+ 759B 00 00        PROGR_PERC	defw	0
 465+ 759D
 466+ 759D              SCRLinesDown	EQU PRN_BUF
 467+ 759D              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 468+ 759D              End:
 469+ 759D
# file closed: txtview.asm
1281  759D              	include "serial.asm"
# file opened: serial.asm
   1+ 759D              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 759D              ;They work with 19200 theoretical speed.
   3+ 759D              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 759D
   5+ 759D              CBAUD	EQU	10	; CBAUD for 19200
   6+ 759D              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 759D
   8+ 759D
   9+ 759D              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 759D              ; A=1 IF FRAMING ERROR
  11+ 759D              ; USES BC,D _DOES NOT USE E!_
  12+ 759D              SERRXI:
  12+ 759D
  13+ 759D 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 75A0 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 75A2 D3 EF        	OUT	(0EFH),A
  16+ 75A4
  17+ 75A4              	; WAIT FOR START
  18+ 75A4              SERWSL:
  19+ 75A4 0B           	DEC	BC
  20+ 75A5 AF           	XOR	A
  21+ 75A6 B8           	CP	B
  22+ 75A7 20 03        	JR	NZ,SERWS
  23+ 75A9 B9           	CP	C
  24+ 75AA 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 75AC DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 75AE CB 7F        	BIT	7,A
  27+ 75B0 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 75B2
  29+ 75B2              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 75B2              ; OF BIT 0
  31+ 75B2 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 75B4 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 75B6
  34+ 75B6              ; GET AND SHIFT BITS
  35+ 75B6              SERRL:
  36+ 75B6 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 75B8 00           	NOP			; 4 (TIMING)
  38+ 75B9 00           	NOP			; 4 (TIMING)
  39+ 75BA 00           	NOP			; 4 (TIMING)
  40+ 75BB DB F7        	IN	A,(0F7H)	; 11
  41+ 75BD 17           	RLA			; 4
  42+ 75BE CB 1A        	RR	D		; 8
  43+ 75C0 06 0A        	LD	B,CBAUD		; 7
  44+ 75C2 0D           	DEC	C		; 4
  45+ 75C3 20 F1        	JR	NZ,SERRL	; 12
  46+ 75C5
  47+ 75C5              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 75C5              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 75C5              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 75C5              ; IDLE UNTIL NEXT START BIT
  51+ 75C5 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 75C7 D3 EF        	OUT	(0EFH),A
  53+ 75C9
  54+ 75C9 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 75CB              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 75CB              SERWIL:
  57+ 75CB 05           	DEC	B
  58+ 75CC 28 0E        	JR	Z,SERRTF
  59+ 75CE DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 75D0 CB 7F        	BIT	7,A
  61+ 75D2 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 75D4
  63+ 75D4              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 75D4 7A           	LD	A,D
  65+ 75D5 2F           	CPL			; INVERT BITS
  66+ 75D6 57           	LD	D,A
  67+ 75D7 AF           	XOR	A		; 0 = SUCCESS
  68+ 75D8 C9           	RET
  69+ 75D9
  70+ 75D9              ; TIMEOUT
  71+ 75D9              SERRTO:
  72+ 75D9 3E FF        	LD	A,0FFH
  73+ 75DB C9           	RET
  74+ 75DC
  75+ 75DC              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 75DC              SERRTF:
  77+ 75DC 3E 01        	LD	A,01H
  78+ 75DE C9           	RET
  79+ 75DF
  80+ 75DF
  81+ 75DF
  82+ 75DF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 75DF              SERRB:
  83+ 75DF
  84+ 75DF              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 75DF              ; BITMAPPED OPTIONS IN E:
  86+ 75DF              ; XXXXXXIT
  87+ 75DF              ; I SET = leave Interrupts disabled at exit
  88+ 75DF              ; T SET = return after Timeout
  89+ 75DF              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 75DF              ; BC=NUMBER OF BYTES RECEIVED
  91+ 75DF              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 75DF F3           	DI
  93+ 75E0 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 75E1              				; OF RECEIVED BYTES
  95+ 75E1
  96+ 75E1              SERRBL:
  97+ 75E1 C5           	PUSH	BC
  98+ 75E2 CD 9D 75     	CALL	SERRXI
  99+ 75E5 C1           	POP	BC
 100+ 75E6 B7           	OR	A
 101+ 75E7 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 75E9 72           	LD	(HL),D
 103+ 75EA 23           	INC	HL
 104+ 75EB 0B           	DEC	BC
 105+ 75EC AF           	XOR	A
 106+ 75ED B8           	CP	B
 107+ 75EE 20 F1        	JR	NZ,SERRBL
 108+ 75F0 B9           	CP	C
 109+ 75F1 20 EE        	JR	NZ,SERRBL
 110+ 75F3              ; FULL RECEIVE
 111+ 75F3 C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 75F4
 113+ 75F4              SERRBX:				; EXIT
 114+ 75F4 CB 4B        	BIT	1,E
 115+ 75F6 C0           	RET	NZ
 116+ 75F7 FB           	EI
 117+ 75F8 C9           	RET
 118+ 75F9
 119+ 75F9              SERRBT:
 120+ 75F9 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 75FB 28 04        	JR	Z,SERRBC
 122+ 75FD CB 43        	BIT	0,E
 123+ 75FF 28 E0        	JR	Z,SERRBL
 124+ 7601
 125+ 7601              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7601 EB           	EX	DE,HL		; PRESERVE HL
 127+ 7602 E1           	POP	HL		; GET INITIAL COUNT
 128+ 7603 37           	SCF
 129+ 7604 3F           	CCF
 130+ 7605 ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7607 44           	LD	B,H
 132+ 7608 4D           	LD	C,L		; BC = COUNT
 133+ 7609 EB           	EX	DE,HL		; RESTORE HL
 134+ 760A
 135+ 760A 18 E8        	JR	SERRBX
 136+ 760C
 137+ 760C              SERRX:
 137+ 760C
 138+ 760C              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 760C              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 760C              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 760C F3           	DI
 142+ 760D CD 9D 75     	CALL	SERRXI
 143+ 7610 FB           	EI
 144+ 7611 C9           	RET
 145+ 7612
 146+ 7612              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7612              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7612              SERTB:
 148+ 7612
 149+ 7612 7E           	LD	A,(HL)
 150+ 7613 C5           	PUSH	BC
 151+ 7614 CD 1F 76     		CALL	SERTX
 152+ 7617 C1           	POP	BC
 153+ 7618 23           	INC	HL
 154+ 7619 0B           	DEC BC
 155+ 761A 78           	LD	A, B
 156+ 761B B1           	OR	C
 157+ 761C 20 F4        	JR	NZ, SERTB
 158+ 761E C9           	RET
 159+ 761F
 160+ 761F              ; SEND CHAR ROUTINE
 161+ 761F              SERTX:
 161+ 761F
 162+ 761F 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7620 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7621 F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7622 3E 01        	LD	A,01H
 166+ 7624 D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7626 1E 20        	LD	E,20H	; PORT MASK
 168+ 7628 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 762A 3E 01        	LD	A,1
 170+ 762C C3 33 76     	JP	SBIT
 171+ 762F
 172+ 762F AF           SHLOOP:	XOR	A		; 4
 173+ 7630 CB 3A        	SRL	D		; 8
 174+ 7632 17           	RLA			; 4
 175+ 7633              SBIT:
 176+ 7633 B3           	OR	E		; 4
 177+ 7634 D3 EF        	OUT	(0EFH),A	; 11
 178+ 7636 06 0A        	LD	B,CBAUD		; 7
 179+ 7638              SBITDL:
 180+ 7638 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 763A 00           	NOP			; 4 (TIMING)
 182+ 763B 0D           	DEC	C		; 4
 183+ 763C 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 763E              ; STOP BIT
 185+ 763E 3E 20        	LD	A,20H
 186+ 7640 D3 EF        	OUT	(0EFH),A
 187+ 7642 06 0A        	LD	B,CBAUD
 188+ 7644 10 FE        STOPL:	DJNZ	STOPL
 189+ 7646 FB           	EI
 190+ 7647 C9           	RET
# file closed: serial.asm
1282  7648
1283  7648              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1284  7648 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-08"
1284  764C 64 20 32 30
1284  7650 32 33 2D 31
1284  7654 32 2D 30 38
1285  7658 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1285  765C 67 65 20 43
1285  7660 68 69 72 74
1285  7664 6F 61 63 E1
1286  7668 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1286  766C 72 61 6D 20
1286  7670 49 6E 66 6F
1286  7674 20 20 20 A0
1287  7678 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1287  767C 20 49 6E 66
1287  7680 6F 20 20 20
1287  7684 20 20 20 A0
1288  7688 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1288  768C 20 49 6E 66
1288  7690 6F 20 20 20
1288  7694 20 20 20 A0
1289  7698 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1289  769C 61 67 65 73
1289  76A0 20 20 20 20
1289  76A4 20 20 20 A0
1290  76A8 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1290  76AC 20 32 2D 42
1290  76B0 3A 20 33 2D
1290  76B4 56 69 65 77
1290  76B8 20 34 2D 50
1290  76BC 72 6F 70 20
1290  76C0 35 2D 43 6F
1290  76C4 70 79 20 36
1290  76C8 2D 52 65 6E
1290  76CC 20 37 2D 41
1290  76D0 74 74 72 20
1290  76D4 38 2D 44 65
1290  76D8 6C 20 39 2D
1290  76DC 44 69 73 6B
1290  76E0 20 30 2D 45
1290  76E4 78 69 F4
1291  76E7 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1291  76EB 46 72 65 65
1291  76EF 3A 20 20
1292  76F2 41 2F        MsgDriveLet		DEFM	'A', '/'
1293  76F4 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1294  76F7 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1294  76FB 73 2F 4B 42
1294  76FF 3A
1295  7700 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1295  7704 30 30 30
1296  7707 45 72 72 6F  MsgErr			DEFM	'Error code '
1296  770B 72 20 63 6F
1296  770F 64 65 20
1297  7712 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1298  7716 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1298  771A 69 6E 67 20
1298  771E 50 72 6F 67
1298  7722 72 61 ED
1299  7725 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1299  7729 69 6E 67 20
1299  772D 53 43 52 45
1299  7731 45 4E A4
1300  7734 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1300  7738 69 6E 67 20
1300  773C 43 4F 44 45
1300  7740 20 28 21 A9
1301  7744 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1301  7748 20 4C 65 6E
1301  774C 3A
1302  774D 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1302  7751 30 20 CB
1303  7754 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1303  7758 69 62 20 20
1303  775C 3A
1304  775D 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1304  7761 48 49 C4
1305  7764 54 79 70 65  MsgFileType		DEFM	'Type    :'
1305  7768 20 20 20 20
1305  776C 3A
1306  776D 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1306  7771 20 20 20 20
1306  7775 20 A0
1307  7777 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1307  777B 72 61 ED
1308  777E 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1308  7782 73 20 A0
1309  7785 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1309  7789 45 4E A4
1310  778C 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1310  7790 41 72 F2
1311  7793 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1311  7797 41 72 F2
1312  779A 4E 6F 6E 65  MsgFileTypeText	DEFM	'None  ', ' ' + $80
1312  779E 20 20 A0
1313  77A1 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1313  77A5 20 20 A0
1314  77A8 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1314  77AC 74 68 20 20
1314  77B0 3A
1315  77B1 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1315  77B5 35 20 C2
1316  77B8 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1316  77BC 74 20 20 20
1316  77C0 3A
1317  77C1 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1317  77C5 35 20 A0
1318  77C8 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1318  77CC 69 6E 67 20
1318  77D0 68 65 61 64
1318  77D4 65 F2
1319  77D6 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1319  77DA 20 20 20 20
1319  77DE 20 20 20 20
1319  77E2 20 20 20 A0
1320  77E6 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1320  77EA 66 69 6C 65
1320  77EE 3F 20 79 2F
1320  77F2 EE
1321  77F3 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1321  77F7 52 2F 4F 3F
1321  77FB 20 79 2F EE
1322  77FF 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1322  7803 48 49 44 3F
1322  7807 20 79 2F EE
1323  780B 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1323  780F 3F 6E 6F 6E
1323  7813 65 3D 61 62
1323  7817 6F 72 74 BA
1324  781B 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1324  781F 20 6D 65 6E
1324  7823 75 BA
1325  7825 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1325  7829 20 63 6F 70
1325  782D 79 20 6D 65
1325  7831 6E 75 BA
1326  7834 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1326  7838 78 69 74 20
1326  783C 6D 65 6E F5
1327  7840
1328  7840 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1328  7844 6F 70 79 20
1329  7848 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1330  784C 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1331  784E
1332  784E 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1332  7852 6F 70 79 20
1333  7856 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1334  785A 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1335  785C
1336  785C 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1336  7860 6F 70 79 20
1337  7864 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1337  7868 43 4F CD
1338  786B
1339  786B 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1339  786F 6F 70 79 20
1339  7873 43 4F 4D 2D
1339  7877 3E
1340  7878 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1341  787A
1342  787A 35 2E 20 46  MsgMenuFmt		DEFM	'5. Format '
1342  787E 6F 72 6D 61
1342  7882 74 20
1343  7884 41 BA        MsgMenuFmtDrv	DEFM	'A', ':' | $80
1344  7886
1345  7886 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1345  788A 61 74 74 69
1345  788E 6E 67 20
1346  7891 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1347  7893
1348  7893 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1348  7897 62 6C 6F 63
1348  789B 6B 73 20 6C
1348  789F 65 66 F4
1349  78A2 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1349  78A6 77 72 69 74
1349  78AA 65 3F 20 79
1349  78AE 2F EE
1350  78B0 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1350  78B4 20 6E 61 6D
1350  78B8 65 20 65 78
1350  78BC 69 73 74 F3
1351  78C0 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1351  78C4 53 4F 55 52
1351  78C8 43 45 20 64
1351  78CC 69 73 EB
1352  78CF 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1352  78D3 44 45 53 54
1352  78D7 2E 20 64 69
1352  78DB 73 6B A0
1353  78DE 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1353  78E2 73 20 61 6E
1353  78E6 79 20 6B 65
1353  78EA F9
1354  78EB 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1354  78EF 73 65 63 74
1354  78F3 6F 72 73 20
1354  78F7 63 6F 70 F9
1355  78FB
1356  78FB              	IFNDEF	_REAL_HW_
1357  78FB ~            FontTable:
1358  78FB ~            	incbin "cpmfnt.bin"
1359  78FB              	ENDIF
1360  78FB              EndCode:
1361  78FB
1362  78FB              ;Unalocated variables
1363  78FB              UnallocStart	EQU		EndCode
1364  78FB              FileCnt			EQU		UnallocStart			;File counter, 1B
1365  78FB              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1366  78FB              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1367  78FB              CursorAddr		EQU		SelFile + 1				;2 B
1368  78FB              AUCntUsed		EQU		CursorAddr + 2			;2 B
1369  78FB              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1370  78FB              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1371  78FB              CopySelOption	EQU		SelFileCache+2			;1 B
1372  78FB
1373  78FB              CopyFileFCB		EQU	CopySelOption + 1
1374  78FB              CopyFileRes		EQU CopyFileFCB + 2
1375  78FB              CopyFileDMAAddr	EQU	CopyFileRes + 1
1376  78FB              FilePosRead		EQU	CopyFileDMAAddr + 2
1377  78FB              FilePosWrite	EQU	FilePosRead + 2
1378  78FB              CopyFileSectCnt EQU FilePosWrite + 2
1379  78FB              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1380  78FB              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1381  78FB              CopyFileDstDrv	EQU CopyFileSrcName + 11
1382  78FB              CopyFileDstName	EQU CopyFileDstDrv + 1
1383  78FB
1384  78FB              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1385  78FB              ;FS block list constants
1386  78FB              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1387  78FB              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1388  78FB              UsedBlockListSz		EQU 320 * 2 + 2							;640
1389  78FB
1390  78FB              	IFDEF	_REAL_HW_
1391  78FB              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1392  78FB              DataBuf			EQU		FontTable + 872
1393  78FB              	ELSE
1394  78FB ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1395  78FB              	ENDIF
1396  78FB
1397  78FB              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1398  78FB
1399  78FB
1400  78FB              ;File viewer constants
1401  78FB              FileData		EQU		DataBuf
1402  78FB              ;File buffer size, without index
1403  78FB              FileIdxSize		EQU		1 * 1024
1404  78FB              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1405  78FB              ;Set a few KB aside for file indexing
1406  78FB              FileIdx			EQU		FileData + FileDataSize
1407  78FB              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1408  78FB
1409  78FB
1410  78FB              ;Copy buffer size, follows
1411  78FB              CopyDiskBuf			EQU DataBuf
1412  78FB
1413  78FB              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1414  78FB              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1415  78FB              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1416  78FB
1417  78FB              	DISPLAY "DataBuf: ", /D,DataBuf
1418  78FB              	DISPLAY "BinSize: ", /D, EndCode - Start
1419  78FB              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1420  78FB              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x680A   NoSub
0x6803   DivLoop
0x77B9   MAX_RAM_FREE
0x0077   MAX_SECT_RAM
0x0400   FileIdxSize
0x0282   UsedBlockListSz
0x78FB   UnallocStart
0x78FB   EndCode
0x76F4 X MsgFreeSpaceNo
0x7644   STOPL
0x762F   SHLOOP
0x7633   SBIT
0x7638   SBITDL
0x761F   SERTX
0x760C X SERRX
0x7601   SERRBC
0x75F4   SERRBX
0x75F9   SERRBT
0x75E1   SERRBL
0x75CE X SERWI
0x75DC   SERRTF
0x75CB   SERWIL
0x75B6   SERRL
0x75D9   SERRTO
0x75AC   SERWS
0x75A4   SERWSL
0x759D   SERRXI
0x000A   CBAUD
0x759D X End
0x7540 X MsgLineWrap
0x74E5   ScrollDownLoop
0x74DC   ScrollDownLoop2
0x74E3   ScrollDownPtrSrc
0x74E0   ScrollDownPtrDest
0x74D2   Scroll
0x74BF   FillScrLinesRev
0x5B2E   SCRLinesUp
0x74C7   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x74A2   FillScrLinesPtr
0x74A1   FillScrLinesLoop
0x7492   GetCellDown
0x748D   ReplaceMatch
0x7481   ReplaceSGCLoop
0x000D   CharReplTblLen
0x750A   CharReplaceTbl
0x002E   MsgLineLen
0x7524   MsgLine
0x7539   MsgLineNo
0x752D   MsgLinePr
0x740A   GetLineFill
0x747A   ReplaceChars
0x73F6   Valid
0x73F3   NotValid
0x73FA   GetLineSkip0D
0x73E9   GetLineNext
0x7424   GetLineFillLoop
0x73E2   GetLineTab
0x7403   GetLineSkip0A
0x73CE   GetLineLoop
0x73AF   PrintStrTxt
0x7552   LineBuf
0x74CF   ScrollDown
0x74CA   ScrollUp
0x7380   CheckBegin
0x7547   MsgLineWrF
0x7312   NoWrap
0x7594   WrapFlag
0x7321   Up
0x734C   Down
0x72CC   GetKey
0x72DB   ViewFileEOF
0x7390   CheckEnd
0x739B   PrintLine
0x73C9   GetLine
0x742B   PrintMsg
0x759B   PROGR_PERC
0x7592   CurLine
0x749C   ScrollInit
0x7597   FileLen
0x7599   FileEnd
0x7595   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x7236   ClearNMsgLinesLoop
0x7224   ReadStrPrint
0x7214   ReadStrChar
0x71F7   ReadStringLoop
0x71EB   Store
0x71EA   NoTurn
0x71DF   PrintCharLine
0x71CB X PrintChar3
0x7176   DrawCursorLoop
0x715D   DrawVLinesLoop
0x712E   DrawLowerIntersectLoop
0x713F   DrawIntersect
0x7119   DrawUpperIntersectLoop
0x70ED   DrawLineLoop
0x70FA   LineDir
0x70EA   StoreDir
0x70E8   VertDir
0x70DF   DrawLine
0x70DB   StrClr
0x708E   GoodChar
0x7246   CurrScrAddr
0x83DF   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x700E   ReadWriteFileSectionLoop
0x702C   ReadWriteFileSectionEnd
0x790A   CopyFileDMAAddr
0x7907   CopyFileFCB
0x6FD3   ReadWriteFileSection
0x0073   MAX_SECT_BUF
0x703D   CopyFilePtr2
0x6FF9   CopyFilePtr
0x7021   CopyFileOperAddr2
0x7002   CopyFileOperAddr1
0x6F84   CopyFileFromCOMDontInc
0x7300   FileDataSize
0x6F71   CopyFileFromCOMLoop
0x6F10   CopyFileToCOMEnd
0x6EF2   CopyFileToCOMLoop
0x6EAC   CopyFileDualDriveLoop
0x6FBA   WriteFileSection
0x78EB   MsgCopySectors
0x6E45   CopyFileSameDriveLoop
0x7910   CopyFileSectCnt
0x6E03   CopyFileCreateNewFile
0x78A2   MsgFileOverwrite
0x6DE7   CopyFileCheckOverwrite
0x6F15   CopyFileFromCOM
0x6EE4   CopyFileToCOM
0x6E9C   CopyFileDualDrive
0x6E21   CopyFileSameDrive
0x6DD0   CopyFileNotExit
0x7825   MsgMenuFileCopy
0x790E   FilePosWrite
0x791E   CopyFileDstName
0x7912   CopyFileSrcName
0x78C0   MsgInsertSrcDsk
0x78DE   MsgPressAnyKey
0x78CF   MsgInsertDstDsk
0x6CD3 X FileAttribSet
0xFA47   FileIdx
0x6C81   GetFileSizeMul
0x6C87   GetFileSizeEnd
0x6C7F   GetFileSizeOK
0x6C5F   BDOSSetRandFilePtr
0x6C5B   BDOSSetDMA
0x6C4D   BDOSWriteFileBlockRandom
0x6C49   BDOSReadFileBlockRandom
0x6C45   BDOSWriteFileBlockSeq
0x6C41   BDOSReadFileBlockSeq
0x6C3D   BDOSCloseFile
0x6C39   BDOSOpenFile
0x6C35   BDOSCreateFile
0x6C2B   DestroyChannel
0x6C15   CreateChannel
0x6C15 X BDOSCloseDrives
0x6C11 X BDOSGetDiskRO
0x6C11 X BDOSMakeDiskRO
0x6C51   BDOS
0x6C03 X PrmIntrlvTbl
0x6C02 X PrmSpinUp
0x6C01 X PrmHeadLoad
0x6BFF X PrmDevType
0x6BFA X RWTSResTmp
0x6BF9 X RWTSResVolNo
0x6BFF   BasPrmTbl
0x6BF5 X RWTSPrmTbl
0x6BF3 X RWTSExtBuf
0x6BF0 X RWTSSector
0x6BEE X RWTSVolNo
0x6BEC X RWTSBlockType
0x6BE3   CopyMsg
0x6BD7   SearchMsgEnd
0x6BE0   SaveMsg
0x6BCE   IF1Paged
0x6B9C   IF1Call
0x6B97   IsFileHeaderValidLoop
0x6C63   GetFileSize
0x6B7B   ReadFileHeaderIsTextFile
0x6B94   IsFileHeaderValid
0x6B90   ReadHeaderEnd
0x6B35   CacheNotFinished
0x6B2A X SeekTrack
0x6ADF   FileReadLoop
0x6AD3 X FileLoadHeader
0x6AE5   FileLoadNoHeader
0x6AF3   FileFree
0x6AAF   MisMatch
0x6AA7   Compare
0x6AA5   StrCmp
0x6A5C   CopyDiskFromCOMLoop
0x75DF   SERRB
0x69F8   CopyDiskToCOMLoop
0x7612   SERTB
0x6D19   PromptDiskChangeSrc
0x69D0   CopyDiskDualDrive2
0x69DD   CopyDiskEnd
0x69AC X CopyDiskWriteEnd
0x6995   CopyDiskLoopWriteLoop
0x698E   CopyDiskReadEnd
0x6CFF   PromptDiskChangeDst
0x6984   CopyDiskDualDrive1
0x695B   CopyDiskLoopReadLoop
0x8747   CopyDiskBuf
0x6954   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7893   MsgBlocksLeft
0x6931   CopyDiskLoop
0x815F   UsedBlockListBlk
0x6B0B   WriteDiskSectors
0x691D   WriteFSBlock
0x6AF8   ReadDiskSectors
0x6910   ReadFSBlock
0x6902   ReadUsedBlocksSkip
0x68E5   ReadUsedBlocksLoop2
0x6905   ReadUsedBlocksSkip2
0x68D5   ReadUsedBlocksLoop
0x815D   UsedBlockListCnt
0x68B7   ReadUsedBlocksList
0x68B0   CheckAUEnd
0x689C   CheckAU
0x6885   FirstAU
0x687F   Track0
0x686A   AU2TS
0x684E   WriteOneDiskSector
0x6BEF   RWTSTrack
0x6BF1   RWTSDMA
0x6BEC   RWTSParams
0x6BF7   RWTSCmd
0x6837   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x001A   CHAR_EOF
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6831   NoAdd
0x682B   MulLoop
0x6812   Div2Loop
0x680D   Div2
0x6800   Div
0x67F7   DivNrLoop
0x67F5   DigitLoop
0x67E6   Byte2Txt_
0x67CF   StrippLeading0
0x67DA   Word2Txt_
0x67B9 X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x67B6   DontInc
0x67B0   ReadAllHeadersEnd
0x679B   AKey
0x704E   KbdHit
0x6780   NextFile
0x77A8   MsgFileLen
0x7764   MsgFileType
0x77B8   MsgFileStart
0x673F   PrintStartStr
0x77C1   MsgFileStartN
0x77A1   MsgNA
0x6731   PrintStart
0x0007   HDR_LINE
0x670C   PrintByteStart
0x6704   PrintProgStart
0x77B1   MsgFileLenN
0x66EA X PrepFileLenText
0x779A   MsgFileTypeText
0x777E   MsgFileTypeByte
0x7785   MsgFileTypeSCR
0x66D0   NotScr
0x66DB   CheckText
0x778C   MsgFileTypeChrA
0x66B3   CheckByte
0x0002   CHAR_TYPE
0x7793   MsgFileTypeNoA
0x66A4   CheckChrArr
0x0001   NUMB_TYPE
0x66E4   PrepFileLen
0x6C00 X PrmStepRate
0x675D   MoveMsg
0x776D   MsgFileTypeN
0x7777   MsgFileTypePrg
0x6695   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6714   HeadNotRead
0x7754   MsgFileAttr
0x6666   AttrEnd
0x665A   NotSYS
0x6646   CheckSys
0x6634   NotRO
0x775D   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x6726   PrintStartNotRead
0x7744   MsgFileSzDsk
0x774D   MsgFileSzDskN
0x72E3   PrintLoop2
0x72A8   PrintLoop
0x724A   InitViewer
0x6F98   ReadFileSection
0x65CB   ViewFileLoop
0x790C   FilePosRead
0x6BA2   LoadProgram
0x7911   CopyFileSrcDrv
0x7716   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7725   MsgLoadingSCR
0x0003   HDR_ADDR
0x6AF8   IF1FileLoadEnd
0x5B00   PRN_BUF
0x6AB2   IF1FileLoad
0x7734   MsgLoadingCODE
0x656D X HandleFileCODE
0x6593   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x65C1   HandleFileText
0x0003   BYTE_TYPE
0x65B1   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6537   FindExtEnd
0x6B2A   FindCache
0x6546   GetFileNamesEnd
0x0009   HDR_SZ
0x6512   FindExt
0x000C   EXT_IDX
0x6888   CheckExtAlloc
0x6539   NextExt
0x0000   EXT_DEL_FLAG
0x64C1   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x649E   DisplayFilenamesLoop
0x6484   LineOK
0x5CB1   LINE
0x5CB0   COL
0x71B3   PrintChar
0x5C81   CODE
0x645E   DispLoop
0x645C   DisplayFilename
0x717B   MoveCursor
0x6859   FormatDisk
0x7886   MsgFormat
0x6A3F   CopyDiskFromCOM
0x641A   CheckDiskMenuFormat
0x69E3   CopyDiskToCOM
0x6410   CheckDiskMenuFromCOM
0x6407   CheckDiskMenuToCOM
0x692A   CopyDisk
0x63F9   CheckDiskMenuDualDrive
0x644B   DiskMenuExit
0x63E7 X CheckKeyDiskMenuLoop
0x787A   MsgMenuFmt
0x786B   MsgMenuFromCOM
0x785C   MsgMenuToCOM
0x784E   MsgMenuDual
0x7840   MsgMenuSingle
0x7834   MsgMenuBack
0x781B   MsgMenuDiskCopy
0x785A   MsgMenuDualDrv2
0x7891   MsgFormatDrv
0x7884   MsgMenuFmtDrv
0x7878   MsgMenuFromCOMDrv
0x7864   MsgMenuToComDrv
0x7856   MsgMenuDualDrv1
0x784C   MsgMenuSingleDrv2
0x7848   MsgMenuSingleDrv1
0x644E   CheckKeyExit
0x6CB2   ChangeFileAttrib
0x635D   AttrChange
0x77FF   MsgSetSYS
0x6345   CheckSYS
0x77F3   MsgSetRO
0x636F   CheckKeyDiskMenu
0x6C8D   DeleteFile
0x6317   DoFileDelete
0x77E6   MsgDelete
0x6324   CheckKeyAttrib
0x6CDC   RenameFile
0x78B0   MsgFileExists
0x62DE   RenameFileNotExist
0x6C99   DoesFileExist
0x62EA   RenameCanceled
0x71F1   ReadString
0x000B   NAMELEN
0x77D6   MsgClear
0x780B   MsgNewFileName
0x62F2   CheckKeyDel
0x65C2   ViewFile
0x6282   CheckKeyRename
0x0001   DRIVE_B_CPM
0x6271   CheckKeyView
0x6366   SelectDrive
0x6268   CheckKeyDriveB
0x6763   ReadAllHeaders
0x625F   CheckKeyDriveA
0x791D   CopyFileDstDrv
0x7906   CopySelOption
0x6234   CopyFileOK
0x7909   CopyFileRes
0x6D33   CopyFile
0x624E   CheckKeyFileInfo
0x7233   ClearNMsgLines
0x6B3B   ReadFileHeader
0x77C8   MsgReadingExt
0x6202   CheckKeyCopy
0x6547   HandleFile
0x61DD   CheckKeyInfo
0x61D7   DoKeyEnter
0x000D   KEY_ENTER
0x61CE   CheckEnter
0x61C1   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x61B9   CheckLeft
0x61A7   DoKeyRight
0x0009   KEY_RIGHT
0x619F   CheckRight
0x6192   DoKeyUp
0x000B   KEY_UP
0x6456   MoveIt
0x618A   CheckUp
0x6179   DoKeyDown
0x000A   KEY_DOWN
0x65F1   DisplayFileInfo
0x7904   SelFileCache
0x6820   Mul
0x6157   CalcFileCache
0x76F7   MsgFilesCnt
0x78FB   FileCnt
0x7700   MsgFilesCntNo
0x76E7   MsgDrive
0x67B9   Word2Txt
0x76F2   MsgDriveLet
0x7900   AUCntUsed
0x6BBB   SetFastKeys
0x7170   DrawCursor
0x0060   SCR_SEL_CLR
0x7698   MsgMessages
0x0007   LST_FILE_INFO
0x7688   MsgFileInf
0x0004   LST_DISK_INFO
0x7678   MsgDskInf
0x7668   MsgSysInf
0x76A8   BtnBar
0x0060   SCR_LBL_CLR
0x7658   VerMsg2
0x7087   PrintStr
0x0001   LST_PROG_INFO
0x7648   VerMsg1
0x70FE   DrawHLines
0x7158   DrawVLines
0x78FE   CursorAddr
0x7248   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x7067   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x78FC   NameCol
0x0010   LST_FIRST_COL
0x78FD   SelFile
0x704B   ReadChar
0x8747   DataBuf
0x6BC6   GetErrMsg
0x5C3A   ERRNR
0x603A   HCRunEnd
0x6168   ReadKeyLoop
0x60F5   DisplayDiskInfo
0x648E   DisplayFilenames
0x6077   InitUI
0x602E   HCRunMain
0x64AE   GetFileNames
0x70AF   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7707   MsgErr
0x67C4   Byte2Txt
0x7712   MsgErrCode
0x602B   HCRunCacheFiles
0x6B1E   ReadCatalogTrack
0x7902   AUCntMaxFree
0x6008   DriveIs80Tracks
0x013E   MAX_FREE_AU_CNT
0x6BF8   RWTSRes
0x6843   ReadOneDiskSector
0x8747   FileData
0x0050   TRACK_CNT
0x6C08   BDOSSelectDisk
0x6BED   RWTSDrive
0x6C05   BDOSInit
0x0000   DRIVE_A_CPM
0x5FE9   DetectTrackCount
0x6C11   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x7929   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8747   TrackBuf
0x5FC6   HCRunInitDisk
0x6042   ErrorHandler
0x5C3D   ERRSP
0x6834   IF1Init
0x7051   InitFonts
0x5FB4   Start
