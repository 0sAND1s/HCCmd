# file opened: hccmd.asm
   1  0000
   2  0000
   3  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   4  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   5  0000              	;DEFINE  _REAL_HW_
   6  0000
   7  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
   8  0000              ;So we have to put our code after the program as loaded in RAM.
   9  0000              	ORG 28000
  10  6D60
  11  6D60              Start:
  12  6D60              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  13  6D60 CD DB 7F     		call InitFonts
  14  6D63              	ENDIF
  15  6D63 CD B7 77     	call IF1Init
  16  6D66
  17  6D66              	;install error handler
  18  6D66 2A 3D 5C     	ld		hl, (ERRSP)
  19  6D69 E5           	push	hl
  20  6D6A 21 EE 6D     	ld		hl, ErrorHandler
  21  6D6D E5           	push	hl
  22  6D6E ED 73 3D 5C  	ld		(ERRSP), sp
  23  6D72
  24  6D72              HCRunInitDisk:
  25  6D72              	;Set track buffer to del marker
  26  6D72 21 59 97     	ld		hl, TrackBuf
  27  6D75 54           	ld		d, h
  28  6D76 5D           	ld		e, l
  29  6D77 13           	inc		de
  30  6D78 01 00 10     	ld		bc, SPT*SECT_SZ
  31  6D7B 36 E5        	ld		(hl), DEL_MARKER
  32  6D7D ED B0        	ldir
  33  6D7F
  34  6D7F              	;Invalidate file cache
  35  6D7F 21 3B 89     	ld		hl, FileCache
  36  6D82 54           	ld		d, h
  37  6D83 5D           	ld		e, l
  38  6D84 13           	inc		de
  39  6D85 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  40  6D88 36 00        	ld		(hl), 0
  41  6D8A ED B0        	ldir
  42  6D8C
  43  6D8C              	;main program
  44  6D8C CD 94 7B     	call	BDOSGetCurrentDrive
  45  6D8F FE FF        	cp		$FF
  46  6D91 20 02        	jr		nz, DetectTrackCount
  47  6D93
  48  6D93 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  49  6D95
  50  6D95              DetectTrackCount:
  51  6D95 F5           	push	af
  52  6D96 CD 88 7B     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  53  6D99 F1           	pop		af
  54  6D9A 32 70 7B     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  55  6D9D CD 8B 7B     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  56  6DA0
  57  6DA0              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  58  6DA0 1E 28        	ld		e, TRACK_CNT/2
  59  6DA2 21 59 97     	ld		hl, FileData
  60  6DA5 CD C6 77     	call	ReadOneDiskSector
  61  6DA8 3A 7B 7B     	ld		a, (RWTSRes)
  62  6DAB B7           	or		a
  63  6DAC 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  64  6DAF 28 03        	jr		z, DriveIs80Tracks
  65  6DB1 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  66  6DB4              DriveIs80Tracks:
  67  6DB4 22 0F 89     	ld		(AUCntMaxFree), hl
  68  6DB7
  69  6DB7 CD A1 7A     	call 	ReadCatalogTrack
  70  6DBA B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  71  6DBB 28 1A        	jr		z, HCRunCacheFiles
  72  6DBD
  73  6DBD 6F           	ld		l, a
  74  6DBE 26 00        	ld		h, 0
  75  6DC0 11 E0 86     	ld		de, MsgErrCode
  76  6DC3 CD A8 76     	call	Byte2Txt
  77  6DC6 21 D5 86     	ld		hl, MsgErr
  78  6DC9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  79  6DCC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  80  6DCE CD 39 80     	call	PrintStrClr
  81  6DD1 CD 88 7B     	call	BDOSInit
  82  6DD4 C3 72 6D     	jp		HCRunInitDisk
  83  6DD7
  84  6DD7
  85  6DD7              HCRunCacheFiles:
  86  6DD7 CD BA 72     	call 	GetFileNames
  87  6DDA
  88  6DDA              HCRunMain:
  89  6DDA CD 23 6E     	call 	InitUI
  90  6DDD CD 9A 72     	call	DisplayFilenames
  91  6DE0 CD A1 6E     	call	DisplayDiskInfo
  92  6DE3 C3 14 6F     	jp		ReadKeyLoop
  93  6DE6
  94  6DE6              HCRunEnd:
  95  6DE6              	;restore error handler
  96  6DE6 E1           	pop		hl
  97  6DE7 E1           	pop		hl
  98  6DE8 22 3D 5C     	ld		(ERRSP), hl
  99  6DEB
 100  6DEB              	;ret
 101  6DEB C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 102  6DEE
 103  6DEE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 104  6DEE
 105  6DEE              ErrorHandler:
 106  6DEE E1           	pop		hl
 107  6DEF 22 3D 5C     	ld		(ERRSP), hl
 108  6DF2
 109  6DF2 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 110  6DF5 6F           	ld		l, a
 111  6DF6 26 00        	ld		h, 0
 112  6DF8 11 E0 86     	ld		de, MsgErrCode
 113  6DFB CD A8 76     	call	Byte2Txt
 114  6DFE 21 D5 86     	ld		hl, MsgErr
 115  6E01 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 116  6E04 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 117  6E06 CD 39 80     	call	PrintStrClr
 118  6E09
 119  6E09 3A 3A 5C     	ld		a, (ERRNR)
 120  6E0C CD 49 7B     	call	GetErrMsg
 121  6E0F
 122  6E0F 21 59 97     	ld		hl, DataBuf
 123  6E12 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 124  6E15 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 125  6E17 CD 39 80     	call	PrintStrClr
 126  6E1A
 127  6E1A CD D5 7F     	call	ReadChar
 128  6E1D CD 88 7B     	call	BDOSInit
 129  6E20 C3 60 6D     	jp		Start
 130  6E23
 131  6E23              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 132  6E23
 133  6E23              InitUI:
 134  6E23 AF           	xor		a
 135  6E24 32 0A 89     	ld		(SelFile), A
 136  6E27 3E 11        	ld		a, LST_FIRST_COL + 1
 137  6E29 32 09 89     	ld		(NameCol), A
 138  6E2C 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 139  6E2F ED 53 B0 5C  	ld		(LineCol), de
 140  6E33
 141  6E33 CD F1 7F     	call	ClrScr
 142  6E36
 143  6E36 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 144  6E39 ED 4B D2 81  	ld		bc, (CurrScrAttrAddr)
 145  6E3D 09           	add		hl, bc
 146  6E3E 22 0B 89     	ld		(CursorAddr), hl
 147  6E41
 148  6E41 CD E2 80     	call	DrawVLines
 149  6E44
 150  6E44 CD 88 80     	call	DrawHLines
 151  6E47
 152  6E47 21 16 86     	ld		hl, VerMsg1
 153  6E4A 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 154  6E4D 3A 25 86     	ld		a, (VerMsg1 + 15)
 155  6E50 F6 80        	or		$80
 156  6E52 32 25 86     	ld		(VerMsg1 + 15), a
 157  6E55 CD 11 80     	call	PrintStr
 158  6E58 21 26 86     	ld		hl, VerMsg2
 159  6E5B 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 160  6E5E CD 11 80     	call	PrintStr
 161  6E61
 162  6E61 3E 60        	ld		a, SCR_LBL_CLR
 163  6E63 11 00 17     	ld		de, 23 << 8
 164  6E66 21 76 86     	ld		hl, BtnBar
 165  6E69 CD 39 80     	call	PrintStrClr
 166  6E6C
 167  6E6C 3E 60        	ld		a, SCR_LBL_CLR
 168  6E6E 21 36 86     	ld		hl, MsgSysInf
 169  6E71 11 00 01     	ld		de, LST_PROG_INFO << 8
 170  6E74 CD 39 80     	call	PrintStrClr
 171  6E77
 172  6E77 3E 60        	ld		a, SCR_LBL_CLR
 173  6E79 21 46 86     	ld		hl, MsgDskInf
 174  6E7C 11 00 04     	ld		de, LST_DISK_INFO << 8
 175  6E7F CD 39 80     	call	PrintStrClr
 176  6E82
 177  6E82 3E 60        	ld		a, SCR_LBL_CLR
 178  6E84 21 56 86     	ld		hl, MsgFileInf
 179  6E87 11 00 07     	ld		de, LST_FILE_INFO << 8
 180  6E8A CD 39 80     	call	PrintStrClr
 181  6E8D
 182  6E8D 3E 60        	ld		a, SCR_LBL_CLR
 183  6E8F 21 66 86     	ld		hl, MsgMessages
 184  6E92 11 00 0D     	ld		de, LST_LINE_MSG << 8
 185  6E95 CD 39 80     	call	PrintStrClr
 186  6E98
 187  6E98 3E 60        	ld		a, SCR_SEL_CLR
 188  6E9A CD FA 80     	call	DrawCursor
 189  6E9D
 190  6E9D CD 3E 7B     	call	SetFastKeys
 191  6EA0
 192  6EA0 C9           	ret
 193  6EA1
 194  6EA1
 195  6EA1              DisplayDiskInfo:
 196  6EA1 2A 0F 89     	ld		hl, (AUCntMaxFree)
 197  6EA4 ED 5B 0D 89  	ld		de, (AUCntUsed)
 198  6EA8 B7           	or		a
 199  6EA9 ED 52        	sbc		hl, de
 200  6EAB CB 15        	rl		l								;*2, 2K/AU
 201  6EAD CB 14        	rl		h
 202  6EAF
 203  6EAF 11 C0 86     	ld		de, MsgDriveLet
 204  6EB2 CD 9D 76     	call	Word2Txt
 205  6EB5 3A C4 86     	ld		a, (MsgDriveLet+4)
 206  6EB8 F6 80        	or		$80
 207  6EBA 32 C4 86     	ld		(MsgDriveLet+4), a
 208  6EBD
 209  6EBD 3A 70 7B     	ld		a, (RWTSDrive)
 210  6EC0 C6 41        	add		'A'
 211  6EC2 32 C0 86     	ld		(MsgDriveLet), a
 212  6EC5 3E 2F        	ld		a, '/'
 213  6EC7 32 C1 86     	ld		(MsgDriveLet+1), a
 214  6ECA
 215  6ECA 21 B5 86     	ld		hl, MsgDrive
 216  6ECD 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 217  6ED0 CD 11 80     	call	PrintStr
 218  6ED3
 219  6ED3 2A 0D 89     	ld		hl, (AUCntUsed)
 220  6ED6 CB 15        	rl		l								;*2, 2K/AU
 221  6ED8 CB 14        	rl		h
 222  6EDA 11 D0 86     	ld		de, MsgFilesCntNo+2
 223  6EDD CD 9D 76     	call	Word2Txt
 224  6EE0 3A D4 86     	ld		a, (MsgFilesCntNo+6)
 225  6EE3 F6 80        	or		$80
 226  6EE5 32 D4 86     	ld		(MsgFilesCntNo+6), a
 227  6EE8 3E 2F        	ld		a, '/'
 228  6EEA 32 D1 86     	ld		(MsgFilesCntNo+3), a
 229  6EED
 230  6EED 3A 08 89     	ld		a, (FileCnt)
 231  6EF0 6F           	ld		l, a
 232  6EF1 26 00        	ld		h, 0
 233  6EF3 11 CE 86     	ld		de, MsgFilesCntNo
 234  6EF6 CD A8 76     	call	Byte2Txt
 235  6EF9 21 C5 86     	ld		hl, MsgFilesCnt
 236  6EFC 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 237  6EFF CD 11 80     	call	PrintStr
 238  6F02
 239  6F02 C9           	ret
 240  6F03
 241  6F03              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 242  6F03
 243  6F03              CalcFileCache:
 244  6F03 3A 0A 89     	ld		a, (SelFile)
 245  6F06 11 19 00     	ld		de, CACHE_SZ
 246  6F09 CD 04 77     	call	Mul
 247  6F0C 01 3B 89     	ld		bc, FileCache
 248  6F0F 09           	add		hl, bc					;HL = file AU cnt
 249  6F10 22 11 89     	ld		(SelFileCache), hl
 250  6F13 C9           	ret
 251  6F14
 252  6F14              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 253  6F14
 254  6F14
 255  6F14              ReadKeyLoop:
 256  6F14 CD 03 6F     	call	CalcFileCache
 257  6F17 CD E1 74     	call	DisplayFileInfo
 258  6F1A
 259  6F1A CD D5 7F     	call	ReadChar
 260  6F1D
 261  6F1D FE 0A        	cp		KEY_DOWN
 262  6F1F 28 04        	jr		z,  DoKeyDown
 263  6F21 FE 61        	cp 		'a'
 264  6F23 20 11        	jr		nz, CheckUp
 265  6F25
 266  6F25              DoKeyDown:
 267  6F25 3A 08 89     	ld		a, (FileCnt)
 268  6F28 47           	ld		b, a
 269  6F29 3A 0A 89     	ld		a, (SelFile)
 270  6F2C 3C           	inc		a
 271  6F2D B8           	cp		b
 272  6F2E 30 E4        	jr		nc, ReadKeyLoop
 273  6F30 32 0A 89     	ld		(SelFile), a
 274  6F33 C3 62 72     	jp		MoveIt
 275  6F36
 276  6F36              CheckUp:
 277  6F36 FE 0B        	cp		KEY_UP
 278  6F38 28 04        	jr		z, DoKeyUp
 279  6F3A FE 71        	cp 		'q'
 280  6F3C 20 0D        	jr		nz, CheckRight
 281  6F3E
 282  6F3E              DoKeyUp:
 283  6F3E 3A 0A 89     	ld		a, (SelFile)
 284  6F41 B7           	or		a
 285  6F42 28 D0        	jr		z, ReadKeyLoop
 286  6F44
 287  6F44 3D           	dec		a
 288  6F45 32 0A 89     	ld		(SelFile), a
 289  6F48 C3 62 72     	jp		MoveIt
 290  6F4B
 291  6F4B              CheckRight:
 292  6F4B FE 09        	cp		KEY_RIGHT
 293  6F4D 28 04        	jr		z, DoKeyRight
 294  6F4F FE 70        	cp 		'p'
 295  6F51 20 12        	jr		nz, CheckLeft
 296  6F53
 297  6F53              DoKeyRight:
 298  6F53 3A 08 89     	ld		a, (FileCnt)
 299  6F56 47           	ld		b, a
 300  6F57 3A 0A 89     	ld		a, (SelFile)
 301  6F5A C6 15        	add		LST_LINES_CNT
 302  6F5C B8           	cp		b
 303  6F5D 30 B5        	jr		nc, ReadKeyLoop
 304  6F5F
 305  6F5F 32 0A 89     	ld		(SelFile), a
 306  6F62 C3 62 72     	jp		MoveIt
 307  6F65
 308  6F65              CheckLeft:
 309  6F65 FE 08        	cp		KEY_LEFT
 310  6F67 28 04        	jr		z, DoKeyLeft
 311  6F69 FE 6F        	cp		'o'
 312  6F6B 20 0D        	jr		nz, CheckEnter
 313  6F6D
 314  6F6D              DoKeyLeft:
 315  6F6D 3A 0A 89     	ld		a, (SelFile)
 316  6F70 D6 15        	sub		LST_LINES_CNT
 317  6F72 38 A0        	jr		c, ReadKeyLoop
 318  6F74
 319  6F74 32 0A 89     	ld		(SelFile), a
 320  6F77 C3 62 72     	jp		MoveIt
 321  6F7A
 322  6F7A              CheckEnter:
 323  6F7A FE 0D        	cp		KEY_ENTER
 324  6F7C 28 05        	jr		z, DoKeyEnter
 325  6F7E FE 6D        	cp		'm'
 326  6F80 C2 89 6F     	jp		nz, CheckKeyInfo
 327  6F83
 328  6F83              DoKeyEnter:
 329  6F83 CD 4F 73     	call	HandleFile
 330  6F86 C3 DA 6D     	jp		HCRunMain
 331  6F89
 332  6F89              CheckKeyInfo:
 333  6F89 FE 34        	cp		'4'
 334  6F8B 20 21        	jr		nz, CheckKeyCopy
 335  6F8D
 336  6F8D 3A 08 89     	ld		a, (FileCnt)
 337  6F90 B7           	or		a
 338  6F91 CA 14 6F     	jp		z, ReadKeyLoop
 339  6F94
 340  6F94 DD 2A 11 89  	ld		ix, (SelFileCache)
 341  6F98 21 96 87     	ld		hl, MsgReadingExt
 342  6F9B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 343  6F9E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 344  6FA0 CD 39 80     	call	PrintStrClr
 345  6FA3 CD BE 7A     	call	ReadFileHeader
 346  6FA6 06 01        	ld		b, 1
 347  6FA8 CD BD 81     	call	ClearNMsgLines
 348  6FAB C3 14 6F     	jp		ReadKeyLoop
 349  6FAE
 350  6FAE              CheckKeyCopy:
 351  6FAE FE 35        	cp		'5'
 352  6FB0 C2 FA 6F     	jp		nz, CheckKeyFileInfo
 353  6FB3
 354  6FB3 3A 08 89     	ld		a, (FileCnt)
 355  6FB6 B7           	or		a
 356  6FB7 CA 14 6F     	jp		z, ReadKeyLoop
 357  6FBA
 358  6FBA 2A 11 89     	ld		hl, (SelFileCache)
 359  6FBD CD B6 7C     	call	CopyFile
 360  6FC0 3A 1B 89     	ld		a, (CopyFileRes)
 361  6FC3 B7           	or		a
 362  6FC4 28 1A        	jr		z, CopyFileOK
 363  6FC6
 364  6FC6 6F           	ld		l, a
 365  6FC7 26 00        	ld		h, 0
 366  6FC9 11 E0 86     	ld		de, MsgErrCode
 367  6FCC CD A8 76     	call	Byte2Txt
 368  6FCF 21 D5 86     	ld		hl, MsgErr
 369  6FD2 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 370  6FD5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371  6FD7 CD 39 80     	call	PrintStrClr
 372  6FDA CD D5 7F     	call	ReadChar
 373  6FDD C3 14 6F     	jp		ReadKeyLoop
 374  6FE0
 375  6FE0              CopyFileOK:
 376  6FE0 06 02        	ld		b, 2
 377  6FE2 CD BD 81     	call	ClearNMsgLines
 378  6FE5              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 379  6FE5 3A 13 89     	ld		a, (CopySelOption)
 380  6FE8 FE 33        	cp		'3'
 381  6FEA CA 14 6F     	jp		z, ReadKeyLoop
 382  6FED 3A 2F 89     	ld		a, (CopyFileDstDrv)
 383  6FF0 3D           	dec		a
 384  6FF1 32 70 7B     	ld		(RWTSDrive), a
 385  6FF4 CD 8B 7B     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 386  6FF7 C3 72 6D     	jp		HCRunInitDisk
 387  6FFA
 388  6FFA              CheckKeyFileInfo:
 389  6FFA FE 20        	cp		' '
 390  6FFC 20 0D        	jr		nz, CheckKeyDriveA
 391  6FFE
 392  6FFE 3A 08 89     	ld		a, (FileCnt)
 393  7001 B7           	or		a
 394  7002 CA 14 6F     	jp		z, ReadKeyLoop
 395  7005
 396  7005 CD 47 76     	call	ReadAllHeaders
 397  7008 C3 14 6F     	jp		ReadKeyLoop
 398  700B
 399  700B              CheckKeyDriveA:
 400  700B FE 31        	cp		'1'
 401  700D 20 05        	jr		nz, CheckKeyDriveB
 402  700F 3E 00        	ld		a, DRIVE_A_CPM
 403  7011 C3 3B 71     	jp		SelectDrive
 404  7014
 405  7014              CheckKeyDriveB:
 406  7014 FE 32        	cp		'2'
 407  7016 20 05        	jr		nz, CheckKeyView
 408  7018 3E 01        	ld		a, DRIVE_B_CPM
 409  701A C3 3B 71     	jp		SelectDrive
 410  701D
 411  701D              CheckKeyView:
 412  701D FE 33        	cp		'3'
 413  701F 20 36        	jr		nz, CheckKeyRename
 414  7021
 415  7021 3A 08 89     	ld		a, (FileCnt)
 416  7024 B7           	or		a
 417  7025 CA 14 6F     	jp		z, ReadKeyLoop
 418  7028
 419  7028
 420  7028 21 D8 88     	ld		hl, MsgViewFileMenu
 421  702B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 422  702E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 423  7030 CD 39 80     	call		PrintStrClr
 424  7033 21 E7 88     	ld		hl, MsgViewFileText
 425  7036 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 426  7039 CD 11 80     	call		PrintStr
 427  703C 21 F0 88     	ld		hl, MsgViewFileHex
 428  703F 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 429  7042 CD 11 80     	call		PrintStr
 430  7045 21 F8 88     	ld		hl, MsgViewFileAuto
 431  7048 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 432  704B CD 11 80     	call		PrintStr
 433  704E CD D5 7F     	call		ReadChar
 434  7051
 435  7051 CD CA 73     	call		ViewFile
 436  7054 C3 DA 6D     	jp		HCRunMain
 437  7057
 438  7057              CheckKeyRename:
 439  7057 FE 36        	cp		'6'
 440  7059 20 6C        	jr		nz, CheckKeyDel
 441  705B
 442  705B 3A 08 89     	ld		a, (FileCnt)
 443  705E B7           	or		a
 444  705F CA 14 6F     	jp		z, ReadKeyLoop
 445  7062
 446  7062 21 D9 87     	ld		hl, MsgNewFileName
 447  7065 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 448  7068 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 449  706A CD 39 80     	call	PrintStrClr
 450  706D
 451  706D 21 A4 87     	ld		hl, MsgClear
 452  7070 11 59 97     	ld		de, FileData
 453  7073 01 0B 00     	ld		bc, NAMELEN
 454  7076 ED B0        	ldir
 455  7078 3E A0        	ld		a, $80 | ' '
 456  707A 12           	ld		(de), a
 457  707B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 458  707E 21 59 97     	ld		hl, FileData
 459  7081 CD 11 80     	call	PrintStr
 460  7084
 461  7084 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 462  7087 01 0B 00     	ld		bc, NAMELEN
 463  708A CD 7B 81     	call	ReadString
 464  708D
 465  708D 11 59 97     	ld		de, FileData
 466  7090 1A           	ld		a, (de)
 467  7091 FE 20        	cp		' '					;If starting with space, input was canceled.
 468  7093 CA BF 70     	jp		z, RenameCanceled
 469  7096
 470  7096              	;Check if new name doesn't exist already. Cancel if so.
 471  7096 21 59 97     	ld		hl, FileData
 472  7099 3A 70 7B     	ld 		a, (RWTSDrive)
 473  709C 3C           	inc		a
 474  709D CD 1C 7C     	call	DoesFileExist
 475  70A0 3C           	inc		a
 476  70A1 28 10        	jr		z, RenameFileNotExist
 477  70A3
 478  70A3 21 7D 88     	ld		hl, MsgFileExists
 479  70A6 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 480  70A9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 481  70AB CD 39 80     	call	PrintStrClr
 482  70AE CD D5 7F     	call	ReadChar
 483  70B1 18 0C        	jr		RenameCanceled
 484  70B3
 485  70B3              RenameFileNotExist:
 486  70B3 11 59 97     	ld		de, FileData
 487  70B6 2A 11 89     	ld		hl, (SelFileCache)
 488  70B9 CD 5F 7C     	call	RenameFile
 489  70BC C3 72 6D     	jp		HCRunInitDisk
 490  70BF
 491  70BF              RenameCanceled:
 492  70BF 06 02        	ld		b, 2
 493  70C1 CD BD 81     	call	ClearNMsgLines
 494  70C4 C3 14 6F     	jp		ReadKeyLoop
 495  70C7
 496  70C7              CheckKeyDel:
 497  70C7 FE 38        	cp		'8'
 498  70C9 20 2E        	jr		nz, CheckKeyAttrib
 499  70CB
 500  70CB 3A 08 89     	ld		a, (FileCnt)
 501  70CE B7           	or		a
 502  70CF CA 14 6F     	jp		z, ReadKeyLoop
 503  70D2
 504  70D2 21 B4 87     	ld		hl, MsgDelete
 505  70D5 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 506  70D8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 507  70DA CD 39 80     	call	PrintStrClr
 508  70DD CD D5 7F     	call	ReadChar
 509  70E0 FE 79        	cp		'y'
 510  70E2 28 08        	jr		z, DoFileDelete
 511  70E4 06 01        	ld		b, 1
 512  70E6 CD BD 81     	call	ClearNMsgLines
 513  70E9 C3 14 6F     	jp		ReadKeyLoop
 514  70EC              DoFileDelete:
 515  70EC 2A 11 89     	ld		hl, (SelFileCache)
 516  70EF 3A 70 7B     	ld 		a, (RWTSDrive)
 517  70F2 3C           	inc		a					;Convert to BASIC drive number: 1,2
 518  70F3 CD 10 7C     	call	DeleteFile
 519  70F6 C3 72 6D     	jp		HCRunInitDisk
 520  70F9
 521  70F9              CheckKeyAttrib:
 522  70F9 FE 37        	cp		'7'
 523  70FB 20 47        	jr		nz, CheckKeyDiskMenu
 524  70FD
 525  70FD 3A 08 89     	ld		a, (FileCnt)
 526  7100 B7           	or		a
 527  7101 CA 14 6F     	jp		z, ReadKeyLoop
 528  7104
 529  7104 21 C1 87     	ld		hl, MsgSetRO
 530  7107 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 531  710A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 532  710C CD 39 80     	call	PrintStrClr
 533  710F CD D5 7F     	call	ReadChar
 534  7112 1E 00        	ld		e, 0
 535  7114 FE 79        	cp		'y'
 536  7116 20 02        	jr		nz, CheckSYS
 537  7118 1E 01        	ld		e, 1
 538  711A
 539  711A              CheckSYS:
 540  711A D5           	push	de
 541  711B 21 CD 87     		ld		hl, MsgSetSYS
 542  711E 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 543  7121 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 544  7123 CD 39 80     		call	PrintStrClr
 545  7126 CD D5 7F     		call	ReadChar
 546  7129 FE 79        		cp		'y'
 547  712B D1           	pop		de
 548  712C 20 04        	jr		nz, AttrChange
 549  712E 3E 02        	ld		a, %10
 550  7130 B3           	or		e
 551  7131 5F           	ld		e, a
 552  7132
 553  7132              AttrChange:
 554  7132 2A 11 89     	ld		hl, (SelFileCache)
 555  7135 CD 35 7C     	call	ChangeFileAttrib
 556  7138 C3 72 6D     	jp		HCRunInitDisk
 557  713B
 558  713B              SelectDrive:
 559  713B 32 70 7B     	ld 		(RWTSDrive), a
 560  713E CD 8B 7B     	call	BDOSSelectDisk
 561  7141              	;call	BDOSInit
 562  7141 C3 72 6D     	jp		HCRunInitDisk
 563  7144
 564  7144              CheckKeyDiskMenu:
 565  7144 FE 39        	cp		'9'
 566  7146 C2 5A 72     	jp		nz, CheckKeyExit
 567  7149
 568  7149 3A 70 7B     	ld		a, (RWTSDrive)
 569  714C C6 41        	add		'A'
 570  714E              	;Update menu messages with current drive.
 571  714E 32 16 88     	ld		(MsgMenuSingleDrv1), a
 572  7151 32 1A 88     	ld		(MsgMenuSingleDrv2), a
 573  7154 32 24 88     	ld		(MsgMenuDualDrv1), a
 574  7157 32 32 88     	ld		(MsgMenuToComDrv), a
 575  715A 32 46 88     	ld		(MsgMenuFromCOMDrv), a
 576  715D              	;Update menu messages with the alternate drive.
 577  715D 3A 70 7B     	ld		a, (RWTSDrive)
 578  7160 3C           	inc		a
 579  7161 EE 03        	xor		%11
 580  7163 C6 40        	add		'A'-1
 581  7165 32 28 88     	ld		(MsgMenuDualDrv2), a
 582  7168
 583  7168 21 E9 87     	ld		hl, MsgMenuDiskCopy
 584  716B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 585  716E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586  7170 CD 39 80     	call	PrintStrClr
 587  7173 21 02 88     	ld		hl, MsgMenuBack
 588  7176 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 589  7179 CD 11 80     	call	PrintStr
 590  717C 21 0E 88     	ld		hl, MsgMenuSingle
 591  717F 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 592  7182 CD 11 80     	call	PrintStr
 593  7185 21 1C 88     	ld		hl, MsgMenuDual
 594  7188 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 595  718B CD 11 80     	call	PrintStr
 596  718E 21 2A 88     	ld		hl, MsgMenuToCOM
 597  7191 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 598  7194 CD 11 80     	call	PrintStr
 599  7197 21 39 88     	ld		hl, MsgMenuFromCOM
 600  719A 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 601  719D CD 11 80     	call	PrintStr
 602  71A0 21 48 88     	ld		hl, MsgMenuFmt1
 603  71A3 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 604  71A6 CD 11 80     	call	PrintStr
 605  71A9 21 54 88     	ld		hl, MsgMenuFmt2
 606  71AC 11 00 15     	ld		de, LST_LINE_MSG + 8 << 8
 607  71AF CD 11 80     	call	PrintStr
 608  71B2
 609  71B2 CD D5 7F     	call	ReadChar
 610  71B5 F5           	push	af
 611  71B6 06 08        		ld		b, 8
 612  71B8 CD BD 81     		call	ClearNMsgLines
 613  71BB F1           	pop		af
 614  71BC 32 13 89     	ld		(CopySelOption), a
 615  71BF
 616  71BF              CheckKeyDiskMenuLoop:
 617  71BF FE 30        	cp		'0'
 618  71C1 CA 57 72     	jp		z, DiskMenuExit
 619  71C4
 620  71C4              	;Single drive copy
 621  71C4 FE 31        	cp		'1'
 622  71C6 20 0B        	jr		nz, CheckDiskMenuDualDrive
 623  71C8 CD AD 78     	call	CopyDisk
 624  71CB 06 02        	ld		b, 2
 625  71CD CD BD 81     	call	ClearNMsgLines
 626  71D0 C3 57 72     	jp		DiskMenuExit
 627  71D3
 628  71D3              	;Dual drive copy
 629  71D3              CheckDiskMenuDualDrive:
 630  71D3 FE 32        	cp		'2'
 631  71D5 20 0A        	jr		nz, CheckDiskMenuToCOM
 632  71D7 CD AD 78     	call	CopyDisk
 633  71DA 06 02        	ld		b, 2
 634  71DC CD BD 81     	call	ClearNMsgLines
 635  71DF 18 76        	jr		DiskMenuExit
 636  71E1
 637  71E1              CheckDiskMenuToCOM:
 638  71E1 FE 33        	cp		'3'
 639  71E3 20 05        	jr		nz, CheckDiskMenuFromCOM
 640  71E5 CD 66 79     	call	CopyDiskToCOM
 641  71E8 18 6D        	jr		DiskMenuExit
 642  71EA
 643  71EA              CheckDiskMenuFromCOM:
 644  71EA FE 34        	cp		'4'
 645  71EC 20 06        	jr		nz, CheckDiskMenuFormat1
 646  71EE CD C2 79     	call	CopyDiskFromCOM
 647  71F1 C3 72 6D     	jp		HCRunInitDisk
 648  71F4
 649  71F4              CheckDiskMenuFormat1:
 650  71F4 FE 35        	cp		'5'
 651  71F6 C2 03 72     	jp		nz, CheckDiskMenuFormat2
 652  71F9
 653  71F9 3E 00        	ld		a, DRIVE_A_CPM
 654  71FB 32 70 7B     	ld		(RWTSDrive), a
 655  71FE 21 4B 88     	ld		hl, MsgMenuFmt1+3
 656  7201 18 0D        	jr		FormatDiskAction
 657  7203
 658  7203              CheckDiskMenuFormat2:
 659  7203 FE 36        	cp		'6'
 660  7205 C2 DA 6D     	jp		nz, HCRunMain
 661  7208
 662  7208 3E 01        	ld		a, DRIVE_B_CPM
 663  720A 32 70 7B     	ld		(RWTSDrive), a
 664  720D 21 57 88     	ld		hl, MsgMenuFmt2+3
 665  7210
 666  7210              FormatDiskAction:
 667  7210 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 668  7213 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 669  7215 CD 39 80     	call	PrintStrClr
 670  7218
 671  7218 21 C8 88     	ld		hl, MsgAreYouSure
 672  721B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 673  721E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 674  7220 CD 39 80     	call	PrintStrClr
 675  7223 CD D5 7F     	call	ReadChar
 676  7226 FE 79        	cp		'y'
 677  7228 C2 DA 6D     	jp		nz, HCRunMain
 678  722B
 679  722B 21 A4 87     	ld		hl, MsgClear
 680  722E 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 681  7231 3E 45        	ld		a, SCR_DEF_CLR
 682  7233 CD 39 80     	call	PrintStrClr
 683  7236
 684  7236 CD DC 77     	call	FormatDisk
 685  7239 B7           	or		a
 686  723A CA 72 6D     	jp		z, HCRunInitDisk
 687  723D
 688  723D              	;Display error for format
 689  723D 6F           	ld		l, a
 690  723E 26 00        	ld		h, 0
 691  7240 11 E0 86     	ld		de, MsgErrCode
 692  7243 CD A8 76     	call	Byte2Txt
 693  7246 21 D5 86     	ld		hl, MsgErr
 694  7249 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 695  724C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 696  724E CD 39 80     	call	PrintStrClr
 697  7251 CD D5 7F     	call	ReadChar
 698  7254 C3 72 6D     	jp		HCRunInitDisk
 699  7257
 700  7257              DiskMenuExit:
 701  7257 C3 14 6F     	jp		ReadKeyLoop
 702  725A
 703  725A              CheckKeyExit:
 704  725A FE 30        	cp		'0'
 705  725C C2 14 6F     	jp		nz, ReadKeyLoop
 706  725F C3 E6 6D     	jp		HCRunEnd
 707  7262              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 708  7262
 709  7262              MoveIt:
 710  7262 CD 05 81     	call 	MoveCursor
 711  7265 C3 14 6F     	jp		ReadKeyLoop
 712  7268
 713  7268              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 714  7268
 715  7268
 716  7268              DisplayFilename:
 717  7268 06 0B        	LD		B, NAMELEN
 718  726A              DispLoop:
 719  726A 1A           	LD		A, (DE)
 720  726B
 721  726B              	;clear bit 7
 722  726B CB BF        	RES 	7, A
 723  726D 32 81 5C     	LD		(CODE), A
 724  7270
 725  7270 13           	INC		DE
 726  7271 D5           	PUSH	DE
 727  7272 C5           	PUSH	BC
 728  7273 CD 3D 81     		CALL	PrintChar
 729  7276 C1           	POP		BC
 730  7277 D1           	POP 	DE
 731  7278
 732  7278 21 B0 5C     	LD		HL, COL
 733  727B 34           	INC		(HL)
 734  727C 10 EC        	DJNZ	DispLoop
 735  727E              	;now a name is displayed
 736  727E
 737  727E              	;check bounds
 738  727E 3A B1 5C     	LD		A, (LINE)
 739  7281 3C           	INC		A
 740  7282 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 741  7284 38 0A        	JR		C, LineOK
 742  7286
 743  7286              	;set names column to the next one
 744  7286 3A 09 89     	LD		A, (NameCol)
 745  7289 C6 0C        	ADD		NAMELEN + 1
 746  728B 32 09 89     	LD		(NameCol), A
 747  728E
 748  728E 3E 01        	LD		A, LST_FIRST_LINE
 749  7290              LineOK:
 750  7290 32 B1 5C     	LD		(LINE), A
 751  7293
 752  7293 3A 09 89     	LD		A, (NameCol)
 753  7296 32 B0 5C     	LD		(COL), A
 754  7299
 755  7299 C9           	RET
 756  729A
 757  729A
 758  729A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759  729A
 760  729A              DisplayFilenames:
 761  729A 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 762  729D ED 53 B0 5C  	ld		(LineCol), de
 763  72A1
 764  72A1 11 3B 89     	ld		de, FileCache
 765  72A4 3A 08 89     	ld		a, (FileCnt)
 766  72A7 B7           	or		a
 767  72A8 C8           	ret		z
 768  72A9
 769  72A9 47           	ld		b,	a
 770  72AA
 771  72AA              DisplayFilenamesLoop:
 772  72AA C5           	push	bc
 773  72AB D5           		push	de
 774  72AC CD 68 72     			call	DisplayFilename
 775  72AF D1           		pop		de
 776  72B0 EB           		ex		de, hl
 777  72B1 01 19 00     		ld		bc, CACHE_SZ
 778  72B4 09           		add		hl, bc
 779  72B5 EB           		ex		de, hl
 780  72B6 C1           	pop		bc
 781  72B7 10 F1        	djnz	DisplayFilenamesLoop
 782  72B9
 783  72B9 C9           	ret
 784  72BA
 785  72BA
 786  72BA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 787  72BA              ;Selects only valid filenames (not deleted and only from first extension)
 788  72BA              GetFileNames:
 789  72BA DD 21 59 97  	ld		ix, TrackBuf
 790  72BE 11 3B 89     	ld		de, FileCache
 791  72C1 06 80        	ld		b, MAX_EXT_CNT
 792  72C3 AF           	xor		a
 793  72C4 32 08 89     	ld		(FileCnt), a
 794  72C7 21 0D 89     	ld		hl, AUCntUsed
 795  72CA 77           	ld		(hl), a
 796  72CB 23           	inc		hl
 797  72CC 77           	ld		(hl), a
 798  72CD
 799  72CD              StoreFilenamesLoop:
 800  72CD AF           	xor a
 801  72CE DD BE 00     	cp (ix + EXT_DEL_FLAG)
 802  72D1 C2 41 73     	jp nz, NextExt
 803  72D4
 804  72D4              	;count AU
 805  72D4 D9           	exx
 806  72D5 E5           	push hl
 807  72D6 CD 0B 78     		call CheckExtAlloc
 808  72D9 EB           		ex de, hl			;save first AU no.
 809  72DA
 810  72DA              		;store disk alocated AU count
 811  72DA 2A 0D 89     		ld hl, (AUCntUsed)
 812  72DD 48           		ld c, b
 813  72DE 06 00        		ld b, 0
 814  72E0 09           		add hl, bc
 815  72E1 22 0D 89     		ld (AUCntUsed), hl
 816  72E4 E1           	pop hl
 817  72E5 D9           	exx
 818  72E6
 819  72E6 AF           	xor	a
 820  72E7 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 821  72EA 20 2E        	jr nz, FindExt
 822  72EC
 823  72EC DD E5        	push ix
 824  72EE E1           	pop hl
 825  72EF 23           	inc hl					;skip del flag
 826  72F0
 827  72F0 C5           	push bc
 828  72F1 ~            		/*
 829  72F1 ~            		push de
 830  72F1 ~            			push hl
 831  72F1 ~            				ex de, hl
 832  72F1 ~            				call DisplayFilename
 833  72F1 ~            			pop hl
 834  72F1 ~            		pop de
 835  72F1 ~            		*/
 836  72F1 01 0B 00     		ld bc, NAMELEN
 837  72F4 ED B0        		ldir				;save file name
 838  72F6
 839  72F6 D9           		exx
 840  72F7 D5           		push 	de			;de = first AU
 841  72F8 D9           		exx
 842  72F9 E1           		pop		hl
 843  72FA EB           		ex		de, hl
 844  72FB 73           		ld		(hl), e
 845  72FC 23           		inc		hl
 846  72FD 72           		ld		(hl), d		;save first AU
 847  72FE
 848  72FE 23           		inc		hl
 849  72FF
 850  72FF D9           		exx					;save AU cnt for file
 851  7300 C5           		push	bc
 852  7301 D9           		exx
 853  7302 C1           		pop		bc
 854  7303 71           		ld		(hl), c
 855  7304 23           		inc		hl
 856  7305 70           		ld		(hl), b
 857  7306 23           		inc		hl
 858  7307
 859  7307              		;xor		a			;make flag 0 to signal that header is not read yet
 860  7307              		;ld		(hl), a
 861  7307
 862  7307 01 0A 00     		ld		bc, HDR_SZ + 1
 863  730A 09           		add		hl, bc
 864  730B
 865  730B EB           		ex		de, hl
 866  730C C1           	pop bc
 867  730D
 868  730D
 869  730D 3A 08 89     	ld 		a, (FileCnt)			;inc file counter
 870  7310 3C           	inc		a
 871  7311 32 08 89     	ld 		(FileCnt), a
 872  7314 FE 54        	cp		LST_MAX_FILES
 873  7316 38 29        	jr		c, NextExt
 874  7318 18 34        	jr		GetFileNamesEnd
 875  731A
 876  731A
 877  731A              FindExt:					;BC' = AU cnt for this ext
 878  731A C5           	push	bc
 879  731B D5           		push 	de
 880  731C DD E5        			push	ix
 881  731E D1           			pop		de
 882  731F 13           			inc		de				;DE = name to find
 883  7320
 884  7320 21 3B 89     			ld		hl, FileCache
 885  7323 3A 08 89     			ld		a, (FileCnt)
 886  7326 4F           			ld		c, a
 887  7327 CD AD 7A     			call	FindCache
 888  732A 20 13        			jr		nz, FindExtEnd
 889  732C
 890  732C 01 0D 00     			ld		bc, CACHE_AU_CNT
 891  732F 09           			add		hl, bc
 892  7330 D9           			exx
 893  7331 C5           			push	bc
 894  7332 D9           			exx
 895  7333 C1           			pop		bc
 896  7334
 897  7334 5E           			ld		e, (hl)		;DE = Current AU CNT for file
 898  7335 23           			inc		hl
 899  7336 56           			ld		d, (hl)
 900  7337 2B           			dec		hl
 901  7338 EB           			ex		de, hl
 902  7339 09           			add		hl, bc
 903  733A EB           			ex		de, hl
 904  733B 73           			ld		(hl), e
 905  733C 23           			inc		hl
 906  733D 72           			ld		(hl), d
 907  733E 2B           			dec		hl
 908  733F              FindExtEnd:
 909  733F D1           		pop		de
 910  7340 C1           	pop		bc
 911  7341
 912  7341              NextExt:
 913  7341 C5           	push bc
 914  7342 01 20 00     		ld bc, EXT_SZ
 915  7345 DD 09        		add ix, bc
 916  7347 C1           	pop	bc
 917  7348
 918  7348 05           	dec	b
 919  7349 78           	ld	a, b
 920  734A B7           	or	a
 921  734B C2 CD 72     	jp	nz, StoreFilenamesLoop
 922  734E              GetFileNamesEnd:
 923  734E C9           	ret
 924  734F
 925  734F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926  734F
 927  734F              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 928  734F              ;IN: HL = file name
 929  734F              HandleFile:
 930  734F              	;Make HL point to the selected file
 931  734F DD 2A 11 89  	ld		ix, (SelFileCache)
 932  7353 DD E5        	push	ix
 933  7355 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 934  7358 B7           		or		a
 935  7359 CC BE 7A     		call	z, ReadFileHeader
 936  735C
 937  735C DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 938  735F FE 00        		cp		PROG_TYPE
 939  7361 28 56        		jr		z, HandleFileProg
 940  7363
 941  7363 FE 03        		cp		BYTE_TYPE
 942  7365 20 62        		jr		nz, HandleFileText
 943  7367
 944  7367 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)		;get length
 945  736A DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 946  736D 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 947  7370 19           		add		hl, de
 948  7371 7C           		ld		a, h
 949  7372 B5           		or		l
 950  7373 28 26        		jr		z, HandleFileSCR
 951  7375
 952  7375
 953  7375              HandleFileCODE:
 954  7375 21 02 87     		ld		hl, MsgLoadingCODE
 955  7378 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 956  737B 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 957  737D CD 39 80     		call	PrintStrClr
 958  7380
 959  7380              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 960  7380 21 35 7A     		ld		hl, IF1FileLoad
 961  7383 11 00 5B     		ld		de, PRN_BUF
 962  7386 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 963  7389 ED B0        		ldir
 964  738B              		;ld		a, $C9
 965  738B              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 966  738B
 967  738B E1           	pop		hl
 968  738C ED 5B 5C 97  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 969  7390 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 970  7391 C1           	pop		bc						;2nd, 3rd call for error handler
 971  7392 C1           	pop		bc
 972  7393 ED 43 3D 5C  	ld		(ERRSP), bc
 973  7397 D5           	push	de						;push CODE address to return to = start of CODE block
 974  7398 C3 00 5B     	jp		PRN_BUF
 975  739B
 976  739B
 977  739B
 978  739B
 979  739B              HandleFileSCR:
 980  739B 21 F3 86     		ld		hl, MsgLoadingSCR
 981  739E 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 982  73A1 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 983  73A3 CD 39 80     		call	PrintStrClr
 984  73A6
 985  73A6 E1           	pop		hl
 986  73A7
 987  73A7              	IFDEF _REAL_HW_
 988  73A7              		;Load to alternate SCREEN$ memory
 989  73A7 11 00 C0     		ld		de, HC_VID_BANK1
 990  73AA CD 35 7A     		call	IF1FileLoad
 991  73AD
 992  73AD              		;Set display to alternate SCREEN$ memory
 993  73AD 3E 08        		ld		a, HC_CFG_VID_C000
 994  73AF D3 7E        		out 	(HC_CFG_PORT), a
 995  73B1 CD D5 7F     		call	ReadChar
 996  73B4
 997  73B4              		;Set back to regular SCREEN$ memory
 998  73B4 3E 00        		ld		a, HC_CFG_VID_4000
 999  73B6 D3 7E        		out 	(HC_CFG_PORT), a
1000  73B8              	ELSE
1001  73B8 ~            		ld		de, HC_VID_BANK0
1002  73B8 ~            		call	IF1FileLoad
1003  73B8 ~            		call	ReadChar
1004  73B8              	ENDIF
1005  73B8
1006  73B8 C9           	ret
1007  73B9
1008  73B9              HandleFileProg:
1009  73B9 21 E4 86     		ld		hl, MsgLoadingPrg
1010  73BC 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
1011  73BF 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
1012  73C1 CD 39 80     		call	PrintStrClr
1013  73C4 E1           	pop		hl
1014  73C5 CD 25 7B     	call	LoadProgram
1015  73C8 C9           	ret
1016  73C9
1017  73C9
1018  73C9              HandleFileText:
1019  73C9 E1           	pop		hl
1020  73CA
1021  73CA
1022  73CA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1023  73CA
1024  73CA              ;Use constants for loading in RAM only as much as we can in order to fit both the binary and the text representation.
1025  73CA              ViewFileConvertRatioText	EQU	1				;Text data is stored as is, 1:1, byte to byte.
1026  73CA              ViewFileConvertRatioBASIC	EQU	4				;BASIC tokens are expanded to text as 1 byte to 3 chars on average? To test!
1027  73CA              ViewFileConvertRatioHEX		EQU	5				;1 byte expands to 4 bytes when printed as hex. So RAM stores 1+4 bytes for each byte.
1028  73CA              ViewFileConvertRatioASM		EQU	3				;Disassembly is expanded as 1:3? To test!
1029  73CA
1030  73CA              ;Auto viewing mode will show content bases on file type: no type - as text, programs as BASIC, rest - as hex
1031  73CA              ;Skip header, if exists.
1032  73CA
1033  73CA              ViewFile:
1034  73CA 21 00 00     	ld	hl, 0
1035  73CD 22 1E 89     	ld	(FilePosRead), hl
1036  73D0 32 14 89     	ld	(ViewSelOption), a
1037  73D3 AF           	xor	a
1038  73D4 32 16 89     	ld	(ViewFilePart), a
1039  73D7 DD 21 59 FA  	ld	ix, FileBlocksIdx
1040  73DB 21 00 00     	ld	hl, 0
1041  73DE DD 75 00     	ld	(ix), l
1042  73E1 DD 74 01     	ld	(ix+1), h
1043  73E4 DD 22 17 89  	ld	(FileBlocksIdxPos), ix
1044  73E8
1045  73E8              	;Read file header if not yet read.
1046  73E8 DD 2A 11 89  	ld		ix, (SelFileCache)
1047  73EC DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
1048  73EF B7           	or		a
1049  73F0 CC BE 7A     	call		z, ReadFileHeader
1050  73F3
1051  73F3              ViewFileNextBlock:
1052  73F3 3A 14 89     	ld		a, (ViewSelOption)
1053  73F6
1054  73F6 FE 31        	cp		'1'
1055  73F8 28 13        	jr		z, ViewFileAsText
1056  73FA
1057  73FA FE 32        	cp		'2'
1058  73FC 28 17        	jr		z, ViewFileAsHex
1059  73FE
1060  73FE              ViewFileAuto:
1061  73FE              	;Decide how to display file, if auto mode.
1062  73FE DD 2A 11 89  	ld		ix, (SelFileCache)
1063  7402 DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1064  7405 FE 00        	cp		PROG_TYPE
1065  7407 28 22        	jr		z, ViewFileAsBASIC
1066  7409
1067  7409 FE 03        	cp		BYTE_TYPE
1068  740B 28 08        	jr		z, ViewFileAsHex
1069  740D
1070  740D              ViewFileAsText:
1071  740D              	;If text file, load as much as possible to RAM.
1072  740D 06 53        	ld		b, MAX_SECT_BUF * ViewFileConvertRatioText
1073  740F CD A7 74     	call		ReadFileForViewing
1074  7412 C3 4F 74     	jp		ViewFileText
1075  7415
1076  7415              ViewFileAsHex:
1077  7415 06 10        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioHEX
1078  7417 CD A7 74     	call		ReadFileForViewing
1079  741A 11 F2 A7     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioHEX
1080  741D D5           	push		de
1081  741E CD 5F 77     		call	Bin2HexStr
1082  7421 E1           	pop		hl
1083  7422              	;Determine lenght of hex print buffer.
1084  7422 EB           	ex		de, hl
1085  7423 B7           	or		a
1086  7424 ED 52        	sbc		hl, de
1087  7426 44           	ld		b, h
1088  7427 4D           	ld		c, l
1089  7428 EB           	ex		de, hl
1090  7429 18 24        	jr		ViewFileText
1091  742B
1092  742B
1093  742B              ViewFileAsBASIC:
1094  742B 06 14        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioBASIC		;Load half of available RAM with program bytecode, leave half for decoded text.
1095  742D CD A7 74     	call		ReadFileForViewing
1096  7430              	;Read program length from header. Skip file header.
1097  7430 01 09 00     	ld		bc, HDR_SZ
1098  7433 09           	add		hl, bc
1099  7434 DD 2A 11 89  	ld		ix, (SelFileCache)
1100  7438 DD 4E 15     	ld		c, (ix + CACHE_HDR + HDR_PLEN)
1101  743B DD 46 16     	ld		b, (ix + CACHE_HDR + HDR_PLEN + 1)
1102  743E 11 19 AC     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioBASIC		;Store text of program after read block.
1103  7441 D5           	push		de
1104  7442 CD 4D 85     		call	BASIC2TXT
1105  7445 D1           	pop		de
1106  7446              	;Get decoded text length
1107  7446 2A 14 86     	ld		hl, (DestinationAddr)
1108  7449 B7           	or		a
1109  744A ED 52        	sbc		hl, de
1110  744C 44           	ld		b, h
1111  744D 4D           	ld		c, l
1112  744E EB           	ex		de, hl
1113  744F
1114  744F              ViewFileText:
1115  744F E5           	push	hl
1116  7450 C5           	push	bc
1117  7451 CD F1 7F     		call	ClrScr
1118  7454 C1           	pop	bc
1119  7455 E1           	pop	hl
1120  7456 E5           	push	hl
1121  7457 CD 58 82     		call	TextViewer
1122  745A E1           	pop	hl
1123  745B
1124  745B              ViewFileTextLoop:
1125  745B 3A 08 5C     	ld	a, (LAST_K)
1126  745E
1127  745E FE 30        	cp	'0'
1128  7460 C8           	ret	z
1129  7461
1130  7461 FE 0B        	cp	KEY_UP
1131  7463 20 22        	jr	nz, ViewFileTextLoopDown
1132  7465
1133  7465 3A 16 89     	ld	a, (ViewFilePart)
1134  7468 B7           	or	a
1135  7469 28 F0        	jr	z, ViewFileTextLoop
1136  746B
1137  746B 3D           	dec	a
1138  746C 32 16 89     	ld	(ViewFilePart), a
1139  746F
1140  746F              	;Go back 1 block index.
1141  746F DD 2A 17 89  	ld	ix, (FileBlocksIdxPos)
1142  7473 DD 2B        	dec	ix
1143  7475 DD 2B        	dec	ix
1144  7477 DD 6E 00     	ld	l, (ix)
1145  747A DD 66 01     	ld	h, (ix+1)
1146  747D 22 1E 89     	ld	(FilePosRead), hl
1147  7480 DD 22 17 89  	ld	(FileBlocksIdxPos), ix
1148  7484 C3 F3 73     	jp	ViewFileNextBlock
1149  7487
1150  7487
1151  7487              ViewFileTextLoopDown:
1152  7487 FE 0A        	cp	KEY_DOWN
1153  7489 20 D0        	jr	nz, ViewFileTextLoop
1154  748B
1155  748B 21 16 89     	ld	hl, ViewFilePart
1156  748E 34           	inc	(hl)
1157  748F
1158  748F              	;Save file index for when scrolling back.
1159  748F DD 2A 17 89  	ld	ix, (FileBlocksIdxPos)
1160  7493 DD 23        	inc	ix
1161  7495 DD 23        	inc	ix
1162  7497 2A 1E 89     	ld	hl, (FilePosRead)
1163  749A DD 75 00     	ld	(ix), l
1164  749D DD 74 01     	ld	(ix+1), h
1165  74A0 DD 22 17 89  	ld	(FileBlocksIdxPos), ix
1166  74A4 C3 F3 73     	jp	ViewFileNextBlock
1167  74A7
1168  74A7
1169  74A7              ;Reads file section, as much as it fits in RAM for the type of output.
1170  74A7              ;Returns HL=start address and BC=length read.
1171  74A7              ;IN: B = how many sectors to read.
1172  74A7              ReadFileForViewing:
1173  74A7 2A 11 89     	ld		hl, (SelFileCache)
1174  74AA 78           	ld		a, b
1175  74AB 32 15 89     	ld		(ViewSectMax), a
1176  74AE 3A 70 7B     	ld 		a, (RWTSDrive)
1177  74B1 3C           	inc		a
1178  74B2 CD 23 7F     	call		ReadFileSection		;DE = last address read
1179  74B5
1180  74B5              	;Calculate size of read buffer.
1181  74B5 D5           	push		de
1182  74B6 21 59 97     		ld		hl, FileData
1183  74B9 EB           		ex		de, hl
1184  74BA B7           		or		a
1185  74BB ED 52        		sbc		hl, de
1186  74BD 44           		ld		b, h
1187  74BE 4D           		ld		c, l
1188  74BF D1           	pop		de
1189  74C0
1190  74C0              	;Check file type from header, to see if header exists or not.
1191  74C0 DD 2A 11 89  	ld		ix, (SelFileCache)
1192  74C4 DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1193  74C7 FE 04        	cp		TEXT_TYPE
1194  74C9 38 12        	jr		c, ReadFileForViewingNotText
1195  74CB
1196  74CB              	;Find EOF for text files and ajust lenght.
1197  74CB 21 59 97     	ld		hl, FileData
1198  74CE 50           	ld		d, b
1199  74CF 59           	ld		e, c
1200  74D0 3E 1A        	ld		a, CHAR_EOF
1201  74D2 ED B1        	cpir
1202  74D4 20 01        	jr		nz, ReadFileForViewingNotFoundEOF
1203  74D6 03           	inc		bc
1204  74D7              ReadFileForViewingNotFoundEOF:
1205  74D7 B7           	or		a
1206  74D8 EB           	ex		hl, de
1207  74D9 ED 42        	sbc		hl, bc
1208  74DB 44           	ld		b, h
1209  74DC 4D           	ld		c, l
1210  74DD
1211  74DD              ReadFileForViewingNotText:
1212  74DD 21 59 97     	ld		hl, FileData
1213  74E0 C9           	ret
1214  74E1
1215  74E1
1216  74E1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217  74E1
1218  74E1
1219  74E1              DisplayFileInfo:
1220  74E1 2A 11 89     	ld		hl, (SelFileCache)
1221  74E4 E5           	push	hl
1222  74E5              		;disk size - at least 2KB ==1  AU
1223  74E5 01 0D 00     		ld		bc, CACHE_AU_CNT
1224  74E8 09           		add		hl, bc
1225  74E9 5E           		ld		e, (hl)
1226  74EA 23           		inc		hl
1227  74EB 56           		ld		d, (hl)
1228  74EC 2B           		dec		hl
1229  74ED EB           		ex		de, hl
1230  74EE              		;*2, since one block (AU) is 2KB.
1231  74EE CB 15        		rl	l
1232  74F0 CB 14        		rl	h
1233  74F2
1234  74F2 11 1B 87     		ld		de, MsgFileSzDskN
1235  74F5 CD 9D 76     		call	Word2Txt
1236  74F8 21 12 87     		ld		hl, MsgFileSzDsk
1237  74FB 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1238  74FE CD 11 80     		call	PrintStr
1239  7501 E1           	pop		hl
1240  7502 E5           	push	hl
1241  7503              		;attributes
1242  7503 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1243  7506 09           		add		hl, bc
1244  7507 EB           		ex		de, hl
1245  7508 21 2B 87     		ld		hl, MsgFileAttrN
1246  750B 1A           		ld		a, (de)
1247  750C E6 80        		and		%10000000
1248  750E 28 10        		jr		z, NotRO
1249  7510
1250  7510 01 52 2F     		ld		bc, '/R'
1251  7513 71           		ld		(hl), c
1252  7514 23           		inc		hl
1253  7515 70           		ld		(hl), b
1254  7516 23           		inc		hl
1255  7517 01 4F 2C     		ld		bc, ',O'
1256  751A 71           		ld		(hl), c
1257  751B 23           		inc		hl
1258  751C 70           		ld		(hl), b
1259  751D 23           		inc		hl
1260  751E 18 0E        		jr		CheckSys
1261  7520              NotRO:
1262  7520 01 2D 2D     		ld		bc, '--'
1263  7523 71           		ld		(hl), c
1264  7524 23           		inc		hl
1265  7525 70           		ld		(hl), b
1266  7526 23           		inc		hl
1267  7527 01 2D 2C     		ld		bc, ',-'
1268  752A 71           		ld		(hl), c
1269  752B 23           		inc		hl
1270  752C 70           		ld		(hl), b
1271  752D 23           		inc		hl
1272  752E
1273  752E              CheckSys:
1274  752E 13           		inc		de
1275  752F 1A           		ld		a, (de)
1276  7530 E6 80        		and		%10000000
1277  7532 28 0C        		jr		z, NotSYS
1278  7534
1279  7534 01 48 49     		ld		bc, 'IH'
1280  7537 71           		ld		(hl), c
1281  7538 23           		inc		hl
1282  7539 70           		ld		(hl), b
1283  753A 23           		inc		hl
1284  753B 3E C4        		ld		a, 'D' + $80
1285  753D 77           		ld		(hl), a
1286  753E 18 0A        		jr		AttrEnd
1287  7540              NotSYS:
1288  7540 01 2D 2D     		ld		bc, '--'
1289  7543 71           		ld		(hl), c
1290  7544 23           		inc		hl
1291  7545 70           		ld		(hl), b
1292  7546 23           		inc		hl
1293  7547 3E AD        		ld		a, '-' + $80
1294  7549 77           		ld		(hl), a
1295  754A              AttrEnd:
1296  754A 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1297  754D 21 22 87     		ld		hl, MsgFileAttr
1298  7550 CD 11 80     		call	PrintStr
1299  7553 DD E1        	pop		ix
1300  7555 DD E5        	push	ix
1301  7557 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1302  755A B7           		or		a
1303  755B CA F8 75             jp		z, HeadNotRead
1304  755E
1305  755E DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1306  7561 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1307  7564 CA F8 75             jp		z, HeadNotRead
1308  7567
1309  7567 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1310  756A FE 00        		cp		PROG_TYPE
1311  756C 20 0B        		jr		nz, CheckNoArr
1312  756E
1313  756E 21 45 87     		ld		hl, MsgFileTypePrg
1314  7571 11 3B 87     		ld		de, MsgFileTypeN
1315  7574 CD 41 76     		call	MoveMsg
1316  7577 18 4F        		jr		PrepFileLen
1317  7579
1318  7579              CheckNoArr:
1319  7579 FE 01        		cp		NUMB_TYPE
1320  757B 20 0B        		jr		nz, CheckChrArr
1321  757D
1322  757D 21 61 87     		ld		hl, MsgFileTypeNoA
1323  7580 11 3B 87     		ld		de, MsgFileTypeN
1324  7583 CD 41 76     		call	MoveMsg
1325  7586 18 40        		jr		PrepFileLen
1326  7588
1327  7588              CheckChrArr:
1328  7588 FE 02        		cp		CHAR_TYPE
1329  758A 20 0B        		jr		nz, CheckByte
1330  758C
1331  758C 21 5A 87     		ld		hl, MsgFileTypeChrA
1332  758F 11 3B 87     		ld		de, MsgFileTypeN
1333  7592 CD 41 76     		call	MoveMsg
1334  7595 18 31        		jr		PrepFileLen
1335  7597
1336  7597              CheckByte:
1337  7597 FE 03        		cp		BYTE_TYPE
1338  7599 20 24        		jr		nz, CheckText
1339  759B
1340  759B DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1341  759E DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1342  75A1 01 00 E5     		ld		bc, -SCR_LEN
1343  75A4 09           		add		hl, bc
1344  75A5 7C           		ld		a, h
1345  75A6 B5           		or		l
1346  75A7 20 0B        		jr		nz, NotScr
1347  75A9
1348  75A9 21 53 87     		ld		hl, MsgFileTypeSCR
1349  75AC 11 3B 87     		ld		de, MsgFileTypeN
1350  75AF CD 41 76     		call	MoveMsg
1351  75B2 18 14        		jr		PrepFileLen
1352  75B4              NotScr:
1353  75B4 21 4C 87     		ld		hl, MsgFileTypeByte
1354  75B7 11 3B 87     		ld		de, MsgFileTypeN
1355  75BA CD 41 76     		call	MoveMsg
1356  75BD 18 09        		jr		PrepFileLen
1357  75BF
1358  75BF              CheckText:
1359  75BF 21 68 87     		ld		hl, MsgFileTypeText
1360  75C2 11 3B 87     		ld		de, MsgFileTypeN
1361  75C5 CD 41 76     		call	MoveMsg
1362  75C8
1363  75C8              PrepFileLen:
1364  75C8              		;File len
1365  75C8 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1366  75CB DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1367  75CE              PrepFileLenText:
1368  75CE 11 7F 87     		ld		de, MsgFileLenN
1369  75D1 CD 9D 76     		call	Word2Txt
1370  75D4 26 C2        		ld		h, 'B' | $80
1371  75D6 2E 20        		ld		l, ' '
1372  75D8 22 84 87     		ld		(MsgFileLenN + 5), hl
1373  75DB
1374  75DB DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1375  75DE FE 00        		cp		PROG_TYPE
1376  75E0 28 06        		jr		z, PrintProgStart
1377  75E2
1378  75E2 FE 03        		cp		BYTE_TYPE
1379  75E4 28 0A        		jr		z, PrintByteStart
1380  75E6
1381  75E6 18 22        		jr		PrintStartNotRead
1382  75E8
1383  75E8              PrintProgStart:
1384  75E8 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1385  75EB DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1386  75EE 18 25        		jr		PrintStart
1387  75F0
1388  75F0              PrintByteStart:
1389  75F0 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1390  75F3 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1391  75F6 18 1D        		jr		PrintStart
1392  75F8
1393  75F8              HeadNotRead:
1394  75F8 21 6F 87             ld        hl, MsgNA
1395  75FB 11 3B 87             ld        de, MsgFileTypeN
1396  75FE CD 41 76             call    MoveMsg
1397  7601
1398  7601 21 6F 87     		ld		hl, MsgNA
1399  7604 11 7F 87     		ld		de, MsgFileLenN
1400  7607 CD 41 76     		call	MoveMsg
1401  760A
1402  760A              PrintStartNotRead:
1403  760A 21 6F 87     		ld		hl, MsgNA
1404  760D 11 8F 87     		ld		de, MsgFileStartN
1405  7610 CD 41 76     		call	MoveMsg
1406  7613 18 0E        		jr		PrintStartStr
1407  7615
1408  7615              PrintStart:
1409  7615 1E 20        	ld		e, ' '
1410  7617 16 A0        	ld		d, ' ' | $80
1411  7619 ED 53 94 87  	ld		(MsgFileStartN + 5), de
1412  761D 11 8F 87     	ld		de, MsgFileStartN
1413  7620 CD 9D 76     	call	Word2Txt
1414  7623              PrintStartStr:
1415  7623 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1416  7626 21 86 87     	ld		hl, MsgFileStart
1417  7629 CD 11 80     	call	PrintStr
1418  762C
1419  762C DD E1        	pop		ix
1420  762E 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1421  7631 21 32 87     	ld		hl, MsgFileType
1422  7634 CD 11 80     	call	PrintStr
1423  7637
1424  7637 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1425  763A 21 76 87     	ld		hl, MsgFileLen
1426  763D CD 11 80     	call	PrintStr
1427  7640
1428  7640 C9           	ret
1429  7641
1430  7641              MoveMsg:
1431  7641 01 07 00     	ld		bc, 7
1432  7644 ED B0        	ldir
1433  7646 C9           	ret
1434  7647
1435  7647              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1436  7647
1437  7647              ReadAllHeaders:
1438  7647 21 96 87     	ld		hl, MsgReadingExt
1439  764A 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1440  764D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1441  764F CD 39 80     	call	PrintStrClr
1442  7652
1443  7652 CD 03 6F     	call	CalcFileCache
1444  7655
1445  7655 3A 0A 89     	ld		a, (SelFile)
1446  7658 47           	ld		b, a
1447  7659 3A 08 89     	ld		a, (FileCnt)
1448  765C 90           	sub		b
1449  765D B7           	or		a
1450  765E C8           	ret		z
1451  765F
1452  765F 47           	ld		b, a
1453  7660
1454  7660 DD 2A 11 89  	ld		ix, (SelFileCache)
1455  7664              NextFile:
1456  7664 C5           	push	bc
1457  7665 CD BE 7A     		call	ReadFileHeader
1458  7668 01 19 00     		ld		bc, CACHE_SZ
1459  766B DD 09        		add		ix, bc
1460  766D DD E5        		push	ix
1461  766F CD 03 6F     			call	CalcFileCache
1462  7672 CD E1 74     			call	DisplayFileInfo
1463  7675 DD E1        		pop		ix
1464  7677
1465  7677 CD D8 7F     		call	KbdHit
1466  767A 38 03        		jr		c, AKey
1467  767C C1           	pop		bc
1468  767D 18 15        	jr		ReadAllHeadersEnd
1469  767F
1470  767F              AKey:
1471  767F 3A 0A 89     		ld		a, (SelFile)
1472  7682 3C           		inc		a
1473  7683 47           		ld		b, a
1474  7684 3A 08 89     		ld		a, (FileCnt)
1475  7687 B8           		cp		b
1476  7688 28 10        		jr		z, DontInc
1477  768A 78           		ld		a, b
1478  768B 32 0A 89     		ld		(SelFile), a
1479  768E CD 05 81     		call	MoveCursor
1480  7691 C1           	pop		bc
1481  7692 10 D0        	djnz	NextFile
1482  7694
1483  7694              ReadAllHeadersEnd:
1484  7694 06 01        	ld		b, 1
1485  7696 CD BD 81     	call	ClearNMsgLines
1486  7699 C9           	ret
1487  769A
1488  769A              DontInc:
1489  769A C1           	pop		bc
1490  769B 18 F7        	jr		ReadAllHeadersEnd
1491  769D
1492  769D
1493  769D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1494  769D
1495  769D              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 769D              	ifndef	_HCCFG_
   2+ 769D              	define	_HCCFG_
   3+ 769D
   4+ 769D              ;HC specific code, for configuration
   5+ 769D
   6+ 769D              HC_CFG_PORT			EQU	$7E
   7+ 769D              HC_FLOPPY_PORT		EQU 7
   8+ 769D
   9+ 769D              ;BASIC/CPM ROM selection
  10+ 769D              HC_CFG_ROM_BAS		EQU	%0
  11+ 769D              HC_CFG_ROM_CPM		EQU	%1
  12+ 769D
  13+ 769D              ;Address for ROM paging: 0 or $E000
  14+ 769D              HC_CFG_ROM_0000		EQU %00
  15+ 769D              HC_CFG_ROM_E000		EQU %10
  16+ 769D
  17+ 769D              ;Cfg. port Enable/Disable
  18+ 769D              HC_CFG_PORT_DIS		EQU %000
  19+ 769D              HC_CFG_PORT_EN		EQU	%100
  20+ 769D
  21+ 769D              ;Video memory bank: $4000 or $C000
  22+ 769D              HC_CFG_VID_4000		EQU	%0000
  23+ 769D              HC_CFG_VID_C000		EQU	%1000
  24+ 769D
  25+ 769D
  26+ 769D              ;Standar BASIC config
  27+ 769D              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 769D              ;Standar CP/M config
  29+ 769D              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 769D
  31+ 769D
  32+ 769D              HC_VID_BANK0		EQU	$4000
  33+ 769D              HC_VID_BANK1		EQU	$C000
  34+ 769D
  35+ 769D              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 769D              ;Info from Rares Atodiresei.
  37+ 769D              IsDrive2_80Tracks:
  38+ 769D              	IFUSED
  39+ 769D ~            	in	a, (HC_FLOPPY_PORT)
  40+ 769D ~            	and %10
  41+ 769D ~            	ret
  42+ 769D              	ENDIF
  43+ 769D
  44+ 769D              	endif
# file closed: hccfg.asm
1496  769D              	include "if1.asm"
# file opened: if1.asm
   1+ 769D              ;HC IF1 routines and constants
   2+ 769D
   3+ 769D              ;IF1 routines error codes, also returned by BASIC commands
   4+ 769D              ;12 = Writing to a 'read' file
   5+ 769D              ;13 = Reading a 'write' file
   6+ 769D              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 769D              ;15 = Disk full (disk or catalog full)
   8+ 769D              ;16 = Disk error (hardware error)
   9+ 769D              ;17 = File not found
  10+ 769D              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 769D              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 769D
  13+ 769D              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 769D              ;00h = OK
  15+ 769D              ;08h = cannot format disk
  16+ 769D              ;10h = disk protected (read-only?)
  17+ 769D              ;20h = volume error
  18+ 769D              ;40h = drive error
  19+ 769D              ;80h = reading error
  20+ 769D              ;Codes I encountered:
  21+ 769D              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 769D
  23+ 769D
  24+ 769D              	ifndef	_DISK_
  25+ 769D              	define	_DISK_
  26+ 769D
  27+ 769D              	include	"math.asm"
# file opened: math.asm
   1++769D              	ifndef	_MATH_
   2++769D              	define	_MATH_
   3++769D
   4++769D              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++769D              ;http://map.tni.nl/sources/external/z80bits.html
   6++769D
   7++769D
   8++769D              Word2Txt:
   9++769D              	IFUSED
  10++769D D5           	push	de
  11++769E CD BE 76     		call	Word2Txt_
  12++76A1 D1           	pop	de
  13++76A2
  14++76A2 06 04        	ld	b, 4
  15++76A4 CD B3 76     	call	StrippLeading0
  16++76A7 C9           	ret
  17++76A8
  18++76A8              Byte2Txt:
  19++76A8 D5           	push	de
  20++76A9 CD CA 76     		call	Byte2Txt_
  21++76AC D1           	pop	de
  22++76AD
  23++76AD 06 02        	ld	b, 2
  24++76AF CD B3 76     	call	StrippLeading0
  25++76B2 C9           	ret
  26++76B3              	ENDIF
  27++76B3
  28++76B3
  29++76B3              StrippLeading0:
  30++76B3 1A           	ld	a, (de)
  31++76B4 FE 31        	cp	'1'
  32++76B6 D0           	ret	nc
  33++76B7
  34++76B7 3E 20        	ld	a, ' '
  35++76B9 12           	ld	(de), a
  36++76BA 13           	inc	de
  37++76BB 10 F6        	djnz	StrippLeading0
  38++76BD C9           	ret
  39++76BE
  40++76BE
  41++76BE              ;Converts the number in HL to ASCII in decimal string at DE
  42++76BE              Word2Txt_:
  43++76BE 01 F0 D8     	ld bc, -10000
  44++76C1 CD D9 76     	call DigitLoop
  45++76C4 01 18 FC     	ld bc, -1000
  46++76C7 CD D9 76     	call DigitLoop
  47++76CA              Byte2Txt_:
  48++76CA 01 9C FF     	ld bc, -100
  49++76CD CD D9 76     	call DigitLoop
  50++76D0 01 F6 FF     	ld bc, -10
  51++76D3 CD D9 76     	call DigitLoop
  52++76D6 01 FF FF     	ld bc, -1
  53++76D9
  54++76D9              DigitLoop:
  55++76D9 3E 2F        	ld	a, '0' - 1
  56++76DB              DivNrLoop:
  57++76DB 3C           	inc	a		;increase reminder
  58++76DC 09           	add	hl, bc	;substract divizor
  59++76DD 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++76DF ED 42        	sbc	hl, bc	;nope, restore
  61++76E1
  62++76E1 12           	ld (de), a
  63++76E2 13           	inc de
  64++76E3 C9           	ret
  65++76E4
  66++76E4
  67++76E4              ;Input: HL = Dividend, C = Divisor
  68++76E4              ;Output: HL = Quotient, A = Remainder
  69++76E4              ;Warning: doesn't work with divisor >= $80
  70++76E4              Div:
  71++76E4              	IFUSED
  72++76E4 AF           	xor a
  73++76E5 06 10        	ld b, 16
  74++76E7
  75++76E7              DivLoop:
  76++76E7 29           	add	hl,hl
  77++76E8 17           	rla
  78++76E9 B9           	cp	c
  79++76EA 38 02        	jr	c, NoSub
  80++76EC 91           	sub	c
  81++76ED 2C           	inc	l
  82++76EE              NoSub:
  83++76EE 10 F7        	djnz DivLoop
  84++76F0
  85++76F0 C9           	ret
  86++76F1              	ENDIF
  87++76F1
  88++76F1              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++76F1              ;Output: A:C = Quotient, HL = Remainder
  90++76F1              Div2:
  91++76F1 21 00 00     	ld hl, 0
  92++76F4 06 10        	ld b, 16
  93++76F6              Div2Loop:
  94++76F6 CB 31        	sll c	; unroll 16 times
  95++76F8 17           	rla		; ...
  96++76F9 ED 6A        	adc	hl,hl	; ...
  97++76FB ED 52        	sbc	hl,de	; ...
  98++76FD 30 02        	jr	nc,$+4	; ...
  99++76FF 19           	add	hl,de	; ...
 100++7700 0D           	dec	c	; ...
 101++7701 10 F3        	djnz Div2Loop
 102++7703 C9           	ret
 103++7704
 104++7704
 105++7704              ;Input: A = Multiplier, DE = Multiplicand
 106++7704              ;Output: A:HL = Product
 107++7704              Mul:
 108++7704              	IFUSED
 109++7704 21 00 00     	ld hl, 0
 110++7707 01 00 07     	ld bc, $0700
 111++770A
 112++770A 87           	add	a, a	; optimised 1st iteration
 113++770B 30 02        	jr	nc, MulLoop
 114++770D 62           	ld	h, d
 115++770E 6B           	ld	l, e
 116++770F
 117++770F              MulLoop:
 118++770F 29           	add	hl,hl
 119++7710 17           	rla
 120++7711 30 02        	jr	nc, NoAdd
 121++7713 19           	add	hl,de
 122++7714 89           	adc	a,c
 123++7715              NoAdd:
 124++7715 10 F8        	djnz MulLoop
 125++7717
 126++7717 C9           	ret
 127++7718              	ENDIF
 128++7718
 129++7718
 130++7718              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++7718              ;IN: HL=address to read, DE=output address	for 2 chars
 132++7718              Byte2Hex:
 133++7718 AF           	xor	a
 134++7719 ED 6F        	rld
 135++771B CD 1E 77     	call	Byte2HexNibble
 136++771E
 137++771E              Byte2HexNibble:
 138++771E F5           	push	af
 139++771F 27           	daa
 140++7720 C6 F0        	add	a,$F0
 141++7722 CE 40        	adc	a,$40
 142++7724
 143++7724 12           	ld	(de), a
 144++7725 13           	inc	de
 145++7726
 146++7726 F1           	pop	af
 147++7727 ED 6F        	rld
 148++7729 C9           	ret
 149++772A
 150++772A
 151++772A              Byte2HexHex:
 152++772A CD 18 77     	call	Byte2Hex
 153++772D 23           	inc	hl
 154++772E 3E 20        	ld	a, ' '
 155++7730 12           	ld	(de), a
 156++7731 13           	inc	de
 157++7732 C9           	ret
 158++7733
 159++7733              Byte2HexChar:
 160++7733 3E 0D        	ld	a, CHAR_CR
 161++7735 BE           	cp	(hl)
 162++7736 20 03        	jr	nz, Bin2HexLineLoopTextCopy
 163++7738
 164++7738              Bin2HexLineLoopTextReplace:
 165++7738 3E 2E        	ld	a, '.'
 166++773A 77           	ld	(hl), a
 167++773B
 168++773B              Bin2HexLineLoopTextCopy:
 169++773B ED A0        	ldi
 170++773D C9           	ret
 171++773E
 172++773E
 173++773E              HEX_COLUMNS	EQU	16
 174++773E
 175++773E              Bin2HexLine:
 176++773E              	;Hex part
 177++773E 06 10        	ld	b, HEX_COLUMNS
 178++7740 E5           	push	hl
 179++7741              Bin2HexLineLoopHex:
 180++7741 CD 2A 77     		call	Byte2HexHex
 181++7744
 182++7744              		;Put separator in the middle of hex line.
 183++7744 3E 09        		ld	a, HEX_COLUMNS/2+1
 184++7746 B8           		cp	b
 185++7747 20 05        		jr	nz, Bin2HexLineLoopHexNotHalf
 186++7749 1B           		dec	de
 187++774A 3E 80        		ld	a, CHR_V
 188++774C 12           		ld	(de), a
 189++774D 13           		inc	de
 190++774E
 191++774E              Bin2HexLineLoopHexNotHalf:
 192++774E 10 F1        		djnz	Bin2HexLineLoopHex
 193++7750 E1           	pop	hl
 194++7751
 195++7751 1B           	dec	de
 196++7752 3E 80        	ld	a, CHR_V
 197++7754 12           	ld	(de), a
 198++7755 13           	inc	de
 199++7756
 200++7756              	;String part
 201++7756              Bin2HexLineText:
 202++7756              	;just to not alter B with LDI, set C to something > 16
 203++7756 01 20 10     	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 204++7759              Bin2HexLineLoopText:
 205++7759 CD 33 77     	call	Byte2HexChar
 206++775C 10 FB        	djnz	Bin2HexLineLoopText
 207++775E C9           	ret
 208++775F
 209++775F
 210++775F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 211++775F              ;Converts binary buffer at HL to hex string at DE
 212++775F              Bin2HexStr:
 213++775F              	;Calculate the number of full lines by dividing BC to 16.
 214++775F AF           	xor	a
 215++7760
 216++7760 CB 18        	rr	b
 217++7762 CB 19        	rr	c
 218++7764 1F           	rra
 219++7765
 220++7765 CB 18        	rr	b
 221++7767 CB 19        	rr	c
 222++7769 1F           	rra
 223++776A
 224++776A CB 18        	rr	b
 225++776C CB 19        	rr	c
 226++776E 1F           	rra
 227++776F
 228++776F CB 18        	rr	b
 229++7771 CB 19        	rr	c
 230++7773 1F           	rra
 231++7774
 232++7774 1F           	rra
 233++7775 1F           	rra
 234++7776 1F           	rra
 235++7777 1F           	rra
 236++7778
 237++7778 08           	ex		af, af'		;Keep reminder
 238++7779
 239++7779              Bin2HexStrLoop:
 240++7779 C5           	push	bc
 241++777A CD 3E 77     		call	Bin2HexLine
 242++777D C1           	pop	bc
 243++777E
 244++777E 0B           	dec	bc
 245++777F 78           	ld	a, b
 246++7780 B1           	or	c
 247++7781 20 F6        	jr	nz, Bin2HexStrLoop
 248++7783
 249++7783              	;Set remaining imcomplete line.
 250++7783 D5           	push	de
 251++7784 E5           	push	hl
 252++7785 3E 20        		ld	a, ' '
 253++7787 06 40        		ld	b, COL_CNT
 254++7789              Bin2HexLineClear:
 255++7789 12           		ld	(de), a
 256++778A 13           		inc	de
 257++778B 10 FC        		djnz	Bin2HexLineClear
 258++778D E1           	pop	hl
 259++778E D1           	pop	de
 260++778F
 261++778F D5           	push	de
 262++7790 DD E1        	pop	ix
 263++7792
 264++7792 01 30 00     	ld	bc, HEX_COLUMNS*3
 265++7795 DD 09        	add	ix, bc
 266++7797
 267++7797              	;Write hex and char part
 268++7797 08           	ex	af, af'
 269++7798 B7           	or	a
 270++7799 C8           	ret	z
 271++779A
 272++779A 47           	ld	b, a
 273++779B 0E 20        	ld	c, HEX_COLUMNS*2
 274++779D
 275++779D              Bin2HexLineLoopHex2:
 276++779D CD 2A 77     	call	Byte2HexHex
 277++77A0 2B           	dec	hl
 278++77A1
 279++77A1 D5           	push	de
 280++77A2 DD 5D        		ld	e, ixl
 281++77A4 DD 54        		ld	d, ixh
 282++77A6 CD 33 77     		call	Byte2HexChar
 283++77A9 D1           	pop	de
 284++77AA DD 23        	inc	ix
 285++77AC 10 EF        	djnz	Bin2HexLineLoopHex2
 286++77AE
 287++77AE 3E 80        	ld	a, CHR_V
 288++77B0 DD 77 17     	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 289++77B3 DD 77 2F     	ld	(ix + HEX_COLUMNS*3 - 1), a
 290++77B6
 291++77B6 C9           	ret
 292++77B7
 293++77B7              	endif
# file closed: math.asm
  28+ 77B7
  29+ 77B7              DRIVE_CUR_BAS	EQU 0
  30+ 77B7              DRIVE_A_BAS		EQU	1
  31+ 77B7              DRIVE_B_BAS		EQU	2
  32+ 77B7              DRIVE_A_CPM		EQU	0
  33+ 77B7              DRIVE_B_CPM		EQU	1
  34+ 77B7              ;Disk geometry stuff
  35+ 77B7              SPT				EQU	16			;sectors per track
  36+ 77B7              SECT_SZ			EQU	256			;sector size in bytes
  37+ 77B7              TRACK_CNT		EQU	80			;track count
  38+ 77B7              HEAD_CNT		EQU	2			;disk face count
  39+ 77B7              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 77B7              EXT_SZ			EQU	32			;directory entry size
  41+ 77B7              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 77B7              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 77B7              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 77B7              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 77B7              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 77B7              REC_SZ			EQU 128			;cp/m record size
  47+ 77B7              DEL_MARKER		EQU	$E5
  48+ 77B7
  49+ 77B7
  50+ 77B7              ;Extension structure (directory entry)
  51+ 77B7              EXT_DEL_FLAG	EQU	0
  52+ 77B7              EXT_NAME		EQU 1
  53+ 77B7              EXT_IDX			EQU 12
  54+ 77B7              EXT_S1			EQU 13
  55+ 77B7              EXT_S2			EQU 14
  56+ 77B7              EXT_RC			EQU	15
  57+ 77B7              EXT_AU0			EQU	16
  58+ 77B7              EXT_AU1			EQU	18
  59+ 77B7              EXT_AU2			EQU	20
  60+ 77B7              EXT_AU3			EQU	22
  61+ 77B7              EXT_AU4			EQU	24
  62+ 77B7              EXT_AU5			EQU	26
  63+ 77B7              EXT_AU6			EQU	28
  64+ 77B7              EXT_AU7			EQU	30
  65+ 77B7              EXT_SIZE		EQU 32
  66+ 77B7
  67+ 77B7              ;FCB structure
  68+ 77B7              FCB_DRIVE		EQU 0
  69+ 77B7              FCB_NAME		EQU EXT_NAME
  70+ 77B7              FCB_EX_IDX		EQU EXT_IDX
  71+ 77B7              FCB_S1			EQU EXT_S1
  72+ 77B7              FCB_S2			EQU EXT_S2
  73+ 77B7              FCB_RC			EQU	EXT_RC
  74+ 77B7              FCB_AU			EQU	EXT_AU0
  75+ 77B7              FCB_CR			EQU	32
  76+ 77B7              FCB_R0			EQU 33
  77+ 77B7              FCB_R1			EQU 34
  78+ 77B7              FCB_R2			EQU 35
  79+ 77B7              FCB_SIZE		EQU 36
  80+ 77B7
  81+ 77B7
  82+ 77B7
  83+ 77B7              ;System variables for disk
  84+ 77B7              DSTR1			EQU	$5CD6		;drive
  85+ 77B7              FSTR1			EQU	$5CDC		;file name
  86+ 77B7              NSTR1			EQU	$5CDA		;name length
  87+ 77B7              HD11			EQU	$5CED		;BDOS argument
  88+ 77B7              COPIES			EQU	$5CEF		;BDOS function
  89+ 77B7
  90+ 77B7              ERRSP			EQU $5C3D
  91+ 77B7              ERRNR			EQU $5C3A
  92+ 77B7              ERRMSG			EQU	$0260
  93+ 77B7
  94+ 77B7              PROG			EQU $5C53
  95+ 77B7              VARS			EQU	$5C4B
  96+ 77B7              STKEND			EQU	$5C65
  97+ 77B7
  98+ 77B7              PRN_BUF			EQU	23296
  99+ 77B7
 100+ 77B7              REPDEL			EQU	23561
 101+ 77B7              REPPER			EQU	23562
 102+ 77B7              PIP			EQU	23609
 103+ 77B7              LAST_K			EQU	$5C08
 104+ 77B7
 105+ 77B7
 106+ 77B7              ;RWTS routine commands
 107+ 77B7              RWTS_CMD_SEEK	EQU	0			;position head
 108+ 77B7              RWTS_CMD_READ	EQU	1			;read sector
 109+ 77B7              RWTS_CMD_WRITE	EQU	2			;write sector
 110+ 77B7              RWTS_CMD_FMT	EQU	4			;format all tracks
 111+ 77B7
 112+ 77B7
 113+ 77B7              ;File name stuff
 114+ 77B7              NAMELEN			EQU	11			;name length
 115+ 77B7              RO_POS			EQU	8			;read-only attribute position in name
 116+ 77B7              SYS_POS			EQU	9			;system attribute position in name
 117+ 77B7
 118+ 77B7              ;File types (first byte in header)
 119+ 77B7              PROG_TYPE		EQU	0			;program
 120+ 77B7              NUMB_TYPE		EQU	1			;number array
 121+ 77B7              CHAR_TYPE		EQU	2			;char array
 122+ 77B7              BYTE_TYPE		EQU	3			;bytes
 123+ 77B7              TEXT_TYPE		EQU	4			;text, >= 4
 124+ 77B7
 125+ 77B7              ;File header offsets
 126+ 77B7              HDR_TYPE		EQU	0
 127+ 77B7              HDR_LEN			EQU 1
 128+ 77B7              HDR_ADDR		EQU 3
 129+ 77B7              HDR_PLEN		EQU	5
 130+ 77B7              HDR_LINE		EQU 7
 131+ 77B7              HDR_SZ			EQU	9
 132+ 77B7
 133+ 77B7              ;BASIC disk channel structure
 134+ 77B7              CH_RW_FLAG		EQU 11
 135+ 77B7              CH_FCB			EQU	12
 136+ 77B7              CH_DATA			EQU	50
 137+ 77B7              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 138+ 77B7
 139+ 77B7              CACHE_NAME		EQU	0					;11B
 140+ 77B7              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 141+ 77B7              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 142+ 77B7              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 143+ 77B7              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 144+ 77B7              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 145+ 77B7
 146+ 77B7              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 147+ 77B7
 148+ 77B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 149+ 77B7              IF1Init:
 150+ 77B7 CF           	rst		08
 151+ 77B8 31           	defb	49		;create system variables
 152+ 77B9 C9           	ret
 153+ 77BA
 154+ 77BA              ;ReadWriteTrackSector
 155+ 77BA              ;A=command: 0, 1, 2, 4
 156+ 77BA              RWTS:
 157+ 77BA 32 7A 7B     	ld (RWTSCmd), a
 158+ 77BD 21 6F 7B     	ld hl, RWTSParams
 159+ 77C0 22 ED 5C     	ld (HD11), hl
 160+ 77C3 CF           	rst 08
 161+ 77C4 3A           	DEFB 58
 162+ 77C5 C9           	ret
 163+ 77C6
 164+ 77C6
 165+ 77C6              ;D = sector, E = track
 166+ 77C6              ;HL = dma
 167+ 77C6              ReadOneDiskSector:
 168+ 77C6 22 74 7B     	ld (RWTSDMA), hl
 169+ 77C9 ED 53 72 7B  	ld (RWTSTrack), de
 170+ 77CD              	;ld (RWTSDrive), a
 171+ 77CD 3E 01        	ld a, RWTS_CMD_READ
 172+ 77CF 18 E9        	jr	RWTS
 173+ 77D1
 174+ 77D1              ;D = sector, E = track
 175+ 77D1              ;HL = dma
 176+ 77D1              WriteOneDiskSector:
 177+ 77D1 22 74 7B     	ld (RWTSDMA), hl
 178+ 77D4 ED 53 72 7B  	ld (RWTSTrack), de
 179+ 77D8              	;ld (RWTSDrive), a
 180+ 77D8 3E 02        	ld a, RWTS_CMD_WRITE
 181+ 77DA 18 DE        	jr	RWTS
 182+ 77DC
 183+ 77DC              FormatDisk:
 184+ 77DC 21 59 97     	ld		hl, DataBuf
 185+ 77DF 36 E5        	ld		(hl), DEL_MARKER
 186+ 77E1 22 74 7B     	ld 		(RWTSDMA), hl
 187+ 77E4 3E 04        	ld 		a, RWTS_CMD_FMT
 188+ 77E6 CD BA 77     	call	RWTS
 189+ 77E9 3A 7B 7B     	ld		a, (RWTSRes)
 190+ 77EC C9           	ret
 191+ 77ED
 192+ 77ED              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 77ED
 194+ 77ED              ;Allocation unit no. to track/sector
 195+ 77ED              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 196+ 77ED              ;IN:  HL=alloc. unit no.
 197+ 77ED              ;OUT: B=sector; C=track (head is determined by the sector number)
 198+ 77ED              AU2TS:
 199+ 77ED 0E 02        	ld c, SPT/SPAL
 200+ 77EF CD E4 76     	call Div					;A = sector
 201+ 77F2 F5           	push af
 202+ 77F3 ~            		/*
 203+ 77F3 ~            		ld c, HEAD_CNT
 204+ 77F3 ~            		call Div				;L = track, A = head (0 or 1)
 205+ 77F3 ~            		*/
 206+ 77F3 AF           		xor a
 207+ 77F4 CB 1C        		rr h
 208+ 77F6 CB 1D        		rr l
 209+ 77F8 CB 1F        		rr a
 210+ 77FA
 211+ 77FA 4D           		ld c, l
 212+ 77FB 06 00        		ld b, 0
 213+ 77FD B7           		or a
 214+ 77FE 28 02        		jr z, Track0
 215+ 7800 06 10        		ld b, SPT
 216+ 7802              Track0:
 217+ 7802 F1           	pop af
 218+ 7803 B7           	or a
 219+ 7804 28 02        	jr z, FirstAU
 220+ 7806 3E 08        	ld a, SPAL
 221+ 7808              FirstAU:
 222+ 7808 80           	add a, b
 223+ 7809 47           	ld  b, a
 224+ 780A C9           	ret
 225+ 780B
 226+ 780B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 227+ 780B
 228+ 780B              ;Checks the allocation units number used in extension
 229+ 780B              ;IN:	IX = extension addr
 230+ 780B              ;OUT:	B = no. of allocation units used
 231+ 780B              ;		C = no. of records used in ext.
 232+ 780B              ;		HL = first alloc. unit no.
 233+ 780B              ;		DE = last alloc. unit no.
 234+ 780B              CheckExtAlloc:
 235+ 780B DD E5        	push ix
 236+ 780D 01 0F 00     		ld bc, EXT_RC
 237+ 7810 DD 09        		add ix, bc
 238+ 7812 DD 4E 00     		ld c, (ix)			;save rec. no.
 239+ 7815 DD 23        		inc ix
 240+ 7817 DD 6E 00     		ld l, (ix)
 241+ 781A DD 66 01     		ld h, (ix + 1)
 242+ 781D 06 08        		ld b, EXT_AU_CNT
 243+ 781F              CheckAU:
 244+ 781F DD 7E 00     		ld a, (ix)
 245+ 7822 DD B6 01     		or (ix + 1)
 246+ 7825 28 0C        		jr z, CheckAUEnd
 247+ 7827 DD 5E 00     		ld e, (ix)
 248+ 782A DD 56 01     		ld d, (ix + 1)
 249+ 782D DD 23        		inc ix
 250+ 782F DD 23        		inc ix
 251+ 7831 10 EC        		djnz CheckAU
 252+ 7833              CheckAUEnd:
 253+ 7833 3E 08        		ld a, EXT_AU_CNT
 254+ 7835 90           		sub b
 255+ 7836 47           		ld b, a
 256+ 7837 DD E1        	pop ix
 257+ 7839 C9           	ret
 258+ 783A
 259+ 783A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 260+ 783A
 261+ 783A              ;Input: TrackBuffer
 262+ 783A              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 263+ 783A              ReadUsedBlocksList:
 264+ 783A DD 21 59 97  	ld		ix, TrackBuf			;source buffer
 265+ 783E 21 6F 91     	ld		hl, UsedBlockListCnt 	;destination buffer
 266+ 7841 ED 4B 0F 89  	ld		bc, (AUCntMaxFree)		;loop counter
 267+ 7845 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 268+ 7848 73           	ld		(hl), e
 269+ 7849 23           	inc		hl
 270+ 784A 72           	ld		(hl), d
 271+ 784B 23           	inc		hl
 272+ 784C
 273+ 784C              	;Add blocks 0 and 1 for directory
 274+ 784C 11 00 00     	ld		de, 0
 275+ 784F 73           	ld		(hl), e
 276+ 7850 23           	inc		hl
 277+ 7851 72           	ld		(hl), d
 278+ 7852 23           	inc		hl
 279+ 7853
 280+ 7853 13           	inc		de
 281+ 7854 73           	ld		(hl), e
 282+ 7855 23           	inc		hl
 283+ 7856 72           	ld		(hl), d
 284+ 7857 23           	inc		hl
 285+ 7858
 286+ 7858              ReadUsedBlocksLoop:
 287+ 7858 AF           	xor		a
 288+ 7859 DD BE 00     	cp		(ix)
 289+ 785C 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 290+ 785E
 291+ 785E DD E5        	push	ix
 292+ 7860 C5           	push	bc
 293+ 7861 06 08        		ld		b, EXT_AU_CNT
 294+ 7863 11 10 00     		ld		de, EXT_AU0
 295+ 7866 DD 19        		add		ix, de
 296+ 7868
 297+ 7868              ReadUsedBlocksLoop2:
 298+ 7868 DD 5E 00     		ld		e, (ix)
 299+ 786B DD 56 01     		ld		d, (ix+1)
 300+ 786E 7B           		ld		a, e
 301+ 786F B2           		or		d
 302+ 7870 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 303+ 7872
 304+ 7872 73           		ld		(hl), e
 305+ 7873 23           		inc		hl
 306+ 7874 72           		ld		(hl), d
 307+ 7875 23           		inc		hl
 308+ 7876
 309+ 7876 DD 23        		inc		ix
 310+ 7878 DD 23        		inc		ix
 311+ 787A
 312+ 787A ED 5B 6F 91  		ld		de, (UsedBlockListCnt)
 313+ 787E 13           		inc		de
 314+ 787F ED 53 6F 91  		ld		(UsedBlockListCnt), de
 315+ 7883
 316+ 7883 10 E3        		djnz	ReadUsedBlocksLoop2
 317+ 7885
 318+ 7885
 319+ 7885              ReadUsedBlocksSkip:
 320+ 7885 C1           	pop		bc
 321+ 7886 DD E1        	pop		ix
 322+ 7888              ReadUsedBlocksSkip2:
 323+ 7888 11 20 00     	ld		de, EXT_SZ
 324+ 788B DD 19        	add		ix, de
 325+ 788D
 326+ 788D 0B           	dec		bc
 327+ 788E 78           	ld		a, b
 328+ 788F B1           	or		c
 329+ 7890 20 C6        	jr		nz, ReadUsedBlocksLoop
 330+ 7892
 331+ 7892 C9           	ret
 332+ 7893
 333+ 7893              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 334+ 7893              ;Reads 8 sectors for an AU
 335+ 7893              ;HL = block number, DE = destination buffer
 336+ 7893              ReadFSBlock:
 337+ 7893 D5           	push	de
 338+ 7894 CD ED 77     		call	AU2TS		;B=sector, C=track
 339+ 7897 E1           	pop		hl				;HL=dest
 340+ 7898
 341+ 7898 50           	ld		d, b
 342+ 7899 59           	ld		e, c
 343+ 789A 06 08        	ld		b, SPAL
 344+ 789C
 345+ 789C CD 7B 7A     	call	ReadDiskSectors
 346+ 789F C9           	ret
 347+ 78A0
 348+ 78A0
 349+ 78A0              ;Write 8 sectors for an AU
 350+ 78A0              ;HL = block number, DE = source buffer
 351+ 78A0              WriteFSBlock:
 352+ 78A0 D5           	push	de
 353+ 78A1 CD ED 77     		call	AU2TS		;B=sector, C=track
 354+ 78A4 E1           	pop		hl				;HL=dest
 355+ 78A5
 356+ 78A5 50           	ld		d, b
 357+ 78A6 59           	ld		e, c
 358+ 78A7 06 08        	ld		b, SPAL
 359+ 78A9
 360+ 78A9 CD 8E 7A     	call	WriteDiskSectors
 361+ 78AC C9           	ret
 362+ 78AD
 363+ 78AD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364+ 78AD              ;Copies the allocated blocks from one disk to another, dual drive.
 365+ 78AD              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366+ 78AD              CopyDisk:
 367+ 78AD              	;Get list of used blocks in current disk, max 632 bytes
 368+ 78AD CD 3A 78     	call	ReadUsedBlocksList
 369+ 78B0 DD 21 71 91  	ld		ix, UsedBlockListBlk
 370+ 78B4
 371+ 78B4              CopyDiskLoop:
 372+ 78B4 2A 6F 91     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373+ 78B7 11 60 88     	ld		de, MsgBlocksLeft
 374+ 78BA CD A8 76     	call	Byte2Txt
 375+ 78BD 21 60 88     	ld		hl, MsgBlocksLeft
 376+ 78C0 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 377+ 78C3 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 378+ 78C5 CD 39 80     	call	PrintStrClr
 379+ 78C8
 380+ 78C8              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381+ 78C8 21 0C 00     	ld		hl, MAX_AU_RAM
 382+ 78CB ED 4B 6F 91  	ld		bc, (UsedBlockListCnt)
 383+ 78CF B7           	or		a
 384+ 78D0 ED 42        	sbc		hl, bc
 385+ 78D2 30 03        	jr		nc, CopyDiskLoopRead
 386+ 78D4 01 0C 00     	ld		bc, MAX_AU_RAM
 387+ 78D7
 388+ 78D7              CopyDiskLoopRead:
 389+ 78D7 41           	ld		b, c
 390+ 78D8 11 59 97     	ld		de, CopyDiskBuf
 391+ 78DB              	;save initial counter and initial block number array position
 392+ 78DB C5           	push	bc
 393+ 78DC DD E5        	push	ix
 394+ 78DE
 395+ 78DE              CopyDiskLoopReadLoop:
 396+ 78DE DD 6E 00     		ld		l, (ix)
 397+ 78E1 DD 66 01     		ld		h, (ix+1)
 398+ 78E4 DD 23        		inc		ix
 399+ 78E6 DD 23        		inc		ix
 400+ 78E8
 401+ 78E8 D5           		push	de
 402+ 78E9 C5           		push	bc
 403+ 78EA CD 93 78     			call	ReadFSBlock			;Stop on error or continue?
 404+ 78ED C1           		pop		bc
 405+ 78EE D1           		pop		de
 406+ 78EF
 407+ 78EF              		;+2048
 408+ 78EF 7A           		ld		a, d
 409+ 78F0 C6 08        		add		8
 410+ 78F2 57           		ld		d, a
 411+ 78F3
 412+ 78F3 10 E9        		djnz	CopyDiskLoopReadLoop
 413+ 78F5
 414+ 78F5              		;Check if selection is 1=single drive or 2=dual drive
 415+ 78F5 3A 13 89     		ld		a, (CopySelOption)
 416+ 78F8 FE 31        		cp		'1'
 417+ 78FA 20 0B        		jr		nz, CopyDiskDualDrive1
 418+ 78FC
 419+ 78FC              		;Prompt for disk change
 420+ 78FC CD 82 7C     		call	PromptDiskChangeDst
 421+ 78FF 3A 70 7B     		ld		a, (RWTSDrive)
 422+ 7902 CD 88 7B     		call	BDOSInit
 423+ 7905 18 0A        		jr		CopyDiskReadEnd
 424+ 7907
 425+ 7907              CopyDiskDualDrive1:
 426+ 7907              		;alternate drive
 427+ 7907 3A 70 7B     		ld		a, (RWTSDrive)
 428+ 790A 3C           		inc 	a
 429+ 790B EE 03        		xor		%11
 430+ 790D 3D           		dec		a
 431+ 790E 32 70 7B     		ld		(RWTSDrive), a
 432+ 7911
 433+ 7911              CopyDiskReadEnd:
 434+ 7911              	;restore initial counter and initial block number array position
 435+ 7911 DD E1        	pop		ix
 436+ 7913 C1           	pop		bc
 437+ 7914 11 59 97     	ld		de, CopyDiskBuf
 438+ 7917 C5           	push	bc
 439+ 7918
 440+ 7918              CopyDiskLoopWriteLoop:
 441+ 7918 DD 6E 00     		ld		l, (ix)
 442+ 791B DD 66 01     		ld		h, (ix+1)
 443+ 791E DD 23        		inc		ix
 444+ 7920 DD 23        		inc		ix
 445+ 7922
 446+ 7922 D5           		push	de
 447+ 7923 C5           		push	bc
 448+ 7924 CD A0 78     			call	WriteFSBlock		;Stop on error or continue?
 449+ 7927 C1           		pop		bc
 450+ 7928 D1           		pop		de
 451+ 7929
 452+ 7929              		;+2048
 453+ 7929 7A           		ld		a, d
 454+ 792A C6 08        		add		8
 455+ 792C 57           		ld		d, a
 456+ 792D
 457+ 792D 10 E9        		djnz	CopyDiskLoopWriteLoop
 458+ 792F
 459+ 792F              CopyDiskWriteEnd:
 460+ 792F C1           	pop		bc
 461+ 7930 48           	ld		c, b
 462+ 7931 06 00        	ld		b, 0
 463+ 7933
 464+ 7933              	;Decrease number of blocks read by now.
 465+ 7933 2A 6F 91     	ld		hl, (UsedBlockListCnt)
 466+ 7936 B7           	or		a
 467+ 7937 ED 42        	sbc		hl, bc
 468+ 7939 22 6F 91     	ld		(UsedBlockListCnt), hl
 469+ 793C
 470+ 793C 7D           	ld		a, l
 471+ 793D B4           	or		h
 472+ 793E 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 473+ 7940
 474+ 7940              	;Check if selection is 1=single drive or 2=dual drive
 475+ 7940 3A 13 89     	ld		a, (CopySelOption)
 476+ 7943 FE 31        	cp		'1'
 477+ 7945 20 0C        	jr		nz, CopyDiskDualDrive2
 478+ 7947
 479+ 7947              	;Prompt for disk change
 480+ 7947 CD 9C 7C     	call	PromptDiskChangeSrc
 481+ 794A 3A 70 7B     	ld		a, (RWTSDrive)
 482+ 794D CD 88 7B     	call	BDOSInit
 483+ 7950 C3 B4 78     	jp		CopyDiskLoop
 484+ 7953
 485+ 7953              CopyDiskDualDrive2:
 486+ 7953              	;alternate drive again
 487+ 7953 3A 70 7B     	ld		a, (RWTSDrive)
 488+ 7956 3C           	inc		a
 489+ 7957 EE 03        	xor		%11
 490+ 7959 3D           	dec		a
 491+ 795A 32 70 7B     	ld		(RWTSDrive), a
 492+ 795D C3 B4 78     	jp		CopyDiskLoop
 493+ 7960
 494+ 7960              CopyDiskEnd:
 495+ 7960 06 01        	ld		b, 1
 496+ 7962 CD BD 81     	call	ClearNMsgLines
 497+ 7965 C9           	ret
 498+ 7966
 499+ 7966              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 500+ 7966              ;Copies the current disk blocks to COM port.
 501+ 7966              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 502+ 7966              CopyDiskToCOM:
 503+ 7966              	;Get list of used blocks in current disk, max 632 bytes
 504+ 7966 CD 3A 78     	call	ReadUsedBlocksList
 505+ 7969
 506+ 7969              	;Send block count and block indexes
 507+ 7969 2A 6F 91     	ld		hl, (UsedBlockListCnt)
 508+ 796C 29           	add		hl, hl
 509+ 796D 23           	inc		hl
 510+ 796E 23           	inc		hl
 511+ 796F 44           	ld		b, h
 512+ 7970 4D           	ld		c, l
 513+ 7971 21 6F 91     	ld		hl, UsedBlockListCnt
 514+ 7974 CD 17 85     	call	SERTB
 515+ 7977
 516+ 7977 DD 21 71 91  	ld		ix, UsedBlockListBlk
 517+ 797B
 518+ 797B              CopyDiskToCOMLoop:
 519+ 797B              	;Print block count left
 520+ 797B 2A 6F 91     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 521+ 797E 11 60 88     	ld		de, MsgBlocksLeft
 522+ 7981 CD A8 76     	call	Byte2Txt
 523+ 7984 21 60 88     	ld		hl, MsgBlocksLeft
 524+ 7987 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 525+ 798A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 526+ 798C CD 39 80     	call	PrintStrClr
 527+ 798F
 528+ 798F              	;Read block into buffer
 529+ 798F DD 6E 00     	ld		l, (ix)
 530+ 7992 DD 66 01     	ld		h, (ix+1)
 531+ 7995 11 59 97     	ld		de, CopyDiskBuf
 532+ 7998 DD E5        	push	ix
 533+ 799A CD 93 78     		call	ReadFSBlock
 534+ 799D DD E1        	pop		ix
 535+ 799F DD 23        	inc		ix
 536+ 79A1 DD 23        	inc		ix
 537+ 79A3
 538+ 79A3              	;Send block buffer
 539+ 79A3 21 59 97     	ld		hl, CopyDiskBuf
 540+ 79A6 01 00 08     	ld		bc, AU_SZ
 541+ 79A9 CD 17 85     	call	SERTB
 542+ 79AC
 543+ 79AC ED 4B 6F 91  	ld		bc, (UsedBlockListCnt)
 544+ 79B0 0B           	dec		bc
 545+ 79B1 ED 43 6F 91  	ld		(UsedBlockListCnt), bc
 546+ 79B5
 547+ 79B5 DD E5        	push	ix
 548+ 79B7 CD D8 7F     		call	KbdHit
 549+ 79BA DD E1        	pop		ix
 550+ 79BC D8           	ret		c
 551+ 79BD
 552+ 79BD 78           	ld		a, b
 553+ 79BE B1           	or		c
 554+ 79BF 20 BA        	jr		nz, CopyDiskToCOMLoop
 555+ 79C1
 556+ 79C1 C9           	ret
 557+ 79C2
 558+ 79C2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 559+ 79C2              CopyDiskFromCOM:
 560+ 79C2              	;Receive block count.
 561+ 79C2 21 6F 91     	ld		hl, UsedBlockListCnt
 562+ 79C5 01 02 00     	ld		bc, 2
 563+ 79C8 1E 00        	ld		e, 0
 564+ 79CA CD E4 84     	call	SERRB
 565+ 79CD
 566+ 79CD              	;Receive block indexes.
 567+ 79CD 2A 6F 91     	ld		hl, (UsedBlockListCnt)
 568+ 79D0 29           	add		hl, hl
 569+ 79D1 44           	ld		b, h
 570+ 79D2 4D           	ld		c, l
 571+ 79D3 21 71 91     	ld		hl, UsedBlockListBlk
 572+ 79D6 1E 00        	ld		e, 0
 573+ 79D8 CD E4 84     	call	SERRB
 574+ 79DB
 575+ 79DB              	;Read each block by index and write to disk
 576+ 79DB DD 21 71 91  	ld		ix, UsedBlockListBlk
 577+ 79DF
 578+ 79DF              CopyDiskFromCOMLoop:
 579+ 79DF              	;Print block count left
 580+ 79DF 2A 6F 91     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 581+ 79E2 11 60 88     	ld		de, MsgBlocksLeft
 582+ 79E5 CD A8 76     	call	Byte2Txt
 583+ 79E8 21 60 88     	ld		hl, MsgBlocksLeft
 584+ 79EB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 585+ 79EE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586+ 79F0 CD 39 80     	call	PrintStrClr
 587+ 79F3
 588+ 79F3              	;Read block buffer
 589+ 79F3 21 59 97     	ld		hl, CopyDiskBuf
 590+ 79F6 01 00 08     	ld		bc, AU_SZ
 591+ 79F9 1E 00        	ld		e, 0
 592+ 79FB CD E4 84     	call	SERRB
 593+ 79FE
 594+ 79FE              	;Write block to disk
 595+ 79FE DD 6E 00     	ld		l, (ix)
 596+ 7A01 DD 66 01     	ld		h, (ix+1)
 597+ 7A04 11 59 97     	ld		de, CopyDiskBuf
 598+ 7A07 DD E5        	push	ix
 599+ 7A09 CD A0 78     		call	WriteFSBlock			;Stop on error or continue?
 600+ 7A0C DD E1        	pop		ix
 601+ 7A0E DD 23        	inc		ix
 602+ 7A10 DD 23        	inc		ix
 603+ 7A12
 604+ 7A12 ED 4B 6F 91  	ld		bc, (UsedBlockListCnt)
 605+ 7A16 0B           	dec		bc
 606+ 7A17 ED 43 6F 91  	ld		(UsedBlockListCnt), bc
 607+ 7A1B
 608+ 7A1B DD E5        	push	ix
 609+ 7A1D CD D8 7F     		call	KbdHit
 610+ 7A20 DD E1        	pop		ix
 611+ 7A22 D8           	ret		c
 612+ 7A23
 613+ 7A23 78           	ld		a, b
 614+ 7A24 B1           	or		c
 615+ 7A25 20 B8        	jr		nz, CopyDiskFromCOMLoop
 616+ 7A27 C9           	ret
 617+ 7A28
 618+ 7A28              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619+ 7A28
 620+ 7A28              ;Compare string at HL with the one at DE, max length B
 621+ 7A28              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 622+ 7A28              ;OUT: z flag, set = match, reset = mismatch
 623+ 7A28              StrCmp:
 624+ 7A28 E5           	push hl
 625+ 7A29 D5           	push de
 626+ 7A2A              Compare:
 627+ 7A2A 1A           		ld a, (de)
 628+ 7A2B BE           		cp (hl)
 629+ 7A2C 20 04        		jr nz, MisMatch
 630+ 7A2E 23           		inc hl
 631+ 7A2F 13           		inc de
 632+ 7A30 10 F8        		djnz Compare
 633+ 7A32              MisMatch:
 634+ 7A32 D1           	pop de
 635+ 7A33 E1           	pop hl
 636+ 7A34 C9           	ret
 637+ 7A35
 638+ 7A35              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 639+ 7A35
 640+ 7A35              ;Read a file into a buffer, sector by sector.
 641+ 7A35              ;It's relocatable, to moved and be used when loading a CODE block.
 642+ 7A35              ;It's not using BDOS, but using similar calls provided by IF1.
 643+ 7A35              ;In: HL = Name address, DE = buffer
 644+ 7A35              IF1FileLoad:
 645+ 7A35 D5           	push	de
 646+ 7A36 22 DC 5C     		ld (FSTR1), hl
 647+ 7A39 26 00        		ld h, 0
 648+ 7A3B 3A 70 7B     		ld a, (RWTSDrive)
 649+ 7A3E 3C           		inc  a			;CP/M drive number to BASIC drive number
 650+ 7A3F 6F           		ld	l, a
 651+ 7A40 22 D6 5C     		ld (DSTR1), hl
 652+ 7A43 2E 0B        		ld l,NAMELEN
 653+ 7A45 22 DA 5C     		ld (NSTR1), hl
 654+ 7A48 CF           		rst 08
 655+ 7A49 33           		DEFB 51			;open disk channel
 656+ 7A4A
 657+ 7A4A CF           		rst		8
 658+ 7A4B 35           		defb	53		;read sector
 659+ 7A4C D1           	pop		de
 660+ 7A4D 30 27        	jr		nc, FileFree
 661+ 7A4F
 662+ 7A4F DD 7E 32     	ld		a, (ix + CH_DATA)
 663+ 7A52 FE 04        	cp		TEXT_TYPE
 664+ 7A54 30 12        	jr		nc, FileLoadNoHeader
 665+ 7A56
 666+ 7A56              FileLoadHeader:
 667+ 7A56 DD E5        	push	ix
 668+ 7A58 E1           	pop		hl
 669+ 7A59 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 670+ 7A5C 09           	add		hl, bc
 671+ 7A5D 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 672+ 7A60 ED B0        	ldir
 673+ 7A62
 674+ 7A62              FileReadLoop:
 675+ 7A62 D5           	push	de
 676+ 7A63 CF           		rst		8
 677+ 7A64 35           		defb	53		;read sector
 678+ 7A65 D1           	pop		de
 679+ 7A66 30 0E        	jr		nc, FileFree
 680+ 7A68
 681+ 7A68              FileLoadNoHeader:
 682+ 7A68 DD E5        	push	ix
 683+ 7A6A E1           	pop		hl
 684+ 7A6B 01 32 00     	ld		bc, CH_DATA
 685+ 7A6E 09           	add		hl, bc
 686+ 7A6F 01 00 01     	ld		bc, SECT_SZ
 687+ 7A72 ED B0        	ldir
 688+ 7A74 18 EC        	jr		FileReadLoop
 689+ 7A76
 690+ 7A76              FileFree:
 691+ 7A76 D5           	push	de
 692+ 7A77 CF           	rst		8
 693+ 7A78 38           	defb	56			;close channel (52) or detroy channel (56)
 694+ 7A79 D1           	pop		de
 695+ 7A7A C9           	ret
 696+ 7A7B              IF1FileLoadEnd:
 697+ 7A7B
 698+ 7A7B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 699+ 7A7B              ;HL = destination buffer, B = count of sectors, DE = track/sector
 700+ 7A7B              ;Out: A = error code, 0=OK
 701+ 7A7B              ReadDiskSectors:
 702+ 7A7B C5           	push bc
 703+ 7A7C E5           		push hl
 704+ 7A7D D5           			push de
 705+ 7A7E CD C6 77     				call ReadOneDiskSector
 706+ 7A81 D1           			pop de
 707+ 7A82 E1           		pop hl
 708+ 7A83
 709+ 7A83 14           		inc d
 710+ 7A84 24           		inc h
 711+ 7A85 C1           	pop bc
 712+ 7A86
 713+ 7A86 3A 7B 7B     	ld	a, (RWTSRes)
 714+ 7A89 B7           	or	a
 715+ 7A8A C0           	ret nz
 716+ 7A8B
 717+ 7A8B 10 EE        	djnz ReadDiskSectors
 718+ 7A8D C9           	ret
 719+ 7A8E
 720+ 7A8E              ;HL = source buffer, B = count of sectors, DE = track/sector
 721+ 7A8E              ;Out: A = error code, 0=OK
 722+ 7A8E              WriteDiskSectors:
 723+ 7A8E C5           	push bc
 724+ 7A8F E5           		push hl
 725+ 7A90 D5           			push de
 726+ 7A91 CD D1 77     				call WriteOneDiskSector
 727+ 7A94 D1           			pop de
 728+ 7A95 E1           		pop hl
 729+ 7A96
 730+ 7A96 14           		inc d
 731+ 7A97 24           		inc h
 732+ 7A98 C1           	pop bc
 733+ 7A99
 734+ 7A99 3A 7B 7B     	ld	a, (RWTSRes)
 735+ 7A9C B7           	or	a
 736+ 7A9D C0           	ret nz
 737+ 7A9E
 738+ 7A9E 10 EE        	djnz WriteDiskSectors
 739+ 7AA0 C9           	ret
 740+ 7AA1
 741+ 7AA1
 742+ 7AA1              ;Reads disk catalog
 743+ 7AA1              ReadCatalogTrack:
 744+ 7AA1 21 59 97     	ld hl, TrackBuf
 745+ 7AA4 11 00 00     	ld de, 0
 746+ 7AA7 06 10        	ld b, SPT
 747+ 7AA9
 748+ 7AA9 CD 7B 7A     	call ReadDiskSectors
 749+ 7AAC C9           	ret
 750+ 7AAD
 751+ 7AAD              ;A = track
 752+ 7AAD              SeekTrack:
 753+ 7AAD              	IFUSED
 754+ 7AAD ~            	ld	(RWTSTrack), a
 755+ 7AAD ~            	ld 	a, RWTS_CMD_SEEK
 756+ 7AAD ~            	jp	RWTS
 757+ 7AAD              	ENDIF
 758+ 7AAD
 759+ 7AAD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 760+ 7AAD
 761+ 7AAD              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 762+ 7AAD              FindCache:
 763+ 7AAD 06 0B        	ld		b, NAMELEN
 764+ 7AAF CD 28 7A     	call	StrCmp			;find the file to wich this extension belongs
 765+ 7AB2 C8           	ret		z
 766+ 7AB3
 767+ 7AB3 0D           	dec		c
 768+ 7AB4 20 02        	jr		nz, CacheNotFinished
 769+ 7AB6 B1           	or		c
 770+ 7AB7 C9           	ret
 771+ 7AB8
 772+ 7AB8              CacheNotFinished:
 773+ 7AB8 01 19 00     	ld		bc, CACHE_SZ
 774+ 7ABB 09           	add		hl, bc			;to the next cache line
 775+ 7ABC 18 EF        	jr		FindCache
 776+ 7ABE
 777+ 7ABE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 778+ 7ABE
 779+ 7ABE              	;ld		ix, (SelFileCache)
 780+ 7ABE              ReadFileHeader:
 781+ 7ABE DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 782+ 7AC1 B7           	or		a
 783+ 7AC2 C0           	ret		nz				;return if already read
 784+ 7AC3
 785+ 7AC3 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 786+ 7AC6 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 787+ 7AC9 7C           	ld		a, h
 788+ 7ACA B5           	or		l
 789+ 7ACB 28 46        	jr		z, ReadHeaderEnd
 790+ 7ACD
 791+ 7ACD CD ED 77     	call	AU2TS
 792+ 7AD0 50           	ld		d, b
 793+ 7AD1 59           	ld		e, c
 794+ 7AD2 21 59 97     	ld		hl, DataBuf
 795+ 7AD5 DD E5        	push	ix
 796+ 7AD7 DD E5        	push	ix
 797+ 7AD9 CD C6 77     		call	ReadOneDiskSector
 798+ 7ADC E1           	pop		hl
 799+ 7ADD DD E1        	pop		ix
 800+ 7ADF
 801+ 7ADF E5           	push	hl
 802+ 7AE0 21 59 97     		ld		hl, DataBuf
 803+ 7AE3 CD 17 7B     		call	IsFileHeaderValid
 804+ 7AE6 E1           	pop		hl
 805+ 7AE7 B7           	or		a
 806+ 7AE8 28 14        	jr		z, ReadFileHeaderIsTextFile
 807+ 7AEA
 808+ 7AEA 01 10 00     	ld		bc, CACHE_HDR
 809+ 7AED 09           	add		hl, bc
 810+ 7AEE EB           	ex		hl, de
 811+ 7AEF 21 59 97     	ld		hl, DataBuf
 812+ 7AF2 01 09 00     	ld		bc, HDR_SZ
 813+ 7AF5 ED B0        	ldir
 814+ 7AF7
 815+ 7AF7              	;For text files, read file size as reported by BDOS, since we don't have a header.
 816+ 7AF7 3E 03        	ld		a, BYTE_TYPE
 817+ 7AF9 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 818+ 7AFC 30 15        	jr		nc, ReadHeaderEnd
 819+ 7AFE
 820+ 7AFE              ReadFileHeaderIsTextFile:
 821+ 7AFE DD E5        	push	ix
 822+ 7B00 DD E5        	push	ix
 823+ 7B02 E1           	pop		hl
 824+ 7B03 CD E6 7B     		call	GetFileSize
 825+ 7B06 DD E1        	pop		ix
 826+ 7B08 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 827+ 7B0B DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 828+ 7B0E 3E 04        	ld		a, TEXT_TYPE
 829+ 7B10 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 830+ 7B13
 831+ 7B13              ReadHeaderEnd:
 832+ 7B13 DD 34 0F     	inc		(ix + CACHE_FLAG)
 833+ 7B16 C9           	ret
 834+ 7B17
 835+ 7B17              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 836+ 7B17              ;Checks if the file header is valid. For now it checks to not have all 0s.
 837+ 7B17              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 838+ 7B17              ;In: HL = header
 839+ 7B17              ;Out: A > 0 if valid
 840+ 7B17              IsFileHeaderValid:
 841+ 7B17              	IFUSED
 842+ 7B17 AF           	xor		a
 843+ 7B18 06 09        	ld		b, HDR_SZ
 844+ 7B1A              IsFileHeaderValidLoop:
 845+ 7B1A B6           	or		(hl)
 846+ 7B1B 23           	inc		hl
 847+ 7B1C 10 FC        	djnz	IsFileHeaderValidLoop
 848+ 7B1E
 849+ 7B1E C9           	ret
 850+ 7B1F              	ENDIF
 851+ 7B1F
 852+ 7B1F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 853+ 7B1F
 854+ 7B1F              ;IN: HL = address from IF1 to call
 855+ 7B1F              IF1Call:
 856+ 7B1F 22 ED 5C     	LD   (HD11), HL
 857+ 7B22 CF           	RST  8
 858+ 7B23 32           	DEFB 50
 859+ 7B24 C9           	RET
 860+ 7B25
 861+ 7B25              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 862+ 7B25
 863+ 7B25              ;Load a program from disk
 864+ 7B25              ;IN: HL = file name addr
 865+ 7B25              LoadProgram:
 866+ 7B25 22 DC 5C     	LD   (FSTR1), HL
 867+ 7B28 26 00        	LD   H, 0
 868+ 7B2A 2E 0B        	LD   L, NAMELEN
 869+ 7B2C 22 DA 5C     	LD   (NSTR1), HL
 870+ 7B2F 3A 70 7B     	LD	 A, (RWTSDrive)
 871+ 7B32 3C           	INC  A					;Adapt for BASIC drive number
 872+ 7B33 6F           	LD   L, A
 873+ 7B34 22 D6 5C     	LD   (DSTR1), HL
 874+ 7B37 21 41 0A     	LD   HL, LOAD_ADDR
 875+ 7B3A CD 1F 7B     	CALL IF1Call
 876+ 7B3D C9           	RET
 877+ 7B3E
 878+ 7B3E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 879+ 7B3E
 880+ 7B3E              SetFastKeys:
 881+ 7B3E 3E 0A        	ld		a, 10
 882+ 7B40 32 09 5C     	ld		(REPDEL), a
 883+ 7B43 3E 01        	ld		a, 1
 884+ 7B45 32 0A 5C     	ld		(REPDEL+1),a
 885+ 7B48
 886+ 7B48 C9           	ret
 887+ 7B49
 888+ 7B49
 889+ 7B49              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890+ 7B49              ;Reads the error message string from IF1 ROM.
 891+ 7B49              GetErrMsg:
 892+ 7B49 3C           	inc		a
 893+ 7B4A 08           	ex		af, af'
 894+ 7B4B
 895+ 7B4B 21 51 7B     	ld		hl, IF1Paged			;page-in IF1
 896+ 7B4E C3 1F 7B     	jp		IF1Call
 897+ 7B51
 898+ 7B51              IF1Paged:
 899+ 7B51 21 60 02     	ld		hl, ERRMSG
 900+ 7B54 08           	ex		af, af'
 901+ 7B55 B7           	or		a
 902+ 7B56 28 0B        	jr		z, SaveMsg
 903+ 7B58
 904+ 7B58 06 00        	ld		b, 0
 905+ 7B5A              SearchMsgEnd:
 906+ 7B5A CB 7E        	bit		7, (hl)
 907+ 7B5C 23           	inc		hl
 908+ 7B5D 28 FB        	jr		z, SearchMsgEnd
 909+ 7B5F
 910+ 7B5F 04           	inc		b
 911+ 7B60 B8           	cp		b
 912+ 7B61 20 F7        	jr		nz, SearchMsgEnd
 913+ 7B63
 914+ 7B63              SaveMsg:
 915+ 7B63 11 59 97     	ld		de, DataBuf
 916+ 7B66              CopyMsg:
 917+ 7B66 7E           	ld		a, (hl)
 918+ 7B67 CB 7F        	bit		7, a
 919+ 7B69 12           	ld		(de), a
 920+ 7B6A 23           	inc		hl
 921+ 7B6B 13           	inc		de
 922+ 7B6C 28 F8        	jr		z, CopyMsg
 923+ 7B6E
 924+ 7B6E C9           	ret
 925+ 7B6F
 926+ 7B6F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 927+ 7B6F
 928+ 7B6F              ;RWTS routine I/O block
 929+ 7B6F              RWTSParams:
 930+ 7B6F 01           RWTSBlockType	DEFB	1							;?
 931+ 7B70 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 932+ 7B71 00           RWTSVolNo		DEFB	0							;?
 933+ 7B72 00           RWTSTrack		DEFB	0
 934+ 7B73 00           RWTSSector		DEFB	0
 935+ 7B74 00 00        RWTSDMA			DEFW	0
 936+ 7B76 32 29        RWTSExtBuf		DEFW	$2932
 937+ 7B78              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 938+ 7B78              	IFDEF _REAL_HW_
 939+ 7B78 82 7B        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 940+ 7B7A              	ELSE
 941+ 7B7A ~            RWTSPrmTbl		DEFW	$1f2a
 942+ 7B7A              	ENDIF
 943+ 7B7A 01           RWTSCmd			DEFB	RWTS_CMD_READ
 944+ 7B7B              ;Results
 945+ 7B7B 00           RWTSRes			DEFB	0
 946+ 7B7C 00           RWTSResVolNo	DEFB	0
 947+ 7B7D 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 947+ 7B81 00
 948+ 7B82
 949+ 7B82              ;Param. table, usualy found in ROM.
 950+ 7B82              	IFDEF _REAL_HW_
 951+ 7B82              BasPrmTbl:
 952+ 7B82
 953+ 7B82              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 954+ 7B82              	;DEFINE _STANDARD_DRIVE_PARAM_
 955+ 7B82              	IFDEF _STANDARD_DRIVE_PARAM_
 956+ 7B82 ~            PrmDevType		DEFB	$01
 957+ 7B82 ~            PrmStepRate		DEFB	$0D		;(milisec)
 958+ 7B82 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 959+ 7B82 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 960+ 7B82              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 961+ 7B82              PrmFastFactor	EQU		4
 962+ 7B82 01           PrmDevType		DEFB	$01
 963+ 7B83 03           PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 964+ 7B84 08           PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 965+ 7B85 19           PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 966+ 7B86              	ENDIF
 967+ 7B86
 968+ 7B86 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 969+ 7B88              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 970+ 7B88              	ENDIF
 971+ 7B88
 972+ 7B88              	endif
# file closed: if1.asm
1497  7B88              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7B88              ;BDOS functions - similar to CP/M
   2+ 7B88
   3+ 7B88              	IFNDEF	_BDOS_
   4+ 7B88              	DEFINE	_BDOS_
   5+ 7B88
   6+ 7B88              	include "if1.asm"
# file opened: if1.asm
   1++7B88              ;HC IF1 routines and constants
   2++7B88
   3++7B88              ;IF1 routines error codes, also returned by BASIC commands
   4++7B88              ;12 = Writing to a 'read' file
   5++7B88              ;13 = Reading a 'write' file
   6++7B88              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7B88              ;15 = Disk full (disk or catalog full)
   8++7B88              ;16 = Disk error (hardware error)
   9++7B88              ;17 = File not found
  10++7B88              ;23 = Disk R/O (disk change detected, software R/O)
  11++7B88              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7B88
  13++7B88              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7B88              ;00h = OK
  15++7B88              ;08h = cannot format disk
  16++7B88              ;10h = disk protected (read-only?)
  17++7B88              ;20h = volume error
  18++7B88              ;40h = drive error
  19++7B88              ;80h = reading error
  20++7B88              ;Codes I encountered:
  21++7B88              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7B88
  23++7B88
  24++7B88              	ifndef	_DISK_
  25++7B88 ~            	define	_DISK_
  26++7B88 ~
  27++7B88 ~            	include	"math.asm"
  28++7B88 ~
  29++7B88 ~            DRIVE_CUR_BAS	EQU 0
  30++7B88 ~            DRIVE_A_BAS		EQU	1
  31++7B88 ~            DRIVE_B_BAS		EQU	2
  32++7B88 ~            DRIVE_A_CPM		EQU	0
  33++7B88 ~            DRIVE_B_CPM		EQU	1
  34++7B88 ~            ;Disk geometry stuff
  35++7B88 ~            SPT				EQU	16			;sectors per track
  36++7B88 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7B88 ~            TRACK_CNT		EQU	80			;track count
  38++7B88 ~            HEAD_CNT		EQU	2			;disk face count
  39++7B88 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7B88 ~            EXT_SZ			EQU	32			;directory entry size
  41++7B88 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7B88 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7B88 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7B88 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7B88 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7B88 ~            REC_SZ			EQU 128			;cp/m record size
  47++7B88 ~            DEL_MARKER		EQU	$E5
  48++7B88 ~
  49++7B88 ~
  50++7B88 ~            ;Extension structure (directory entry)
  51++7B88 ~            EXT_DEL_FLAG	EQU	0
  52++7B88 ~            EXT_NAME		EQU 1
  53++7B88 ~            EXT_IDX			EQU 12
  54++7B88 ~            EXT_S1			EQU 13
  55++7B88 ~            EXT_S2			EQU 14
  56++7B88 ~            EXT_RC			EQU	15
  57++7B88 ~            EXT_AU0			EQU	16
  58++7B88 ~            EXT_AU1			EQU	18
  59++7B88 ~            EXT_AU2			EQU	20
  60++7B88 ~            EXT_AU3			EQU	22
  61++7B88 ~            EXT_AU4			EQU	24
  62++7B88 ~            EXT_AU5			EQU	26
  63++7B88 ~            EXT_AU6			EQU	28
  64++7B88 ~            EXT_AU7			EQU	30
  65++7B88 ~            EXT_SIZE		EQU 32
  66++7B88 ~
  67++7B88 ~            ;FCB structure
  68++7B88 ~            FCB_DRIVE		EQU 0
  69++7B88 ~            FCB_NAME		EQU EXT_NAME
  70++7B88 ~            FCB_EX_IDX		EQU EXT_IDX
  71++7B88 ~            FCB_S1			EQU EXT_S1
  72++7B88 ~            FCB_S2			EQU EXT_S2
  73++7B88 ~            FCB_RC			EQU	EXT_RC
  74++7B88 ~            FCB_AU			EQU	EXT_AU0
  75++7B88 ~            FCB_CR			EQU	32
  76++7B88 ~            FCB_R0			EQU 33
  77++7B88 ~            FCB_R1			EQU 34
  78++7B88 ~            FCB_R2			EQU 35
  79++7B88 ~            FCB_SIZE		EQU 36
  80++7B88 ~
  81++7B88 ~
  82++7B88 ~
  83++7B88 ~            ;System variables for disk
  84++7B88 ~            DSTR1			EQU	$5CD6		;drive
  85++7B88 ~            FSTR1			EQU	$5CDC		;file name
  86++7B88 ~            NSTR1			EQU	$5CDA		;name length
  87++7B88 ~            HD11			EQU	$5CED		;BDOS argument
  88++7B88 ~            COPIES			EQU	$5CEF		;BDOS function
  89++7B88 ~
  90++7B88 ~            ERRSP			EQU $5C3D
  91++7B88 ~            ERRNR			EQU $5C3A
  92++7B88 ~            ERRMSG			EQU	$0260
  93++7B88 ~
  94++7B88 ~            PROG			EQU $5C53
  95++7B88 ~            VARS			EQU	$5C4B
  96++7B88 ~            STKEND			EQU	$5C65
  97++7B88 ~
  98++7B88 ~            PRN_BUF			EQU	23296
  99++7B88 ~
 100++7B88 ~            REPDEL			EQU	23561
 101++7B88 ~            REPPER			EQU	23562
 102++7B88 ~            PIP			EQU	23609
 103++7B88 ~            LAST_K			EQU	$5C08
 104++7B88 ~
 105++7B88 ~
 106++7B88 ~            ;RWTS routine commands
 107++7B88 ~            RWTS_CMD_SEEK	EQU	0			;position head
 108++7B88 ~            RWTS_CMD_READ	EQU	1			;read sector
 109++7B88 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 110++7B88 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 111++7B88 ~
 112++7B88 ~
 113++7B88 ~            ;File name stuff
 114++7B88 ~            NAMELEN			EQU	11			;name length
 115++7B88 ~            RO_POS			EQU	8			;read-only attribute position in name
 116++7B88 ~            SYS_POS			EQU	9			;system attribute position in name
 117++7B88 ~
 118++7B88 ~            ;File types (first byte in header)
 119++7B88 ~            PROG_TYPE		EQU	0			;program
 120++7B88 ~            NUMB_TYPE		EQU	1			;number array
 121++7B88 ~            CHAR_TYPE		EQU	2			;char array
 122++7B88 ~            BYTE_TYPE		EQU	3			;bytes
 123++7B88 ~            TEXT_TYPE		EQU	4			;text, >= 4
 124++7B88 ~
 125++7B88 ~            ;File header offsets
 126++7B88 ~            HDR_TYPE		EQU	0
 127++7B88 ~            HDR_LEN			EQU 1
 128++7B88 ~            HDR_ADDR		EQU 3
 129++7B88 ~            HDR_PLEN		EQU	5
 130++7B88 ~            HDR_LINE		EQU 7
 131++7B88 ~            HDR_SZ			EQU	9
 132++7B88 ~
 133++7B88 ~            ;BASIC disk channel structure
 134++7B88 ~            CH_RW_FLAG		EQU 11
 135++7B88 ~            CH_FCB			EQU	12
 136++7B88 ~            CH_DATA			EQU	50
 137++7B88 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 138++7B88 ~
 139++7B88 ~            CACHE_NAME		EQU	0					;11B
 140++7B88 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 141++7B88 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 142++7B88 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 143++7B88 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 144++7B88 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 145++7B88 ~
 146++7B88 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 147++7B88 ~
 148++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 149++7B88 ~            IF1Init:
 150++7B88 ~            	rst		08
 151++7B88 ~            	defb	49		;create system variables
 152++7B88 ~            	ret
 153++7B88 ~
 154++7B88 ~            ;ReadWriteTrackSector
 155++7B88 ~            ;A=command: 0, 1, 2, 4
 156++7B88 ~            RWTS:
 157++7B88 ~            	ld (RWTSCmd), a
 158++7B88 ~            	ld hl, RWTSParams
 159++7B88 ~            	ld (HD11), hl
 160++7B88 ~            	rst 08
 161++7B88 ~            	DEFB 58
 162++7B88 ~            	ret
 163++7B88 ~
 164++7B88 ~
 165++7B88 ~            ;D = sector, E = track
 166++7B88 ~            ;HL = dma
 167++7B88 ~            ReadOneDiskSector:
 168++7B88 ~            	ld (RWTSDMA), hl
 169++7B88 ~            	ld (RWTSTrack), de
 170++7B88 ~            	;ld (RWTSDrive), a
 171++7B88 ~            	ld a, RWTS_CMD_READ
 172++7B88 ~            	jr	RWTS
 173++7B88 ~
 174++7B88 ~            ;D = sector, E = track
 175++7B88 ~            ;HL = dma
 176++7B88 ~            WriteOneDiskSector:
 177++7B88 ~            	ld (RWTSDMA), hl
 178++7B88 ~            	ld (RWTSTrack), de
 179++7B88 ~            	;ld (RWTSDrive), a
 180++7B88 ~            	ld a, RWTS_CMD_WRITE
 181++7B88 ~            	jr	RWTS
 182++7B88 ~
 183++7B88 ~            FormatDisk:
 184++7B88 ~            	ld		hl, DataBuf
 185++7B88 ~            	ld		(hl), DEL_MARKER
 186++7B88 ~            	ld 		(RWTSDMA), hl
 187++7B88 ~            	ld 		a, RWTS_CMD_FMT
 188++7B88 ~            	call	RWTS
 189++7B88 ~            	ld		a, (RWTSRes)
 190++7B88 ~            	ret
 191++7B88 ~
 192++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193++7B88 ~
 194++7B88 ~            ;Allocation unit no. to track/sector
 195++7B88 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 196++7B88 ~            ;IN:  HL=alloc. unit no.
 197++7B88 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 198++7B88 ~            AU2TS:
 199++7B88 ~            	ld c, SPT/SPAL
 200++7B88 ~            	call Div					;A = sector
 201++7B88 ~            	push af
 202++7B88 ~            		/*
 203++7B88 ~            		ld c, HEAD_CNT
 204++7B88 ~            		call Div				;L = track, A = head (0 or 1)
 205++7B88 ~            		*/
 206++7B88 ~            		xor a
 207++7B88 ~            		rr h
 208++7B88 ~            		rr l
 209++7B88 ~            		rr a
 210++7B88 ~
 211++7B88 ~            		ld c, l
 212++7B88 ~            		ld b, 0
 213++7B88 ~            		or a
 214++7B88 ~            		jr z, Track0
 215++7B88 ~            		ld b, SPT
 216++7B88 ~            Track0:
 217++7B88 ~            	pop af
 218++7B88 ~            	or a
 219++7B88 ~            	jr z, FirstAU
 220++7B88 ~            	ld a, SPAL
 221++7B88 ~            FirstAU:
 222++7B88 ~            	add a, b
 223++7B88 ~            	ld  b, a
 224++7B88 ~            	ret
 225++7B88 ~
 226++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 227++7B88 ~
 228++7B88 ~            ;Checks the allocation units number used in extension
 229++7B88 ~            ;IN:	IX = extension addr
 230++7B88 ~            ;OUT:	B = no. of allocation units used
 231++7B88 ~            ;		C = no. of records used in ext.
 232++7B88 ~            ;		HL = first alloc. unit no.
 233++7B88 ~            ;		DE = last alloc. unit no.
 234++7B88 ~            CheckExtAlloc:
 235++7B88 ~            	push ix
 236++7B88 ~            		ld bc, EXT_RC
 237++7B88 ~            		add ix, bc
 238++7B88 ~            		ld c, (ix)			;save rec. no.
 239++7B88 ~            		inc ix
 240++7B88 ~            		ld l, (ix)
 241++7B88 ~            		ld h, (ix + 1)
 242++7B88 ~            		ld b, EXT_AU_CNT
 243++7B88 ~            CheckAU:
 244++7B88 ~            		ld a, (ix)
 245++7B88 ~            		or (ix + 1)
 246++7B88 ~            		jr z, CheckAUEnd
 247++7B88 ~            		ld e, (ix)
 248++7B88 ~            		ld d, (ix + 1)
 249++7B88 ~            		inc ix
 250++7B88 ~            		inc ix
 251++7B88 ~            		djnz CheckAU
 252++7B88 ~            CheckAUEnd:
 253++7B88 ~            		ld a, EXT_AU_CNT
 254++7B88 ~            		sub b
 255++7B88 ~            		ld b, a
 256++7B88 ~            	pop ix
 257++7B88 ~            	ret
 258++7B88 ~
 259++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 260++7B88 ~
 261++7B88 ~            ;Input: TrackBuffer
 262++7B88 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 263++7B88 ~            ReadUsedBlocksList:
 264++7B88 ~            	ld		ix, TrackBuf			;source buffer
 265++7B88 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 266++7B88 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 267++7B88 ~            	ld		de, 2					;counter of used blocks, start with 2
 268++7B88 ~            	ld		(hl), e
 269++7B88 ~            	inc		hl
 270++7B88 ~            	ld		(hl), d
 271++7B88 ~            	inc		hl
 272++7B88 ~
 273++7B88 ~            	;Add blocks 0 and 1 for directory
 274++7B88 ~            	ld		de, 0
 275++7B88 ~            	ld		(hl), e
 276++7B88 ~            	inc		hl
 277++7B88 ~            	ld		(hl), d
 278++7B88 ~            	inc		hl
 279++7B88 ~
 280++7B88 ~            	inc		de
 281++7B88 ~            	ld		(hl), e
 282++7B88 ~            	inc		hl
 283++7B88 ~            	ld		(hl), d
 284++7B88 ~            	inc		hl
 285++7B88 ~
 286++7B88 ~            ReadUsedBlocksLoop:
 287++7B88 ~            	xor		a
 288++7B88 ~            	cp		(ix)
 289++7B88 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 290++7B88 ~
 291++7B88 ~            	push	ix
 292++7B88 ~            	push	bc
 293++7B88 ~            		ld		b, EXT_AU_CNT
 294++7B88 ~            		ld		de, EXT_AU0
 295++7B88 ~            		add		ix, de
 296++7B88 ~
 297++7B88 ~            ReadUsedBlocksLoop2:
 298++7B88 ~            		ld		e, (ix)
 299++7B88 ~            		ld		d, (ix+1)
 300++7B88 ~            		ld		a, e
 301++7B88 ~            		or		d
 302++7B88 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 303++7B88 ~
 304++7B88 ~            		ld		(hl), e
 305++7B88 ~            		inc		hl
 306++7B88 ~            		ld		(hl), d
 307++7B88 ~            		inc		hl
 308++7B88 ~
 309++7B88 ~            		inc		ix
 310++7B88 ~            		inc		ix
 311++7B88 ~
 312++7B88 ~            		ld		de, (UsedBlockListCnt)
 313++7B88 ~            		inc		de
 314++7B88 ~            		ld		(UsedBlockListCnt), de
 315++7B88 ~
 316++7B88 ~            		djnz	ReadUsedBlocksLoop2
 317++7B88 ~
 318++7B88 ~
 319++7B88 ~            ReadUsedBlocksSkip:
 320++7B88 ~            	pop		bc
 321++7B88 ~            	pop		ix
 322++7B88 ~            ReadUsedBlocksSkip2:
 323++7B88 ~            	ld		de, EXT_SZ
 324++7B88 ~            	add		ix, de
 325++7B88 ~
 326++7B88 ~            	dec		bc
 327++7B88 ~            	ld		a, b
 328++7B88 ~            	or		c
 329++7B88 ~            	jr		nz, ReadUsedBlocksLoop
 330++7B88 ~
 331++7B88 ~            	ret
 332++7B88 ~
 333++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 334++7B88 ~            ;Reads 8 sectors for an AU
 335++7B88 ~            ;HL = block number, DE = destination buffer
 336++7B88 ~            ReadFSBlock:
 337++7B88 ~            	push	de
 338++7B88 ~            		call	AU2TS		;B=sector, C=track
 339++7B88 ~            	pop		hl				;HL=dest
 340++7B88 ~
 341++7B88 ~            	ld		d, b
 342++7B88 ~            	ld		e, c
 343++7B88 ~            	ld		b, SPAL
 344++7B88 ~
 345++7B88 ~            	call	ReadDiskSectors
 346++7B88 ~            	ret
 347++7B88 ~
 348++7B88 ~
 349++7B88 ~            ;Write 8 sectors for an AU
 350++7B88 ~            ;HL = block number, DE = source buffer
 351++7B88 ~            WriteFSBlock:
 352++7B88 ~            	push	de
 353++7B88 ~            		call	AU2TS		;B=sector, C=track
 354++7B88 ~            	pop		hl				;HL=dest
 355++7B88 ~
 356++7B88 ~            	ld		d, b
 357++7B88 ~            	ld		e, c
 358++7B88 ~            	ld		b, SPAL
 359++7B88 ~
 360++7B88 ~            	call	WriteDiskSectors
 361++7B88 ~            	ret
 362++7B88 ~
 363++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364++7B88 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 365++7B88 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366++7B88 ~            CopyDisk:
 367++7B88 ~            	;Get list of used blocks in current disk, max 632 bytes
 368++7B88 ~            	call	ReadUsedBlocksList
 369++7B88 ~            	ld		ix, UsedBlockListBlk
 370++7B88 ~
 371++7B88 ~            CopyDiskLoop:
 372++7B88 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373++7B88 ~            	ld		de, MsgBlocksLeft
 374++7B88 ~            	call	Byte2Txt
 375++7B88 ~            	ld		hl, MsgBlocksLeft
 376++7B88 ~            	ld		de, LST_LINE_MSG + 1 << 8
 377++7B88 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 378++7B88 ~            	call	PrintStrClr
 379++7B88 ~
 380++7B88 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381++7B88 ~            	ld		hl, MAX_AU_RAM
 382++7B88 ~            	ld		bc, (UsedBlockListCnt)
 383++7B88 ~            	or		a
 384++7B88 ~            	sbc		hl, bc
 385++7B88 ~            	jr		nc, CopyDiskLoopRead
 386++7B88 ~            	ld		bc, MAX_AU_RAM
 387++7B88 ~
 388++7B88 ~            CopyDiskLoopRead:
 389++7B88 ~            	ld		b, c
 390++7B88 ~            	ld		de, CopyDiskBuf
 391++7B88 ~            	;save initial counter and initial block number array position
 392++7B88 ~            	push	bc
 393++7B88 ~            	push	ix
 394++7B88 ~
 395++7B88 ~            CopyDiskLoopReadLoop:
 396++7B88 ~            		ld		l, (ix)
 397++7B88 ~            		ld		h, (ix+1)
 398++7B88 ~            		inc		ix
 399++7B88 ~            		inc		ix
 400++7B88 ~
 401++7B88 ~            		push	de
 402++7B88 ~            		push	bc
 403++7B88 ~            			call	ReadFSBlock			;Stop on error or continue?
 404++7B88 ~            		pop		bc
 405++7B88 ~            		pop		de
 406++7B88 ~
 407++7B88 ~            		;+2048
 408++7B88 ~            		ld		a, d
 409++7B88 ~            		add		8
 410++7B88 ~            		ld		d, a
 411++7B88 ~
 412++7B88 ~            		djnz	CopyDiskLoopReadLoop
 413++7B88 ~
 414++7B88 ~            		;Check if selection is 1=single drive or 2=dual drive
 415++7B88 ~            		ld		a, (CopySelOption)
 416++7B88 ~            		cp		'1'
 417++7B88 ~            		jr		nz, CopyDiskDualDrive1
 418++7B88 ~
 419++7B88 ~            		;Prompt for disk change
 420++7B88 ~            		call	PromptDiskChangeDst
 421++7B88 ~            		ld		a, (RWTSDrive)
 422++7B88 ~            		call	BDOSInit
 423++7B88 ~            		jr		CopyDiskReadEnd
 424++7B88 ~
 425++7B88 ~            CopyDiskDualDrive1:
 426++7B88 ~            		;alternate drive
 427++7B88 ~            		ld		a, (RWTSDrive)
 428++7B88 ~            		inc 	a
 429++7B88 ~            		xor		%11
 430++7B88 ~            		dec		a
 431++7B88 ~            		ld		(RWTSDrive), a
 432++7B88 ~
 433++7B88 ~            CopyDiskReadEnd:
 434++7B88 ~            	;restore initial counter and initial block number array position
 435++7B88 ~            	pop		ix
 436++7B88 ~            	pop		bc
 437++7B88 ~            	ld		de, CopyDiskBuf
 438++7B88 ~            	push	bc
 439++7B88 ~
 440++7B88 ~            CopyDiskLoopWriteLoop:
 441++7B88 ~            		ld		l, (ix)
 442++7B88 ~            		ld		h, (ix+1)
 443++7B88 ~            		inc		ix
 444++7B88 ~            		inc		ix
 445++7B88 ~
 446++7B88 ~            		push	de
 447++7B88 ~            		push	bc
 448++7B88 ~            			call	WriteFSBlock		;Stop on error or continue?
 449++7B88 ~            		pop		bc
 450++7B88 ~            		pop		de
 451++7B88 ~
 452++7B88 ~            		;+2048
 453++7B88 ~            		ld		a, d
 454++7B88 ~            		add		8
 455++7B88 ~            		ld		d, a
 456++7B88 ~
 457++7B88 ~            		djnz	CopyDiskLoopWriteLoop
 458++7B88 ~
 459++7B88 ~            CopyDiskWriteEnd:
 460++7B88 ~            	pop		bc
 461++7B88 ~            	ld		c, b
 462++7B88 ~            	ld		b, 0
 463++7B88 ~
 464++7B88 ~            	;Decrease number of blocks read by now.
 465++7B88 ~            	ld		hl, (UsedBlockListCnt)
 466++7B88 ~            	or		a
 467++7B88 ~            	sbc		hl, bc
 468++7B88 ~            	ld		(UsedBlockListCnt), hl
 469++7B88 ~
 470++7B88 ~            	ld		a, l
 471++7B88 ~            	or		h
 472++7B88 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 473++7B88 ~
 474++7B88 ~            	;Check if selection is 1=single drive or 2=dual drive
 475++7B88 ~            	ld		a, (CopySelOption)
 476++7B88 ~            	cp		'1'
 477++7B88 ~            	jr		nz, CopyDiskDualDrive2
 478++7B88 ~
 479++7B88 ~            	;Prompt for disk change
 480++7B88 ~            	call	PromptDiskChangeSrc
 481++7B88 ~            	ld		a, (RWTSDrive)
 482++7B88 ~            	call	BDOSInit
 483++7B88 ~            	jp		CopyDiskLoop
 484++7B88 ~
 485++7B88 ~            CopyDiskDualDrive2:
 486++7B88 ~            	;alternate drive again
 487++7B88 ~            	ld		a, (RWTSDrive)
 488++7B88 ~            	inc		a
 489++7B88 ~            	xor		%11
 490++7B88 ~            	dec		a
 491++7B88 ~            	ld		(RWTSDrive), a
 492++7B88 ~            	jp		CopyDiskLoop
 493++7B88 ~
 494++7B88 ~            CopyDiskEnd:
 495++7B88 ~            	ld		b, 1
 496++7B88 ~            	call	ClearNMsgLines
 497++7B88 ~            	ret
 498++7B88 ~
 499++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 500++7B88 ~            ;Copies the current disk blocks to COM port.
 501++7B88 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 502++7B88 ~            CopyDiskToCOM:
 503++7B88 ~            	;Get list of used blocks in current disk, max 632 bytes
 504++7B88 ~            	call	ReadUsedBlocksList
 505++7B88 ~
 506++7B88 ~            	;Send block count and block indexes
 507++7B88 ~            	ld		hl, (UsedBlockListCnt)
 508++7B88 ~            	add		hl, hl
 509++7B88 ~            	inc		hl
 510++7B88 ~            	inc		hl
 511++7B88 ~            	ld		b, h
 512++7B88 ~            	ld		c, l
 513++7B88 ~            	ld		hl, UsedBlockListCnt
 514++7B88 ~            	call	SERTB
 515++7B88 ~
 516++7B88 ~            	ld		ix, UsedBlockListBlk
 517++7B88 ~
 518++7B88 ~            CopyDiskToCOMLoop:
 519++7B88 ~            	;Print block count left
 520++7B88 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 521++7B88 ~            	ld		de, MsgBlocksLeft
 522++7B88 ~            	call	Byte2Txt
 523++7B88 ~            	ld		hl, MsgBlocksLeft
 524++7B88 ~            	ld		de, LST_LINE_MSG + 1 << 8
 525++7B88 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 526++7B88 ~            	call	PrintStrClr
 527++7B88 ~
 528++7B88 ~            	;Read block into buffer
 529++7B88 ~            	ld		l, (ix)
 530++7B88 ~            	ld		h, (ix+1)
 531++7B88 ~            	ld		de, CopyDiskBuf
 532++7B88 ~            	push	ix
 533++7B88 ~            		call	ReadFSBlock
 534++7B88 ~            	pop		ix
 535++7B88 ~            	inc		ix
 536++7B88 ~            	inc		ix
 537++7B88 ~
 538++7B88 ~            	;Send block buffer
 539++7B88 ~            	ld		hl, CopyDiskBuf
 540++7B88 ~            	ld		bc, AU_SZ
 541++7B88 ~            	call	SERTB
 542++7B88 ~
 543++7B88 ~            	ld		bc, (UsedBlockListCnt)
 544++7B88 ~            	dec		bc
 545++7B88 ~            	ld		(UsedBlockListCnt), bc
 546++7B88 ~
 547++7B88 ~            	push	ix
 548++7B88 ~            		call	KbdHit
 549++7B88 ~            	pop		ix
 550++7B88 ~            	ret		c
 551++7B88 ~
 552++7B88 ~            	ld		a, b
 553++7B88 ~            	or		c
 554++7B88 ~            	jr		nz, CopyDiskToCOMLoop
 555++7B88 ~
 556++7B88 ~            	ret
 557++7B88 ~
 558++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 559++7B88 ~            CopyDiskFromCOM:
 560++7B88 ~            	;Receive block count.
 561++7B88 ~            	ld		hl, UsedBlockListCnt
 562++7B88 ~            	ld		bc, 2
 563++7B88 ~            	ld		e, 0
 564++7B88 ~            	call	SERRB
 565++7B88 ~
 566++7B88 ~            	;Receive block indexes.
 567++7B88 ~            	ld		hl, (UsedBlockListCnt)
 568++7B88 ~            	add		hl, hl
 569++7B88 ~            	ld		b, h
 570++7B88 ~            	ld		c, l
 571++7B88 ~            	ld		hl, UsedBlockListBlk
 572++7B88 ~            	ld		e, 0
 573++7B88 ~            	call	SERRB
 574++7B88 ~
 575++7B88 ~            	;Read each block by index and write to disk
 576++7B88 ~            	ld		ix, UsedBlockListBlk
 577++7B88 ~
 578++7B88 ~            CopyDiskFromCOMLoop:
 579++7B88 ~            	;Print block count left
 580++7B88 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 581++7B88 ~            	ld		de, MsgBlocksLeft
 582++7B88 ~            	call	Byte2Txt
 583++7B88 ~            	ld		hl, MsgBlocksLeft
 584++7B88 ~            	ld		de, LST_LINE_MSG + 1 << 8
 585++7B88 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 586++7B88 ~            	call	PrintStrClr
 587++7B88 ~
 588++7B88 ~            	;Read block buffer
 589++7B88 ~            	ld		hl, CopyDiskBuf
 590++7B88 ~            	ld		bc, AU_SZ
 591++7B88 ~            	ld		e, 0
 592++7B88 ~            	call	SERRB
 593++7B88 ~
 594++7B88 ~            	;Write block to disk
 595++7B88 ~            	ld		l, (ix)
 596++7B88 ~            	ld		h, (ix+1)
 597++7B88 ~            	ld		de, CopyDiskBuf
 598++7B88 ~            	push	ix
 599++7B88 ~            		call	WriteFSBlock			;Stop on error or continue?
 600++7B88 ~            	pop		ix
 601++7B88 ~            	inc		ix
 602++7B88 ~            	inc		ix
 603++7B88 ~
 604++7B88 ~            	ld		bc, (UsedBlockListCnt)
 605++7B88 ~            	dec		bc
 606++7B88 ~            	ld		(UsedBlockListCnt), bc
 607++7B88 ~
 608++7B88 ~            	push	ix
 609++7B88 ~            		call	KbdHit
 610++7B88 ~            	pop		ix
 611++7B88 ~            	ret		c
 612++7B88 ~
 613++7B88 ~            	ld		a, b
 614++7B88 ~            	or		c
 615++7B88 ~            	jr		nz, CopyDiskFromCOMLoop
 616++7B88 ~            	ret
 617++7B88 ~
 618++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619++7B88 ~
 620++7B88 ~            ;Compare string at HL with the one at DE, max length B
 621++7B88 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 622++7B88 ~            ;OUT: z flag, set = match, reset = mismatch
 623++7B88 ~            StrCmp:
 624++7B88 ~            	push hl
 625++7B88 ~            	push de
 626++7B88 ~            Compare:
 627++7B88 ~            		ld a, (de)
 628++7B88 ~            		cp (hl)
 629++7B88 ~            		jr nz, MisMatch
 630++7B88 ~            		inc hl
 631++7B88 ~            		inc de
 632++7B88 ~            		djnz Compare
 633++7B88 ~            MisMatch:
 634++7B88 ~            	pop de
 635++7B88 ~            	pop hl
 636++7B88 ~            	ret
 637++7B88 ~
 638++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 639++7B88 ~
 640++7B88 ~            ;Read a file into a buffer, sector by sector.
 641++7B88 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 642++7B88 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 643++7B88 ~            ;In: HL = Name address, DE = buffer
 644++7B88 ~            IF1FileLoad:
 645++7B88 ~            	push	de
 646++7B88 ~            		ld (FSTR1), hl
 647++7B88 ~            		ld h, 0
 648++7B88 ~            		ld a, (RWTSDrive)
 649++7B88 ~            		inc  a			;CP/M drive number to BASIC drive number
 650++7B88 ~            		ld	l, a
 651++7B88 ~            		ld (DSTR1), hl
 652++7B88 ~            		ld l,NAMELEN
 653++7B88 ~            		ld (NSTR1), hl
 654++7B88 ~            		rst 08
 655++7B88 ~            		DEFB 51			;open disk channel
 656++7B88 ~
 657++7B88 ~            		rst		8
 658++7B88 ~            		defb	53		;read sector
 659++7B88 ~            	pop		de
 660++7B88 ~            	jr		nc, FileFree
 661++7B88 ~
 662++7B88 ~            	ld		a, (ix + CH_DATA)
 663++7B88 ~            	cp		TEXT_TYPE
 664++7B88 ~            	jr		nc, FileLoadNoHeader
 665++7B88 ~
 666++7B88 ~            FileLoadHeader:
 667++7B88 ~            	push	ix
 668++7B88 ~            	pop		hl
 669++7B88 ~            	ld		bc, CH_DATA + HDR_SZ
 670++7B88 ~            	add		hl, bc
 671++7B88 ~            	ld		bc, SECT_SZ - HDR_SZ
 672++7B88 ~            	ldir
 673++7B88 ~
 674++7B88 ~            FileReadLoop:
 675++7B88 ~            	push	de
 676++7B88 ~            		rst		8
 677++7B88 ~            		defb	53		;read sector
 678++7B88 ~            	pop		de
 679++7B88 ~            	jr		nc, FileFree
 680++7B88 ~
 681++7B88 ~            FileLoadNoHeader:
 682++7B88 ~            	push	ix
 683++7B88 ~            	pop		hl
 684++7B88 ~            	ld		bc, CH_DATA
 685++7B88 ~            	add		hl, bc
 686++7B88 ~            	ld		bc, SECT_SZ
 687++7B88 ~            	ldir
 688++7B88 ~            	jr		FileReadLoop
 689++7B88 ~
 690++7B88 ~            FileFree:
 691++7B88 ~            	push	de
 692++7B88 ~            	rst		8
 693++7B88 ~            	defb	56			;close channel (52) or detroy channel (56)
 694++7B88 ~            	pop		de
 695++7B88 ~            	ret
 696++7B88 ~            IF1FileLoadEnd:
 697++7B88 ~
 698++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 699++7B88 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 700++7B88 ~            ;Out: A = error code, 0=OK
 701++7B88 ~            ReadDiskSectors:
 702++7B88 ~            	push bc
 703++7B88 ~            		push hl
 704++7B88 ~            			push de
 705++7B88 ~            				call ReadOneDiskSector
 706++7B88 ~            			pop de
 707++7B88 ~            		pop hl
 708++7B88 ~
 709++7B88 ~            		inc d
 710++7B88 ~            		inc h
 711++7B88 ~            	pop bc
 712++7B88 ~
 713++7B88 ~            	ld	a, (RWTSRes)
 714++7B88 ~            	or	a
 715++7B88 ~            	ret nz
 716++7B88 ~
 717++7B88 ~            	djnz ReadDiskSectors
 718++7B88 ~            	ret
 719++7B88 ~
 720++7B88 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 721++7B88 ~            ;Out: A = error code, 0=OK
 722++7B88 ~            WriteDiskSectors:
 723++7B88 ~            	push bc
 724++7B88 ~            		push hl
 725++7B88 ~            			push de
 726++7B88 ~            				call WriteOneDiskSector
 727++7B88 ~            			pop de
 728++7B88 ~            		pop hl
 729++7B88 ~
 730++7B88 ~            		inc d
 731++7B88 ~            		inc h
 732++7B88 ~            	pop bc
 733++7B88 ~
 734++7B88 ~            	ld	a, (RWTSRes)
 735++7B88 ~            	or	a
 736++7B88 ~            	ret nz
 737++7B88 ~
 738++7B88 ~            	djnz WriteDiskSectors
 739++7B88 ~            	ret
 740++7B88 ~
 741++7B88 ~
 742++7B88 ~            ;Reads disk catalog
 743++7B88 ~            ReadCatalogTrack:
 744++7B88 ~            	ld hl, TrackBuf
 745++7B88 ~            	ld de, 0
 746++7B88 ~            	ld b, SPT
 747++7B88 ~
 748++7B88 ~            	call ReadDiskSectors
 749++7B88 ~            	ret
 750++7B88 ~
 751++7B88 ~            ;A = track
 752++7B88 ~            SeekTrack:
 753++7B88 ~            	IFUSED
 754++7B88 ~            	ld	(RWTSTrack), a
 755++7B88 ~            	ld 	a, RWTS_CMD_SEEK
 756++7B88 ~            	jp	RWTS
 757++7B88 ~            	ENDIF
 758++7B88 ~
 759++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 760++7B88 ~
 761++7B88 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 762++7B88 ~            FindCache:
 763++7B88 ~            	ld		b, NAMELEN
 764++7B88 ~            	call	StrCmp			;find the file to wich this extension belongs
 765++7B88 ~            	ret		z
 766++7B88 ~
 767++7B88 ~            	dec		c
 768++7B88 ~            	jr		nz, CacheNotFinished
 769++7B88 ~            	or		c
 770++7B88 ~            	ret
 771++7B88 ~
 772++7B88 ~            CacheNotFinished:
 773++7B88 ~            	ld		bc, CACHE_SZ
 774++7B88 ~            	add		hl, bc			;to the next cache line
 775++7B88 ~            	jr		FindCache
 776++7B88 ~
 777++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 778++7B88 ~
 779++7B88 ~            	;ld		ix, (SelFileCache)
 780++7B88 ~            ReadFileHeader:
 781++7B88 ~            	ld		a, (ix + CACHE_FLAG)
 782++7B88 ~            	or		a
 783++7B88 ~            	ret		nz				;return if already read
 784++7B88 ~
 785++7B88 ~            	ld		l, (ix + CACHE_FIRST_AU)
 786++7B88 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 787++7B88 ~            	ld		a, h
 788++7B88 ~            	or		l
 789++7B88 ~            	jr		z, ReadHeaderEnd
 790++7B88 ~
 791++7B88 ~            	call	AU2TS
 792++7B88 ~            	ld		d, b
 793++7B88 ~            	ld		e, c
 794++7B88 ~            	ld		hl, DataBuf
 795++7B88 ~            	push	ix
 796++7B88 ~            	push	ix
 797++7B88 ~            		call	ReadOneDiskSector
 798++7B88 ~            	pop		hl
 799++7B88 ~            	pop		ix
 800++7B88 ~
 801++7B88 ~            	push	hl
 802++7B88 ~            		ld		hl, DataBuf
 803++7B88 ~            		call	IsFileHeaderValid
 804++7B88 ~            	pop		hl
 805++7B88 ~            	or		a
 806++7B88 ~            	jr		z, ReadFileHeaderIsTextFile
 807++7B88 ~
 808++7B88 ~            	ld		bc, CACHE_HDR
 809++7B88 ~            	add		hl, bc
 810++7B88 ~            	ex		hl, de
 811++7B88 ~            	ld		hl, DataBuf
 812++7B88 ~            	ld		bc, HDR_SZ
 813++7B88 ~            	ldir
 814++7B88 ~
 815++7B88 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 816++7B88 ~            	ld		a, BYTE_TYPE
 817++7B88 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 818++7B88 ~            	jr		nc, ReadHeaderEnd
 819++7B88 ~
 820++7B88 ~            ReadFileHeaderIsTextFile:
 821++7B88 ~            	push	ix
 822++7B88 ~            	push	ix
 823++7B88 ~            	pop		hl
 824++7B88 ~            		call	GetFileSize
 825++7B88 ~            	pop		ix
 826++7B88 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 827++7B88 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 828++7B88 ~            	ld		a, TEXT_TYPE
 829++7B88 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 830++7B88 ~
 831++7B88 ~            ReadHeaderEnd:
 832++7B88 ~            	inc		(ix + CACHE_FLAG)
 833++7B88 ~            	ret
 834++7B88 ~
 835++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 836++7B88 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 837++7B88 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 838++7B88 ~            ;In: HL = header
 839++7B88 ~            ;Out: A > 0 if valid
 840++7B88 ~            IsFileHeaderValid:
 841++7B88 ~            	IFUSED
 842++7B88 ~            	xor		a
 843++7B88 ~            	ld		b, HDR_SZ
 844++7B88 ~            IsFileHeaderValidLoop:
 845++7B88 ~            	or		(hl)
 846++7B88 ~            	inc		hl
 847++7B88 ~            	djnz	IsFileHeaderValidLoop
 848++7B88 ~
 849++7B88 ~            	ret
 850++7B88 ~            	ENDIF
 851++7B88 ~
 852++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 853++7B88 ~
 854++7B88 ~            ;IN: HL = address from IF1 to call
 855++7B88 ~            IF1Call:
 856++7B88 ~            	LD   (HD11), HL
 857++7B88 ~            	RST  8
 858++7B88 ~            	DEFB 50
 859++7B88 ~            	RET
 860++7B88 ~
 861++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 862++7B88 ~
 863++7B88 ~            ;Load a program from disk
 864++7B88 ~            ;IN: HL = file name addr
 865++7B88 ~            LoadProgram:
 866++7B88 ~            	LD   (FSTR1), HL
 867++7B88 ~            	LD   H, 0
 868++7B88 ~            	LD   L, NAMELEN
 869++7B88 ~            	LD   (NSTR1), HL
 870++7B88 ~            	LD	 A, (RWTSDrive)
 871++7B88 ~            	INC  A					;Adapt for BASIC drive number
 872++7B88 ~            	LD   L, A
 873++7B88 ~            	LD   (DSTR1), HL
 874++7B88 ~            	LD   HL, LOAD_ADDR
 875++7B88 ~            	CALL IF1Call
 876++7B88 ~            	RET
 877++7B88 ~
 878++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 879++7B88 ~
 880++7B88 ~            SetFastKeys:
 881++7B88 ~            	ld		a, 10
 882++7B88 ~            	ld		(REPDEL), a
 883++7B88 ~            	ld		a, 1
 884++7B88 ~            	ld		(REPDEL+1),a
 885++7B88 ~
 886++7B88 ~            	ret
 887++7B88 ~
 888++7B88 ~
 889++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890++7B88 ~            ;Reads the error message string from IF1 ROM.
 891++7B88 ~            GetErrMsg:
 892++7B88 ~            	inc		a
 893++7B88 ~            	ex		af, af'
 894++7B88 ~
 895++7B88 ~            	ld		hl, IF1Paged			;page-in IF1
 896++7B88 ~            	jp		IF1Call
 897++7B88 ~
 898++7B88 ~            IF1Paged:
 899++7B88 ~            	ld		hl, ERRMSG
 900++7B88 ~            	ex		af, af'
 901++7B88 ~            	or		a
 902++7B88 ~            	jr		z, SaveMsg
 903++7B88 ~
 904++7B88 ~            	ld		b, 0
 905++7B88 ~            SearchMsgEnd:
 906++7B88 ~            	bit		7, (hl)
 907++7B88 ~            	inc		hl
 908++7B88 ~            	jr		z, SearchMsgEnd
 909++7B88 ~
 910++7B88 ~            	inc		b
 911++7B88 ~            	cp		b
 912++7B88 ~            	jr		nz, SearchMsgEnd
 913++7B88 ~
 914++7B88 ~            SaveMsg:
 915++7B88 ~            	ld		de, DataBuf
 916++7B88 ~            CopyMsg:
 917++7B88 ~            	ld		a, (hl)
 918++7B88 ~            	bit		7, a
 919++7B88 ~            	ld		(de), a
 920++7B88 ~            	inc		hl
 921++7B88 ~            	inc		de
 922++7B88 ~            	jr		z, CopyMsg
 923++7B88 ~
 924++7B88 ~            	ret
 925++7B88 ~
 926++7B88 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 927++7B88 ~
 928++7B88 ~            ;RWTS routine I/O block
 929++7B88 ~            RWTSParams:
 930++7B88 ~            RWTSBlockType	DEFB	1							;?
 931++7B88 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 932++7B88 ~            RWTSVolNo		DEFB	0							;?
 933++7B88 ~            RWTSTrack		DEFB	0
 934++7B88 ~            RWTSSector		DEFB	0
 935++7B88 ~            RWTSDMA			DEFW	0
 936++7B88 ~            RWTSExtBuf		DEFW	$2932
 937++7B88 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 938++7B88 ~            	IFDEF _REAL_HW_
 939++7B88 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 940++7B88 ~            	ELSE
 941++7B88 ~            RWTSPrmTbl		DEFW	$1f2a
 942++7B88 ~            	ENDIF
 943++7B88 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 944++7B88 ~            ;Results
 945++7B88 ~            RWTSRes			DEFB	0
 946++7B88 ~            RWTSResVolNo	DEFB	0
 947++7B88 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 948++7B88 ~
 949++7B88 ~            ;Param. table, usualy found in ROM.
 950++7B88 ~            	IFDEF _REAL_HW_
 951++7B88 ~            BasPrmTbl:
 952++7B88 ~
 953++7B88 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 954++7B88 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 955++7B88 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 956++7B88 ~            PrmDevType		DEFB	$01
 957++7B88 ~            PrmStepRate		DEFB	$0D		;(milisec)
 958++7B88 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 959++7B88 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 960++7B88 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 961++7B88 ~            PrmFastFactor	EQU		4
 962++7B88 ~            PrmDevType		DEFB	$01
 963++7B88 ~            PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 964++7B88 ~            PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 965++7B88 ~            PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 966++7B88 ~            	ENDIF
 967++7B88 ~
 968++7B88 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 969++7B88 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 970++7B88 ~            	ENDIF
 971++7B88 ~
 972++7B88              	endif
# file closed: if1.asm
   7+ 7B88
   8+ 7B88              BDOSInit:
   9+ 7B88 AF           	xor		a
  10+ 7B89 18 49        	jr		BDOS
  11+ 7B8B
  12+ 7B8B
  13+ 7B8B              ;IN: A = Drive to select
  14+ 7B8B              BDOSSelectDisk:
  15+ 7B8B              	IFUSED
  16+ 7B8B DD 6F        	ld		ixl, a
  17+ 7B8D DD 26 00     	ld		ixh, 0
  18+ 7B90 3E 01        	ld		a, 1
  19+ 7B92 18 40        	jr		BDOS
  20+ 7B94              	ENDIF
  21+ 7B94
  22+ 7B94
  23+ 7B94              BDOSMakeDiskRO:
  24+ 7B94              	IFUSED
  25+ 7B94 ~            	ld		a, 15
  26+ 7B94 ~            	jr		BDOS
  27+ 7B94              	ENDIF
  28+ 7B94
  29+ 7B94              ;Get Read Only flag
  30+ 7B94              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 7B94              BDOSGetDiskRO:
  32+ 7B94              	IFUSED
  33+ 7B94 ~            	ld	a, 16
  34+ 7B94 ~            	jr	BDOS
  35+ 7B94              	ENDIF
  36+ 7B94
  37+ 7B94              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 7B94              BDOSGetCurrentDrive:
  39+ 7B94              	IFUSED
  40+ 7B94 3E 0C        	ld		a, 12
  41+ 7B96 18 3C        	jr		BDOS
  42+ 7B98              	ENDIF
  43+ 7B98
  44+ 7B98              ;Does log-off for all drives?
  45+ 7B98              BDOSCloseDrives:
  46+ 7B98              	IFUSED
  47+ 7B98 ~            	ld		ixl, a
  48+ 7B98 ~            	ld		ixh, 0
  49+ 7B98 ~            	ld		a, 22
  50+ 7B98 ~            	jr		BDOS
  51+ 7B98              	ENDIF
  52+ 7B98
  53+ 7B98              ;Create a disk channel for BDOS access (does not open the file)
  54+ 7B98              ;IN: HL=name addr, A=drive
  55+ 7B98              ;OUT: IX=FCB
  56+ 7B98              CreateChannel:
  57+ 7B98 22 DC 5C     	ld (FSTR1), hl
  58+ 7B9B 26 00        	ld h,0
  59+ 7B9D 6F           	ld l,a
  60+ 7B9E 22 D6 5C     	ld (DSTR1), hl
  61+ 7BA1 2E 0B        	ld l,NAMELEN
  62+ 7BA3 22 DA 5C     	ld (NSTR1), hl
  63+ 7BA6 CF           	rst 08
  64+ 7BA7 37           	DEFB 55
  65+ 7BA8 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 7BAB DD 09        	add ix, bc
  67+ 7BAD C9           	ret
  68+ 7BAE
  69+ 7BAE
  70+ 7BAE              ;Destroy a BDOS channel
  71+ 7BAE              ;IN: IX=FCB
  72+ 7BAE              DestroyChannel:
  73+ 7BAE C5           	push bc
  74+ 7BAF 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 7BB2 DD 09        	add ix, bc
  76+ 7BB4 CF           	rst 08
  77+ 7BB5 38           	DEFB 56
  78+ 7BB6 C1           	pop bc
  79+ 7BB7 C9           	ret
  80+ 7BB8
  81+ 7BB8
  82+ 7BB8              ;Input: IX=FCB
  83+ 7BB8              BDOSCreateFile:
  84+ 7BB8 3E 09        	ld	a, 9
  85+ 7BBA 18 18        	jr	BDOS
  86+ 7BBC
  87+ 7BBC              ;Input: IX=FCB
  88+ 7BBC              BDOSOpenFile:
  89+ 7BBC 3E 02        	ld	a, 2
  90+ 7BBE 18 14        	jr	BDOS
  91+ 7BC0
  92+ 7BC0              ;IN: IX=FCB
  93+ 7BC0              BDOSCloseFile:
  94+ 7BC0 3E 03        	ld	a, 3
  95+ 7BC2 18 10        	jr	BDOS
  96+ 7BC4
  97+ 7BC4
  98+ 7BC4              ;0 OK,
  99+ 7BC4              ;1 end of file,
 100+ 7BC4              ;9 invalid FCB,
 101+ 7BC4              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 7BC4              ;11 (MP/M) unlocked file verification error,
 103+ 7BC4              ;0FFh hardware error.
 104+ 7BC4
 105+ 7BC4              ;IN: IX=FCB
 106+ 7BC4              BDOSReadFileBlockSeq:
 107+ 7BC4 3E 07        	ld	a, 7
 108+ 7BC6 18 0C        	jr	BDOS
 109+ 7BC8
 110+ 7BC8
 111+ 7BC8              ;0 OK,
 112+ 7BC8              ;1 directory full,
 113+ 7BC8              ;2 disc full,
 114+ 7BC8              ;8 (MP/M) record locked by another process,
 115+ 7BC8              ;9 invalid FCB,
 116+ 7BC8              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 7BC8              ;11 (MP/M) unlocked file verification error,
 118+ 7BC8              ;0FFh hardware error.
 119+ 7BC8
 120+ 7BC8              ;IN: IX=FCB
 121+ 7BC8              BDOSWriteFileBlockSeq:
 122+ 7BC8 3E 08        	ld	a, 8
 123+ 7BCA 18 08        	jr	BDOS
 124+ 7BCC
 125+ 7BCC
 126+ 7BCC              ;0 OK
 127+ 7BCC              ;1 Reading unwritten data
 128+ 7BCC              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 7BCC              ;6 Record number out of range
 130+ 7BCC              ;9 Invalid FCB
 131+ 7BCC              BDOSReadFileBlockRandom:
 132+ 7BCC 3E 12        	ld	a, 18
 133+ 7BCE 18 04        	jr	BDOS
 134+ 7BD0
 135+ 7BD0              ;0 OK
 136+ 7BD0              ;2 Disc full
 137+ 7BD0              ;3 Cannot close extent
 138+ 7BD0              ;5 Directory full
 139+ 7BD0              ;6 Record number out of range
 140+ 7BD0              ;8 Record is locked by another process (MP/M)
 141+ 7BD0              ;9 Invalid FCB
 142+ 7BD0              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 7BD0              BDOSWriteFileBlockRandom:
 144+ 7BD0 3E 13        	ld	a, 19
 145+ 7BD2 18 00        	jr	BDOS
 146+ 7BD4
 147+ 7BD4
 148+ 7BD4              ;Generic BDOS call
 149+ 7BD4              ;IX=arg, A=function
 150+ 7BD4              BDOS:
 151+ 7BD4 DD 22 ED 5C  	ld (HD11), ix
 152+ 7BD8 32 EF 5C     	ld (COPIES), a
 153+ 7BDB CF           	rst 08
 154+ 7BDC 39           	DEFB 57
 155+ 7BDD C9           	ret
 156+ 7BDE
 157+ 7BDE              ;Set DMA address for BDOS
 158+ 7BDE              ;IX=DMA
 159+ 7BDE              BDOSSetDMA:
 160+ 7BDE 3E 0D        	ld a, 13
 161+ 7BE0 18 F2        	jr BDOS
 162+ 7BE2
 163+ 7BE2              ;In: IX=FCB
 164+ 7BE2              BDOSSetRandFilePtr:
 165+ 7BE2 3E 15        	ld	a, 21
 166+ 7BE4 18 EE        	jr	BDOS
 167+ 7BE6
 168+ 7BE6              ;In: HL=filename
 169+ 7BE6              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 7BE6              GetFileSize:
 171+ 7BE6              	IFUSED
 172+ 7BE6
 173+ 7BE6 3A 70 7B     	ld 		a, (RWTSDrive)
 174+ 7BE9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 7BEA CD 98 7B     	call	CreateChannel
 176+ 7BED
 177+ 7BED 3E 14        	ld		a, 20
 178+ 7BEF CD D4 7B     	call	BDOS
 179+ 7BF2              	;inc		a
 180+ 7BF2              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 7BF2
 182+ 7BF2 DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 7BF5 DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 7BF8
 185+ 7BF8              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 7BF8 3E 01        	ld		a, 1
 187+ 7BFA BC           	cp		h
 188+ 7BFB 30 05        	jr		nc, GetFileSizeOK
 189+ 7BFD 21 00 00     	ld		hl, 0
 190+ 7C00 18 08        	jr		GetFileSizeEnd
 191+ 7C02
 192+ 7C02              GetFileSizeOK:
 193+ 7C02              	;*128 == 2^7
 194+ 7C02 06 07        	ld		b, 7
 195+ 7C04              GetFileSizeMul:
 196+ 7C04 CB 15        	rl		l
 197+ 7C06 CB 14        	rl		h
 198+ 7C08 10 FA        	djnz	GetFileSizeMul
 199+ 7C0A
 200+ 7C0A              GetFileSizeEnd:
 201+ 7C0A E5           	push	hl
 202+ 7C0B CD AE 7B     		call	DestroyChannel
 203+ 7C0E E1           	pop		hl
 204+ 7C0F
 205+ 7C0F C9           	ret
 206+ 7C10              	ENDIF
 207+ 7C10
 208+ 7C10              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 7C10              ;HL=file name, A=drive
 210+ 7C10              DeleteFile:
 211+ 7C10 CD 98 7B     	call	CreateChannel
 212+ 7C13
 213+ 7C13 3E 06        	ld		a, 6
 214+ 7C15 CD D4 7B     	call	BDOS
 215+ 7C18
 216+ 7C18 CD AE 7B     	call	DestroyChannel
 217+ 7C1B C9           	ret
 218+ 7C1C
 219+ 7C1C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 7C1C              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 7C1C              ;HL=file name, A=drive
 222+ 7C1C              DoesFileExist:
 223+ 7C1C              	IFUSED
 224+ 7C1C              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 7C1C F5           	push	af
 226+ 7C1D E5           	push	hl
 227+ 7C1E DD 21 59 EA  		ld		ix, FileIdx
 228+ 7C22 CD DE 7B     		call 	BDOSSetDMA
 229+ 7C25 E1           	pop		hl
 230+ 7C26 F1           	pop		af
 231+ 7C27
 232+ 7C27 CD 98 7B     	call	CreateChannel
 233+ 7C2A
 234+ 7C2A              	;Uses FindFirst system call.
 235+ 7C2A 3E 04        	ld		a, 4
 236+ 7C2C CD D4 7B     	call	BDOS
 237+ 7C2F
 238+ 7C2F F5           	push	af
 239+ 7C30 CD AE 7B     		call	DestroyChannel
 240+ 7C33 F1           	pop		af
 241+ 7C34 C9           	ret
 242+ 7C35              	ENDIF
 243+ 7C35
 244+ 7C35              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7C35              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 7C35              ChangeFileAttrib:
 247+ 7C35 3A 70 7B     	ld 		a, (RWTSDrive)
 248+ 7C38 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 7C39 D5           	push	de
 250+ 7C3A CD 98 7B     	call	CreateChannel
 251+ 7C3D D1           	pop		de
 252+ 7C3E
 253+ 7C3E DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 7C41 CB 27        	sla		a								;reset existing attribute flag
 255+ 7C43 CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 7C45 CB 1F        	rr		a								;put Carry flag in register L
 257+ 7C47 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 7C4A
 259+ 7C4A DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 7C4D CB 27        	sla		a
 261+ 7C4F CB 1B        	rr		e
 262+ 7C51 CB 1F        	rr		a
 263+ 7C53 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 7C56
 265+ 7C56              FileAttribSet:
 266+ 7C56 3E 11        	ld		a, 17
 267+ 7C58 CD D4 7B     	call	BDOS
 268+ 7C5B
 269+ 7C5B CD AE 7B     	call	DestroyChannel
 270+ 7C5E C9           	ret
 271+ 7C5F
 272+ 7C5F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 7C5F
 274+ 7C5F              ;HL=original name, DE = new name
 275+ 7C5F              ;Works only on the same drive.
 276+ 7C5F              RenameFile:
 277+ 7C5F 3A 70 7B     	ld 		a, (RWTSDrive)
 278+ 7C62 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 7C63 D5           	push	de
 280+ 7C64 CD 98 7B     	call	CreateChannel
 281+ 7C67 D1           	pop		de
 282+ 7C68
 283+ 7C68 DD E5        	push	ix					;IX == FCB
 284+ 7C6A E1           	pop		hl
 285+ 7C6B 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 7C6E 09           	add		hl, bc
 287+ 7C6F EB           	ex		de, hl
 288+ 7C70 3A 70 7B     	ld		a, (RWTSDrive)
 289+ 7C73 12           	ld		(de), a
 290+ 7C74 01 0B 00     	ld		bc, NAMELEN
 291+ 7C77 ED B0        	ldir
 292+ 7C79
 293+ 7C79 3E 0A        	ld		a, 10
 294+ 7C7B CD D4 7B     	call	BDOS
 295+ 7C7E
 296+ 7C7E CD AE 7B     	call	DestroyChannel
 297+ 7C81 C9           	ret
 298+ 7C82              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 7C82              PromptDiskChangeDst:
 300+ 7C82 21 9C 88     	ld		hl, MsgInsertDstDsk
 301+ 7C85 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 7C88 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 7C8A CD 39 80     	call	PrintStrClr
 304+ 7C8D 21 AB 88     	ld		hl, MsgPressAnyKey
 305+ 7C90 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 7C93 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 7C95 CD 39 80     	call	PrintStrClr
 308+ 7C98 CD D5 7F     	call	ReadChar
 309+ 7C9B C9           	ret
 310+ 7C9C
 311+ 7C9C              PromptDiskChangeSrc:
 312+ 7C9C 21 8D 88     	ld		hl, MsgInsertSrcDsk
 313+ 7C9F 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 7CA2 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 7CA4 CD 39 80     	call	PrintStrClr
 316+ 7CA7 21 AB 88     	ld		hl, MsgPressAnyKey
 317+ 7CAA 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 7CAD 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 7CAF CD 39 80     	call	PrintStrClr
 320+ 7CB2 CD D5 7F     	call	ReadChar
 321+ 7CB5 C9           	ret
 322+ 7CB6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 7CB6
 324+ 7CB6              ;HL = source file name, A = source drive
 325+ 7CB6              ;Use cases:
 326+ 7CB6              ;1. Copy from A: to B: or B: to A:.
 327+ 7CB6              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 7CB6              ;3. Copy from A:/B: to COM.
 329+ 7CB6              ;4. Copy from COM to A:/B:.
 330+ 7CB6              ;Single drive scenario:
 331+ 7CB6              ;1. Read first file part,
 332+ 7CB6              ;2. Ask for dest disk,
 333+ 7CB6              ;3. check if file exists/ask for overwrite,
 334+ 7CB6              ;4. create empty dest file,
 335+ 7CB6              ;5. write first file part,
 336+ 7CB6              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 7CB6              CopyFile:
 338+ 7CB6 3A 70 7B     	ld 		a, (RWTSDrive)
 339+ 7CB9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 7CBA 32 23 89     	ld		(CopyFileSrcDrv), a
 341+ 7CBD 32 2F 89     	ld		(CopyFileDstDrv), a
 342+ 7CC0 11 24 89     	ld		de, CopyFileSrcName
 343+ 7CC3 01 0B 00     	ld		bc, NAMELEN
 344+ 7CC6 E5           	push	hl
 345+ 7CC7 C5           	push	bc
 346+ 7CC8 ED B0        	ldir
 347+ 7CCA C1           	pop		bc
 348+ 7CCB E1           	pop		hl
 349+ 7CCC 11 30 89     	ld		de, CopyFileDstName
 350+ 7CCF ED B0        	ldir
 351+ 7CD1
 352+ 7CD1              	;Reset R/O attribute for destination, to allow file write.
 353+ 7CD1 3A 38 89     	ld		a, (CopyFileDstName+RO_POS)
 354+ 7CD4 CB BF        	res		7, a
 355+ 7CD6 32 38 89     	ld		(CopyFileDstName+RO_POS), a
 356+ 7CD9
 357+ 7CD9 AF           	xor		a
 358+ 7CDA 32 1B 89     	ld		(CopyFileRes), a
 359+ 7CDD 11 00 00     	ld		de, 0
 360+ 7CE0 ED 53 1E 89  	ld		(FilePosRead), de
 361+ 7CE4 ED 53 20 89  	ld		(FilePosWrite), de
 362+ 7CE8
 363+ 7CE8 3A 23 89     	ld		a, (CopyFileSrcDrv)
 364+ 7CEB C6 40        	add		'A'-1
 365+ 7CED              	;Update menu messages with current drive.
 366+ 7CED 32 16 88     	ld		(MsgMenuSingleDrv1), a
 367+ 7CF0 32 1A 88     	ld		(MsgMenuSingleDrv2), a
 368+ 7CF3 32 24 88     	ld		(MsgMenuDualDrv1), a
 369+ 7CF6 32 32 88     	ld		(MsgMenuToComDrv), a
 370+ 7CF9 32 46 88     	ld		(MsgMenuFromCOMDrv), a
 371+ 7CFC              	;Update menu messages with the alternate drive.
 372+ 7CFC 3A 23 89     	ld		a, (CopyFileSrcDrv)
 373+ 7CFF EE 03        	xor		%11
 374+ 7D01 C6 40        	add		'A'-1
 375+ 7D03 32 28 88     	ld		(MsgMenuDualDrv2), a
 376+ 7D06
 377+ 7D06 21 F3 87     	ld		hl, MsgMenuFileCopy
 378+ 7D09 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 7D0C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 7D0E CD 39 80     	call	PrintStrClr
 381+ 7D11 21 02 88     	ld		hl, MsgMenuBack
 382+ 7D14 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 7D17 CD 11 80     	call	PrintStr
 384+ 7D1A 21 0E 88     	ld		hl, MsgMenuSingle
 385+ 7D1D 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 7D20 CD 11 80     	call	PrintStr
 387+ 7D23 21 1C 88     	ld		hl, MsgMenuDual
 388+ 7D26 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 7D29 CD 11 80     	call	PrintStr
 390+ 7D2C 21 2A 88     	ld		hl, MsgMenuToCOM
 391+ 7D2F 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 7D32 CD 11 80     	call	PrintStr
 393+ 7D35 21 39 88     	ld		hl, MsgMenuFromCOM
 394+ 7D38 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 7D3B CD 11 80     	call	PrintStr
 396+ 7D3E
 397+ 7D3E CD D5 7F     	call	ReadChar
 398+ 7D41 32 13 89     	ld		(CopySelOption), a
 399+ 7D44
 400+ 7D44 F5           	push	af
 401+ 7D45 06 06        		ld		b, 6
 402+ 7D47 CD BD 81     		call	ClearNMsgLines
 403+ 7D4A F1           	pop		af
 404+ 7D4B
 405+ 7D4B              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 7D4B FE 30        	cp		'0'
 407+ 7D4D 20 04        	jr		nz, CopyFileNotExit
 408+ 7D4F E1           	pop		hl
 409+ 7D50 C3 14 6F     	jp		ReadKeyLoop
 410+ 7D53
 411+ 7D53              CopyFileNotExit:
 412+ 7D53 FE 31        	cp		'1'
 413+ 7D55 28 4D        	jr		z, CopyFileSameDrive
 414+ 7D57
 415+ 7D57 FE 32        	cp		'2'
 416+ 7D59 CA 23 7E     	jp		z, CopyFileDualDrive
 417+ 7D5C
 418+ 7D5C FE 33        	cp		'3'
 419+ 7D5E CA 6D 7E     	jp		z, CopyFileToCOM
 420+ 7D61
 421+ 7D61 FE 34        	cp		'4'
 422+ 7D63 CA A0 7E     	jp		z, CopyFileFromCOM
 423+ 7D66
 424+ 7D66 E1           	pop		hl
 425+ 7D67 C3 14 6F     	jp		ReadKeyLoop
 426+ 7D6A
 427+ 7D6A
 428+ 7D6A              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 7D6A              CopyFileCheckOverwrite:
 430+ 7D6A              	;Check if destination file exists.
 431+ 7D6A 3A 2F 89     	ld		a, (CopyFileDstDrv)
 432+ 7D6D 21 30 89     	ld		hl, CopyFileDstName
 433+ 7D70 CD 1C 7C     	call	DoesFileExist
 434+ 7D73 3C           	inc		a
 435+ 7D74 C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 7D75
 437+ 7D75              	;Ask overwrite confirmation.
 438+ 7D75 21 6F 88     	ld		hl, MsgFileOverwrite
 439+ 7D78 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 7D7B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 7D7D CD 39 80     	call	PrintStrClr
 442+ 7D80 CD D5 7F     	call	ReadChar
 443+ 7D83 FE 79        	cp		'y'
 444+ 7D85 C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 7D86
 446+ 7D86
 447+ 7D86              CopyFileCreateNewFile:
 448+ 7D86 3A 2F 89     	ld		a, (CopyFileDstDrv)
 449+ 7D89 21 30 89     	ld		hl, CopyFileDstName
 450+ 7D8C F5           	push	af
 451+ 7D8D E5           	push	hl
 452+ 7D8E CD 10 7C     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 7D91 E1           	pop		hl
 454+ 7D92 F1           	pop		af
 455+ 7D93 CD 98 7B     	call	CreateChannel
 456+ 7D96 CD B8 7B     	call 	BDOSCreateFile
 457+ 7D99 3C           	inc  	a						;Cancel if A==$FF
 458+ 7D9A C8           	ret		z
 459+ 7D9B
 460+ 7D9B              	;Close dest file once created.
 461+ 7D9B F5           	push	af
 462+ 7D9C CD C0 7B     		call	BDOSCloseFile
 463+ 7D9F CD AE 7B     		call	DestroyChannel
 464+ 7DA2 F1           	pop		af
 465+ 7DA3 C9           	ret
 466+ 7DA4
 467+ 7DA4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 7DA4              CopyFileSameDrive:
 469+ 7DA4              	;Read first file section from SRC.
 470+ 7DA4 3A 23 89     	ld		a, (CopyFileSrcDrv)
 471+ 7DA7 21 24 89     	ld		hl, CopyFileSrcName
 472+ 7DAA 06 53        	ld		b, MAX_SECT_BUF
 473+ 7DAC CD 23 7F     	call	ReadFileSection
 474+ 7DAF 3A 22 89     	ld		a, (CopyFileSectCnt)
 475+ 7DB2 B7           	or		a
 476+ 7DB3 C8           	ret		z
 477+ 7DB4
 478+ 7DB4              	;Prompt for DST disk change.
 479+ 7DB4 CD 82 7C     	call	PromptDiskChangeDst
 480+ 7DB7 3A 70 7B     	ld		a, (RWTSDrive)
 481+ 7DBA CD 88 7B     	call	BDOSInit
 482+ 7DBD
 483+ 7DBD 06 02        	ld		b, 2
 484+ 7DBF CD BD 81     	call	ClearNMsgLines
 485+ 7DC2
 486+ 7DC2 CD 6A 7D     	call	CopyFileCheckOverwrite
 487+ 7DC5 C0           	ret		nz
 488+ 7DC6
 489+ 7DC6 CD 86 7D     	call	CopyFileCreateNewFile
 490+ 7DC9 C8           	ret		z
 491+ 7DCA
 492+ 7DCA              CopyFileSameDriveLoop:
 493+ 7DCA 3A 22 89     	ld		a, (CopyFileSectCnt)
 494+ 7DCD 6F           	ld		l, a
 495+ 7DCE 26 00        	ld		h, 0
 496+ 7DD0 11 B8 88     	ld		de, MsgCopySectors
 497+ 7DD3 CD A8 76     	call	Byte2Txt
 498+ 7DD6 21 B8 88     	ld		hl, MsgCopySectors
 499+ 7DD9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500+ 7DDC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501+ 7DDE CD 39 80     	call	PrintStrClr
 502+ 7DE1
 503+ 7DE1 3A 1B 89     	ld		a, (CopyFileRes)			;Save read status code.
 504+ 7DE4 F5           	push	af
 505+ 7DE5 3A 2F 89     		ld		a, (CopyFileDstDrv)
 506+ 7DE8 21 30 89     		ld		hl, CopyFileDstName
 507+ 7DEB CD 44 7F     		call	WriteFileSection
 508+ 7DEE 3A 1B 89     		ld		a, (CopyFileRes)
 509+ 7DF1 6F           		ld		l, a
 510+ 7DF2 F1           	pop		af
 511+ 7DF3 B5           	or		l
 512+ 7DF4 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 513+ 7DF5
 514+ 7DF5
 515+ 7DF5              	;Prompt for SRC disk change.
 516+ 7DF5 CD 9C 7C     	call	PromptDiskChangeSrc
 517+ 7DF8 3A 70 7B     	ld		a, (RWTSDrive)
 518+ 7DFB CD 88 7B     	call	BDOSInit
 519+ 7DFE
 520+ 7DFE 06 02        	ld		b, 2
 521+ 7E00 CD BD 81     	call	ClearNMsgLines
 522+ 7E03
 523+ 7E03 3A 23 89     	ld		a, (CopyFileSrcDrv)
 524+ 7E06 21 24 89     	ld		hl, CopyFileSrcName
 525+ 7E09 06 53        	ld		b, MAX_SECT_BUF
 526+ 7E0B CD 23 7F     	call	ReadFileSection
 527+ 7E0E 3A 22 89     	ld		a, (CopyFileSectCnt)
 528+ 7E11 B7           	or		a
 529+ 7E12 C8           	ret		z
 530+ 7E13
 531+ 7E13              	;Prompt for DST disk change.
 532+ 7E13 CD 82 7C     	call	PromptDiskChangeDst
 533+ 7E16 3A 70 7B     	ld		a, (RWTSDrive)
 534+ 7E19 CD 88 7B     	call	BDOSInit
 535+ 7E1C
 536+ 7E1C 06 02        	ld		b, 2
 537+ 7E1E CD BD 81     	call	ClearNMsgLines
 538+ 7E21
 539+ 7E21 18 A7        	jr		CopyFileSameDriveLoop
 540+ 7E23
 541+ 7E23              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 542+ 7E23
 543+ 7E23              CopyFileDualDrive:
 544+ 7E23 3A 23 89     	ld		a, (CopyFileSrcDrv)
 545+ 7E26 EE 03        	xor		%11
 546+ 7E28 32 2F 89     	ld		(CopyFileDstDrv), a
 547+ 7E2B
 548+ 7E2B CD 6A 7D     	call	CopyFileCheckOverwrite
 549+ 7E2E C0           	ret		nz
 550+ 7E2F
 551+ 7E2F CD 86 7D     	call	CopyFileCreateNewFile
 552+ 7E32 C8           	ret		z
 553+ 7E33
 554+ 7E33              CopyFileDualDriveLoop:
 555+ 7E33 3A 23 89     	ld		a, (CopyFileSrcDrv)
 556+ 7E36 21 24 89     	ld		hl, CopyFileSrcName
 557+ 7E39 06 53        	ld		b, MAX_SECT_BUF
 558+ 7E3B CD 23 7F     	call	ReadFileSection
 559+ 7E3E 3A 22 89     	ld		a, (CopyFileSectCnt)
 560+ 7E41 B7           	or		a
 561+ 7E42 C8           	ret		z
 562+ 7E43
 563+ 7E43 3A 22 89     	ld		a, (CopyFileSectCnt)
 564+ 7E46 6F           	ld		l, a
 565+ 7E47 26 00        	ld		h, 0
 566+ 7E49 11 B8 88     	ld		de, MsgCopySectors
 567+ 7E4C CD A8 76     	call	Byte2Txt
 568+ 7E4F 21 B8 88     	ld		hl, MsgCopySectors
 569+ 7E52 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 570+ 7E55 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 571+ 7E57
 572+ 7E57 3A 1B 89     	ld		a, (CopyFileRes)
 573+ 7E5A F5           	push	af
 574+ 7E5B 3A 2F 89     		ld		a, (CopyFileDstDrv)
 575+ 7E5E 21 30 89     		ld		hl, CopyFileDstName
 576+ 7E61 CD 44 7F     		call	WriteFileSection
 577+ 7E64 3A 1B 89     		ld		a, (CopyFileRes)
 578+ 7E67 6F           		ld		l, a
 579+ 7E68 F1           	pop		af
 580+ 7E69 B5           	or		l
 581+ 7E6A C0           	ret		nz
 582+ 7E6B
 583+ 7E6B 18 C6        	jr		CopyFileDualDriveLoop
 584+ 7E6D
 585+ 7E6D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 586+ 7E6D              CopyFileToCOM:
 587+ 7E6D AF           	xor		a
 588+ 7E6E 32 1B 89     	ld		(CopyFileRes), a
 589+ 7E71 32 22 89     	ld		(CopyFileSectCnt), a
 590+ 7E74 11 00 00     	ld		de, 0
 591+ 7E77 ED 53 1E 89  	ld		(FilePosRead), de
 592+ 7E7B
 593+ 7E7B              CopyFileToCOMLoop:
 594+ 7E7B 3A 23 89     	ld		a, (CopyFileSrcDrv)
 595+ 7E7E 21 24 89     	ld		hl, CopyFileSrcName
 596+ 7E81 06 53        	ld		b, MAX_SECT_BUF
 597+ 7E83 CD 23 7F     	call	ReadFileSection
 598+ 7E86
 599+ 7E86 3A 22 89     	ld		a, (CopyFileSectCnt)
 600+ 7E89 B7           	or		a
 601+ 7E8A 28 0F        	jr		z, CopyFileToCOMEnd
 602+ 7E8C
 603+ 7E8C              	;Send buffer to COM port.
 604+ 7E8C 21 59 97     	ld		hl, FileData
 605+ 7E8F 47           	ld		b, a					;Sector size is 256.
 606+ 7E90 0E 00        	ld		c, 0
 607+ 7E92 CD 17 85     	call	SERTB
 608+ 7E95
 609+ 7E95 3A 1B 89     	ld		a, (CopyFileRes)
 610+ 7E98 B7           	or		a
 611+ 7E99 28 E0        	jr		z, CopyFileToCOMLoop
 612+ 7E9B
 613+ 7E9B              CopyFileToCOMEnd:
 614+ 7E9B              	;Reset read error code, as 1 is returned when file is finished reading.
 615+ 7E9B AF           	xor		a
 616+ 7E9C 32 1B 89     	ld		(CopyFileRes), a
 617+ 7E9F
 618+ 7E9F C9           	ret
 619+ 7EA0
 620+ 7EA0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 621+ 7EA0              CopyFileFromCOM:
 622+ 7EA0 AF           	xor		a
 623+ 7EA1 32 1B 89     	ld		(CopyFileRes), a
 624+ 7EA4 11 00 00     	ld		de, 0
 625+ 7EA7 ED 53 20 89  	ld		(FilePosWrite), de
 626+ 7EAB
 627+ 7EAB              	;Must ask for the new file name and check to not exist.
 628+ 7EAB 21 D9 87     	ld		hl, MsgNewFileName
 629+ 7EAE 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 630+ 7EB1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 631+ 7EB3 CD 39 80     	call	PrintStrClr
 632+ 7EB6
 633+ 7EB6 21 A4 87     	ld		hl, MsgClear
 634+ 7EB9 11 59 97     	ld		de, FileData
 635+ 7EBC 01 0B 00     	ld		bc, NAMELEN
 636+ 7EBF ED B0        	ldir
 637+ 7EC1 3E A0        	ld		a, $80 | ' '
 638+ 7EC3 12           	ld		(de), a
 639+ 7EC4 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 7EC7 21 59 97     	ld		hl, FileData
 641+ 7ECA CD 11 80     	call	PrintStr
 642+ 7ECD
 643+ 7ECD 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 644+ 7ED0 01 0B 00     	ld		bc, NAMELEN
 645+ 7ED3 CD 7B 81     	call	ReadString
 646+ 7ED6
 647+ 7ED6 11 59 97     	ld		de, FileData
 648+ 7ED9 1A           	ld		a, (de)
 649+ 7EDA FE 20        	cp		' '					;If starting with space, input was canceled.
 650+ 7EDC C8           	ret		z
 651+ 7EDD
 652+ 7EDD              	;Copy new file name
 653+ 7EDD 21 59 97     	ld		hl, FileData
 654+ 7EE0 11 30 89     	ld		de, CopyFileDstName
 655+ 7EE3 01 0B 00     	ld		bc, NAMELEN
 656+ 7EE6 ED B0        	ldir
 657+ 7EE8
 658+ 7EE8              	;Check if new name doesn't exist already.
 659+ 7EE8 3A 23 89     	ld		a, (CopyFileSrcDrv)
 660+ 7EEB 21 30 89     	ld		hl, CopyFileDstName
 661+ 7EEE CD 6A 7D     	call	CopyFileCheckOverwrite
 662+ 7EF1 C0           	ret		nz
 663+ 7EF2
 664+ 7EF2              	;Delete and re-create empty destination file
 665+ 7EF2 3A 23 89     	ld		a, (CopyFileSrcDrv)
 666+ 7EF5 21 30 89     	ld		hl, CopyFileDstName
 667+ 7EF8 CD 86 7D     	call	CopyFileCreateNewFile
 668+ 7EFB C8           	ret		z
 669+ 7EFC
 670+ 7EFC              CopyFileFromCOMLoop:
 671+ 7EFC 21 59 97     	ld		hl, FileData
 672+ 7EFF 01 00 53     	ld		bc, FileDataSize
 673+ 7F02 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 674+ 7F04 CD E4 84     	call	SERRB				;BC = Number of bytes read from COM
 675+ 7F07 79           	ld		a, c
 676+ 7F08 B0           	or		b
 677+ 7F09 C8           	ret		z
 678+ 7F0A
 679+ 7F0A              	;If C is not 0, add one more sector.
 680+ 7F0A 79           	ld 		a, c
 681+ 7F0B B7           	or		a
 682+ 7F0C 28 01        	jr		z, CopyFileFromCOMDontInc
 683+ 7F0E 04           	inc		b
 684+ 7F0F              CopyFileFromCOMDontInc:
 685+ 7F0F 78           	ld		a, b				;Sector size is 256
 686+ 7F10 32 22 89     	ld		(CopyFileSectCnt), a
 687+ 7F13 3A 2F 89     	ld		a, (CopyFileDstDrv)
 688+ 7F16 21 30 89     	ld		hl, CopyFileDstName
 689+ 7F19 CD 44 7F     	call	WriteFileSection
 690+ 7F1C
 691+ 7F1C 3A 1B 89     	ld		a, (CopyFileRes)
 692+ 7F1F B7           	or		a
 693+ 7F20 28 DA        	jr		z, CopyFileFromCOMLoop
 694+ 7F22
 695+ 7F22 C9           	ret
 696+ 7F23
 697+ 7F23              ;Reads/Writes disk file portion to/from memory.
 698+ 7F23              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 699+ 7F23              ;This should work with single-drive file copy from one disk to another.
 700+ 7F23              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records, B = max sectors to read
 701+ 7F23              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 702+ 7F23              ;
 703+ 7F23              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 704+ 7F23              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 705+ 7F23              ;Must use sequential read/write. But for the first operation must use random read/write.
 706+ 7F23              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 7F23              ReadFileSection:
 708+ 7F23 11 CC 7B     	ld		de, BDOSReadFileBlockRandom
 709+ 7F26 ED 53 8C 7F  	ld		(CopyFileOperAddr1), de
 710+ 7F2A 11 C4 7B     	ld		de, BDOSReadFileBlockSeq
 711+ 7F2D ED 53 AB 7F  	ld		(CopyFileOperAddr2), de
 712+ 7F31 11 1E 89     	ld		de, FilePosRead
 713+ 7F34 ED 53 83 7F  	ld		(CopyFilePtr), de
 714+ 7F38 ED 53 C8 7F  	ld		(CopyFilePtr2), de
 715+ 7F3C
 716+ 7F3C              	;Limit max sectors to read to leave space for the index too.
 717+ 7F3C F5           	push	af
 718+ 7F3D 78           		ld		a, b
 719+ 7F3E 32 22 89     		ld		(CopyFileSectCnt), a
 720+ 7F41 F1           	pop		af
 721+ 7F42 18 19        	jr		ReadWriteFileSection
 722+ 7F44
 723+ 7F44              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 724+ 7F44
 725+ 7F44              WriteFileSection:
 726+ 7F44 11 D0 7B     	ld		de, BDOSWriteFileBlockRandom
 727+ 7F47 ED 53 8C 7F  	ld		(CopyFileOperAddr1), de
 728+ 7F4B 11 C8 7B     	ld		de, BDOSWriteFileBlockSeq
 729+ 7F4E ED 53 AB 7F  	ld		(CopyFileOperAddr2), de
 730+ 7F52 11 20 89     	ld		de, FilePosWrite
 731+ 7F55 ED 53 83 7F  	ld		(CopyFilePtr), de
 732+ 7F59 ED 53 C8 7F  	ld		(CopyFilePtr2), de
 733+ 7F5D
 734+ 7F5D
 735+ 7F5D              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 736+ 7F5D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 737+ 7F5D              ReadWriteFileSection:
 738+ 7F5D CD 98 7B     	call	CreateChannel
 739+ 7F60 DD 22 19 89  	ld	(CopyFileFCB), ix
 740+ 7F64 CD BC 7B     	call 	BDOSOpenFile
 741+ 7F67 3C           	inc  	a						;Cancel if A==$FF
 742+ 7F68 C8           	ret	z
 743+ 7F69
 744+ 7F69              	;Set DMA initial pointer = FileData
 745+ 7F69 DD E5        	push	ix
 746+ 7F6B 21 59 97     		ld		hl, FileData
 747+ 7F6E DD 21 1C 89  		ld		ix, CopyFileDMAAddr
 748+ 7F72 DD 75 00     		ld		(ix), l
 749+ 7F75 DD 74 01     		ld		(ix+1), h
 750+ 7F78 DD 21 59 97  		ld		ix, FileData
 751+ 7F7C CD DE 7B     		call 	BDOSSetDMA
 752+ 7F7F DD E1        	pop		ix
 753+ 7F81
 754+ 7F81              CopyFilePtr EQU $+2
 755+ 7F81              	;Update file pointer using read/write random call.
 756+ 7F81 ED 5B 1E 89  	ld		de, (FilePosRead)
 757+ 7F85 DD 73 21     	ld		(ix + FCB_R0), e
 758+ 7F88 DD 72 22     	ld		(ix + FCB_R1), d
 759+ 7F8B              CopyFileOperAddr1 EQU $ + 1
 760+ 7F8B CD CC 7B     	call 	BDOSReadFileBlockRandom
 761+ 7F8E
 762+ 7F8E 32 1B 89     	ld		(CopyFileRes), a
 763+ 7F91 B7           	or		a
 764+ 7F92 20 22        	jr		nz, ReadWriteFileSectionEnd
 765+ 7F94
 766+ 7F94 3A 22 89     	ld		a, (CopyFileSectCnt)
 767+ 7F97 47           	ld		b, a
 768+ 7F98
 769+ 7F98              ReadWriteFileSectionLoop:
 770+ 7F98 C5           	push	bc
 771+ 7F99 DD 2A 1C 89  		ld		ix, (CopyFileDMAAddr)
 772+ 7F9D CD DE 7B     		call 	BDOSSetDMA
 773+ 7FA0 DD 24        		inc		ixh
 774+ 7FA2 DD 22 1C 89  		ld		(CopyFileDMAAddr), ix
 775+ 7FA6
 776+ 7FA6 DD 2A 19 89  		ld		ix, (CopyFileFCB)
 777+ 7FAA              CopyFileOperAddr2 EQU $ + 1
 778+ 7FAA CD C4 7B     		call 	BDOSReadFileBlockSeq
 779+ 7FAD 32 1B 89     		ld		(CopyFileRes), a
 780+ 7FB0 C1           	pop		bc
 781+ 7FB1 B7           	or		a
 782+ 7FB2 20 02        	jr		nz, ReadWriteFileSectionEnd	;Exit on read/write error.
 783+ 7FB4 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 784+ 7FB6
 785+ 7FB6              ReadWriteFileSectionEnd:
 786+ 7FB6              	;Update sector count variable with how many sectors were transfered.
 787+ 7FB6 3A 22 89     	ld		a, (CopyFileSectCnt)
 788+ 7FB9 90           	sub		b				;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 789+ 7FBA 32 22 89     	ld		(CopyFileSectCnt), a		;Store the number of sectors actualy read.
 790+ 7FBD
 791+ 7FBD              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 792+ 7FBD CD E2 7B     	call	BDOSSetRandFilePtr
 793+ 7FC0 DD 5E 21     	ld		e, (ix + FCB_R0)
 794+ 7FC3 DD 56 22     	ld		d, (ix + FCB_R1)
 795+ 7FC6              CopyFilePtr2 EQU $+2
 796+ 7FC6 ED 53 1E 89  	ld		(FilePosRead), de
 797+ 7FCA
 798+ 7FCA CD C0 7B     	call 	BDOSCloseFile
 799+ 7FCD CD AE 7B     	call 	DestroyChannel
 800+ 7FD0
 801+ 7FD0 ED 5B 1C 89  	ld		de, (CopyFileDMAAddr)
 802+ 7FD4              	;dec		d
 803+ 7FD4 C9           	ret
 804+ 7FD5
 805+ 7FD5              	ENDIF
 806+ 7FD5
# file closed: bdos.asm
1498  7FD5              	include "ui.asm"
# file opened: ui.asm
   1+ 7FD5              ;UI related functions
   2+ 7FD5
   3+ 7FD5              	ifndef	_UI_
   4+ 7FD5              	define	_UI_
   5+ 7FD5
   6+ 7FD5              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++7FD5              	ifndef	_HCCFG_
   2++7FD5 ~            	define	_HCCFG_
   3++7FD5 ~
   4++7FD5 ~            ;HC specific code, for configuration
   5++7FD5 ~
   6++7FD5 ~            HC_CFG_PORT			EQU	$7E
   7++7FD5 ~            HC_FLOPPY_PORT		EQU 7
   8++7FD5 ~
   9++7FD5 ~            ;BASIC/CPM ROM selection
  10++7FD5 ~            HC_CFG_ROM_BAS		EQU	%0
  11++7FD5 ~            HC_CFG_ROM_CPM		EQU	%1
  12++7FD5 ~
  13++7FD5 ~            ;Address for ROM paging: 0 or $E000
  14++7FD5 ~            HC_CFG_ROM_0000		EQU %00
  15++7FD5 ~            HC_CFG_ROM_E000		EQU %10
  16++7FD5 ~
  17++7FD5 ~            ;Cfg. port Enable/Disable
  18++7FD5 ~            HC_CFG_PORT_DIS		EQU %000
  19++7FD5 ~            HC_CFG_PORT_EN		EQU	%100
  20++7FD5 ~
  21++7FD5 ~            ;Video memory bank: $4000 or $C000
  22++7FD5 ~            HC_CFG_VID_4000		EQU	%0000
  23++7FD5 ~            HC_CFG_VID_C000		EQU	%1000
  24++7FD5 ~
  25++7FD5 ~
  26++7FD5 ~            ;Standar BASIC config
  27++7FD5 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++7FD5 ~            ;Standar CP/M config
  29++7FD5 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++7FD5 ~
  31++7FD5 ~
  32++7FD5 ~            HC_VID_BANK0		EQU	$4000
  33++7FD5 ~            HC_VID_BANK1		EQU	$C000
  34++7FD5 ~
  35++7FD5 ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++7FD5 ~            ;Info from Rares Atodiresei.
  37++7FD5 ~            IsDrive2_80Tracks:
  38++7FD5 ~            	IFUSED
  39++7FD5 ~            	in	a, (HC_FLOPPY_PORT)
  40++7FD5 ~            	and %10
  41++7FD5 ~            	ret
  42++7FD5 ~            	ENDIF
  43++7FD5 ~
  44++7FD5              	endif
# file closed: hccfg.asm
   7+ 7FD5
   8+ 7FD5              COL             EQU 23728
   9+ 7FD5              LINE            EQU 23729               ;Coordinates
  10+ 7FD5              LineCol			EQU	COL
  11+ 7FD5              CODE			EQU 23681               ;Char to print
  12+ 7FD5
  13+ 7FD5              CPM_FNT         EQU $25AB
  14+ 7FD5
  15+ 7FD5              PORT_ZX			EQU	$FE
  16+ 7FD5
  17+ 7FD5              ;COLORS
  18+ 7FD5              CLR_BLACK		EQU 0
  19+ 7FD5              CLR_BLUE		EQU 1
  20+ 7FD5              CLR_RED			EQU 2
  21+ 7FD5              CLR_MAGENTA		EQU 3
  22+ 7FD5              CLR_GREEN		EQU 4
  23+ 7FD5              CLR_CYAN		EQU	5
  24+ 7FD5              CLR_YELLOW		EQU	6
  25+ 7FD5              CLR_WHITE		EQU	7
  26+ 7FD5              CLR_BRIGHT		EQU	%01000000
  27+ 7FD5              CLR_FLASH		EQU	%10000000
  28+ 7FD5
  29+ 7FD5              ;PAPER
  30+ 7FD5              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 7FD5              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 7FD5              PAPER_RED		EQU (CLR_RED << 3)
  33+ 7FD5              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 7FD5              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 7FD5              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 7FD5              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 7FD5              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 7FD5
  39+ 7FD5              ;INK
  40+ 7FD5              INK_BLACK		EQU CLR_BLACK
  41+ 7FD5              INK_BLUE		EQU CLR_BLUE
  42+ 7FD5              INK_RED			EQU CLR_RED
  43+ 7FD5              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 7FD5              INK_GREEN		EQU CLR_GREEN
  45+ 7FD5              INK_CYAN		EQU	CLR_CYAN
  46+ 7FD5              INK_YELLOW		EQU	CLR_YELLOW
  47+ 7FD5              INK_WHITE		EQU	CLR_WHITE
  48+ 7FD5
  49+ 7FD5
  50+ 7FD5              SCR_ATTR_ADDR	EQU 22528
  51+ 7FD5              SCR_ADDR		EQU 16384
  52+ 7FD5              SCR_PIX_LEN		EQU	6144
  53+ 7FD5              SCR_ATTR_LEN	EQU	768
  54+ 7FD5              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 7FD5              SCR_BYTES_PER_LINE	EQU	32
  56+ 7FD5
  57+ 7FD5              SCR_COLS		EQU	64
  58+ 7FD5              SCR_LINES		EQU 24
  59+ 7FD5
  60+ 7FD5              ;used for file names list positioning
  61+ 7FD5              LST_LINES_CNT	EQU	21
  62+ 7FD5              LST_FIRST_LINE	EQU	1
  63+ 7FD5              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 7FD5              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 7FD5              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 7FD5              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 7FD5              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 7FD5              LST_FIRST_COL	EQU	16
  69+ 7FD5              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 7FD5
  71+ 7FD5              ;key codes
  72+ 7FD5              KEY_ESC			EQU	7
  73+ 7FD5              KEY_LEFT		EQU	8
  74+ 7FD5              KEY_RIGHT		EQU	9
  75+ 7FD5              KEY_DOWN		EQU	10
  76+ 7FD5              KEY_UP			EQU	11
  77+ 7FD5              KEY_BACKSP		EQU	12
  78+ 7FD5              KEY_ENTER		EQU	13
  79+ 7FD5              KEY_CTRL		EQU	14
  80+ 7FD5
  81+ 7FD5              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 7FD5              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 7FD5              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 7FD5
  85+ 7FD5              ;Special formating chars
  86+ 7FD5              CHR_CR			EQU	13
  87+ 7FD5              CHR_LF			EQU	10
  88+ 7FD5              CHR_TAB			EQU	09
  89+ 7FD5
  90+ 7FD5
  91+ 7FD5              ;Semi-graphical chars
  92+ 7FD5              ;           UC
  93+ 7FD5              ;     UL +H-+--+UR
  94+ 7FD5              ;        |  |  |
  95+ 7FD5              ;     ML +--+--+MR
  96+ 7FD5              ;        V C|  |
  97+ 7FD5              ;     LL +--+--+LR
  98+ 7FD5              ;           DC
  99+ 7FD5              CHR_GRID        EQU 127
 100+ 7FD5              CHR_V           EQU 128
 101+ 7FD5              CHR_MR          EQU 129
 102+ 7FD5              CHR_UR          EQU 130
 103+ 7FD5              CHR_DL          EQU 131
 104+ 7FD5              CHR_DC          EQU 132
 105+ 7FD5              CHR_UC          EQU 133
 106+ 7FD5              CHR_ML          EQU 134
 107+ 7FD5              CHR_H           EQU 135
 108+ 7FD5              CHR_C           EQU 136
 109+ 7FD5              CHR_LR          EQU 137
 110+ 7FD5              CHR_UL          EQU 138
 111+ 7FD5              CHR_FULL        EQU 139
 112+ 7FD5              CHR_HALF        EQU 140
 113+ 7FD5
 114+ 7FD5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 7FD5
 116+ 7FD5              ;Return read char in A
 117+ 7FD5              ReadChar:
 118+ 7FD5 CF           	rst 08
 119+ 7FD6 1B           	DEFB 27
 120+ 7FD7 C9           	ret
 121+ 7FD8
 122+ 7FD8              ;Checks if a key is pressed
 123+ 7FD8              ;Cy=1 if key is pressed
 124+ 7FD8              KbdHit:
 125+ 7FD8 CF           	rst 08
 126+ 7FD9 20           	DEFB 32
 127+ 7FDA C9           	ret
 128+ 7FDB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 7FDB
 130+ 7FDB              InitFonts:
 131+ 7FDB              	IFUSED
 132+ 7FDB                  ;page-in CPM ROM to get fonts
 133+ 7FDB F3               di
 134+ 7FDC 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 7FDE D3 7E            out	(HC_CFG_PORT), a
 136+ 7FE0
 137+ 7FE0 21 AB 25     	ld		hl, CPM_FNT
 138+ 7FE3 11 F1 93     	ld		de, FontTable
 139+ 7FE6 01 68 03     	ld		bc, 872
 140+ 7FE9 ED B0        	ldir
 141+ 7FEB
 142+ 7FEB                  ;restore BASIC ROM
 143+ 7FEB 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 7FED D3 7E            out	(HC_CFG_PORT), a
 145+ 7FEF FB               ei
 146+ 7FF0
 147+ 7FF0 C9           	ret
 148+ 7FF1              	ENDIF
 149+ 7FF1
 150+ 7FF1              ClrScr:
 151+ 7FF1 2A D0 81     	ld		hl, (CurrScrAddr)
 152+ 7FF4 54           	ld		d, h
 153+ 7FF5 5D           	ld		e, l
 154+ 7FF6 13           	inc		de
 155+ 7FF7 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 7FFA 36 00        	ld		(hl), 0
 157+ 7FFC ED B0        	ldir
 158+ 7FFE
 159+ 7FFE 23           	inc 	hl
 160+ 7FFF 13           	inc		de
 161+ 8000
 162+ 8000 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 8003 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 8005 ED B0        	ldir
 165+ 8007
 166+ 8007              	;also set border color
 167+ 8007 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 8009 D3 FE        	out		(PORT_ZX), a
 169+ 800B
 170+ 800B 3E 45        	ld		a, SCR_DEF_CLR
 171+ 800D 32 48 5C     	ld		(23624), a
 172+ 8010 C9           	ret
 173+ 8011
 174+ 8011              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 8011              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 8011              PrintStr:
 177+ 8011 7E           	ld		a, (hl)
 178+ 8012 FE 20        	cp		' '
 179+ 8014 30 02        	jr		nc, GoodChar
 180+ 8016 3E 3F        	ld		a, '?'
 181+ 8018              GoodChar:
 182+ 8018 CB 7F        	bit		7, a
 183+ 801A CB BF        	res		7, a
 184+ 801C 32 81 5C     	ld		(CODE), a
 185+ 801F ED 53 B0 5C  	ld		(LineCol), de
 186+ 8023 08           	ex		af, af'
 187+ 8024 D9           	exx
 188+ 8025 E5           	push	hl
 189+ 8026 CD 3D 81     	call 	PrintChar
 190+ 8029 E1           	pop		hl
 191+ 802A D9           	exx
 192+ 802B 08           	ex		af, af'
 193+ 802C C0           	ret		nz
 194+ 802D
 195+ 802D 1C           	inc		e
 196+ 802E 23           	inc		hl
 197+ 802F
 198+ 802F 7B           	ld		a, e
 199+ 8030 FE 40        	cp		64
 200+ 8032 38 DD        	jr		c, PrintStr
 201+ 8034 1E 00        	ld		e, 0
 202+ 8036 14           	inc		d
 203+ 8037
 204+ 8037 18 D8        	jr		PrintStr
 205+ 8039
 206+ 8039              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 8039
 208+ 8039              ;IN: HL = string, DE = coords, A = color
 209+ 8039              PrintStrClr:
 210+ 8039 32 65 80     	ld		(StrClr), a
 211+ 803C D5           	push	de
 212+ 803D CD 11 80     		call	PrintStr
 213+ 8040 E1           	pop		hl
 214+ 8041              	;get string len.
 215+ 8041 7B           	ld		a, e
 216+ 8042 95           	sub		l
 217+ 8043 1F           	rra
 218+ 8044 08           	ex		af, af'
 219+ 8045              		;line * 32
 220+ 8045 7C           		ld		a, h
 221+ 8046 17           		rla
 222+ 8047 17           		rla
 223+ 8048 11 00 00     		ld	de, 0
 224+ 804B 17           		rla
 225+ 804C CB 12        		rl	d
 226+ 804E 17           		rla
 227+ 804F CB 12        		rl	d
 228+ 8051 17           		rla
 229+ 8052 CB 12        		rl	d
 230+ 8054 5F           		ld	e, a
 231+ 8055
 232+ 8055 26 00        		ld		h, 0
 233+ 8057 19           		add		hl, de
 234+ 8058 ED 5B D2 81  		ld		de, (CurrScrAttrAddr)
 235+ 805C 19           		add		hl, de
 236+ 805D 08           	ex		af, af'
 237+ 805E 4F           	ld		c, a
 238+ 805F 06 00        	ld		b, 0
 239+ 8061 54           	ld		d, h
 240+ 8062 5D           	ld		e, l
 241+ 8063 13           	inc 	de
 242+ 8064              StrClr	EQU	$ + 1
 243+ 8064 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 8066 ED B0        	ldir
 245+ 8068 C9           	ret
 246+ 8069              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 8069
 248+ 8069              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 8069              DrawLine:
 250+ 8069 32 81 5C     	ld		(CODE), a
 251+ 806C
 252+ 806C 38 04        	jr		c, VertDir
 253+ 806E 3E 1C        	ld		a, $1C
 254+ 8070 18 02        	jr		StoreDir
 255+ 8072              VertDir:
 256+ 8072 3E 14        	ld		a, $14
 257+ 8074              StoreDir:
 258+ 8074 32 84 80     	ld		(LineDir), a
 259+ 8077
 260+ 8077              DrawLineLoop:
 261+ 8077 ED 53 B0 5C  	ld		(LineCol), de
 262+ 807B D5           	push	de
 263+ 807C D9           		exx
 264+ 807D E5           		push	hl
 265+ 807E CD 3D 81     		call 	PrintChar
 266+ 8081 E1           		pop		hl
 267+ 8082 D9           		exx
 268+ 8083 D1           	pop		de
 269+ 8084              LineDir:
 270+ 8084 1C           	inc		e
 271+ 8085 10 F0        	djnz	DrawLineLoop
 272+ 8087
 273+ 8087 C9           	ret
 274+ 8088
 275+ 8088              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 8088
 277+ 8088              DrawHLines:
 278+ 8088 11 00 00     	ld		de, 0
 279+ 808B 06 40        	ld		b, 64
 280+ 808D 3E 87        	ld		a, CHR_H
 281+ 808F B7           	or		a
 282+ 8090 CD 69 80     	call	DrawLine
 283+ 8093
 284+ 8093 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 8096 06 40        	ld		b, 64
 286+ 8098 3E 87        	ld		a, CHR_H
 287+ 809A B7           	or		a
 288+ 809B CD 69 80     	call	DrawLine
 289+ 809E
 290+ 809E 06 04        	ld		b, 4
 291+ 80A0 11 10 00     	ld		de, LST_FIRST_COL
 292+ 80A3              DrawUpperIntersectLoop:
 293+ 80A3 C5           	push	bc
 294+ 80A4 D5           	push	de
 295+ 80A5 3E 85        		ld		a, CHR_UC
 296+ 80A7 CD C9 80     		call	DrawIntersect
 297+ 80AA D1           	pop		de
 298+ 80AB C1           	pop		bc
 299+ 80AC 21 0C 00     	ld		hl, NAMELEN+1
 300+ 80AF 19           	add		hl, de
 301+ 80B0 EB           	ex		de, hl
 302+ 80B1 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 80B3
 304+ 80B3 06 04        	ld		b, 4
 305+ 80B5 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 80B8              DrawLowerIntersectLoop:
 307+ 80B8 C5           	push	bc
 308+ 80B9 D5           	push	de
 309+ 80BA 3E 84        		ld		a, CHR_DC
 310+ 80BC CD C9 80     		call	DrawIntersect
 311+ 80BF D1           	pop		de
 312+ 80C0 C1           	pop		bc
 313+ 80C1 21 0C 00     	ld		hl, NAMELEN+1
 314+ 80C4 19           	add		hl, de
 315+ 80C5 EB           	ex		de, hl
 316+ 80C6 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 80C8
 318+ 80C8 C9           	ret
 319+ 80C9
 320+ 80C9
 321+ 80C9              DrawIntersect:
 322+ 80C9 21 B0 5C     	ld		hl, LineCol
 323+ 80CC 73           	ld		(hl), e
 324+ 80CD 23           	inc		hl
 325+ 80CE 72           	ld		(hl), d
 326+ 80CF 2B           	dec		hl
 327+ 80D0 32 81 5C     	ld		(CODE), a
 328+ 80D3 E5           	push	hl
 329+ 80D4 CD 3D 81     	call	PrintChar
 330+ 80D7 E1           	pop		hl
 331+ 80D8 34           	inc		(hl)
 332+ 80D9 3E 87        	ld		a, CHR_H
 333+ 80DB 32 81 5C     	ld		(CODE), a
 334+ 80DE CD 3D 81     	call	PrintChar
 335+ 80E1 C9           	ret
 336+ 80E2
 337+ 80E2
 338+ 80E2              DrawVLines:
 339+ 80E2 06 04        	ld		b, 4
 340+ 80E4 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 341+ 80E7              DrawVLinesLoop:
 342+ 80E7 C5           	push 	bc
 343+ 80E8 D5           	push	de
 344+ 80E9 06 15        		ld		b, LST_LINES_CNT
 345+ 80EB 3E 80        		ld		a, CHR_V
 346+ 80ED 37           		scf
 347+ 80EE CD 69 80     		call	DrawLine
 348+ 80F1 D1           	pop		de
 349+ 80F2 C1           	pop	bc
 350+ 80F3 7B           	ld		a, e
 351+ 80F4 C6 0C        	add		NAMELEN+1
 352+ 80F6 5F           	ld		e, a
 353+ 80F7 10 EE        	djnz	DrawVLinesLoop
 354+ 80F9 C9           	ret
 355+ 80FA
 356+ 80FA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 357+ 80FA
 358+ 80FA              ;IN: A = color mask
 359+ 80FA              DrawCursor:
 360+ 80FA ED 5B 0B 89  	ld	de, (CursorAddr)
 361+ 80FE 06 06        	ld	b, 	(NAMELEN + 1)/2
 362+ 8100              DrawCursorLoop:
 363+ 8100 12           	ld	(de), a
 364+ 8101 13           	inc de
 365+ 8102 10 FC        	djnz DrawCursorLoop
 366+ 8104 C9           	ret
 367+ 8105
 368+ 8105              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 369+ 8105
 370+ 8105              ;IN:	A = file idx.
 371+ 8105              MoveCursor:
 372+ 8105              	;File idx / SCR_LINES => cursor line & column
 373+ 8105 6F           	ld		l, a
 374+ 8106 26 00        	ld		h, 0
 375+ 8108 0E 15        	ld		c, LST_LINES_CNT
 376+ 810A CD E4 76     	call	Div					;HL = file column, A = line
 377+ 810D
 378+ 810D              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 379+ 810D C6 01        	add		LST_FIRST_LINE
 380+ 810F
 381+ 810F
 382+ 810F 54           	ld d, h
 383+ 8110 5D           	ld e, l
 384+ 8111 21 00 00     	ld	hl, 0
 385+ 8114
 386+ 8114              	;line*32
 387+ 8114 17           	rla
 388+ 8115 17           	rla
 389+ 8116 17           	rla
 390+ 8117 17           	rla
 391+ 8118 CB 14        	rl h
 392+ 811A 17           	rla
 393+ 811B CB 14        	rl h
 394+ 811D 6F           	ld l, a
 395+ 811E
 396+ 811E
 397+ 811E              	;col * 6
 398+ 811E E5           	push	hl					;save line * 32
 399+ 811F 3E 06        		ld		a, (NAMELEN + 1)/2
 400+ 8121 CD 04 77     		call	Mul				;HL = column * 12/2
 401+ 8124 D1           	pop		de
 402+ 8125 19           	add		hl, de
 403+ 8126
 404+ 8126 11 08 00     	ld		de, LST_FIRST_COL/2
 405+ 8129 ED 4B D2 81  	ld		bc, (CurrScrAttrAddr)
 406+ 812D 19           	add		hl, de
 407+ 812E 09           	add		hl, bc
 408+ 812F
 409+ 812F              	;clear old cursor
 410+ 812F 3E 45        	ld		a, SCR_DEF_CLR
 411+ 8131 CD FA 80     	call	DrawCursor
 412+ 8134
 413+ 8134              	;draw new one
 414+ 8134 22 0B 89     	ld		(CursorAddr), hl
 415+ 8137 3E 60        	ld		a, SCR_SEL_CLR
 416+ 8139 CD FA 80     	call	DrawCursor
 417+ 813C
 418+ 813C C9           	ret
 419+ 813D
 420+ 813D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 421+ 813D
 422+ 813D              PrintChar:
 423+ 813D ED 5B B0 5C      ld		de, (LineCol)
 424+ 8141
 425+ 8141                  ;calculate 64 column screen address
 426+ 8141              	;IN: D = line, E = col
 427+ 8141              	;OUT: HL = screen address
 428+ 8141
 429+ 8141 CB 3B            SRL     E                                       ;col = col/2
 430+ 8143 CB 19            RR      C                                       ;mark odd/even column
 431+ 8145 7A               LD      A, D                            ;A = line
 432+ 8146 E6 18            AND 24                                  ;keep only %00011000
 433+ 8148 2A D0 81         ld		hl, (CurrScrAddr)
 434+ 814B B4               OR      h								;add screen start address
 435+ 814C 67               LD      H, A                            ;save H
 436+ 814D 7A               LD      A, D                            ;A = line
 437+ 814E E6 07            AND 7                                   ;keep only %00000111
 438+ 8150 0F               RRCA                                    ;%10000011
 439+ 8151 0F               RRCA                                    ;%11000001
 440+ 8152 0F               RRCA                                    ;%11100000
 441+ 8153 B3               OR      E                                       ;add column
 442+ 8154 6F               LD      L, A                            ;HL = screen address
 443+ 8155
 444+ 8155              PrintChar3:
 445+ 8155                  ;get font address
 446+ 8155 E5               PUSH HL
 447+ 8156 AF                   XOR A
 448+ 8157 67                   LD  H, A
 449+ 8158 3A 81 5C             LD  A, (CODE)
 450+ 815B D6 20                SUB ' '
 451+ 815D 6F                   LD  L, A
 452+ 815E 29                   ADD     HL, HL                  ;char code = char code * 8
 453+ 815F 29                   ADD     HL, HL                  ;i.e. offset into font table
 454+ 8160 29                   ADD     HL, HL
 455+ 8161 11 F1 93             LD      DE, FontTable             ;get font table
 456+ 8164 19                   ADD     HL, DE
 457+ 8165 EB                   EX      DE, HL                  ;DE = our char font address
 458+ 8166 E1               POP     HL
 459+ 8167
 460+ 8167
 461+ 8167                  ;print a char
 462+ 8167 06 08            LD      B, 8                            ;char height is 8 lines
 463+ 8169              PrintCharLine:
 464+ 8169 1A                   LD      A, (DE)                         ;load char line in A
 465+ 816A
 466+ 816A CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 467+ 816C 20 06                JR  	NZ, NoTurn
 468+ 816E
 469+ 816E 07                   RLCA
 470+ 816F 07                   RLCA
 471+ 8170 07                   RLCA
 472+ 8171 07                   RLCA
 473+ 8172 18 01                JR      Store
 474+ 8174              NoTurn:
 475+ 8174 B6                   OR (HL)
 476+ 8175              Store:
 477+ 8175 77                   LD (HL), A
 478+ 8176
 479+ 8176 13                   INC     DE                                      ;next char line in font table
 480+ 8177 24                   INC     H                                       ;next char line on screen
 481+ 8178 10 EF            DJNZ PrintCharLine                  ;last line of char?
 482+ 817A
 483+ 817A C9               ret
 484+ 817B
 485+ 817B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 486+ 817B
 487+ 817B              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 488+ 817B              ReadString:
 489+ 817B 21 59 97     	ld		hl, FileData
 490+ 817E D5           	push	de
 491+ 817F DD E1        	pop		ix
 492+ 8181
 493+ 8181              ReadStringLoop:
 494+ 8181 D5           	push	de
 495+ 8182 E5           	push	hl
 496+ 8183 CD D5 7F     		call ReadChar
 497+ 8186 E1           	pop		hl
 498+ 8187 D1           	pop		de
 499+ 8188
 500+ 8188 FE 0D        	cp	KEY_ENTER
 501+ 818A C8           	ret z
 502+ 818B
 503+ 818B FE 0C        	cp  KEY_BACKSP
 504+ 818D 20 0F        	jr	nz, ReadStrChar
 505+ 818F
 506+ 818F E5           	push hl
 507+ 8190 01 5A 97     	ld   bc, FileData+1
 508+ 8193 ED 42        	sbc	 hl, bc
 509+ 8195 E1           	pop  hl
 510+ 8196 38 16        	jr   c, ReadStrPrint
 511+ 8198
 512+ 8198 1B           	dec	de
 513+ 8199 2B           	dec	hl
 514+ 819A 36 20        	ld	(hl), ' '
 515+ 819C 18 10        	jr	ReadStrPrint
 516+ 819E
 517+ 819E              ReadStrChar:
 518+ 819E FE 20        	cp	' '
 519+ 81A0 38 DF        	jr	c, ReadStringLoop
 520+ 81A2 FE 8C        	cp	CHR_HALF
 521+ 81A4 30 DB        	jr	nc, ReadStringLoop
 522+ 81A6
 523+ 81A6              	;Check end of string and go back if found.
 524+ 81A6 46           	ld	b, (hl)
 525+ 81A7 CB 78        	bit 7, b
 526+ 81A9 20 03        	jr	nz, ReadStrPrint
 527+ 81AB
 528+ 81AB 77           	ld	(hl), a
 529+ 81AC 23           	inc	hl
 530+ 81AD 13           	inc	de
 531+ 81AE
 532+ 81AE              ReadStrPrint:
 533+ 81AE E5           	push	hl
 534+ 81AF D5           	push	de
 535+ 81B0 21 59 97     	ld		hl, FileData
 536+ 81B3 DD E5        	push	ix
 537+ 81B5 D1           	pop		de
 538+ 81B6 CD 11 80     	call	PrintStr
 539+ 81B9 D1           	pop		de
 540+ 81BA E1           	pop		hl
 541+ 81BB
 542+ 81BB 18 C4        	jr		ReadStringLoop
 543+ 81BD
 544+ 81BD              ClearNMsgLines:
 545+ 81BD 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 546+ 81C0              ClearNMsgLinesLoop:
 547+ 81C0 D5           	push	de
 548+ 81C1 C5           	push	bc
 549+ 81C2 21 A4 87     	ld		hl, MsgClear
 550+ 81C5 3E 45        	ld		a, SCR_DEF_CLR
 551+ 81C7 CD 39 80     	call	PrintStrClr
 552+ 81CA C1           	pop		bc
 553+ 81CB D1           	pop		de
 554+ 81CC 14           	inc		d
 555+ 81CD 10 F1        	djnz	ClearNMsgLinesLoop
 556+ 81CF
 557+ 81CF C9           	ret
 558+ 81D0
 559+ 81D0 00 40        CurrScrAddr		DEFW	SCR_ADDR
 560+ 81D2 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 561+ 81D4
 562+ 81D4                 	endif
# file closed: ui.asm
1499  81D4              	include "math.asm"
# file opened: math.asm
   1+ 81D4              	ifndef	_MATH_
   2+ 81D4 ~            	define	_MATH_
   3+ 81D4 ~
   4+ 81D4 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 81D4 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 81D4 ~
   7+ 81D4 ~
   8+ 81D4 ~            Word2Txt:
   9+ 81D4 ~            	IFUSED
  10+ 81D4 ~            	push	de
  11+ 81D4 ~            		call	Word2Txt_
  12+ 81D4 ~            	pop	de
  13+ 81D4 ~
  14+ 81D4 ~            	ld	b, 4
  15+ 81D4 ~            	call	StrippLeading0
  16+ 81D4 ~            	ret
  17+ 81D4 ~
  18+ 81D4 ~            Byte2Txt:
  19+ 81D4 ~            	push	de
  20+ 81D4 ~            		call	Byte2Txt_
  21+ 81D4 ~            	pop	de
  22+ 81D4 ~
  23+ 81D4 ~            	ld	b, 2
  24+ 81D4 ~            	call	StrippLeading0
  25+ 81D4 ~            	ret
  26+ 81D4 ~            	ENDIF
  27+ 81D4 ~
  28+ 81D4 ~
  29+ 81D4 ~            StrippLeading0:
  30+ 81D4 ~            	ld	a, (de)
  31+ 81D4 ~            	cp	'1'
  32+ 81D4 ~            	ret	nc
  33+ 81D4 ~
  34+ 81D4 ~            	ld	a, ' '
  35+ 81D4 ~            	ld	(de), a
  36+ 81D4 ~            	inc	de
  37+ 81D4 ~            	djnz	StrippLeading0
  38+ 81D4 ~            	ret
  39+ 81D4 ~
  40+ 81D4 ~
  41+ 81D4 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 81D4 ~            Word2Txt_:
  43+ 81D4 ~            	ld bc, -10000
  44+ 81D4 ~            	call DigitLoop
  45+ 81D4 ~            	ld bc, -1000
  46+ 81D4 ~            	call DigitLoop
  47+ 81D4 ~            Byte2Txt_:
  48+ 81D4 ~            	ld bc, -100
  49+ 81D4 ~            	call DigitLoop
  50+ 81D4 ~            	ld bc, -10
  51+ 81D4 ~            	call DigitLoop
  52+ 81D4 ~            	ld bc, -1
  53+ 81D4 ~
  54+ 81D4 ~            DigitLoop:
  55+ 81D4 ~            	ld	a, '0' - 1
  56+ 81D4 ~            DivNrLoop:
  57+ 81D4 ~            	inc	a		;increase reminder
  58+ 81D4 ~            	add	hl, bc	;substract divizor
  59+ 81D4 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 81D4 ~            	sbc	hl, bc	;nope, restore
  61+ 81D4 ~
  62+ 81D4 ~            	ld (de), a
  63+ 81D4 ~            	inc de
  64+ 81D4 ~            	ret
  65+ 81D4 ~
  66+ 81D4 ~
  67+ 81D4 ~            ;Input: HL = Dividend, C = Divisor
  68+ 81D4 ~            ;Output: HL = Quotient, A = Remainder
  69+ 81D4 ~            ;Warning: doesn't work with divisor >= $80
  70+ 81D4 ~            Div:
  71+ 81D4 ~            	IFUSED
  72+ 81D4 ~            	xor a
  73+ 81D4 ~            	ld b, 16
  74+ 81D4 ~
  75+ 81D4 ~            DivLoop:
  76+ 81D4 ~            	add	hl,hl
  77+ 81D4 ~            	rla
  78+ 81D4 ~            	cp	c
  79+ 81D4 ~            	jr	c, NoSub
  80+ 81D4 ~            	sub	c
  81+ 81D4 ~            	inc	l
  82+ 81D4 ~            NoSub:
  83+ 81D4 ~            	djnz DivLoop
  84+ 81D4 ~
  85+ 81D4 ~            	ret
  86+ 81D4 ~            	ENDIF
  87+ 81D4 ~
  88+ 81D4 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 81D4 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 81D4 ~            Div2:
  91+ 81D4 ~            	ld hl, 0
  92+ 81D4 ~            	ld b, 16
  93+ 81D4 ~            Div2Loop:
  94+ 81D4 ~            	sll c	; unroll 16 times
  95+ 81D4 ~            	rla		; ...
  96+ 81D4 ~            	adc	hl,hl	; ...
  97+ 81D4 ~            	sbc	hl,de	; ...
  98+ 81D4 ~            	jr	nc,$+4	; ...
  99+ 81D4 ~            	add	hl,de	; ...
 100+ 81D4 ~            	dec	c	; ...
 101+ 81D4 ~            	djnz Div2Loop
 102+ 81D4 ~            	ret
 103+ 81D4 ~
 104+ 81D4 ~
 105+ 81D4 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 81D4 ~            ;Output: A:HL = Product
 107+ 81D4 ~            Mul:
 108+ 81D4 ~            	IFUSED
 109+ 81D4 ~            	ld hl, 0
 110+ 81D4 ~            	ld bc, $0700
 111+ 81D4 ~
 112+ 81D4 ~            	add	a, a	; optimised 1st iteration
 113+ 81D4 ~            	jr	nc, MulLoop
 114+ 81D4 ~            	ld	h, d
 115+ 81D4 ~            	ld	l, e
 116+ 81D4 ~
 117+ 81D4 ~            MulLoop:
 118+ 81D4 ~            	add	hl,hl
 119+ 81D4 ~            	rla
 120+ 81D4 ~            	jr	nc, NoAdd
 121+ 81D4 ~            	add	hl,de
 122+ 81D4 ~            	adc	a,c
 123+ 81D4 ~            NoAdd:
 124+ 81D4 ~            	djnz MulLoop
 125+ 81D4 ~
 126+ 81D4 ~            	ret
 127+ 81D4 ~            	ENDIF
 128+ 81D4 ~
 129+ 81D4 ~
 130+ 81D4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131+ 81D4 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132+ 81D4 ~            Byte2Hex:
 133+ 81D4 ~            	xor	a
 134+ 81D4 ~            	rld
 135+ 81D4 ~            	call	Byte2HexNibble
 136+ 81D4 ~
 137+ 81D4 ~            Byte2HexNibble:
 138+ 81D4 ~            	push	af
 139+ 81D4 ~            	daa
 140+ 81D4 ~            	add	a,$F0
 141+ 81D4 ~            	adc	a,$40
 142+ 81D4 ~
 143+ 81D4 ~            	ld	(de), a
 144+ 81D4 ~            	inc	de
 145+ 81D4 ~
 146+ 81D4 ~            	pop	af
 147+ 81D4 ~            	rld
 148+ 81D4 ~            	ret
 149+ 81D4 ~
 150+ 81D4 ~
 151+ 81D4 ~            Byte2HexHex:
 152+ 81D4 ~            	call	Byte2Hex
 153+ 81D4 ~            	inc	hl
 154+ 81D4 ~            	ld	a, ' '
 155+ 81D4 ~            	ld	(de), a
 156+ 81D4 ~            	inc	de
 157+ 81D4 ~            	ret
 158+ 81D4 ~
 159+ 81D4 ~            Byte2HexChar:
 160+ 81D4 ~            	ld	a, CHAR_CR
 161+ 81D4 ~            	cp	(hl)
 162+ 81D4 ~            	jr	nz, Bin2HexLineLoopTextCopy
 163+ 81D4 ~
 164+ 81D4 ~            Bin2HexLineLoopTextReplace:
 165+ 81D4 ~            	ld	a, '.'
 166+ 81D4 ~            	ld	(hl), a
 167+ 81D4 ~
 168+ 81D4 ~            Bin2HexLineLoopTextCopy:
 169+ 81D4 ~            	ldi
 170+ 81D4 ~            	ret
 171+ 81D4 ~
 172+ 81D4 ~
 173+ 81D4 ~            HEX_COLUMNS	EQU	16
 174+ 81D4 ~
 175+ 81D4 ~            Bin2HexLine:
 176+ 81D4 ~            	;Hex part
 177+ 81D4 ~            	ld	b, HEX_COLUMNS
 178+ 81D4 ~            	push	hl
 179+ 81D4 ~            Bin2HexLineLoopHex:
 180+ 81D4 ~            		call	Byte2HexHex
 181+ 81D4 ~
 182+ 81D4 ~            		;Put separator in the middle of hex line.
 183+ 81D4 ~            		ld	a, HEX_COLUMNS/2+1
 184+ 81D4 ~            		cp	b
 185+ 81D4 ~            		jr	nz, Bin2HexLineLoopHexNotHalf
 186+ 81D4 ~            		dec	de
 187+ 81D4 ~            		ld	a, CHR_V
 188+ 81D4 ~            		ld	(de), a
 189+ 81D4 ~            		inc	de
 190+ 81D4 ~
 191+ 81D4 ~            Bin2HexLineLoopHexNotHalf:
 192+ 81D4 ~            		djnz	Bin2HexLineLoopHex
 193+ 81D4 ~            	pop	hl
 194+ 81D4 ~
 195+ 81D4 ~            	dec	de
 196+ 81D4 ~            	ld	a, CHR_V
 197+ 81D4 ~            	ld	(de), a
 198+ 81D4 ~            	inc	de
 199+ 81D4 ~
 200+ 81D4 ~            	;String part
 201+ 81D4 ~            Bin2HexLineText:
 202+ 81D4 ~            	;just to not alter B with LDI, set C to something > 16
 203+ 81D4 ~            	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 204+ 81D4 ~            Bin2HexLineLoopText:
 205+ 81D4 ~            	call	Byte2HexChar
 206+ 81D4 ~            	djnz	Bin2HexLineLoopText
 207+ 81D4 ~            	ret
 208+ 81D4 ~
 209+ 81D4 ~
 210+ 81D4 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 211+ 81D4 ~            ;Converts binary buffer at HL to hex string at DE
 212+ 81D4 ~            Bin2HexStr:
 213+ 81D4 ~            	;Calculate the number of full lines by dividing BC to 16.
 214+ 81D4 ~            	xor	a
 215+ 81D4 ~
 216+ 81D4 ~            	rr	b
 217+ 81D4 ~            	rr	c
 218+ 81D4 ~            	rra
 219+ 81D4 ~
 220+ 81D4 ~            	rr	b
 221+ 81D4 ~            	rr	c
 222+ 81D4 ~            	rra
 223+ 81D4 ~
 224+ 81D4 ~            	rr	b
 225+ 81D4 ~            	rr	c
 226+ 81D4 ~            	rra
 227+ 81D4 ~
 228+ 81D4 ~            	rr	b
 229+ 81D4 ~            	rr	c
 230+ 81D4 ~            	rra
 231+ 81D4 ~
 232+ 81D4 ~            	rra
 233+ 81D4 ~            	rra
 234+ 81D4 ~            	rra
 235+ 81D4 ~            	rra
 236+ 81D4 ~
 237+ 81D4 ~            	ex		af, af'		;Keep reminder
 238+ 81D4 ~
 239+ 81D4 ~            Bin2HexStrLoop:
 240+ 81D4 ~            	push	bc
 241+ 81D4 ~            		call	Bin2HexLine
 242+ 81D4 ~            	pop	bc
 243+ 81D4 ~
 244+ 81D4 ~            	dec	bc
 245+ 81D4 ~            	ld	a, b
 246+ 81D4 ~            	or	c
 247+ 81D4 ~            	jr	nz, Bin2HexStrLoop
 248+ 81D4 ~
 249+ 81D4 ~            	;Set remaining imcomplete line.
 250+ 81D4 ~            	push	de
 251+ 81D4 ~            	push	hl
 252+ 81D4 ~            		ld	a, ' '
 253+ 81D4 ~            		ld	b, COL_CNT
 254+ 81D4 ~            Bin2HexLineClear:
 255+ 81D4 ~            		ld	(de), a
 256+ 81D4 ~            		inc	de
 257+ 81D4 ~            		djnz	Bin2HexLineClear
 258+ 81D4 ~            	pop	hl
 259+ 81D4 ~            	pop	de
 260+ 81D4 ~
 261+ 81D4 ~            	push	de
 262+ 81D4 ~            	pop	ix
 263+ 81D4 ~
 264+ 81D4 ~            	ld	bc, HEX_COLUMNS*3
 265+ 81D4 ~            	add	ix, bc
 266+ 81D4 ~
 267+ 81D4 ~            	;Write hex and char part
 268+ 81D4 ~            	ex	af, af'
 269+ 81D4 ~            	or	a
 270+ 81D4 ~            	ret	z
 271+ 81D4 ~
 272+ 81D4 ~            	ld	b, a
 273+ 81D4 ~            	ld	c, HEX_COLUMNS*2
 274+ 81D4 ~
 275+ 81D4 ~            Bin2HexLineLoopHex2:
 276+ 81D4 ~            	call	Byte2HexHex
 277+ 81D4 ~            	dec	hl
 278+ 81D4 ~
 279+ 81D4 ~            	push	de
 280+ 81D4 ~            		ld	e, ixl
 281+ 81D4 ~            		ld	d, ixh
 282+ 81D4 ~            		call	Byte2HexChar
 283+ 81D4 ~            	pop	de
 284+ 81D4 ~            	inc	ix
 285+ 81D4 ~            	djnz	Bin2HexLineLoopHex2
 286+ 81D4 ~
 287+ 81D4 ~            	ld	a, CHR_V
 288+ 81D4 ~            	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 289+ 81D4 ~            	ld	(ix + HEX_COLUMNS*3 - 1), a
 290+ 81D4 ~
 291+ 81D4 ~            	ret
 292+ 81D4 ~
 293+ 81D4              	endif
# file closed: math.asm
1500  81D4              	include "txtview.asm"
# file opened: txtview.asm
   1+ 81D4              	IFNDEF _TXTVIEW_
   2+ 81D4              	DEFINE _TXTVIEW_
   3+ 81D4
   4+ 81D4              LINE_CNT	EQU	23
   5+ 81D4              COL_CNT		EQU	64
   6+ 81D4
   7+ 81D4              CHAR_CR	EQU	$0D
   8+ 81D4              CHAR_LF	EQU	$0A
   9+ 81D4              CHAR_TAB	EQU	$09
  10+ 81D4              CHAR_EOF	EQU	$1A
  11+ 81D4
  12+ 81D4              COORDS		EQU	23728	;Coordinates
  13+ 81D4              SCRLinesDown	EQU	PRN_BUF
  14+ 81D4              SCRLinesUp	EQU	SCRLinesDown + LINE_CNT*2
  15+ 81D4
  16+ 81D4
  17+ 81D4              	include "scroll.asm"
# file opened: scroll.asm
   1++81D4              ;Scrolling routines for UP/DOWN
   2++81D4              ;They use 2 tables of pointers of screen cell rows.
   3++81D4              ;One table has addresses in increasing order, for scroll down,
   4++81D4              ;the other in decreasing order, for scroll up, so the same
   5++81D4              ;scroll routine is used in both cases.
   6++81D4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++81D4
   8++81D4              ; Char Down
   9++81D4              ; Adjusts screen address HL to move eight pixels down on the display.
  10++81D4              ; enter: HL = valid screen address
  11++81D4              ; exit : HL = moves one character down
  12++81D4              ; used : AF, HL
  13++81D4              GetCellDown:
  14++81D4 7D           	ld a,l
  15++81D5 C6 20        	add a,$20
  16++81D7 6F           	ld l,a
  17++81D8 D0           	ret nc
  18++81D9 7C           	ld a,h
  19++81DA C6 08        	add a,$08
  20++81DC 67           	ld h,a
  21++81DD C9           	ret
  22++81DE
  23++81DE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++81DE              ;Fills the two tables with pointers.
  25++81DE              ScrollInit:
  26++81DE 21 00 40     	ld		hl, SCR_ADDR
  27++81E1 06 17        	ld		b, LINE_CNT
  28++81E3 DD 21 00 5B  	ld		ix, SCRLinesDown
  29++81E7
  30++81E7              	;Don't init again if already did it.
  31++81E7 DD 7E 00     	ld		a, (ix)
  32++81EA BD           	cp		l
  33++81EB 20 05        	jr		nz, FillScrLinesLoop
  34++81ED DD 7E 01     	ld		a, (ix+1)
  35++81F0 BC           	cp		h
  36++81F1 C8           	ret		z
  37++81F2
  38++81F2              FillScrLinesLoop:
  39++81F2 DD 75 00     	ld		(ix), l
  40++81F5 DD 74 01     	ld		(ix+1), h
  41++81F8 DD 23        	inc		ix
  42++81FA DD 23        	inc		ix
  43++81FC              	;inc. pointer in destination table (of pointers to lines)
  44++81FC CD D4 81     	call	GetCellDown
  45++81FF 10 F1        	djnz	FillScrLinesLoop
  46++8201
  47++8201              	;now fill the table in reverse, every 2 bytes
  48++8201 DD E5        	push	ix
  49++8203 E1           	pop		hl
  50++8204 2B           	dec		hl
  51++8205 06 17        	ld		b, LINE_CNT
  52++8207              FillScrLinesRev:
  53++8207 56           	ld		d, (hl)
  54++8208 2B           	dec		hl
  55++8209 5E           	ld		e, (hl)
  56++820A 2B           	dec		hl
  57++820B
  58++820B DD 73 00     	ld		(ix), e
  59++820E DD 72 01     	ld		(ix+1), d
  60++8211 DD 23        	inc		ix
  61++8213 DD 23        	inc		ix
  62++8215 10 F0        	djnz	FillScrLinesRev
  63++8217 C9           	ret
  64++8218
  65++8218              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  66++8218              ScrollUp:
  67++8218 21 2E 5B     	ld		hl, SCRLinesUp
  68++821B 18 03        	jr		Scroll
  69++821D
  70++821D              ScrollDown:
  71++821D 21 00 5B     	ld		hl, SCRLinesDown
  72++8220
  73++8220              Scroll:
  74++8220 22 2E 82     	ld		(ScrollDownPtrDest), hl
  75++8223 23           	inc		hl
  76++8224 23           	inc		hl
  77++8225 22 31 82     	ld		(ScrollDownPtrSrc), hl
  78++8228 0E 16        	ld		c, LINE_CNT - 1
  79++822A
  80++822A              ScrollDownLoop2:
  81++822A 06 04        	ld		b, 4
  82++822C              ScrollDownPtrDest	EQU	$ + 2
  83++822C ED 5B 00 5B  	ld		de, (SCRLinesDown)
  84++8230              ScrollDownPtrSrc	EQU	$ + 1
  85++8230 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  86++8233
  87++8233              ScrollDownLoop:					;copy a single char line
  88++8233 C5           	push	bc
  89++8234 01 20 00     	ld		bc, 32
  90++8237 ED B0        	ldir
  91++8239 2B           	dec		hl
  92++823A 1B           	dec		de
  93++823B 24           	inc		h
  94++823C 14           	inc		d
  95++823D 01 20 00     	ld		bc, 32
  96++8240 ED B8        	lddr
  97++8242 23           	inc		hl
  98++8243 13           	inc		de
  99++8244 24           	inc		h
 100++8245 14           	inc		d
 101++8246 C1           	pop		bc
 102++8247 10 EA        	djnz	ScrollDownLoop
 103++8249
 104++8249 0D           	dec		c
 105++824A C8           	ret		z
 106++824B
 107++824B 2A 31 82     	ld		hl, (ScrollDownPtrSrc)
 108++824E 22 2E 82     	ld		(ScrollDownPtrDest), hl
 109++8251 23           	inc		hl
 110++8252 23           	inc		hl
 111++8253 22 31 82     	ld		(ScrollDownPtrSrc), hl
 112++8256 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
  18+ 8258              	include "math.asm"
# file opened: math.asm
   1++8258              	ifndef	_MATH_
   2++8258 ~            	define	_MATH_
   3++8258 ~
   4++8258 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++8258 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6++8258 ~
   7++8258 ~
   8++8258 ~            Word2Txt:
   9++8258 ~            	IFUSED
  10++8258 ~            	push	de
  11++8258 ~            		call	Word2Txt_
  12++8258 ~            	pop	de
  13++8258 ~
  14++8258 ~            	ld	b, 4
  15++8258 ~            	call	StrippLeading0
  16++8258 ~            	ret
  17++8258 ~
  18++8258 ~            Byte2Txt:
  19++8258 ~            	push	de
  20++8258 ~            		call	Byte2Txt_
  21++8258 ~            	pop	de
  22++8258 ~
  23++8258 ~            	ld	b, 2
  24++8258 ~            	call	StrippLeading0
  25++8258 ~            	ret
  26++8258 ~            	ENDIF
  27++8258 ~
  28++8258 ~
  29++8258 ~            StrippLeading0:
  30++8258 ~            	ld	a, (de)
  31++8258 ~            	cp	'1'
  32++8258 ~            	ret	nc
  33++8258 ~
  34++8258 ~            	ld	a, ' '
  35++8258 ~            	ld	(de), a
  36++8258 ~            	inc	de
  37++8258 ~            	djnz	StrippLeading0
  38++8258 ~            	ret
  39++8258 ~
  40++8258 ~
  41++8258 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42++8258 ~            Word2Txt_:
  43++8258 ~            	ld bc, -10000
  44++8258 ~            	call DigitLoop
  45++8258 ~            	ld bc, -1000
  46++8258 ~            	call DigitLoop
  47++8258 ~            Byte2Txt_:
  48++8258 ~            	ld bc, -100
  49++8258 ~            	call DigitLoop
  50++8258 ~            	ld bc, -10
  51++8258 ~            	call DigitLoop
  52++8258 ~            	ld bc, -1
  53++8258 ~
  54++8258 ~            DigitLoop:
  55++8258 ~            	ld	a, '0' - 1
  56++8258 ~            DivNrLoop:
  57++8258 ~            	inc	a		;increase reminder
  58++8258 ~            	add	hl, bc	;substract divizor
  59++8258 ~            	jr	c, DivNrLoop	;still dividing?
  60++8258 ~            	sbc	hl, bc	;nope, restore
  61++8258 ~
  62++8258 ~            	ld (de), a
  63++8258 ~            	inc de
  64++8258 ~            	ret
  65++8258 ~
  66++8258 ~
  67++8258 ~            ;Input: HL = Dividend, C = Divisor
  68++8258 ~            ;Output: HL = Quotient, A = Remainder
  69++8258 ~            ;Warning: doesn't work with divisor >= $80
  70++8258 ~            Div:
  71++8258 ~            	IFUSED
  72++8258 ~            	xor a
  73++8258 ~            	ld b, 16
  74++8258 ~
  75++8258 ~            DivLoop:
  76++8258 ~            	add	hl,hl
  77++8258 ~            	rla
  78++8258 ~            	cp	c
  79++8258 ~            	jr	c, NoSub
  80++8258 ~            	sub	c
  81++8258 ~            	inc	l
  82++8258 ~            NoSub:
  83++8258 ~            	djnz DivLoop
  84++8258 ~
  85++8258 ~            	ret
  86++8258 ~            	ENDIF
  87++8258 ~
  88++8258 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++8258 ~            ;Output: A:C = Quotient, HL = Remainder
  90++8258 ~            Div2:
  91++8258 ~            	ld hl, 0
  92++8258 ~            	ld b, 16
  93++8258 ~            Div2Loop:
  94++8258 ~            	sll c	; unroll 16 times
  95++8258 ~            	rla		; ...
  96++8258 ~            	adc	hl,hl	; ...
  97++8258 ~            	sbc	hl,de	; ...
  98++8258 ~            	jr	nc,$+4	; ...
  99++8258 ~            	add	hl,de	; ...
 100++8258 ~            	dec	c	; ...
 101++8258 ~            	djnz Div2Loop
 102++8258 ~            	ret
 103++8258 ~
 104++8258 ~
 105++8258 ~            ;Input: A = Multiplier, DE = Multiplicand
 106++8258 ~            ;Output: A:HL = Product
 107++8258 ~            Mul:
 108++8258 ~            	IFUSED
 109++8258 ~            	ld hl, 0
 110++8258 ~            	ld bc, $0700
 111++8258 ~
 112++8258 ~            	add	a, a	; optimised 1st iteration
 113++8258 ~            	jr	nc, MulLoop
 114++8258 ~            	ld	h, d
 115++8258 ~            	ld	l, e
 116++8258 ~
 117++8258 ~            MulLoop:
 118++8258 ~            	add	hl,hl
 119++8258 ~            	rla
 120++8258 ~            	jr	nc, NoAdd
 121++8258 ~            	add	hl,de
 122++8258 ~            	adc	a,c
 123++8258 ~            NoAdd:
 124++8258 ~            	djnz MulLoop
 125++8258 ~
 126++8258 ~            	ret
 127++8258 ~            	ENDIF
 128++8258 ~
 129++8258 ~
 130++8258 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++8258 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132++8258 ~            Byte2Hex:
 133++8258 ~            	xor	a
 134++8258 ~            	rld
 135++8258 ~            	call	Byte2HexNibble
 136++8258 ~
 137++8258 ~            Byte2HexNibble:
 138++8258 ~            	push	af
 139++8258 ~            	daa
 140++8258 ~            	add	a,$F0
 141++8258 ~            	adc	a,$40
 142++8258 ~
 143++8258 ~            	ld	(de), a
 144++8258 ~            	inc	de
 145++8258 ~
 146++8258 ~            	pop	af
 147++8258 ~            	rld
 148++8258 ~            	ret
 149++8258 ~
 150++8258 ~
 151++8258 ~            Byte2HexHex:
 152++8258 ~            	call	Byte2Hex
 153++8258 ~            	inc	hl
 154++8258 ~            	ld	a, ' '
 155++8258 ~            	ld	(de), a
 156++8258 ~            	inc	de
 157++8258 ~            	ret
 158++8258 ~
 159++8258 ~            Byte2HexChar:
 160++8258 ~            	ld	a, CHAR_CR
 161++8258 ~            	cp	(hl)
 162++8258 ~            	jr	nz, Bin2HexLineLoopTextCopy
 163++8258 ~
 164++8258 ~            Bin2HexLineLoopTextReplace:
 165++8258 ~            	ld	a, '.'
 166++8258 ~            	ld	(hl), a
 167++8258 ~
 168++8258 ~            Bin2HexLineLoopTextCopy:
 169++8258 ~            	ldi
 170++8258 ~            	ret
 171++8258 ~
 172++8258 ~
 173++8258 ~            HEX_COLUMNS	EQU	16
 174++8258 ~
 175++8258 ~            Bin2HexLine:
 176++8258 ~            	;Hex part
 177++8258 ~            	ld	b, HEX_COLUMNS
 178++8258 ~            	push	hl
 179++8258 ~            Bin2HexLineLoopHex:
 180++8258 ~            		call	Byte2HexHex
 181++8258 ~
 182++8258 ~            		;Put separator in the middle of hex line.
 183++8258 ~            		ld	a, HEX_COLUMNS/2+1
 184++8258 ~            		cp	b
 185++8258 ~            		jr	nz, Bin2HexLineLoopHexNotHalf
 186++8258 ~            		dec	de
 187++8258 ~            		ld	a, CHR_V
 188++8258 ~            		ld	(de), a
 189++8258 ~            		inc	de
 190++8258 ~
 191++8258 ~            Bin2HexLineLoopHexNotHalf:
 192++8258 ~            		djnz	Bin2HexLineLoopHex
 193++8258 ~            	pop	hl
 194++8258 ~
 195++8258 ~            	dec	de
 196++8258 ~            	ld	a, CHR_V
 197++8258 ~            	ld	(de), a
 198++8258 ~            	inc	de
 199++8258 ~
 200++8258 ~            	;String part
 201++8258 ~            Bin2HexLineText:
 202++8258 ~            	;just to not alter B with LDI, set C to something > 16
 203++8258 ~            	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 204++8258 ~            Bin2HexLineLoopText:
 205++8258 ~            	call	Byte2HexChar
 206++8258 ~            	djnz	Bin2HexLineLoopText
 207++8258 ~            	ret
 208++8258 ~
 209++8258 ~
 210++8258 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 211++8258 ~            ;Converts binary buffer at HL to hex string at DE
 212++8258 ~            Bin2HexStr:
 213++8258 ~            	;Calculate the number of full lines by dividing BC to 16.
 214++8258 ~            	xor	a
 215++8258 ~
 216++8258 ~            	rr	b
 217++8258 ~            	rr	c
 218++8258 ~            	rra
 219++8258 ~
 220++8258 ~            	rr	b
 221++8258 ~            	rr	c
 222++8258 ~            	rra
 223++8258 ~
 224++8258 ~            	rr	b
 225++8258 ~            	rr	c
 226++8258 ~            	rra
 227++8258 ~
 228++8258 ~            	rr	b
 229++8258 ~            	rr	c
 230++8258 ~            	rra
 231++8258 ~
 232++8258 ~            	rra
 233++8258 ~            	rra
 234++8258 ~            	rra
 235++8258 ~            	rra
 236++8258 ~
 237++8258 ~            	ex		af, af'		;Keep reminder
 238++8258 ~
 239++8258 ~            Bin2HexStrLoop:
 240++8258 ~            	push	bc
 241++8258 ~            		call	Bin2HexLine
 242++8258 ~            	pop	bc
 243++8258 ~
 244++8258 ~            	dec	bc
 245++8258 ~            	ld	a, b
 246++8258 ~            	or	c
 247++8258 ~            	jr	nz, Bin2HexStrLoop
 248++8258 ~
 249++8258 ~            	;Set remaining imcomplete line.
 250++8258 ~            	push	de
 251++8258 ~            	push	hl
 252++8258 ~            		ld	a, ' '
 253++8258 ~            		ld	b, COL_CNT
 254++8258 ~            Bin2HexLineClear:
 255++8258 ~            		ld	(de), a
 256++8258 ~            		inc	de
 257++8258 ~            		djnz	Bin2HexLineClear
 258++8258 ~            	pop	hl
 259++8258 ~            	pop	de
 260++8258 ~
 261++8258 ~            	push	de
 262++8258 ~            	pop	ix
 263++8258 ~
 264++8258 ~            	ld	bc, HEX_COLUMNS*3
 265++8258 ~            	add	ix, bc
 266++8258 ~
 267++8258 ~            	;Write hex and char part
 268++8258 ~            	ex	af, af'
 269++8258 ~            	or	a
 270++8258 ~            	ret	z
 271++8258 ~
 272++8258 ~            	ld	b, a
 273++8258 ~            	ld	c, HEX_COLUMNS*2
 274++8258 ~
 275++8258 ~            Bin2HexLineLoopHex2:
 276++8258 ~            	call	Byte2HexHex
 277++8258 ~            	dec	hl
 278++8258 ~
 279++8258 ~            	push	de
 280++8258 ~            		ld	e, ixl
 281++8258 ~            		ld	d, ixh
 282++8258 ~            		call	Byte2HexChar
 283++8258 ~            	pop	de
 284++8258 ~            	inc	ix
 285++8258 ~            	djnz	Bin2HexLineLoopHex2
 286++8258 ~
 287++8258 ~            	ld	a, CHR_V
 288++8258 ~            	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 289++8258 ~            	ld	(ix + HEX_COLUMNS*3 - 1), a
 290++8258 ~
 291++8258 ~            	ret
 292++8258 ~
 293++8258              	endif
# file closed: math.asm
  19+ 8258
  20+ 8258              TextViewer:
  21+ 8258 CD A7 83     	call	TextViewIndex
  22+ 825B
  23+ 825B 21 00 00     	ld	hl, 0
  24+ 825E 22 B0 5C     	ld	(COORDS), hl
  25+ 8261 CD DE 81     	call	ScrollInit
  26+ 8264
  27+ 8264              	;Check if we have in file 23 lines or less.
  28+ 8264 2A 5D 84     	ld	hl, (LineCount)
  29+ 8267 01 17 00     	ld	bc, LINE_CNT
  30+ 826A B7           	or	a
  31+ 826B ED 42        	sbc	hl, bc
  32+ 826D 06 17        	ld	b, LINE_CNT
  33+ 826F 30 0A        	jr	nc, MoreThan23LinesInFile
  34+ 8271
  35+ 8271              	;If file has less than 23 lines, show only lines 0 to line count-1.
  36+ 8271 2A 5D 84     	ld	hl, (LineCount)
  37+ 8274 45           	ld	b, l
  38+ 8275 2B           	dec	hl
  39+ 8276 11 00 00     	ld	de, 0
  40+ 8279 18 1D        	jr	TextViewerShowBegining
  41+ 827B
  42+ 827B              MoreThan23LinesInFile:
  43+ 827B              	;Check last key pressed to see if we need to show last part of file or the first part.
  44+ 827B 3A 08 5C     	ld	a, (LAST_K)
  45+ 827E FE 0B        	cp	KEY_UP
  46+ 8280 11 00 00     	ld	de, 0
  47+ 8283 21 16 00     	ld	hl, LINE_CNT-1
  48+ 8286 20 10        	jr	nz, TextViewerShowBegining
  49+ 8288
  50+ 8288              	;Must show end of file.
  51+ 8288 2A 5D 84     	ld	hl, (LineCount)
  52+ 828B 2B           	dec	hl
  53+ 828C E5           	push	hl
  54+ 828D C5           	push	bc
  55+ 828E 01 16 00     		ld	bc, LINE_CNT-1
  56+ 8291 B7           		or	a
  57+ 8292 ED 42        		sbc	hl, bc
  58+ 8294 54           		ld	d, h
  59+ 8295 5D           		ld	e, l
  60+ 8296 C1           	pop	bc
  61+ 8297 E1           	pop	hl
  62+ 8298
  63+ 8298              TextViewerShowBegining:
  64+ 8298 22 61 84     	ld	(LastLineShown), hl
  65+ 829B ED 53 5F 84  	ld	(FirstLineShown), de
  66+ 829F
  67+ 829F              	;If first line is 0, don't need to add offset.
  68+ 829F 7A           	ld	a, d
  69+ 82A0 B3           	or	e
  70+ 82A1 DD 21 59 EA  	ld	ix, FileIdx
  71+ 82A5 28 0D        	jr	z, TextViewerLoop
  72+ 82A7
  73+ 82A7              	;Get pointer to the first line index.
  74+ 82A7 3E 03        	ld	a, 3
  75+ 82A9 C5           	push	bc
  76+ 82AA E5           	push	hl
  77+ 82AB CD 04 77     		call	Mul
  78+ 82AE 44           		ld	b, h
  79+ 82AF 4D           		ld	c, l
  80+ 82B0 DD 09        		add	ix, bc
  81+ 82B2 E1           	pop	hl
  82+ 82B3 C1           	pop	bc
  83+ 82B4
  84+ 82B4              ;Display first screen of text.
  85+ 82B4              TextViewerLoop:
  86+ 82B4 C5           	push	bc
  87+ 82B5 CD 03 84     		call	PrintOneLine
  88+ 82B8 DD 23        		inc	ix
  89+ 82BA DD 23        		inc	ix
  90+ 82BC DD 23        		inc	ix
  91+ 82BE
  92+ 82BE ED 5B B0 5C  		ld	de, (COORDS)
  93+ 82C2 14           		inc	d
  94+ 82C3 1E 00        		ld	e, 0
  95+ 82C5 ED 53 B0 5C  		ld	(COORDS), de
  96+ 82C9 C1           	pop	bc
  97+ 82CA 10 E8        	djnz	TextViewerLoop
  98+ 82CC
  99+ 82CC DD 2B        	dec	ix
 100+ 82CE DD 2B        	dec	ix
 101+ 82D0 DD 2B        	dec	ix
 102+ 82D2
 103+ 82D2 2A 5D 84     	ld	hl, (LineCount)
 104+ 82D5 11 7F 84     	ld	de, MsgLineTotal
 105+ 82D8 CD 9D 76     	call	Word2Txt
 106+ 82DB
 107+ 82DB              TextViewerLoop3:
 108+ 82DB 2A 61 84     	ld	hl, (LastLineShown)
 109+ 82DE 23           	inc	hl
 110+ 82DF 11 79 84     	ld	de, MsgLineNo
 111+ 82E2 CD 9D 76     	call	Word2Txt
 112+ 82E5 3A 16 89     	ld	a, (ViewFilePart)
 113+ 82E8 3C           	inc	a
 114+ 82E9 6F           	ld	l, a
 115+ 82EA 26 00        	ld	h, 0
 116+ 82EC 11 8D 84     	ld	de, MsgFilePart
 117+ 82EF CD A8 76     	call	Byte2Txt
 118+ 82F2
 119+ 82F2 2A 11 89     	ld	hl, (SelFileCache)
 120+ 82F5 11 68 84     	ld	de, MsgLineFileName
 121+ 82F8 06 0B        	ld	b, NAMELEN
 122+ 82FA              TextViewerShowFilename:
 123+ 82FA 7E           	ld	a, (hl)
 124+ 82FB E6 7F        	and	$7F
 125+ 82FD 12           	ld	(de), a
 126+ 82FE 23           	inc	hl
 127+ 82FF 13           	inc	de
 128+ 8300 10 F8        	djnz	TextViewerShowFilename
 129+ 8302
 130+ 8302 21 63 84     	ld	hl, MsgLine
 131+ 8305 11 00 17     	ld	de, LINE_CNT << 8
 132+ 8308 3E 60        	ld	a, SCR_SEL_CLR
 133+ 830A CD 39 80     	call	PrintStrClr
 134+ 830D
 135+ 830D CD D5 7F     	call	ReadChar
 136+ 8310
 137+ 8310 FE 0A        	cp	KEY_DOWN
 138+ 8312 28 51        	jr	z, TextViewerScrollDown
 139+ 8314 FE 61        	cp	'a'
 140+ 8316 28 4D        	jr	z, TextViewerScrollDown
 141+ 8318
 142+ 8318 FE 0B        	cp	KEY_UP
 143+ 831A 28 09        	jr	z, TextViewerScrollUp
 144+ 831C FE 71        	cp	'q'
 145+ 831E 28 05        	jr	z, TextViewerScrollUp
 146+ 8320
 147+ 8320 FE 30        	cp	'0'
 148+ 8322 C8           	ret	z
 149+ 8323
 150+ 8323 18 B6        	jr	TextViewerLoop3
 151+ 8325
 152+ 8325              TextViewerScrollUp:
 153+ 8325              	;Do nothing if showing begining of file.
 154+ 8325 ED 5B 5F 84  	ld	de, (FirstLineShown)
 155+ 8329 7A           	ld	a, d
 156+ 832A B3           	or	e
 157+ 832B 20 07        	jr	nz, TextViewerScrollUpOK
 158+ 832D
 159+ 832D 3A 16 89     	ld	a, (ViewFilePart)
 160+ 8330 B7           	or	a
 161+ 8331 28 A8        	jr	z, TextViewerLoop3
 162+ 8333 C9           	ret
 163+ 8334
 164+ 8334              TextViewerScrollUpOK:
 165+ 8334 1B           	dec	de
 166+ 8335 ED 53 5F 84  	ld	(FirstLineShown), de
 167+ 8339
 168+ 8339 2A 61 84     	ld	hl, (LastLineShown)
 169+ 833C 2B           	dec	hl
 170+ 833D 22 61 84     	ld	(LastLineShown), hl
 171+ 8340
 172+ 8340 7A           	ld	a, d
 173+ 8341 B3           	or	e
 174+ 8342 DD 21 59 EA  	ld	ix, FileIdx
 175+ 8346 28 09        	jr	z, TextViewerScrollUp1
 176+ 8348
 177+ 8348              	;3*FirstLineShown
 178+ 8348 3E 03        	ld	a, 3
 179+ 834A CD 04 77     	call	Mul
 180+ 834D EB           	ex	de, hl
 181+ 834E B7           	or	a
 182+ 834F DD 19        	add	ix, de
 183+ 8351
 184+ 8351
 185+ 8351              TextViewerScrollUp1:
 186+ 8351 CD 18 82     	call	ScrollUp
 187+ 8354 ED 5B B0 5C  	ld	de, (COORDS)
 188+ 8358 11 00 00     	ld	de, 0
 189+ 835B ED 53 B0 5C  	ld	(COORDS), de
 190+ 835F CD 03 84     	call	PrintOneLine
 191+ 8362
 192+ 8362 C3 DB 82     	jp	TextViewerLoop3
 193+ 8365
 194+ 8365              TextViewerScrollDown:
 195+ 8365              	;Exit if reached last line from file and more data is available for reading.
 196+ 8365 ED 5B 61 84  	ld	de, (LastLineShown)
 197+ 8369 13           	inc	de
 198+ 836A 2A 5D 84     	ld	hl, (LineCount)
 199+ 836D B7           	or	a
 200+ 836E ED 52        	sbc	hl, de
 201+ 8370 7C           	ld	a, h
 202+ 8371 B5           	or	l
 203+ 8372 20 08        	jr	nz, TextViewerScrollDown1
 204+ 8374
 205+ 8374              	;Exit if not end of file.
 206+ 8374 3A 1B 89     	ld	a, (CopyFileRes)
 207+ 8377 B7           	or	a
 208+ 8378 C2 DB 82     	jp	nz, TextViewerLoop3
 209+ 837B C9           	ret
 210+ 837C
 211+ 837C              TextViewerScrollDown1:
 212+ 837C ED 53 61 84  	ld	(LastLineShown), de
 213+ 8380
 214+ 8380 2A 5F 84     	ld	hl, (FirstLineShown)
 215+ 8383 23           	inc	hl
 216+ 8384 22 5F 84     	ld	(FirstLineShown), hl
 217+ 8387
 218+ 8387              	;Index of next line = LastLineShown * 3
 219+ 8387 3E 03        	ld	a, 3
 220+ 8389 CD 04 77     	call	Mul
 221+ 838C EB           	ex	de, hl
 222+ 838D DD 21 59 EA  	ld	ix, FileIdx
 223+ 8391 DD 19        	add	ix, de
 224+ 8393
 225+ 8393 CD 1D 82     	call	ScrollDown
 226+ 8396 ED 5B B0 5C  	ld	de, (COORDS)
 227+ 839A 11 00 16     	ld	de, (LINE_CNT - 1) << 8
 228+ 839D ED 53 B0 5C  	ld	(COORDS), de
 229+ 83A1
 230+ 83A1 CD 03 84     	call	PrintOneLine
 231+ 83A4 C3 DB 82     	jp	TextViewerLoop3
 232+ 83A7
 233+ 83A7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 234+ 83A7
 235+ 83A7              ;Creates line start indexes, with 2 byte address and 1 byte length for each line. Stores total line count.
 236+ 83A7              ;IN: HL=start address, BC: length
 237+ 83A7              TextViewIndex:
 238+ 83A7 DD 21 59 EA  	ld	ix, FileIdx
 239+ 83AB
 240+ 83AB              	;Save initial length in DE.
 241+ 83AB E5           	push	hl
 242+ 83AC B7           		or	a
 243+ 83AD ED 4A        		adc	hl, bc
 244+ 83AF EB           		ex	de, hl
 245+ 83B0 E1           	pop	hl
 246+ 83B1
 247+ 83B1 ED 53 5B 84  	ld	(FileEnd), de
 248+ 83B5
 249+ 83B5 11 00 00     	ld	de, 0				;Assume at least one line is shown, even if empty.
 250+ 83B8 ED 53 5D 84  	ld	(LineCount), de
 251+ 83BC
 252+ 83BC              TextViewIndexLoop:
 253+ 83BC DD 75 00     	ld	(ix), l
 254+ 83BF DD 74 01     	ld	(ix+1), h
 255+ 83C2
 256+ 83C2              	;BC to hold 64 or less, if on last line from file.
 257+ 83C2 ED 5B 5B 84  	ld	de, (FileEnd)
 258+ 83C6 EB           	ex	de, hl
 259+ 83C7 B7           	or	a
 260+ 83C8 ED 52        	sbc	hl, de
 261+ 83CA C8           	ret	z
 262+ 83CB
 263+ 83CB E5           	push	hl
 264+ 83CC 01 40 00     		ld	bc, COL_CNT
 265+ 83CF B7           		or	a
 266+ 83D0 ED 42        		sbc	hl, bc
 267+ 83D2 EB           		ex	de, hl
 268+ 83D3 D1           	pop	de
 269+ 83D4 79           	ld	a, c
 270+ 83D5 30 01        	jr	nc, TextViewLineShort
 271+ 83D7 7B           	ld	a, e
 272+ 83D8
 273+ 83D8              TextViewLineShort:
 274+ 83D8 5F           	ld	e, a		;Save line lenght.
 275+ 83D9
 276+ 83D9              	;Must detect if line is shorter because of CR.
 277+ 83D9 4F           	ld	c, a
 278+ 83DA 3E 0D        	ld	a, CHAR_CR
 279+ 83DC ED B1        	cpir
 280+ 83DE 20 01        	jr	nz, TextViewNotFoundCR
 281+ 83E0 0C           	inc	c
 282+ 83E1
 283+ 83E1              TextViewNotFoundCR:
 284+ 83E1 7B           	ld	a, e
 285+ 83E2 91           	sub	c
 286+ 83E3 DD 77 02     	ld	(ix+2), a
 287+ 83E6
 288+ 83E6 3E 0D        	ld	a, CHAR_CR	;Don't show an empty line if the CR char is exactly after 64 chars.
 289+ 83E8 BE           	cp	(hl)
 290+ 83E9 20 01        	jr	nz, TextViewCheckLF
 291+ 83EB 23           	inc	hl
 292+ 83EC
 293+ 83EC              TextViewCheckLF:
 294+ 83EC 3E 0A        	ld	a, CHR_LF
 295+ 83EE BE           	cp	(hl)
 296+ 83EF 20 01        	jr	nz, TextViewNoLF
 297+ 83F1 23           	inc	hl					;Skip LF char.
 298+ 83F2              TextViewNoLF:
 299+ 83F2
 300+ 83F2              	;Point to the next index position.
 301+ 83F2 ED 4B 5D 84  	ld	bc, (LineCount)
 302+ 83F6 03           	inc	bc
 303+ 83F7 ED 43 5D 84  	ld	(LineCount), bc
 304+ 83FB
 305+ 83FB DD 23        	inc	ix
 306+ 83FD DD 23        	inc	ix
 307+ 83FF DD 23        	inc	ix
 308+ 8401 18 B9        	jr	 TextViewIndexLoop
 309+ 8403
 310+ 8403              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 311+ 8403              PrintOneLine:
 312+ 8403 DD 6E 00     	ld	l, (ix)
 313+ 8406 DD 66 01     	ld	h, (ix+1)
 314+ 8409 DD 7E 02     	ld	a, (ix+2)
 315+ 840C
 316+ 840C B7           	or	a
 317+ 840D 06 40        	ld	b, COL_CNT
 318+ 840F 28 34        	jr	z, PrintOneLineCleanLine
 319+ 8411
 320+ 8411 47           	ld	b, a
 321+ 8412              PrintOneLineLoop:
 322+ 8412 7E           	ld	a, (hl)
 323+ 8413
 324+ 8413              	;Put space instead of tab
 325+ 8413 FE 09        	cp	CHAR_TAB
 326+ 8415 20 02        	jr	nz, PrintOneLineNotTab
 327+ 8417 3E 20        	ld	a, ' '
 328+ 8419
 329+ 8419              PrintOneLineNotTab:
 330+ 8419 E5           	push	hl
 331+ 841A FE 20        		cp	' '
 332+ 841C 38 06        		jr	c, PrintCharNotValid
 333+ 841E FE 8C        		cp	CHR_HALF
 334+ 8420 30 02        		jr	nc, PrintCharNotValid
 335+ 8422
 336+ 8422 18 02        		jr	PrintCharValid
 337+ 8424              PrintCharNotValid:
 338+ 8424 3E 2E        		ld	a, '.'
 339+ 8426              PrintCharValid:
 340+ 8426 32 81 5C     		ld	(CODE), a
 341+ 8429 C5           		push	bc
 342+ 842A CD 3D 81     			call	PrintChar
 343+ 842D C1           		pop	bc
 344+ 842E
 345+ 842E ED 5B B0 5C  		ld	de, (COORDS)
 346+ 8432 1C           		inc	e
 347+ 8433 ED 53 B0 5C  		ld	(COORDS), de
 348+ 8437 E1           	pop	hl
 349+ 8438 23           	inc	hl
 350+ 8439 10 D7        	djnz	PrintOneLineLoop
 351+ 843B
 352+ 843B              	;Fill rest of line with spaces.
 353+ 843B DD 46 02     	ld	b, (ix+2)
 354+ 843E 3E 40        	ld	a, COL_CNT
 355+ 8440 B8           	cp	b
 356+ 8441 C8           	ret	z
 357+ 8442
 358+ 8442 B7           	or	a
 359+ 8443 98           	sbc	b
 360+ 8444 47           	ld	b, a
 361+ 8445
 362+ 8445              PrintOneLineCleanLine:
 363+ 8445 3E 20        	ld	a, ' '
 364+ 8447 32 81 5C     	ld	(CODE), a
 365+ 844A C5           	push	bc
 366+ 844B CD 3D 81     		call	PrintChar
 367+ 844E ED 5B B0 5C  		ld	de, (COORDS)
 368+ 8452 1C           		inc	e
 369+ 8453 ED 53 B0 5C  		ld	(COORDS), de
 370+ 8457 C1           	pop	bc
 371+ 8458 10 EB        	djnz	PrintOneLineCleanLine
 372+ 845A
 373+ 845A C9           	ret
 374+ 845B
 375+ 845B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 376+ 845B
 377+ 845B 00 00        FileEnd		DEFW	0
 378+ 845D 00 00        LineCount	DEFW	0
 379+ 845F 00 00        FirstLineShown	DEFW	0
 380+ 8461 00 00        LastLineShown	DEFW	0
 381+ 8463
 382+ 8463 46 69 6C 65  MsgLine	defb	'File:'
 382+ 8467 3A
 383+ 8468 20 20 20 20  MsgLineFileName defb 	'           |'
 383+ 846C 20 20 20 20
 383+ 8470 20 20 20 7C
 384+ 8474 4C 69 6E 65  		defb	'Line:'
 384+ 8478 3A
 385+ 8479 20 20 20 20  MsgLineNo	defb	'     /'
 385+ 847D 20 2F
 386+ 847F 20 20 20 20  MsgLineTotal	defb	'     |'
 386+ 8483 20 7C
 387+ 8485 53 65 67 6D  		defb	'Segment:'
 387+ 8489 65 6E 74 3A
 388+ 848D 20 20 20 7C  MsgFilePart	defb	'   |'
 389+ 8491 20 20 20...  		defs	10, ' '
 390+ 849B 7C 30 3A 45  		defb	'|0:Exi', 't' | $80
 390+ 849F 78 69 F4
 391+ 84A2
 392+ 84A2              	ENDIF
# file closed: txtview.asm
1501  84A2              	include "serial.asm"
# file opened: serial.asm
   1+ 84A2              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 84A2              ;They work with 19200 theoretical speed.
   3+ 84A2              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 84A2
   5+ 84A2              CBAUD	EQU	10	; CBAUD for 19200
   6+ 84A2              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 84A2
   8+ 84A2
   9+ 84A2              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 84A2              ; A=1 IF FRAMING ERROR
  11+ 84A2              ; USES BC,D _DOES NOT USE E!_
  12+ 84A2              SERRXI:
  12+ 84A2
  13+ 84A2 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 84A5 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 84A7 D3 EF        	OUT	(0EFH),A
  16+ 84A9
  17+ 84A9              	; WAIT FOR START
  18+ 84A9              SERWSL:
  19+ 84A9 0B           	DEC	BC
  20+ 84AA AF           	XOR	A
  21+ 84AB B8           	CP	B
  22+ 84AC 20 03        	JR	NZ,SERWS
  23+ 84AE B9           	CP	C
  24+ 84AF 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 84B1 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 84B3 CB 7F        	BIT	7,A
  27+ 84B5 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 84B7
  29+ 84B7              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 84B7              ; OF BIT 0
  31+ 84B7 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 84B9 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 84BB
  34+ 84BB              ; GET AND SHIFT BITS
  35+ 84BB              SERRL:
  36+ 84BB 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 84BD 00           	NOP			; 4 (TIMING)
  38+ 84BE 00           	NOP			; 4 (TIMING)
  39+ 84BF 00           	NOP			; 4 (TIMING)
  40+ 84C0 DB F7        	IN	A,(0F7H)	; 11
  41+ 84C2 17           	RLA			; 4
  42+ 84C3 CB 1A        	RR	D		; 8
  43+ 84C5 06 0A        	LD	B,CBAUD		; 7
  44+ 84C7 0D           	DEC	C		; 4
  45+ 84C8 20 F1        	JR	NZ,SERRL	; 12
  46+ 84CA
  47+ 84CA              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 84CA              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 84CA              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 84CA              ; IDLE UNTIL NEXT START BIT
  51+ 84CA 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 84CC D3 EF        	OUT	(0EFH),A
  53+ 84CE
  54+ 84CE 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 84D0              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 84D0              SERWIL:
  57+ 84D0 05           	DEC	B
  58+ 84D1 28 0E        	JR	Z,SERRTF
  59+ 84D3 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 84D5 CB 7F        	BIT	7,A
  61+ 84D7 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 84D9
  63+ 84D9              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 84D9 7A           	LD	A,D
  65+ 84DA 2F           	CPL			; INVERT BITS
  66+ 84DB 57           	LD	D,A
  67+ 84DC AF           	XOR	A		; 0 = SUCCESS
  68+ 84DD C9           	RET
  69+ 84DE
  70+ 84DE              ; TIMEOUT
  71+ 84DE              SERRTO:
  72+ 84DE 3E FF        	LD	A,0FFH
  73+ 84E0 C9           	RET
  74+ 84E1
  75+ 84E1              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 84E1              SERRTF:
  77+ 84E1 3E 01        	LD	A,01H
  78+ 84E3 C9           	RET
  79+ 84E4
  80+ 84E4
  81+ 84E4
  82+ 84E4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 84E4              SERRB:
  83+ 84E4
  84+ 84E4              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 84E4              ; BITMAPPED OPTIONS IN E:
  86+ 84E4              ; XXXXXXIT
  87+ 84E4              ; I SET = leave Interrupts disabled at exit
  88+ 84E4              ; T SET = return after Timeout
  89+ 84E4              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 84E4              ; BC=NUMBER OF BYTES RECEIVED
  91+ 84E4              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 84E4 F3           	DI
  93+ 84E5 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 84E6              				; OF RECEIVED BYTES
  95+ 84E6
  96+ 84E6              SERRBL:
  97+ 84E6 C5           	PUSH	BC
  98+ 84E7 CD A2 84     	CALL	SERRXI
  99+ 84EA C1           	POP	BC
 100+ 84EB B7           	OR	A
 101+ 84EC 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 84EE 72           	LD	(HL),D
 103+ 84EF 23           	INC	HL
 104+ 84F0 0B           	DEC	BC
 105+ 84F1 AF           	XOR	A
 106+ 84F2 B8           	CP	B
 107+ 84F3 20 F1        	JR	NZ,SERRBL
 108+ 84F5 B9           	CP	C
 109+ 84F6 20 EE        	JR	NZ,SERRBL
 110+ 84F8              ; FULL RECEIVE
 111+ 84F8 C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 84F9
 113+ 84F9              SERRBX:				; EXIT
 114+ 84F9 CB 4B        	BIT	1,E
 115+ 84FB C0           	RET	NZ
 116+ 84FC FB           	EI
 117+ 84FD C9           	RET
 118+ 84FE
 119+ 84FE              SERRBT:
 120+ 84FE FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 8500 28 04        	JR	Z,SERRBC
 122+ 8502 CB 43        	BIT	0,E
 123+ 8504 28 E0        	JR	Z,SERRBL
 124+ 8506
 125+ 8506              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 8506 EB           	EX	DE,HL		; PRESERVE HL
 127+ 8507 E1           	POP	HL		; GET INITIAL COUNT
 128+ 8508 37           	SCF
 129+ 8509 3F           	CCF
 130+ 850A ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 850C 44           	LD	B,H
 132+ 850D 4D           	LD	C,L		; BC = COUNT
 133+ 850E EB           	EX	DE,HL		; RESTORE HL
 134+ 850F
 135+ 850F 18 E8        	JR	SERRBX
 136+ 8511
 137+ 8511              SERRX:
 137+ 8511
 138+ 8511              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 8511              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 8511              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 8511 F3           	DI
 142+ 8512 CD A2 84     	CALL	SERRXI
 143+ 8515 FB           	EI
 144+ 8516 C9           	RET
 145+ 8517
 146+ 8517              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 8517              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 8517              SERTB:
 148+ 8517
 149+ 8517 7E           	LD	A,(HL)
 150+ 8518 C5           	PUSH	BC
 151+ 8519 CD 24 85     		CALL	SERTX
 152+ 851C C1           	POP	BC
 153+ 851D 23           	INC	HL
 154+ 851E 0B           	DEC BC
 155+ 851F 78           	LD	A, B
 156+ 8520 B1           	OR	C
 157+ 8521 20 F4        	JR	NZ, SERTB
 158+ 8523 C9           	RET
 159+ 8524
 160+ 8524              ; SEND CHAR ROUTINE
 161+ 8524              SERTX:
 161+ 8524
 162+ 8524 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 8525 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 8526 F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 8527 3E 01        	LD	A,01H
 166+ 8529 D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 852B 1E 20        	LD	E,20H	; PORT MASK
 168+ 852D 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 852F 3E 01        	LD	A,1
 170+ 8531 C3 38 85     	JP	SBIT
 171+ 8534
 172+ 8534 AF           SHLOOP:	XOR	A		; 4
 173+ 8535 CB 3A        	SRL	D		; 8
 174+ 8537 17           	RLA			; 4
 175+ 8538              SBIT:
 176+ 8538 B3           	OR	E		; 4
 177+ 8539 D3 EF        	OUT	(0EFH),A	; 11
 178+ 853B 06 0A        	LD	B,CBAUD		; 7
 179+ 853D              SBITDL:
 180+ 853D 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 853F 00           	NOP			; 4 (TIMING)
 182+ 8540 0D           	DEC	C		; 4
 183+ 8541 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 8543              ; STOP BIT
 185+ 8543 3E 20        	LD	A,20H
 186+ 8545 D3 EF        	OUT	(0EFH),A
 187+ 8547 06 0A        	LD	B,CBAUD
 188+ 8549 10 FE        STOPL:	DJNZ	STOPL
 189+ 854B FB           	EI
 190+ 854C C9           	RET
# file closed: serial.asm
1502  854D              	include "bas2txt.asm"
# file opened: bas2txt.asm
   1+ 854D              	IFNDEF _BAS2TXT_
   2+ 854D              	DEFINE _BAS2TXT_
   3+ 854D
   4+ 854D              CHANS		EQU		23631
   5+ 854D              CH_LEN		EQU		5
   6+ 854D              CHANNEL		EQU		3
   7+ 854D              CHAN_OPEN	EQU		$1601
   8+ 854D
   9+ 854D              NumMarker	EQU		$0E
  10+ 854D
  11+ 854D              PO_SEARCH	EQU		$0C41
  12+ 854D              TKN_TABLE	EQU		$0095
  13+ 854D
  14+ 854D
  15+ 854D              ;Input: HL=source of program, BC=length of program, DE=text output address
  16+ 854D              ;Output: DE=end of text
  17+ 854D              BASIC2TXT:
  18+ 854D 22 10 86     	ld		(ProgramStartAddr), hl
  19+ 8550 09           	add		hl, bc
  20+ 8551 22 12 86     	ld		(ProgramEndAddr), hl
  21+ 8554 ED 53 14 86  	ld		(DestinationAddr), de
  22+ 8558
  23+ 8558              	;Open channel.
  24+ 8558 3E 03        	LD   A, CHANNEL
  25+ 855A CD 01 16     	CALL CHAN_OPEN		;
  26+ 855D
  27+ 855D              	;modify output routine
  28+ 855D 2A 4F 5C     	ld   hl, (CHANS)
  29+ 8560 01 0F 00     	ld	 bc, CH_LEN * CHANNEL
  30+ 8563 09           	add	 hl, bc
  31+ 8564 11 E3 85     	ld   de, OutputFnct
  32+ 8567 73           	ld   (hl), e
  33+ 8568 23           	inc	hl
  34+ 8569 72           	ld	(hl), d
  35+ 856A
  36+ 856A 2A 10 86     	ld	hl, (ProgramStartAddr)
  37+ 856D
  38+ 856D              NextLine:
  39+ 856D E5           	PUSH HL
  40+ 856E B7           		or	 a
  41+ 856F ED 5B 12 86  		ld   de, (ProgramEndAddr)
  42+ 8573 EB           		ex	de, hl
  43+ 8574 ED 52        		SBC  HL,DE
  44+ 8576 7C           		LD   A,H
  45+ 8577 B5           		OR   L
  46+ 8578 E1           	POP  HL
  47+ 8579 C8           	RET  Z				;Return if length == 0.
  48+ 857A
  49+ 857A              	;Print line number
  50+ 857A 3E 20        	ld		a, ' '
  51+ 857C CD 01 86     	call	PrintIt
  52+ 857F 46           	LD   B,(HL)
  53+ 8580 23           	INC  HL
  54+ 8581 4E           	LD   C,(HL)
  55+ 8582 23           	INC  HL
  56+ 8583 E5           	PUSH HL
  57+ 8584 CD 2B 2D     		CALL $2D2B		;STACK_BC
  58+ 8587 CD E3 2D     		CALL $2DE3		;PRINT_FP
  59+ 858A 3E 20        		ld		a, ' '
  60+ 858C CD 01 86     		call	PrintIt
  61+ 858F E1           	POP  HL
  62+ 8590
  63+ 8590              	;Get line length in BC.
  64+ 8590 4E           	LD   C,(HL)
  65+ 8591 23           	INC  HL
  66+ 8592 46           	LD   B,(HL)
  67+ 8593 23           	INC  HL
  68+ 8594
  69+ 8594              	;Save line end address.
  70+ 8594 E5           	PUSH HL
  71+ 8595 09           		ADD  HL,BC
  72+ 8596 22 0E 86     		LD   (LineEndAddr),HL
  73+ 8599 E1           	POP  HL
  74+ 859A
  75+ 859A              GetCharLoop:
  76+ 859A              	;Load a char
  77+ 859A 7E           	LD   A, (HL)
  78+ 859B FE 0D        	CP   CHR_CR
  79+ 859D 20 04        	JR   NZ, IsNotCR		; A == CR
  80+ 859F
  81+ 859F              	;Print CR and process next line.
  82+ 859F 23           	INC  HL
  83+ 85A0 D7           	RST  $10			;PRINT_A_1
  84+ 85A1 18 CA        	JR   NextLine
  85+ 85A3
  86+ 85A3              IsNotCR:
  87+ 85A3 FE 2E        	CP   '.'
  88+ 85A5 28 08        	JR   Z, SearchNum	; A == '.'
  89+ 85A7
  90+ 85A7 FE 3A        	CP   ':'
  91+ 85A9 30 13        	JR   NC, TestSPC1	; A >= ':'
  92+ 85AB
  93+ 85AB FE 30        	CP   '0'
  94+ 85AD 38 0F        	JR   C, TestSPC1	; A < '0'
  95+ 85AF
  96+ 85AF              SearchNum:
  97+ 85AF 44           	LD   B, H
  98+ 85B0 3E 0E        	LD   A, NumMarker
  99+ 85B2 ED B1        	CPIR
 100+ 85B4 CD B4 33     	CALL $33B4			;STACK_NUM
 101+ 85B7 E5           	PUSH HL
 102+ 85B8 CD E3 2D     		CALL $2DE3		;PRINT_FP
 103+ 85BB E1           	POP  HL
 104+ 85BC 18 DC        	JR   GetCharLoop
 105+ 85BE
 106+ 85BE              TestSPC1:
 107+ 85BE FE 20        	CP   ' '
 108+ 85C0 38 02        	JR   C, TestREM		; A < ' '
 109+ 85C2
 110+ 85C2              	;Print char >= ' '
 111+ 85C2 D7           	RST  $10			;PRINT_A_1
 112+ 85C3 7E           	LD   A,(HL)
 113+ 85C4
 114+ 85C4              TestREM:
 115+ 85C4 FE EA        	CP   $EA			;RND token
 116+ 85C6 20 08        	JR   NZ, TestQuote1	; A != RND
 117+ 85C8
 118+ 85C8              	;Print CR.
 119+ 85C8 3E 0D        	LD   A, CHR_CR
 120+ 85CA D7           	RST  $10			;PRINT_A_1
 121+ 85CB 2A 0E 86     	LD   HL,(LineEndAddr)	;Ingore chars after REM.
 122+ 85CE 18 9D        	JR   NextLine
 123+ 85D0
 124+ 85D0              TestQuote1:
 125+ 85D0 FE 22        	CP   '"'
 126+ 85D2 20 0C        	JR   NZ, SkipChar	; A != '"'
 127+ 85D4
 128+ 85D4              TestSPC2:
 129+ 85D4 23           	INC  HL
 130+ 85D5 7E           	LD   A,(HL)
 131+ 85D6 FE 20        	CP   ' '
 132+ 85D8 38 02        	JR   C, TestQuote2	; A < ' '
 133+ 85DA
 134+ 85DA              	;Print >= ' '.
 135+ 85DA D7           	RST  $10			;PRINT_A_1
 136+ 85DB 7E           	LD   A,(HL)
 137+ 85DC
 138+ 85DC              TestQuote2:
 139+ 85DC FE 22        	CP   '"'
 140+ 85DE 20 F4        	JR   NZ, TestSPC2	; A != '"'
 141+ 85E0
 142+ 85E0              SkipChar:
 143+ 85E0 23           	INC  HL
 144+ 85E1 18 B7        	JR   GetCharLoop
 145+ 85E3
 146+ 85E3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 85E3
 148+ 85E3              OutputFnct:
 149+ 85E3 FE A4        	cp	164
 150+ 85E5 38 1A        	jr	c, PrintIt	; A <= 164 ?
 151+ 85E7
 152+ 85E7 D6 A5        	sub		165
 153+ 85E9 11 95 00     	ld		de, TKN_TABLE
 154+ 85EC CD 41 0C     	call	PO_SEARCH
 155+ 85EF
 156+ 85EF              NextTokenChar:
 157+ 85EF 1A           	ld		a, (de)
 158+ 85F0 13           	inc		de
 159+ 85F1 CB 7F        	bit		7, a
 160+ 85F3 20 05        	jr		nz, LastChar
 161+ 85F5 CD 01 86     	call	PrintIt
 162+ 85F8 18 F5        	jr		NextTokenChar
 163+ 85FA
 164+ 85FA              LastChar:
 165+ 85FA E6 7F        	and		%01111111
 166+ 85FC CD 01 86     	call	PrintIt
 167+ 85FF 3E 20        	ld		a, ' '
 168+ 8601
 169+ 8601              PrintIt:
 170+ 8601 D5           	push	de
 171+ 8602 ED 5B 14 86  		ld	de, (DestinationAddr)
 172+ 8606 12           		ld	(de), a
 173+ 8607 13           		inc	de
 174+ 8608 ED 53 14 86  		ld	(DestinationAddr), de
 175+ 860C D1           	pop		de
 176+ 860D C9           	ret
 177+ 860E
 178+ 860E 00 00        LineEndAddr			DEFW 0
 179+ 8610 00 00        ProgramStartAddr	DEFW 0
 180+ 8612 00 00        ProgramEndAddr		DEFW 0
 181+ 8614 00 00        DestinationAddr		DEFW 0
 182+ 8616
 183+ 8616              	ENDIF
# file closed: bas2txt.asm
1503  8616
1504  8616              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1505  8616 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-28"
1505  861A 64 20 32 30
1505  861E 32 33 2D 31
1505  8622 32 2D 32 38
1506  8626 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1506  862A 67 65 20 43
1506  862E 68 69 72 74
1506  8632 6F 61 63 E1
1507  8636 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1507  863A 72 61 6D 20
1507  863E 49 6E 66 6F
1507  8642 20 20 20 A0
1508  8646 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1508  864A 20 49 6E 66
1508  864E 6F 20 20 20
1508  8652 20 20 20 A0
1509  8656 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1509  865A 20 49 6E 66
1509  865E 6F 20 20 20
1509  8662 20 20 20 A0
1510  8666 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1510  866A 61 67 65 73
1510  866E 20 20 20 20
1510  8672 20 20 20 A0
1511  8676 31 2D 41 3A  BtnBar			DEFM	'1-A:|2-B:|3-View|4-Prop|5-Copy|6-Ren|7-Attr|8-Del|9-Disk|0-Exi', 't' + $80
1511  867A 7C 32 2D 42
1511  867E 3A 7C 33 2D
1511  8682 56 69 65 77
1511  8686 7C 34 2D 50
1511  868A 72 6F 70 7C
1511  868E 35 2D 43 6F
1511  8692 70 79 7C 36
1511  8696 2D 52 65 6E
1511  869A 7C 37 2D 41
1511  869E 74 74 72 7C
1511  86A2 38 2D 44 65
1511  86A6 6C 7C 39 2D
1511  86AA 44 69 73 6B
1511  86AE 7C 30 2D 45
1511  86B2 78 69 F4
1512  86B5 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1512  86B9 46 72 65 65
1512  86BD 3A 20 20
1513  86C0 41 2F        MsgDriveLet		DEFM	'A', '/'
1514  86C2 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1515  86C5 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1515  86C9 73 2F 4B 42
1515  86CD 3A
1516  86CE 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1516  86D2 30 30 30
1517  86D5 45 72 72 6F  MsgErr			DEFM	'Error code '
1517  86D9 72 20 63 6F
1517  86DD 64 65 20
1518  86E0 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1519  86E4 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1519  86E8 69 6E 67 20
1519  86EC 50 72 6F 67
1519  86F0 72 61 ED
1520  86F3 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1520  86F7 69 6E 67 20
1520  86FB 53 43 52 45
1520  86FF 45 4E A4
1521  8702 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1521  8706 69 6E 67 20
1521  870A 43 4F 44 45
1521  870E 20 28 21 A9
1522  8712 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1522  8716 20 4C 65 6E
1522  871A 3A
1523  871B 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1523  871F 30 20 CB
1524  8722 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1524  8726 69 62 20 20
1524  872A 3A
1525  872B 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1525  872F 48 49 C4
1526  8732 54 79 70 65  MsgFileType		DEFM	'Type    :'
1526  8736 20 20 20 20
1526  873A 3A
1527  873B 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1527  873F 20 20 20 20
1527  8743 20 A0
1528  8745 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1528  8749 72 61 ED
1529  874C 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1529  8750 73 20 A0
1530  8753 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1530  8757 45 4E A4
1531  875A 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1531  875E 41 72 F2
1532  8761 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1532  8765 41 72 F2
1533  8768 55 6E 74 79  MsgFileTypeText	DEFM	'Untype', 'd' + $80
1533  876C 70 65 E4
1534  876F 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1534  8773 20 20 A0
1535  8776 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1535  877A 74 68 20 20
1535  877E 3A
1536  877F 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1536  8783 35 20 C2
1537  8786 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1537  878A 74 20 20 20
1537  878E 3A
1538  878F 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1538  8793 35 20 A0
1539  8796 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1539  879A 69 6E 67 20
1539  879E 68 65 61 64
1539  87A2 65 F2
1540  87A4 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1540  87A8 20 20 20 20
1540  87AC 20 20 20 20
1540  87B0 20 20 20 A0
1541  87B4 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1541  87B8 66 69 6C 65
1541  87BC 3F 20 79 2F
1541  87C0 EE
1542  87C1 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1542  87C5 52 2F 4F 3F
1542  87C9 20 79 2F EE
1543  87CD 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1543  87D1 48 49 44 3F
1543  87D5 20 79 2F EE
1544  87D9 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1544  87DD 3F 6E 6F 6E
1544  87E1 65 3D 61 62
1544  87E5 6F 72 74 BA
1545  87E9 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1545  87ED 20 6D 65 6E
1545  87F1 75 BA
1546  87F3 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1546  87F7 20 63 6F 70
1546  87FB 79 20 6D 65
1546  87FF 6E 75 BA
1547  8802 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1547  8806 78 69 74 20
1547  880A 6D 65 6E F5
1548  880E
1549  880E 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1549  8812 6F 70 79 20
1550  8816 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1551  881A 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1552  881C
1553  881C 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1553  8820 6F 70 79 20
1554  8824 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1555  8828 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1556  882A
1557  882A 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1557  882E 6F 70 79 20
1558  8832 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1558  8836 43 4F CD
1559  8839
1560  8839 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1560  883D 6F 70 79 20
1560  8841 43 4F 4D 2D
1560  8845 3E
1561  8846 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1562  8848
1563  8848 35 2E 20 46  MsgMenuFmt1		DEFM	'5. Format A', ':' | $80
1563  884C 6F 72 6D 61
1563  8850 74 20 41 BA
1564  8854 36 2E 20 46  MsgMenuFmt2		DEFM	'6. Format B', ':' | $80
1564  8858 6F 72 6D 61
1564  885C 74 20 42 BA
1565  8860
1566  8860 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1566  8864 62 6C 6F 63
1566  8868 6B 73 20 6C
1566  886C 65 66 F4
1567  886F 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1567  8873 77 72 69 74
1567  8877 65 3F 20 79
1567  887B 2F EE
1568  887D 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1568  8881 20 6E 61 6D
1568  8885 65 20 65 78
1568  8889 69 73 74 F3
1569  888D 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1569  8891 53 4F 55 52
1569  8895 43 45 20 64
1569  8899 69 73 EB
1570  889C 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1570  88A0 44 45 53 54
1570  88A4 2E 20 64 69
1570  88A8 73 6B A0
1571  88AB 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1571  88AF 73 20 61 6E
1571  88B3 79 20 6B 65
1571  88B7 F9
1572  88B8 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1572  88BC 73 65 63 74
1572  88C0 6F 72 73 20
1572  88C4 63 6F 70 F9
1573  88C8 41 72 65 20  MsgAreYouSure	DEFM	'Are you sure?y/', 'n' | $80
1573  88CC 79 6F 75 20
1573  88D0 73 75 72 65
1573  88D4 3F 79 2F EE
1574  88D8 56 69 65 77  MsgViewFileMenu	DEFM	'View file menu', ':' | $80
1574  88DC 20 66 69 6C
1574  88E0 65 20 6D 65
1574  88E4 6E 75 BA
1575  88E7 31 2E 41 73  MsgViewFileText	DEFM	'1.As tex', 't' | $80
1575  88EB 20 74 65 78
1575  88EF F4
1576  88F0 32 2E 41 73  MsgViewFileHex	DEFM	'2.As he', 'x' | $80
1576  88F4 20 68 65 F8
1577  88F8 33 2E 41 75  MsgViewFileAuto	DEFM	'3.Auto-1/2/BASI', 'C' | $80
1577  88FC 74 6F 2D 31
1577  8900 2F 32 2F 42
1577  8904 41 53 49 C3
1578  8908
1579  8908              	IFNDEF	_REAL_HW_
1580  8908 ~            FontTable:
1581  8908 ~            	incbin "cpmfnt.bin"
1582  8908              	ENDIF
1583  8908              EndCode:
1584  8908
1585  8908              ;Unalocated variables
1586  8908              UnallocStart	EQU		EndCode
1587  8908              FileCnt			EQU		UnallocStart			;File counter, 1B
1588  8908              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1589  8908              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1590  8908              CursorAddr		EQU		SelFile + 1				;2 B
1591  8908              AUCntUsed		EQU		CursorAddr + 2			;2 B
1592  8908              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1593  8908              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1594  8908              CopySelOption	EQU		SelFileCache+2			;1 B
1595  8908              ViewSelOption	EQU		CopySelOption + 1
1596  8908              ViewSectMax	EQU		ViewSelOption + 1
1597  8908              ViewFilePart	EQU		ViewSectMax+1
1598  8908              FileBlocksIdxPos EQU		ViewFilePart+1
1599  8908
1600  8908              CopyFileFCB		EQU	FileBlocksIdxPos + 2
1601  8908              CopyFileRes		EQU CopyFileFCB + 2
1602  8908              CopyFileDMAAddr	EQU	CopyFileRes + 1
1603  8908              FilePosRead		EQU	CopyFileDMAAddr + 2
1604  8908              FilePosWrite	EQU	FilePosRead + 2
1605  8908              CopyFileSectCnt EQU FilePosWrite + 2
1606  8908              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1607  8908              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1608  8908              CopyFileDstDrv	EQU CopyFileSrcName + 11
1609  8908              CopyFileDstName	EQU CopyFileDstDrv + 1
1610  8908
1611  8908              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1612  8908              ;FS block list constants
1613  8908              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1614  8908              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1615  8908              UsedBlockListSz		EQU 320 * 2 + 2							;640
1616  8908
1617  8908              	IFDEF	_REAL_HW_
1618  8908              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1619  8908              DataBuf			EQU		FontTable + 872
1620  8908              	ELSE
1621  8908 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1622  8908              	ENDIF
1623  8908
1624  8908              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1625  8908
1626  8908
1627  8908              ;File viewer constants
1628  8908              FileData		EQU		DataBuf
1629  8908              ;4K index allows for 2000 lines of text.
1630  8908              FileIdxSize		EQU		4 * 1024
1631  8908              FileIdxBlocksSize	EQU		1 * 1024
1632  8908              ;File buffer size, without index
1633  8908              FileDataSize	EQU		(MAX_SECT_RAM * SECT_SZ) - FileIdxSize - FileIdxBlocksSize
1634  8908              ;Set a few KB aside for file indexing
1635  8908              FileIdx			EQU		FileData + FileDataSize
1636  8908              FileBlocksIdx		EQU		FileIdx + FileIdxSize
1637  8908              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1638  8908
1639  8908
1640  8908              ;Copy buffer size, follows
1641  8908              CopyDiskBuf			EQU DataBuf
1642  8908
1643  8908              ;256 bytes for the stack should be enough.
1644  8908              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1645  8908              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1646  8908              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1647  8908
1648  8908              	DISPLAY "DataBuf addr: ", /D,DataBuf
1649  8908              	DISPLAY "BinSize: ", /D, EndCode - Start
1650  8908              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1651  8908              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x76EE   NoSub
0x76E7   DivLoop
0x67A7   MAX_RAM_FREE
0x0067   MAX_SECT_RAM
0x0400   FileIdxBlocksSize
0x1000   FileIdxSize
0x0282   UsedBlockListSz
0x8908   UnallocStart
0x8908   EndCode
0x86C2 X MsgFreeSpaceNo
0x85FA   LastChar
0x85EF   NextTokenChar
0x85DC   TestQuote2
0x85D4   TestSPC2
0x85E0   SkipChar
0x85D0   TestQuote1
0x85C4   TestREM
0x85BE   TestSPC1
0x85AF   SearchNum
0x85A3   IsNotCR
0x859A   GetCharLoop
0x860E   LineEndAddr
0x8601   PrintIt
0x856D   NextLine
0x85E3   OutputFnct
0x8612   ProgramEndAddr
0x8610   ProgramStartAddr
0x0095   TKN_TABLE
0x0C41   PO_SEARCH
0x000E   NumMarker
0x1601   CHAN_OPEN
0x0003   CHANNEL
0x0005   CH_LEN
0x5C4F   CHANS
0x8549   STOPL
0x8534   SHLOOP
0x8538   SBIT
0x853D   SBITDL
0x8524   SERTX
0x8511 X SERRX
0x8506   SERRBC
0x84F9   SERRBX
0x84FE   SERRBT
0x84E6   SERRBL
0x84D3 X SERWI
0x84E1   SERRTF
0x84D0   SERWIL
0x84BB   SERRL
0x84DE   SERRTO
0x84B1   SERWS
0x84A9   SERWSL
0x84A2   SERRXI
0x000A   CBAUD
0x8426   PrintCharValid
0x8424   PrintCharNotValid
0x8419   PrintOneLineNotTab
0x8412   PrintOneLineLoop
0x83F2   TextViewNoLF
0x83EC   TextViewCheckLF
0x83E1   TextViewNotFoundCR
0x83D8   TextViewLineShort
0x83BC   TextViewIndexLoop
0x845B   FileEnd
0x837C   TextViewerScrollDown1
0x8351   TextViewerScrollUp1
0x8334   TextViewerScrollUpOK
0x8365   TextViewerScrollDown
0x8463   MsgLine
0x82FA   TextViewerShowFilename
0x8468   MsgLineFileName
0x848D   MsgFilePart
0x8479   MsgLineNo
0x82DB   TextViewerLoop3
0x847F   MsgLineTotal
0x8403   PrintOneLine
0x82B4   TextViewerLoop
0x845F   FirstLineShown
0x8325   TextViewerScrollUp
0x8461   LastLineShown
0x8298   TextViewerShowBegining
0x827B   MoreThan23LinesInFile
0x845D   LineCount
0x83A7   TextViewIndex
0x8233   ScrollDownLoop
0x822A   ScrollDownLoop2
0x8231   ScrollDownPtrSrc
0x822E   ScrollDownPtrDest
0x821D   ScrollDown
0x8220   Scroll
0x8218   ScrollUp
0x8207   FillScrLinesRev
0x81F2   FillScrLinesLoop
0x81DE   ScrollInit
0x81D4   GetCellDown
0x5B2E   SCRLinesUp
0x5B00   SCRLinesDown
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A X CHAR_LF
0x0017   LINE_CNT
0x81C0   ClearNMsgLinesLoop
0x81AE   ReadStrPrint
0x819E   ReadStrChar
0x8181   ReadStringLoop
0x8175   Store
0x8174   NoTurn
0x8169   PrintCharLine
0x8155 X PrintChar3
0x8100   DrawCursorLoop
0x80E7   DrawVLinesLoop
0x80B8   DrawLowerIntersectLoop
0x80C9   DrawIntersect
0x80A3   DrawUpperIntersectLoop
0x8077   DrawLineLoop
0x8084   LineDir
0x8074   StoreDir
0x8072   VertDir
0x8069   DrawLine
0x8065   StrClr
0x8018   GoodChar
0x81D0   CurrScrAddr
0x93F1   FontTable
0x008C   CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A   CHR_LF
0x000D   CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x7F98   ReadWriteFileSectionLoop
0x7FB6   ReadWriteFileSectionEnd
0x891C   CopyFileDMAAddr
0x8919   CopyFileFCB
0x7F5D   ReadWriteFileSection
0x7FC8   CopyFilePtr2
0x7F83   CopyFilePtr
0x7FAB   CopyFileOperAddr2
0x7F8C   CopyFileOperAddr1
0x7F0F   CopyFileFromCOMDontInc
0x5300   FileDataSize
0x7EFC   CopyFileFromCOMLoop
0x7E9B   CopyFileToCOMEnd
0x7E7B   CopyFileToCOMLoop
0x7E33   CopyFileDualDriveLoop
0x7F44   WriteFileSection
0x88B8   MsgCopySectors
0x7DCA   CopyFileSameDriveLoop
0x8922   CopyFileSectCnt
0x7D86   CopyFileCreateNewFile
0x886F   MsgFileOverwrite
0x7D6A   CopyFileCheckOverwrite
0x7EA0   CopyFileFromCOM
0x7E6D   CopyFileToCOM
0x7E23   CopyFileDualDrive
0x7DA4   CopyFileSameDrive
0x7D53   CopyFileNotExit
0x87F3   MsgMenuFileCopy
0x8920   FilePosWrite
0x8930   CopyFileDstName
0x888D   MsgInsertSrcDsk
0x88AB   MsgPressAnyKey
0x889C   MsgInsertDstDsk
0x7C56 X FileAttribSet
0xEA59   FileIdx
0x7C04   GetFileSizeMul
0x7C0A   GetFileSizeEnd
0x7C02   GetFileSizeOK
0x7BE2   BDOSSetRandFilePtr
0x7BDE   BDOSSetDMA
0x7BD0   BDOSWriteFileBlockRandom
0x7BCC   BDOSReadFileBlockRandom
0x7BC8   BDOSWriteFileBlockSeq
0x7BC4   BDOSReadFileBlockSeq
0x7BC0   BDOSCloseFile
0x7BBC   BDOSOpenFile
0x7BB8   BDOSCreateFile
0x7BAE   DestroyChannel
0x7B98   CreateChannel
0x7B98 X BDOSCloseDrives
0x7B94 X BDOSGetDiskRO
0x7B94 X BDOSMakeDiskRO
0x7BD4   BDOS
0x7B86 X PrmIntrlvTbl
0x7B85 X PrmSpinUp
0x7B84 X PrmHeadLoad
0x7B82 X PrmDevType
0x0004   PrmFastFactor
0x7B7D X RWTSResTmp
0x7B7C X RWTSResVolNo
0x7B82   BasPrmTbl
0x7B78 X RWTSPrmTbl
0x7B76 X RWTSExtBuf
0x7B73 X RWTSSector
0x7B71 X RWTSVolNo
0x7B6F X RWTSBlockType
0x7B66   CopyMsg
0x7B5A   SearchMsgEnd
0x7B63   SaveMsg
0x7B51   IF1Paged
0x7B1F   IF1Call
0x7B1A   IsFileHeaderValidLoop
0x7BE6   GetFileSize
0x7AFE   ReadFileHeaderIsTextFile
0x7B17   IsFileHeaderValid
0x7B13   ReadHeaderEnd
0x7AB8   CacheNotFinished
0x7AAD X SeekTrack
0x7A62   FileReadLoop
0x7A56 X FileLoadHeader
0x7A68   FileLoadNoHeader
0x7A76   FileFree
0x7A32   MisMatch
0x7A2A   Compare
0x7A28   StrCmp
0x79DF   CopyDiskFromCOMLoop
0x84E4   SERRB
0x797B   CopyDiskToCOMLoop
0x8517   SERTB
0x7C9C   PromptDiskChangeSrc
0x7953   CopyDiskDualDrive2
0x7960   CopyDiskEnd
0x792F X CopyDiskWriteEnd
0x7918   CopyDiskLoopWriteLoop
0x7911   CopyDiskReadEnd
0x7C82   PromptDiskChangeDst
0x7907   CopyDiskDualDrive1
0x78DE   CopyDiskLoopReadLoop
0x9759   CopyDiskBuf
0x78D7   CopyDiskLoopRead
0x000C   MAX_AU_RAM
0x8860   MsgBlocksLeft
0x78B4   CopyDiskLoop
0x9171   UsedBlockListBlk
0x7A8E   WriteDiskSectors
0x78A0   WriteFSBlock
0x7A7B   ReadDiskSectors
0x7893   ReadFSBlock
0x7885   ReadUsedBlocksSkip
0x7868   ReadUsedBlocksLoop2
0x7888   ReadUsedBlocksSkip2
0x7858   ReadUsedBlocksLoop
0x916F   UsedBlockListCnt
0x783A   ReadUsedBlocksList
0x7833   CheckAUEnd
0x781F   CheckAU
0x7808   FirstAU
0x7802   Track0
0x77ED   AU2TS
0x77D1   WriteOneDiskSector
0x7B72   RWTSTrack
0x7B74   RWTSDMA
0x7B6F   RWTSParams
0x7B7A   RWTSCmd
0x77BA   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x779D   Bin2HexLineLoopHex2
0x7789   Bin2HexLineClear
0x0040   COL_CNT
0x7779   Bin2HexStrLoop
0x7759   Bin2HexLineLoopText
0x7756 X Bin2HexLineText
0x0080   CHR_V
0x774E   Bin2HexLineLoopHexNotHalf
0x7741   Bin2HexLineLoopHex
0x773E   Bin2HexLine
0x0010   HEX_COLUMNS
0x7738 X Bin2HexLineLoopTextReplace
0x773B   Bin2HexLineLoopTextCopy
0x000D   CHAR_CR
0x7733   Byte2HexChar
0x772A   Byte2HexHex
0x771E   Byte2HexNibble
0x7718   Byte2Hex
0x7715   NoAdd
0x770F   MulLoop
0x76F6   Div2Loop
0x76F1 X Div2
0x76E4   Div
0x76DB   DivNrLoop
0x76D9   DigitLoop
0x76CA   Byte2Txt_
0x76B3   StrippLeading0
0x76BE   Word2Txt_
0x769D X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x769A   DontInc
0x7694   ReadAllHeadersEnd
0x767F   AKey
0x7FD8   KbdHit
0x7664   NextFile
0x8776   MsgFileLen
0x8732   MsgFileType
0x8786   MsgFileStart
0x7623   PrintStartStr
0x878F   MsgFileStartN
0x876F   MsgNA
0x7615   PrintStart
0x0007   HDR_LINE
0x75F0   PrintByteStart
0x75E8   PrintProgStart
0x877F   MsgFileLenN
0x75CE X PrepFileLenText
0x8768   MsgFileTypeText
0x874C   MsgFileTypeByte
0x8753   MsgFileTypeSCR
0x75B4   NotScr
0x75BF   CheckText
0x875A   MsgFileTypeChrA
0x7597   CheckByte
0x0002   CHAR_TYPE
0x8761   MsgFileTypeNoA
0x7588   CheckChrArr
0x0001   NUMB_TYPE
0x75C8   PrepFileLen
0x7B83 X PrmStepRate
0x7641   MoveMsg
0x873B   MsgFileTypeN
0x8745   MsgFileTypePrg
0x7579   CheckNoArr
0x000B   CACHE_FIRST_AU
0x75F8   HeadNotRead
0x8722   MsgFileAttr
0x754A   AttrEnd
0x7540   NotSYS
0x752E   CheckSys
0x7520   NotRO
0x0008   RO_POS
0x0000   CACHE_NAME
0x760A   PrintStartNotRead
0x8712   MsgFileSzDsk
0x871B   MsgFileSzDskN
0x8924   CopyFileSrcName
0x74D7   ReadFileForViewingNotFoundEOF
0x5CED   HD11
0x001A   CHAR_EOF
0x74DD   ReadFileForViewingNotText
0x0004   TEXT_TYPE
0x7F23   ReadFileSection
0x8915   ViewSectMax
0x7487   ViewFileTextLoopDown
0x5C08   LAST_K
0x745B   ViewFileTextLoop
0x8258   TextViewer
0x8614   DestinationAddr
0x854D   BASIC2TXT
0x0005   HDR_PLEN
0x775F   Bin2HexStr
0x744F   ViewFileText
0x74A7   ReadFileForViewing
0x0053   MAX_SECT_BUF
0x742B   ViewFileAsBASIC
0x73FE X ViewFileAuto
0x7415   ViewFileAsHex
0x740D   ViewFileAsText
0x73F3   ViewFileNextBlock
0x8917   FileBlocksIdxPos
0xFA59   FileBlocksIdx
0x8916   ViewFilePart
0x8914   ViewSelOption
0x891E   FilePosRead
0x872B   MsgFileAttrN
0x0003 X ViewFileConvertRatioASM
0x0005   ViewFileConvertRatioHEX
0x0004   ViewFileConvertRatioBASIC
0x0001   ViewFileConvertRatioText
0x7B25   LoadProgram
0x8923   CopyFileSrcDrv
0x86E4   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x86F3   MsgLoadingSCR
0x0003   HDR_ADDR
0x7A7B   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7A35   IF1FileLoad
0x8702   MsgLoadingCODE
0x7375 X HandleFileCODE
0x739B   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x73C9   HandleFileText
0x0003   BYTE_TYPE
0x73B9   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x733F   FindExtEnd
0x7AAD   FindCache
0x734E   GetFileNamesEnd
0x0009   HDR_SZ
0x731A   FindExt
0x000C   EXT_IDX
0x780B   CheckExtAlloc
0x7341   NextExt
0x0000   EXT_DEL_FLAG
0x72CD   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x72AA   DisplayFilenamesLoop
0x7290   LineOK
0x5CB1   LINE
0x5CB0   COL
0x813D   PrintChar
0x5C81   CODE
0x726A   DispLoop
0x7268   DisplayFilename
0x8105   MoveCursor
0x77DC   FormatDisk
0x88C8   MsgAreYouSure
0x7210   FormatDiskAction
0x7203   CheckDiskMenuFormat2
0x79C2   CopyDiskFromCOM
0x71F4   CheckDiskMenuFormat1
0x7966   CopyDiskToCOM
0x71EA   CheckDiskMenuFromCOM
0x71E1   CheckDiskMenuToCOM
0x78AD   CopyDisk
0x71D3   CheckDiskMenuDualDrive
0x7257   DiskMenuExit
0x71BF X CheckKeyDiskMenuLoop
0x8854   MsgMenuFmt2
0x8848   MsgMenuFmt1
0x8839   MsgMenuFromCOM
0x882A   MsgMenuToCOM
0x881C   MsgMenuDual
0x880E   MsgMenuSingle
0x8802   MsgMenuBack
0x87E9   MsgMenuDiskCopy
0x8828   MsgMenuDualDrv2
0x8846   MsgMenuFromCOMDrv
0x8832   MsgMenuToComDrv
0x8824   MsgMenuDualDrv1
0x881A   MsgMenuSingleDrv2
0x8816   MsgMenuSingleDrv1
0x725A   CheckKeyExit
0x7C35   ChangeFileAttrib
0x7132   AttrChange
0x87CD   MsgSetSYS
0x711A   CheckSYS
0x87C1   MsgSetRO
0x7144   CheckKeyDiskMenu
0x7C10   DeleteFile
0x70EC   DoFileDelete
0x87B4   MsgDelete
0x70F9   CheckKeyAttrib
0x7C5F   RenameFile
0x887D   MsgFileExists
0x70B3   RenameFileNotExist
0x7C1C   DoesFileExist
0x70BF   RenameCanceled
0x817B   ReadString
0x000B   NAMELEN
0x87A4   MsgClear
0x87D9   MsgNewFileName
0x70C7   CheckKeyDel
0x73CA   ViewFile
0x88F8   MsgViewFileAuto
0x88F0   MsgViewFileHex
0x88E7   MsgViewFileText
0x88D8   MsgViewFileMenu
0x7057   CheckKeyRename
0x0001   DRIVE_B_CPM
0x701D   CheckKeyView
0x713B   SelectDrive
0x7014   CheckKeyDriveB
0x7647   ReadAllHeaders
0x700B   CheckKeyDriveA
0x892F   CopyFileDstDrv
0x8913   CopySelOption
0x6FE0   CopyFileOK
0x891B   CopyFileRes
0x7CB6   CopyFile
0x6FFA   CheckKeyFileInfo
0x81BD   ClearNMsgLines
0x7ABE   ReadFileHeader
0x8796   MsgReadingExt
0x6FAE   CheckKeyCopy
0x734F   HandleFile
0x6F89   CheckKeyInfo
0x6F83   DoKeyEnter
0x000D   KEY_ENTER
0x6F7A   CheckEnter
0x6F6D   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6F65   CheckLeft
0x6F53   DoKeyRight
0x0009   KEY_RIGHT
0x6F4B   CheckRight
0x6F3E   DoKeyUp
0x000B   KEY_UP
0x7262   MoveIt
0x6F36   CheckUp
0x6F25   DoKeyDown
0x000A   KEY_DOWN
0x74E1   DisplayFileInfo
0x8911   SelFileCache
0x7704   Mul
0x6F03   CalcFileCache
0x86C5   MsgFilesCnt
0x8908   FileCnt
0x86CE   MsgFilesCntNo
0x86B5   MsgDrive
0x769D   Word2Txt
0x86C0   MsgDriveLet
0x890D   AUCntUsed
0x7B3E   SetFastKeys
0x80FA   DrawCursor
0x0060   SCR_SEL_CLR
0x8666   MsgMessages
0x0007   LST_FILE_INFO
0x8656   MsgFileInf
0x0004   LST_DISK_INFO
0x8646   MsgDskInf
0x8636   MsgSysInf
0x8676   BtnBar
0x0060   SCR_LBL_CLR
0x8626   VerMsg2
0x8011   PrintStr
0x0001   LST_PROG_INFO
0x8616   VerMsg1
0x8088   DrawHLines
0x80E2   DrawVLines
0x890B   CursorAddr
0x81D2   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x7FF1   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x8909   NameCol
0x0010   LST_FIRST_COL
0x890A   SelFile
0x7FD5   ReadChar
0x9759   DataBuf
0x7B49   GetErrMsg
0x5C3A   ERRNR
0x6DE6   HCRunEnd
0x6F14   ReadKeyLoop
0x6EA1   DisplayDiskInfo
0x729A   DisplayFilenames
0x6E23   InitUI
0x6DDA   HCRunMain
0x72BA   GetFileNames
0x8039   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x86D5   MsgErr
0x76A8   Byte2Txt
0x86E0   MsgErrCode
0x6DD7   HCRunCacheFiles
0x7AA1   ReadCatalogTrack
0x890F   AUCntMaxFree
0x6DB4   DriveIs80Tracks
0x8445   PrintOneLineCleanLine
0x013E   MAX_FREE_AU_CNT
0x7B7B   RWTSRes
0x77C6   ReadOneDiskSector
0x9759   FileData
0x0050   TRACK_CNT
0x7B8B   BDOSSelectDisk
0x7B70   RWTSDrive
0x7B88   BDOSInit
0x0000   DRIVE_A_CPM
0x6D95   DetectTrackCount
0x7B94   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x893B   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x9759   TrackBuf
0x6D72   HCRunInitDisk
0x6DEE   ErrorHandler
0x5C3D   ERRSP
0x77B7   IF1Init
0x7FDB   InitFonts
0x6D60   Start
