# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 29000
  12  7148
  13  7148              Start:
  14  7148              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  7148 CD 9D 7E     		call InitFonts
  16  714B              	ENDIF
  17  714B CD E6 79     	call IF1Init
  18  714E
  19  714E              	;install error handler
  20  714E 2A 3D 5C     	ld		hl, (ERRSP)
  21  7151 E5           	push	hl
  22  7152 21 B0 71     	ld		hl, ErrorHandler
  23  7155 E5           	push	hl
  24  7156 ED 73 3D 5C  	ld		(ERRSP), sp
  25  715A
  26  715A              HCRunInitDisk:
  27  715A              	;Set track buffer to del marker
  28  715A 21 2A 95     	ld		hl, TrackBuf
  29  715D 54           	ld		d, h
  30  715E 5D           	ld		e, l
  31  715F 13           	inc		de
  32  7160 01 00 10     	ld		bc, SPT*SECT_SZ
  33  7163 36 E5        	ld		(hl), DEL_MARKER
  34  7165 ED B0        	ldir
  35  7167
  36  7167              	;Invalidate file cache
  37  7167 21 44 86     	ld		hl, FileCache
  38  716A 54           	ld		d, h
  39  716B 5D           	ld		e, l
  40  716C 13           	inc		de
  41  716D 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  7170 36 00        	ld		(hl), 0
  43  7172 ED B0        	ldir
  44  7174
  45  7174              	;main program
  46  7174 CD DD 7B     	call 	ReadCatalogTrack
  47  7177 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  7178 28 1E        	jr		z, HCRunCacheFiles
  49  717A
  50  717A 6F           	ld		l, a
  51  717B 26 00        	ld		h, 0
  52  717D 11 B7 84     	ld		de, MsgErrCode
  53  7180 CD 76 79     	call	Byte2Txt
  54  7183 21 AC 84     	ld		hl, MsgErr
  55  7186 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
  56  7189 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  718B CD FB 7E     	call	PrintStrClr
  58  718E CD 97 7E     	call	ReadChar
  59  7191 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  7193 32 B9 7C     	ld		(RWTSDrive), a
  61  7196 18 C2        	jr		HCRunInitDisk
  62  7198
  63  7198              HCRunCacheFiles:
  64  7198 CD E1 75     	call 	GetFileNames
  65  719B
  66  719B              HCRunMain:
  67  719B CD E2 71     	call 	InitUI
  68  719E CD E1 78     	call	PrintIntro
  69  71A1 CD C1 75     	call	DisplayFilenames
  70  71A4 CD 45 72     	call	DisplayDiskInfo
  71  71A7 C3 9F 72     	jp		ReadKeyLoop
  72  71AA
  73  71AA              HCRunEnd:
  74  71AA              	;restore error handler
  75  71AA E1           	pop		hl
  76  71AB E1           	pop		hl
  77  71AC 22 3D 5C     	ld		(ERRSP), hl
  78  71AF
  79  71AF C9           	ret
  80  71B0
  81  71B0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  82  71B0
  83  71B0              ErrorHandler:
  84  71B0 E1           	pop		hl
  85  71B1 22 3D 5C     	ld		(ERRSP), hl
  86  71B4
  87  71B4 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  88  71B7 6F           	ld		l, a
  89  71B8 26 00        	ld		h, 0
  90  71BA 11 B7 84     	ld		de, MsgErrCode
  91  71BD CD 76 79     	call	Byte2Txt
  92  71C0 21 AC 84     	ld		hl, MsgErr
  93  71C3 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
  94  71C6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  95  71C8 CD FB 7E     	call	PrintStrClr
  96  71CB
  97  71CB 3A 3A 5C     	ld		a, (ERRNR)
  98  71CE CD 92 7C     	call	GetErrMsg
  99  71D1
 100  71D1 21 2A 95     	ld		hl, DataBuf
 101  71D4 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 102  71D7 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 103  71D9 CD FB 7E     	call	PrintStrClr
 104  71DC
 105  71DC CD 97 7E     	call	ReadChar
 106  71DF C3 48 71     	jp	Start
 107  71E2
 108  71E2
 109  71E2
 110  71E2
 111  71E2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 112  71E2
 113  71E2              InitUI:
 114  71E2 AF           	xor		a
 115  71E3 32 3D 86     	ld		(SelFile), A
 116  71E6 3E 11        	ld		a, LST_FIRST_COL + 1
 117  71E8 32 3C 86     	ld		(NameCol), A
 118  71EB 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 119  71EE ED 53 B0 5C  	ld		(LineCol), de
 120  71F2
 121  71F2 CD B3 7E     	call	ClrScr
 122  71F5
 123  71F5 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 124  71F8 ED 4B 58 80  	ld		bc, (CurrScrAttrAddr)
 125  71FC 09           	add		hl, bc
 126  71FD 22 3E 86     	ld		(CursorAddr), hl
 127  7200
 128  7200 3E 84        	ld		a, CHR_DC
 129  7202 CD 74 7F     	call	DrawVLines
 130  7205
 131  7205 3E 28        	ld		a, SCR_LBL_CLR
 132  7207 11 00 17     	ld		de, 23 << 8
 133  720A 21 3D 84     	ld		hl, BtnBar
 134  720D CD FB 7E     	call	PrintStrClr
 135  7210
 136  7210 3E 28        	ld		a, SCR_LBL_CLR
 137  7212 21 DE 83     	ld		hl, MsgSysInf
 138  7215 11 00 00     	ld		de, LST_PROG_INFO << 8
 139  7218 CD FB 7E     	call	PrintStrClr
 140  721B
 141  721B 3E 28        	ld		a, SCR_LBL_CLR
 142  721D 21 0D 84     	ld		hl, MsgDskInf
 143  7220 11 00 06     	ld		de, LST_DISK_INFO << 8
 144  7223 CD FB 7E     	call	PrintStrClr
 145  7226
 146  7226 3E 28        	ld		a, SCR_LBL_CLR
 147  7228 21 1D 84     	ld		hl, MsgFileInf
 148  722B 11 00 0A     	ld		de, LST_FILE_INFO << 8
 149  722E CD FB 7E     	call	PrintStrClr
 150  7231
 151  7231 3E 28        	ld		a, SCR_LBL_CLR
 152  7233 21 2D 84     	ld		hl, MsgMessages
 153  7236 11 00 10     	ld		de, LST_LINE_MSG << 8
 154  7239 CD FB 7E     	call	PrintStrClr
 155  723C
 156  723C 3E 28        	ld		a, SCR_SEL_CLR
 157  723E CD 93 7F     	call	DrawCursor
 158  7241
 159  7241 CD 87 7C     	call	SetFastKeys
 160  7244
 161  7244 C9           	ret
 162  7245
 163  7245
 164  7245              DisplayDiskInfo:
 165  7245 3A B9 7C     	ld		a, (RWTSDrive)
 166  7248 C6 C1        	add		'A' + $80
 167  724A 32 8B 84     	ld		(MsgDriveLet), a
 168  724D 21 7C 84     	ld		hl, MsgDrive
 169  7250 11 00 07     	ld		de, LST_DISK_INFO + 1 << 8
 170  7253 CD D3 7E     	call	PrintStr
 171  7256
 172  7256 3A 3B 86     	ld		a, (FileCnt)
 173  7259 6F           	ld		l, a
 174  725A 26 00        	ld		h, 0
 175  725C 11 95 84     	ld		de, MsgFilesCntNo
 176  725F CD 76 79     	call	Byte2Txt
 177  7262 21 8C 84     	ld		hl, MsgFilesCnt
 178  7265 11 00 08     	ld		de, LST_DISK_INFO + 2 << 8
 179  7268 CD D3 7E     	call	PrintStr
 180  726B
 181  726B ED 5B 40 86  	ld		de, (AUCnt)
 182  726F 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 183  7272 B7           	or		a
 184  7273 ED 52        	sbc		hl, de
 185  7275 CB 15        	rl		l								;*2, 2K/AU
 186  7277 CB 14        	rl		h
 187  7279 11 A3 84     	ld		de, MsgFreeSpaceNo - 2
 188  727C CD 6B 79     	call	Word2Txt
 189  727F 3E 3A        	ld		a, ':'
 190  7281 32 A4 84     	ld		(MsgFreeSpaceNo -1), a
 191  7284 21 9C 84     	ld		hl, MsgFreeSpace
 192  7287 11 00 09     	ld		de, LST_DISK_INFO + 3 << 8
 193  728A CD D3 7E     	call	PrintStr
 194  728D
 195  728D C9           	ret
 196  728E
 197  728E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198  728E
 199  728E              CalcFileCache:
 200  728E 3A 3D 86     	ld		a, (SelFile)
 201  7291 11 19 00     	ld		de, CACHE_SZ
 202  7294 CD D2 79     	call	Mul
 203  7297 01 44 86     	ld		bc, FileCache
 204  729A 09           	add		hl, bc					;HL = file AU cnt
 205  729B 22 42 86     	ld		(SelFileCache), hl
 206  729E C9           	ret
 207  729F
 208  729F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209  729F
 210  729F
 211  729F              ReadKeyLoop:
 212  729F CD 8E 72     	call	CalcFileCache
 213  72A2 CD 13 77     	call	DisplayFileInfo
 214  72A5
 215  72A5 CD 97 7E     	call	ReadChar
 216  72A8
 217  72A8 FE 0A        	cp		KEY_DOWN
 218  72AA 20 11        	jr		nz, CheckUp
 219  72AC
 220  72AC 3A 3B 86     	ld		a, (FileCnt)
 221  72AF 47           	ld		b, a
 222  72B0 3A 3D 86     	ld		a, (SelFile)
 223  72B3 3C           	inc		a
 224  72B4 B8           	cp		b
 225  72B5 30 E8        	jr		nc, ReadKeyLoop
 226  72B7 32 3D 86     	ld		(SelFile), a
 227  72BA C3 89 75     	jp		MoveIt
 228  72BD
 229  72BD              CheckUp:
 230  72BD FE 0B        	cp		KEY_UP
 231  72BF 20 0D        	jr		nz, CheckRight
 232  72C1
 233  72C1 3A 3D 86     	ld		a, (SelFile)
 234  72C4 B7           	or		a
 235  72C5 28 D8        	jr		z, ReadKeyLoop
 236  72C7
 237  72C7 3D           	dec		a
 238  72C8 32 3D 86     	ld		(SelFile), a
 239  72CB C3 89 75     	jp		MoveIt
 240  72CE
 241  72CE              CheckRight:
 242  72CE FE 09        	cp		KEY_RIGHT
 243  72D0 20 12        	jr		nz, CheckLeft
 244  72D2
 245  72D2 3A 3B 86     	ld		a, (FileCnt)
 246  72D5 47           	ld		b, a
 247  72D6 3A 3D 86     	ld		a, (SelFile)
 248  72D9 C6 17        	add		LST_LINES_CNT
 249  72DB B8           	cp		b
 250  72DC 30 C1        	jr		nc, ReadKeyLoop
 251  72DE
 252  72DE 32 3D 86     	ld		(SelFile), a
 253  72E1 C3 89 75     	jp		MoveIt
 254  72E4
 255  72E4              CheckLeft:
 256  72E4 FE 08        	cp		KEY_LEFT
 257  72E6 20 0D        	jr		nz, CheckEnter
 258  72E8
 259  72E8 3A 3D 86     	ld		a, (SelFile)
 260  72EB D6 17        	sub		LST_LINES_CNT
 261  72ED 38 B0        	jr		c, ReadKeyLoop
 262  72EF
 263  72EF 32 3D 86     	ld		(SelFile), a
 264  72F2 C3 89 75     	jp		MoveIt
 265  72F5
 266  72F5              CheckEnter:
 267  72F5 FE 0D        	cp		KEY_ENTER
 268  72F7 C2 00 73     	jp		nz, CheckKeyInfo
 269  72FA CD 7A 76     	call	HandleFile
 270  72FD C3 9B 71     	jp		HCRunMain
 271  7300
 272  7300              CheckKeyInfo:
 273  7300 FE 34        	cp		'4'
 274  7302 20 27        	jr		nz, CheckKeyCopy
 275  7304
 276  7304 3A 3B 86     	ld		a, (FileCnt)
 277  7307 B7           	or		a
 278  7308 CA 9F 72     	jp		z, ReadKeyLoop
 279  730B
 280  730B DD 2A 42 86  	ld		ix, (SelFileCache)
 281  730F 21 6E 85     	ld		hl, MsgReadingExt
 282  7312 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 283  7315 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 284  7317 CD FB 7E     	call	PrintStrClr
 285  731A CD 07 7C     	call	ReadFileHeader
 286  731D 21 7C 85     	ld		hl, MsgClear
 287  7320 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
 288  7323 3E 0F        	ld		a, SCR_DEF_CLR
 289  7325 CD FB 7E     	call	PrintStrClr
 290  7328 C3 9F 72     	jp		ReadKeyLoop
 291  732B
 292  732B              CheckKeyCopy:
 293  732B FE 35        	cp		'5'
 294  732D C2 A8 73     	jp		nz, CheckKeyFileInfo
 295  7330
 296  7330 3A 3B 86     	ld		a, (FileCnt)
 297  7333 B7           	or		a
 298  7334 CA 9F 72     	jp		z, ReadKeyLoop
 299  7337
 300  7337 3A B9 7C     	ld 		a, (RWTSDrive)
 301  733A 3C           	inc		a
 302  733B EE 03        	xor		%11
 303  733D C6 40        	add		'A' - 1
 304  733F 32 D2 85     	ld		(MsgCopyFileDrv), a
 305  7342 21 C7 85     	ld		hl, MsgCopyFile
 306  7345 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 307  7348 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 308  734A CD FB 7E     	call	PrintStrClr
 309  734D
 310  734D 2A 42 86     	ld		hl, (SelFileCache)
 311  7350 3A B9 7C     	ld 		a, (RWTSDrive)
 312  7353 3C           	inc		a
 313  7354 EE 03        	xor		%11
 314  7356 CD 4F 7D     	call	DoesFileExist
 315  7359 3C           	inc		a
 316  735A 28 13        	jr		z, CopyFileDestNotExist
 317  735C
 318  735C 21 1B 86     	ld		hl, MsgFileOverwrite
 319  735F 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 320  7362 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 321  7364 CD FB 7E     	call	PrintStrClr
 322  7367 CD 97 7E     	call	ReadChar
 323  736A FE 79        	cp		'y'
 324  736C C2 8F 73     	jp		nz, CopyFileDontOverwrite
 325  736F
 326  736F              CopyFileDestNotExist:
 327  736F 2A 42 86     	ld		hl, (SelFileCache)
 328  7372 CD AA 7D     	call	CopyFile
 329  7375 B7           	or		a
 330  7376 28 17        	jr		z, CopyFileOK
 331  7378
 332  7378 6F           	ld		l, a
 333  7379 26 00        	ld		h, 0
 334  737B 11 B7 84     	ld		de, MsgErrCode
 335  737E CD 76 79     	call	Byte2Txt
 336  7381 21 AC 84     	ld		hl, MsgErr
 337  7384 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 338  7387 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 339  7389 CD FB 7E     	call	PrintStrClr
 340  738C CD 97 7E     	call	ReadChar
 341  738F
 342  738F              CopyFileOK:
 343  738F              CopyFileDontOverwrite:
 344  738F 21 7C 85     	ld		hl, MsgClear
 345  7392 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
 346  7395 3E 0F        	ld		a, SCR_DEF_CLR
 347  7397 CD FB 7E     	call	PrintStrClr
 348  739A 21 7C 85     	ld		hl, MsgClear
 349  739D 11 00 12     	ld		de, LST_LINE_MSG+2 << 8
 350  73A0 3E 0F        	ld		a, SCR_DEF_CLR
 351  73A2 CD FB 7E     	call	PrintStrClr
 352  73A5 C3 5A 71     	jp		HCRunInitDisk
 353  73A8
 354  73A8              CheckKeyFileInfo:
 355  73A8 FE 20        	cp		' '
 356  73AA 20 0D        	jr		nz, CheckKeyDriveA
 357  73AC
 358  73AC 3A 3B 86     	ld		a, (FileCnt)
 359  73AF B7           	or		a
 360  73B0 CA 9F 72     	jp		z, ReadKeyLoop
 361  73B3
 362  73B3 CD 85 78     	call	ReadAllHeaders
 363  73B6 C3 9F 72     	jp		ReadKeyLoop
 364  73B9
 365  73B9              CheckKeyDriveA:
 366  73B9 FE 31        	cp		'1'
 367  73BB 20 05        	jr		nz, CheckKeyDriveB
 368  73BD 3E 00        	ld		a, DRIVE_A_CPM
 369  73BF C3 D7 74     	jp		SelectDrive
 370  73C2
 371  73C2              CheckKeyDriveB:
 372  73C2 FE 32        	cp		'2'
 373  73C4 20 05        	jr		nz, CheckKeyView
 374  73C6 3E 01        	ld		a, DRIVE_B_CPM
 375  73C8 C3 D7 74     	jp		SelectDrive
 376  73CB
 377  73CB              CheckKeyView:
 378  73CB FE 33        	cp		'3'
 379  73CD 20 0D        	jr		nz, CheckKeyRename
 380  73CF
 381  73CF 3A 3B 86     	ld		a, (FileCnt)
 382  73D2 B7           	or		a
 383  73D3 CA 9F 72     	jp		z, ReadKeyLoop
 384  73D6
 385  73D6 CD F8 76     	call	ViewFile
 386  73D9 C3 9B 71     	jp		HCRunMain
 387  73DC
 388  73DC              CheckKeyRename:
 389  73DC FE 36        	cp		'6'
 390  73DE 20 7D        	jr		nz, CheckKeyDel
 391  73E0
 392  73E0 3A 3B 86     	ld		a, (FileCnt)
 393  73E3 B7           	or		a
 394  73E4 CA 9F 72     	jp		z, ReadKeyLoop
 395  73E7
 396  73E7 21 B7 85     	ld		hl, MsgNewFileName
 397  73EA 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 398  73ED 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 399  73EF CD FB 7E     	call	PrintStrClr
 400  73F2
 401  73F2 21 7C 85     	ld		hl, MsgClear
 402  73F5 11 2A 95     	ld		de, DataBuf
 403  73F8 01 0B 00     	ld		bc, NAMELEN
 404  73FB ED B0        	ldir
 405  73FD 3E A0        	ld		a, $80 | ' '
 406  73FF 12           	ld		(de), a
 407  7400 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 408  7403 21 2A 95     	ld		hl, DataBuf
 409  7406 CD D3 7E     	call	PrintStr
 410  7409
 411  7409 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 412  740C 01 0B 00     	ld		bc, NAMELEN
 413  740F CD 14 80     	call	ReadString
 414  7412
 415  7412 11 2A 95     	ld		de, DataBuf
 416  7415 1A           	ld		a, (de)
 417  7416 FE 20        	cp		' '					;If starting with space, input was canceled.
 418  7418 CA 44 74     	jp		z, RenameCanceled
 419  741B
 420  741B              	;Check if new name doesn't exist already. Cancel if so.
 421  741B 21 2A 95     	ld		hl, DataBuf
 422  741E 3A B9 7C     	ld 		a, (RWTSDrive)
 423  7421 3C           	inc		a
 424  7422 CD 4F 7D     	call	DoesFileExist
 425  7425 3C           	inc		a
 426  7426 28 10        	jr		z, RenameFileNotExist
 427  7428
 428  7428 21 2B 86     	ld		hl, MsgFileExists
 429  742B 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 430  742E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 431  7430 CD FB 7E     	call	PrintStrClr
 432  7433 CD 97 7E     	call	ReadChar
 433  7436 18 0C        	jr		RenameCanceled
 434  7438
 435  7438              RenameFileNotExist:
 436  7438 11 2A 95     	ld		de, DataBuf
 437  743B 2A 42 86     	ld		hl, (SelFileCache)
 438  743E CD 87 7D     	call	RenameFile
 439  7441 C3 5A 71     	jp		HCRunInitDisk
 440  7444
 441  7444              RenameCanceled:
 442  7444 21 7C 85     	ld		hl, MsgClear
 443  7447 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 444  744A 3E 0F        	ld		a, SCR_DEF_CLR
 445  744C CD FB 7E     	call	PrintStrClr
 446  744F 21 7C 85     	ld		hl, MsgClear
 447  7452 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 448  7455 3E 0F        	ld		a, SCR_DEF_CLR
 449  7457 CD FB 7E     	call	PrintStrClr
 450  745A C3 9F 72     	jp		ReadKeyLoop
 451  745D
 452  745D              CheckKeyDel:
 453  745D FE 38        	cp		'8'
 454  745F 20 34        	jr		nz, CheckKeyAttrib
 455  7461
 456  7461 3A 3B 86     	ld		a, (FileCnt)
 457  7464 B7           	or		a
 458  7465 CA 9F 72     	jp		z, ReadKeyLoop
 459  7468
 460  7468 21 8C 85     	ld		hl, MsgDelete
 461  746B 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 462  746E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 463  7470 CD FB 7E     	call	PrintStrClr
 464  7473 CD 97 7E     	call	ReadChar
 465  7476 FE 79        	cp		'y'
 466  7478 28 0E        	jr		z, DoFileDelete
 467  747A 21 7C 85     	ld		hl, MsgClear
 468  747D 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 469  7480 3E 0F        	ld		a, SCR_DEF_CLR
 470  7482 CD FB 7E     	call	PrintStrClr
 471  7485 C3 9F 72     	jp		ReadKeyLoop
 472  7488              DoFileDelete:
 473  7488 2A 42 86     	ld		hl, (SelFileCache)
 474  748B 3A B9 7C     	ld 		a, (RWTSDrive)
 475  748E 3C           	inc		a					;Convert to BASIC drive number: 1,2
 476  748F CD 43 7D     	call	DeleteFile
 477  7492 C3 5A 71     	jp		HCRunInitDisk
 478  7495
 479  7495              CheckKeyAttrib:
 480  7495 FE 37        	cp		'7'
 481  7497 20 44        	jr		nz, CheckKeyExtra
 482  7499
 483  7499 3A 3B 86     	ld		a, (FileCnt)
 484  749C B7           	or		a
 485  749D CA 9F 72     	jp		z, ReadKeyLoop
 486  74A0
 487  74A0 21 9B 85     	ld		hl, MsgSetRO
 488  74A3 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 489  74A6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 490  74A8 CD FB 7E     	call	PrintStrClr
 491  74AB CD 97 7E     	call	ReadChar
 492  74AE 1E 00        	ld		e, 0
 493  74B0 FE 79        	cp		'y'
 494  74B2 20 02        	jr		nz, CheckSYS
 495  74B4 1E 01        	ld		e, 1
 496  74B6
 497  74B6              CheckSYS:
 498  74B6 D5           	push	de
 499  74B7 21 A9 85     		ld		hl, MsgSetSYS
 500  74BA 11 00 12     		ld		de, LST_LINE_MSG + 2 << 8
 501  74BD 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 502  74BF CD FB 7E     		call	PrintStrClr
 503  74C2 CD 97 7E     		call	ReadChar
 504  74C5 FE 79        		cp		'y'
 505  74C7 D1           	pop		de
 506  74C8 20 04        	jr		nz, AttrChange
 507  74CA 3E 02        	ld		a, %10
 508  74CC B3           	or		e
 509  74CD 5F           	ld		e, a
 510  74CE
 511  74CE              AttrChange:
 512  74CE 2A 42 86     	ld		hl, (SelFileCache)
 513  74D1 CD 5D 7D     	call	ChangeFileAttrib
 514  74D4 C3 5A 71     	jp		HCRunInitDisk
 515  74D7
 516  74D7              SelectDrive:
 517  74D7 32 B9 7C     	ld 		(RWTSDrive), a
 518  74DA C3 5A 71     	jp		HCRunInitDisk
 519  74DD
 520  74DD              CheckKeyExtra:
 521  74DD FE 39        	cp		'9'
 522  74DF C2 81 75     	jp		nz, CheckKeyExit
 523  74E2
 524  74E2 21 D4 85     	ld		hl, MsgMenu0
 525  74E5 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 526  74E8 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 527  74EA CD FB 7E     	call	PrintStrClr
 528  74ED 3A B9 7C     	ld		a, (RWTSDrive)
 529  74F0 C6 41        	add		'A'
 530  74F2 32 EA 85     	ld		(MsgMenu1Drv), a
 531  74F5 32 0A 86     	ld		(MsgFormatDrv), a
 532  74F8 32 F3 85     	ld		(MsgMenu2Drv1), a
 533  74FB 3A B9 7C     	ld		a, (RWTSDrive)
 534  74FE 3C           	inc		a
 535  74FF EE 03        	xor		%11
 536  7501 C6 40        	add		'A'-1
 537  7503 32 F7 85     	ld		(MsgMenu2Drv2), a
 538  7506
 539  7506              CheckKeyExtraMenu:
 540  7506 21 F9 85     	ld		hl, MsgMenu3
 541  7509 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 542  750C CD D3 7E     	call	PrintStr
 543  750F 21 E1 85     	ld		hl, MsgMenu1
 544  7512 11 00 13     	ld		de, LST_LINE_MSG + 3 << 8
 545  7515 CD D3 7E     	call	PrintStr
 546  7518 21 EC 85     	ld		hl, MsgMenu2
 547  751B 11 00 14     	ld		de, LST_LINE_MSG + 4 << 8
 548  751E CD D3 7E     	call	PrintStr
 549  7521 CD 97 7E     	call	ReadChar
 550  7524 F5           	push	af
 551  7525
 552  7525 21 7C 85     		ld		hl, MsgClear
 553  7528 11 00 12     		ld		de, LST_LINE_MSG + 2 << 8
 554  752B CD D3 7E     		call	PrintStr
 555  752E 21 7C 85     		ld		hl, MsgClear
 556  7531 11 00 13     		ld		de, LST_LINE_MSG + 3 << 8
 557  7534 CD D3 7E     		call	PrintStr
 558  7537 21 7C 85     		ld		hl, MsgClear
 559  753A 11 00 14     		ld		de, LST_LINE_MSG + 4 << 8
 560  753D CD D3 7E     		call	PrintStr
 561  7540
 562  7540 F1           	pop		af
 563  7541 FE 30        	cp		'0'
 564  7543 28 39        	jr		z, ExtraMenuExit
 565  7545
 566  7545 FE 31        	cp		'1'
 567  7547 20 2C        	jr		nz, CheckExtra2
 568  7549
 569  7549 21 FF 85     	ld		hl, MsgFormat
 570  754C 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 571  754F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 572  7551 CD FB 7E     	call	PrintStrClr
 573  7554
 574  7554 CD 0B 7A     	call	FormatDisk
 575  7557 B7           	or		a
 576  7558 CA 5A 71     	jp		z, HCRunInitDisk
 577  755B
 578  755B              	;Display error for format
 579  755B 6F           	ld		l, a
 580  755C 26 00        	ld		h, 0
 581  755E 11 B7 84     	ld		de, MsgErrCode
 582  7561 CD 76 79     	call	Byte2Txt
 583  7564 21 AC 84     	ld		hl, MsgErr
 584  7567 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 585  756A 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586  756C CD FB 7E     	call	PrintStrClr
 587  756F CD 97 7E     	call	ReadChar
 588  7572 C3 5A 71     	jp		HCRunInitDisk
 589  7575
 590  7575              CheckExtra2:
 591  7575 FE 32        	cp		'2'
 592  7577 20 8D        	jr		nz, CheckKeyExtraMenu
 593  7579
 594  7579 CD DB 7A     	call	CopyDisk
 595  757C 18 00        	jr		ExtraMenuExit
 596  757E
 597  757E              ExtraMenuExit:
 598  757E C3 9B 71     	jp		HCRunMain
 599  7581
 600  7581              CheckKeyExit:
 601  7581 FE 30        	cp		'0'
 602  7583 C2 9F 72     	jp		nz, ReadKeyLoop
 603  7586 C3 AA 71     	jp		HCRunEnd
 604  7589
 605  7589              MoveIt:
 606  7589 CD 9E 7F     	call 	MoveCursor
 607  758C C3 9F 72     	jp		ReadKeyLoop
 608  758F
 609  758F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 610  758F
 611  758F
 612  758F              DisplayFilename:
 613  758F 06 0B        	LD		B, NAMELEN
 614  7591              DispLoop:
 615  7591 1A           	LD		A, (DE)
 616  7592
 617  7592              	;clear bit 7
 618  7592 CB BF        	RES 	7, A
 619  7594 32 81 5C     	LD		(CODE), A
 620  7597
 621  7597 13           	INC		DE
 622  7598 D5           	PUSH	DE
 623  7599 C5           	PUSH	BC
 624  759A CD D6 7F     		CALL	PrintChar
 625  759D C1           	POP		BC
 626  759E D1           	POP 	DE
 627  759F
 628  759F 21 B0 5C     	LD		HL, COL
 629  75A2 34           	INC		(HL)
 630  75A3 10 EC        	DJNZ	DispLoop
 631  75A5              	;now a name is displayed
 632  75A5
 633  75A5              	;check bounds
 634  75A5 3A B1 5C     	LD		A, (LINE)
 635  75A8 3C           	INC		A
 636  75A9 FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 637  75AB 38 0A        	JR		C, LineOK
 638  75AD
 639  75AD              	;set names column to the next one
 640  75AD 3A 3C 86     	LD		A, (NameCol)
 641  75B0 C6 0C        	ADD		NAMELEN + 1
 642  75B2 32 3C 86     	LD		(NameCol), A
 643  75B5
 644  75B5 3E 00        	LD		A, LST_FIRST_LINE
 645  75B7              LineOK:
 646  75B7 32 B1 5C     	LD		(LINE), A
 647  75BA
 648  75BA 3A 3C 86     	LD		A, (NameCol)
 649  75BD 32 B0 5C     	LD		(COL), A
 650  75C0
 651  75C0 C9           	RET
 652  75C1
 653  75C1
 654  75C1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 655  75C1
 656  75C1              DisplayFilenames:
 657  75C1 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 658  75C4 ED 53 B0 5C  	ld		(LineCol), de
 659  75C8
 660  75C8 11 44 86     	ld		de, FileCache
 661  75CB 3A 3B 86     	ld		a, (FileCnt)
 662  75CE B7           	or		a
 663  75CF C8           	ret		z
 664  75D0
 665  75D0 47           	ld		b,	a
 666  75D1
 667  75D1              DisplayFilenamesLoop:
 668  75D1 C5           	push	bc
 669  75D2 D5           		push	de
 670  75D3 CD 8F 75     			call	DisplayFilename
 671  75D6 D1           		pop		de
 672  75D7 EB           		ex		de, hl
 673  75D8 01 19 00     		ld		bc, CACHE_SZ
 674  75DB 09           		add		hl, bc
 675  75DC EB           		ex		de, hl
 676  75DD C1           	pop		bc
 677  75DE 10 F1        	djnz	DisplayFilenamesLoop
 678  75E0
 679  75E0 C9           	ret
 680  75E1
 681  75E1
 682  75E1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 683  75E1              ;Selects only valid filenames (not deleted and only from first extension)
 684  75E1              GetFileNames:
 685  75E1 DD 21 2A 95  	ld		ix, TrackBuf
 686  75E5 11 44 86     	ld		de, FileCache
 687  75E8 06 80        	ld		b, MAX_EXT_CNT
 688  75EA AF           	xor		a
 689  75EB 32 3B 86     	ld		(FileCnt), a
 690  75EE 21 40 86     	ld		hl, AUCnt
 691  75F1 77           	ld		(hl), a
 692  75F2 23           	inc		hl
 693  75F3 77           	ld		(hl), a
 694  75F4
 695  75F4              StoreFilenamesLoop:
 696  75F4 AF           	xor a
 697  75F5 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 698  75F8 C2 6C 76     	jp nz, NextExt
 699  75FB
 700  75FB              	;count AU
 701  75FB D9           	exx
 702  75FC E5           	push hl
 703  75FD CD 3A 7A     		call CheckExtAlloc
 704  7600 EB           		ex de, hl			;save first AU no.
 705  7601
 706  7601              		;store disk alocated AU count
 707  7601 2A 40 86     		ld hl, (AUCnt)
 708  7604 48           		ld c, b
 709  7605 06 00        		ld b, 0
 710  7607 09           		add hl, bc
 711  7608 22 40 86     		ld (AUCnt), hl
 712  760B E1           	pop hl
 713  760C D9           	exx
 714  760D
 715  760D AF           	xor	a
 716  760E DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 717  7611 20 32        	jr nz, FindExt
 718  7613
 719  7613 DD E5        	push ix
 720  7615 E1           	pop hl
 721  7616 23           	inc hl					;skip del flag
 722  7617
 723  7617 C5           	push bc
 724  7618 ~            		/*
 725  7618 ~            		push de
 726  7618 ~            			push hl
 727  7618 ~            				ex de, hl
 728  7618 ~            				call DisplayFilename
 729  7618 ~            			pop hl
 730  7618 ~            		pop de
 731  7618 ~            		*/
 732  7618 01 0B 00     		ld bc, NAMELEN
 733  761B ED B0        		ldir				;save file name
 734  761D
 735  761D D9           		exx
 736  761E D5           		push 	de			;de = first AU
 737  761F D9           		exx
 738  7620 E1           		pop		hl
 739  7621 EB           		ex		de, hl
 740  7622 73 23 72 2B  		ld		(hl), de	;save first AU
 741  7626
 742  7626 23           		inc		hl
 743  7627 23           		inc		hl
 744  7628
 745  7628 D9           		exx					;save AU cnt for file
 746  7629 C5           		push	bc
 747  762A D9           		exx
 748  762B C1           		pop		bc
 749  762C 71 23 70 2B  		ld		(hl), bc
 750  7630
 751  7630 23           		inc		hl
 752  7631 23           		inc		hl
 753  7632
 754  7632              		;xor		a			;make flag 0 to signal that header is not read yet
 755  7632              		;ld		(hl), a
 756  7632
 757  7632 01 0A 00     		ld		bc, HDR_SZ + 1
 758  7635 09           		add		hl, bc
 759  7636
 760  7636 EB           		ex		de, hl
 761  7637 C1           	pop bc
 762  7638
 763  7638
 764  7638 3A 3B 86     	ld 		a, (FileCnt)			;inc file counter
 765  763B 3C           	inc		a
 766  763C 32 3B 86     	ld 		(FileCnt), a
 767  763F FE 5C        	cp		LST_MAX_FILES
 768  7641 38 29        	jr		c, NextExt
 769  7643 18 34        	jr		GetFileNamesEnd
 770  7645
 771  7645
 772  7645              FindExt:					;BC' = AU cnt for this ext
 773  7645 C5           	push	bc
 774  7646 D5           		push 	de
 775  7647 DD E5        			push	ix
 776  7649 D1           			pop		de
 777  764A 13           			inc		de				;DE = name to find
 778  764B
 779  764B 21 44 86     			ld		hl, FileCache
 780  764E 3A 3B 86     			ld		a, (FileCnt)
 781  7651 4F           			ld		c, a
 782  7652 CD F6 7B     			call	FindCache
 783  7655 20 13        			jr		nz, FindExtEnd
 784  7657
 785  7657 01 0D 00     			ld		bc, CACHE_AU_CNT
 786  765A 09           			add		hl, bc
 787  765B D9           			exx
 788  765C C5           			push	bc
 789  765D D9           			exx
 790  765E C1           			pop		bc
 791  765F
 792  765F 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 793  7663 EB           			ex		de, hl
 794  7664 09           			add		hl, bc
 795  7665 EB           			ex		de, hl
 796  7666 73 23 72 2B  			ld		(hl), de
 797  766A              FindExtEnd:
 798  766A D1           		pop		de
 799  766B C1           	pop		bc
 800  766C
 801  766C              NextExt:
 802  766C C5           	push bc
 803  766D 01 20 00     		ld bc, EXT_SZ
 804  7670 DD 09        		add ix, bc
 805  7672 C1           	pop	bc
 806  7673
 807  7673 05           	dec	b
 808  7674 78           	ld	a, b
 809  7675 B7           	or	a
 810  7676 C2 F4 75     	jp	nz, StoreFilenamesLoop
 811  7679              GetFileNamesEnd:
 812  7679 C9           	ret
 813  767A
 814  767A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 815  767A
 816  767A              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 817  767A              ;IN: HL = file name
 818  767A              HandleFile:
 819  767A              	;Make HL point to the selected file
 820  767A DD 2A 42 86  	ld		ix, (SelFileCache)
 821  767E DD E5        	push	ix
 822  7680 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 823  7683 B7           		or		a
 824  7684 CC 07 7C     		call	z, ReadFileHeader
 825  7687
 826  7687 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 827  768A FE 00        		cp		PROG_TYPE
 828  768C 28 59        		jr		z, HandleFileProg
 829  768E
 830  768E FE 03        		cp		BYTE_TYPE
 831  7690 20 65        		jr		nz, HandleFileText
 832  7692
 833  7692 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 833  7696 66 12
 834  7698 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 835  769B 19           		add		hl, de
 836  769C 7C           		ld		a, h
 837  769D B5           		or		l
 838  769E 28 29        		jr		z, HandleFileSCR
 839  76A0
 840  76A0
 841  76A0              HandleFileCODE:
 842  76A0 21 DA 84     		ld		hl, MsgLoadingCODE
 843  76A3 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 844  76A6 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 845  76A8 CD FB 7E     		call	PrintStrClr
 846  76AB
 847  76AB              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 848  76AB 21 71 7B     		ld		hl, IF1FileLoad
 849  76AE 11 00 5B     		ld		de, PRN_BUF
 850  76B1 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 851  76B4 ED B0        		ldir
 852  76B6 3E C9        		ld		a, $C9
 853  76B8 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 854  76B9
 855  76B9 E1           	pop		hl
 856  76BA ED 5B 2D 95  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 857  76BE C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 858  76BF C1           	pop		bc						;2nd, 3rd call for error handler
 859  76C0 C1           	pop		bc
 860  76C1 ED 43 3D 5C  	ld		(ERRSP), bc
 861  76C5 D5           	push	de						;push CODE address to return to = start of CODE block
 862  76C6 C3 00 5B     	jp		PRN_BUF
 863  76C9
 864  76C9
 865  76C9
 866  76C9
 867  76C9              HandleFileSCR:
 868  76C9 21 CB 84     		ld		hl, MsgLoadingSCR
 869  76CC 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 870  76CF 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 871  76D1 CD FB 7E     		call	PrintStrClr
 872  76D4
 873  76D4 E1           	pop		hl
 874  76D5
 875  76D5              	IFDEF _ROM_FNT_
 876  76D5              		;Load to alternate SCREEN$ memory
 877  76D5 11 00 C0     		ld		de, HC_VID_BANK1
 878  76D8 CD 71 7B     		call	IF1FileLoad
 879  76DB
 880  76DB              		;Set display to alternate SCREEN$ memory
 881  76DB 3E 08        		ld		a, HC_CFG_VID_C000
 882  76DD D3 7E        		out 	(HC_CFG_PORT), a
 883  76DF CD 97 7E     		call	ReadChar
 884  76E2
 885  76E2              		;Set back to regular SCREEN$ memory
 886  76E2 3E 00        		ld		a, HC_CFG_VID_4000
 887  76E4 D3 7E        		out 	(HC_CFG_PORT), a
 888  76E6              	ELSE
 889  76E6 ~            		ld		de, HC_VID_BANK0
 890  76E6 ~            		call	IF1FileLoad
 891  76E6 ~            		call	ReadChar
 892  76E6              	ENDIF
 893  76E6
 894  76E6 C9           	ret
 895  76E7
 896  76E7              HandleFileProg:
 897  76E7 21 BC 84     		ld		hl, MsgLoadingPrg
 898  76EA 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 899  76ED 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 900  76EF CD FB 7E     		call	PrintStrClr
 901  76F2 E1           	pop		hl
 902  76F3 CD 6E 7C     	call	LoadProgram
 903  76F6 C9           	ret
 904  76F7
 905  76F7
 906  76F7              HandleFileText:
 907  76F7 E1           	pop		hl
 908  76F8
 909  76F8
 910  76F8              ViewFile:
 911  76F8 CD B3 7E     	call	ClrScr
 912  76FB 2A 42 86     	ld		hl, (SelFileCache)
 913  76FE CD 4D 7E     	call	ReadFileSection					;DE = last address read
 914  7701 21 2A 96     	ld		hl, FileData
 915  7704              	;Calculate size of read buffer
 916  7704 E5           	push	hl
 917  7705 EB           		ex	de, hl
 918  7706 B7           		or	a
 919  7707 ED 52        		sbc	hl, de
 920  7709 44           		ld	b, h
 921  770A 4B           		ld	c, e
 922  770B E1           	pop		hl
 923  770C CD 5A 80     	call	InitViewer
 924  770F CD B4 80     	call	PrintLoop
 925  7712              ViewFileEnd:
 926  7712 C9           	ret
 927  7713
 928  7713              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 929  7713
 930  7713
 931  7713              DisplayFileInfo:
 932  7713 2A 42 86     	ld		hl, (SelFileCache)
 933  7716 E5           	push	hl
 934  7717              		;disk size - at least 2KB ==1  AU
 935  7717 01 0D 00     		ld		bc, CACHE_AU_CNT
 936  771A 09           		add		hl, bc
 937  771B 5E 23 56 2B  		ld		de, (hl)
 938  771F EB           		ex		de, hl
 939  7720              		;*2, since one block (AU) is 2KB.
 940  7720 CB 15        		rl	l
 941  7722 CB 14        		rl	h
 942  7724
 943  7724 11 F3 84     		ld		de, MsgFileSzDskN
 944  7727 CD 6B 79     		call	Word2Txt
 945  772A 21 EA 84     		ld		hl, MsgFileSzDsk
 946  772D 11 00 0B     		ld		de, LST_FILE_INFO + 1 << 8
 947  7730 CD D3 7E     		call	PrintStr
 948  7733 E1           	pop		hl
 949  7734 E5           	push	hl
 950  7735              		;attributes
 951  7735 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 952  7738 09           		add		hl, bc
 953  7739 EB           		ex		de, hl
 954  773A 21 03 85     		ld		hl, MsgFileAttrN
 955  773D 1A           		ld		a, (de)
 956  773E E6 80        		and		%10000000
 957  7740 28 14        		jr		z, NotRO
 958  7742
 959  7742 01 52 2F     		ld		bc, '/R'
 960  7745 71 23 70 2B  		ld		(hl), bc
 961  7749 23           		inc		hl
 962  774A 23           		inc		hl
 963  774B 01 4F 2C     		ld		bc, ',O'
 964  774E 71 23 70 2B  		ld		(hl), bc
 965  7752 23           		inc		hl
 966  7753 23           		inc		hl
 967  7754 18 12        		jr		CheckSys
 968  7756              NotRO:
 969  7756 01 2D 2D     		ld		bc, '--'
 970  7759 71 23 70 2B  		ld		(hl), bc
 971  775D 23           		inc		hl
 972  775E 23           		inc		hl
 973  775F 01 2D 2C     		ld		bc, ',-'
 974  7762 71 23 70 2B  		ld		(hl), bc
 975  7766 23           		inc		hl
 976  7767 23           		inc		hl
 977  7768
 978  7768              CheckSys:
 979  7768 13           		inc		de
 980  7769 1A           		ld		a, (de)
 981  776A E6 80        		and		%10000000
 982  776C 28 0E        		jr		z, NotSYS
 983  776E
 984  776E 01 48 49     		ld		bc, 'IH'
 985  7771 71 23 70 2B  		ld		(hl), bc
 986  7775 23           		inc		hl
 987  7776 23           		inc		hl
 988  7777 3E C4        		ld		a, 'D' + $80
 989  7779 77           		ld		(hl), a
 990  777A 18 0C        		jr		AttrEnd
 991  777C              NotSYS:
 992  777C 01 2D 2D     		ld		bc, '--'
 993  777F 71 23 70 2B  		ld		(hl), bc
 994  7783 23           		inc		hl
 995  7784 23           		inc		hl
 996  7785 3E AD        		ld		a, '-' + $80
 997  7787 77           		ld		(hl), a
 998  7788              AttrEnd:
 999  7788 11 00 0C     		ld		de, LST_FILE_INFO + 2 << 8
1000  778B 21 FA 84     		ld		hl, MsgFileAttr
1001  778E CD D3 7E     		call	PrintStr
1002  7791 DD E1        	pop		ix
1003  7793 DD E5        	push	ix
1004  7795 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1005  7798 B7           		or		a
1006  7799 CA 36 78             jp		z, HeadNotRead
1007  779C
1008  779C DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1009  779F DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1010  77A2 CA 36 78             jp		z, HeadNotRead
1011  77A5
1012  77A5 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1013  77A8 FE 00        		cp		PROG_TYPE
1014  77AA 20 0B        		jr		nz, CheckNoArr
1015  77AC
1016  77AC 21 1D 85     		ld		hl, MsgFileTypePrg
1017  77AF 11 13 85     		ld		de, MsgFileTypeN
1018  77B2 CD 7F 78     		call	MoveMsg
1019  77B5 18 4F        		jr		PrepFileLen
1020  77B7
1021  77B7              CheckNoArr:
1022  77B7 FE 01        		cp		NUMB_TYPE
1023  77B9 20 0B        		jr		nz, CheckChrArr
1024  77BB
1025  77BB 21 39 85     		ld		hl, MsgFileTypeNoA
1026  77BE 11 13 85     		ld		de, MsgFileTypeN
1027  77C1 CD 7F 78     		call	MoveMsg
1028  77C4 18 40        		jr		PrepFileLen
1029  77C6
1030  77C6              CheckChrArr:
1031  77C6 FE 02        		cp		CHAR_TYPE
1032  77C8 20 0B        		jr		nz, CheckByte
1033  77CA
1034  77CA 21 32 85     		ld		hl, MsgFileTypeChrA
1035  77CD 11 13 85     		ld		de, MsgFileTypeN
1036  77D0 CD 7F 78     		call	MoveMsg
1037  77D3 18 31        		jr		PrepFileLen
1038  77D5
1039  77D5              CheckByte:
1040  77D5 FE 03        		cp		BYTE_TYPE
1041  77D7 20 24        		jr		nz, CheckText
1042  77D9
1043  77D9 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1043  77DD 66 12
1044  77DF 01 00 E5     		ld		bc, -SCR_LEN
1045  77E2 09           		add		hl, bc
1046  77E3 7C           		ld		a, h
1047  77E4 B5           		or		l
1048  77E5 20 0B        		jr		nz, NotScr
1049  77E7
1050  77E7 21 2B 85     		ld		hl, MsgFileTypeSCR
1051  77EA 11 13 85     		ld		de, MsgFileTypeN
1052  77ED CD 7F 78     		call	MoveMsg
1053  77F0 18 14        		jr		PrepFileLen
1054  77F2              NotScr:
1055  77F2 21 24 85     		ld		hl, MsgFileTypeByte
1056  77F5 11 13 85     		ld		de, MsgFileTypeN
1057  77F8 CD 7F 78     		call	MoveMsg
1058  77FB 18 09        		jr		PrepFileLen
1059  77FD
1060  77FD              CheckText:
1061  77FD 21 40 85     		ld		hl, MsgFileTypeText
1062  7800 11 13 85     		ld		de, MsgFileTypeN
1063  7803 CD 7F 78     		call	MoveMsg
1064  7806
1065  7806              PrepFileLen:
1066  7806              		;File len
1067  7806 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1068  7809 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1069  780C              PrepFileLenText:
1070  780C 11 57 85     		ld		de, MsgFileLenN
1071  780F CD 6B 79     		call	Word2Txt
1072  7812 26 C2        		ld		h, 'B' | $80
1073  7814 2E 20        		ld		l, ' '
1074  7816 22 5C 85     		ld		(MsgFileLenN + 5), hl
1075  7819
1076  7819 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1077  781C FE 00        		cp		PROG_TYPE
1078  781E 28 06        		jr		z, PrintProgStart
1079  7820
1080  7820 FE 03        		cp		BYTE_TYPE
1081  7822 28 0A        		jr		z, PrintByteStart
1082  7824
1083  7824 18 22        		jr		PrintStartNotRead
1084  7826
1085  7826              PrintProgStart:
1086  7826 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1087  7829 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1088  782C 18 25        		jr		PrintStart
1089  782E
1090  782E              PrintByteStart:
1091  782E DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1092  7831 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1093  7834 18 1D        		jr		PrintStart
1094  7836
1095  7836              HeadNotRead:
1096  7836 21 47 85             ld        hl, MsgNA
1097  7839 11 13 85             ld        de, MsgFileTypeN
1098  783C CD 7F 78             call    MoveMsg
1099  783F
1100  783F 21 47 85     		ld		hl, MsgNA
1101  7842 11 57 85     		ld		de, MsgFileLenN
1102  7845 CD 7F 78     		call	MoveMsg
1103  7848
1104  7848              PrintStartNotRead:
1105  7848 21 47 85     		ld		hl, MsgNA
1106  784B 11 67 85     		ld		de, MsgFileStartN
1107  784E CD 7F 78     		call	MoveMsg
1108  7851 18 0E        		jr		PrintStartStr
1109  7853
1110  7853              PrintStart:
1111  7853 1E 20        	ld		e, ' '
1112  7855 16 A0        	ld		d, ' ' | $80
1113  7857 ED 53 6C 85  	ld		(MsgFileStartN + 5), de
1114  785B 11 67 85     	ld		de, MsgFileStartN
1115  785E CD 6B 79     	call	Word2Txt
1116  7861              PrintStartStr:
1117  7861 11 00 0E     	ld		de, LST_FILE_INFO + 4 << 8
1118  7864 21 5E 85     	ld		hl, MsgFileStart
1119  7867 CD D3 7E     	call	PrintStr
1120  786A
1121  786A DD E1        	pop		ix
1122  786C 11 00 0D     	ld		de, LST_FILE_INFO + 3 << 8
1123  786F 21 0A 85     	ld		hl, MsgFileType
1124  7872 CD D3 7E     	call	PrintStr
1125  7875
1126  7875 11 00 0F     	ld		de, LST_FILE_INFO + 5 << 8
1127  7878 21 4E 85     	ld		hl, MsgFileLen
1128  787B CD D3 7E     	call	PrintStr
1129  787E
1130  787E C9           	ret
1131  787F
1132  787F              MoveMsg:
1133  787F 01 07 00     	ld		bc, 7
1134  7882 ED B0        	ldir
1135  7884 C9           	ret
1136  7885
1137  7885              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1138  7885
1139  7885              ReadAllHeaders:
1140  7885 21 6E 85     	ld		hl, MsgReadingExt
1141  7888 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
1142  788B 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1143  788D CD FB 7E     	call	PrintStrClr
1144  7890
1145  7890 CD 8E 72     	call	CalcFileCache
1146  7893
1147  7893 3A 3D 86     	ld		a, (SelFile)
1148  7896 47           	ld		b, a
1149  7897 3A 3B 86     	ld		a, (FileCnt)
1150  789A 90           	sub		b
1151  789B B7           	or		a
1152  789C C8           	ret		z
1153  789D
1154  789D 47           	ld		b, a
1155  789E
1156  789E DD 2A 42 86  	ld		ix, (SelFileCache)
1157  78A2              NextFile:
1158  78A2 C5           	push	bc
1159  78A3 CD 07 7C     		call	ReadFileHeader
1160  78A6 01 19 00     		ld		bc, CACHE_SZ
1161  78A9 DD 09        		add		ix, bc
1162  78AB DD E5        		push	ix
1163  78AD CD 8E 72     			call	CalcFileCache
1164  78B0 CD 13 77     			call	DisplayFileInfo
1165  78B3 DD E1        		pop		ix
1166  78B5
1167  78B5 CD 9A 7E     		call	KbdHit
1168  78B8 38 03        		jr		c, AKey
1169  78BA C1           	pop		bc
1170  78BB 18 15        	jr		ReadAllHeadersEnd
1171  78BD
1172  78BD              AKey:
1173  78BD 3A 3D 86     		ld		a, (SelFile)
1174  78C0 3C           		inc		a
1175  78C1 47           		ld		b, a
1176  78C2 3A 3B 86     		ld		a, (FileCnt)
1177  78C5 B8           		cp		b
1178  78C6 28 16        		jr		z, DontInc
1179  78C8 78           		ld		a, b
1180  78C9 32 3D 86     		ld		(SelFile), a
1181  78CC CD 9E 7F     		call	MoveCursor
1182  78CF C1           	pop		bc
1183  78D0 10 D0        	djnz	NextFile
1184  78D2
1185  78D2              ReadAllHeadersEnd:
1186  78D2 21 7C 85     	ld		hl, MsgClear
1187  78D5 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
1188  78D8 3E 0F        	ld		a, SCR_DEF_CLR
1189  78DA CD FB 7E     	call	PrintStrClr
1190  78DD C9           	ret
1191  78DE
1192  78DE              DontInc:
1193  78DE C1           	pop		bc
1194  78DF 18 F1        	jr		ReadAllHeadersEnd
1195  78E1
1196  78E1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1197  78E1              ;Will report HC version based on copyright string. For HC2000 will report v1/v2. For IF1 will report v1/v2.
1198  78E1              ;Versions:
1199  78E1              ;"HC - 85", 6, 32, 32, 32, 32, "I.C.E FELIX"
1200  78E1              ;"HC - 90", 6, 32, 32, 32, 32, "I.C.E FELIX"
1201  78E1              ;"HC - 91", 6, 32, 32, 32, 32, "I.C.E FELIX"
1202  78E1              ;"HC2000 ICE FELIX COMPUTER SA" - v1
1203  78E1              ;"HC2000", 6, 32, 32, 32, 32, "I.C.E FELIX" - v2
1204  78E1              PrintIntro:
1205  78E1 21 AE 83     	ld		hl, VerMsg1
1206  78E4 11 00 01     	ld		de, LST_PROG_INFO + 1 << 8
1207  78E7 CD D3 7E     	call	PrintStr
1208  78EA 21 BE 83     	ld		hl, VerMsg2
1209  78ED 11 00 02     	ld		de, LST_PROG_INFO + 2 << 8
1210  78F0 CD D3 7E     	call	PrintStr
1211  78F3 21 CE 83     	ld		hl, VerMsg3
1212  78F6 11 00 03     	ld		de, LST_PROG_INFO + 3 << 8
1213  78F9 CD D3 7E     	call	PrintStr
1214  78FC
1215  78FC 21 39 15     	ld		hl, STR_MSG_BASIC
1216  78FF 11 F5 83     	ld		de, MsgCompModelName
1217  7902 06 07        	ld		b, 7
1218  7904              PrintComputerInfoLoop:
1219  7904 7E           	ld		a, (hl)
1220  7905 FE 20        	cp		' '
1221  7907 28 02        	jr		z, PrintComputerInfoSkip
1222  7909 12           	ld		(de), a
1223  790A 13           	inc		de
1224  790B              PrintComputerInfoSkip:
1225  790B 23           	inc		hl
1226  790C 10 F6        	djnz	PrintComputerInfoLoop
1227  790E
1228  790E 3A 3B 15     	ld		a, (STR_MSG_BASIC + 2)
1229  7911 FE 32        	cp		'2'
1230  7913 20 1E        	jr		nz, PrintComputerInfoIF1
1231  7915
1232  7915              	;HC2000
1233  7915 3E 20        	ld		a, ' '
1234  7917 12           	ld		(de), a
1235  7918 13           	inc		de
1236  7919 3E 76        	ld		a, 'v'
1237  791B 12           	ld		(de), a
1238  791C 13           	inc		de
1239  791D
1240  791D 7E           	ld		a, (hl)
1241  791E FE 49        	cp		'I'
1242  7920 28 04        	jr		z, HC2000v1
1243  7922 3E B2        	ld		a, '2' | $80
1244  7924 18 02        	jr		HC2000Store
1245  7926              HC2000v1:
1246  7926 3E B1        	ld		a, '1' | $80
1247  7928              HC2000Store:
1248  7928 12           	ld		(de), a
1249  7929 13           	inc		de
1250  792A              	;Patch code to look for HC2000 IF1 string at a different address.
1251  792A 21 3E 79     	ld		hl, GetIF1String+1
1252  792D 11 F0 27     	ld		de, STR_MSG_IF1_2000
1253  7930 73           	ld		(hl), e
1254  7931 23           	inc		hl
1255  7932 72           	ld		(hl), d
1256  7933
1257  7933              PrintComputerInfoIF1:
1258  7933 21 3D 79     	ld		hl, GetIF1String
1259  7936 11 58 79     	ld		de, PrintCompInfo
1260  7939 D5           	push	de
1261  793A C3 68 7C     	jp		IF1Call
1262  793D
1263  793D              GetIF1String:
1264  793D 21 F0 23     	ld		hl, STR_MSG_IF1_91
1265  7940 11 05 84     	ld		de, MsgIF1Date
1266  7943 3E 2E        	ld		a, '.'
1267  7945              GetIF1StringLoop:
1268  7945 ED A0        	ldi
1269  7947 ED A0        	ldi
1270  7949 12           	ld		(de), a
1271  794A 13           	inc		de
1272  794B ED A0        	ldi
1273  794D ED A0        	ldi
1274  794F 12           	ld		(de), a
1275  7950 13           	inc		de
1276  7951 ED A0        	ldi
1277  7953 7E           	ld		a, (hl)
1278  7954 F6 80        	or		$80
1279  7956 12           	ld		(de), a
1280  7957 C9           	ret
1281  7958
1282  7958              PrintCompInfo:
1283  7958 21 EE 83     	ld		hl, MsgCompModel
1284  795B 11 00 04     	ld		de, LST_PROG_INFO + 4 << 8
1285  795E CD D3 7E     	call	PrintStr
1286  7961
1287  7961 21 FE 83     	ld		hl, MsgIF1Version
1288  7964 11 00 05     	ld		de, LST_PROG_INFO + 5 << 8
1289  7967 CD D3 7E     	call	PrintStr
1290  796A
1291  796A C9           	ret
1292  796B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1293  796B
1294  796B              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 796B              	ifndef	_HCCFG_
   2+ 796B              	define	_HCCFG_
   3+ 796B
   4+ 796B              ;HC specific code, for configuration
   5+ 796B
   6+ 796B              HC_CFG_PORT			EQU	$7E
   7+ 796B
   8+ 796B              ;BASIC/CPM ROM selection
   9+ 796B              HC_CFG_ROM_BAS		EQU	%0
  10+ 796B              HC_CFG_ROM_CPM		EQU	%1
  11+ 796B
  12+ 796B              ;Address for ROM paging: 0 or $E000
  13+ 796B              HC_CFG_ROM_0000		EQU %00
  14+ 796B              HC_CFG_ROM_E000		EQU %10
  15+ 796B
  16+ 796B              ;Cfg. port Enable/Disable
  17+ 796B              HC_CFG_PORT_DIS		EQU %000
  18+ 796B              HC_CFG_PORT_EN		EQU	%100
  19+ 796B
  20+ 796B              ;Video memory bank: $4000 or $C000
  21+ 796B              HC_CFG_VID_4000		EQU	%0000
  22+ 796B              HC_CFG_VID_C000		EQU	%1000
  23+ 796B
  24+ 796B
  25+ 796B              ;Standar BASIC config
  26+ 796B              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 796B              ;Standar CP/M config
  28+ 796B              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 796B
  30+ 796B
  31+ 796B              HC_VID_BANK0		EQU	$4000
  32+ 796B              HC_VID_BANK1		EQU	$C000
  33+ 796B
  34+ 796B              	endif
# file closed: hccfg.asm
1295  796B              	include "disk.asm"
# file opened: disk.asm
   1+ 796B              ;HC IF1 routines and constants
   2+ 796B
   3+ 796B              ;IF1 routines error codes, also returned by BASIC commands
   4+ 796B              ;12 = Writing to a 'read' file
   5+ 796B              ;13 = Reading a 'write' file
   6+ 796B              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 796B              ;15 = Disk full (disk or catalog full)
   8+ 796B              ;16 = Disk error (hardware error)
   9+ 796B              ;17 = File not found
  10+ 796B              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 796B              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 796B
  13+ 796B              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 796B              ;00h = OK
  15+ 796B              ;08h = cannot format disk
  16+ 796B              ;10h = disk protected (read-only?)
  17+ 796B              ;20h = volume error
  18+ 796B              ;40h = drive error
  19+ 796B              ;80h = reading error
  20+ 796B              ;Codes I encountered:
  21+ 796B              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 796B
  23+ 796B
  24+ 796B              	ifndef	_DISK_
  25+ 796B              	define	_DISK_
  26+ 796B
  27+ 796B              	include	"math.asm"
# file opened: math.asm
   1++796B              	ifndef	_MATH_
   2++796B              	define	_MATH_
   3++796B
   4++796B              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++796B              ;http://map.tni.nl/sources/external/z80bits.html
   6++796B
   7++796B
   8++796B              Word2Txt:
   9++796B              	IFUSED
  10++796B D5           	push	de
  11++796C CD 8C 79     		call	Word2Txt_
  12++796F D1           	pop		de
  13++7970
  14++7970 06 04        	ld		b, 4
  15++7972 CD 81 79     	call	StrippLeading0
  16++7975 C9           	ret
  17++7976
  18++7976              Byte2Txt:
  19++7976 D5           	push	de
  20++7977 CD 98 79     		call	Byte2Txt_
  21++797A D1           	pop		de
  22++797B
  23++797B 06 02        	ld		b, 2
  24++797D CD 81 79     	call	StrippLeading0
  25++7980 C9           	ret
  26++7981              	ENDIF
  27++7981
  28++7981
  29++7981              StrippLeading0:
  30++7981 1A           	ld		a, (de)
  31++7982 FE 31        	cp		'1'
  32++7984 D0           	ret		nc
  33++7985
  34++7985 3E 20        	ld		a, ' '
  35++7987 12           	ld		(de), a
  36++7988 13           	inc		de
  37++7989 10 F6        	djnz	StrippLeading0
  38++798B C9           	ret
  39++798C
  40++798C
  41++798C              ;Converts the number in HL to ASCII in decimal string at DE
  42++798C              Word2Txt_:
  43++798C 01 F0 D8     	ld bc, -10000
  44++798F CD A7 79     	call DigitLoop
  45++7992 01 18 FC     	ld bc, -1000
  46++7995 CD A7 79     	call DigitLoop
  47++7998              Byte2Txt_:
  48++7998 01 9C FF     	ld bc, -100
  49++799B CD A7 79     	call DigitLoop
  50++799E 01 F6 FF     	ld bc, -10
  51++79A1 CD A7 79     	call DigitLoop
  52++79A4 01 FF FF     	ld bc, -1
  53++79A7
  54++79A7              DigitLoop:
  55++79A7 3E 2F        	ld	a, '0' - 1
  56++79A9              DivNrLoop:
  57++79A9 3C           	inc	a			;increase reminder
  58++79AA 09           	add	hl, bc		;substract divizor
  59++79AB 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++79AD ED 42        	sbc	hl, bc		;nope, restore
  61++79AF
  62++79AF 12           	ld (de), a
  63++79B0 13           	inc de
  64++79B1 C9           	ret
  65++79B2
  66++79B2
  67++79B2              ;Input: HL = Dividend, C = Divisor
  68++79B2              ;Output: HL = Quotient, A = Remainder
  69++79B2              ;Warning: doesn't work with divisor >= $80
  70++79B2              Div:
  71++79B2              	IFUSED
  72++79B2 AF           	xor a
  73++79B3 06 10        	ld b, 16
  74++79B5
  75++79B5              DivLoop:
  76++79B5 29           	add	hl,hl
  77++79B6 17           	rla
  78++79B7 B9           	cp	c
  79++79B8 38 02        	jr	c, NoSub
  80++79BA 91           	sub	c
  81++79BB 2C           	inc	l
  82++79BC              NoSub:
  83++79BC 10 F7        	djnz DivLoop
  84++79BE
  85++79BE C9           	ret
  86++79BF              	ENDIF
  87++79BF
  88++79BF              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++79BF              ;Output: A:C = Quotient, HL = Remainder
  90++79BF              Div2:
  91++79BF 21 00 00     	ld hl, 0
  92++79C2 06 10        	ld b, 16
  93++79C4              Div2Loop:
  94++79C4 CB 31        	sll c		; unroll 16 times
  95++79C6 17           	rla			; ...
  96++79C7 ED 6A        	adc	hl,hl		; ...
  97++79C9 ED 52        	sbc	hl,de		; ...
  98++79CB 30 02        	jr	nc,$+4		; ...
  99++79CD 19           	add	hl,de		; ...
 100++79CE 0D           	dec	c		; ...
 101++79CF 10 F3        	djnz Div2Loop
 102++79D1 C9           	ret
 103++79D2
 104++79D2
 105++79D2              ;Input: A = Multiplier, DE = Multiplicand
 106++79D2              ;Output: A:HL = Product
 107++79D2              Mul:
 108++79D2              	IFUSED
 109++79D2 21 00 00     	ld hl, 0
 110++79D5 01 00 07     	ld bc, $0700
 111++79D8
 112++79D8 87           	add	a, a		; optimised 1st iteration
 113++79D9 30 02        	jr	nc, MulLoop
 114++79DB 62           	ld	h, d
 115++79DC 6B           	ld	l, e
 116++79DD
 117++79DD              MulLoop:
 118++79DD 29           	add	hl,hl
 119++79DE 17           	rla
 120++79DF 30 02        	jr	nc, NoAdd
 121++79E1 19           	add	hl,de
 122++79E2 89           	adc	a,c
 123++79E3              NoAdd:
 124++79E3 10 F8        	djnz MulLoop
 125++79E5
 126++79E5 C9           	ret
 127++79E6              	ENDIF
 128++79E6
 129++79E6              	endif
# file closed: math.asm
  28+ 79E6
  29+ 79E6              DRIVE_CUR_BAS	EQU 0
  30+ 79E6              DRIVE_A_BAS		EQU	1
  31+ 79E6              DRIVE_B_BAS		EQU	2
  32+ 79E6              DRIVE_A_CPM		EQU	0
  33+ 79E6              DRIVE_B_CPM		EQU	1
  34+ 79E6              ;Disk geometry stuff
  35+ 79E6              SPT				EQU	16			;sectors per track
  36+ 79E6              SECT_SZ			EQU	256			;sector size in bytes
  37+ 79E6              TRACK_CNT		EQU	80			;track count
  38+ 79E6              HEAD_CNT		EQU	2			;disk face count
  39+ 79E6              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 79E6              EXT_SZ			EQU	32			;directory entry size
  41+ 79E6              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 79E6              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 79E6              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 79E6              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 79E6              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 79E6              REC_SZ			EQU 128			;cp/m record size
  47+ 79E6              DEL_MARKER		EQU	$E5
  48+ 79E6
  49+ 79E6
  50+ 79E6              ;Extension structure (directory entry)
  51+ 79E6              EXT_DEL_FLAG	EQU	0
  52+ 79E6              EXT_NAME		EQU 1
  53+ 79E6              EXT_IDX			EQU 12
  54+ 79E6              EXT_S1			EQU 13
  55+ 79E6              EXT_S2			EQU 14
  56+ 79E6              EXT_RC			EQU	15
  57+ 79E6              EXT_AU0			EQU	16
  58+ 79E6              EXT_AU1			EQU	18
  59+ 79E6              EXT_AU2			EQU	20
  60+ 79E6              EXT_AU3			EQU	22
  61+ 79E6              EXT_AU4			EQU	24
  62+ 79E6              EXT_AU5			EQU	26
  63+ 79E6              EXT_AU6			EQU	28
  64+ 79E6              EXT_AU7			EQU	30
  65+ 79E6              EXT_SIZE		EQU 32
  66+ 79E6
  67+ 79E6              ;FCB structure
  68+ 79E6              FCB_DRIVE		EQU 0
  69+ 79E6              FCB_NAME		EQU EXT_NAME
  70+ 79E6              FCB_EX_IDX		EQU EXT_IDX
  71+ 79E6              FCB_S1			EQU EXT_S1
  72+ 79E6              FCB_S2			EQU EXT_S2
  73+ 79E6              FCB_RC			EQU	EXT_RC
  74+ 79E6              FCB_AU			EQU	EXT_AU0
  75+ 79E6              FCB_CR			EQU	32
  76+ 79E6              FCB_R0			EQU 33
  77+ 79E6              FCB_R1			EQU 34
  78+ 79E6              FCB_R2			EQU 35
  79+ 79E6              FCB_SIZE		EQU 36
  80+ 79E6
  81+ 79E6
  82+ 79E6
  83+ 79E6              ;System variables for disk
  84+ 79E6              DSTR1			EQU	$5CD6		;drive
  85+ 79E6              FSTR1			EQU	$5CDC		;file name
  86+ 79E6              NSTR1			EQU	$5CDA		;name length
  87+ 79E6              HD11			EQU	$5CED		;BDOS argument
  88+ 79E6              COPIES			EQU	$5CEF		;BDOS function
  89+ 79E6
  90+ 79E6              ERRSP			EQU $5C3D
  91+ 79E6              ERRNR			EQU $5C3A
  92+ 79E6              ERRMSG			EQU	$0260
  93+ 79E6
  94+ 79E6              PROG			EQU $5C53
  95+ 79E6              VARS			EQU	$5C4B
  96+ 79E6              STKEND			EQU	$5C65
  97+ 79E6
  98+ 79E6              PRN_BUF			EQU	23296
  99+ 79E6
 100+ 79E6              STR_MSG_BASIC	EQU	$1539
 101+ 79E6              STR_MSG_BASIC_LEN EQU 32
 102+ 79E6              STR_MSG_IF1_2000	EQU $27F0
 103+ 79E6              STR_MSG_IF1_91		EQU $23F0
 104+ 79E6              STR_MSG_IF1_LEN EQU 31
 105+ 79E6
 106+ 79E6              REPDEL			EQU	23561
 107+ 79E6              REPPER			EQU	23562
 108+ 79E6              PIP				EQU	23609
 109+ 79E6
 110+ 79E6
 111+ 79E6              ;RWTS routine commands
 112+ 79E6              RWTS_CMD_POS	EQU	0			;position head
 113+ 79E6              RWTS_CMD_READ	EQU	1			;read sector
 114+ 79E6              RWTS_CMD_WRITE	EQU	2			;write sector
 115+ 79E6              RWTS_CMD_FMT	EQU	4			;format all tracks
 116+ 79E6
 117+ 79E6
 118+ 79E6              ;File name stuff
 119+ 79E6              NAMELEN			EQU	11			;name length
 120+ 79E6              RO_POS			EQU	8			;read-only attribute position in name
 121+ 79E6              SYS_POS			EQU	9			;system attribute position in name
 122+ 79E6
 123+ 79E6              ;File types (first byte in header)
 124+ 79E6              PROG_TYPE		EQU	0			;program
 125+ 79E6              NUMB_TYPE		EQU	1			;number array
 126+ 79E6              CHAR_TYPE		EQU	2			;char array
 127+ 79E6              BYTE_TYPE		EQU	3			;bytes
 128+ 79E6              TEXT_TYPE		EQU	4			;text, >= 4
 129+ 79E6
 130+ 79E6              ;File header offsets
 131+ 79E6              HDR_TYPE		EQU	0
 132+ 79E6              HDR_LEN			EQU 1
 133+ 79E6              HDR_ADDR		EQU 3
 134+ 79E6              HDR_PLEN		EQU	5
 135+ 79E6              HDR_LINE		EQU 7
 136+ 79E6              HDR_SZ			EQU	9
 137+ 79E6
 138+ 79E6              ;BASIC disk channel structure
 139+ 79E6              CH_RW_FLAG		EQU 11
 140+ 79E6              CH_FCB			EQU	12
 141+ 79E6              CH_DATA			EQU	50
 142+ 79E6              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143+ 79E6
 144+ 79E6              CACHE_NAME		EQU	0					;11B
 145+ 79E6              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146+ 79E6              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147+ 79E6              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148+ 79E6              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149+ 79E6              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150+ 79E6
 151+ 79E6              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152+ 79E6
 153+ 79E6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154+ 79E6              IF1Init:
 155+ 79E6 CF           	rst		08
 156+ 79E7 31           	defb	49		;create system variables
 157+ 79E8 C9           	ret
 158+ 79E9
 159+ 79E9              ;ReadWriteTrackSector
 160+ 79E9              ;A=command: 0, 1, 2, 4
 161+ 79E9              RWTS:
 162+ 79E9 32 C3 7C     	ld (RWTSCmd), a
 163+ 79EC 21 B8 7C     	ld hl, RWTSParams
 164+ 79EF 22 ED 5C     	ld (HD11), hl
 165+ 79F2 CF           	rst 08
 166+ 79F3 3A           	DEFB 58
 167+ 79F4 C9           	ret
 168+ 79F5
 169+ 79F5
 170+ 79F5              ;D = sector, E = track
 171+ 79F5              ;HL = dma
 172+ 79F5              ReadOneDiskSector:
 173+ 79F5 22 BD 7C     	ld (RWTSDMA), hl
 174+ 79F8 ED 53 BB 7C  	ld (RWTSTrack), de
 175+ 79FC              	;ld (RWTSDrive), a
 176+ 79FC 3E 01        	ld a, RWTS_CMD_READ
 177+ 79FE 18 E9        	jr	RWTS
 178+ 7A00
 179+ 7A00              ;D = sector, E = track
 180+ 7A00              ;HL = dma
 181+ 7A00              WriteOneDiskSector:
 182+ 7A00 22 BD 7C     	ld (RWTSDMA), hl
 183+ 7A03 ED 53 BB 7C  	ld (RWTSTrack), de
 184+ 7A07              	;ld (RWTSDrive), a
 185+ 7A07 3E 02        	ld a, RWTS_CMD_WRITE
 186+ 7A09 18 DE        	jr	RWTS
 187+ 7A0B
 188+ 7A0B              FormatDisk:
 189+ 7A0B 21 2A 95     	ld		hl, DataBuf
 190+ 7A0E 36 E5        	ld		(hl), DEL_MARKER
 191+ 7A10 22 BD 7C     	ld 		(RWTSDMA), hl
 192+ 7A13 3E 04        	ld 		a, RWTS_CMD_FMT
 193+ 7A15 CD E9 79     	call	RWTS
 194+ 7A18 3A C4 7C     	ld		a, (RWTSRes)
 195+ 7A1B C9           	ret
 196+ 7A1C
 197+ 7A1C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198+ 7A1C
 199+ 7A1C              ;Allocation unit no. to track/sector
 200+ 7A1C              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201+ 7A1C              ;IN:  HL=alloc. unit no.
 202+ 7A1C              ;OUT: B=sector; C=track (head is determined by the sector number)
 203+ 7A1C              AU2TS:
 204+ 7A1C 0E 02        	ld c, SPT/SPAL
 205+ 7A1E CD B2 79     	call Div					;A = sector
 206+ 7A21 F5           	push af
 207+ 7A22 ~            		/*
 208+ 7A22 ~            		ld c, HEAD_CNT
 209+ 7A22 ~            		call Div				;L = track, A = head (0 or 1)
 210+ 7A22 ~            		*/
 211+ 7A22 AF           		xor a
 212+ 7A23 CB 1C        		rr h
 213+ 7A25 CB 1D        		rr l
 214+ 7A27 CB 1F        		rr a
 215+ 7A29
 216+ 7A29 4D           		ld c, l
 217+ 7A2A 06 00        		ld b, 0
 218+ 7A2C B7           		or a
 219+ 7A2D 28 02        		jr z, Track0
 220+ 7A2F 06 10        		ld b, SPT
 221+ 7A31              Track0:
 222+ 7A31 F1           	pop af
 223+ 7A32 B7           	or a
 224+ 7A33 28 02        	jr z, FirstAU
 225+ 7A35 3E 08        	ld a, SPAL
 226+ 7A37              FirstAU:
 227+ 7A37 80           	add a, b
 228+ 7A38 47           	ld  b, a
 229+ 7A39 C9           	ret
 230+ 7A3A
 231+ 7A3A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232+ 7A3A
 233+ 7A3A              ;Checks the allocation units number used in extension
 234+ 7A3A              ;IN:	IX = extension addr
 235+ 7A3A              ;OUT:	B = no. of allocation units used
 236+ 7A3A              ;		C = no. of records used in ext.
 237+ 7A3A              ;		HL = first alloc. unit no.
 238+ 7A3A              ;		DE = last alloc. unit no.
 239+ 7A3A              CheckExtAlloc:
 240+ 7A3A DD E5        	push ix
 241+ 7A3C 01 0F 00     		ld bc, EXT_RC
 242+ 7A3F DD 09        		add ix, bc
 243+ 7A41 DD 4E 00     		ld c, (ix)			;save rec. no.
 244+ 7A44 DD 23        		inc ix
 245+ 7A46 DD 6E 00     		ld l, (ix)
 246+ 7A49 DD 66 01     		ld h, (ix + 1)
 247+ 7A4C 06 08        		ld b, EXT_AU_CNT
 248+ 7A4E              CheckAU:
 249+ 7A4E DD 7E 00     		ld a, (ix)
 250+ 7A51 DD B6 01     		or (ix + 1)
 251+ 7A54 28 0C        		jr z, CheckAUEnd
 252+ 7A56 DD 5E 00     		ld e, (ix)
 253+ 7A59 DD 56 01     		ld d, (ix + 1)
 254+ 7A5C DD 23        		inc ix
 255+ 7A5E DD 23        		inc ix
 256+ 7A60 10 EC        		djnz CheckAU
 257+ 7A62              CheckAUEnd:
 258+ 7A62 3E 08        		ld a, EXT_AU_CNT
 259+ 7A64 90           		sub b
 260+ 7A65 47           		ld b, a
 261+ 7A66 DD E1        	pop ix
 262+ 7A68 C9           	ret
 263+ 7A69
 264+ 7A69              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265+ 7A69
 266+ 7A69              ;Input: TrackBuffer
 267+ 7A69              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268+ 7A69              ReadUsedBlocksList:
 269+ 7A69 DD 21 2A 95  	ld		ix, TrackBuf			;source buffer
 270+ 7A6D 21 40 8F     	ld		hl, UsedBlockListCnt 	;destination buffer
 271+ 7A70 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272+ 7A73 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 273+ 7A76 73           	ld		(hl), e
 274+ 7A77 23           	inc		hl
 275+ 7A78 72           	ld		(hl), d
 276+ 7A79 23           	inc		hl
 277+ 7A7A
 278+ 7A7A              	;Add blocks 0 and 1 for directory
 279+ 7A7A 11 00 00     	ld		de, 0
 280+ 7A7D 73           	ld		(hl), e
 281+ 7A7E 23           	inc		hl
 282+ 7A7F 72           	ld		(hl), d
 283+ 7A80 23           	inc		hl
 284+ 7A81
 285+ 7A81 13           	inc		de
 286+ 7A82 73           	ld		(hl), e
 287+ 7A83 23           	inc		hl
 288+ 7A84 72           	ld		(hl), d
 289+ 7A85 23           	inc		hl
 290+ 7A86
 291+ 7A86              ReadUsedBlocksLoop:
 292+ 7A86 AF           	xor		a
 293+ 7A87 DD BE 00     	cp		(ix)
 294+ 7A8A 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295+ 7A8C
 296+ 7A8C DD E5        	push	ix
 297+ 7A8E C5           	push	bc
 298+ 7A8F 06 08        		ld		b, EXT_AU_CNT
 299+ 7A91 11 10 00     		ld		de, EXT_AU0
 300+ 7A94 DD 19        		add		ix, de
 301+ 7A96
 302+ 7A96              ReadUsedBlocksLoop2:
 303+ 7A96 DD 5E 00     		ld		e, (ix)
 304+ 7A99 DD 56 01     		ld		d, (ix+1)
 305+ 7A9C 7B           		ld		a, e
 306+ 7A9D B2           		or		d
 307+ 7A9E 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308+ 7AA0
 309+ 7AA0 73           		ld		(hl), e
 310+ 7AA1 23           		inc		hl
 311+ 7AA2 72           		ld		(hl), d
 312+ 7AA3 23           		inc		hl
 313+ 7AA4
 314+ 7AA4 DD 23        		inc		ix
 315+ 7AA6 DD 23        		inc		ix
 316+ 7AA8
 317+ 7AA8 ED 5B 40 8F  		ld		de, (UsedBlockListCnt)
 318+ 7AAC 13           		inc		de
 319+ 7AAD ED 53 40 8F  		ld		(UsedBlockListCnt), de
 320+ 7AB1
 321+ 7AB1 10 E3        		djnz	ReadUsedBlocksLoop2
 322+ 7AB3
 323+ 7AB3
 324+ 7AB3              ReadUsedBlocksSkip:
 325+ 7AB3 C1           	pop		bc
 326+ 7AB4 DD E1        	pop		ix
 327+ 7AB6              ReadUsedBlocksSkip2:
 328+ 7AB6 11 20 00     	ld		de, EXT_SZ
 329+ 7AB9 DD 19        	add		ix, de
 330+ 7ABB
 331+ 7ABB 0B           	dec		bc
 332+ 7ABC 78           	ld		a, b
 333+ 7ABD B1           	or		c
 334+ 7ABE 20 C6        	jr		nz, ReadUsedBlocksLoop
 335+ 7AC0
 336+ 7AC0 C9           	ret
 337+ 7AC1
 338+ 7AC1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339+ 7AC1              ;Reads 8 sectors for an AU
 340+ 7AC1              ;HL = block number, DE = destination buffer
 341+ 7AC1              ReadFSBlock:
 342+ 7AC1 D5           	push	de
 343+ 7AC2 CD 1C 7A     		call	AU2TS		;B=sector, C=track
 344+ 7AC5 E1           	pop		hl				;HL=dest
 345+ 7AC6
 346+ 7AC6 50           	ld		d, b
 347+ 7AC7 59           	ld		e, c
 348+ 7AC8 06 08        	ld		b, SPAL
 349+ 7ACA
 350+ 7ACA              ReadFSBlockLoop:
 351+ 7ACA CD B7 7B     	call	ReadDiskSectors
 352+ 7ACD C9           	ret
 353+ 7ACE
 354+ 7ACE
 355+ 7ACE              ;Write 8 sectors for an AU
 356+ 7ACE              ;HL = block number, DE = source buffer
 357+ 7ACE              WriteFSBlock:
 358+ 7ACE D5           	push	de
 359+ 7ACF CD 1C 7A     		call	AU2TS		;B=sector, C=track
 360+ 7AD2 E1           	pop		hl				;HL=dest
 361+ 7AD3
 362+ 7AD3 50           	ld		d, b
 363+ 7AD4 59           	ld		e, c
 364+ 7AD5 06 08        	ld		b, SPAL
 365+ 7AD7
 366+ 7AD7              WriteFSBlockLoop:
 367+ 7AD7 CD CA 7B     	call	WriteDiskSectors
 368+ 7ADA C9           	ret
 369+ 7ADB
 370+ 7ADB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371+ 7ADB              ;Copies the allocated blocks from one disk to another.
 372+ 7ADB              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373+ 7ADB              CopyDisk:
 374+ 7ADB              	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 375+ 7ADB CD 69 7A     	call	ReadUsedBlocksList
 376+ 7ADE DD 21 42 8F  	ld		ix, UsedBlockListBlk
 377+ 7AE2
 378+ 7AE2              CopyDiskLoop:
 379+ 7AE2 2A 40 8F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380+ 7AE5 11 0C 86     	ld		de, MsgBlocksLeft
 381+ 7AE8 CD 76 79     	call	Byte2Txt
 382+ 7AEB 21 0C 86     	ld		hl, MsgBlocksLeft
 383+ 7AEE 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 384+ 7AF1 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 385+ 7AF3 CD FB 7E     	call	PrintStrClr
 386+ 7AF6
 387+ 7AF6              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388+ 7AF6 21 0D 00     	ld		hl, MAX_AU_RAM
 389+ 7AF9 ED 4B 40 8F  	ld		bc, (UsedBlockListCnt)
 390+ 7AFD B7           	or		a
 391+ 7AFE ED 42        	sbc		hl, bc
 392+ 7B00 30 03        	jr		nc, CopyDiskLoopRead
 393+ 7B02 01 0D 00     	ld		bc, MAX_AU_RAM
 394+ 7B05
 395+ 7B05              CopyDiskLoopRead:
 396+ 7B05 41           	ld		b, c
 397+ 7B06 11 2A 95     	ld		de, CopyDiskBuf
 398+ 7B09              	;save initial counter and initial block number array position
 399+ 7B09 C5           	push	bc
 400+ 7B0A DD E5        	push	ix
 401+ 7B0C
 402+ 7B0C              CopyDiskLoopReadLoop:
 403+ 7B0C DD 6E 00     		ld		l, (ix)
 404+ 7B0F DD 66 01     		ld		h, (ix+1)
 405+ 7B12 DD 23        		inc		ix
 406+ 7B14 DD 23        		inc		ix
 407+ 7B16
 408+ 7B16 D5           		push	de
 409+ 7B17 C5           		push	bc
 410+ 7B18 CD C1 7A     			call	ReadFSBlock			;Stop on error or continue?
 411+ 7B1B C1           		pop		bc
 412+ 7B1C D1           		pop		de
 413+ 7B1D
 414+ 7B1D              		;+2048
 415+ 7B1D 7A           		ld		a, d
 416+ 7B1E C6 08        		add		8
 417+ 7B20 57           		ld		d, a
 418+ 7B21
 419+ 7B21 10 E9        		djnz	CopyDiskLoopReadLoop
 420+ 7B23
 421+ 7B23              		;alternate drive
 422+ 7B23 3A B9 7C     		ld		a, (RWTSDrive)
 423+ 7B26 EE 03        		xor		%11
 424+ 7B28 32 B9 7C     		ld		(RWTSDrive), a
 425+ 7B2B
 426+ 7B2B              	;restore initial counter and initial block number array position
 427+ 7B2B DD E1        	pop		ix
 428+ 7B2D C1           	pop		bc
 429+ 7B2E 11 2A 95     	ld		de, CopyDiskBuf
 430+ 7B31 C5           	push	bc
 431+ 7B32
 432+ 7B32              CopyDiskLoopWriteLoop:
 433+ 7B32 DD 6E 00     		ld		l, (ix)
 434+ 7B35 DD 66 01     		ld		h, (ix+1)
 435+ 7B38 DD 23        		inc		ix
 436+ 7B3A DD 23        		inc		ix
 437+ 7B3C
 438+ 7B3C D5           		push	de
 439+ 7B3D C5           		push	bc
 440+ 7B3E CD CE 7A     			call	WriteFSBlock		;Stop on error or continue?
 441+ 7B41 C1           		pop		bc
 442+ 7B42 D1           		pop		de
 443+ 7B43
 444+ 7B43              		;+2048
 445+ 7B43 7A           		ld		a, d
 446+ 7B44 C6 08        		add		8
 447+ 7B46 57           		ld		d, a
 448+ 7B47
 449+ 7B47 10 E9        		djnz	CopyDiskLoopWriteLoop
 450+ 7B49
 451+ 7B49              		;alternate drive again
 452+ 7B49 3A B9 7C     		ld		a, (RWTSDrive)
 453+ 7B4C EE 03        		xor		%11
 454+ 7B4E 32 B9 7C     		ld		(RWTSDrive), a
 455+ 7B51
 456+ 7B51 C1           	pop		bc
 457+ 7B52 48           	ld		c, b
 458+ 7B53 06 00        	ld		b, 0
 459+ 7B55
 460+ 7B55              	;Decrease number of blocks read by now.
 461+ 7B55 2A 40 8F     	ld		hl, (UsedBlockListCnt)
 462+ 7B58 B7           	or		a
 463+ 7B59 ED 42        	sbc		hl, bc
 464+ 7B5B 22 40 8F     	ld		(UsedBlockListCnt), hl
 465+ 7B5E
 466+ 7B5E 7D           	ld		a, l
 467+ 7B5F B4           	or		h
 468+ 7B60 C2 E2 7A     	jp		nz, CopyDiskLoop
 469+ 7B63
 470+ 7B63 C9           	ret
 471+ 7B64
 472+ 7B64              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473+ 7B64
 474+ 7B64              ;Compare string at HL with the one at DE, max length B
 475+ 7B64              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 476+ 7B64              ;OUT: z flag, set = match, reset = mismatch
 477+ 7B64              StrCmp:
 478+ 7B64 E5           	push hl
 479+ 7B65 D5           	push de
 480+ 7B66              Compare:
 481+ 7B66 1A           		ld a, (de)
 482+ 7B67 BE           		cp (hl)
 483+ 7B68 20 04        		jr nz, MisMatch
 484+ 7B6A 23           		inc hl
 485+ 7B6B 13           		inc de
 486+ 7B6C 10 F8        		djnz Compare
 487+ 7B6E              MisMatch:
 488+ 7B6E D1           	pop de
 489+ 7B6F E1           	pop hl
 490+ 7B70 C9           	ret
 491+ 7B71
 492+ 7B71              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 493+ 7B71
 494+ 7B71              ;Read a file into a buffer, sector by sector.
 495+ 7B71              ;It's relocatable, to moved and be used when loading a CODE block.
 496+ 7B71              ;It's not using BDOS, but using similar calls provided by IF1.
 497+ 7B71              ;In: HL = Name address, DE = buffer
 498+ 7B71              IF1FileLoad:
 499+ 7B71 D5           	push	de
 500+ 7B72 22 DC 5C     		ld (FSTR1), hl
 501+ 7B75 26 00        		ld h, 0
 502+ 7B77 3A B9 7C     		ld a, (RWTSDrive)
 503+ 7B7A 3C           		inc  a			;CP/M drive number to BASIC drive number
 504+ 7B7B 6F           		ld	l, a
 505+ 7B7C 22 D6 5C     		ld (DSTR1), hl
 506+ 7B7F 2E 0B        		ld l,NAMELEN
 507+ 7B81 22 DA 5C     		ld (NSTR1), hl
 508+ 7B84 CF           		rst 08
 509+ 7B85 33           		DEFB 51			;open disk channel
 510+ 7B86
 511+ 7B86 CF           		rst		8
 512+ 7B87 35           		defb	53		;read sector
 513+ 7B88 D1           	pop		de
 514+ 7B89 30 27        	jr		nc, FileFree
 515+ 7B8B
 516+ 7B8B DD 7E 32     	ld		a, (ix + CH_DATA)
 517+ 7B8E FE 04        	cp		TEXT_TYPE
 518+ 7B90 30 12        	jr		nc, FileLoadNoHeader
 519+ 7B92
 520+ 7B92              FileLoadHeader:
 521+ 7B92 DD E5        	push	ix
 522+ 7B94 E1           	pop		hl
 523+ 7B95 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 524+ 7B98 09           	add		hl, bc
 525+ 7B99 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 526+ 7B9C ED B0        	ldir
 527+ 7B9E
 528+ 7B9E              FileReadLoop:
 529+ 7B9E D5           	push	de
 530+ 7B9F CF           		rst		8
 531+ 7BA0 35           		defb	53		;read sector
 532+ 7BA1 D1           	pop		de
 533+ 7BA2 30 0E        	jr		nc, FileFree
 534+ 7BA4
 535+ 7BA4              FileLoadNoHeader:
 536+ 7BA4 DD E5        	push	ix
 537+ 7BA6 E1           	pop		hl
 538+ 7BA7 01 32 00     	ld		bc, CH_DATA
 539+ 7BAA 09           	add		hl, bc
 540+ 7BAB 01 00 01     	ld		bc, SECT_SZ
 541+ 7BAE ED B0        	ldir
 542+ 7BB0 18 EC        	jr		FileReadLoop
 543+ 7BB2              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 544+ 7BB2              IF1FileLoadEnd:
 545+ 7BB2
 546+ 7BB2              FileFree:
 547+ 7BB2 D5           	push	de
 548+ 7BB3 CF           	rst		8
 549+ 7BB4 38           	defb	56			;close channel (52) or detroy channel (56)
 550+ 7BB5 D1           	pop		de
 551+ 7BB6 C9           	ret
 552+ 7BB7
 553+ 7BB7
 554+ 7BB7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 555+ 7BB7              ;HL = destination buffer, B = count of sectors, DE = track/sector
 556+ 7BB7              ;Out: A = error code, 0=OK
 557+ 7BB7              ReadDiskSectors:
 558+ 7BB7 C5           	push bc
 559+ 7BB8 E5           		push hl
 560+ 7BB9 D5           			push de
 561+ 7BBA CD F5 79     				call ReadOneDiskSector
 562+ 7BBD D1           			pop de
 563+ 7BBE E1           		pop hl
 564+ 7BBF
 565+ 7BBF 14           		inc d
 566+ 7BC0 24           		inc h
 567+ 7BC1 C1           	pop bc
 568+ 7BC2
 569+ 7BC2 3A C4 7C     	ld	a, (RWTSRes)
 570+ 7BC5 B7           	or	a
 571+ 7BC6 C0           	ret nz
 572+ 7BC7
 573+ 7BC7 10 EE        	djnz ReadDiskSectors
 574+ 7BC9 C9           	ret
 575+ 7BCA
 576+ 7BCA              ;HL = source buffer, B = count of sectors, DE = track/sector
 577+ 7BCA              ;Out: A = error code, 0=OK
 578+ 7BCA              WriteDiskSectors:
 579+ 7BCA C5           	push bc
 580+ 7BCB E5           		push hl
 581+ 7BCC D5           			push de
 582+ 7BCD CD 00 7A     				call WriteOneDiskSector
 583+ 7BD0 D1           			pop de
 584+ 7BD1 E1           		pop hl
 585+ 7BD2
 586+ 7BD2 14           		inc d
 587+ 7BD3 24           		inc h
 588+ 7BD4 C1           	pop bc
 589+ 7BD5
 590+ 7BD5 3A C4 7C     	ld	a, (RWTSRes)
 591+ 7BD8 B7           	or	a
 592+ 7BD9 C0           	ret nz
 593+ 7BDA
 594+ 7BDA 10 EE        	djnz WriteDiskSectors
 595+ 7BDC C9           	ret
 596+ 7BDD
 597+ 7BDD
 598+ 7BDD              ;Reads disk catalog
 599+ 7BDD              ReadCatalogTrack:
 600+ 7BDD 21 2A 95     	ld hl, TrackBuf
 601+ 7BE0 11 00 00     	ld de, 0
 602+ 7BE3 06 10        	ld b, SPT
 603+ 7BE5
 604+ 7BE5 CD B7 7B     	call ReadDiskSectors
 605+ 7BE8 B7           	or   a
 606+ 7BE9 C0           	ret  nz
 607+ 7BEA
 608+ 7BEA              	;Sync with BDOS, to avoid disk R/O error on disk change
 609+ 7BEA F5           	push  af
 610+ 7BEB 3A B9 7C     		ld  a, (RWTSDrive)
 611+ 7BEE CD CE 7C     		call BDOSSelectDisk
 612+ 7BF1 CD CB 7C     		call BDOSInit
 613+ 7BF4 F1           	pop   af
 614+ 7BF5 C9           	ret
 615+ 7BF6
 616+ 7BF6
 617+ 7BF6
 618+ 7BF6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619+ 7BF6
 620+ 7BF6              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 621+ 7BF6              FindCache:
 622+ 7BF6 06 0B        	ld		b, NAMELEN
 623+ 7BF8 CD 64 7B     	call	StrCmp			;find the file to wich this extension belongs
 624+ 7BFB C8           	ret		z
 625+ 7BFC
 626+ 7BFC 0D           	dec		c
 627+ 7BFD 20 02        	jr		nz, CacheNotFinished
 628+ 7BFF B1           	or		c
 629+ 7C00 C9           	ret
 630+ 7C01
 631+ 7C01              CacheNotFinished:
 632+ 7C01 01 19 00     	ld		bc, CACHE_SZ
 633+ 7C04 09           	add		hl, bc			;to the next cache line
 634+ 7C05 18 EF        	jr		FindCache
 635+ 7C07
 636+ 7C07              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 637+ 7C07
 638+ 7C07              	;ld		ix, (SelFileCache)
 639+ 7C07              ReadFileHeader:
 640+ 7C07 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 641+ 7C0A B7           	or		a
 642+ 7C0B C0           	ret		nz				;return if already read
 643+ 7C0C
 644+ 7C0C DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 645+ 7C0F DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 646+ 7C12 7C           	ld		a, h
 647+ 7C13 B5           	or		l
 648+ 7C14 28 46        	jr		z, ReadHeaderEnd
 649+ 7C16
 650+ 7C16 CD 1C 7A     	call	AU2TS
 651+ 7C19 50           	ld		d, b
 652+ 7C1A 59           	ld		e, c
 653+ 7C1B 21 2A 95     	ld		hl, DataBuf
 654+ 7C1E DD E5        	push	ix
 655+ 7C20 DD E5        	push	ix
 656+ 7C22 CD F5 79     		call	ReadOneDiskSector
 657+ 7C25 E1           	pop		hl
 658+ 7C26 DD E1        	pop		ix
 659+ 7C28
 660+ 7C28 E5           	push	hl
 661+ 7C29 21 2A 95     		ld		hl, DataBuf
 662+ 7C2C CD 60 7C     		call	IsFileHeaderValid
 663+ 7C2F E1           	pop		hl
 664+ 7C30 B7           	or		a
 665+ 7C31 28 14        	jr		z, ReadFileHeaderIsTextFile
 666+ 7C33
 667+ 7C33 01 10 00     	ld		bc, CACHE_HDR
 668+ 7C36 09           	add		hl, bc
 669+ 7C37 EB           	ex		hl, de
 670+ 7C38 21 2A 95     	ld		hl, DataBuf
 671+ 7C3B 01 09 00     	ld		bc, HDR_SZ
 672+ 7C3E ED B0        	ldir
 673+ 7C40
 674+ 7C40              	;For text files, read file size as reported by BDOS, since we don't have a header.
 675+ 7C40 3E 03        	ld		a, BYTE_TYPE
 676+ 7C42 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 677+ 7C45 30 15        	jr		nc, ReadHeaderEnd
 678+ 7C47
 679+ 7C47              ReadFileHeaderIsTextFile:
 680+ 7C47 DD E5        	push	ix
 681+ 7C49 DD E5        	push	ix
 682+ 7C4B E1           	pop		hl
 683+ 7C4C CD 19 7D     		call	GetFileSize
 684+ 7C4F DD E1        	pop		ix
 685+ 7C51 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 686+ 7C54 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 687+ 7C57 3E 04        	ld		a, TEXT_TYPE
 688+ 7C59 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 689+ 7C5C
 690+ 7C5C              ReadHeaderEnd:
 691+ 7C5C DD 34 0F     	inc		(ix + CACHE_FLAG)
 692+ 7C5F C9           	ret
 693+ 7C60
 694+ 7C60              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 695+ 7C60              ;Checks if the file header is valid. For now it checks to not have all 0s.
 696+ 7C60              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 697+ 7C60              ;In: HL = header
 698+ 7C60              ;Out: A > 0 if valid
 699+ 7C60              IsFileHeaderValid:
 700+ 7C60              	IFUSED
 701+ 7C60 AF           	xor		a
 702+ 7C61 06 09        	ld		b, HDR_SZ
 703+ 7C63              IsFileHeaderValidLoop:
 704+ 7C63 B6           	or		(hl)
 705+ 7C64 23           	inc		hl
 706+ 7C65 10 FC        	djnz	IsFileHeaderValidLoop
 707+ 7C67
 708+ 7C67 C9           	ret
 709+ 7C68              	ENDIF
 710+ 7C68
 711+ 7C68              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 712+ 7C68
 713+ 7C68              ;IN: HL = address from IF1 to call
 714+ 7C68              IF1Call:
 715+ 7C68 22 ED 5C     	LD   (HD11), HL
 716+ 7C6B CF           	RST  8
 717+ 7C6C 32           	DEFB 50
 718+ 7C6D C9           	RET
 719+ 7C6E
 720+ 7C6E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 721+ 7C6E
 722+ 7C6E              ;Load a program from disk
 723+ 7C6E              ;IN: HL = file name addr
 724+ 7C6E              LoadProgram:
 725+ 7C6E 22 DC 5C     	LD   (FSTR1), HL
 726+ 7C71 26 00        	LD   H, 0
 727+ 7C73 2E 0B        	LD   L, NAMELEN
 728+ 7C75 22 DA 5C     	LD   (NSTR1), HL
 729+ 7C78 3A B9 7C     	LD	 A, (RWTSDrive)
 730+ 7C7B 3C           	INC  A					;Adapt for BASIC drive number
 731+ 7C7C 6F           	LD   L, A
 732+ 7C7D 22 D6 5C     	LD   (DSTR1), HL
 733+ 7C80 21 41 0A     	LD   HL, LOAD_ADDR
 734+ 7C83 CD 68 7C     	CALL IF1Call
 735+ 7C86 C9           	RET
 736+ 7C87
 737+ 7C87              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738+ 7C87
 739+ 7C87              SetFastKeys:
 740+ 7C87 21 09 5C     	ld		hl, REPDEL
 741+ 7C8A 11 0F 01     	ld		de, (1 << 8) | 15
 742+ 7C8D 73 23 72 2B  	ld		(hl), de
 743+ 7C91
 744+ 7C91 C9           	ret
 745+ 7C92
 746+ 7C92
 747+ 7C92              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 748+ 7C92              ;Reads the error message string from IF1 ROM.
 749+ 7C92              GetErrMsg:
 750+ 7C92 3C           	inc		a
 751+ 7C93 08           	ex		af, af'
 752+ 7C94
 753+ 7C94 21 9A 7C     	ld		hl, IF1Paged			;page-in IF1
 754+ 7C97 C3 68 7C     	jp		IF1Call
 755+ 7C9A
 756+ 7C9A              IF1Paged:
 757+ 7C9A 21 60 02     	ld		hl, ERRMSG
 758+ 7C9D 08           	ex		af, af'
 759+ 7C9E B7           	or		a
 760+ 7C9F 28 0B        	jr		z, SaveMsg
 761+ 7CA1
 762+ 7CA1 06 00        	ld		b, 0
 763+ 7CA3              SearchMsgEnd:
 764+ 7CA3 CB 7E        	bit		7, (hl)
 765+ 7CA5 23           	inc		hl
 766+ 7CA6 28 FB        	jr		z, SearchMsgEnd
 767+ 7CA8
 768+ 7CA8 04           	inc		b
 769+ 7CA9 B8           	cp		b
 770+ 7CAA 20 F7        	jr		nz, SearchMsgEnd
 771+ 7CAC
 772+ 7CAC              SaveMsg:
 773+ 7CAC 11 2A 95     	ld		de, DataBuf
 774+ 7CAF              CopyMsg:
 775+ 7CAF 7E           	ld		a, (hl)
 776+ 7CB0 CB 7F        	bit		7, a
 777+ 7CB2 12           	ld		(de), a
 778+ 7CB3 23           	inc		hl
 779+ 7CB4 13           	inc		de
 780+ 7CB5 28 F8        	jr		z, CopyMsg
 781+ 7CB7
 782+ 7CB7 C9           	ret
 783+ 7CB8
 784+ 7CB8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 785+ 7CB8
 786+ 7CB8              ;RWTS routine I/O block
 787+ 7CB8              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 788+ 7CB8              RWTSParams:
 789+ 7CB8 01           RWTSBlockType	DEFB	1							;?
 790+ 7CB9 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 791+ 7CBA 00           RWTSVolNo		DEFB	0							;?
 792+ 7CBB 00           RWTSTrack		DEFB	0
 793+ 7CBC 00           RWTSSector		DEFB	0
 794+ 7CBD 00 00        RWTSDMA			DEFW	0
 795+ 7CBF 32 29        RWTSExtBuf		DEFW	$2932
 796+ 7CC1 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 797+ 7CC3 01           RWTSCmd			DEFB	RWTS_CMD_READ
 798+ 7CC4              ;Results
 799+ 7CC4 00           RWTSRes			DEFB	0
 800+ 7CC5 00           RWTSResVolNo	DEFB	0
 801+ 7CC6 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 801+ 7CCA 00
 802+ 7CCB
 803+ 7CCB              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 804+ 7CCB ~            /*
 805+ 7CCB ~            BasPrmTbl:
 806+ 7CCB ~            PrmDevType		DEFB	$01			;$01
 807+ 7CCB ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 808+ 7CCB ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 809+ 7CCB ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 810+ 7CCB ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 811+ 7CCB ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 812+ 7CCB ~            */
 813+ 7CCB
 814+ 7CCB              	endif
# file closed: disk.asm
1296  7CCB              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7CCB              ;BDOS functions - similar to CP/M
   2+ 7CCB
   3+ 7CCB              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 7CCB              ;0 OK,
   5+ 7CCB              ;1 directory full,
   6+ 7CCB              ;2 disc full,
   7+ 7CCB              ;9 invalid FCB,
   8+ 7CCB              ;10(CP/M) media changed;
   9+ 7CCB              ;0FFh hardware error.
  10+ 7CCB
  11+ 7CCB              	IFNDEF	_BDOS_
  12+ 7CCB              	DEFINE	_BDOS_
  13+ 7CCB
  14+ 7CCB              	include "disk.asm"
# file opened: disk.asm
   1++7CCB              ;HC IF1 routines and constants
   2++7CCB
   3++7CCB              ;IF1 routines error codes, also returned by BASIC commands
   4++7CCB              ;12 = Writing to a 'read' file
   5++7CCB              ;13 = Reading a 'write' file
   6++7CCB              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7CCB              ;15 = Disk full (disk or catalog full)
   8++7CCB              ;16 = Disk error (hardware error)
   9++7CCB              ;17 = File not found
  10++7CCB              ;23 = Disk R/O (disk change detected, software R/O)
  11++7CCB              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7CCB
  13++7CCB              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7CCB              ;00h = OK
  15++7CCB              ;08h = cannot format disk
  16++7CCB              ;10h = disk protected (read-only?)
  17++7CCB              ;20h = volume error
  18++7CCB              ;40h = drive error
  19++7CCB              ;80h = reading error
  20++7CCB              ;Codes I encountered:
  21++7CCB              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7CCB
  23++7CCB
  24++7CCB              	ifndef	_DISK_
  25++7CCB ~            	define	_DISK_
  26++7CCB ~
  27++7CCB ~            	include	"math.asm"
  28++7CCB ~
  29++7CCB ~            DRIVE_CUR_BAS	EQU 0
  30++7CCB ~            DRIVE_A_BAS		EQU	1
  31++7CCB ~            DRIVE_B_BAS		EQU	2
  32++7CCB ~            DRIVE_A_CPM		EQU	0
  33++7CCB ~            DRIVE_B_CPM		EQU	1
  34++7CCB ~            ;Disk geometry stuff
  35++7CCB ~            SPT				EQU	16			;sectors per track
  36++7CCB ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7CCB ~            TRACK_CNT		EQU	80			;track count
  38++7CCB ~            HEAD_CNT		EQU	2			;disk face count
  39++7CCB ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7CCB ~            EXT_SZ			EQU	32			;directory entry size
  41++7CCB ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7CCB ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7CCB ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7CCB ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7CCB ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7CCB ~            REC_SZ			EQU 128			;cp/m record size
  47++7CCB ~            DEL_MARKER		EQU	$E5
  48++7CCB ~
  49++7CCB ~
  50++7CCB ~            ;Extension structure (directory entry)
  51++7CCB ~            EXT_DEL_FLAG	EQU	0
  52++7CCB ~            EXT_NAME		EQU 1
  53++7CCB ~            EXT_IDX			EQU 12
  54++7CCB ~            EXT_S1			EQU 13
  55++7CCB ~            EXT_S2			EQU 14
  56++7CCB ~            EXT_RC			EQU	15
  57++7CCB ~            EXT_AU0			EQU	16
  58++7CCB ~            EXT_AU1			EQU	18
  59++7CCB ~            EXT_AU2			EQU	20
  60++7CCB ~            EXT_AU3			EQU	22
  61++7CCB ~            EXT_AU4			EQU	24
  62++7CCB ~            EXT_AU5			EQU	26
  63++7CCB ~            EXT_AU6			EQU	28
  64++7CCB ~            EXT_AU7			EQU	30
  65++7CCB ~            EXT_SIZE		EQU 32
  66++7CCB ~
  67++7CCB ~            ;FCB structure
  68++7CCB ~            FCB_DRIVE		EQU 0
  69++7CCB ~            FCB_NAME		EQU EXT_NAME
  70++7CCB ~            FCB_EX_IDX		EQU EXT_IDX
  71++7CCB ~            FCB_S1			EQU EXT_S1
  72++7CCB ~            FCB_S2			EQU EXT_S2
  73++7CCB ~            FCB_RC			EQU	EXT_RC
  74++7CCB ~            FCB_AU			EQU	EXT_AU0
  75++7CCB ~            FCB_CR			EQU	32
  76++7CCB ~            FCB_R0			EQU 33
  77++7CCB ~            FCB_R1			EQU 34
  78++7CCB ~            FCB_R2			EQU 35
  79++7CCB ~            FCB_SIZE		EQU 36
  80++7CCB ~
  81++7CCB ~
  82++7CCB ~
  83++7CCB ~            ;System variables for disk
  84++7CCB ~            DSTR1			EQU	$5CD6		;drive
  85++7CCB ~            FSTR1			EQU	$5CDC		;file name
  86++7CCB ~            NSTR1			EQU	$5CDA		;name length
  87++7CCB ~            HD11			EQU	$5CED		;BDOS argument
  88++7CCB ~            COPIES			EQU	$5CEF		;BDOS function
  89++7CCB ~
  90++7CCB ~            ERRSP			EQU $5C3D
  91++7CCB ~            ERRNR			EQU $5C3A
  92++7CCB ~            ERRMSG			EQU	$0260
  93++7CCB ~
  94++7CCB ~            PROG			EQU $5C53
  95++7CCB ~            VARS			EQU	$5C4B
  96++7CCB ~            STKEND			EQU	$5C65
  97++7CCB ~
  98++7CCB ~            PRN_BUF			EQU	23296
  99++7CCB ~
 100++7CCB ~            STR_MSG_BASIC	EQU	$1539
 101++7CCB ~            STR_MSG_BASIC_LEN EQU 32
 102++7CCB ~            STR_MSG_IF1_2000	EQU $27F0
 103++7CCB ~            STR_MSG_IF1_91		EQU $23F0
 104++7CCB ~            STR_MSG_IF1_LEN EQU 31
 105++7CCB ~
 106++7CCB ~            REPDEL			EQU	23561
 107++7CCB ~            REPPER			EQU	23562
 108++7CCB ~            PIP				EQU	23609
 109++7CCB ~
 110++7CCB ~
 111++7CCB ~            ;RWTS routine commands
 112++7CCB ~            RWTS_CMD_POS	EQU	0			;position head
 113++7CCB ~            RWTS_CMD_READ	EQU	1			;read sector
 114++7CCB ~            RWTS_CMD_WRITE	EQU	2			;write sector
 115++7CCB ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 116++7CCB ~
 117++7CCB ~
 118++7CCB ~            ;File name stuff
 119++7CCB ~            NAMELEN			EQU	11			;name length
 120++7CCB ~            RO_POS			EQU	8			;read-only attribute position in name
 121++7CCB ~            SYS_POS			EQU	9			;system attribute position in name
 122++7CCB ~
 123++7CCB ~            ;File types (first byte in header)
 124++7CCB ~            PROG_TYPE		EQU	0			;program
 125++7CCB ~            NUMB_TYPE		EQU	1			;number array
 126++7CCB ~            CHAR_TYPE		EQU	2			;char array
 127++7CCB ~            BYTE_TYPE		EQU	3			;bytes
 128++7CCB ~            TEXT_TYPE		EQU	4			;text, >= 4
 129++7CCB ~
 130++7CCB ~            ;File header offsets
 131++7CCB ~            HDR_TYPE		EQU	0
 132++7CCB ~            HDR_LEN			EQU 1
 133++7CCB ~            HDR_ADDR		EQU 3
 134++7CCB ~            HDR_PLEN		EQU	5
 135++7CCB ~            HDR_LINE		EQU 7
 136++7CCB ~            HDR_SZ			EQU	9
 137++7CCB ~
 138++7CCB ~            ;BASIC disk channel structure
 139++7CCB ~            CH_RW_FLAG		EQU 11
 140++7CCB ~            CH_FCB			EQU	12
 141++7CCB ~            CH_DATA			EQU	50
 142++7CCB ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143++7CCB ~
 144++7CCB ~            CACHE_NAME		EQU	0					;11B
 145++7CCB ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146++7CCB ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147++7CCB ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148++7CCB ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149++7CCB ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150++7CCB ~
 151++7CCB ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152++7CCB ~
 153++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154++7CCB ~            IF1Init:
 155++7CCB ~            	rst		08
 156++7CCB ~            	defb	49		;create system variables
 157++7CCB ~            	ret
 158++7CCB ~
 159++7CCB ~            ;ReadWriteTrackSector
 160++7CCB ~            ;A=command: 0, 1, 2, 4
 161++7CCB ~            RWTS:
 162++7CCB ~            	ld (RWTSCmd), a
 163++7CCB ~            	ld hl, RWTSParams
 164++7CCB ~            	ld (HD11), hl
 165++7CCB ~            	rst 08
 166++7CCB ~            	DEFB 58
 167++7CCB ~            	ret
 168++7CCB ~
 169++7CCB ~
 170++7CCB ~            ;D = sector, E = track
 171++7CCB ~            ;HL = dma
 172++7CCB ~            ReadOneDiskSector:
 173++7CCB ~            	ld (RWTSDMA), hl
 174++7CCB ~            	ld (RWTSTrack), de
 175++7CCB ~            	;ld (RWTSDrive), a
 176++7CCB ~            	ld a, RWTS_CMD_READ
 177++7CCB ~            	jr	RWTS
 178++7CCB ~
 179++7CCB ~            ;D = sector, E = track
 180++7CCB ~            ;HL = dma
 181++7CCB ~            WriteOneDiskSector:
 182++7CCB ~            	ld (RWTSDMA), hl
 183++7CCB ~            	ld (RWTSTrack), de
 184++7CCB ~            	;ld (RWTSDrive), a
 185++7CCB ~            	ld a, RWTS_CMD_WRITE
 186++7CCB ~            	jr	RWTS
 187++7CCB ~
 188++7CCB ~            FormatDisk:
 189++7CCB ~            	ld		hl, DataBuf
 190++7CCB ~            	ld		(hl), DEL_MARKER
 191++7CCB ~            	ld 		(RWTSDMA), hl
 192++7CCB ~            	ld 		a, RWTS_CMD_FMT
 193++7CCB ~            	call	RWTS
 194++7CCB ~            	ld		a, (RWTSRes)
 195++7CCB ~            	ret
 196++7CCB ~
 197++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198++7CCB ~
 199++7CCB ~            ;Allocation unit no. to track/sector
 200++7CCB ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201++7CCB ~            ;IN:  HL=alloc. unit no.
 202++7CCB ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 203++7CCB ~            AU2TS:
 204++7CCB ~            	ld c, SPT/SPAL
 205++7CCB ~            	call Div					;A = sector
 206++7CCB ~            	push af
 207++7CCB ~            		/*
 208++7CCB ~            		ld c, HEAD_CNT
 209++7CCB ~            		call Div				;L = track, A = head (0 or 1)
 210++7CCB ~            		*/
 211++7CCB ~            		xor a
 212++7CCB ~            		rr h
 213++7CCB ~            		rr l
 214++7CCB ~            		rr a
 215++7CCB ~
 216++7CCB ~            		ld c, l
 217++7CCB ~            		ld b, 0
 218++7CCB ~            		or a
 219++7CCB ~            		jr z, Track0
 220++7CCB ~            		ld b, SPT
 221++7CCB ~            Track0:
 222++7CCB ~            	pop af
 223++7CCB ~            	or a
 224++7CCB ~            	jr z, FirstAU
 225++7CCB ~            	ld a, SPAL
 226++7CCB ~            FirstAU:
 227++7CCB ~            	add a, b
 228++7CCB ~            	ld  b, a
 229++7CCB ~            	ret
 230++7CCB ~
 231++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232++7CCB ~
 233++7CCB ~            ;Checks the allocation units number used in extension
 234++7CCB ~            ;IN:	IX = extension addr
 235++7CCB ~            ;OUT:	B = no. of allocation units used
 236++7CCB ~            ;		C = no. of records used in ext.
 237++7CCB ~            ;		HL = first alloc. unit no.
 238++7CCB ~            ;		DE = last alloc. unit no.
 239++7CCB ~            CheckExtAlloc:
 240++7CCB ~            	push ix
 241++7CCB ~            		ld bc, EXT_RC
 242++7CCB ~            		add ix, bc
 243++7CCB ~            		ld c, (ix)			;save rec. no.
 244++7CCB ~            		inc ix
 245++7CCB ~            		ld l, (ix)
 246++7CCB ~            		ld h, (ix + 1)
 247++7CCB ~            		ld b, EXT_AU_CNT
 248++7CCB ~            CheckAU:
 249++7CCB ~            		ld a, (ix)
 250++7CCB ~            		or (ix + 1)
 251++7CCB ~            		jr z, CheckAUEnd
 252++7CCB ~            		ld e, (ix)
 253++7CCB ~            		ld d, (ix + 1)
 254++7CCB ~            		inc ix
 255++7CCB ~            		inc ix
 256++7CCB ~            		djnz CheckAU
 257++7CCB ~            CheckAUEnd:
 258++7CCB ~            		ld a, EXT_AU_CNT
 259++7CCB ~            		sub b
 260++7CCB ~            		ld b, a
 261++7CCB ~            	pop ix
 262++7CCB ~            	ret
 263++7CCB ~
 264++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265++7CCB ~
 266++7CCB ~            ;Input: TrackBuffer
 267++7CCB ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268++7CCB ~            ReadUsedBlocksList:
 269++7CCB ~            	ld		ix, TrackBuf			;source buffer
 270++7CCB ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 271++7CCB ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272++7CCB ~            	ld		de, 2					;counter of used blocks, start with 2
 273++7CCB ~            	ld		(hl), e
 274++7CCB ~            	inc		hl
 275++7CCB ~            	ld		(hl), d
 276++7CCB ~            	inc		hl
 277++7CCB ~
 278++7CCB ~            	;Add blocks 0 and 1 for directory
 279++7CCB ~            	ld		de, 0
 280++7CCB ~            	ld		(hl), e
 281++7CCB ~            	inc		hl
 282++7CCB ~            	ld		(hl), d
 283++7CCB ~            	inc		hl
 284++7CCB ~
 285++7CCB ~            	inc		de
 286++7CCB ~            	ld		(hl), e
 287++7CCB ~            	inc		hl
 288++7CCB ~            	ld		(hl), d
 289++7CCB ~            	inc		hl
 290++7CCB ~
 291++7CCB ~            ReadUsedBlocksLoop:
 292++7CCB ~            	xor		a
 293++7CCB ~            	cp		(ix)
 294++7CCB ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295++7CCB ~
 296++7CCB ~            	push	ix
 297++7CCB ~            	push	bc
 298++7CCB ~            		ld		b, EXT_AU_CNT
 299++7CCB ~            		ld		de, EXT_AU0
 300++7CCB ~            		add		ix, de
 301++7CCB ~
 302++7CCB ~            ReadUsedBlocksLoop2:
 303++7CCB ~            		ld		e, (ix)
 304++7CCB ~            		ld		d, (ix+1)
 305++7CCB ~            		ld		a, e
 306++7CCB ~            		or		d
 307++7CCB ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308++7CCB ~
 309++7CCB ~            		ld		(hl), e
 310++7CCB ~            		inc		hl
 311++7CCB ~            		ld		(hl), d
 312++7CCB ~            		inc		hl
 313++7CCB ~
 314++7CCB ~            		inc		ix
 315++7CCB ~            		inc		ix
 316++7CCB ~
 317++7CCB ~            		ld		de, (UsedBlockListCnt)
 318++7CCB ~            		inc		de
 319++7CCB ~            		ld		(UsedBlockListCnt), de
 320++7CCB ~
 321++7CCB ~            		djnz	ReadUsedBlocksLoop2
 322++7CCB ~
 323++7CCB ~
 324++7CCB ~            ReadUsedBlocksSkip:
 325++7CCB ~            	pop		bc
 326++7CCB ~            	pop		ix
 327++7CCB ~            ReadUsedBlocksSkip2:
 328++7CCB ~            	ld		de, EXT_SZ
 329++7CCB ~            	add		ix, de
 330++7CCB ~
 331++7CCB ~            	dec		bc
 332++7CCB ~            	ld		a, b
 333++7CCB ~            	or		c
 334++7CCB ~            	jr		nz, ReadUsedBlocksLoop
 335++7CCB ~
 336++7CCB ~            	ret
 337++7CCB ~
 338++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339++7CCB ~            ;Reads 8 sectors for an AU
 340++7CCB ~            ;HL = block number, DE = destination buffer
 341++7CCB ~            ReadFSBlock:
 342++7CCB ~            	push	de
 343++7CCB ~            		call	AU2TS		;B=sector, C=track
 344++7CCB ~            	pop		hl				;HL=dest
 345++7CCB ~
 346++7CCB ~            	ld		d, b
 347++7CCB ~            	ld		e, c
 348++7CCB ~            	ld		b, SPAL
 349++7CCB ~
 350++7CCB ~            ReadFSBlockLoop:
 351++7CCB ~            	call	ReadDiskSectors
 352++7CCB ~            	ret
 353++7CCB ~
 354++7CCB ~
 355++7CCB ~            ;Write 8 sectors for an AU
 356++7CCB ~            ;HL = block number, DE = source buffer
 357++7CCB ~            WriteFSBlock:
 358++7CCB ~            	push	de
 359++7CCB ~            		call	AU2TS		;B=sector, C=track
 360++7CCB ~            	pop		hl				;HL=dest
 361++7CCB ~
 362++7CCB ~            	ld		d, b
 363++7CCB ~            	ld		e, c
 364++7CCB ~            	ld		b, SPAL
 365++7CCB ~
 366++7CCB ~            WriteFSBlockLoop:
 367++7CCB ~            	call	WriteDiskSectors
 368++7CCB ~            	ret
 369++7CCB ~
 370++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371++7CCB ~            ;Copies the allocated blocks from one disk to another.
 372++7CCB ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373++7CCB ~            CopyDisk:
 374++7CCB ~            	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 375++7CCB ~            	call	ReadUsedBlocksList
 376++7CCB ~            	ld		ix, UsedBlockListBlk
 377++7CCB ~
 378++7CCB ~            CopyDiskLoop:
 379++7CCB ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380++7CCB ~            	ld		de, MsgBlocksLeft
 381++7CCB ~            	call	Byte2Txt
 382++7CCB ~            	ld		hl, MsgBlocksLeft
 383++7CCB ~            	ld		de, LST_LINE_MSG + 1 << 8
 384++7CCB ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 385++7CCB ~            	call	PrintStrClr
 386++7CCB ~
 387++7CCB ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388++7CCB ~            	ld		hl, MAX_AU_RAM
 389++7CCB ~            	ld		bc, (UsedBlockListCnt)
 390++7CCB ~            	or		a
 391++7CCB ~            	sbc		hl, bc
 392++7CCB ~            	jr		nc, CopyDiskLoopRead
 393++7CCB ~            	ld		bc, MAX_AU_RAM
 394++7CCB ~
 395++7CCB ~            CopyDiskLoopRead:
 396++7CCB ~            	ld		b, c
 397++7CCB ~            	ld		de, CopyDiskBuf
 398++7CCB ~            	;save initial counter and initial block number array position
 399++7CCB ~            	push	bc
 400++7CCB ~            	push	ix
 401++7CCB ~
 402++7CCB ~            CopyDiskLoopReadLoop:
 403++7CCB ~            		ld		l, (ix)
 404++7CCB ~            		ld		h, (ix+1)
 405++7CCB ~            		inc		ix
 406++7CCB ~            		inc		ix
 407++7CCB ~
 408++7CCB ~            		push	de
 409++7CCB ~            		push	bc
 410++7CCB ~            			call	ReadFSBlock			;Stop on error or continue?
 411++7CCB ~            		pop		bc
 412++7CCB ~            		pop		de
 413++7CCB ~
 414++7CCB ~            		;+2048
 415++7CCB ~            		ld		a, d
 416++7CCB ~            		add		8
 417++7CCB ~            		ld		d, a
 418++7CCB ~
 419++7CCB ~            		djnz	CopyDiskLoopReadLoop
 420++7CCB ~
 421++7CCB ~            		;alternate drive
 422++7CCB ~            		ld		a, (RWTSDrive)
 423++7CCB ~            		xor		%11
 424++7CCB ~            		ld		(RWTSDrive), a
 425++7CCB ~
 426++7CCB ~            	;restore initial counter and initial block number array position
 427++7CCB ~            	pop		ix
 428++7CCB ~            	pop		bc
 429++7CCB ~            	ld		de, CopyDiskBuf
 430++7CCB ~            	push	bc
 431++7CCB ~
 432++7CCB ~            CopyDiskLoopWriteLoop:
 433++7CCB ~            		ld		l, (ix)
 434++7CCB ~            		ld		h, (ix+1)
 435++7CCB ~            		inc		ix
 436++7CCB ~            		inc		ix
 437++7CCB ~
 438++7CCB ~            		push	de
 439++7CCB ~            		push	bc
 440++7CCB ~            			call	WriteFSBlock		;Stop on error or continue?
 441++7CCB ~            		pop		bc
 442++7CCB ~            		pop		de
 443++7CCB ~
 444++7CCB ~            		;+2048
 445++7CCB ~            		ld		a, d
 446++7CCB ~            		add		8
 447++7CCB ~            		ld		d, a
 448++7CCB ~
 449++7CCB ~            		djnz	CopyDiskLoopWriteLoop
 450++7CCB ~
 451++7CCB ~            		;alternate drive again
 452++7CCB ~            		ld		a, (RWTSDrive)
 453++7CCB ~            		xor		%11
 454++7CCB ~            		ld		(RWTSDrive), a
 455++7CCB ~
 456++7CCB ~            	pop		bc
 457++7CCB ~            	ld		c, b
 458++7CCB ~            	ld		b, 0
 459++7CCB ~
 460++7CCB ~            	;Decrease number of blocks read by now.
 461++7CCB ~            	ld		hl, (UsedBlockListCnt)
 462++7CCB ~            	or		a
 463++7CCB ~            	sbc		hl, bc
 464++7CCB ~            	ld		(UsedBlockListCnt), hl
 465++7CCB ~
 466++7CCB ~            	ld		a, l
 467++7CCB ~            	or		h
 468++7CCB ~            	jp		nz, CopyDiskLoop
 469++7CCB ~
 470++7CCB ~            	ret
 471++7CCB ~
 472++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473++7CCB ~
 474++7CCB ~            ;Compare string at HL with the one at DE, max length B
 475++7CCB ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 476++7CCB ~            ;OUT: z flag, set = match, reset = mismatch
 477++7CCB ~            StrCmp:
 478++7CCB ~            	push hl
 479++7CCB ~            	push de
 480++7CCB ~            Compare:
 481++7CCB ~            		ld a, (de)
 482++7CCB ~            		cp (hl)
 483++7CCB ~            		jr nz, MisMatch
 484++7CCB ~            		inc hl
 485++7CCB ~            		inc de
 486++7CCB ~            		djnz Compare
 487++7CCB ~            MisMatch:
 488++7CCB ~            	pop de
 489++7CCB ~            	pop hl
 490++7CCB ~            	ret
 491++7CCB ~
 492++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 493++7CCB ~
 494++7CCB ~            ;Read a file into a buffer, sector by sector.
 495++7CCB ~            ;It's relocatable, to moved and be used when loading a CODE block.
 496++7CCB ~            ;It's not using BDOS, but using similar calls provided by IF1.
 497++7CCB ~            ;In: HL = Name address, DE = buffer
 498++7CCB ~            IF1FileLoad:
 499++7CCB ~            	push	de
 500++7CCB ~            		ld (FSTR1), hl
 501++7CCB ~            		ld h, 0
 502++7CCB ~            		ld a, (RWTSDrive)
 503++7CCB ~            		inc  a			;CP/M drive number to BASIC drive number
 504++7CCB ~            		ld	l, a
 505++7CCB ~            		ld (DSTR1), hl
 506++7CCB ~            		ld l,NAMELEN
 507++7CCB ~            		ld (NSTR1), hl
 508++7CCB ~            		rst 08
 509++7CCB ~            		DEFB 51			;open disk channel
 510++7CCB ~
 511++7CCB ~            		rst		8
 512++7CCB ~            		defb	53		;read sector
 513++7CCB ~            	pop		de
 514++7CCB ~            	jr		nc, FileFree
 515++7CCB ~
 516++7CCB ~            	ld		a, (ix + CH_DATA)
 517++7CCB ~            	cp		TEXT_TYPE
 518++7CCB ~            	jr		nc, FileLoadNoHeader
 519++7CCB ~
 520++7CCB ~            FileLoadHeader:
 521++7CCB ~            	push	ix
 522++7CCB ~            	pop		hl
 523++7CCB ~            	ld		bc, CH_DATA + HDR_SZ
 524++7CCB ~            	add		hl, bc
 525++7CCB ~            	ld		bc, SECT_SZ - HDR_SZ
 526++7CCB ~            	ldir
 527++7CCB ~
 528++7CCB ~            FileReadLoop:
 529++7CCB ~            	push	de
 530++7CCB ~            		rst		8
 531++7CCB ~            		defb	53		;read sector
 532++7CCB ~            	pop		de
 533++7CCB ~            	jr		nc, FileFree
 534++7CCB ~
 535++7CCB ~            FileLoadNoHeader:
 536++7CCB ~            	push	ix
 537++7CCB ~            	pop		hl
 538++7CCB ~            	ld		bc, CH_DATA
 539++7CCB ~            	add		hl, bc
 540++7CCB ~            	ld		bc, SECT_SZ
 541++7CCB ~            	ldir
 542++7CCB ~            	jr		FileReadLoop
 543++7CCB ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 544++7CCB ~            IF1FileLoadEnd:
 545++7CCB ~
 546++7CCB ~            FileFree:
 547++7CCB ~            	push	de
 548++7CCB ~            	rst		8
 549++7CCB ~            	defb	56			;close channel (52) or detroy channel (56)
 550++7CCB ~            	pop		de
 551++7CCB ~            	ret
 552++7CCB ~
 553++7CCB ~
 554++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 555++7CCB ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 556++7CCB ~            ;Out: A = error code, 0=OK
 557++7CCB ~            ReadDiskSectors:
 558++7CCB ~            	push bc
 559++7CCB ~            		push hl
 560++7CCB ~            			push de
 561++7CCB ~            				call ReadOneDiskSector
 562++7CCB ~            			pop de
 563++7CCB ~            		pop hl
 564++7CCB ~
 565++7CCB ~            		inc d
 566++7CCB ~            		inc h
 567++7CCB ~            	pop bc
 568++7CCB ~
 569++7CCB ~            	ld	a, (RWTSRes)
 570++7CCB ~            	or	a
 571++7CCB ~            	ret nz
 572++7CCB ~
 573++7CCB ~            	djnz ReadDiskSectors
 574++7CCB ~            	ret
 575++7CCB ~
 576++7CCB ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 577++7CCB ~            ;Out: A = error code, 0=OK
 578++7CCB ~            WriteDiskSectors:
 579++7CCB ~            	push bc
 580++7CCB ~            		push hl
 581++7CCB ~            			push de
 582++7CCB ~            				call WriteOneDiskSector
 583++7CCB ~            			pop de
 584++7CCB ~            		pop hl
 585++7CCB ~
 586++7CCB ~            		inc d
 587++7CCB ~            		inc h
 588++7CCB ~            	pop bc
 589++7CCB ~
 590++7CCB ~            	ld	a, (RWTSRes)
 591++7CCB ~            	or	a
 592++7CCB ~            	ret nz
 593++7CCB ~
 594++7CCB ~            	djnz WriteDiskSectors
 595++7CCB ~            	ret
 596++7CCB ~
 597++7CCB ~
 598++7CCB ~            ;Reads disk catalog
 599++7CCB ~            ReadCatalogTrack:
 600++7CCB ~            	ld hl, TrackBuf
 601++7CCB ~            	ld de, 0
 602++7CCB ~            	ld b, SPT
 603++7CCB ~
 604++7CCB ~            	call ReadDiskSectors
 605++7CCB ~            	or   a
 606++7CCB ~            	ret  nz
 607++7CCB ~
 608++7CCB ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 609++7CCB ~            	push  af
 610++7CCB ~            		ld  a, (RWTSDrive)
 611++7CCB ~            		call BDOSSelectDisk
 612++7CCB ~            		call BDOSInit
 613++7CCB ~            	pop   af
 614++7CCB ~            	ret
 615++7CCB ~
 616++7CCB ~
 617++7CCB ~
 618++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619++7CCB ~
 620++7CCB ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 621++7CCB ~            FindCache:
 622++7CCB ~            	ld		b, NAMELEN
 623++7CCB ~            	call	StrCmp			;find the file to wich this extension belongs
 624++7CCB ~            	ret		z
 625++7CCB ~
 626++7CCB ~            	dec		c
 627++7CCB ~            	jr		nz, CacheNotFinished
 628++7CCB ~            	or		c
 629++7CCB ~            	ret
 630++7CCB ~
 631++7CCB ~            CacheNotFinished:
 632++7CCB ~            	ld		bc, CACHE_SZ
 633++7CCB ~            	add		hl, bc			;to the next cache line
 634++7CCB ~            	jr		FindCache
 635++7CCB ~
 636++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 637++7CCB ~
 638++7CCB ~            	;ld		ix, (SelFileCache)
 639++7CCB ~            ReadFileHeader:
 640++7CCB ~            	ld		a, (ix + CACHE_FLAG)
 641++7CCB ~            	or		a
 642++7CCB ~            	ret		nz				;return if already read
 643++7CCB ~
 644++7CCB ~            	ld		l, (ix + CACHE_FIRST_AU)
 645++7CCB ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 646++7CCB ~            	ld		a, h
 647++7CCB ~            	or		l
 648++7CCB ~            	jr		z, ReadHeaderEnd
 649++7CCB ~
 650++7CCB ~            	call	AU2TS
 651++7CCB ~            	ld		d, b
 652++7CCB ~            	ld		e, c
 653++7CCB ~            	ld		hl, DataBuf
 654++7CCB ~            	push	ix
 655++7CCB ~            	push	ix
 656++7CCB ~            		call	ReadOneDiskSector
 657++7CCB ~            	pop		hl
 658++7CCB ~            	pop		ix
 659++7CCB ~
 660++7CCB ~            	push	hl
 661++7CCB ~            		ld		hl, DataBuf
 662++7CCB ~            		call	IsFileHeaderValid
 663++7CCB ~            	pop		hl
 664++7CCB ~            	or		a
 665++7CCB ~            	jr		z, ReadFileHeaderIsTextFile
 666++7CCB ~
 667++7CCB ~            	ld		bc, CACHE_HDR
 668++7CCB ~            	add		hl, bc
 669++7CCB ~            	ex		hl, de
 670++7CCB ~            	ld		hl, DataBuf
 671++7CCB ~            	ld		bc, HDR_SZ
 672++7CCB ~            	ldir
 673++7CCB ~
 674++7CCB ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 675++7CCB ~            	ld		a, BYTE_TYPE
 676++7CCB ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 677++7CCB ~            	jr		nc, ReadHeaderEnd
 678++7CCB ~
 679++7CCB ~            ReadFileHeaderIsTextFile:
 680++7CCB ~            	push	ix
 681++7CCB ~            	push	ix
 682++7CCB ~            	pop		hl
 683++7CCB ~            		call	GetFileSize
 684++7CCB ~            	pop		ix
 685++7CCB ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 686++7CCB ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 687++7CCB ~            	ld		a, TEXT_TYPE
 688++7CCB ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 689++7CCB ~
 690++7CCB ~            ReadHeaderEnd:
 691++7CCB ~            	inc		(ix + CACHE_FLAG)
 692++7CCB ~            	ret
 693++7CCB ~
 694++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 695++7CCB ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 696++7CCB ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 697++7CCB ~            ;In: HL = header
 698++7CCB ~            ;Out: A > 0 if valid
 699++7CCB ~            IsFileHeaderValid:
 700++7CCB ~            	IFUSED
 701++7CCB ~            	xor		a
 702++7CCB ~            	ld		b, HDR_SZ
 703++7CCB ~            IsFileHeaderValidLoop:
 704++7CCB ~            	or		(hl)
 705++7CCB ~            	inc		hl
 706++7CCB ~            	djnz	IsFileHeaderValidLoop
 707++7CCB ~
 708++7CCB ~            	ret
 709++7CCB ~            	ENDIF
 710++7CCB ~
 711++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 712++7CCB ~
 713++7CCB ~            ;IN: HL = address from IF1 to call
 714++7CCB ~            IF1Call:
 715++7CCB ~            	LD   (HD11), HL
 716++7CCB ~            	RST  8
 717++7CCB ~            	DEFB 50
 718++7CCB ~            	RET
 719++7CCB ~
 720++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 721++7CCB ~
 722++7CCB ~            ;Load a program from disk
 723++7CCB ~            ;IN: HL = file name addr
 724++7CCB ~            LoadProgram:
 725++7CCB ~            	LD   (FSTR1), HL
 726++7CCB ~            	LD   H, 0
 727++7CCB ~            	LD   L, NAMELEN
 728++7CCB ~            	LD   (NSTR1), HL
 729++7CCB ~            	LD	 A, (RWTSDrive)
 730++7CCB ~            	INC  A					;Adapt for BASIC drive number
 731++7CCB ~            	LD   L, A
 732++7CCB ~            	LD   (DSTR1), HL
 733++7CCB ~            	LD   HL, LOAD_ADDR
 734++7CCB ~            	CALL IF1Call
 735++7CCB ~            	RET
 736++7CCB ~
 737++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738++7CCB ~
 739++7CCB ~            SetFastKeys:
 740++7CCB ~            	ld		hl, REPDEL
 741++7CCB ~            	ld		de, (1 << 8) | 15
 742++7CCB ~            	ld		(hl), de
 743++7CCB ~
 744++7CCB ~            	ret
 745++7CCB ~
 746++7CCB ~
 747++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 748++7CCB ~            ;Reads the error message string from IF1 ROM.
 749++7CCB ~            GetErrMsg:
 750++7CCB ~            	inc		a
 751++7CCB ~            	ex		af, af'
 752++7CCB ~
 753++7CCB ~            	ld		hl, IF1Paged			;page-in IF1
 754++7CCB ~            	jp		IF1Call
 755++7CCB ~
 756++7CCB ~            IF1Paged:
 757++7CCB ~            	ld		hl, ERRMSG
 758++7CCB ~            	ex		af, af'
 759++7CCB ~            	or		a
 760++7CCB ~            	jr		z, SaveMsg
 761++7CCB ~
 762++7CCB ~            	ld		b, 0
 763++7CCB ~            SearchMsgEnd:
 764++7CCB ~            	bit		7, (hl)
 765++7CCB ~            	inc		hl
 766++7CCB ~            	jr		z, SearchMsgEnd
 767++7CCB ~
 768++7CCB ~            	inc		b
 769++7CCB ~            	cp		b
 770++7CCB ~            	jr		nz, SearchMsgEnd
 771++7CCB ~
 772++7CCB ~            SaveMsg:
 773++7CCB ~            	ld		de, DataBuf
 774++7CCB ~            CopyMsg:
 775++7CCB ~            	ld		a, (hl)
 776++7CCB ~            	bit		7, a
 777++7CCB ~            	ld		(de), a
 778++7CCB ~            	inc		hl
 779++7CCB ~            	inc		de
 780++7CCB ~            	jr		z, CopyMsg
 781++7CCB ~
 782++7CCB ~            	ret
 783++7CCB ~
 784++7CCB ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 785++7CCB ~
 786++7CCB ~            ;RWTS routine I/O block
 787++7CCB ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 788++7CCB ~            RWTSParams:
 789++7CCB ~            RWTSBlockType	DEFB	1							;?
 790++7CCB ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 791++7CCB ~            RWTSVolNo		DEFB	0							;?
 792++7CCB ~            RWTSTrack		DEFB	0
 793++7CCB ~            RWTSSector		DEFB	0
 794++7CCB ~            RWTSDMA			DEFW	0
 795++7CCB ~            RWTSExtBuf		DEFW	$2932
 796++7CCB ~            RWTSPrmTbl		DEFW	$1f2a
 797++7CCB ~            RWTSCmd			DEFB	RWTS_CMD_READ
 798++7CCB ~            ;Results
 799++7CCB ~            RWTSRes			DEFB	0
 800++7CCB ~            RWTSResVolNo	DEFB	0
 801++7CCB ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 802++7CCB ~
 803++7CCB ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 804++7CCB ~            /*
 805++7CCB ~            BasPrmTbl:
 806++7CCB ~            PrmDevType		DEFB	$01			;$01
 807++7CCB ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 808++7CCB ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 809++7CCB ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 810++7CCB ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 811++7CCB ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 812++7CCB ~            */
 813++7CCB ~
 814++7CCB              	endif
# file closed: disk.asm
  15+ 7CCB
  16+ 7CCB              BDOSInit:
  17+ 7CCB AF           	xor		a
  18+ 7CCC 18 3D        	jr		BDOS
  19+ 7CCE
  20+ 7CCE
  21+ 7CCE              ;IN: A = Drive to select
  22+ 7CCE              BDOSSelectDisk:
  23+ 7CCE              	IFUSED
  24+ 7CCE DD 6F        	ld		ixl, a
  25+ 7CD0 DD 26 00     	ld		ixh, 0
  26+ 7CD3 3E 01        	ld		a, 1
  27+ 7CD5 18 34        	jr		BDOS
  28+ 7CD7              	ENDIF
  29+ 7CD7
  30+ 7CD7
  31+ 7CD7              BDOSMakeDiskRO:
  32+ 7CD7              	IFUSED
  33+ 7CD7 ~            	ld		a, 15
  34+ 7CD7 ~            	jr		BDOS
  35+ 7CD7              	ENDIF
  36+ 7CD7
  37+ 7CD7              ;Get Read Only flag
  38+ 7CD7              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 7CD7              BDOSGetDiskRO:
  40+ 7CD7              	IFUSED
  41+ 7CD7 ~            	ld	a, 16
  42+ 7CD7 ~            	jr	BDOS
  43+ 7CD7              	ENDIF
  44+ 7CD7
  45+ 7CD7              BDOSGetCurrentDisk:
  46+ 7CD7              	IFUSED
  47+ 7CD7 ~            	ld		a, 12
  48+ 7CD7 ~            	jr		BDOS
  49+ 7CD7              	ENDIF
  50+ 7CD7
  51+ 7CD7
  52+ 7CD7              ;Create a disk channel for BDOS access (does not open the file)
  53+ 7CD7              ;IN: HL=name addr, A=drive
  54+ 7CD7              ;OUT: IX=FCB
  55+ 7CD7              CreateChannel:
  56+ 7CD7 22 DC 5C     	ld (FSTR1), hl
  57+ 7CDA 26 00        	ld h,0
  58+ 7CDC 6F           	ld l,a
  59+ 7CDD 22 D6 5C     	ld (DSTR1), hl
  60+ 7CE0 2E 0B        	ld l,NAMELEN
  61+ 7CE2 22 DA 5C     	ld (NSTR1), hl
  62+ 7CE5 CF           	rst 08
  63+ 7CE6 37           	DEFB 55
  64+ 7CE7 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 7CEA DD 09        	add ix, bc
  66+ 7CEC C9           	ret
  67+ 7CED
  68+ 7CED
  69+ 7CED              ;Destroy a BDOS channel
  70+ 7CED              ;IN: IX=FCB
  71+ 7CED              DestroyChannel:
  72+ 7CED C5           	push bc
  73+ 7CEE 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 7CF1 DD 09        	add ix, bc
  75+ 7CF3 CF           	rst 08
  76+ 7CF4 38           	DEFB 56
  77+ 7CF5 C1           	pop bc
  78+ 7CF6 C9           	ret
  79+ 7CF7
  80+ 7CF7
  81+ 7CF7              ;Input: IX=FCB
  82+ 7CF7              CreateFile:
  83+ 7CF7 3E 09        	ld	a, 9
  84+ 7CF9 18 10        	jr	BDOS
  85+ 7CFB
  86+ 7CFB              ;Input: IX=FCB
  87+ 7CFB              OpenFile:
  88+ 7CFB 3E 02        	ld	a, 2
  89+ 7CFD 18 0C        	jr	BDOS
  90+ 7CFF
  91+ 7CFF              ;IN: IX=FCB
  92+ 7CFF              CloseFile:
  93+ 7CFF 3E 03        	ld	a, 3
  94+ 7D01 18 08        	jr	BDOS
  95+ 7D03
  96+ 7D03              ;IN: IX=FCB
  97+ 7D03              ReadFileBlock:
  98+ 7D03 3E 07        	ld	a, 7
  99+ 7D05 18 04        	jr	BDOS
 100+ 7D07
 101+ 7D07              ;IN: IX=FCB
 102+ 7D07              WriteFileBlock:
 103+ 7D07 3E 08        	ld	a, 8
 104+ 7D09 18 00        	jr	BDOS
 105+ 7D0B
 106+ 7D0B              ;Generic BDOS call
 107+ 7D0B              ;IX=arg, A=function
 108+ 7D0B              BDOS:
 109+ 7D0B DD 22 ED 5C  	ld (HD11), ix
 110+ 7D0F 32 EF 5C     	ld (COPIES), a
 111+ 7D12 CF           	rst 08
 112+ 7D13 39           	DEFB 57
 113+ 7D14 C9           	ret
 114+ 7D15
 115+ 7D15              ;Set DMA address for BDOS
 116+ 7D15              ;IX=DMA
 117+ 7D15              BDOSSetDMA:
 118+ 7D15 3E 0D        	ld a, 13
 119+ 7D17 18 F2        	jr BDOS
 120+ 7D19
 121+ 7D19
 122+ 7D19              ;In: HL=filename
 123+ 7D19              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 124+ 7D19              GetFileSize:
 125+ 7D19              	IFUSED
 126+ 7D19
 127+ 7D19 3A B9 7C     	ld 		a, (RWTSDrive)
 128+ 7D1C 3C           	inc		a					;Convert to BASIC drive number: 1,2
 129+ 7D1D CD D7 7C     	call	CreateChannel
 130+ 7D20
 131+ 7D20 3E 14        	ld		a, 20
 132+ 7D22 CD 0B 7D     	call	BDOS
 133+ 7D25              	;inc		a
 134+ 7D25              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 135+ 7D25
 136+ 7D25 DD 6E 21     	ld		l, (ix + FCB_R0)
 137+ 7D28 DD 66 22     	ld		h, (ix + FCB_R1)
 138+ 7D2B
 139+ 7D2B              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 140+ 7D2B 3E 01        	ld		a, 1
 141+ 7D2D BC           	cp		h
 142+ 7D2E 30 05        	jr		nc, GetFileSizeOK
 143+ 7D30 21 00 00     	ld		hl, 0
 144+ 7D33 18 08        	jr		GetFileSizeEnd
 145+ 7D35
 146+ 7D35              GetFileSizeOK:
 147+ 7D35              	;*128 == 2^7
 148+ 7D35 06 07        	ld		b, 7
 149+ 7D37              GetFileSizeMul:
 150+ 7D37 CB 15        	rl		l
 151+ 7D39 CB 14        	rl		h
 152+ 7D3B 10 FA        	djnz	GetFileSizeMul
 153+ 7D3D
 154+ 7D3D              GetFileSizeEnd:
 155+ 7D3D E5           	push	hl
 156+ 7D3E CD ED 7C     		call	DestroyChannel
 157+ 7D41 E1           	pop		hl
 158+ 7D42
 159+ 7D42 C9           	ret
 160+ 7D43              	ENDIF
 161+ 7D43
 162+ 7D43              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 163+ 7D43              ;HL=file name, A=drive
 164+ 7D43              DeleteFile:
 165+ 7D43 CD D7 7C     	call	CreateChannel
 166+ 7D46
 167+ 7D46 3E 06        	ld		a, 6
 168+ 7D48 CD 0B 7D     	call	BDOS
 169+ 7D4B
 170+ 7D4B CD ED 7C     	call	DestroyChannel
 171+ 7D4E C9           	ret
 172+ 7D4F
 173+ 7D4F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 7D4F              ;Returns A > 0 if the file exists
 175+ 7D4F              ;HL=file name, A=drive
 176+ 7D4F              DoesFileExist:
 177+ 7D4F              	IFUSED
 178+ 7D4F CD D7 7C     	call	CreateChannel
 179+ 7D52
 180+ 7D52 3E 04        	ld		a, 4
 181+ 7D54 CD 0B 7D     	call	BDOS
 182+ 7D57
 183+ 7D57 F5           	push	af
 184+ 7D58 CD ED 7C     		call	DestroyChannel
 185+ 7D5B F1           	pop		af
 186+ 7D5C C9           	ret
 187+ 7D5D              	ENDIF
 188+ 7D5D
 189+ 7D5D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 190+ 7D5D              ;IN: E0 = RO, E1 = SYS, HL=filename
 191+ 7D5D              ChangeFileAttrib:
 192+ 7D5D 3A B9 7C     	ld 		a, (RWTSDrive)
 193+ 7D60 3C           	inc		a					;Convert to BASIC drive number: 1,2
 194+ 7D61 D5           	push	de
 195+ 7D62 CD D7 7C     	call	CreateChannel
 196+ 7D65 D1           	pop		de
 197+ 7D66
 198+ 7D66 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 199+ 7D69 CB 27        	sla		a								;reset existing attribute flag
 200+ 7D6B CB 1B        	rr		e								;put wanted flag in Carry flag
 201+ 7D6D CB 1F        	rr		a								;put Carry flag in register L
 202+ 7D6F DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 203+ 7D72
 204+ 7D72 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 205+ 7D75 CB 27        	sla		a
 206+ 7D77 CB 1B        	rr		e
 207+ 7D79 CB 1F        	rr		a
 208+ 7D7B DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 209+ 7D7E
 210+ 7D7E              FileAttribSet:
 211+ 7D7E 3E 11        	ld		a, 17
 212+ 7D80 CD 0B 7D     	call	BDOS
 213+ 7D83
 214+ 7D83 CD ED 7C     	call	DestroyChannel
 215+ 7D86 C9           	ret
 216+ 7D87
 217+ 7D87              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 7D87
 219+ 7D87              ;HL=original name, DE = new name
 220+ 7D87              ;Works only on the same drive.
 221+ 7D87              RenameFile:
 222+ 7D87 3A B9 7C     	ld 		a, (RWTSDrive)
 223+ 7D8A 3C           	inc		a					;Convert to BASIC drive number: 1,2
 224+ 7D8B D5           	push	de
 225+ 7D8C CD D7 7C     	call	CreateChannel
 226+ 7D8F D1           	pop		de
 227+ 7D90
 228+ 7D90 DD E5        	push	ix					;IX == FCB
 229+ 7D92 E1           	pop		hl
 230+ 7D93 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 231+ 7D96 09           	add		hl, bc
 232+ 7D97 EB           	ex		de, hl
 233+ 7D98 3A B9 7C     	ld		a, (RWTSDrive)
 234+ 7D9B 12           	ld		(de), a
 235+ 7D9C 01 0B 00     	ld		bc, NAMELEN
 236+ 7D9F ED B0        	ldir
 237+ 7DA1
 238+ 7DA1 3E 0A        	ld		a, 10
 239+ 7DA3 CD 0B 7D     	call	BDOS
 240+ 7DA6
 241+ 7DA6 CD ED 7C     	call	DestroyChannel
 242+ 7DA9 C9           	ret
 243+ 7DAA
 244+ 7DAA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7DAA
 246+ 7DAA              ;Will copy a file from A: to B: or vice versa.
 247+ 7DAA              ;HL=source file name
 248+ 7DAA              CopyFile:
 249+ 7DAA              	;Prepare source file
 250+ 7DAA E5           	push hl
 251+ 7DAB 3A B9 7C     		ld 		a, (RWTSDrive)
 252+ 7DAE 3C           		inc		a					;Convert to BASIC drive number: 1,2
 253+ 7DAF CD D7 7C     		call	CreateChannel
 254+ 7DB2 CD FB 7C     		call 	OpenFile
 255+ 7DB5 DD 22 2A 95  		ld		(CopyFileFCBSrc), ix
 256+ 7DB9 E1           	pop hl
 257+ 7DBA 3C           	inc  	a						;Cancel if A==$FF
 258+ 7DBB 28 75        	jr   	z, CopyFileEnd
 259+ 7DBD
 260+ 7DBD              	;Create destination file
 261+ 7DBD DD 7E 00     	ld		a, (ix)
 262+ 7DC0 EE 03        	xor		%11						;Alternate drive, A->B, B-A
 263+ 7DC2 F5           	push	af
 264+ 7DC3 E5           	push	hl
 265+ 7DC4 CD 43 7D     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 266+ 7DC7 E1           	pop		hl
 267+ 7DC8 F1           	pop		af
 268+ 7DC9 CD D7 7C     	call	CreateChannel
 269+ 7DCC CD F7 7C     	call 	CreateFile
 270+ 7DCF DD 22 2C 95  	ld		(CopyFileFCBDst), ix
 271+ 7DD3 3C           	inc  	a						;Cancel if A==$FF
 272+ 7DD4 28 5C        	jr   	z, CopyFileEnd
 273+ 7DD6
 274+ 7DD6              FileCopyLoop:
 275+ 7DD6 06 69        	ld		b, MAX_SECT_RAM
 276+ 7DD8 DD 21 30 95  	ld		ix, CopyFileDMAAddr
 277+ 7DDC 21 32 95     	ld		hl, CopyFileDMA
 278+ 7DDF DD 75 00     	ld		(ix), l
 279+ 7DE2 DD 74 01     	ld		(ix+1), h
 280+ 7DE5              FileCopyReadLoop:
 281+ 7DE5 C5           	push	bc
 282+ 7DE6 DD 2A 30 95  		ld		ix, (CopyFileDMAAddr)
 283+ 7DEA CD 15 7D     		call 	BDOSSetDMA
 284+ 7DED DD 24        		inc		ixh
 285+ 7DEF DD 22 30 95  		ld		(CopyFileDMAAddr), ix
 286+ 7DF3
 287+ 7DF3 DD 2A 2A 95  		ld		ix, (CopyFileFCBSrc)
 288+ 7DF7 CD 03 7D     		call 	ReadFileBlock
 289+ 7DFA B7           		or		a
 290+ 7DFB 32 2E 95     		ld		(CopyFileResRead), a
 291+ 7DFE C1           	pop		bc
 292+ 7DFF 20 02        	jr		nz, FileCopyWrite
 293+ 7E01 10 E2        	djnz	FileCopyReadLoop
 294+ 7E03
 295+ 7E03              FileCopyWrite:
 296+ 7E03 DD 21 30 95  	ld		ix, CopyFileDMAAddr
 297+ 7E07 21 32 95     	ld		hl, CopyFileDMA
 298+ 7E0A DD 75 00     	ld		(ix), l
 299+ 7E0D DD 74 01     	ld		(ix+1), h
 300+ 7E10
 301+ 7E10              	;Calculate how many sectors were read.
 302+ 7E10 3E 69        	ld		a, MAX_SECT_RAM
 303+ 7E12 90           	sub		b
 304+ 7E13 47           	ld		b, a
 305+ 7E14
 306+ 7E14              FileCopyWriteLoop:
 307+ 7E14 C5           	push	bc
 308+ 7E15 DD 2A 30 95  		ld		ix, (CopyFileDMAAddr)
 309+ 7E19 CD 15 7D     		call 	BDOSSetDMA
 310+ 7E1C DD 24        		inc		ixh
 311+ 7E1E DD 22 30 95  		ld		(CopyFileDMAAddr), ix
 312+ 7E22
 313+ 7E22 DD 2A 2C 95  		ld		ix, (CopyFileFCBDst)
 314+ 7E26 CD 07 7D     		call	WriteFileBlock
 315+ 7E29 B7           		or		a
 316+ 7E2A 32 2F 95     		ld		(CopyFileResWrite), a
 317+ 7E2D C1           	pop		bc
 318+ 7E2E 20 02        	jr		nz, CopyFileEnd
 319+ 7E30 10 E2        	djnz	FileCopyWriteLoop
 320+ 7E32
 321+ 7E32              CopyFileEnd:
 322+ 7E32              	;Check if file ended, if not, continue copying.
 323+ 7E32 3A 2E 95     	ld		a, (CopyFileResRead)
 324+ 7E35 B7           	or		a
 325+ 7E36 28 9E        	jr		z, FileCopyLoop
 326+ 7E38
 327+ 7E38 DD 2A 2C 95  	ld		ix, (CopyFileFCBDst)
 328+ 7E3C CD FF 7C     	call 	CloseFile				;close destination file
 329+ 7E3F CD ED 7C     	call 	DestroyChannel
 330+ 7E42
 331+ 7E42              	;Don't need to close source file, but must free channel
 332+ 7E42 DD 2A 2A 95  	ld		ix, (CopyFileFCBSrc)
 333+ 7E46 CD ED 7C     	call 	DestroyChannel
 334+ 7E49
 335+ 7E49 3A 2F 95     	ld		a, (CopyFileResWrite)
 336+ 7E4C
 337+ 7E4C C9           	ret
 338+ 7E4D
 339+ 7E4D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 340+ 7E4D              ;Reads part of a file
 341+ 7E4D              ;In: HL = name, DE = file offset in bytes
 342+ 7E4D              ;Out: FileData = read buffer, DE = end of file
 343+ 7E4D              ReadFileSection:
 344+ 7E4D 3A B9 7C     	ld 		a, (RWTSDrive)
 345+ 7E50 3C           	inc		a					;Convert to BASIC drive number: 1,2
 346+ 7E51 CD D7 7C     	call	CreateChannel
 347+ 7E54 CD FB 7C     	call 	OpenFile
 348+ 7E57 DD 22 2A 95  	ld		(CopyFileFCBSrc), ix
 349+ 7E5B 3C           	inc  	a						;Cancel if A==$FF
 350+ 7E5C C8           	ret		z
 351+ 7E5D
 352+ 7E5D              	;Limit max sectors to read to leave space for the index too.
 353+ 7E5D 06 61        	ld		b, FileDataSize/SECT_SZ
 354+ 7E5F              	;Set destination memory pointer.
 355+ 7E5F DD 21 30 95  	ld		ix, CopyFileDMAAddr
 356+ 7E63 21 2A 96     	ld		hl, FileData
 357+ 7E66 DD 75 00     	ld		(ix), l
 358+ 7E69 DD 74 01     	ld		(ix+1), h
 359+ 7E6C              ReadFileSectionLoop:
 360+ 7E6C C5           	push	bc
 361+ 7E6D DD 2A 30 95  		ld		ix, (CopyFileDMAAddr)
 362+ 7E71 CD 15 7D     		call 	BDOSSetDMA
 363+ 7E74 DD 24        		inc		ixh
 364+ 7E76 DD 22 30 95  		ld		(CopyFileDMAAddr), ix
 365+ 7E7A
 366+ 7E7A DD 2A 2A 95  		ld		ix, (CopyFileFCBSrc)
 367+ 7E7E CD 03 7D     		call 	ReadFileBlock
 368+ 7E81 B7           		or		a
 369+ 7E82 32 2E 95     		ld		(CopyFileResRead), a
 370+ 7E85 C1           	pop		bc
 371+ 7E86 20 02        	jr		nz, ReadFileSectionEnd
 372+ 7E88 10 E2        	djnz	ReadFileSectionLoop
 373+ 7E8A
 374+ 7E8A              ReadFileSectionEnd:
 375+ 7E8A DD 2A 2A 95  	ld		ix, (CopyFileFCBSrc)
 376+ 7E8E CD ED 7C     	call 	DestroyChannel
 377+ 7E91
 378+ 7E91 ED 5B 30 95  	ld		de, (CopyFileDMAAddr)
 379+ 7E95 15           	dec		d
 380+ 7E96 C9           	ret
 381+ 7E97
 382+ 7E97              	ENDIF
 383+ 7E97
# file closed: bdos.asm
1297  7E97              	include "ui.asm"
# file opened: ui.asm
   1+ 7E97              ;UI related functions
   2+ 7E97
   3+ 7E97              	ifndef	_UI_
   4+ 7E97              	define	_UI_
   5+ 7E97
   6+ 7E97              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++7E97              	ifndef	_HCCFG_
   2++7E97 ~            	define	_HCCFG_
   3++7E97 ~
   4++7E97 ~            ;HC specific code, for configuration
   5++7E97 ~
   6++7E97 ~            HC_CFG_PORT			EQU	$7E
   7++7E97 ~
   8++7E97 ~            ;BASIC/CPM ROM selection
   9++7E97 ~            HC_CFG_ROM_BAS		EQU	%0
  10++7E97 ~            HC_CFG_ROM_CPM		EQU	%1
  11++7E97 ~
  12++7E97 ~            ;Address for ROM paging: 0 or $E000
  13++7E97 ~            HC_CFG_ROM_0000		EQU %00
  14++7E97 ~            HC_CFG_ROM_E000		EQU %10
  15++7E97 ~
  16++7E97 ~            ;Cfg. port Enable/Disable
  17++7E97 ~            HC_CFG_PORT_DIS		EQU %000
  18++7E97 ~            HC_CFG_PORT_EN		EQU	%100
  19++7E97 ~
  20++7E97 ~            ;Video memory bank: $4000 or $C000
  21++7E97 ~            HC_CFG_VID_4000		EQU	%0000
  22++7E97 ~            HC_CFG_VID_C000		EQU	%1000
  23++7E97 ~
  24++7E97 ~
  25++7E97 ~            ;Standar BASIC config
  26++7E97 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++7E97 ~            ;Standar CP/M config
  28++7E97 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++7E97 ~
  30++7E97 ~
  31++7E97 ~            HC_VID_BANK0		EQU	$4000
  32++7E97 ~            HC_VID_BANK1		EQU	$C000
  33++7E97 ~
  34++7E97              	endif
# file closed: hccfg.asm
   7+ 7E97
   8+ 7E97              COL             EQU 23728
   9+ 7E97              LINE            EQU 23729               ;Coordinates
  10+ 7E97              LineCol			EQU	COL
  11+ 7E97              CODE			EQU 23681               ;Char to print
  12+ 7E97
  13+ 7E97              CPM_FNT         EQU $25AB
  14+ 7E97
  15+ 7E97              PORT_ZX			EQU	$FE
  16+ 7E97
  17+ 7E97              ;COLORS
  18+ 7E97              CLR_BLACK		EQU 0
  19+ 7E97              CLR_BLUE		EQU 1
  20+ 7E97              CLR_RED			EQU 2
  21+ 7E97              CLR_MAGENTA		EQU 3
  22+ 7E97              CLR_GREEN		EQU 4
  23+ 7E97              CLR_CYAN		EQU	5
  24+ 7E97              CLR_YELLOW		EQU	6
  25+ 7E97              CLR_WHITE		EQU	7
  26+ 7E97              CLR_BRIGHT		EQU	%01000000
  27+ 7E97              CLR_FLASH		EQU	%10000000
  28+ 7E97
  29+ 7E97              ;PAPER
  30+ 7E97              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 7E97              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 7E97              PAPER_RED		EQU (CLR_RED << 3)
  33+ 7E97              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 7E97              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 7E97              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 7E97              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 7E97              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 7E97
  39+ 7E97              ;INK
  40+ 7E97              INK_BLACK		EQU CLR_BLACK
  41+ 7E97              INK_BLUE		EQU CLR_BLUE
  42+ 7E97              INK_RED			EQU CLR_RED
  43+ 7E97              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 7E97              INK_GREEN		EQU CLR_GREEN
  45+ 7E97              INK_CYAN		EQU	CLR_CYAN
  46+ 7E97              INK_YELLOW		EQU	CLR_YELLOW
  47+ 7E97              INK_WHITE		EQU	CLR_WHITE
  48+ 7E97
  49+ 7E97
  50+ 7E97              ;SCR_ATTR_ADDR	EQU 22528
  51+ 7E97              SCR_PIX_LEN		EQU	6144
  52+ 7E97              SCR_ATTR_LEN	EQU	768
  53+ 7E97              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 7E97              SCR_BYTES_PER_LINE	EQU	32
  55+ 7E97
  56+ 7E97              SCR_COLS		EQU	64
  57+ 7E97              SCR_LINES		EQU 24
  58+ 7E97
  59+ 7E97              ;used for file names list positioning
  60+ 7E97              LST_LINES_CNT	EQU	23
  61+ 7E97              LST_FIRST_LINE	EQU	0
  62+ 7E97              LST_PROG_INFO	EQU LST_FIRST_LINE
  63+ 7E97              LST_DISK_INFO	EQU LST_PROG_INFO + 6
  64+ 7E97              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  65+ 7E97              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  66+ 7E97              LST_FIRST_COL	EQU	16
  67+ 7E97              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  68+ 7E97
  69+ 7E97              ;key codes
  70+ 7E97              KEY_ESC			EQU	7
  71+ 7E97              KEY_LEFT		EQU	8
  72+ 7E97              KEY_RIGHT		EQU	9
  73+ 7E97              KEY_DOWN		EQU	10
  74+ 7E97              KEY_UP			EQU	11
  75+ 7E97              KEY_BACKSP		EQU 12
  76+ 7E97              KEY_ENTER		EQU	13
  77+ 7E97              KEY_CTRL		EQU	14
  78+ 7E97
  79+ 7E97              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  80+ 7E97              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  81+ 7E97              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  82+ 7E97
  83+ 7E97              ;Special formating chars
  84+ 7E97              CHR_CR			EQU	13
  85+ 7E97              CHR_LF			EQU	10
  86+ 7E97              CHR_TAB			EQU	09
  87+ 7E97              CHR_EOF			EQU $1A
  88+ 7E97
  89+ 7E97
  90+ 7E97              ;Semi-graphical chars
  91+ 7E97              ;           UC
  92+ 7E97              ;     UL +H-+--+UR
  93+ 7E97              ;        |  |  |
  94+ 7E97              ;     ML +--+--+MR
  95+ 7E97              ;        V C|  |
  96+ 7E97              ;     LL +--+--+LR
  97+ 7E97              ;           DC
  98+ 7E97              CHR_GRID        EQU 127
  99+ 7E97              CHR_V           EQU	128
 100+ 7E97              CHR_MR          EQU	129
 101+ 7E97              CHR_UR          EQU 130
 102+ 7E97              CHR_DL          EQU 131
 103+ 7E97              CHR_DC          EQU 132
 104+ 7E97              CHR_UC          EQU 133
 105+ 7E97              CHR_ML          EQU 134
 106+ 7E97              CHR_H           EQU 135
 107+ 7E97              CHR_C           EQU 136
 108+ 7E97              CHR_LR          EQU 137
 109+ 7E97              CHR_UL          EQU 138
 110+ 7E97              CHR_FULL        EQU 139
 111+ 7E97              CHR_HALF        EQU 140
 112+ 7E97
 113+ 7E97              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 114+ 7E97
 115+ 7E97              ;Return read char in A
 116+ 7E97              ReadChar:
 117+ 7E97 CF           	rst 08
 118+ 7E98 1B           	DEFB 27
 119+ 7E99 C9           	ret
 120+ 7E9A
 121+ 7E9A              ;Checks if a key is pressed
 122+ 7E9A              ;Cy=1 if key is pressed
 123+ 7E9A              KbdHit:
 124+ 7E9A CF           	rst 08
 125+ 7E9B 20           	DEFB 32
 126+ 7E9C C9           	ret
 127+ 7E9D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 128+ 7E9D
 129+ 7E9D              InitFonts:
 130+ 7E9D              	IFUSED
 131+ 7E9D                  ;page-in CPM ROM to get fonts
 132+ 7E9D F3               di
 133+ 7E9E 3E 01            ld a, HC_CFG_ROM_CPM
 134+ 7EA0 D3 7E            out	(HC_CFG_PORT), a
 135+ 7EA2
 136+ 7EA2 21 AB 25     	ld		hl, CPM_FNT
 137+ 7EA5 11 C2 91     	ld		de, FontTable
 138+ 7EA8 01 68 03     	ld		bc, 872
 139+ 7EAB ED B0        	ldir
 140+ 7EAD
 141+ 7EAD                  ;restore BASIC ROM
 142+ 7EAD 3E 00            ld a, HC_CFG_ROM_BAS
 143+ 7EAF D3 7E            out	(HC_CFG_PORT), a
 144+ 7EB1 FB               ei
 145+ 7EB2
 146+ 7EB2 C9           	ret
 147+ 7EB3              	ENDIF
 148+ 7EB3
 149+ 7EB3              ClrScr:
 150+ 7EB3 2A 56 80     	ld		hl, (CurrScrAddr)
 151+ 7EB6 54           	ld		d, h
 152+ 7EB7 5D           	ld		e, l
 153+ 7EB8 13           	inc		de
 154+ 7EB9 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 155+ 7EBC 36 00        	ld		(hl), 0
 156+ 7EBE ED B0        	ldir
 157+ 7EC0
 158+ 7EC0 23           	inc 	hl
 159+ 7EC1 13           	inc		de
 160+ 7EC2
 161+ 7EC2 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 162+ 7EC5 36 0F        	ld		(hl), SCR_DEF_CLR
 163+ 7EC7 ED B0        	ldir
 164+ 7EC9
 165+ 7EC9              	;also set border color
 166+ 7EC9 3E 01        	ld		a, SCR_DEF_CLR >> 3
 167+ 7ECB D3 FE        	out		(PORT_ZX), a
 168+ 7ECD
 169+ 7ECD 3E 0F        	ld		a, SCR_DEF_CLR
 170+ 7ECF 32 48 5C     	ld		(23624), a
 171+ 7ED2 C9           	ret
 172+ 7ED3
 173+ 7ED3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 7ED3              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 175+ 7ED3              PrintStr:
 176+ 7ED3 7E           	ld		a, (hl)
 177+ 7ED4 FE 20        	cp		' '
 178+ 7ED6 30 02        	jr		nc, GoodChar
 179+ 7ED8 3E 3F        	ld		a, '?'
 180+ 7EDA              GoodChar:
 181+ 7EDA CB 7F        	bit		7, a
 182+ 7EDC CB BF        	res		7, a
 183+ 7EDE 32 81 5C     	ld		(CODE), a
 184+ 7EE1 ED 53 B0 5C  	ld		(LineCol), de
 185+ 7EE5 08           	ex		af, af'
 186+ 7EE6 D9           	exx
 187+ 7EE7 E5           	push	hl
 188+ 7EE8 CD D6 7F     	call 	PrintChar
 189+ 7EEB E1           	pop		hl
 190+ 7EEC D9           	exx
 191+ 7EED 08           	ex		af, af'
 192+ 7EEE C0           	ret		nz
 193+ 7EEF
 194+ 7EEF 1C           	inc		e
 195+ 7EF0 23           	inc		hl
 196+ 7EF1
 197+ 7EF1 7B           	ld		a, e
 198+ 7EF2 FE 40        	cp		64
 199+ 7EF4 38 DD        	jr		c, PrintStr
 200+ 7EF6 1E 00        	ld		e, 0
 201+ 7EF8 14           	inc		d
 202+ 7EF9
 203+ 7EF9 18 D8        	jr		PrintStr
 204+ 7EFB
 205+ 7EFB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 206+ 7EFB
 207+ 7EFB              ;IN: HL = string, DE = coords, A = color
 208+ 7EFB              PrintStrClr:
 209+ 7EFB 32 27 7F     	ld		(StrClr), a
 210+ 7EFE D5           	push	de
 211+ 7EFF CD D3 7E     		call	PrintStr
 212+ 7F02 E1           	pop		hl
 213+ 7F03              	;get string len.
 214+ 7F03 7B           	ld		a, e
 215+ 7F04 95           	sub		l
 216+ 7F05 1F           	rra
 217+ 7F06 08           	ex		af, af'
 218+ 7F07              		;line * 32
 219+ 7F07 7C           		ld		a, h
 220+ 7F08 17           		rla
 221+ 7F09 17           		rla
 222+ 7F0A 11 00 00     		ld	de, 0
 223+ 7F0D 17           		rla
 224+ 7F0E CB 12        		rl	d
 225+ 7F10 17           		rla
 226+ 7F11 CB 12        		rl	d
 227+ 7F13 17           		rla
 228+ 7F14 CB 12        		rl	d
 229+ 7F16 5F           		ld	e, a
 230+ 7F17
 231+ 7F17 26 00        		ld		h, 0
 232+ 7F19 19           		add		hl, de
 233+ 7F1A ED 5B 58 80  		ld		de, (CurrScrAttrAddr)
 234+ 7F1E 19           		add		hl, de
 235+ 7F1F 08           	ex		af, af'
 236+ 7F20 4F           	ld		c, a
 237+ 7F21 06 00        	ld		b, 0
 238+ 7F23 54           	ld		d, h
 239+ 7F24 5D           	ld		e, l
 240+ 7F25 13           	inc 	de
 241+ 7F26              StrClr	EQU	$ + 1
 242+ 7F26 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 243+ 7F28 ED B0        	ldir
 244+ 7F2A C9           	ret
 245+ 7F2B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 246+ 7F2B
 247+ 7F2B              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 248+ 7F2B              DrawLine:
 249+ 7F2B 32 81 5C     	ld		(CODE), a
 250+ 7F2E
 251+ 7F2E 38 04        	jr		c, VertDir
 252+ 7F30 3E 1C        	ld		a, $1C
 253+ 7F32 18 02        	jr		StoreDir
 254+ 7F34              VertDir:
 255+ 7F34 3E 14        	ld		a, $14
 256+ 7F36              StoreDir:
 257+ 7F36 32 46 7F     	ld		(LineDir), a
 258+ 7F39
 259+ 7F39              DrawLineLoop:
 260+ 7F39 ED 53 B0 5C  	ld		(LineCol), de
 261+ 7F3D D5           	push	de
 262+ 7F3E D9           		exx
 263+ 7F3F E5           		push	hl
 264+ 7F40 CD D6 7F     		call 	PrintChar
 265+ 7F43 E1           		pop		hl
 266+ 7F44 D9           		exx
 267+ 7F45 D1           	pop		de
 268+ 7F46              LineDir:
 269+ 7F46 1C           	inc		e
 270+ 7F47 10 F0        	djnz	DrawLineLoop
 271+ 7F49
 272+ 7F49 C9           	ret
 273+ 7F4A
 274+ 7F4A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 275+ 7F4A
 276+ 7F4A              DrawHLine:
 277+ 7F4A 32 59 7F     	ld		(ChrParam), a
 278+ 7F4D
 279+ 7F4D 06 10        	ld		b, 16
 280+ 7F4F 3E 87        	ld		a, CHR_H
 281+ 7F51 B7           	or		a
 282+ 7F52 CD 2B 7F     	call	DrawLine
 283+ 7F55
 284+ 7F55 06 04        	ld		b, 4
 285+ 7F57              DrawUpLine:
 286+ 7F57 C5           	push	bc
 287+ 7F58              ChrParam	EQU		$ + 1
 288+ 7F58 3E 85        		ld		a, CHR_UC
 289+ 7F5A D5           		push	de
 290+ 7F5B CD 8C 7F     			call	PrintChar2
 291+ 7F5E D1           		pop		de
 292+ 7F5F 13           		inc		de
 293+ 7F60
 294+ 7F60 06 0B        		ld		b, NAMELEN
 295+ 7F62 3E 87        		ld		a, CHR_H
 296+ 7F64 B7           		or		a
 297+ 7F65 CD 2B 7F     		call	DrawLine
 298+ 7F68 C1           	pop		bc
 299+ 7F69 10 EC        	djnz	DrawUpLine
 300+ 7F6B
 301+ 7F6B 06 04        	ld		b, 4
 302+ 7F6D 3E 87        	ld		a, CHR_H
 303+ 7F6F B7           	or		a
 304+ 7F70 CD 2B 7F     	call	DrawLine
 305+ 7F73 C9           	ret
 306+ 7F74
 307+ 7F74
 308+ 7F74              DrawVLines:
 309+ 7F74 06 04        	ld		b, 4
 310+ 7F76 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 311+ 7F79              DrawVLinesLoop:
 312+ 7F79 C5           	push 	bc
 313+ 7F7A D5           	push	de
 314+ 7F7B 06 17        		ld		b, LST_LINES_CNT
 315+ 7F7D 3E 80        		ld		a, CHR_V
 316+ 7F7F 37           		scf
 317+ 7F80 CD 2B 7F     		call	DrawLine
 318+ 7F83 D1           	pop		de
 319+ 7F84 C1           	pop	bc
 320+ 7F85 7B           	ld		a, e
 321+ 7F86 C6 0C        	add		NAMELEN+1
 322+ 7F88 5F           	ld		e, a
 323+ 7F89 10 EE        	djnz	DrawVLinesLoop
 324+ 7F8B C9           	ret
 325+ 7F8C
 326+ 7F8C              PrintChar2:
 327+ 7F8C 32 81 5C     	ld		(CODE), a
 328+ 7F8F ED 53 B0 5C  	ld		(LineCol), de
 329+ 7F93
 330+ 7F93              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 331+ 7F93
 332+ 7F93              ;IN: A = color mask
 333+ 7F93              DrawCursor:
 334+ 7F93 ED 5B 3E 86  	ld	de, (CursorAddr)
 335+ 7F97 06 06        	ld	b, 	(NAMELEN + 1)/2
 336+ 7F99              DrawCursorLoop:
 337+ 7F99 12           	ld	(de), a
 338+ 7F9A 13           	inc de
 339+ 7F9B 10 FC        	djnz DrawCursorLoop
 340+ 7F9D C9           	ret
 341+ 7F9E
 342+ 7F9E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 343+ 7F9E
 344+ 7F9E              ;IN:	A = file idx.
 345+ 7F9E              MoveCursor:
 346+ 7F9E              	;File idx / SCR_LINES => cursor line & column
 347+ 7F9E 6F           	ld		l, a
 348+ 7F9F 26 00        	ld		h, 0
 349+ 7FA1 0E 17        	ld		c, LST_LINES_CNT
 350+ 7FA3 CD B2 79     	call	Div					;HL = file column, A = line
 351+ 7FA6
 352+ 7FA6              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 353+ 7FA6 C6 00        	add		LST_FIRST_LINE
 354+ 7FA8
 355+ 7FA8
 356+ 7FA8 54           	ld d, h
 357+ 7FA9 5D           	ld e, l
 358+ 7FAA 21 00 00     	ld	hl, 0
 359+ 7FAD
 360+ 7FAD              	;line*32
 361+ 7FAD 17           	rla
 362+ 7FAE 17           	rla
 363+ 7FAF 17           	rla
 364+ 7FB0 17           	rla
 365+ 7FB1 CB 14        	rl h
 366+ 7FB3 17           	rla
 367+ 7FB4 CB 14        	rl h
 368+ 7FB6 6F           	ld l, a
 369+ 7FB7
 370+ 7FB7
 371+ 7FB7              	;col * 6
 372+ 7FB7 E5           	push	hl					;save line * 32
 373+ 7FB8 3E 06        		ld		a, (NAMELEN + 1)/2
 374+ 7FBA CD D2 79     		call	Mul				;HL = column * 12/2
 375+ 7FBD D1           	pop		de
 376+ 7FBE 19           	add		hl, de
 377+ 7FBF
 378+ 7FBF 11 08 00     	ld		de, LST_FIRST_COL/2
 379+ 7FC2 ED 4B 58 80  	ld		bc, (CurrScrAttrAddr)
 380+ 7FC6 19           	add		hl, de
 381+ 7FC7 09           	add		hl, bc
 382+ 7FC8
 383+ 7FC8              	;clear old cursor
 384+ 7FC8 3E 0F        	ld		a, SCR_DEF_CLR
 385+ 7FCA CD 93 7F     	call	DrawCursor
 386+ 7FCD
 387+ 7FCD              	;draw new one
 388+ 7FCD 22 3E 86     	ld		(CursorAddr), hl
 389+ 7FD0 3E 28        	ld		a, SCR_SEL_CLR
 390+ 7FD2 CD 93 7F     	call	DrawCursor
 391+ 7FD5
 392+ 7FD5 C9           	ret
 393+ 7FD6
 394+ 7FD6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 395+ 7FD6
 396+ 7FD6              PrintChar:
 397+ 7FD6 ED 5B B0 5C      ld		de, (LineCol)
 398+ 7FDA
 399+ 7FDA                  ;calculate 64 column screen address
 400+ 7FDA              	;IN: D = line, E = col
 401+ 7FDA              	;OUT: HL = screen address
 402+ 7FDA
 403+ 7FDA CB 3B            SRL     E                                       ;col = col/2
 404+ 7FDC CB 19            RR      C                                       ;mark odd/even column
 405+ 7FDE 7A               LD      A, D                            ;A = line
 406+ 7FDF E6 18            AND 24                                  ;keep only %00011000
 407+ 7FE1 2A 56 80         ld		hl, (CurrScrAddr)
 408+ 7FE4 B4               OR      h								;add screen start address
 409+ 7FE5 67               LD      H, A                            ;save H
 410+ 7FE6 7A               LD      A, D                            ;A = line
 411+ 7FE7 E6 07            AND 7                                   ;keep only %00000111
 412+ 7FE9 0F               RRCA                                    ;%10000011
 413+ 7FEA 0F               RRCA                                    ;%11000001
 414+ 7FEB 0F               RRCA                                    ;%11100000
 415+ 7FEC B3               OR      E                                       ;add column
 416+ 7FED 6F               LD      L, A                            ;HL = screen address
 417+ 7FEE
 418+ 7FEE              PrintChar3:
 419+ 7FEE                  ;get font address
 420+ 7FEE E5               PUSH HL
 421+ 7FEF AF                   XOR A
 422+ 7FF0 67                   LD  H, A
 423+ 7FF1 3A 81 5C             LD  A, (CODE)
 424+ 7FF4 D6 20                SUB ' '
 425+ 7FF6 6F                   LD  L, A
 426+ 7FF7 29                   ADD     HL, HL                  ;char code = char code * 8
 427+ 7FF8 29                   ADD     HL, HL                  ;i.e. offset into font table
 428+ 7FF9 29                   ADD     HL, HL
 429+ 7FFA 11 C2 91             LD      DE, FontTable             ;get font table
 430+ 7FFD 19                   ADD     HL, DE
 431+ 7FFE EB                   EX      DE, HL                  ;DE = our char font address
 432+ 7FFF E1               POP     HL
 433+ 8000
 434+ 8000
 435+ 8000                  ;print a char
 436+ 8000 06 08            LD      B, 8                            ;char height is 8 lines
 437+ 8002              PrintCharLine:
 438+ 8002 1A                   LD      A, (DE)                         ;load char line in A
 439+ 8003
 440+ 8003 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 441+ 8005 20 06                JR  	NZ, NoTurn
 442+ 8007
 443+ 8007 07                   RLCA
 444+ 8008 07                   RLCA
 445+ 8009 07                   RLCA
 446+ 800A 07                   RLCA
 447+ 800B 18 01                JR      Store
 448+ 800D              NoTurn:
 449+ 800D B6                   OR (HL)
 450+ 800E              Store:
 451+ 800E 77                   LD (HL), A
 452+ 800F
 453+ 800F 13                   INC     DE                                      ;next char line in font table
 454+ 8010 24                   INC     H                                       ;next char line on screen
 455+ 8011 10 EF            DJNZ PrintCharLine                  ;last line of char?
 456+ 8013
 457+ 8013 C9               ret
 458+ 8014
 459+ 8014              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 460+ 8014
 461+ 8014              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 462+ 8014              ReadString:
 463+ 8014 21 2A 95     	ld		hl, DataBuf
 464+ 8017 D5           	push	de
 465+ 8018 DD E1        	pop		ix
 466+ 801A
 467+ 801A              ReadStringLoop:
 468+ 801A D5           	push	de
 469+ 801B E5           	push	hl
 470+ 801C CD 97 7E     		call ReadChar
 471+ 801F E1           	pop		hl
 472+ 8020 D1           	pop		de
 473+ 8021
 474+ 8021 FE 0D        	cp	KEY_ENTER
 475+ 8023 C8           	ret z
 476+ 8024
 477+ 8024 FE 0C        	cp  KEY_BACKSP
 478+ 8026 20 0F        	jr	nz, ReadStrChar
 479+ 8028
 480+ 8028 E5           	push hl
 481+ 8029 01 2B 95     	ld   bc, DataBuf+1
 482+ 802C ED 42        	sbc	 hl, bc
 483+ 802E E1           	pop  hl
 484+ 802F 38 16        	jr   c, ReadStrPrint
 485+ 8031
 486+ 8031 1B           	dec	de
 487+ 8032 2B           	dec	hl
 488+ 8033 36 20        	ld	(hl), ' '
 489+ 8035 18 10        	jr	ReadStrPrint
 490+ 8037
 491+ 8037              ReadStrChar:
 492+ 8037 FE 20        	cp	' '
 493+ 8039 38 DF        	jr	c, ReadStringLoop
 494+ 803B FE 7F        	cp  127
 495+ 803D 30 DB        	jr	nc, ReadStringLoop
 496+ 803F
 497+ 803F              	;Check end of string and go back if found.
 498+ 803F 46           	ld	b, (hl)
 499+ 8040 CB 78        	bit 7, b
 500+ 8042 20 03        	jr	nz, ReadStrPrint
 501+ 8044
 502+ 8044 77           	ld	(hl), a
 503+ 8045 23           	inc	hl
 504+ 8046 13           	inc	de
 505+ 8047
 506+ 8047              ReadStrPrint:
 507+ 8047 E5           	push	hl
 508+ 8048 D5           	push	de
 509+ 8049 21 2A 95     	ld		hl, DataBuf
 510+ 804C DD E5        	push	ix
 511+ 804E D1           	pop		de
 512+ 804F CD D3 7E     	call	PrintStr
 513+ 8052 D1           	pop		de
 514+ 8053 E1           	pop		hl
 515+ 8054
 516+ 8054 18 C4        	jr		ReadStringLoop
 517+ 8056
 518+ 8056 00 40        CurrScrAddr		DEFW	16384
 519+ 8058 00 58        CurrScrAttrAddr	DEFW	22528
 520+ 805A
 521+ 805A                 	endif
# file closed: ui.asm
1298  805A              	include "math.asm"
# file opened: math.asm
   1+ 805A              	ifndef	_MATH_
   2+ 805A ~            	define	_MATH_
   3+ 805A ~
   4+ 805A ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 805A ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 805A ~
   7+ 805A ~
   8+ 805A ~            Word2Txt:
   9+ 805A ~            	IFUSED
  10+ 805A ~            	push	de
  11+ 805A ~            		call	Word2Txt_
  12+ 805A ~            	pop		de
  13+ 805A ~
  14+ 805A ~            	ld		b, 4
  15+ 805A ~            	call	StrippLeading0
  16+ 805A ~            	ret
  17+ 805A ~
  18+ 805A ~            Byte2Txt:
  19+ 805A ~            	push	de
  20+ 805A ~            		call	Byte2Txt_
  21+ 805A ~            	pop		de
  22+ 805A ~
  23+ 805A ~            	ld		b, 2
  24+ 805A ~            	call	StrippLeading0
  25+ 805A ~            	ret
  26+ 805A ~            	ENDIF
  27+ 805A ~
  28+ 805A ~
  29+ 805A ~            StrippLeading0:
  30+ 805A ~            	ld		a, (de)
  31+ 805A ~            	cp		'1'
  32+ 805A ~            	ret		nc
  33+ 805A ~
  34+ 805A ~            	ld		a, ' '
  35+ 805A ~            	ld		(de), a
  36+ 805A ~            	inc		de
  37+ 805A ~            	djnz	StrippLeading0
  38+ 805A ~            	ret
  39+ 805A ~
  40+ 805A ~
  41+ 805A ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 805A ~            Word2Txt_:
  43+ 805A ~            	ld bc, -10000
  44+ 805A ~            	call DigitLoop
  45+ 805A ~            	ld bc, -1000
  46+ 805A ~            	call DigitLoop
  47+ 805A ~            Byte2Txt_:
  48+ 805A ~            	ld bc, -100
  49+ 805A ~            	call DigitLoop
  50+ 805A ~            	ld bc, -10
  51+ 805A ~            	call DigitLoop
  52+ 805A ~            	ld bc, -1
  53+ 805A ~
  54+ 805A ~            DigitLoop:
  55+ 805A ~            	ld	a, '0' - 1
  56+ 805A ~            DivNrLoop:
  57+ 805A ~            	inc	a			;increase reminder
  58+ 805A ~            	add	hl, bc		;substract divizor
  59+ 805A ~            	jr	c, DivNrLoop	;still dividing?
  60+ 805A ~            	sbc	hl, bc		;nope, restore
  61+ 805A ~
  62+ 805A ~            	ld (de), a
  63+ 805A ~            	inc de
  64+ 805A ~            	ret
  65+ 805A ~
  66+ 805A ~
  67+ 805A ~            ;Input: HL = Dividend, C = Divisor
  68+ 805A ~            ;Output: HL = Quotient, A = Remainder
  69+ 805A ~            ;Warning: doesn't work with divisor >= $80
  70+ 805A ~            Div:
  71+ 805A ~            	IFUSED
  72+ 805A ~            	xor a
  73+ 805A ~            	ld b, 16
  74+ 805A ~
  75+ 805A ~            DivLoop:
  76+ 805A ~            	add	hl,hl
  77+ 805A ~            	rla
  78+ 805A ~            	cp	c
  79+ 805A ~            	jr	c, NoSub
  80+ 805A ~            	sub	c
  81+ 805A ~            	inc	l
  82+ 805A ~            NoSub:
  83+ 805A ~            	djnz DivLoop
  84+ 805A ~
  85+ 805A ~            	ret
  86+ 805A ~            	ENDIF
  87+ 805A ~
  88+ 805A ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 805A ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 805A ~            Div2:
  91+ 805A ~            	ld hl, 0
  92+ 805A ~            	ld b, 16
  93+ 805A ~            Div2Loop:
  94+ 805A ~            	sll c		; unroll 16 times
  95+ 805A ~            	rla			; ...
  96+ 805A ~            	adc	hl,hl		; ...
  97+ 805A ~            	sbc	hl,de		; ...
  98+ 805A ~            	jr	nc,$+4		; ...
  99+ 805A ~            	add	hl,de		; ...
 100+ 805A ~            	dec	c		; ...
 101+ 805A ~            	djnz Div2Loop
 102+ 805A ~            	ret
 103+ 805A ~
 104+ 805A ~
 105+ 805A ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 805A ~            ;Output: A:HL = Product
 107+ 805A ~            Mul:
 108+ 805A ~            	IFUSED
 109+ 805A ~            	ld hl, 0
 110+ 805A ~            	ld bc, $0700
 111+ 805A ~
 112+ 805A ~            	add	a, a		; optimised 1st iteration
 113+ 805A ~            	jr	nc, MulLoop
 114+ 805A ~            	ld	h, d
 115+ 805A ~            	ld	l, e
 116+ 805A ~
 117+ 805A ~            MulLoop:
 118+ 805A ~            	add	hl,hl
 119+ 805A ~            	rla
 120+ 805A ~            	jr	nc, NoAdd
 121+ 805A ~            	add	hl,de
 122+ 805A ~            	adc	a,c
 123+ 805A ~            NoAdd:
 124+ 805A ~            	djnz MulLoop
 125+ 805A ~
 126+ 805A ~            	ret
 127+ 805A ~            	ENDIF
 128+ 805A ~
 129+ 805A              	endif
# file closed: math.asm
1299  805A              	include "txtview.asm"
# file opened: txtview.asm
   1+ 805A              ; 	DEVICE ZXSPECTRUM48
   2+ 805A
   3+ 805A              LINE_CNT	EQU	23
   4+ 805A              COL_CNT		EQU	64
   5+ 805A
   6+ 805A              CHAR_CR		EQU	$0D
   7+ 805A              CHAR_LF		EQU	$0A
   8+ 805A              CHAR_TAB	EQU	$09
   9+ 805A              EOF_MARKER		EQU	$1A
  10+ 805A
  11+ 805A              COORDS		EQU	23728		;Coordinates
  12+ 805A
  13+ 805A
  14+ 805A              InitViewer:
  15+ 805A 22 A6 83     	ld		 (FileBegin), hl
  16+ 805D 09           	add		hl, bc
  17+ 805E              	;must filter any EOF chars, max 256 of them.
  18+ 805E 25           	dec		h
  19+ 805F 3E 1A        	ld		a, EOF_MARKER
  20+ 8061 ED B1        	cpir
  21+ 8063 2B           	dec		hl
  22+ 8064 22 AA 83     	ld		(FileEnd), hl
  23+ 8067 ED 5B A6 83  	ld		de, (FileBegin)
  24+ 806B B7           	or		a
  25+ 806C ED 52        	sbc		hl, de
  26+ 806E 22 A8 83     	ld		(FileLen), hl
  27+ 8071
  28+ 8071 3E 0D        	ld		a, CHAR_CR
  29+ 8073 77           	ld		(hl), a
  30+ 8074
  31+ 8074
  32+ 8074 21 04 02     	ld		hl, (2 << 8) | 4
  33+ 8077 22 09 5C     	ld		(23561), hl
  34+ 807A
  35+ 807A 21 00 00     	ld		hl, 0
  36+ 807D 22 B0 5C     	ld		(COORDS), hl
  37+ 8080
  38+ 8080 21 00 58     	ld		hl, 16384 + 6144
  39+ 8083 54           	ld		d, h
  40+ 8084 5D           	ld		e, l
  41+ 8085 13           	inc		de
  42+ 8086 01 FF 02     	ld		bc, 767
  43+ 8089 36 0F        	ld		(hl), (1 << 3) | 7
  44+ 808B ED B0        	ldir
  45+ 808D
  46+ 808D CD AC 82     	call	ScrollInit
  47+ 8090
  48+ 8090 11 00 00     	ld		de, 0
  49+ 8093 ED 53 A1 83  	ld		(CurLine), de
  50+ 8097
  51+ 8097              	;prepare file progress %
  52+ 8097 2A A8 83     	ld		hl, (FileLen)
  53+ 809A 7C           	ld		a, h
  54+ 809B 4D           	ld		c, l
  55+ 809C 11 64 00     	ld		de, 100
  56+ 809F CD BF 79     	call	Div2
  57+ 80A2 67           	ld		h, a
  58+ 80A3 69           	ld		l, c
  59+ 80A4 22 AC 83     	ld		(PROGR_PERC), hl
  60+ 80A7
  61+ 80A7 CD 3B 82     	call	PrintMsg
  62+ 80AA
  63+ 80AA DD 21 28 F7  	ld		ix, FileIdx	- 2
  64+ 80AE 06 17        	ld		b, LINE_CNT
  65+ 80B0 2A A6 83     	ld		hl, (FileBegin)
  66+ 80B3
  67+ 80B3 C9           	ret
  68+ 80B4
  69+ 80B4              PrintLoop:
  70+ 80B4 C5           	push	bc
  71+ 80B5 DD 23        		inc		ix
  72+ 80B7 DD 23        		inc		ix
  73+ 80B9 DD 75 00     		ld		(ix), l
  74+ 80BC DD 74 01     		ld		(ix + 1), h
  75+ 80BF
  76+ 80BF CD D6 81     		call	GetLine
  77+ 80C2 CD A8 81     		call	PrintLine
  78+ 80C5
  79+ 80C5 ED 5B A1 83  		ld		de, (CurLine)
  80+ 80C9 13           		inc		de
  81+ 80CA ED 53 A1 83  		ld		(CurLine), de
  82+ 80CE C1           	pop		bc
  83+ 80CF CD 9D 81     	call	CheckEnd
  84+ 80D2 28 13        	jr		z, EOF
  85+ 80D4
  86+ 80D4 10 DE        	djnz	PrintLoop
  87+ 80D6 18 17        	jr		PrintLoop2
  88+ 80D8
  89+ 80D8              GetKey:
  90+ 80D8 76           	halt
  91+ 80D9 FD CB 01 6E  	bit		5, (iy + 1);
  92+ 80DD 28 F9        	jr		z, GetKey
  93+ 80DF FD CB 01 AE  	res		5, (iy + 1)
  94+ 80E3 FD 7E CE     	ld		a, (iy - $32)
  95+ 80E6 C9           	ret
  96+ 80E7
  97+ 80E7              EOF:
  98+ 80E7 CD D8 80     	call	GetKey
  99+ 80EA FE 30        	cp		'0'
 100+ 80EC 20 F9        	jr		nz, EOF
 101+ 80EE C9           	ret
 102+ 80EF
 103+ 80EF              PrintLoop2:
 104+ 80EF CD 3B 82     	call	PrintMsg
 105+ 80F2
 106+ 80F2 CD D8 80     	call	GetKey
 107+ 80F5 FE 30        	cp		'0'					;Exit on 0
 108+ 80F7 C8           	ret		z
 109+ 80F8
 110+ 80F8 FE 0A        	cp		KEY_DOWN
 111+ 80FA 28 5C        	jr		z, Down
 112+ 80FC
 113+ 80FC FE 0B        	cp		KEY_UP
 114+ 80FE 28 2D        	jr		z, Up
 115+ 8100
 116+ 8100 FE 32        	cp		'2'
 117+ 8102 20 EB        	jr		nz, PrintLoop2
 118+ 8104
 119+ 8104 3A A5 83     	ld		a, (WrapFlag)
 120+ 8107 EE 01        	xor		1
 121+ 8109 32 A5 83     	ld		(WrapFlag), a
 122+ 810C B7           	or		a
 123+ 810D 28 0F        	jr		z, NoWrap
 124+ 810F
 125+ 810F 11 4F 6E     	ld		de, 'nO'
 126+ 8112 ED 53 57 83  	ld		(MsgLineWrF), de
 127+ 8116 3E 20        	ld		a, ' '
 128+ 8118 32 59 83     	ld		(MsgLineWrF + 2), a
 129+ 811B C3 EF 80     	jp		PrintLoop2
 130+ 811E
 131+ 811E              NoWrap:
 132+ 811E 11 4F 66     	ld		de, 'fO'
 133+ 8121 ED 53 57 83  	ld		(MsgLineWrF), de
 134+ 8125 3E 66        	ld		a, 'f'
 135+ 8127 32 59 83     	ld		(MsgLineWrF + 2), a
 136+ 812A
 137+ 812A C3 EF 80     	jp		PrintLoop2
 138+ 812D
 139+ 812D
 140+ 812D              Up:
 141+ 812D CD 8D 81     	call	CheckBegin
 142+ 8130 28 BD        	jr		z, PrintLoop2
 143+ 8132
 144+ 8132 CD DA 82     	call	ScrollUp
 145+ 8135
 146+ 8135 DD 2B        	dec		ix
 147+ 8137 DD 2B        	dec		ix
 148+ 8139 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 149+ 813C DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 150+ 813F CD D6 81     	call	GetLine						;extract previous line to display
 151+ 8142
 152+ 8142 11 00 00     	ld		de, 0
 153+ 8145 ED 53 B0 5C  	ld		(COORDS), de
 154+ 8149 CD A8 81     	call	PrintLine
 155+ 814C
 156+ 814C 2A A1 83     	ld		hl, (CurLine)
 157+ 814F 2B           	dec		hl
 158+ 8150 22 A1 83     	ld		(CurLine), hl
 159+ 8153 CD 3B 82     	call	PrintMsg
 160+ 8156 18 97        	jr		PrintLoop2
 161+ 8158
 162+ 8158
 163+ 8158              Down:
 164+ 8158 DD 6E 00     	ld		l, (ix)
 165+ 815B DD 66 01     	ld		h, (ix + 1)
 166+ 815E CD D6 81     	call	GetLine						;get next line pointer
 167+ 8161
 168+ 8161 CD 9D 81     	call	CheckEnd					;check if HL == file end
 169+ 8164 38 89        	jr		c, PrintLoop2
 170+ 8166
 171+ 8166 DD 23        	inc		ix								;save next line pointer
 172+ 8168 DD 23        	inc		ix
 173+ 816A DD 75 00     	ld		(ix), l
 174+ 816D DD 74 01     	ld		(ix + 1), h
 175+ 8170
 176+ 8170 CD D6 81     	call	GetLine						;extract next line in buffer for display
 177+ 8173
 178+ 8173 CD DF 82     	call	ScrollDown
 179+ 8176
 180+ 8176 11 00 16     	ld		de, (LINE_CNT-1) << 8
 181+ 8179 ED 53 B0 5C  	ld		(COORDS), de
 182+ 817D CD A8 81     	call	PrintLine
 183+ 8180
 184+ 8180 2A A1 83     	ld		hl, (CurLine)
 185+ 8183 23           	inc		hl
 186+ 8184 22 A1 83     	ld		(CurLine), hl
 187+ 8187 CD 3B 82     	call	PrintMsg
 188+ 818A
 189+ 818A C3 EF 80     	jp		PrintLoop2
 190+ 818D
 191+ 818D
 192+ 818D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 818D              ;check begining of buffer
 194+ 818D              CheckBegin:
 195+ 818D E5           	push	hl
 196+ 818E DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 197+ 8191 DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 198+ 8194 ED 5B A6 83  		ld		de, (FileBegin)
 199+ 8198 B7           		or		a
 200+ 8199 ED 52        		sbc		hl, de
 201+ 819B E1           	pop		hl
 202+ 819C C9           	ret
 203+ 819D
 204+ 819D              ;check end of buffer
 205+ 819D              CheckEnd:
 206+ 819D E5           	push	hl
 207+ 819E ED 5B AA 83  		ld		de, (FileEnd)
 208+ 81A2 EB           		ex		de, hl
 209+ 81A3 B7           		or		a
 210+ 81A4 ED 52        		sbc		hl, de
 211+ 81A6 E1           	pop		hl
 212+ 81A7 C9           	ret
 213+ 81A8
 214+ 81A8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 215+ 81A8              ;Print a line
 216+ 81A8              PrintLine:
 217+ 81A8 11 61 83     	ld		de, LineBuf
 218+ 81AB 06 40        	ld		b, COL_CNT
 219+ 81AD
 220+ 81AD CD BC 81     	call	PrintStrTxt
 221+ 81B0
 222+ 81B0              	;go to the next screen line
 223+ 81B0 ED 5B B0 5C  	ld		de, (COORDS)
 224+ 81B4 14           	inc		d
 225+ 81B5 1E 00        	ld		e, 0
 226+ 81B7 ED 53 B0 5C  	ld		(COORDS), de
 227+ 81BB C9           	ret
 228+ 81BC
 229+ 81BC              PrintStrTxt:
 230+ 81BC 1A           	ld		a, (de)
 231+ 81BD 13           	inc		de
 232+ 81BE D5           	push	de
 233+ 81BF 32 81 5C     		ld		(CODE), a
 234+ 81C2 C5           		push	bc
 235+ 81C3 E5           			push	hl
 236+ 81C4 CD D6 7F     				call	PrintChar
 237+ 81C7 E1           			pop		hl
 238+ 81C8 C1           		pop		bc
 239+ 81C9
 240+ 81C9 ED 5B B0 5C  		ld		de, (COORDS)
 241+ 81CD 1C           		inc		e
 242+ 81CE ED 53 B0 5C  		ld		(COORDS), de
 243+ 81D2 D1           	pop		de
 244+ 81D3 10 E7        	djnz	PrintStrTxt
 245+ 81D5 C9           	ret
 246+ 81D6
 247+ 81D6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 248+ 81D6              ;Extract a line of text to fit exactly on a 64 screen line
 249+ 81D6              ;IN:	HL = current file pointer
 250+ 81D6              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 251+ 81D6              GetLine:
 252+ 81D6 11 61 83     	ld		de, LineBuf
 253+ 81D9 06 40        	ld		b, COL_CNT
 254+ 81DB              GetLineLoop:
 255+ 81DB 7E           	ld		a, (hl)
 256+ 81DC 23           	inc		hl
 257+ 81DD
 258+ 81DD FE 0D        	cp		CHAR_CR
 259+ 81DF 28 29        	jr		z, GetLineSkip0A
 260+ 81E1
 261+ 81E1 FE 0A        	cp		CHAR_LF
 262+ 81E3 28 25        	jr		z, GetLineSkip0A
 263+ 81E5
 264+ 81E5 FE 09        	cp		CHAR_TAB
 265+ 81E7 20 07        	jr		nz, GetLineNext
 266+ 81E9
 267+ 81E9 3E 20        	ld		a, ' '
 268+ 81EB 12           	ld		(de), a
 269+ 81EC 13           	inc		de
 270+ 81ED 05           	dec		b
 271+ 81EE 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 272+ 81F0
 273+ 81F0              GetLineNext:
 274+ 81F0 FE 20        	cp		' '
 275+ 81F2 38 06        	jr		c, NotValid
 276+ 81F4
 277+ 81F4 FE 80        	cp		128
 278+ 81F6 30 02        	jr		nc, NotValid
 279+ 81F8 18 03        	jr		Valid
 280+ 81FA
 281+ 81FA              NotValid:
 282+ 81FA CD 8A 82     	call	ReplaceChars
 283+ 81FD
 284+ 81FD              Valid:
 285+ 81FD 12           	ld		(de), a
 286+ 81FE 13           	inc		de
 287+ 81FF 10 DA        	djnz	GetLineLoop
 288+ 8201
 289+ 8201              ;if line is exactly 64 char long, must skip the new line char(s)
 290+ 8201              GetLineSkip0D:
 291+ 8201 0E 00        	ld		c, 0
 292+ 8203 3E 0D        	ld		a, CHAR_CR						;skip 0D
 293+ 8205 BE           	cp		(hl)
 294+ 8206 20 02        	jr		nz, GetLineSkip0A
 295+ 8208 23           	inc		hl
 296+ 8209 0C           	inc		c
 297+ 820A
 298+ 820A              GetLineSkip0A:						;skip 0A
 299+ 820A 3E 0A        	ld		a, CHAR_LF
 300+ 820C BE           	cp		(hl)
 301+ 820D 20 02        	jr		nz, GetLineFill
 302+ 820F 23           	inc		hl
 303+ 8210 0C           	inc		c
 304+ 8211
 305+ 8211              GetLineFill:
 306+ 8211 78           	ld		a, b
 307+ 8212 B7           	or		a
 308+ 8213 20 1F        	jr		nz, GetLineFillLoop
 309+ 8215
 310+ 8215 79           	ld		a, c
 311+ 8216 B7           	or		a
 312+ 8217 C0           	ret		nz
 313+ 8218
 314+ 8218              	;wrap or not
 315+ 8218 3A A5 83     	ld		a, (WrapFlag)
 316+ 821B B7           	or		a
 317+ 821C C0           	ret		nz
 318+ 821D
 319+ 821D ED 5B AA 83  	ld		de, (FileEnd)
 320+ 8221 E5           	push	hl
 321+ 8222 EB           	ex		de, hl
 322+ 8223 B7           	or		a
 323+ 8224 ED 52        	sbc		hl, de
 324+ 8226 44           	ld		b, h
 325+ 8227 4D           	ld		c, l
 326+ 8228 3E 0D        	ld		a, CHAR_CR
 327+ 822A E1           	pop		hl
 328+ 822B ED B1        	cpir
 329+ 822D C0           	ret		nz
 330+ 822E 3E 0A        	ld		a, CHAR_LF
 331+ 8230 BE           	cp		(hl)
 332+ 8231 C0           	ret		nz
 333+ 8232 23           	inc		hl
 334+ 8233
 335+ 8233 C9           	ret
 336+ 8234
 337+ 8234              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 338+ 8234 3E 20        	ld		a, ' '
 339+ 8236 12           	ld		(de), a
 340+ 8237 13           	inc		de
 341+ 8238 10 FA        	djnz	GetLineFillLoop
 342+ 823A C9           	ret
 343+ 823B
 344+ 823B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 345+ 823B              PrintMsg:
 346+ 823B ED 5B B0 5C  	ld		de, (COORDS)
 347+ 823F D5           	push	de
 348+ 8240 11 00 17     	ld		de, LINE_CNT<<8
 349+ 8243 ED 53 B0 5C  	ld		(COORDS), de
 350+ 8247
 351+ 8247              	;Get current file pointer
 352+ 8247 DD 6E 00     	ld		l, (ix)
 353+ 824A DD 66 01     	ld		h, (ix + 1)
 354+ 824D ED 4B A6 83  	ld		bc, (FileBegin)
 355+ 8251 B7           	or		a
 356+ 8252 ED 42        	sbc		hl, bc
 357+ 8254
 358+ 8254              	;Divide by one percent length
 359+ 8254 7C           	ld		a, h
 360+ 8255 4D           	ld		c, l
 361+ 8256 ED 5B AC 83  	ld		de, (PROGR_PERC)
 362+ 825A CD BF 79     	call	Div2
 363+ 825D
 364+ 825D              	;Display %
 365+ 825D 11 3D 83     	ld		de, MsgLinePr
 366+ 8260 67           	ld		h, a
 367+ 8261 69           	ld		l, c
 368+ 8262 CD 76 79     	call	Byte2Txt
 369+ 8265
 370+ 8265
 371+ 8265 2A A1 83     	ld		hl, (CurLine)
 372+ 8268 11 49 83     	ld		de, MsgLineNo
 373+ 826B CD 6B 79     	call	Word2Txt
 374+ 826E
 375+ 826E 11 34 83     	ld		de, MsgLine
 376+ 8271 06 2D        	ld		b, MsgLineLen
 377+ 8273 CD BC 81     	call	PrintStrTxt
 378+ 8276 D1           	pop		de
 379+ 8277 ED 53 B0 5C  	ld		(COORDS), DE
 380+ 827B
 381+ 827B 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 382+ 827E 54           	ld		d, h
 383+ 827F 5D           	ld		e, l
 384+ 8280 13           	inc		de
 385+ 8281 3E 28        	ld		a, (5 << 3) | 0
 386+ 8283 77           	ld		(hl), a
 387+ 8284 01 1F 00     	ld		bc, 31
 388+ 8287 ED B0        	ldir
 389+ 8289 C9           	ret
 390+ 828A
 391+ 828A
 392+ 828A              ReplaceChars:
 393+ 828A E5           	push	hl
 394+ 828B C5           	push	bc
 395+ 828C 21 1A 83     		ld		hl, CharReplaceTbl
 396+ 828F 06 0D        		ld		b, CharReplTblLen
 397+ 8291              ReplaceSGCLoop:
 398+ 8291 BE           		cp		(hl)
 399+ 8292 28 09        		jr		z, ReplaceMatch
 400+ 8294 23           		inc		hl
 401+ 8295 23           		inc		hl
 402+ 8296 10 F9        		djnz	ReplaceSGCLoop
 403+ 8298
 404+ 8298 3E 3F        		ld		a, '?'
 405+ 829A C1           		pop		bc
 406+ 829B E1           		pop		hl
 407+ 829C C9           	ret
 408+ 829D
 409+ 829D              ReplaceMatch:
 410+ 829D 23           		inc		hl
 411+ 829E 7E           		ld		a, (hl)
 412+ 829F C1           	pop		bc
 413+ 82A0 E1           	pop		hl
 414+ 82A1 C9           	ret
 415+ 82A2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 416+ 82A2
 417+ 82A2              	include	"scroll.asm"
# file opened: scroll.asm
   1++82A2              ;Scrolling routines for UP/DOWN
   2++82A2              ;They use 2 tables of pointers of screen cell rows.
   3++82A2              ;One table has addresses in increasing order, for scroll down,
   4++82A2              ;the other in decreasing order, for scroll up, so the same
   5++82A2              ;scroll routine is used in both cases.
   6++82A2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++82A2
   8++82A2              ; Char Down
   9++82A2              ; Adjusts screen address HL to move eight pixels down on the display.
  10++82A2              ; enter: HL = valid screen address
  11++82A2              ; exit : HL = moves one character down
  12++82A2              ; used : AF, HL
  13++82A2              GetCellDown:
  14++82A2 7D           	ld a,l
  15++82A3 C6 20        	add a,$20
  16++82A5 6F           	ld l,a
  17++82A6 D0           	ret nc
  18++82A7 7C           	ld a,h
  19++82A8 C6 08        	add a,$08
  20++82AA 67           	ld h,a
  21++82AB C9           	ret
  22++82AC
  23++82AC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++82AC              ;Fills the two tables with pointers.
  25++82AC              ScrollInit:
  26++82AC 21 00 40     	ld		hl, 16384
  27++82AF 06 17        	ld		b, LINE_CNT
  28++82B1              FillScrLinesLoop:
  29++82B1              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++82B1 22 00 5B     	ld		(SCRLinesDown), hl
  31++82B4              	;inc. pointer in destination table (of pointers to lines)
  32++82B4 ED 5B B2 82  	ld		de, (FillScrLinesPtr)
  33++82B8 13           	inc		de
  34++82B9 13           	inc		de
  35++82BA ED 53 B2 82  	ld		(FillScrLinesPtr), de
  36++82BE CD A2 82     	call	GetCellDown
  37++82C1 10 EE        	djnz	FillScrLinesLoop
  38++82C3
  39++82C3              	;now fill the table in reverse
  40++82C3 ED 73 D7 82  	ld		(FillScrLinesSPStore), sp
  41++82C7 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++82CA 06 17        	ld		b, LINE_CNT
  43++82CC 21 00 5B     	ld		hl, SCRLinesDown
  44++82CF              FillScrLinesRev:
  45++82CF 5E           	ld		e, (hl)
  46++82D0 23           	inc		hl
  47++82D1 56           	ld		d, (hl)
  48++82D2 23           	inc		hl
  49++82D3 D5           	push	de
  50++82D4 10 F9        	djnz	FillScrLinesRev
  51++82D6              FillScrLinesSPStore	EQU	$ + 1
  52++82D6 31 00 00     	ld		sp, 0
  53++82D9 C9           	ret
  54++82DA
  55++82DA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++82DA              ScrollUp:
  57++82DA 21 2E 5B     	ld		hl, SCRLinesUp
  58++82DD 18 03        	jr		Scroll
  59++82DF
  60++82DF              ScrollDown:
  61++82DF 21 00 5B     	ld		hl, SCRLinesDown
  62++82E2
  63++82E2              Scroll:
  64++82E2 22 F0 82     	ld		(ScrollDownPtrDest), hl
  65++82E5 23           	inc		hl
  66++82E6 23           	inc		hl
  67++82E7 22 F3 82     	ld		(ScrollDownPtrSrc), hl
  68++82EA 0E 16        	ld		c, LINE_CNT - 1
  69++82EC
  70++82EC              ScrollDownLoop2:
  71++82EC 06 04        	ld		b, 4
  72++82EE              ScrollDownPtrDest	EQU	$ + 2
  73++82EE ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++82F2              ScrollDownPtrSrc	EQU	$ + 1
  75++82F2 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++82F5
  77++82F5              ScrollDownLoop:					;copy a single char line
  78++82F5 C5           	push	bc
  79++82F6 01 20 00     	ld		bc, 32
  80++82F9 ED B0        	ldir
  81++82FB 2B           	dec		hl
  82++82FC 1B           	dec		de
  83++82FD 24           	inc		h
  84++82FE 14           	inc		d
  85++82FF 01 20 00     	ld		bc, 32
  86++8302 ED B8        	lddr
  87++8304 23           	inc		hl
  88++8305 13           	inc		de
  89++8306 24           	inc		h
  90++8307 14           	inc		d
  91++8308 C1           	pop		bc
  92++8309 10 EA        	djnz	ScrollDownLoop
  93++830B
  94++830B 0D           	dec		c
  95++830C C8           	ret		z
  96++830D
  97++830D 2A F3 82     	ld		hl, (ScrollDownPtrSrc)
  98++8310 22 F0 82     	ld		(ScrollDownPtrDest), hl
  99++8313 23           	inc		hl
 100++8314 23           	inc		hl
 101++8315 22 F3 82     	ld		(ScrollDownPtrSrc), hl
 102++8318 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 418+ 831A
 419+ 831A              CharReplaceTbl:
 420+ 831A B3 80        	defb	179, 128
 421+ 831C B4 81        	defb	180, 129
 422+ 831E BF 82        	defb	191, 130
 423+ 8320 C0 83        	defb	192, 131
 424+ 8322 C1 84        	defb	193, 132
 425+ 8324 C2 85        	defb	194, 133
 426+ 8326 C3 86        	defb	195, 134
 427+ 8328 C4 87        	defb	196, 135
 428+ 832A C5 88        	defb	197, 136
 429+ 832C D9 89        	defb	217, 137
 430+ 832E DA 8A        	defb	218, 138
 431+ 8330 DB 8B        	defb	219, 139
 432+ 8332 DC 8C        	defb	220, 140
 433+ 8334              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 434+ 8334
 435+ 8334 50 72 6F 67  MsgLine		defb	'Progress:'
 435+ 8338 72 65 73 73
 435+ 833C 3A
 436+ 833D 20 20 20 25  MsgLinePr	defb	'   %; '
 436+ 8341 3B 20
 437+ 8343 4C 69 6E 65  			defb	'Line: '
 437+ 8347 3A 20
 438+ 8349 20 20 20 20  MsgLineNo	defb	'     ; '
 438+ 834D 20 3B 20
 439+ 8350 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 439+ 8354 61 70 20
 440+ 8357 20 4F 6E     MsgLineWrF	defb	' On'
 441+ 835A 20 30 2D 45  			defb	' 0-Exit'
 441+ 835E 78 69 74
 442+ 8361              MsgLineLen	EQU		$ - MsgLine
 443+ 8361
 444+ 8361 20 20 20 20  LineBuf		defb	'                                                                '
 444+ 8365 20 20 20 20
 444+ 8369 20 20 20 20
 444+ 836D 20 20 20 20
 444+ 8371 20 20 20 20
 444+ 8375 20 20 20 20
 444+ 8379 20 20 20 20
 444+ 837D 20 20 20 20
 444+ 8381 20 20 20 20
 444+ 8385 20 20 20 20
 444+ 8389 20 20 20 20
 444+ 838D 20 20 20 20
 444+ 8391 20 20 20 20
 444+ 8395 20 20 20 20
 444+ 8399 20 20 20 20
 444+ 839D 20 20 20 20
 445+ 83A1 00 00        CurLine		defw	0
 446+ 83A3 00 00        MaxLine		defw	0
 447+ 83A5 01           WrapFlag	defb	1
 448+ 83A6 00 00        FileBegin	defw	0
 449+ 83A8 00 00        FileLen		defw	0
 450+ 83AA 00 00        FileEnd		defw	0
 451+ 83AC 00 00        PROGR_PERC	defw	0
 452+ 83AE
 453+ 83AE              SCRLinesDown	EQU $5b00
 454+ 83AE              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 455+ 83AE              End:
 456+ 83AE
# file closed: txtview.asm
1300  83AE
1301  83AE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1302  83AE 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1302  83B2 6F 6D 6D 61
1302  83B6 6E 64 65 72
1302  83BA 20 31 2E B0
1303  83BE 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1303  83C2 67 65 2E 63
1303  83C6 68 69 72 74
1303  83CA 6F 61 63 E1
1304  83CE 40 67 6D 61  VerMsg3			DEFM	'@gmail.com, 202', '3' + $80
1304  83D2 69 6C 2E 63
1304  83D6 6F 6D 2C 20
1304  83DA 32 30 32 B3
1305  83DE 53 79 73 74  MsgSysInf		DEFM	'System Info    ', ' ' + $80
1305  83E2 65 6D 20 49
1305  83E6 6E 66 6F 20
1305  83EA 20 20 20 A0
1306  83EE 4D 6F 64 65  MsgCompModel	DEFB	'Model: '
1306  83F2 6C 3A 20
1307  83F5 20 20 20 20  MsgCompModelName DEFB	'        ', ' ' | $80
1307  83F9 20 20 20 20
1307  83FD A0
1308  83FE 49 46 31 20  MsgIF1Version	DEFB	'IF1  : '
1308  8402 20 3A 20
1309  8405 20 20 20 20  MsgIF1Date		DEFB	'       ', ' ' | $80
1309  8409 20 20 20 A0
1310  840D 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1310  8411 20 49 6E 66
1310  8415 6F 20 20 20
1310  8419 20 20 20 A0
1311  841D 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1311  8421 20 49 6E 66
1311  8425 6F 20 20 20
1311  8429 20 20 20 A0
1312  842D 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1312  8431 61 67 65 73
1312  8435 20 20 20 20
1312  8439 20 20 20 A0
1313  843D 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1313  8441 20 32 2D 42
1313  8445 3A 20 33 2D
1313  8449 56 69 65 77
1313  844D 20 34 2D 50
1313  8451 72 6F 70 20
1313  8455 35 2D 43 6F
1313  8459 70 79 20 36
1313  845D 2D 52 65 6E
1313  8461 20 37 2D 41
1313  8465 74 74 72 20
1313  8469 38 2D 44 65
1313  846D 6C 20 39 2D
1313  8471 44 69 73 6B
1313  8475 20 30 2D 45
1313  8479 78 69 F4
1314  847C 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1314  8480 65 20 20 20
1314  8484 3A 20 20 20
1314  8488 20 20 20
1315  848B C1           MsgDriveLet		DEFM	'A' + $80
1316  848C 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1316  8490 73 20 20 20
1316  8494 3A
1317  8495 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1317  8499 31 32 B8
1318  849C 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1318  84A0 20 4B 42 20
1318  84A4 3A
1319  84A5 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1319  84A9 36 33 B6
1320  84AC 45 72 72 6F  MsgErr			DEFM	'Error code '
1320  84B0 72 20 63 6F
1320  84B4 64 65 20
1321  84B7 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1321  84BB A0
1322  84BC 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1322  84C0 69 6E 67 20
1322  84C4 50 72 6F 67
1322  84C8 72 61 ED
1323  84CB 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1323  84CF 69 6E 67 20
1323  84D3 53 43 52 45
1323  84D7 45 4E A4
1324  84DA 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1324  84DE 69 6E 67 20
1324  84E2 43 4F 44 45
1324  84E6 20 28 21 A9
1325  84EA 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1325  84EE 20 4C 65 6E
1325  84F2 3A
1326  84F3 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1326  84F7 30 20 CB
1327  84FA 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1327  84FE 69 62 20 20
1327  8502 3A
1328  8503 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1328  8507 48 49 C4
1329  850A 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1329  850E 54 79 70 65
1329  8512 3A
1330  8513 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1330  8517 20 20 20 20
1330  851B 20 A0
1331  851D 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1331  8521 72 61 ED
1332  8524 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1332  8528 73 20 A0
1333  852B 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1333  852F 45 4E A4
1334  8532 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1334  8536 41 72 F2
1335  8539 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1335  853D 41 72 F2
1336  8540 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1336  8544 20 20 A0
1337  8547 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1337  854B 20 20 A0
1338  854E 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1338  8552 74 68 20 20
1338  8556 3A
1339  8557 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1339  855B 35 20 C2
1340  855E 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1340  8562 74 20 20 20
1340  8566 3A
1341  8567 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1341  856B 35 20 A0
1342  856E 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1342  8572 69 6E 67 20
1342  8576 68 65 61 64
1342  857A 65 F2
1343  857C 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1343  8580 20 20 20 20
1343  8584 20 20 20 20
1343  8588 20 20 20 A0
1344  858C 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1344  8590 66 69 6C 65
1344  8594 20 28 79 2F
1344  8598 6E 29 BF
1345  859B 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1345  859F 52 2F 4F 20
1345  85A3 28 79 2F 6E
1345  85A7 29 BF
1346  85A9 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1346  85AD 48 49 44 20
1346  85B1 28 79 2F 6E
1346  85B5 29 BF
1347  85B7 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1347  85BB 2C 6E 6F 6E
1347  85BF 65 3D 61 62
1347  85C3 6F 72 74 BA
1348  85C7 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1348  85CB 69 6E 67 20
1348  85CF 74 6F 20
1349  85D2 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1350  85D4 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1350  85D8 20 6F 70 74
1350  85DC 69 6F 6E 73
1350  85E0 BA
1351  85E1 31 2E 46 6F  MsgMenu1		DEFM	'1.Format '
1351  85E5 72 6D 61 74
1351  85E9 20
1352  85EA 41 BA        MsgMenu1Drv		DEFM	'A', ':' | $80
1353  85EC 32 2E 43 6F  MsgMenu2		DEFM	'2.Copy '
1353  85F0 70 79 20
1354  85F3 41 3A 2D 3E  MsgMenu2Drv1	DEFM	'A:->'
1355  85F7 42 BA        MsgMenu2Drv2	DEFM	'B', ':' | $80
1356  85F9 30 2E 42 61  MsgMenu3		DEFM	'0.Bac', 'k' | $80
1356  85FD 63 EB
1357  85FF 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1357  8603 61 74 74 69
1357  8607 6E 67 20
1358  860A 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1359  860C 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1359  8610 62 6C 6F 63
1359  8614 6B 73 20 6C
1359  8618 65 66 F4
1360  861B 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite (y/n)', '?' | $80
1360  861F 77 72 69 74
1360  8623 65 20 28 79
1360  8627 2F 6E 29 BF
1361  862B 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1361  862F 20 6E 61 6D
1361  8633 65 20 65 78
1361  8637 69 73 74 F3
1362  863B
1363  863B              	IFNDEF	_ROM_FNT_
1364  863B ~            FontTable:
1365  863B ~            	incbin "cpmfnt.bin"
1366  863B              	ENDIF
1367  863B              EndCode:
1368  863B
1369  863B              ;Unalocated variables
1370  863B              UnallocStart	EQU		EndCode
1371  863B              FileCnt			EQU		UnallocStart			;File counter, 1B
1372  863B              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1373  863B              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1374  863B              CursorAddr		EQU		SelFile + 1				;2 B
1375  863B              AUCnt			EQU		CursorAddr + 2			;2 B
1376  863B              SelFileCache	EQU		AUCnt + 2				;2 B
1377  863B
1378  863B              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1379  863B              ;FS block list constants
1380  863B              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1381  863B              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1382  863B              UsedBlockListSz		EQU 320 * 2 + 2							;640
1383  863B
1384  863B              	IFDEF	_ROM_FNT_
1385  863B              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1386  863B              DataBuf			EQU		FontTable + 872
1387  863B              	ELSE
1388  863B ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1389  863B              	ENDIF
1390  863B
1391  863B              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1392  863B
1393  863B              CopyFileFCBSrc	EQU	DataBuf
1394  863B              CopyFileFCBDst	EQU	DataBuf + 2
1395  863B              CopyFileResRead	EQU DataBuf + 4
1396  863B              CopyFileResWrite EQU DataBuf + 5
1397  863B              CopyFileDMAAddr	EQU	DataBuf + 6
1398  863B              CopyFileDMA		EQU	DataBuf + 8
1399  863B
1400  863B              ;File viewer constants
1401  863B              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1402  863B              ;File buffer size, without index
1403  863B              FileIdxSize		EQU		2 * 1024
1404  863B              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1405  863B              ;Set a few KB aside for file indexing
1406  863B              FileIdx			EQU		FileData + FileDataSize
1407  863B
1408  863B
1409  863B              ;Copy buffer size, follows
1410  863B              CopyDiskBuf			EQU DataBuf
1411  863B
1412  863B              ;We can use up to about 30KB free space if we load at address 24000.
1413  863B              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1414  863B              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1415  863B              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1416  863B              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1417  863B              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1418  863B
1419  863B              	DISPLAY "DataBuf: ", /D,DataBuf
1420  863B              	DISPLAY "BinSize: ", /D, EndCode - Start
1421  863B              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1422  863B              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x79BC   NoSub
0x79B5   DivLoop
0x69D6   MAX_RAM_FREE
0x0800   FileIdxSize
0x0282   UsedBlockListSz
0x863B   UnallocStart
0x863B   EndCode
0x83AE X End
0x83A3 X MaxLine
0x8350 X MsgLineWrap
0x82F5   ScrollDownLoop
0x82EC   ScrollDownLoop2
0x82F3   ScrollDownPtrSrc
0x82F0   ScrollDownPtrDest
0x82E2   Scroll
0x82CF   FillScrLinesRev
0x5B2E   SCRLinesUp
0x82D7   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x82B2   FillScrLinesPtr
0x82B1   FillScrLinesLoop
0x82A2   GetCellDown
0x829D   ReplaceMatch
0x8291   ReplaceSGCLoop
0x000D   CharReplTblLen
0x831A   CharReplaceTbl
0x002D   MsgLineLen
0x8334   MsgLine
0x8349   MsgLineNo
0x833D   MsgLinePr
0x8234   GetLineFillLoop
0x8211   GetLineFill
0x828A   ReplaceChars
0x81FD   Valid
0x81FA   NotValid
0x8201   GetLineSkip0D
0x81F0   GetLineNext
0x820A   GetLineSkip0A
0x81DB   GetLineLoop
0x81BC   PrintStrTxt
0x8361   LineBuf
0x82DF   ScrollDown
0x82DA   ScrollUp
0x818D   CheckBegin
0x8357   MsgLineWrF
0x811E   NoWrap
0x83A5   WrapFlag
0x812D   Up
0x8158   Down
0x80D8   GetKey
0x80EF   PrintLoop2
0x80E7   EOF
0x819D   CheckEnd
0x81A8   PrintLine
0x81D6   GetLine
0xF72A   FileIdx
0x823B   PrintMsg
0x83AC   PROGR_PERC
0x83A1   CurLine
0x82AC   ScrollInit
0x83A8   FileLen
0x83AA   FileEnd
0x83A6   FileBegin
0x5CB0   COORDS
0x001A   EOF_MARKER
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x8047   ReadStrPrint
0x8037   ReadStrChar
0x801A   ReadStringLoop
0x800E   Store
0x800D   NoTurn
0x8002   PrintCharLine
0x7FEE X PrintChar3
0x7F99   DrawCursorLoop
0x7F79   DrawVLinesLoop
0x7F8C   PrintChar2
0x7F57   DrawUpLine
0x7F59   ChrParam
0x7F4A X DrawHLine
0x7F39   DrawLineLoop
0x7F46   LineDir
0x7F36   StoreDir
0x7F34   VertDir
0x7F2B   DrawLine
0x7F27   StrClr
0x7EDA   GoodChar
0x8056   CurrScrAddr
0x91C2   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x7E8A   ReadFileSectionEnd
0x7E6C   ReadFileSectionLoop
0x6100   FileDataSize
0x952F   CopyFileResWrite
0x7E14   FileCopyWriteLoop
0x7E03   FileCopyWrite
0x952E   CopyFileResRead
0x7DE5   FileCopyReadLoop
0x9532   CopyFileDMA
0x9530   CopyFileDMAAddr
0x0069   MAX_SECT_RAM
0x7DD6   FileCopyLoop
0x952C   CopyFileFCBDst
0x7E32   CopyFileEnd
0x952A   CopyFileFCBSrc
0x7D7E X FileAttribSet
0x7D37   GetFileSizeMul
0x7D3D   GetFileSizeEnd
0x7D35   GetFileSizeOK
0x7D15   BDOSSetDMA
0x7D07   WriteFileBlock
0x7D03   ReadFileBlock
0x7CFF   CloseFile
0x7CFB   OpenFile
0x7CF7   CreateFile
0x7CED   DestroyChannel
0x7CD7   CreateChannel
0x7CD7 X BDOSGetCurrentDisk
0x7CD7 X BDOSGetDiskRO
0x7CD7 X BDOSMakeDiskRO
0x7D0B   BDOS
0x7CC6 X RWTSResTmp
0x7CC5 X RWTSResVolNo
0x7CC1 X RWTSPrmTbl
0x7CBF X RWTSExtBuf
0x7CBC X RWTSSector
0x7CBA X RWTSVolNo
0x7CB8 X RWTSBlockType
0x7CAF   CopyMsg
0x7CA3   SearchMsgEnd
0x7CAC   SaveMsg
0x7C9A   IF1Paged
0x7C63   IsFileHeaderValidLoop
0x7D19   GetFileSize
0x7C47   ReadFileHeaderIsTextFile
0x7C60   IsFileHeaderValid
0x7C5C   ReadHeaderEnd
0x7C01   CacheNotFinished
0x7CCB   BDOSInit
0x7CCE   BDOSSelectDisk
0x7B9E   FileReadLoop
0x7B92 X FileLoadHeader
0x7BA4   FileLoadNoHeader
0x7BB2   FileFree
0x7B6E   MisMatch
0x7B66   Compare
0x7B64   StrCmp
0x7B32   CopyDiskLoopWriteLoop
0x7B0C   CopyDiskLoopReadLoop
0x952A   CopyDiskBuf
0x7B05   CopyDiskLoopRead
0x000D   MAX_AU_RAM
0x860C   MsgBlocksLeft
0x7AE2   CopyDiskLoop
0x8F42   UsedBlockListBlk
0x7BCA   WriteDiskSectors
0x7AD7 X WriteFSBlockLoop
0x7ACE   WriteFSBlock
0x7BB7   ReadDiskSectors
0x7ACA X ReadFSBlockLoop
0x7AC1   ReadFSBlock
0x7AB3   ReadUsedBlocksSkip
0x7A96   ReadUsedBlocksLoop2
0x7AB6   ReadUsedBlocksSkip2
0x7A86   ReadUsedBlocksLoop
0x8F40   UsedBlockListCnt
0x7A69   ReadUsedBlocksList
0x7A62   CheckAUEnd
0x7A4E   CheckAU
0x7A37   FirstAU
0x7A31   Track0
0x7A1C   AU2TS
0x7CC4   RWTSRes
0x7A00   WriteOneDiskSector
0x7CBB   RWTSTrack
0x7CBD   RWTSDMA
0x79F5   ReadOneDiskSector
0x7CB8   RWTSParams
0x7CC3   RWTSCmd
0x79E9   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x001F X STR_MSG_IF1_LEN
0x0020 X STR_MSG_BASIC_LEN
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x79E3   NoAdd
0x79DD   MulLoop
0x79C4   Div2Loop
0x79BF   Div2
0x79B2   Div
0x79A9   DivNrLoop
0x79A7   DigitLoop
0x7998   Byte2Txt_
0x7981   StrippLeading0
0x798C   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x83FE   MsgIF1Version
0x83EE   MsgCompModel
0x7945 X GetIF1StringLoop
0x8405   MsgIF1Date
0x23F0   STR_MSG_IF1_91
0x7C68   IF1Call
0x7958   PrintCompInfo
0x27F0   STR_MSG_IF1_2000
0x793D   GetIF1String
0x7928   HC2000Store
0x7926   HC2000v1
0x7933   PrintComputerInfoIF1
0x790B   PrintComputerInfoSkip
0x7904   PrintComputerInfoLoop
0x83F5   MsgCompModelName
0x1539   STR_MSG_BASIC
0x83CE   VerMsg3
0x83BE   VerMsg2
0x83AE   VerMsg1
0x78DE   DontInc
0x78D2   ReadAllHeadersEnd
0x78BD   AKey
0x7E9A   KbdHit
0x78A2   NextFile
0x854E   MsgFileLen
0x850A   MsgFileType
0x855E   MsgFileStart
0x7861   PrintStartStr
0x8567   MsgFileStartN
0x8547   MsgNA
0x7853   PrintStart
0x0007   HDR_LINE
0x782E   PrintByteStart
0x7826   PrintProgStart
0x8557   MsgFileLenN
0x780C X PrepFileLenText
0x8540   MsgFileTypeText
0x8524   MsgFileTypeByte
0x852B   MsgFileTypeSCR
0x77F2   NotScr
0x77FD   CheckText
0x8532   MsgFileTypeChrA
0x77D5   CheckByte
0x0002   CHAR_TYPE
0x8539   MsgFileTypeNoA
0x77C6   CheckChrArr
0x0001   NUMB_TYPE
0x7806   PrepFileLen
0x787F   MoveMsg
0x8513   MsgFileTypeN
0x851D   MsgFileTypePrg
0x77B7   CheckNoArr
0x000B   CACHE_FIRST_AU
0x7836   HeadNotRead
0x84FA   MsgFileAttr
0x7788   AttrEnd
0x777C   NotSYS
0x7768   CheckSys
0x7756   NotRO
0x8503   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x7848   PrintStartNotRead
0x84EA   MsgFileSzDsk
0x84F3   MsgFileSzDskN
0x7712 X ViewFileEnd
0x80B4   PrintLoop
0x805A   InitViewer
0x962A   FileData
0x7E4D   ReadFileSection
0x7C6E   LoadProgram
0x84BC   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x84CB   MsgLoadingSCR
0x0003   HDR_ADDR
0x7BB2   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7B71   IF1FileLoad
0x84DA   MsgLoadingCODE
0x76A0 X HandleFileCODE
0x76C9   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x76F7   HandleFileText
0x0003   BYTE_TYPE
0x76E7   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x766A   FindExtEnd
0x7BF6   FindCache
0x7679   GetFileNamesEnd
0x0009   HDR_SZ
0x7645   FindExt
0x000C   EXT_IDX
0x7A3A   CheckExtAlloc
0x766C   NextExt
0x0000   EXT_DEL_FLAG
0x75F4   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x75D1   DisplayFilenamesLoop
0x75B7   LineOK
0x5CB1   LINE
0x5CB0   COL
0x7FD6   PrintChar
0x5C81   CODE
0x7591   DispLoop
0x758F   DisplayFilename
0x7F9E   MoveCursor
0x7ADB   CopyDisk
0x7A0B   FormatDisk
0x85FF   MsgFormat
0x7575   CheckExtra2
0x757E   ExtraMenuExit
0x85EC   MsgMenu2
0x85E1   MsgMenu1
0x85F9   MsgMenu3
0x7506   CheckKeyExtraMenu
0x85F7   MsgMenu2Drv2
0x85F3   MsgMenu2Drv1
0x860A   MsgFormatDrv
0x85EA   MsgMenu1Drv
0x85D4   MsgMenu0
0x7581   CheckKeyExit
0x7D5D   ChangeFileAttrib
0x74CE   AttrChange
0x85A9   MsgSetSYS
0x74B6   CheckSYS
0x859B   MsgSetRO
0x74DD   CheckKeyExtra
0x7D43   DeleteFile
0x7488   DoFileDelete
0x858C   MsgDelete
0x7495   CheckKeyAttrib
0x7D87   RenameFile
0x862B   MsgFileExists
0x7438   RenameFileNotExist
0x7444   RenameCanceled
0x8014   ReadString
0x000B   NAMELEN
0x85B7   MsgNewFileName
0x745D   CheckKeyDel
0x76F8   ViewFile
0x73DC   CheckKeyRename
0x0001   DRIVE_B_CPM
0x73CB   CheckKeyView
0x74D7   SelectDrive
0x73C2   CheckKeyDriveB
0x7885   ReadAllHeaders
0x73B9   CheckKeyDriveA
0x738F   CopyFileOK
0x7DAA   CopyFile
0x738F   CopyFileDontOverwrite
0x861B   MsgFileOverwrite
0x736F   CopyFileDestNotExist
0x7D4F   DoesFileExist
0x85C7   MsgCopyFile
0x85D2   MsgCopyFileDrv
0x73A8   CheckKeyFileInfo
0x857C   MsgClear
0x7C07   ReadFileHeader
0x856E   MsgReadingExt
0x732B   CheckKeyCopy
0x767A   HandleFile
0x7300   CheckKeyInfo
0x000D   KEY_ENTER
0x72F5   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x72E4   CheckLeft
0x0009   KEY_RIGHT
0x72CE   CheckRight
0x000B   KEY_UP
0x7589   MoveIt
0x72BD   CheckUp
0x000A   KEY_DOWN
0x7713   DisplayFileInfo
0x8642   SelFileCache
0x79D2   Mul
0x728E   CalcFileCache
0x849C   MsgFreeSpace
0x796B   Word2Txt
0x84A5   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x8640   AUCnt
0x848C   MsgFilesCnt
0x8495   MsgFilesCntNo
0x863B   FileCnt
0x7ED3   PrintStr
0x847C   MsgDrive
0x848B   MsgDriveLet
0x7C87   SetFastKeys
0x7F93   DrawCursor
0x0028   SCR_SEL_CLR
0x842D   MsgMessages
0x000A   LST_FILE_INFO
0x841D   MsgFileInf
0x0006   LST_DISK_INFO
0x840D   MsgDskInf
0x0000   LST_PROG_INFO
0x83DE   MsgSysInf
0x843D   BtnBar
0x0028   SCR_LBL_CLR
0x7F74   DrawVLines
0x0084   CHR_DC
0x863E   CursorAddr
0x8058   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x7EB3   ClrScr
0x5CB0   LineCol
0x0000   LST_FIRST_LINE
0x863C   NameCol
0x0010   LST_FIRST_COL
0x863D   SelFile
0x952A   DataBuf
0x7C92   GetErrMsg
0x5C3A   ERRNR
0x71AA   HCRunEnd
0x729F   ReadKeyLoop
0x7245   DisplayDiskInfo
0x75C1   DisplayFilenames
0x78E1   PrintIntro
0x71E2   InitUI
0x719B   HCRunMain
0x75E1   GetFileNames
0x7CB9   RWTSDrive
0x0000   DRIVE_A_CPM
0x7E97   ReadChar
0x7EFB   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x0010   LST_LINE_MSG
0x84AC   MsgErr
0x7976   Byte2Txt
0x84B7   MsgErrCode
0x7198   HCRunCacheFiles
0x7BDD   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0x8644   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x952A   TrackBuf
0x715A   HCRunInitDisk
0x71B0   ErrorHandler
0x5C3D   ERRSP
0x79E6   IF1Init
0x7E9D   InitFonts
0x7148   Start
