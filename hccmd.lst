# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 32768
  12  8000
  13  8000              Start:
  14  8000              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  8000 CD 56 8E     		call InitFonts
  16  8003              	ENDIF
  17  8003 CD DD 88     	call IF1Init
  18  8006
  19  8006              	;install error handler
  20  8006 2A 3D 5C     	ld		hl, (ERRSP)
  21  8009 E5           	push	hl
  22  800A 21 68 80     	ld		hl, ErrorHandler
  23  800D E5           	push	hl
  24  800E ED 73 3D 5C  	ld		(ERRSP), sp
  25  8012
  26  8012              HCRunInitDisk:
  27  8012              	;Set track buffer to del marker
  28  8012 21 AF A5     	ld		hl, TrackBuf
  29  8015 54           	ld		d, h
  30  8016 5D           	ld		e, l
  31  8017 13           	inc		de
  32  8018 01 00 10     	ld		bc, SPT*SECT_SZ
  33  801B 36 E5        	ld		(hl), DEL_MARKER
  34  801D ED B0        	ldir
  35  801F
  36  801F              	;Invalidate file cache
  37  801F 21 C9 96     	ld		hl, FileCache
  38  8022 54           	ld		d, h
  39  8023 5D           	ld		e, l
  40  8024 13           	inc		de
  41  8025 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  8028 36 00        	ld		(hl), 0
  43  802A ED B0        	ldir
  44  802C
  45  802C              	;main program
  46  802C CD 96 8B     	call 	ReadCatalogTrack
  47  802F B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  8030 28 1E        	jr		z, HCRunCacheFiles
  49  8032
  50  8032 6F           	ld		l, a
  51  8033 26 00        	ld		h, 0
  52  8035 11 1B 95     	ld		de, MsgErrCode
  53  8038 CD 6D 88     	call	Byte2Txt
  54  803B 21 10 95     	ld		hl, MsgErr
  55  803E 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
  56  8041 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  8043 CD B4 8E     	call	PrintStrClr
  58  8046 CD 50 8E     	call	ReadChar
  59  8049 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  804B 32 72 8C     	ld		(RWTSDrive), a
  61  804E 18 C2        	jr		HCRunInitDisk
  62  8050
  63  8050              HCRunCacheFiles:
  64  8050 CD D8 84     	call 	GetFileNames
  65  8053
  66  8053              HCRunMain:
  67  8053 CD 9A 80     	call 	InitUI
  68  8056 CD D8 87     	call	PrintIntro
  69  8059 CD B8 84     	call	DisplayFilenames
  70  805C CD FD 80     	call	DisplayDiskInfo
  71  805F C3 57 81     	jp		ReadKeyLoop
  72  8062
  73  8062              HCRunEnd:
  74  8062              	;restore error handler
  75  8062 E1           	pop		hl
  76  8063 E1           	pop		hl
  77  8064 22 3D 5C     	ld		(ERRSP), hl
  78  8067
  79  8067 C9           	ret
  80  8068
  81  8068              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  82  8068
  83  8068              ErrorHandler:
  84  8068 E1           	pop		hl
  85  8069 22 3D 5C     	ld		(ERRSP), hl
  86  806C
  87  806C 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  88  806F 6F           	ld		l, a
  89  8070 26 00        	ld		h, 0
  90  8072 11 1B 95     	ld		de, MsgErrCode
  91  8075 CD 6D 88     	call	Byte2Txt
  92  8078 21 10 95     	ld		hl, MsgErr
  93  807B 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
  94  807E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  95  8080 CD B4 8E     	call	PrintStrClr
  96  8083
  97  8083 3A 3A 5C     	ld		a, (ERRNR)
  98  8086 CD 4B 8C     	call	GetErrMsg
  99  8089
 100  8089 21 AF A5     	ld		hl, DataBuf
 101  808C 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 102  808F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 103  8091 CD B4 8E     	call	PrintStrClr
 104  8094
 105  8094 CD 50 8E     	call	ReadChar
 106  8097 C3 00 80     	jp	Start
 107  809A
 108  809A
 109  809A
 110  809A
 111  809A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 112  809A
 113  809A              InitUI:
 114  809A AF           	xor		a
 115  809B 32 C2 96     	ld		(SelFile), A
 116  809E 3E 11        	ld		a, LST_FIRST_COL + 1
 117  80A0 32 C1 96     	ld		(NameCol), A
 118  80A3 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 119  80A6 ED 53 B0 5C  	ld		(LineCol), de
 120  80AA
 121  80AA CD 6C 8E     	call	ClrScr
 122  80AD
 123  80AD 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 124  80B0 ED 4B 11 90  	ld		bc, (CurrScrAttrAddr)
 125  80B4 09           	add		hl, bc
 126  80B5 22 C3 96     	ld		(CursorAddr), hl
 127  80B8
 128  80B8 3E 84        	ld		a, CHR_DC
 129  80BA CD 2D 8F     	call	DrawVLines
 130  80BD
 131  80BD 3E 28        	ld		a, SCR_LBL_CLR
 132  80BF 11 00 17     	ld		de, 23 << 8
 133  80C2 21 A1 94     	ld		hl, BtnBar
 134  80C5 CD B4 8E     	call	PrintStrClr
 135  80C8
 136  80C8 3E 28        	ld		a, SCR_LBL_CLR
 137  80CA 21 42 94     	ld		hl, MsgSysInf
 138  80CD 11 00 00     	ld		de, LST_PROG_INFO << 8
 139  80D0 CD B4 8E     	call	PrintStrClr
 140  80D3
 141  80D3 3E 28        	ld		a, SCR_LBL_CLR
 142  80D5 21 71 94     	ld		hl, MsgDskInf
 143  80D8 11 00 06     	ld		de, LST_DISK_INFO << 8
 144  80DB CD B4 8E     	call	PrintStrClr
 145  80DE
 146  80DE 3E 28        	ld		a, SCR_LBL_CLR
 147  80E0 21 81 94     	ld		hl, MsgFileInf
 148  80E3 11 00 0A     	ld		de, LST_FILE_INFO << 8
 149  80E6 CD B4 8E     	call	PrintStrClr
 150  80E9
 151  80E9 3E 28        	ld		a, SCR_LBL_CLR
 152  80EB 21 91 94     	ld		hl, MsgMessages
 153  80EE 11 00 10     	ld		de, LST_LINE_MSG << 8
 154  80F1 CD B4 8E     	call	PrintStrClr
 155  80F4
 156  80F4 3E 28        	ld		a, SCR_SEL_CLR
 157  80F6 CD 4C 8F     	call	DrawCursor
 158  80F9
 159  80F9 CD 40 8C     	call	SetFastKeys
 160  80FC
 161  80FC C9           	ret
 162  80FD
 163  80FD
 164  80FD              DisplayDiskInfo:
 165  80FD 3A 72 8C     	ld		a, (RWTSDrive)
 166  8100 C6 C1        	add		'A' + $80
 167  8102 32 EF 94     	ld		(MsgDriveLet), a
 168  8105 21 E0 94     	ld		hl, MsgDrive
 169  8108 11 00 07     	ld		de, LST_DISK_INFO + 1 << 8
 170  810B CD 8C 8E     	call	PrintStr
 171  810E
 172  810E 3A C0 96     	ld		a, (FileCnt)
 173  8111 6F           	ld		l, a
 174  8112 26 00        	ld		h, 0
 175  8114 11 F9 94     	ld		de, MsgFilesCntNo
 176  8117 CD 6D 88     	call	Byte2Txt
 177  811A 21 F0 94     	ld		hl, MsgFilesCnt
 178  811D 11 00 08     	ld		de, LST_DISK_INFO + 2 << 8
 179  8120 CD 8C 8E     	call	PrintStr
 180  8123
 181  8123 ED 5B C5 96  	ld		de, (AUCnt)
 182  8127 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 183  812A B7           	or		a
 184  812B ED 52        	sbc		hl, de
 185  812D CB 15        	rl		l								;*2, 2K/AU
 186  812F CB 14        	rl		h
 187  8131 11 07 95     	ld		de, MsgFreeSpaceNo - 2
 188  8134 CD 62 88     	call	Word2Txt
 189  8137 3E 3A        	ld		a, ':'
 190  8139 32 08 95     	ld		(MsgFreeSpaceNo -1), a
 191  813C 21 00 95     	ld		hl, MsgFreeSpace
 192  813F 11 00 09     	ld		de, LST_DISK_INFO + 3 << 8
 193  8142 CD 8C 8E     	call	PrintStr
 194  8145
 195  8145 C9           	ret
 196  8146
 197  8146              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198  8146
 199  8146              CalcFileCache:
 200  8146 3A C2 96     	ld		a, (SelFile)
 201  8149 11 19 00     	ld		de, CACHE_SZ
 202  814C CD C9 88     	call	Mul
 203  814F 01 C9 96     	ld		bc, FileCache
 204  8152 09           	add		hl, bc					;HL = file AU cnt
 205  8153 22 C7 96     	ld		(SelFileCache), hl
 206  8156 C9           	ret
 207  8157
 208  8157              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209  8157
 210  8157
 211  8157              ReadKeyLoop:
 212  8157 CD 46 81     	call	CalcFileCache
 213  815A CD 0A 86     	call	DisplayFileInfo
 214  815D
 215  815D CD 50 8E     	call	ReadChar
 216  8160
 217  8160 FE 0A        	cp		KEY_DOWN
 218  8162 20 11        	jr		nz, CheckUp
 219  8164
 220  8164 3A C0 96     	ld		a, (FileCnt)
 221  8167 47           	ld		b, a
 222  8168 3A C2 96     	ld		a, (SelFile)
 223  816B 3C           	inc		a
 224  816C B8           	cp		b
 225  816D 30 E8        	jr		nc, ReadKeyLoop
 226  816F 32 C2 96     	ld		(SelFile), a
 227  8172 C3 80 84     	jp		MoveIt
 228  8175
 229  8175              CheckUp:
 230  8175 FE 0B        	cp		KEY_UP
 231  8177 20 0D        	jr		nz, CheckRight
 232  8179
 233  8179 3A C2 96     	ld		a, (SelFile)
 234  817C B7           	or		a
 235  817D 28 D8        	jr		z, ReadKeyLoop
 236  817F
 237  817F 3D           	dec		a
 238  8180 32 C2 96     	ld		(SelFile), a
 239  8183 C3 80 84     	jp		MoveIt
 240  8186
 241  8186              CheckRight:
 242  8186 FE 09        	cp		KEY_RIGHT
 243  8188 20 12        	jr		nz, CheckLeft
 244  818A
 245  818A 3A C0 96     	ld		a, (FileCnt)
 246  818D 47           	ld		b, a
 247  818E 3A C2 96     	ld		a, (SelFile)
 248  8191 C6 17        	add		LST_LINES_CNT
 249  8193 B8           	cp		b
 250  8194 30 C1        	jr		nc, ReadKeyLoop
 251  8196
 252  8196 32 C2 96     	ld		(SelFile), a
 253  8199 C3 80 84     	jp		MoveIt
 254  819C
 255  819C              CheckLeft:
 256  819C FE 08        	cp		KEY_LEFT
 257  819E 20 0D        	jr		nz, CheckEnter
 258  81A0
 259  81A0 3A C2 96     	ld		a, (SelFile)
 260  81A3 D6 17        	sub		LST_LINES_CNT
 261  81A5 38 B0        	jr		c, ReadKeyLoop
 262  81A7
 263  81A7 32 C2 96     	ld		(SelFile), a
 264  81AA C3 80 84     	jp		MoveIt
 265  81AD
 266  81AD              CheckEnter:
 267  81AD FE 0D        	cp		KEY_ENTER
 268  81AF C2 B8 81     	jp		nz, CheckKeyInfo
 269  81B2 CD 71 85     	call	HandleFile
 270  81B5 C3 53 80     	jp		HCRunMain
 271  81B8
 272  81B8              CheckKeyInfo:
 273  81B8 FE 34        	cp		'4'
 274  81BA 20 27        	jr		nz, CheckKeyCopy
 275  81BC
 276  81BC 3A C0 96     	ld		a, (FileCnt)
 277  81BF B7           	or		a
 278  81C0 CA 57 81     	jp		z, ReadKeyLoop
 279  81C3
 280  81C3 DD 2A C7 96  	ld		ix, (SelFileCache)
 281  81C7 21 D2 95     	ld		hl, MsgReadingExt
 282  81CA 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 283  81CD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 284  81CF CD B4 8E     	call	PrintStrClr
 285  81D2 CD C0 8B     	call	ReadFileHeader
 286  81D5 21 E0 95     	ld		hl, MsgClear
 287  81D8 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
 288  81DB 3E 0F        	ld		a, SCR_DEF_CLR
 289  81DD CD B4 8E     	call	PrintStrClr
 290  81E0 C3 57 81     	jp		ReadKeyLoop
 291  81E3
 292  81E3              CheckKeyCopy:
 293  81E3 FE 35        	cp		'5'
 294  81E5 C2 60 82     	jp		nz, CheckKeyFileInfo
 295  81E8
 296  81E8 3A C0 96     	ld		a, (FileCnt)
 297  81EB B7           	or		a
 298  81EC CA 57 81     	jp		z, ReadKeyLoop
 299  81EF
 300  81EF 3A 72 8C     	ld 		a, (RWTSDrive)
 301  81F2 3C           	inc		a
 302  81F3 EE 03        	xor		%11
 303  81F5 C6 40        	add		'A' - 1
 304  81F7 32 36 96     	ld		(MsgCopyFileDrv), a
 305  81FA 21 2B 96     	ld		hl, MsgCopyFile
 306  81FD 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 307  8200 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 308  8202 CD B4 8E     	call	PrintStrClr
 309  8205
 310  8205 2A C7 96     	ld		hl, (SelFileCache)
 311  8208 3A 72 8C     	ld 		a, (RWTSDrive)
 312  820B 3C           	inc		a
 313  820C EE 03        	xor		%11
 314  820E CD 08 8D     	call	DoesFileExist
 315  8211 3C           	inc		a
 316  8212 28 13        	jr		z, CopyFileDestNotExist
 317  8214
 318  8214 21 A0 96     	ld		hl, MsgFileOverwrite
 319  8217 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 320  821A 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 321  821C CD B4 8E     	call	PrintStrClr
 322  821F CD 50 8E     	call	ReadChar
 323  8222 FE 79        	cp		'y'
 324  8224 C2 47 82     	jp		nz, CopyFileDontOverwrite
 325  8227
 326  8227              CopyFileDestNotExist:
 327  8227 2A C7 96     	ld		hl, (SelFileCache)
 328  822A CD 63 8D     	call	CopyFile
 329  822D B7           	or		a
 330  822E 28 17        	jr		z, CopyFileOK
 331  8230
 332  8230 6F           	ld		l, a
 333  8231 26 00        	ld		h, 0
 334  8233 11 1B 95     	ld		de, MsgErrCode
 335  8236 CD 6D 88     	call	Byte2Txt
 336  8239 21 10 95     	ld		hl, MsgErr
 337  823C 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 338  823F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 339  8241 CD B4 8E     	call	PrintStrClr
 340  8244 CD 50 8E     	call	ReadChar
 341  8247
 342  8247              CopyFileOK:
 343  8247              CopyFileDontOverwrite:
 344  8247 21 E0 95     	ld		hl, MsgClear
 345  824A 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
 346  824D 3E 0F        	ld		a, SCR_DEF_CLR
 347  824F CD B4 8E     	call	PrintStrClr
 348  8252 21 E0 95     	ld		hl, MsgClear
 349  8255 11 00 12     	ld		de, LST_LINE_MSG+2 << 8
 350  8258 3E 0F        	ld		a, SCR_DEF_CLR
 351  825A CD B4 8E     	call	PrintStrClr
 352  825D C3 12 80     	jp		HCRunInitDisk
 353  8260
 354  8260              CheckKeyFileInfo:
 355  8260 FE 20        	cp		' '
 356  8262 20 0D        	jr		nz, CheckKeyDriveA
 357  8264
 358  8264 3A C0 96     	ld		a, (FileCnt)
 359  8267 B7           	or		a
 360  8268 CA 57 81     	jp		z, ReadKeyLoop
 361  826B
 362  826B CD 7C 87     	call	ReadAllHeaders
 363  826E C3 57 81     	jp		ReadKeyLoop
 364  8271
 365  8271              CheckKeyDriveA:
 366  8271 FE 31        	cp		'1'
 367  8273 20 05        	jr		nz, CheckKeyDriveB
 368  8275 3E 00        	ld		a, DRIVE_A_CPM
 369  8277 C3 8F 83     	jp		SelectDrive
 370  827A
 371  827A              CheckKeyDriveB:
 372  827A FE 32        	cp		'2'
 373  827C 20 05        	jr		nz, CheckKeyView
 374  827E 3E 01        	ld		a, DRIVE_B_CPM
 375  8280 C3 8F 83     	jp		SelectDrive
 376  8283
 377  8283              CheckKeyView:
 378  8283 FE 33        	cp		'3'
 379  8285 20 0D        	jr		nz, CheckKeyRename
 380  8287
 381  8287 3A C0 96     	ld		a, (FileCnt)
 382  828A B7           	or		a
 383  828B CA 57 81     	jp		z, ReadKeyLoop
 384  828E
 385  828E CD EF 85     	call	ViewFile
 386  8291 C3 53 80     	jp		HCRunMain
 387  8294
 388  8294              CheckKeyRename:
 389  8294 FE 36        	cp		'6'
 390  8296 20 7D        	jr		nz, CheckKeyDel
 391  8298
 392  8298 3A C0 96     	ld		a, (FileCnt)
 393  829B B7           	or		a
 394  829C CA 57 81     	jp		z, ReadKeyLoop
 395  829F
 396  829F 21 1B 96     	ld		hl, MsgNewFileName
 397  82A2 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 398  82A5 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 399  82A7 CD B4 8E     	call	PrintStrClr
 400  82AA
 401  82AA 21 E0 95     	ld		hl, MsgClear
 402  82AD 11 AF A5     	ld		de, DataBuf
 403  82B0 01 0B 00     	ld		bc, NAMELEN
 404  82B3 ED B0        	ldir
 405  82B5 3E A0        	ld		a, $80 | ' '
 406  82B7 12           	ld		(de), a
 407  82B8 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 408  82BB 21 AF A5     	ld		hl, DataBuf
 409  82BE CD 8C 8E     	call	PrintStr
 410  82C1
 411  82C1 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 412  82C4 01 0B 00     	ld		bc, NAMELEN
 413  82C7 CD CD 8F     	call	ReadString
 414  82CA
 415  82CA 11 AF A5     	ld		de, DataBuf
 416  82CD 1A           	ld		a, (de)
 417  82CE FE 20        	cp		' '					;If starting with space, input was canceled.
 418  82D0 CA FC 82     	jp		z, RenameCanceled
 419  82D3
 420  82D3              	;Check if new name doesn't exist already. Cancel if so.
 421  82D3 21 AF A5     	ld		hl, DataBuf
 422  82D6 3A 72 8C     	ld 		a, (RWTSDrive)
 423  82D9 3C           	inc		a
 424  82DA CD 08 8D     	call	DoesFileExist
 425  82DD 3C           	inc		a
 426  82DE 28 10        	jr		z, RenameFileNotExist
 427  82E0
 428  82E0 21 B0 96     	ld		hl, MsgFileExists
 429  82E3 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 430  82E6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 431  82E8 CD B4 8E     	call	PrintStrClr
 432  82EB CD 50 8E     	call	ReadChar
 433  82EE 18 0C        	jr		RenameCanceled
 434  82F0
 435  82F0              RenameFileNotExist:
 436  82F0 11 AF A5     	ld		de, DataBuf
 437  82F3 2A C7 96     	ld		hl, (SelFileCache)
 438  82F6 CD 40 8D     	call	RenameFile
 439  82F9 C3 12 80     	jp		HCRunInitDisk
 440  82FC
 441  82FC              RenameCanceled:
 442  82FC 21 E0 95     	ld		hl, MsgClear
 443  82FF 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 444  8302 3E 0F        	ld		a, SCR_DEF_CLR
 445  8304 CD B4 8E     	call	PrintStrClr
 446  8307 21 E0 95     	ld		hl, MsgClear
 447  830A 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 448  830D 3E 0F        	ld		a, SCR_DEF_CLR
 449  830F CD B4 8E     	call	PrintStrClr
 450  8312 C3 57 81     	jp		ReadKeyLoop
 451  8315
 452  8315              CheckKeyDel:
 453  8315 FE 38        	cp		'8'
 454  8317 20 34        	jr		nz, CheckKeyAttrib
 455  8319
 456  8319 3A C0 96     	ld		a, (FileCnt)
 457  831C B7           	or		a
 458  831D CA 57 81     	jp		z, ReadKeyLoop
 459  8320
 460  8320 21 F0 95     	ld		hl, MsgDelete
 461  8323 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 462  8326 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 463  8328 CD B4 8E     	call	PrintStrClr
 464  832B CD 50 8E     	call	ReadChar
 465  832E FE 79        	cp		'y'
 466  8330 28 0E        	jr		z, DoFileDelete
 467  8332 21 E0 95     	ld		hl, MsgClear
 468  8335 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 469  8338 3E 0F        	ld		a, SCR_DEF_CLR
 470  833A CD B4 8E     	call	PrintStrClr
 471  833D C3 57 81     	jp		ReadKeyLoop
 472  8340              DoFileDelete:
 473  8340 2A C7 96     	ld		hl, (SelFileCache)
 474  8343 3A 72 8C     	ld 		a, (RWTSDrive)
 475  8346 3C           	inc		a					;Convert to BASIC drive number: 1,2
 476  8347 CD FC 8C     	call	DeleteFile
 477  834A C3 12 80     	jp		HCRunInitDisk
 478  834D
 479  834D              CheckKeyAttrib:
 480  834D FE 37        	cp		'7'
 481  834F 20 44        	jr		nz, CheckKeyExtra
 482  8351
 483  8351 3A C0 96     	ld		a, (FileCnt)
 484  8354 B7           	or		a
 485  8355 CA 57 81     	jp		z, ReadKeyLoop
 486  8358
 487  8358 21 FF 95     	ld		hl, MsgSetRO
 488  835B 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 489  835E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 490  8360 CD B4 8E     	call	PrintStrClr
 491  8363 CD 50 8E     	call	ReadChar
 492  8366 1E 00        	ld		e, 0
 493  8368 FE 79        	cp		'y'
 494  836A 20 02        	jr		nz, CheckSYS
 495  836C 1E 01        	ld		e, 1
 496  836E
 497  836E              CheckSYS:
 498  836E D5           	push	de
 499  836F 21 0D 96     		ld		hl, MsgSetSYS
 500  8372 11 00 12     		ld		de, LST_LINE_MSG + 2 << 8
 501  8375 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 502  8377 CD B4 8E     		call	PrintStrClr
 503  837A CD 50 8E     		call	ReadChar
 504  837D FE 79        		cp		'y'
 505  837F D1           	pop		de
 506  8380 20 04        	jr		nz, AttrChange
 507  8382 3E 02        	ld		a, %10
 508  8384 B3           	or		e
 509  8385 5F           	ld		e, a
 510  8386
 511  8386              AttrChange:
 512  8386 2A C7 96     	ld		hl, (SelFileCache)
 513  8389 CD 16 8D     	call	ChangeFileAttrib
 514  838C C3 12 80     	jp		HCRunInitDisk
 515  838F
 516  838F              SelectDrive:
 517  838F 32 72 8C     	ld 		(RWTSDrive), a
 518  8392 C3 12 80     	jp		HCRunInitDisk
 519  8395
 520  8395              CheckKeyExtra:
 521  8395 FE 39        	cp		'9'
 522  8397 C2 78 84     	jp		nz, CheckKeyExit
 523  839A
 524  839A 21 38 96     	ld		hl, MsgMenu0
 525  839D 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 526  83A0 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 527  83A2 CD B4 8E     	call	PrintStrClr
 528  83A5 3A 72 8C     	ld		a, (RWTSDrive)
 529  83A8 C6 41        	add		'A'
 530  83AA 32 56 96     	ld		(MsgMenu2Drv), a
 531  83AD 32 8F 96     	ld		(MsgFormatDrv), a
 532  83B0 32 60 96     	ld		(MsgMenu3Drv1), a
 533  83B3 32 6E 96     	ld		(MsgMenu4Drv1), a
 534  83B6 32 82 96     	ld		(MsgMenu5Drv1), a
 535  83B9 3A 72 8C     	ld		a, (RWTSDrive)
 536  83BC 3C           	inc		a
 537  83BD EE 03        	xor		%11
 538  83BF C6 40        	add		'A'-1
 539  83C1 32 64 96     	ld		(MsgMenu3Drv2), a
 540  83C4
 541  83C4              CheckKeyDiskMenu:
 542  83C4 21 45 96     	ld		hl, MsgMenu1
 543  83C7 11 00 12     	ld		de, LST_LINE_MSG + 2 << 8
 544  83CA CD 8C 8E     	call	PrintStr
 545  83CD 21 4C 96     	ld		hl, MsgMenu2
 546  83D0 11 00 13     	ld		de, LST_LINE_MSG + 3 << 8
 547  83D3 CD 8C 8E     	call	PrintStr
 548  83D6 21 58 96     	ld		hl, MsgMenu3
 549  83D9 11 00 14     	ld		de, LST_LINE_MSG + 4 << 8
 550  83DC CD 8C 8E     	call	PrintStr
 551  83DF 21 66 96     	ld		hl, MsgMenu4
 552  83E2 11 00 15     	ld		de, LST_LINE_MSG + 5 << 8
 553  83E5 CD 8C 8E     	call	PrintStr
 554  83E8 21 75 96     	ld		hl, MsgMenu5
 555  83EB 11 00 16     	ld		de, LST_LINE_MSG + 6 << 8
 556  83EE CD 8C 8E     	call	PrintStr
 557  83F1 CD 50 8E     	call	ReadChar
 558  83F4 F5           	push	af
 559  83F5
 560  83F5 21 E0 95     		ld		hl, MsgClear
 561  83F8 11 00 12     		ld		de, LST_LINE_MSG + 2 << 8
 562  83FB CD 8C 8E     		call	PrintStr
 563  83FE 21 E0 95     		ld		hl, MsgClear
 564  8401 11 00 13     		ld		de, LST_LINE_MSG + 3 << 8
 565  8404 CD 8C 8E     		call	PrintStr
 566  8407 21 E0 95     		ld		hl, MsgClear
 567  840A 11 00 14     		ld		de, LST_LINE_MSG + 4 << 8
 568  840D CD 8C 8E     		call	PrintStr
 569  8410 21 E0 95     		ld		hl, MsgClear
 570  8413 11 00 15     		ld		de, LST_LINE_MSG + 5 << 8
 571  8416 CD 8C 8E     		call	PrintStr
 572  8419 21 E0 95     		ld		hl, MsgClear
 573  841C 11 00 16     		ld		de, LST_LINE_MSG + 6 << 8
 574  841F CD 8C 8E     		call	PrintStr
 575  8422
 576  8422 F1           	pop		af
 577  8423
 578  8423              CheckKeyDiskMenuLoop:
 579  8423 FE 30        	cp		'0'
 580  8425 28 4E        	jr		z, ExtraMenuExit
 581  8427
 582  8427 FE 31        	cp		'1'
 583  8429 20 2C        	jr		nz, CheckExtra2
 584  842B
 585  842B 21 84 96     	ld		hl, MsgFormat
 586  842E 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 587  8431 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 588  8433 CD B4 8E     	call	PrintStrClr
 589  8436
 590  8436 CD 02 89     	call	FormatDisk
 591  8439 B7           	or		a
 592  843A CA 12 80     	jp		z, HCRunInitDisk
 593  843D
 594  843D              	;Display error for format
 595  843D 6F           	ld		l, a
 596  843E 26 00        	ld		h, 0
 597  8440 11 1B 95     	ld		de, MsgErrCode
 598  8443 CD 6D 88     	call	Byte2Txt
 599  8446 21 10 95     	ld		hl, MsgErr
 600  8449 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 601  844C 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 602  844E CD B4 8E     	call	PrintStrClr
 603  8451 CD 50 8E     	call	ReadChar
 604  8454 C3 12 80     	jp		HCRunInitDisk
 605  8457
 606  8457              CheckExtra2:
 607  8457 FE 32        	cp		'2'
 608  8459 20 05        	jr		nz, CheckExtra3
 609  845B
 610  845B CD D2 89     	call	CopyDisk
 611  845E 18 15        	jr		ExtraMenuExit
 612  8460
 613  8460              CheckExtra3:
 614  8460 FE 33        	cp		'3'
 615  8462 C2 6A 84     	jp		nz, CheckExtra4
 616  8465 CD 5B 8A     	call	CopyDiskToCOM
 617  8468 18 0B        	jr		ExtraMenuExit
 618  846A
 619  846A              CheckExtra4:
 620  846A FE 34        	cp		'4'
 621  846C C2 75 84     	jp		nz, ExtraMenuExit
 622  846F CD B7 8A     	call	CopyDiskFromCOM
 623  8472 C3 12 80     	jp		HCRunInitDisk
 624  8475
 625  8475              ExtraMenuExit:
 626  8475 C3 53 80     	jp		HCRunMain
 627  8478
 628  8478              CheckKeyExit:
 629  8478 FE 30        	cp		'0'
 630  847A C2 57 81     	jp		nz, ReadKeyLoop
 631  847D C3 62 80     	jp		HCRunEnd
 632  8480
 633  8480              MoveIt:
 634  8480 CD 57 8F     	call 	MoveCursor
 635  8483 C3 57 81     	jp		ReadKeyLoop
 636  8486
 637  8486              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638  8486
 639  8486
 640  8486              DisplayFilename:
 641  8486 06 0B        	LD		B, NAMELEN
 642  8488              DispLoop:
 643  8488 1A           	LD		A, (DE)
 644  8489
 645  8489              	;clear bit 7
 646  8489 CB BF        	RES 	7, A
 647  848B 32 81 5C     	LD		(CODE), A
 648  848E
 649  848E 13           	INC		DE
 650  848F D5           	PUSH	DE
 651  8490 C5           	PUSH	BC
 652  8491 CD 8F 8F     		CALL	PrintChar
 653  8494 C1           	POP		BC
 654  8495 D1           	POP 	DE
 655  8496
 656  8496 21 B0 5C     	LD		HL, COL
 657  8499 34           	INC		(HL)
 658  849A 10 EC        	DJNZ	DispLoop
 659  849C              	;now a name is displayed
 660  849C
 661  849C              	;check bounds
 662  849C 3A B1 5C     	LD		A, (LINE)
 663  849F 3C           	INC		A
 664  84A0 FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 665  84A2 38 0A        	JR		C, LineOK
 666  84A4
 667  84A4              	;set names column to the next one
 668  84A4 3A C1 96     	LD		A, (NameCol)
 669  84A7 C6 0C        	ADD		NAMELEN + 1
 670  84A9 32 C1 96     	LD		(NameCol), A
 671  84AC
 672  84AC 3E 00        	LD		A, LST_FIRST_LINE
 673  84AE              LineOK:
 674  84AE 32 B1 5C     	LD		(LINE), A
 675  84B1
 676  84B1 3A C1 96     	LD		A, (NameCol)
 677  84B4 32 B0 5C     	LD		(COL), A
 678  84B7
 679  84B7 C9           	RET
 680  84B8
 681  84B8
 682  84B8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 683  84B8
 684  84B8              DisplayFilenames:
 685  84B8 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 686  84BB ED 53 B0 5C  	ld		(LineCol), de
 687  84BF
 688  84BF 11 C9 96     	ld		de, FileCache
 689  84C2 3A C0 96     	ld		a, (FileCnt)
 690  84C5 B7           	or		a
 691  84C6 C8           	ret		z
 692  84C7
 693  84C7 47           	ld		b,	a
 694  84C8
 695  84C8              DisplayFilenamesLoop:
 696  84C8 C5           	push	bc
 697  84C9 D5           		push	de
 698  84CA CD 86 84     			call	DisplayFilename
 699  84CD D1           		pop		de
 700  84CE EB           		ex		de, hl
 701  84CF 01 19 00     		ld		bc, CACHE_SZ
 702  84D2 09           		add		hl, bc
 703  84D3 EB           		ex		de, hl
 704  84D4 C1           	pop		bc
 705  84D5 10 F1        	djnz	DisplayFilenamesLoop
 706  84D7
 707  84D7 C9           	ret
 708  84D8
 709  84D8
 710  84D8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 711  84D8              ;Selects only valid filenames (not deleted and only from first extension)
 712  84D8              GetFileNames:
 713  84D8 DD 21 AF A5  	ld		ix, TrackBuf
 714  84DC 11 C9 96     	ld		de, FileCache
 715  84DF 06 80        	ld		b, MAX_EXT_CNT
 716  84E1 AF           	xor		a
 717  84E2 32 C0 96     	ld		(FileCnt), a
 718  84E5 21 C5 96     	ld		hl, AUCnt
 719  84E8 77           	ld		(hl), a
 720  84E9 23           	inc		hl
 721  84EA 77           	ld		(hl), a
 722  84EB
 723  84EB              StoreFilenamesLoop:
 724  84EB AF           	xor a
 725  84EC DD BE 00     	cp (ix + EXT_DEL_FLAG)
 726  84EF C2 63 85     	jp nz, NextExt
 727  84F2
 728  84F2              	;count AU
 729  84F2 D9           	exx
 730  84F3 E5           	push hl
 731  84F4 CD 31 89     		call CheckExtAlloc
 732  84F7 EB           		ex de, hl			;save first AU no.
 733  84F8
 734  84F8              		;store disk alocated AU count
 735  84F8 2A C5 96     		ld hl, (AUCnt)
 736  84FB 48           		ld c, b
 737  84FC 06 00        		ld b, 0
 738  84FE 09           		add hl, bc
 739  84FF 22 C5 96     		ld (AUCnt), hl
 740  8502 E1           	pop hl
 741  8503 D9           	exx
 742  8504
 743  8504 AF           	xor	a
 744  8505 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 745  8508 20 32        	jr nz, FindExt
 746  850A
 747  850A DD E5        	push ix
 748  850C E1           	pop hl
 749  850D 23           	inc hl					;skip del flag
 750  850E
 751  850E C5           	push bc
 752  850F ~            		/*
 753  850F ~            		push de
 754  850F ~            			push hl
 755  850F ~            				ex de, hl
 756  850F ~            				call DisplayFilename
 757  850F ~            			pop hl
 758  850F ~            		pop de
 759  850F ~            		*/
 760  850F 01 0B 00     		ld bc, NAMELEN
 761  8512 ED B0        		ldir				;save file name
 762  8514
 763  8514 D9           		exx
 764  8515 D5           		push 	de			;de = first AU
 765  8516 D9           		exx
 766  8517 E1           		pop		hl
 767  8518 EB           		ex		de, hl
 768  8519 73 23 72 2B  		ld		(hl), de	;save first AU
 769  851D
 770  851D 23           		inc		hl
 771  851E 23           		inc		hl
 772  851F
 773  851F D9           		exx					;save AU cnt for file
 774  8520 C5           		push	bc
 775  8521 D9           		exx
 776  8522 C1           		pop		bc
 777  8523 71 23 70 2B  		ld		(hl), bc
 778  8527
 779  8527 23           		inc		hl
 780  8528 23           		inc		hl
 781  8529
 782  8529              		;xor		a			;make flag 0 to signal that header is not read yet
 783  8529              		;ld		(hl), a
 784  8529
 785  8529 01 0A 00     		ld		bc, HDR_SZ + 1
 786  852C 09           		add		hl, bc
 787  852D
 788  852D EB           		ex		de, hl
 789  852E C1           	pop bc
 790  852F
 791  852F
 792  852F 3A C0 96     	ld 		a, (FileCnt)			;inc file counter
 793  8532 3C           	inc		a
 794  8533 32 C0 96     	ld 		(FileCnt), a
 795  8536 FE 5C        	cp		LST_MAX_FILES
 796  8538 38 29        	jr		c, NextExt
 797  853A 18 34        	jr		GetFileNamesEnd
 798  853C
 799  853C
 800  853C              FindExt:					;BC' = AU cnt for this ext
 801  853C C5           	push	bc
 802  853D D5           		push 	de
 803  853E DD E5        			push	ix
 804  8540 D1           			pop		de
 805  8541 13           			inc		de				;DE = name to find
 806  8542
 807  8542 21 C9 96     			ld		hl, FileCache
 808  8545 3A C0 96     			ld		a, (FileCnt)
 809  8548 4F           			ld		c, a
 810  8549 CD AF 8B     			call	FindCache
 811  854C 20 13        			jr		nz, FindExtEnd
 812  854E
 813  854E 01 0D 00     			ld		bc, CACHE_AU_CNT
 814  8551 09           			add		hl, bc
 815  8552 D9           			exx
 816  8553 C5           			push	bc
 817  8554 D9           			exx
 818  8555 C1           			pop		bc
 819  8556
 820  8556 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 821  855A EB           			ex		de, hl
 822  855B 09           			add		hl, bc
 823  855C EB           			ex		de, hl
 824  855D 73 23 72 2B  			ld		(hl), de
 825  8561              FindExtEnd:
 826  8561 D1           		pop		de
 827  8562 C1           	pop		bc
 828  8563
 829  8563              NextExt:
 830  8563 C5           	push bc
 831  8564 01 20 00     		ld bc, EXT_SZ
 832  8567 DD 09        		add ix, bc
 833  8569 C1           	pop	bc
 834  856A
 835  856A 05           	dec	b
 836  856B 78           	ld	a, b
 837  856C B7           	or	a
 838  856D C2 EB 84     	jp	nz, StoreFilenamesLoop
 839  8570              GetFileNamesEnd:
 840  8570 C9           	ret
 841  8571
 842  8571              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 843  8571
 844  8571              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 845  8571              ;IN: HL = file name
 846  8571              HandleFile:
 847  8571              	;Make HL point to the selected file
 848  8571 DD 2A C7 96  	ld		ix, (SelFileCache)
 849  8575 DD E5        	push	ix
 850  8577 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 851  857A B7           		or		a
 852  857B CC C0 8B     		call	z, ReadFileHeader
 853  857E
 854  857E DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 855  8581 FE 00        		cp		PROG_TYPE
 856  8583 28 59        		jr		z, HandleFileProg
 857  8585
 858  8585 FE 03        		cp		BYTE_TYPE
 859  8587 20 65        		jr		nz, HandleFileText
 860  8589
 861  8589 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 861  858D 66 12
 862  858F 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 863  8592 19           		add		hl, de
 864  8593 7C           		ld		a, h
 865  8594 B5           		or		l
 866  8595 28 29        		jr		z, HandleFileSCR
 867  8597
 868  8597
 869  8597              HandleFileCODE:
 870  8597 21 3E 95     		ld		hl, MsgLoadingCODE
 871  859A 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 872  859D 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 873  859F CD B4 8E     		call	PrintStrClr
 874  85A2
 875  85A2              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 876  85A2 21 2A 8B     		ld		hl, IF1FileLoad
 877  85A5 11 00 5B     		ld		de, PRN_BUF
 878  85A8 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 879  85AB ED B0        		ldir
 880  85AD 3E C9        		ld		a, $C9
 881  85AF 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 882  85B0
 883  85B0 E1           	pop		hl
 884  85B1 ED 5B B2 A5  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 885  85B5 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 886  85B6 C1           	pop		bc						;2nd, 3rd call for error handler
 887  85B7 C1           	pop		bc
 888  85B8 ED 43 3D 5C  	ld		(ERRSP), bc
 889  85BC D5           	push	de						;push CODE address to return to = start of CODE block
 890  85BD C3 00 5B     	jp		PRN_BUF
 891  85C0
 892  85C0
 893  85C0
 894  85C0
 895  85C0              HandleFileSCR:
 896  85C0 21 2F 95     		ld		hl, MsgLoadingSCR
 897  85C3 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 898  85C6 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 899  85C8 CD B4 8E     		call	PrintStrClr
 900  85CB
 901  85CB E1           	pop		hl
 902  85CC
 903  85CC              	IFDEF _ROM_FNT_
 904  85CC              		;Load to alternate SCREEN$ memory
 905  85CC 11 00 C0     		ld		de, HC_VID_BANK1
 906  85CF CD 2A 8B     		call	IF1FileLoad
 907  85D2
 908  85D2              		;Set display to alternate SCREEN$ memory
 909  85D2 3E 08        		ld		a, HC_CFG_VID_C000
 910  85D4 D3 7E        		out 	(HC_CFG_PORT), a
 911  85D6 CD 50 8E     		call	ReadChar
 912  85D9
 913  85D9              		;Set back to regular SCREEN$ memory
 914  85D9 3E 00        		ld		a, HC_CFG_VID_4000
 915  85DB D3 7E        		out 	(HC_CFG_PORT), a
 916  85DD              	ELSE
 917  85DD ~            		ld		de, HC_VID_BANK0
 918  85DD ~            		call	IF1FileLoad
 919  85DD ~            		call	ReadChar
 920  85DD              	ENDIF
 921  85DD
 922  85DD C9           	ret
 923  85DE
 924  85DE              HandleFileProg:
 925  85DE 21 20 95     		ld		hl, MsgLoadingPrg
 926  85E1 11 00 11     		ld		de, LST_LINE_MSG+1 << 8
 927  85E4 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 928  85E6 CD B4 8E     		call	PrintStrClr
 929  85E9 E1           	pop		hl
 930  85EA CD 27 8C     	call	LoadProgram
 931  85ED C9           	ret
 932  85EE
 933  85EE
 934  85EE              HandleFileText:
 935  85EE E1           	pop		hl
 936  85EF
 937  85EF
 938  85EF              ViewFile:
 939  85EF CD 6C 8E     	call	ClrScr
 940  85F2 2A C7 96     	ld		hl, (SelFileCache)
 941  85F5 CD 06 8E     	call	ReadFileSection					;DE = last address read
 942  85F8 21 AF A6     	ld		hl, FileData
 943  85FB              	;Calculate size of read buffer
 944  85FB E5           	push	hl
 945  85FC EB           		ex	de, hl
 946  85FD B7           		or	a
 947  85FE ED 52        		sbc	hl, de
 948  8600 44           		ld	b, h
 949  8601 4B           		ld	c, e
 950  8602 E1           	pop		hl
 951  8603 CD 13 90     	call	InitViewer
 952  8606 CD 6D 90     	call	PrintLoop
 953  8609              ViewFileEnd:
 954  8609 C9           	ret
 955  860A
 956  860A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 957  860A
 958  860A
 959  860A              DisplayFileInfo:
 960  860A 2A C7 96     	ld		hl, (SelFileCache)
 961  860D E5           	push	hl
 962  860E              		;disk size - at least 2KB ==1  AU
 963  860E 01 0D 00     		ld		bc, CACHE_AU_CNT
 964  8611 09           		add		hl, bc
 965  8612 5E 23 56 2B  		ld		de, (hl)
 966  8616 EB           		ex		de, hl
 967  8617              		;*2, since one block (AU) is 2KB.
 968  8617 CB 15        		rl	l
 969  8619 CB 14        		rl	h
 970  861B
 971  861B 11 57 95     		ld		de, MsgFileSzDskN
 972  861E CD 62 88     		call	Word2Txt
 973  8621 21 4E 95     		ld		hl, MsgFileSzDsk
 974  8624 11 00 0B     		ld		de, LST_FILE_INFO + 1 << 8
 975  8627 CD 8C 8E     		call	PrintStr
 976  862A E1           	pop		hl
 977  862B E5           	push	hl
 978  862C              		;attributes
 979  862C 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 980  862F 09           		add		hl, bc
 981  8630 EB           		ex		de, hl
 982  8631 21 67 95     		ld		hl, MsgFileAttrN
 983  8634 1A           		ld		a, (de)
 984  8635 E6 80        		and		%10000000
 985  8637 28 14        		jr		z, NotRO
 986  8639
 987  8639 01 52 2F     		ld		bc, '/R'
 988  863C 71 23 70 2B  		ld		(hl), bc
 989  8640 23           		inc		hl
 990  8641 23           		inc		hl
 991  8642 01 4F 2C     		ld		bc, ',O'
 992  8645 71 23 70 2B  		ld		(hl), bc
 993  8649 23           		inc		hl
 994  864A 23           		inc		hl
 995  864B 18 12        		jr		CheckSys
 996  864D              NotRO:
 997  864D 01 2D 2D     		ld		bc, '--'
 998  8650 71 23 70 2B  		ld		(hl), bc
 999  8654 23           		inc		hl
1000  8655 23           		inc		hl
1001  8656 01 2D 2C     		ld		bc, ',-'
1002  8659 71 23 70 2B  		ld		(hl), bc
1003  865D 23           		inc		hl
1004  865E 23           		inc		hl
1005  865F
1006  865F              CheckSys:
1007  865F 13           		inc		de
1008  8660 1A           		ld		a, (de)
1009  8661 E6 80        		and		%10000000
1010  8663 28 0E        		jr		z, NotSYS
1011  8665
1012  8665 01 48 49     		ld		bc, 'IH'
1013  8668 71 23 70 2B  		ld		(hl), bc
1014  866C 23           		inc		hl
1015  866D 23           		inc		hl
1016  866E 3E C4        		ld		a, 'D' + $80
1017  8670 77           		ld		(hl), a
1018  8671 18 0C        		jr		AttrEnd
1019  8673              NotSYS:
1020  8673 01 2D 2D     		ld		bc, '--'
1021  8676 71 23 70 2B  		ld		(hl), bc
1022  867A 23           		inc		hl
1023  867B 23           		inc		hl
1024  867C 3E AD        		ld		a, '-' + $80
1025  867E 77           		ld		(hl), a
1026  867F              AttrEnd:
1027  867F 11 00 0C     		ld		de, LST_FILE_INFO + 2 << 8
1028  8682 21 5E 95     		ld		hl, MsgFileAttr
1029  8685 CD 8C 8E     		call	PrintStr
1030  8688 DD E1        	pop		ix
1031  868A DD E5        	push	ix
1032  868C DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1033  868F B7           		or		a
1034  8690 CA 2D 87             jp		z, HeadNotRead
1035  8693
1036  8693 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1037  8696 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1038  8699 CA 2D 87             jp		z, HeadNotRead
1039  869C
1040  869C DD 7E 10     		ld		a, (ix + CACHE_HDR)
1041  869F FE 00        		cp		PROG_TYPE
1042  86A1 20 0B        		jr		nz, CheckNoArr
1043  86A3
1044  86A3 21 81 95     		ld		hl, MsgFileTypePrg
1045  86A6 11 77 95     		ld		de, MsgFileTypeN
1046  86A9 CD 76 87     		call	MoveMsg
1047  86AC 18 4F        		jr		PrepFileLen
1048  86AE
1049  86AE              CheckNoArr:
1050  86AE FE 01        		cp		NUMB_TYPE
1051  86B0 20 0B        		jr		nz, CheckChrArr
1052  86B2
1053  86B2 21 9D 95     		ld		hl, MsgFileTypeNoA
1054  86B5 11 77 95     		ld		de, MsgFileTypeN
1055  86B8 CD 76 87     		call	MoveMsg
1056  86BB 18 40        		jr		PrepFileLen
1057  86BD
1058  86BD              CheckChrArr:
1059  86BD FE 02        		cp		CHAR_TYPE
1060  86BF 20 0B        		jr		nz, CheckByte
1061  86C1
1062  86C1 21 96 95     		ld		hl, MsgFileTypeChrA
1063  86C4 11 77 95     		ld		de, MsgFileTypeN
1064  86C7 CD 76 87     		call	MoveMsg
1065  86CA 18 31        		jr		PrepFileLen
1066  86CC
1067  86CC              CheckByte:
1068  86CC FE 03        		cp		BYTE_TYPE
1069  86CE 20 24        		jr		nz, CheckText
1070  86D0
1071  86D0 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1071  86D4 66 12
1072  86D6 01 00 E5     		ld		bc, -SCR_LEN
1073  86D9 09           		add		hl, bc
1074  86DA 7C           		ld		a, h
1075  86DB B5           		or		l
1076  86DC 20 0B        		jr		nz, NotScr
1077  86DE
1078  86DE 21 8F 95     		ld		hl, MsgFileTypeSCR
1079  86E1 11 77 95     		ld		de, MsgFileTypeN
1080  86E4 CD 76 87     		call	MoveMsg
1081  86E7 18 14        		jr		PrepFileLen
1082  86E9              NotScr:
1083  86E9 21 88 95     		ld		hl, MsgFileTypeByte
1084  86EC 11 77 95     		ld		de, MsgFileTypeN
1085  86EF CD 76 87     		call	MoveMsg
1086  86F2 18 09        		jr		PrepFileLen
1087  86F4
1088  86F4              CheckText:
1089  86F4 21 A4 95     		ld		hl, MsgFileTypeText
1090  86F7 11 77 95     		ld		de, MsgFileTypeN
1091  86FA CD 76 87     		call	MoveMsg
1092  86FD
1093  86FD              PrepFileLen:
1094  86FD              		;File len
1095  86FD DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1096  8700 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1097  8703              PrepFileLenText:
1098  8703 11 BB 95     		ld		de, MsgFileLenN
1099  8706 CD 62 88     		call	Word2Txt
1100  8709 26 C2        		ld		h, 'B' | $80
1101  870B 2E 20        		ld		l, ' '
1102  870D 22 C0 95     		ld		(MsgFileLenN + 5), hl
1103  8710
1104  8710 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1105  8713 FE 00        		cp		PROG_TYPE
1106  8715 28 06        		jr		z, PrintProgStart
1107  8717
1108  8717 FE 03        		cp		BYTE_TYPE
1109  8719 28 0A        		jr		z, PrintByteStart
1110  871B
1111  871B 18 22        		jr		PrintStartNotRead
1112  871D
1113  871D              PrintProgStart:
1114  871D DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1115  8720 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1116  8723 18 25        		jr		PrintStart
1117  8725
1118  8725              PrintByteStart:
1119  8725 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1120  8728 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1121  872B 18 1D        		jr		PrintStart
1122  872D
1123  872D              HeadNotRead:
1124  872D 21 AB 95             ld        hl, MsgNA
1125  8730 11 77 95             ld        de, MsgFileTypeN
1126  8733 CD 76 87             call    MoveMsg
1127  8736
1128  8736 21 AB 95     		ld		hl, MsgNA
1129  8739 11 BB 95     		ld		de, MsgFileLenN
1130  873C CD 76 87     		call	MoveMsg
1131  873F
1132  873F              PrintStartNotRead:
1133  873F 21 AB 95     		ld		hl, MsgNA
1134  8742 11 CB 95     		ld		de, MsgFileStartN
1135  8745 CD 76 87     		call	MoveMsg
1136  8748 18 0E        		jr		PrintStartStr
1137  874A
1138  874A              PrintStart:
1139  874A 1E 20        	ld		e, ' '
1140  874C 16 A0        	ld		d, ' ' | $80
1141  874E ED 53 D0 95  	ld		(MsgFileStartN + 5), de
1142  8752 11 CB 95     	ld		de, MsgFileStartN
1143  8755 CD 62 88     	call	Word2Txt
1144  8758              PrintStartStr:
1145  8758 11 00 0E     	ld		de, LST_FILE_INFO + 4 << 8
1146  875B 21 C2 95     	ld		hl, MsgFileStart
1147  875E CD 8C 8E     	call	PrintStr
1148  8761
1149  8761 DD E1        	pop		ix
1150  8763 11 00 0D     	ld		de, LST_FILE_INFO + 3 << 8
1151  8766 21 6E 95     	ld		hl, MsgFileType
1152  8769 CD 8C 8E     	call	PrintStr
1153  876C
1154  876C 11 00 0F     	ld		de, LST_FILE_INFO + 5 << 8
1155  876F 21 B2 95     	ld		hl, MsgFileLen
1156  8772 CD 8C 8E     	call	PrintStr
1157  8775
1158  8775 C9           	ret
1159  8776
1160  8776              MoveMsg:
1161  8776 01 07 00     	ld		bc, 7
1162  8779 ED B0        	ldir
1163  877B C9           	ret
1164  877C
1165  877C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1166  877C
1167  877C              ReadAllHeaders:
1168  877C 21 D2 95     	ld		hl, MsgReadingExt
1169  877F 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
1170  8782 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1171  8784 CD B4 8E     	call	PrintStrClr
1172  8787
1173  8787 CD 46 81     	call	CalcFileCache
1174  878A
1175  878A 3A C2 96     	ld		a, (SelFile)
1176  878D 47           	ld		b, a
1177  878E 3A C0 96     	ld		a, (FileCnt)
1178  8791 90           	sub		b
1179  8792 B7           	or		a
1180  8793 C8           	ret		z
1181  8794
1182  8794 47           	ld		b, a
1183  8795
1184  8795 DD 2A C7 96  	ld		ix, (SelFileCache)
1185  8799              NextFile:
1186  8799 C5           	push	bc
1187  879A CD C0 8B     		call	ReadFileHeader
1188  879D 01 19 00     		ld		bc, CACHE_SZ
1189  87A0 DD 09        		add		ix, bc
1190  87A2 DD E5        		push	ix
1191  87A4 CD 46 81     			call	CalcFileCache
1192  87A7 CD 0A 86     			call	DisplayFileInfo
1193  87AA DD E1        		pop		ix
1194  87AC
1195  87AC CD 53 8E     		call	KbdHit
1196  87AF 38 03        		jr		c, AKey
1197  87B1 C1           	pop		bc
1198  87B2 18 15        	jr		ReadAllHeadersEnd
1199  87B4
1200  87B4              AKey:
1201  87B4 3A C2 96     		ld		a, (SelFile)
1202  87B7 3C           		inc		a
1203  87B8 47           		ld		b, a
1204  87B9 3A C0 96     		ld		a, (FileCnt)
1205  87BC B8           		cp		b
1206  87BD 28 16        		jr		z, DontInc
1207  87BF 78           		ld		a, b
1208  87C0 32 C2 96     		ld		(SelFile), a
1209  87C3 CD 57 8F     		call	MoveCursor
1210  87C6 C1           	pop		bc
1211  87C7 10 D0        	djnz	NextFile
1212  87C9
1213  87C9              ReadAllHeadersEnd:
1214  87C9 21 E0 95     	ld		hl, MsgClear
1215  87CC 11 00 11     	ld		de, LST_LINE_MSG+1 << 8
1216  87CF 3E 0F        	ld		a, SCR_DEF_CLR
1217  87D1 CD B4 8E     	call	PrintStrClr
1218  87D4 C9           	ret
1219  87D5
1220  87D5              DontInc:
1221  87D5 C1           	pop		bc
1222  87D6 18 F1        	jr		ReadAllHeadersEnd
1223  87D8
1224  87D8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1225  87D8              ;Will report HC version based on copyright string. For HC2000 will report v1/v2. For IF1 will report v1/v2.
1226  87D8              ;Versions:
1227  87D8              ;"HC - 85", 6, 32, 32, 32, 32, "I.C.E FELIX"
1228  87D8              ;"HC - 90", 6, 32, 32, 32, 32, "I.C.E FELIX"
1229  87D8              ;"HC - 91", 6, 32, 32, 32, 32, "I.C.E FELIX"
1230  87D8              ;"HC2000 ICE FELIX COMPUTER SA" - v1
1231  87D8              ;"HC2000", 6, 32, 32, 32, 32, "I.C.E FELIX" - v2
1232  87D8              PrintIntro:
1233  87D8 21 12 94     	ld		hl, VerMsg1
1234  87DB 11 00 01     	ld		de, LST_PROG_INFO + 1 << 8
1235  87DE CD 8C 8E     	call	PrintStr
1236  87E1 21 22 94     	ld		hl, VerMsg2
1237  87E4 11 00 02     	ld		de, LST_PROG_INFO + 2 << 8
1238  87E7 CD 8C 8E     	call	PrintStr
1239  87EA 21 32 94     	ld		hl, VerMsg3
1240  87ED 11 00 03     	ld		de, LST_PROG_INFO + 3 << 8
1241  87F0 CD 8C 8E     	call	PrintStr
1242  87F3
1243  87F3 21 39 15     	ld		hl, STR_MSG_BASIC
1244  87F6 11 59 94     	ld		de, MsgCompModelName
1245  87F9 06 07        	ld		b, 7
1246  87FB              PrintComputerInfoLoop:
1247  87FB 7E           	ld		a, (hl)
1248  87FC FE 20        	cp		' '
1249  87FE 28 02        	jr		z, PrintComputerInfoSkip
1250  8800 12           	ld		(de), a
1251  8801 13           	inc		de
1252  8802              PrintComputerInfoSkip:
1253  8802 23           	inc		hl
1254  8803 10 F6        	djnz	PrintComputerInfoLoop
1255  8805
1256  8805 3A 3B 15     	ld		a, (STR_MSG_BASIC + 2)
1257  8808 FE 32        	cp		'2'
1258  880A 20 1E        	jr		nz, PrintComputerInfoIF1
1259  880C
1260  880C              	;HC2000
1261  880C 3E 20        	ld		a, ' '
1262  880E 12           	ld		(de), a
1263  880F 13           	inc		de
1264  8810 3E 76        	ld		a, 'v'
1265  8812 12           	ld		(de), a
1266  8813 13           	inc		de
1267  8814
1268  8814 7E           	ld		a, (hl)
1269  8815 FE 49        	cp		'I'
1270  8817 28 04        	jr		z, HC2000v1
1271  8819 3E B2        	ld		a, '2' | $80
1272  881B 18 02        	jr		HC2000Store
1273  881D              HC2000v1:
1274  881D 3E B1        	ld		a, '1' | $80
1275  881F              HC2000Store:
1276  881F 12           	ld		(de), a
1277  8820 13           	inc		de
1278  8821              	;Patch code to look for HC2000 IF1 string at a different address.
1279  8821 21 35 88     	ld		hl, GetIF1String+1
1280  8824 11 F0 27     	ld		de, STR_MSG_IF1_2000
1281  8827 73           	ld		(hl), e
1282  8828 23           	inc		hl
1283  8829 72           	ld		(hl), d
1284  882A
1285  882A              PrintComputerInfoIF1:
1286  882A 21 34 88     	ld		hl, GetIF1String
1287  882D 11 4F 88     	ld		de, PrintCompInfo
1288  8830 D5           	push	de
1289  8831 C3 21 8C     	jp		IF1Call
1290  8834
1291  8834              GetIF1String:
1292  8834 21 F0 23     	ld		hl, STR_MSG_IF1_91
1293  8837 11 69 94     	ld		de, MsgIF1Date
1294  883A 3E 2E        	ld		a, '.'
1295  883C              GetIF1StringLoop:
1296  883C ED A0        	ldi
1297  883E ED A0        	ldi
1298  8840 12           	ld		(de), a
1299  8841 13           	inc		de
1300  8842 ED A0        	ldi
1301  8844 ED A0        	ldi
1302  8846 12           	ld		(de), a
1303  8847 13           	inc		de
1304  8848 ED A0        	ldi
1305  884A 7E           	ld		a, (hl)
1306  884B F6 80        	or		$80
1307  884D 12           	ld		(de), a
1308  884E C9           	ret
1309  884F
1310  884F              PrintCompInfo:
1311  884F 21 52 94     	ld		hl, MsgCompModel
1312  8852 11 00 04     	ld		de, LST_PROG_INFO + 4 << 8
1313  8855 CD 8C 8E     	call	PrintStr
1314  8858
1315  8858 21 62 94     	ld		hl, MsgIF1Version
1316  885B 11 00 05     	ld		de, LST_PROG_INFO + 5 << 8
1317  885E CD 8C 8E     	call	PrintStr
1318  8861
1319  8861 C9           	ret
1320  8862              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1321  8862
1322  8862              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 8862              	ifndef	_HCCFG_
   2+ 8862              	define	_HCCFG_
   3+ 8862
   4+ 8862              ;HC specific code, for configuration
   5+ 8862
   6+ 8862              HC_CFG_PORT			EQU	$7E
   7+ 8862
   8+ 8862              ;BASIC/CPM ROM selection
   9+ 8862              HC_CFG_ROM_BAS		EQU	%0
  10+ 8862              HC_CFG_ROM_CPM		EQU	%1
  11+ 8862
  12+ 8862              ;Address for ROM paging: 0 or $E000
  13+ 8862              HC_CFG_ROM_0000		EQU %00
  14+ 8862              HC_CFG_ROM_E000		EQU %10
  15+ 8862
  16+ 8862              ;Cfg. port Enable/Disable
  17+ 8862              HC_CFG_PORT_DIS		EQU %000
  18+ 8862              HC_CFG_PORT_EN		EQU	%100
  19+ 8862
  20+ 8862              ;Video memory bank: $4000 or $C000
  21+ 8862              HC_CFG_VID_4000		EQU	%0000
  22+ 8862              HC_CFG_VID_C000		EQU	%1000
  23+ 8862
  24+ 8862
  25+ 8862              ;Standar BASIC config
  26+ 8862              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 8862              ;Standar CP/M config
  28+ 8862              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 8862
  30+ 8862
  31+ 8862              HC_VID_BANK0		EQU	$4000
  32+ 8862              HC_VID_BANK1		EQU	$C000
  33+ 8862
  34+ 8862              	endif
# file closed: hccfg.asm
1323  8862              	include "if1.asm"
# file opened: if1.asm
   1+ 8862              ;HC IF1 routines and constants
   2+ 8862
   3+ 8862              ;IF1 routines error codes, also returned by BASIC commands
   4+ 8862              ;12 = Writing to a 'read' file
   5+ 8862              ;13 = Reading a 'write' file
   6+ 8862              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 8862              ;15 = Disk full (disk or catalog full)
   8+ 8862              ;16 = Disk error (hardware error)
   9+ 8862              ;17 = File not found
  10+ 8862              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 8862              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 8862
  13+ 8862              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 8862              ;00h = OK
  15+ 8862              ;08h = cannot format disk
  16+ 8862              ;10h = disk protected (read-only?)
  17+ 8862              ;20h = volume error
  18+ 8862              ;40h = drive error
  19+ 8862              ;80h = reading error
  20+ 8862              ;Codes I encountered:
  21+ 8862              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 8862
  23+ 8862
  24+ 8862              	ifndef	_DISK_
  25+ 8862              	define	_DISK_
  26+ 8862
  27+ 8862              	include	"math.asm"
# file opened: math.asm
   1++8862              	ifndef	_MATH_
   2++8862              	define	_MATH_
   3++8862
   4++8862              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++8862              ;http://map.tni.nl/sources/external/z80bits.html
   6++8862
   7++8862
   8++8862              Word2Txt:
   9++8862              	IFUSED
  10++8862 D5           	push	de
  11++8863 CD 83 88     		call	Word2Txt_
  12++8866 D1           	pop		de
  13++8867
  14++8867 06 04        	ld		b, 4
  15++8869 CD 78 88     	call	StrippLeading0
  16++886C C9           	ret
  17++886D
  18++886D              Byte2Txt:
  19++886D D5           	push	de
  20++886E CD 8F 88     		call	Byte2Txt_
  21++8871 D1           	pop		de
  22++8872
  23++8872 06 02        	ld		b, 2
  24++8874 CD 78 88     	call	StrippLeading0
  25++8877 C9           	ret
  26++8878              	ENDIF
  27++8878
  28++8878
  29++8878              StrippLeading0:
  30++8878 1A           	ld		a, (de)
  31++8879 FE 31        	cp		'1'
  32++887B D0           	ret		nc
  33++887C
  34++887C 3E 20        	ld		a, ' '
  35++887E 12           	ld		(de), a
  36++887F 13           	inc		de
  37++8880 10 F6        	djnz	StrippLeading0
  38++8882 C9           	ret
  39++8883
  40++8883
  41++8883              ;Converts the number in HL to ASCII in decimal string at DE
  42++8883              Word2Txt_:
  43++8883 01 F0 D8     	ld bc, -10000
  44++8886 CD 9E 88     	call DigitLoop
  45++8889 01 18 FC     	ld bc, -1000
  46++888C CD 9E 88     	call DigitLoop
  47++888F              Byte2Txt_:
  48++888F 01 9C FF     	ld bc, -100
  49++8892 CD 9E 88     	call DigitLoop
  50++8895 01 F6 FF     	ld bc, -10
  51++8898 CD 9E 88     	call DigitLoop
  52++889B 01 FF FF     	ld bc, -1
  53++889E
  54++889E              DigitLoop:
  55++889E 3E 2F        	ld	a, '0' - 1
  56++88A0              DivNrLoop:
  57++88A0 3C           	inc	a			;increase reminder
  58++88A1 09           	add	hl, bc		;substract divizor
  59++88A2 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++88A4 ED 42        	sbc	hl, bc		;nope, restore
  61++88A6
  62++88A6 12           	ld (de), a
  63++88A7 13           	inc de
  64++88A8 C9           	ret
  65++88A9
  66++88A9
  67++88A9              ;Input: HL = Dividend, C = Divisor
  68++88A9              ;Output: HL = Quotient, A = Remainder
  69++88A9              ;Warning: doesn't work with divisor >= $80
  70++88A9              Div:
  71++88A9              	IFUSED
  72++88A9 AF           	xor a
  73++88AA 06 10        	ld b, 16
  74++88AC
  75++88AC              DivLoop:
  76++88AC 29           	add	hl,hl
  77++88AD 17           	rla
  78++88AE B9           	cp	c
  79++88AF 38 02        	jr	c, NoSub
  80++88B1 91           	sub	c
  81++88B2 2C           	inc	l
  82++88B3              NoSub:
  83++88B3 10 F7        	djnz DivLoop
  84++88B5
  85++88B5 C9           	ret
  86++88B6              	ENDIF
  87++88B6
  88++88B6              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++88B6              ;Output: A:C = Quotient, HL = Remainder
  90++88B6              Div2:
  91++88B6 21 00 00     	ld hl, 0
  92++88B9 06 10        	ld b, 16
  93++88BB              Div2Loop:
  94++88BB CB 31        	sll c		; unroll 16 times
  95++88BD 17           	rla			; ...
  96++88BE ED 6A        	adc	hl,hl		; ...
  97++88C0 ED 52        	sbc	hl,de		; ...
  98++88C2 30 02        	jr	nc,$+4		; ...
  99++88C4 19           	add	hl,de		; ...
 100++88C5 0D           	dec	c		; ...
 101++88C6 10 F3        	djnz Div2Loop
 102++88C8 C9           	ret
 103++88C9
 104++88C9
 105++88C9              ;Input: A = Multiplier, DE = Multiplicand
 106++88C9              ;Output: A:HL = Product
 107++88C9              Mul:
 108++88C9              	IFUSED
 109++88C9 21 00 00     	ld hl, 0
 110++88CC 01 00 07     	ld bc, $0700
 111++88CF
 112++88CF 87           	add	a, a		; optimised 1st iteration
 113++88D0 30 02        	jr	nc, MulLoop
 114++88D2 62           	ld	h, d
 115++88D3 6B           	ld	l, e
 116++88D4
 117++88D4              MulLoop:
 118++88D4 29           	add	hl,hl
 119++88D5 17           	rla
 120++88D6 30 02        	jr	nc, NoAdd
 121++88D8 19           	add	hl,de
 122++88D9 89           	adc	a,c
 123++88DA              NoAdd:
 124++88DA 10 F8        	djnz MulLoop
 125++88DC
 126++88DC C9           	ret
 127++88DD              	ENDIF
 128++88DD
 129++88DD              	endif
# file closed: math.asm
  28+ 88DD
  29+ 88DD              DRIVE_CUR_BAS	EQU 0
  30+ 88DD              DRIVE_A_BAS		EQU	1
  31+ 88DD              DRIVE_B_BAS		EQU	2
  32+ 88DD              DRIVE_A_CPM		EQU	0
  33+ 88DD              DRIVE_B_CPM		EQU	1
  34+ 88DD              ;Disk geometry stuff
  35+ 88DD              SPT				EQU	16			;sectors per track
  36+ 88DD              SECT_SZ			EQU	256			;sector size in bytes
  37+ 88DD              TRACK_CNT		EQU	80			;track count
  38+ 88DD              HEAD_CNT		EQU	2			;disk face count
  39+ 88DD              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 88DD              EXT_SZ			EQU	32			;directory entry size
  41+ 88DD              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 88DD              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 88DD              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 88DD              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 88DD              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 88DD              REC_SZ			EQU 128			;cp/m record size
  47+ 88DD              DEL_MARKER		EQU	$E5
  48+ 88DD
  49+ 88DD
  50+ 88DD              ;Extension structure (directory entry)
  51+ 88DD              EXT_DEL_FLAG	EQU	0
  52+ 88DD              EXT_NAME		EQU 1
  53+ 88DD              EXT_IDX			EQU 12
  54+ 88DD              EXT_S1			EQU 13
  55+ 88DD              EXT_S2			EQU 14
  56+ 88DD              EXT_RC			EQU	15
  57+ 88DD              EXT_AU0			EQU	16
  58+ 88DD              EXT_AU1			EQU	18
  59+ 88DD              EXT_AU2			EQU	20
  60+ 88DD              EXT_AU3			EQU	22
  61+ 88DD              EXT_AU4			EQU	24
  62+ 88DD              EXT_AU5			EQU	26
  63+ 88DD              EXT_AU6			EQU	28
  64+ 88DD              EXT_AU7			EQU	30
  65+ 88DD              EXT_SIZE		EQU 32
  66+ 88DD
  67+ 88DD              ;FCB structure
  68+ 88DD              FCB_DRIVE		EQU 0
  69+ 88DD              FCB_NAME		EQU EXT_NAME
  70+ 88DD              FCB_EX_IDX		EQU EXT_IDX
  71+ 88DD              FCB_S1			EQU EXT_S1
  72+ 88DD              FCB_S2			EQU EXT_S2
  73+ 88DD              FCB_RC			EQU	EXT_RC
  74+ 88DD              FCB_AU			EQU	EXT_AU0
  75+ 88DD              FCB_CR			EQU	32
  76+ 88DD              FCB_R0			EQU 33
  77+ 88DD              FCB_R1			EQU 34
  78+ 88DD              FCB_R2			EQU 35
  79+ 88DD              FCB_SIZE		EQU 36
  80+ 88DD
  81+ 88DD
  82+ 88DD
  83+ 88DD              ;System variables for disk
  84+ 88DD              DSTR1			EQU	$5CD6		;drive
  85+ 88DD              FSTR1			EQU	$5CDC		;file name
  86+ 88DD              NSTR1			EQU	$5CDA		;name length
  87+ 88DD              HD11			EQU	$5CED		;BDOS argument
  88+ 88DD              COPIES			EQU	$5CEF		;BDOS function
  89+ 88DD
  90+ 88DD              ERRSP			EQU $5C3D
  91+ 88DD              ERRNR			EQU $5C3A
  92+ 88DD              ERRMSG			EQU	$0260
  93+ 88DD
  94+ 88DD              PROG			EQU $5C53
  95+ 88DD              VARS			EQU	$5C4B
  96+ 88DD              STKEND			EQU	$5C65
  97+ 88DD
  98+ 88DD              PRN_BUF			EQU	23296
  99+ 88DD
 100+ 88DD              STR_MSG_BASIC	EQU	$1539
 101+ 88DD              STR_MSG_BASIC_LEN EQU 32
 102+ 88DD              STR_MSG_IF1_2000	EQU $27F0
 103+ 88DD              STR_MSG_IF1_91		EQU $23F0
 104+ 88DD              STR_MSG_IF1_LEN EQU 31
 105+ 88DD
 106+ 88DD              REPDEL			EQU	23561
 107+ 88DD              REPPER			EQU	23562
 108+ 88DD              PIP				EQU	23609
 109+ 88DD
 110+ 88DD
 111+ 88DD              ;RWTS routine commands
 112+ 88DD              RWTS_CMD_POS	EQU	0			;position head
 113+ 88DD              RWTS_CMD_READ	EQU	1			;read sector
 114+ 88DD              RWTS_CMD_WRITE	EQU	2			;write sector
 115+ 88DD              RWTS_CMD_FMT	EQU	4			;format all tracks
 116+ 88DD
 117+ 88DD
 118+ 88DD              ;File name stuff
 119+ 88DD              NAMELEN			EQU	11			;name length
 120+ 88DD              RO_POS			EQU	8			;read-only attribute position in name
 121+ 88DD              SYS_POS			EQU	9			;system attribute position in name
 122+ 88DD
 123+ 88DD              ;File types (first byte in header)
 124+ 88DD              PROG_TYPE		EQU	0			;program
 125+ 88DD              NUMB_TYPE		EQU	1			;number array
 126+ 88DD              CHAR_TYPE		EQU	2			;char array
 127+ 88DD              BYTE_TYPE		EQU	3			;bytes
 128+ 88DD              TEXT_TYPE		EQU	4			;text, >= 4
 129+ 88DD
 130+ 88DD              ;File header offsets
 131+ 88DD              HDR_TYPE		EQU	0
 132+ 88DD              HDR_LEN			EQU 1
 133+ 88DD              HDR_ADDR		EQU 3
 134+ 88DD              HDR_PLEN		EQU	5
 135+ 88DD              HDR_LINE		EQU 7
 136+ 88DD              HDR_SZ			EQU	9
 137+ 88DD
 138+ 88DD              ;BASIC disk channel structure
 139+ 88DD              CH_RW_FLAG		EQU 11
 140+ 88DD              CH_FCB			EQU	12
 141+ 88DD              CH_DATA			EQU	50
 142+ 88DD              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143+ 88DD
 144+ 88DD              CACHE_NAME		EQU	0					;11B
 145+ 88DD              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146+ 88DD              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147+ 88DD              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148+ 88DD              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149+ 88DD              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150+ 88DD
 151+ 88DD              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152+ 88DD
 153+ 88DD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154+ 88DD              IF1Init:
 155+ 88DD CF           	rst		08
 156+ 88DE 31           	defb	49		;create system variables
 157+ 88DF C9           	ret
 158+ 88E0
 159+ 88E0              ;ReadWriteTrackSector
 160+ 88E0              ;A=command: 0, 1, 2, 4
 161+ 88E0              RWTS:
 162+ 88E0 32 7C 8C     	ld (RWTSCmd), a
 163+ 88E3 21 71 8C     	ld hl, RWTSParams
 164+ 88E6 22 ED 5C     	ld (HD11), hl
 165+ 88E9 CF           	rst 08
 166+ 88EA 3A           	DEFB 58
 167+ 88EB C9           	ret
 168+ 88EC
 169+ 88EC
 170+ 88EC              ;D = sector, E = track
 171+ 88EC              ;HL = dma
 172+ 88EC              ReadOneDiskSector:
 173+ 88EC 22 76 8C     	ld (RWTSDMA), hl
 174+ 88EF ED 53 74 8C  	ld (RWTSTrack), de
 175+ 88F3              	;ld (RWTSDrive), a
 176+ 88F3 3E 01        	ld a, RWTS_CMD_READ
 177+ 88F5 18 E9        	jr	RWTS
 178+ 88F7
 179+ 88F7              ;D = sector, E = track
 180+ 88F7              ;HL = dma
 181+ 88F7              WriteOneDiskSector:
 182+ 88F7 22 76 8C     	ld (RWTSDMA), hl
 183+ 88FA ED 53 74 8C  	ld (RWTSTrack), de
 184+ 88FE              	;ld (RWTSDrive), a
 185+ 88FE 3E 02        	ld a, RWTS_CMD_WRITE
 186+ 8900 18 DE        	jr	RWTS
 187+ 8902
 188+ 8902              FormatDisk:
 189+ 8902 21 AF A5     	ld		hl, DataBuf
 190+ 8905 36 E5        	ld		(hl), DEL_MARKER
 191+ 8907 22 76 8C     	ld 		(RWTSDMA), hl
 192+ 890A 3E 04        	ld 		a, RWTS_CMD_FMT
 193+ 890C CD E0 88     	call	RWTS
 194+ 890F 3A 7D 8C     	ld		a, (RWTSRes)
 195+ 8912 C9           	ret
 196+ 8913
 197+ 8913              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198+ 8913
 199+ 8913              ;Allocation unit no. to track/sector
 200+ 8913              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201+ 8913              ;IN:  HL=alloc. unit no.
 202+ 8913              ;OUT: B=sector; C=track (head is determined by the sector number)
 203+ 8913              AU2TS:
 204+ 8913 0E 02        	ld c, SPT/SPAL
 205+ 8915 CD A9 88     	call Div					;A = sector
 206+ 8918 F5           	push af
 207+ 8919 ~            		/*
 208+ 8919 ~            		ld c, HEAD_CNT
 209+ 8919 ~            		call Div				;L = track, A = head (0 or 1)
 210+ 8919 ~            		*/
 211+ 8919 AF           		xor a
 212+ 891A CB 1C        		rr h
 213+ 891C CB 1D        		rr l
 214+ 891E CB 1F        		rr a
 215+ 8920
 216+ 8920 4D           		ld c, l
 217+ 8921 06 00        		ld b, 0
 218+ 8923 B7           		or a
 219+ 8924 28 02        		jr z, Track0
 220+ 8926 06 10        		ld b, SPT
 221+ 8928              Track0:
 222+ 8928 F1           	pop af
 223+ 8929 B7           	or a
 224+ 892A 28 02        	jr z, FirstAU
 225+ 892C 3E 08        	ld a, SPAL
 226+ 892E              FirstAU:
 227+ 892E 80           	add a, b
 228+ 892F 47           	ld  b, a
 229+ 8930 C9           	ret
 230+ 8931
 231+ 8931              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232+ 8931
 233+ 8931              ;Checks the allocation units number used in extension
 234+ 8931              ;IN:	IX = extension addr
 235+ 8931              ;OUT:	B = no. of allocation units used
 236+ 8931              ;		C = no. of records used in ext.
 237+ 8931              ;		HL = first alloc. unit no.
 238+ 8931              ;		DE = last alloc. unit no.
 239+ 8931              CheckExtAlloc:
 240+ 8931 DD E5        	push ix
 241+ 8933 01 0F 00     		ld bc, EXT_RC
 242+ 8936 DD 09        		add ix, bc
 243+ 8938 DD 4E 00     		ld c, (ix)			;save rec. no.
 244+ 893B DD 23        		inc ix
 245+ 893D DD 6E 00     		ld l, (ix)
 246+ 8940 DD 66 01     		ld h, (ix + 1)
 247+ 8943 06 08        		ld b, EXT_AU_CNT
 248+ 8945              CheckAU:
 249+ 8945 DD 7E 00     		ld a, (ix)
 250+ 8948 DD B6 01     		or (ix + 1)
 251+ 894B 28 0C        		jr z, CheckAUEnd
 252+ 894D DD 5E 00     		ld e, (ix)
 253+ 8950 DD 56 01     		ld d, (ix + 1)
 254+ 8953 DD 23        		inc ix
 255+ 8955 DD 23        		inc ix
 256+ 8957 10 EC        		djnz CheckAU
 257+ 8959              CheckAUEnd:
 258+ 8959 3E 08        		ld a, EXT_AU_CNT
 259+ 895B 90           		sub b
 260+ 895C 47           		ld b, a
 261+ 895D DD E1        	pop ix
 262+ 895F C9           	ret
 263+ 8960
 264+ 8960              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265+ 8960
 266+ 8960              ;Input: TrackBuffer
 267+ 8960              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268+ 8960              ReadUsedBlocksList:
 269+ 8960 DD 21 AF A5  	ld		ix, TrackBuf			;source buffer
 270+ 8964 21 C5 9F     	ld		hl, UsedBlockListCnt 	;destination buffer
 271+ 8967 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272+ 896A 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 273+ 896D 73           	ld		(hl), e
 274+ 896E 23           	inc		hl
 275+ 896F 72           	ld		(hl), d
 276+ 8970 23           	inc		hl
 277+ 8971
 278+ 8971              	;Add blocks 0 and 1 for directory
 279+ 8971 11 00 00     	ld		de, 0
 280+ 8974 73           	ld		(hl), e
 281+ 8975 23           	inc		hl
 282+ 8976 72           	ld		(hl), d
 283+ 8977 23           	inc		hl
 284+ 8978
 285+ 8978 13           	inc		de
 286+ 8979 73           	ld		(hl), e
 287+ 897A 23           	inc		hl
 288+ 897B 72           	ld		(hl), d
 289+ 897C 23           	inc		hl
 290+ 897D
 291+ 897D              ReadUsedBlocksLoop:
 292+ 897D AF           	xor		a
 293+ 897E DD BE 00     	cp		(ix)
 294+ 8981 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295+ 8983
 296+ 8983 DD E5        	push	ix
 297+ 8985 C5           	push	bc
 298+ 8986 06 08        		ld		b, EXT_AU_CNT
 299+ 8988 11 10 00     		ld		de, EXT_AU0
 300+ 898B DD 19        		add		ix, de
 301+ 898D
 302+ 898D              ReadUsedBlocksLoop2:
 303+ 898D DD 5E 00     		ld		e, (ix)
 304+ 8990 DD 56 01     		ld		d, (ix+1)
 305+ 8993 7B           		ld		a, e
 306+ 8994 B2           		or		d
 307+ 8995 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308+ 8997
 309+ 8997 73           		ld		(hl), e
 310+ 8998 23           		inc		hl
 311+ 8999 72           		ld		(hl), d
 312+ 899A 23           		inc		hl
 313+ 899B
 314+ 899B DD 23        		inc		ix
 315+ 899D DD 23        		inc		ix
 316+ 899F
 317+ 899F ED 5B C5 9F  		ld		de, (UsedBlockListCnt)
 318+ 89A3 13           		inc		de
 319+ 89A4 ED 53 C5 9F  		ld		(UsedBlockListCnt), de
 320+ 89A8
 321+ 89A8 10 E3        		djnz	ReadUsedBlocksLoop2
 322+ 89AA
 323+ 89AA
 324+ 89AA              ReadUsedBlocksSkip:
 325+ 89AA C1           	pop		bc
 326+ 89AB DD E1        	pop		ix
 327+ 89AD              ReadUsedBlocksSkip2:
 328+ 89AD 11 20 00     	ld		de, EXT_SZ
 329+ 89B0 DD 19        	add		ix, de
 330+ 89B2
 331+ 89B2 0B           	dec		bc
 332+ 89B3 78           	ld		a, b
 333+ 89B4 B1           	or		c
 334+ 89B5 20 C6        	jr		nz, ReadUsedBlocksLoop
 335+ 89B7
 336+ 89B7 C9           	ret
 337+ 89B8
 338+ 89B8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339+ 89B8              ;Reads 8 sectors for an AU
 340+ 89B8              ;HL = block number, DE = destination buffer
 341+ 89B8              ReadFSBlock:
 342+ 89B8 D5           	push	de
 343+ 89B9 CD 13 89     		call	AU2TS		;B=sector, C=track
 344+ 89BC E1           	pop		hl				;HL=dest
 345+ 89BD
 346+ 89BD 50           	ld		d, b
 347+ 89BE 59           	ld		e, c
 348+ 89BF 06 08        	ld		b, SPAL
 349+ 89C1
 350+ 89C1              ReadFSBlockLoop:
 351+ 89C1 CD 70 8B     	call	ReadDiskSectors
 352+ 89C4 C9           	ret
 353+ 89C5
 354+ 89C5
 355+ 89C5              ;Write 8 sectors for an AU
 356+ 89C5              ;HL = block number, DE = source buffer
 357+ 89C5              WriteFSBlock:
 358+ 89C5 D5           	push	de
 359+ 89C6 CD 13 89     		call	AU2TS		;B=sector, C=track
 360+ 89C9 E1           	pop		hl				;HL=dest
 361+ 89CA
 362+ 89CA 50           	ld		d, b
 363+ 89CB 59           	ld		e, c
 364+ 89CC 06 08        	ld		b, SPAL
 365+ 89CE
 366+ 89CE              WriteFSBlockLoop:
 367+ 89CE CD 83 8B     	call	WriteDiskSectors
 368+ 89D1 C9           	ret
 369+ 89D2
 370+ 89D2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371+ 89D2              ;Copies the allocated blocks from one disk to another, dual drive.
 372+ 89D2              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373+ 89D2              CopyDisk:
 374+ 89D2              	;Get list of used blocks in current disk, max 632 bytes
 375+ 89D2 CD 60 89     	call	ReadUsedBlocksList
 376+ 89D5 DD 21 C7 9F  	ld		ix, UsedBlockListBlk
 377+ 89D9
 378+ 89D9              CopyDiskLoop:
 379+ 89D9 2A C5 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380+ 89DC 11 91 96     	ld		de, MsgBlocksLeft
 381+ 89DF CD 6D 88     	call	Byte2Txt
 382+ 89E2 21 91 96     	ld		hl, MsgBlocksLeft
 383+ 89E5 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 384+ 89E8 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 385+ 89EA CD B4 8E     	call	PrintStrClr
 386+ 89ED
 387+ 89ED              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388+ 89ED 21 0B 00     	ld		hl, MAX_AU_RAM
 389+ 89F0 ED 4B C5 9F  	ld		bc, (UsedBlockListCnt)
 390+ 89F4 B7           	or		a
 391+ 89F5 ED 42        	sbc		hl, bc
 392+ 89F7 30 03        	jr		nc, CopyDiskLoopRead
 393+ 89F9 01 0B 00     	ld		bc, MAX_AU_RAM
 394+ 89FC
 395+ 89FC              CopyDiskLoopRead:
 396+ 89FC 41           	ld		b, c
 397+ 89FD 11 AF A5     	ld		de, CopyDiskBuf
 398+ 8A00              	;save initial counter and initial block number array position
 399+ 8A00 C5           	push	bc
 400+ 8A01 DD E5        	push	ix
 401+ 8A03
 402+ 8A03              CopyDiskLoopReadLoop:
 403+ 8A03 DD 6E 00     		ld		l, (ix)
 404+ 8A06 DD 66 01     		ld		h, (ix+1)
 405+ 8A09 DD 23        		inc		ix
 406+ 8A0B DD 23        		inc		ix
 407+ 8A0D
 408+ 8A0D D5           		push	de
 409+ 8A0E C5           		push	bc
 410+ 8A0F CD B8 89     			call	ReadFSBlock			;Stop on error or continue?
 411+ 8A12 C1           		pop		bc
 412+ 8A13 D1           		pop		de
 413+ 8A14
 414+ 8A14              		;+2048
 415+ 8A14 7A           		ld		a, d
 416+ 8A15 C6 08        		add		8
 417+ 8A17 57           		ld		d, a
 418+ 8A18
 419+ 8A18 10 E9        		djnz	CopyDiskLoopReadLoop
 420+ 8A1A
 421+ 8A1A              		;alternate drive
 422+ 8A1A 3A 72 8C     		ld		a, (RWTSDrive)
 423+ 8A1D EE 03        		xor		%11
 424+ 8A1F 32 72 8C     		ld		(RWTSDrive), a
 425+ 8A22
 426+ 8A22              	;restore initial counter and initial block number array position
 427+ 8A22 DD E1        	pop		ix
 428+ 8A24 C1           	pop		bc
 429+ 8A25 11 AF A5     	ld		de, CopyDiskBuf
 430+ 8A28 C5           	push	bc
 431+ 8A29
 432+ 8A29              CopyDiskLoopWriteLoop:
 433+ 8A29 DD 6E 00     		ld		l, (ix)
 434+ 8A2C DD 66 01     		ld		h, (ix+1)
 435+ 8A2F DD 23        		inc		ix
 436+ 8A31 DD 23        		inc		ix
 437+ 8A33
 438+ 8A33 D5           		push	de
 439+ 8A34 C5           		push	bc
 440+ 8A35 CD C5 89     			call	WriteFSBlock		;Stop on error or continue?
 441+ 8A38 C1           		pop		bc
 442+ 8A39 D1           		pop		de
 443+ 8A3A
 444+ 8A3A              		;+2048
 445+ 8A3A 7A           		ld		a, d
 446+ 8A3B C6 08        		add		8
 447+ 8A3D 57           		ld		d, a
 448+ 8A3E
 449+ 8A3E 10 E9        		djnz	CopyDiskLoopWriteLoop
 450+ 8A40
 451+ 8A40              		;alternate drive again
 452+ 8A40 3A 72 8C     		ld		a, (RWTSDrive)
 453+ 8A43 EE 03        		xor		%11
 454+ 8A45 32 72 8C     		ld		(RWTSDrive), a
 455+ 8A48
 456+ 8A48 C1           	pop		bc
 457+ 8A49 48           	ld		c, b
 458+ 8A4A 06 00        	ld		b, 0
 459+ 8A4C
 460+ 8A4C              	;Decrease number of blocks read by now.
 461+ 8A4C 2A C5 9F     	ld		hl, (UsedBlockListCnt)
 462+ 8A4F B7           	or		a
 463+ 8A50 ED 42        	sbc		hl, bc
 464+ 8A52 22 C5 9F     	ld		(UsedBlockListCnt), hl
 465+ 8A55
 466+ 8A55 7D           	ld		a, l
 467+ 8A56 B4           	or		h
 468+ 8A57 C2 D9 89     	jp		nz, CopyDiskLoop
 469+ 8A5A
 470+ 8A5A C9           	ret
 471+ 8A5B
 472+ 8A5B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473+ 8A5B              ;Copies the current disk blocks to COM port.
 474+ 8A5B              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475+ 8A5B              CopyDiskToCOM:
 476+ 8A5B              	;Get list of used blocks in current disk, max 632 bytes
 477+ 8A5B CD 60 89     	call	ReadUsedBlocksList
 478+ 8A5E
 479+ 8A5E              	;Send block count and block indexes
 480+ 8A5E 2A C5 9F     	ld		hl, (UsedBlockListCnt)
 481+ 8A61 29           	add		hl, hl
 482+ 8A62 23           	inc		hl
 483+ 8A63 23           	inc		hl
 484+ 8A64 44           	ld		b, h
 485+ 8A65 4D           	ld		c, l
 486+ 8A66 21 C5 9F     	ld		hl, UsedBlockListCnt
 487+ 8A69 CD DC 93     	call	SERTB
 488+ 8A6C
 489+ 8A6C DD 21 C7 9F  	ld		ix, UsedBlockListBlk
 490+ 8A70
 491+ 8A70              CopyDiskToCOMLoop:
 492+ 8A70              	;Print block count left
 493+ 8A70 2A C5 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494+ 8A73 11 91 96     	ld		de, MsgBlocksLeft
 495+ 8A76 CD 6D 88     	call	Byte2Txt
 496+ 8A79 21 91 96     	ld		hl, MsgBlocksLeft
 497+ 8A7C 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 498+ 8A7F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 499+ 8A81 CD B4 8E     	call	PrintStrClr
 500+ 8A84
 501+ 8A84              	;Read block into buffer
 502+ 8A84 DD 6E 00     	ld		l, (ix)
 503+ 8A87 DD 66 01     	ld		h, (ix+1)
 504+ 8A8A 11 AF A5     	ld		de, CopyDiskBuf
 505+ 8A8D DD E5        	push	ix
 506+ 8A8F CD B8 89     		call	ReadFSBlock
 507+ 8A92 DD E1        	pop		ix
 508+ 8A94 DD 23        	inc		ix
 509+ 8A96 DD 23        	inc		ix
 510+ 8A98
 511+ 8A98              	;Send block buffer
 512+ 8A98 21 AF A5     	ld		hl, CopyDiskBuf
 513+ 8A9B 01 00 08     	ld		bc, AU_SZ
 514+ 8A9E CD DC 93     	call	SERTB
 515+ 8AA1
 516+ 8AA1 ED 4B C5 9F  	ld		bc, (UsedBlockListCnt)
 517+ 8AA5 0B           	dec		bc
 518+ 8AA6 ED 43 C5 9F  	ld		(UsedBlockListCnt), bc
 519+ 8AAA
 520+ 8AAA DD E5        	push	ix
 521+ 8AAC CD 53 8E     		call	KbdHit
 522+ 8AAF DD E1        	pop		ix
 523+ 8AB1 D8           	ret		c
 524+ 8AB2
 525+ 8AB2 78           	ld		a, b
 526+ 8AB3 B1           	or		c
 527+ 8AB4 20 BA        	jr		nz, CopyDiskToCOMLoop
 528+ 8AB6
 529+ 8AB6 C9           	ret
 530+ 8AB7
 531+ 8AB7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532+ 8AB7              CopyDiskFromCOM:
 533+ 8AB7              	;Receive block count.
 534+ 8AB7 21 C5 9F     	ld		hl, UsedBlockListCnt
 535+ 8ABA 01 02 00     	ld		bc, 2
 536+ 8ABD 1E 00        	ld		e, 0
 537+ 8ABF CD A9 93     	call	SERRB
 538+ 8AC2
 539+ 8AC2              	;Receive block indexes.
 540+ 8AC2 2A C5 9F     	ld		hl, (UsedBlockListCnt)
 541+ 8AC5 29           	add		hl, hl
 542+ 8AC6 44           	ld		b, h
 543+ 8AC7 4D           	ld		c, l
 544+ 8AC8 21 C7 9F     	ld		hl, UsedBlockListBlk
 545+ 8ACB 1E 00        	ld		e, 0
 546+ 8ACD CD A9 93     	call	SERRB
 547+ 8AD0
 548+ 8AD0              	;Read each block by index and write to disk
 549+ 8AD0 DD 21 C7 9F  	ld		ix, UsedBlockListBlk
 550+ 8AD4
 551+ 8AD4              CopyDiskFromCOMLoop:
 552+ 8AD4              	;Print block count left
 553+ 8AD4 2A C5 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554+ 8AD7 11 91 96     	ld		de, MsgBlocksLeft
 555+ 8ADA CD 6D 88     	call	Byte2Txt
 556+ 8ADD 21 91 96     	ld		hl, MsgBlocksLeft
 557+ 8AE0 11 00 11     	ld		de, LST_LINE_MSG + 1 << 8
 558+ 8AE3 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 559+ 8AE5 CD B4 8E     	call	PrintStrClr
 560+ 8AE8
 561+ 8AE8              	;Read block buffer
 562+ 8AE8 21 AF A5     	ld		hl, CopyDiskBuf
 563+ 8AEB 01 00 08     	ld		bc, AU_SZ
 564+ 8AEE 1E 00        	ld		e, 0
 565+ 8AF0 CD A9 93     	call	SERRB
 566+ 8AF3
 567+ 8AF3              	;Write block to disk
 568+ 8AF3 DD 6E 00     	ld		l, (ix)
 569+ 8AF6 DD 66 01     	ld		h, (ix+1)
 570+ 8AF9 11 AF A5     	ld		de, CopyDiskBuf
 571+ 8AFC DD E5        	push	ix
 572+ 8AFE CD C5 89     		call	WriteFSBlock			;Stop on error or continue?
 573+ 8B01 DD E1        	pop		ix
 574+ 8B03 DD 23        	inc		ix
 575+ 8B05 DD 23        	inc		ix
 576+ 8B07
 577+ 8B07 ED 4B C5 9F  	ld		bc, (UsedBlockListCnt)
 578+ 8B0B 0B           	dec		bc
 579+ 8B0C ED 43 C5 9F  	ld		(UsedBlockListCnt), bc
 580+ 8B10
 581+ 8B10 DD E5        	push	ix
 582+ 8B12 CD 53 8E     		call	KbdHit
 583+ 8B15 DD E1        	pop		ix
 584+ 8B17 D8           	ret		c
 585+ 8B18
 586+ 8B18 78           	ld		a, b
 587+ 8B19 B1           	or		c
 588+ 8B1A 20 B8        	jr		nz, CopyDiskFromCOMLoop
 589+ 8B1C C9           	ret
 590+ 8B1D
 591+ 8B1D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592+ 8B1D
 593+ 8B1D              ;Compare string at HL with the one at DE, max length B
 594+ 8B1D              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595+ 8B1D              ;OUT: z flag, set = match, reset = mismatch
 596+ 8B1D              StrCmp:
 597+ 8B1D E5           	push hl
 598+ 8B1E D5           	push de
 599+ 8B1F              Compare:
 600+ 8B1F 1A           		ld a, (de)
 601+ 8B20 BE           		cp (hl)
 602+ 8B21 20 04        		jr nz, MisMatch
 603+ 8B23 23           		inc hl
 604+ 8B24 13           		inc de
 605+ 8B25 10 F8        		djnz Compare
 606+ 8B27              MisMatch:
 607+ 8B27 D1           	pop de
 608+ 8B28 E1           	pop hl
 609+ 8B29 C9           	ret
 610+ 8B2A
 611+ 8B2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612+ 8B2A
 613+ 8B2A              ;Read a file into a buffer, sector by sector.
 614+ 8B2A              ;It's relocatable, to moved and be used when loading a CODE block.
 615+ 8B2A              ;It's not using BDOS, but using similar calls provided by IF1.
 616+ 8B2A              ;In: HL = Name address, DE = buffer
 617+ 8B2A              IF1FileLoad:
 618+ 8B2A D5           	push	de
 619+ 8B2B 22 DC 5C     		ld (FSTR1), hl
 620+ 8B2E 26 00        		ld h, 0
 621+ 8B30 3A 72 8C     		ld a, (RWTSDrive)
 622+ 8B33 3C           		inc  a			;CP/M drive number to BASIC drive number
 623+ 8B34 6F           		ld	l, a
 624+ 8B35 22 D6 5C     		ld (DSTR1), hl
 625+ 8B38 2E 0B        		ld l,NAMELEN
 626+ 8B3A 22 DA 5C     		ld (NSTR1), hl
 627+ 8B3D CF           		rst 08
 628+ 8B3E 33           		DEFB 51			;open disk channel
 629+ 8B3F
 630+ 8B3F CF           		rst		8
 631+ 8B40 35           		defb	53		;read sector
 632+ 8B41 D1           	pop		de
 633+ 8B42 30 27        	jr		nc, FileFree
 634+ 8B44
 635+ 8B44 DD 7E 32     	ld		a, (ix + CH_DATA)
 636+ 8B47 FE 04        	cp		TEXT_TYPE
 637+ 8B49 30 12        	jr		nc, FileLoadNoHeader
 638+ 8B4B
 639+ 8B4B              FileLoadHeader:
 640+ 8B4B DD E5        	push	ix
 641+ 8B4D E1           	pop		hl
 642+ 8B4E 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 643+ 8B51 09           	add		hl, bc
 644+ 8B52 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 645+ 8B55 ED B0        	ldir
 646+ 8B57
 647+ 8B57              FileReadLoop:
 648+ 8B57 D5           	push	de
 649+ 8B58 CF           		rst		8
 650+ 8B59 35           		defb	53		;read sector
 651+ 8B5A D1           	pop		de
 652+ 8B5B 30 0E        	jr		nc, FileFree
 653+ 8B5D
 654+ 8B5D              FileLoadNoHeader:
 655+ 8B5D DD E5        	push	ix
 656+ 8B5F E1           	pop		hl
 657+ 8B60 01 32 00     	ld		bc, CH_DATA
 658+ 8B63 09           	add		hl, bc
 659+ 8B64 01 00 01     	ld		bc, SECT_SZ
 660+ 8B67 ED B0        	ldir
 661+ 8B69 18 EC        	jr		FileReadLoop
 662+ 8B6B              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663+ 8B6B              IF1FileLoadEnd:
 664+ 8B6B
 665+ 8B6B              FileFree:
 666+ 8B6B D5           	push	de
 667+ 8B6C CF           	rst		8
 668+ 8B6D 38           	defb	56			;close channel (52) or detroy channel (56)
 669+ 8B6E D1           	pop		de
 670+ 8B6F C9           	ret
 671+ 8B70
 672+ 8B70
 673+ 8B70              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674+ 8B70              ;HL = destination buffer, B = count of sectors, DE = track/sector
 675+ 8B70              ;Out: A = error code, 0=OK
 676+ 8B70              ReadDiskSectors:
 677+ 8B70 C5           	push bc
 678+ 8B71 E5           		push hl
 679+ 8B72 D5           			push de
 680+ 8B73 CD EC 88     				call ReadOneDiskSector
 681+ 8B76 D1           			pop de
 682+ 8B77 E1           		pop hl
 683+ 8B78
 684+ 8B78 14           		inc d
 685+ 8B79 24           		inc h
 686+ 8B7A C1           	pop bc
 687+ 8B7B
 688+ 8B7B 3A 7D 8C     	ld	a, (RWTSRes)
 689+ 8B7E B7           	or	a
 690+ 8B7F C0           	ret nz
 691+ 8B80
 692+ 8B80 10 EE        	djnz ReadDiskSectors
 693+ 8B82 C9           	ret
 694+ 8B83
 695+ 8B83              ;HL = source buffer, B = count of sectors, DE = track/sector
 696+ 8B83              ;Out: A = error code, 0=OK
 697+ 8B83              WriteDiskSectors:
 698+ 8B83 C5           	push bc
 699+ 8B84 E5           		push hl
 700+ 8B85 D5           			push de
 701+ 8B86 CD F7 88     				call WriteOneDiskSector
 702+ 8B89 D1           			pop de
 703+ 8B8A E1           		pop hl
 704+ 8B8B
 705+ 8B8B 14           		inc d
 706+ 8B8C 24           		inc h
 707+ 8B8D C1           	pop bc
 708+ 8B8E
 709+ 8B8E 3A 7D 8C     	ld	a, (RWTSRes)
 710+ 8B91 B7           	or	a
 711+ 8B92 C0           	ret nz
 712+ 8B93
 713+ 8B93 10 EE        	djnz WriteDiskSectors
 714+ 8B95 C9           	ret
 715+ 8B96
 716+ 8B96
 717+ 8B96              ;Reads disk catalog
 718+ 8B96              ReadCatalogTrack:
 719+ 8B96 21 AF A5     	ld hl, TrackBuf
 720+ 8B99 11 00 00     	ld de, 0
 721+ 8B9C 06 10        	ld b, SPT
 722+ 8B9E
 723+ 8B9E CD 70 8B     	call ReadDiskSectors
 724+ 8BA1 B7           	or   a
 725+ 8BA2 C0           	ret  nz
 726+ 8BA3
 727+ 8BA3              	;Sync with BDOS, to avoid disk R/O error on disk change
 728+ 8BA3 F5           	push  af
 729+ 8BA4 3A 72 8C     		ld  a, (RWTSDrive)
 730+ 8BA7 CD 87 8C     		call BDOSSelectDisk
 731+ 8BAA CD 84 8C     		call BDOSInit
 732+ 8BAD F1           	pop   af
 733+ 8BAE C9           	ret
 734+ 8BAF
 735+ 8BAF
 736+ 8BAF
 737+ 8BAF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738+ 8BAF
 739+ 8BAF              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740+ 8BAF              FindCache:
 741+ 8BAF 06 0B        	ld		b, NAMELEN
 742+ 8BB1 CD 1D 8B     	call	StrCmp			;find the file to wich this extension belongs
 743+ 8BB4 C8           	ret		z
 744+ 8BB5
 745+ 8BB5 0D           	dec		c
 746+ 8BB6 20 02        	jr		nz, CacheNotFinished
 747+ 8BB8 B1           	or		c
 748+ 8BB9 C9           	ret
 749+ 8BBA
 750+ 8BBA              CacheNotFinished:
 751+ 8BBA 01 19 00     	ld		bc, CACHE_SZ
 752+ 8BBD 09           	add		hl, bc			;to the next cache line
 753+ 8BBE 18 EF        	jr		FindCache
 754+ 8BC0
 755+ 8BC0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756+ 8BC0
 757+ 8BC0              	;ld		ix, (SelFileCache)
 758+ 8BC0              ReadFileHeader:
 759+ 8BC0 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 760+ 8BC3 B7           	or		a
 761+ 8BC4 C0           	ret		nz				;return if already read
 762+ 8BC5
 763+ 8BC5 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 764+ 8BC8 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 765+ 8BCB 7C           	ld		a, h
 766+ 8BCC B5           	or		l
 767+ 8BCD 28 46        	jr		z, ReadHeaderEnd
 768+ 8BCF
 769+ 8BCF CD 13 89     	call	AU2TS
 770+ 8BD2 50           	ld		d, b
 771+ 8BD3 59           	ld		e, c
 772+ 8BD4 21 AF A5     	ld		hl, DataBuf
 773+ 8BD7 DD E5        	push	ix
 774+ 8BD9 DD E5        	push	ix
 775+ 8BDB CD EC 88     		call	ReadOneDiskSector
 776+ 8BDE E1           	pop		hl
 777+ 8BDF DD E1        	pop		ix
 778+ 8BE1
 779+ 8BE1 E5           	push	hl
 780+ 8BE2 21 AF A5     		ld		hl, DataBuf
 781+ 8BE5 CD 19 8C     		call	IsFileHeaderValid
 782+ 8BE8 E1           	pop		hl
 783+ 8BE9 B7           	or		a
 784+ 8BEA 28 14        	jr		z, ReadFileHeaderIsTextFile
 785+ 8BEC
 786+ 8BEC 01 10 00     	ld		bc, CACHE_HDR
 787+ 8BEF 09           	add		hl, bc
 788+ 8BF0 EB           	ex		hl, de
 789+ 8BF1 21 AF A5     	ld		hl, DataBuf
 790+ 8BF4 01 09 00     	ld		bc, HDR_SZ
 791+ 8BF7 ED B0        	ldir
 792+ 8BF9
 793+ 8BF9              	;For text files, read file size as reported by BDOS, since we don't have a header.
 794+ 8BF9 3E 03        	ld		a, BYTE_TYPE
 795+ 8BFB DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 796+ 8BFE 30 15        	jr		nc, ReadHeaderEnd
 797+ 8C00
 798+ 8C00              ReadFileHeaderIsTextFile:
 799+ 8C00 DD E5        	push	ix
 800+ 8C02 DD E5        	push	ix
 801+ 8C04 E1           	pop		hl
 802+ 8C05 CD D2 8C     		call	GetFileSize
 803+ 8C08 DD E1        	pop		ix
 804+ 8C0A DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 805+ 8C0D DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806+ 8C10 3E 04        	ld		a, TEXT_TYPE
 807+ 8C12 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808+ 8C15
 809+ 8C15              ReadHeaderEnd:
 810+ 8C15 DD 34 0F     	inc		(ix + CACHE_FLAG)
 811+ 8C18 C9           	ret
 812+ 8C19
 813+ 8C19              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814+ 8C19              ;Checks if the file header is valid. For now it checks to not have all 0s.
 815+ 8C19              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816+ 8C19              ;In: HL = header
 817+ 8C19              ;Out: A > 0 if valid
 818+ 8C19              IsFileHeaderValid:
 819+ 8C19              	IFUSED
 820+ 8C19 AF           	xor		a
 821+ 8C1A 06 09        	ld		b, HDR_SZ
 822+ 8C1C              IsFileHeaderValidLoop:
 823+ 8C1C B6           	or		(hl)
 824+ 8C1D 23           	inc		hl
 825+ 8C1E 10 FC        	djnz	IsFileHeaderValidLoop
 826+ 8C20
 827+ 8C20 C9           	ret
 828+ 8C21              	ENDIF
 829+ 8C21
 830+ 8C21              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831+ 8C21
 832+ 8C21              ;IN: HL = address from IF1 to call
 833+ 8C21              IF1Call:
 834+ 8C21 22 ED 5C     	LD   (HD11), HL
 835+ 8C24 CF           	RST  8
 836+ 8C25 32           	DEFB 50
 837+ 8C26 C9           	RET
 838+ 8C27
 839+ 8C27              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840+ 8C27
 841+ 8C27              ;Load a program from disk
 842+ 8C27              ;IN: HL = file name addr
 843+ 8C27              LoadProgram:
 844+ 8C27 22 DC 5C     	LD   (FSTR1), HL
 845+ 8C2A 26 00        	LD   H, 0
 846+ 8C2C 2E 0B        	LD   L, NAMELEN
 847+ 8C2E 22 DA 5C     	LD   (NSTR1), HL
 848+ 8C31 3A 72 8C     	LD	 A, (RWTSDrive)
 849+ 8C34 3C           	INC  A					;Adapt for BASIC drive number
 850+ 8C35 6F           	LD   L, A
 851+ 8C36 22 D6 5C     	LD   (DSTR1), HL
 852+ 8C39 21 41 0A     	LD   HL, LOAD_ADDR
 853+ 8C3C CD 21 8C     	CALL IF1Call
 854+ 8C3F C9           	RET
 855+ 8C40
 856+ 8C40              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857+ 8C40
 858+ 8C40              SetFastKeys:
 859+ 8C40 21 09 5C     	ld		hl, REPDEL
 860+ 8C43 11 0F 01     	ld		de, (1 << 8) | 15
 861+ 8C46 73 23 72 2B  	ld		(hl), de
 862+ 8C4A
 863+ 8C4A C9           	ret
 864+ 8C4B
 865+ 8C4B
 866+ 8C4B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867+ 8C4B              ;Reads the error message string from IF1 ROM.
 868+ 8C4B              GetErrMsg:
 869+ 8C4B 3C           	inc		a
 870+ 8C4C 08           	ex		af, af'
 871+ 8C4D
 872+ 8C4D 21 53 8C     	ld		hl, IF1Paged			;page-in IF1
 873+ 8C50 C3 21 8C     	jp		IF1Call
 874+ 8C53
 875+ 8C53              IF1Paged:
 876+ 8C53 21 60 02     	ld		hl, ERRMSG
 877+ 8C56 08           	ex		af, af'
 878+ 8C57 B7           	or		a
 879+ 8C58 28 0B        	jr		z, SaveMsg
 880+ 8C5A
 881+ 8C5A 06 00        	ld		b, 0
 882+ 8C5C              SearchMsgEnd:
 883+ 8C5C CB 7E        	bit		7, (hl)
 884+ 8C5E 23           	inc		hl
 885+ 8C5F 28 FB        	jr		z, SearchMsgEnd
 886+ 8C61
 887+ 8C61 04           	inc		b
 888+ 8C62 B8           	cp		b
 889+ 8C63 20 F7        	jr		nz, SearchMsgEnd
 890+ 8C65
 891+ 8C65              SaveMsg:
 892+ 8C65 11 AF A5     	ld		de, DataBuf
 893+ 8C68              CopyMsg:
 894+ 8C68 7E           	ld		a, (hl)
 895+ 8C69 CB 7F        	bit		7, a
 896+ 8C6B 12           	ld		(de), a
 897+ 8C6C 23           	inc		hl
 898+ 8C6D 13           	inc		de
 899+ 8C6E 28 F8        	jr		z, CopyMsg
 900+ 8C70
 901+ 8C70 C9           	ret
 902+ 8C71
 903+ 8C71              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904+ 8C71
 905+ 8C71              ;RWTS routine I/O block
 906+ 8C71              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 907+ 8C71              RWTSParams:
 908+ 8C71 01           RWTSBlockType	DEFB	1							;?
 909+ 8C72 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 910+ 8C73 00           RWTSVolNo		DEFB	0							;?
 911+ 8C74 00           RWTSTrack		DEFB	0
 912+ 8C75 00           RWTSSector		DEFB	0
 913+ 8C76 00 00        RWTSDMA			DEFW	0
 914+ 8C78 32 29        RWTSExtBuf		DEFW	$2932
 915+ 8C7A 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 916+ 8C7C 01           RWTSCmd			DEFB	RWTS_CMD_READ
 917+ 8C7D              ;Results
 918+ 8C7D 00           RWTSRes			DEFB	0
 919+ 8C7E 00           RWTSResVolNo	DEFB	0
 920+ 8C7F 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 920+ 8C83 00
 921+ 8C84
 922+ 8C84              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 923+ 8C84 ~            /*
 924+ 8C84 ~            BasPrmTbl:
 925+ 8C84 ~            PrmDevType		DEFB	$01			;$01
 926+ 8C84 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 927+ 8C84 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 928+ 8C84 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 929+ 8C84 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 930+ 8C84 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 931+ 8C84 ~            */
 932+ 8C84
 933+ 8C84              	endif
# file closed: if1.asm
1324  8C84              	include "bdos.asm"
# file opened: bdos.asm
   1+ 8C84              ;BDOS functions - similar to CP/M
   2+ 8C84
   3+ 8C84              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 8C84              ;0 OK,
   5+ 8C84              ;1 directory full,
   6+ 8C84              ;2 disc full,
   7+ 8C84              ;9 invalid FCB,
   8+ 8C84              ;10(CP/M) media changed;
   9+ 8C84              ;0FFh hardware error.
  10+ 8C84
  11+ 8C84              	IFNDEF	_BDOS_
  12+ 8C84              	DEFINE	_BDOS_
  13+ 8C84
  14+ 8C84              	include "if1.asm"
# file opened: if1.asm
   1++8C84              ;HC IF1 routines and constants
   2++8C84
   3++8C84              ;IF1 routines error codes, also returned by BASIC commands
   4++8C84              ;12 = Writing to a 'read' file
   5++8C84              ;13 = Reading a 'write' file
   6++8C84              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++8C84              ;15 = Disk full (disk or catalog full)
   8++8C84              ;16 = Disk error (hardware error)
   9++8C84              ;17 = File not found
  10++8C84              ;23 = Disk R/O (disk change detected, software R/O)
  11++8C84              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++8C84
  13++8C84              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++8C84              ;00h = OK
  15++8C84              ;08h = cannot format disk
  16++8C84              ;10h = disk protected (read-only?)
  17++8C84              ;20h = volume error
  18++8C84              ;40h = drive error
  19++8C84              ;80h = reading error
  20++8C84              ;Codes I encountered:
  21++8C84              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++8C84
  23++8C84
  24++8C84              	ifndef	_DISK_
  25++8C84 ~            	define	_DISK_
  26++8C84 ~
  27++8C84 ~            	include	"math.asm"
  28++8C84 ~
  29++8C84 ~            DRIVE_CUR_BAS	EQU 0
  30++8C84 ~            DRIVE_A_BAS		EQU	1
  31++8C84 ~            DRIVE_B_BAS		EQU	2
  32++8C84 ~            DRIVE_A_CPM		EQU	0
  33++8C84 ~            DRIVE_B_CPM		EQU	1
  34++8C84 ~            ;Disk geometry stuff
  35++8C84 ~            SPT				EQU	16			;sectors per track
  36++8C84 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++8C84 ~            TRACK_CNT		EQU	80			;track count
  38++8C84 ~            HEAD_CNT		EQU	2			;disk face count
  39++8C84 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++8C84 ~            EXT_SZ			EQU	32			;directory entry size
  41++8C84 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++8C84 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++8C84 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++8C84 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++8C84 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++8C84 ~            REC_SZ			EQU 128			;cp/m record size
  47++8C84 ~            DEL_MARKER		EQU	$E5
  48++8C84 ~
  49++8C84 ~
  50++8C84 ~            ;Extension structure (directory entry)
  51++8C84 ~            EXT_DEL_FLAG	EQU	0
  52++8C84 ~            EXT_NAME		EQU 1
  53++8C84 ~            EXT_IDX			EQU 12
  54++8C84 ~            EXT_S1			EQU 13
  55++8C84 ~            EXT_S2			EQU 14
  56++8C84 ~            EXT_RC			EQU	15
  57++8C84 ~            EXT_AU0			EQU	16
  58++8C84 ~            EXT_AU1			EQU	18
  59++8C84 ~            EXT_AU2			EQU	20
  60++8C84 ~            EXT_AU3			EQU	22
  61++8C84 ~            EXT_AU4			EQU	24
  62++8C84 ~            EXT_AU5			EQU	26
  63++8C84 ~            EXT_AU6			EQU	28
  64++8C84 ~            EXT_AU7			EQU	30
  65++8C84 ~            EXT_SIZE		EQU 32
  66++8C84 ~
  67++8C84 ~            ;FCB structure
  68++8C84 ~            FCB_DRIVE		EQU 0
  69++8C84 ~            FCB_NAME		EQU EXT_NAME
  70++8C84 ~            FCB_EX_IDX		EQU EXT_IDX
  71++8C84 ~            FCB_S1			EQU EXT_S1
  72++8C84 ~            FCB_S2			EQU EXT_S2
  73++8C84 ~            FCB_RC			EQU	EXT_RC
  74++8C84 ~            FCB_AU			EQU	EXT_AU0
  75++8C84 ~            FCB_CR			EQU	32
  76++8C84 ~            FCB_R0			EQU 33
  77++8C84 ~            FCB_R1			EQU 34
  78++8C84 ~            FCB_R2			EQU 35
  79++8C84 ~            FCB_SIZE		EQU 36
  80++8C84 ~
  81++8C84 ~
  82++8C84 ~
  83++8C84 ~            ;System variables for disk
  84++8C84 ~            DSTR1			EQU	$5CD6		;drive
  85++8C84 ~            FSTR1			EQU	$5CDC		;file name
  86++8C84 ~            NSTR1			EQU	$5CDA		;name length
  87++8C84 ~            HD11			EQU	$5CED		;BDOS argument
  88++8C84 ~            COPIES			EQU	$5CEF		;BDOS function
  89++8C84 ~
  90++8C84 ~            ERRSP			EQU $5C3D
  91++8C84 ~            ERRNR			EQU $5C3A
  92++8C84 ~            ERRMSG			EQU	$0260
  93++8C84 ~
  94++8C84 ~            PROG			EQU $5C53
  95++8C84 ~            VARS			EQU	$5C4B
  96++8C84 ~            STKEND			EQU	$5C65
  97++8C84 ~
  98++8C84 ~            PRN_BUF			EQU	23296
  99++8C84 ~
 100++8C84 ~            STR_MSG_BASIC	EQU	$1539
 101++8C84 ~            STR_MSG_BASIC_LEN EQU 32
 102++8C84 ~            STR_MSG_IF1_2000	EQU $27F0
 103++8C84 ~            STR_MSG_IF1_91		EQU $23F0
 104++8C84 ~            STR_MSG_IF1_LEN EQU 31
 105++8C84 ~
 106++8C84 ~            REPDEL			EQU	23561
 107++8C84 ~            REPPER			EQU	23562
 108++8C84 ~            PIP				EQU	23609
 109++8C84 ~
 110++8C84 ~
 111++8C84 ~            ;RWTS routine commands
 112++8C84 ~            RWTS_CMD_POS	EQU	0			;position head
 113++8C84 ~            RWTS_CMD_READ	EQU	1			;read sector
 114++8C84 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 115++8C84 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 116++8C84 ~
 117++8C84 ~
 118++8C84 ~            ;File name stuff
 119++8C84 ~            NAMELEN			EQU	11			;name length
 120++8C84 ~            RO_POS			EQU	8			;read-only attribute position in name
 121++8C84 ~            SYS_POS			EQU	9			;system attribute position in name
 122++8C84 ~
 123++8C84 ~            ;File types (first byte in header)
 124++8C84 ~            PROG_TYPE		EQU	0			;program
 125++8C84 ~            NUMB_TYPE		EQU	1			;number array
 126++8C84 ~            CHAR_TYPE		EQU	2			;char array
 127++8C84 ~            BYTE_TYPE		EQU	3			;bytes
 128++8C84 ~            TEXT_TYPE		EQU	4			;text, >= 4
 129++8C84 ~
 130++8C84 ~            ;File header offsets
 131++8C84 ~            HDR_TYPE		EQU	0
 132++8C84 ~            HDR_LEN			EQU 1
 133++8C84 ~            HDR_ADDR		EQU 3
 134++8C84 ~            HDR_PLEN		EQU	5
 135++8C84 ~            HDR_LINE		EQU 7
 136++8C84 ~            HDR_SZ			EQU	9
 137++8C84 ~
 138++8C84 ~            ;BASIC disk channel structure
 139++8C84 ~            CH_RW_FLAG		EQU 11
 140++8C84 ~            CH_FCB			EQU	12
 141++8C84 ~            CH_DATA			EQU	50
 142++8C84 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143++8C84 ~
 144++8C84 ~            CACHE_NAME		EQU	0					;11B
 145++8C84 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146++8C84 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147++8C84 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148++8C84 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149++8C84 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150++8C84 ~
 151++8C84 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152++8C84 ~
 153++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154++8C84 ~            IF1Init:
 155++8C84 ~            	rst		08
 156++8C84 ~            	defb	49		;create system variables
 157++8C84 ~            	ret
 158++8C84 ~
 159++8C84 ~            ;ReadWriteTrackSector
 160++8C84 ~            ;A=command: 0, 1, 2, 4
 161++8C84 ~            RWTS:
 162++8C84 ~            	ld (RWTSCmd), a
 163++8C84 ~            	ld hl, RWTSParams
 164++8C84 ~            	ld (HD11), hl
 165++8C84 ~            	rst 08
 166++8C84 ~            	DEFB 58
 167++8C84 ~            	ret
 168++8C84 ~
 169++8C84 ~
 170++8C84 ~            ;D = sector, E = track
 171++8C84 ~            ;HL = dma
 172++8C84 ~            ReadOneDiskSector:
 173++8C84 ~            	ld (RWTSDMA), hl
 174++8C84 ~            	ld (RWTSTrack), de
 175++8C84 ~            	;ld (RWTSDrive), a
 176++8C84 ~            	ld a, RWTS_CMD_READ
 177++8C84 ~            	jr	RWTS
 178++8C84 ~
 179++8C84 ~            ;D = sector, E = track
 180++8C84 ~            ;HL = dma
 181++8C84 ~            WriteOneDiskSector:
 182++8C84 ~            	ld (RWTSDMA), hl
 183++8C84 ~            	ld (RWTSTrack), de
 184++8C84 ~            	;ld (RWTSDrive), a
 185++8C84 ~            	ld a, RWTS_CMD_WRITE
 186++8C84 ~            	jr	RWTS
 187++8C84 ~
 188++8C84 ~            FormatDisk:
 189++8C84 ~            	ld		hl, DataBuf
 190++8C84 ~            	ld		(hl), DEL_MARKER
 191++8C84 ~            	ld 		(RWTSDMA), hl
 192++8C84 ~            	ld 		a, RWTS_CMD_FMT
 193++8C84 ~            	call	RWTS
 194++8C84 ~            	ld		a, (RWTSRes)
 195++8C84 ~            	ret
 196++8C84 ~
 197++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198++8C84 ~
 199++8C84 ~            ;Allocation unit no. to track/sector
 200++8C84 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201++8C84 ~            ;IN:  HL=alloc. unit no.
 202++8C84 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 203++8C84 ~            AU2TS:
 204++8C84 ~            	ld c, SPT/SPAL
 205++8C84 ~            	call Div					;A = sector
 206++8C84 ~            	push af
 207++8C84 ~            		/*
 208++8C84 ~            		ld c, HEAD_CNT
 209++8C84 ~            		call Div				;L = track, A = head (0 or 1)
 210++8C84 ~            		*/
 211++8C84 ~            		xor a
 212++8C84 ~            		rr h
 213++8C84 ~            		rr l
 214++8C84 ~            		rr a
 215++8C84 ~
 216++8C84 ~            		ld c, l
 217++8C84 ~            		ld b, 0
 218++8C84 ~            		or a
 219++8C84 ~            		jr z, Track0
 220++8C84 ~            		ld b, SPT
 221++8C84 ~            Track0:
 222++8C84 ~            	pop af
 223++8C84 ~            	or a
 224++8C84 ~            	jr z, FirstAU
 225++8C84 ~            	ld a, SPAL
 226++8C84 ~            FirstAU:
 227++8C84 ~            	add a, b
 228++8C84 ~            	ld  b, a
 229++8C84 ~            	ret
 230++8C84 ~
 231++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232++8C84 ~
 233++8C84 ~            ;Checks the allocation units number used in extension
 234++8C84 ~            ;IN:	IX = extension addr
 235++8C84 ~            ;OUT:	B = no. of allocation units used
 236++8C84 ~            ;		C = no. of records used in ext.
 237++8C84 ~            ;		HL = first alloc. unit no.
 238++8C84 ~            ;		DE = last alloc. unit no.
 239++8C84 ~            CheckExtAlloc:
 240++8C84 ~            	push ix
 241++8C84 ~            		ld bc, EXT_RC
 242++8C84 ~            		add ix, bc
 243++8C84 ~            		ld c, (ix)			;save rec. no.
 244++8C84 ~            		inc ix
 245++8C84 ~            		ld l, (ix)
 246++8C84 ~            		ld h, (ix + 1)
 247++8C84 ~            		ld b, EXT_AU_CNT
 248++8C84 ~            CheckAU:
 249++8C84 ~            		ld a, (ix)
 250++8C84 ~            		or (ix + 1)
 251++8C84 ~            		jr z, CheckAUEnd
 252++8C84 ~            		ld e, (ix)
 253++8C84 ~            		ld d, (ix + 1)
 254++8C84 ~            		inc ix
 255++8C84 ~            		inc ix
 256++8C84 ~            		djnz CheckAU
 257++8C84 ~            CheckAUEnd:
 258++8C84 ~            		ld a, EXT_AU_CNT
 259++8C84 ~            		sub b
 260++8C84 ~            		ld b, a
 261++8C84 ~            	pop ix
 262++8C84 ~            	ret
 263++8C84 ~
 264++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265++8C84 ~
 266++8C84 ~            ;Input: TrackBuffer
 267++8C84 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268++8C84 ~            ReadUsedBlocksList:
 269++8C84 ~            	ld		ix, TrackBuf			;source buffer
 270++8C84 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 271++8C84 ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272++8C84 ~            	ld		de, 2					;counter of used blocks, start with 2
 273++8C84 ~            	ld		(hl), e
 274++8C84 ~            	inc		hl
 275++8C84 ~            	ld		(hl), d
 276++8C84 ~            	inc		hl
 277++8C84 ~
 278++8C84 ~            	;Add blocks 0 and 1 for directory
 279++8C84 ~            	ld		de, 0
 280++8C84 ~            	ld		(hl), e
 281++8C84 ~            	inc		hl
 282++8C84 ~            	ld		(hl), d
 283++8C84 ~            	inc		hl
 284++8C84 ~
 285++8C84 ~            	inc		de
 286++8C84 ~            	ld		(hl), e
 287++8C84 ~            	inc		hl
 288++8C84 ~            	ld		(hl), d
 289++8C84 ~            	inc		hl
 290++8C84 ~
 291++8C84 ~            ReadUsedBlocksLoop:
 292++8C84 ~            	xor		a
 293++8C84 ~            	cp		(ix)
 294++8C84 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295++8C84 ~
 296++8C84 ~            	push	ix
 297++8C84 ~            	push	bc
 298++8C84 ~            		ld		b, EXT_AU_CNT
 299++8C84 ~            		ld		de, EXT_AU0
 300++8C84 ~            		add		ix, de
 301++8C84 ~
 302++8C84 ~            ReadUsedBlocksLoop2:
 303++8C84 ~            		ld		e, (ix)
 304++8C84 ~            		ld		d, (ix+1)
 305++8C84 ~            		ld		a, e
 306++8C84 ~            		or		d
 307++8C84 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308++8C84 ~
 309++8C84 ~            		ld		(hl), e
 310++8C84 ~            		inc		hl
 311++8C84 ~            		ld		(hl), d
 312++8C84 ~            		inc		hl
 313++8C84 ~
 314++8C84 ~            		inc		ix
 315++8C84 ~            		inc		ix
 316++8C84 ~
 317++8C84 ~            		ld		de, (UsedBlockListCnt)
 318++8C84 ~            		inc		de
 319++8C84 ~            		ld		(UsedBlockListCnt), de
 320++8C84 ~
 321++8C84 ~            		djnz	ReadUsedBlocksLoop2
 322++8C84 ~
 323++8C84 ~
 324++8C84 ~            ReadUsedBlocksSkip:
 325++8C84 ~            	pop		bc
 326++8C84 ~            	pop		ix
 327++8C84 ~            ReadUsedBlocksSkip2:
 328++8C84 ~            	ld		de, EXT_SZ
 329++8C84 ~            	add		ix, de
 330++8C84 ~
 331++8C84 ~            	dec		bc
 332++8C84 ~            	ld		a, b
 333++8C84 ~            	or		c
 334++8C84 ~            	jr		nz, ReadUsedBlocksLoop
 335++8C84 ~
 336++8C84 ~            	ret
 337++8C84 ~
 338++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339++8C84 ~            ;Reads 8 sectors for an AU
 340++8C84 ~            ;HL = block number, DE = destination buffer
 341++8C84 ~            ReadFSBlock:
 342++8C84 ~            	push	de
 343++8C84 ~            		call	AU2TS		;B=sector, C=track
 344++8C84 ~            	pop		hl				;HL=dest
 345++8C84 ~
 346++8C84 ~            	ld		d, b
 347++8C84 ~            	ld		e, c
 348++8C84 ~            	ld		b, SPAL
 349++8C84 ~
 350++8C84 ~            ReadFSBlockLoop:
 351++8C84 ~            	call	ReadDiskSectors
 352++8C84 ~            	ret
 353++8C84 ~
 354++8C84 ~
 355++8C84 ~            ;Write 8 sectors for an AU
 356++8C84 ~            ;HL = block number, DE = source buffer
 357++8C84 ~            WriteFSBlock:
 358++8C84 ~            	push	de
 359++8C84 ~            		call	AU2TS		;B=sector, C=track
 360++8C84 ~            	pop		hl				;HL=dest
 361++8C84 ~
 362++8C84 ~            	ld		d, b
 363++8C84 ~            	ld		e, c
 364++8C84 ~            	ld		b, SPAL
 365++8C84 ~
 366++8C84 ~            WriteFSBlockLoop:
 367++8C84 ~            	call	WriteDiskSectors
 368++8C84 ~            	ret
 369++8C84 ~
 370++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371++8C84 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 372++8C84 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373++8C84 ~            CopyDisk:
 374++8C84 ~            	;Get list of used blocks in current disk, max 632 bytes
 375++8C84 ~            	call	ReadUsedBlocksList
 376++8C84 ~            	ld		ix, UsedBlockListBlk
 377++8C84 ~
 378++8C84 ~            CopyDiskLoop:
 379++8C84 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380++8C84 ~            	ld		de, MsgBlocksLeft
 381++8C84 ~            	call	Byte2Txt
 382++8C84 ~            	ld		hl, MsgBlocksLeft
 383++8C84 ~            	ld		de, LST_LINE_MSG + 1 << 8
 384++8C84 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 385++8C84 ~            	call	PrintStrClr
 386++8C84 ~
 387++8C84 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388++8C84 ~            	ld		hl, MAX_AU_RAM
 389++8C84 ~            	ld		bc, (UsedBlockListCnt)
 390++8C84 ~            	or		a
 391++8C84 ~            	sbc		hl, bc
 392++8C84 ~            	jr		nc, CopyDiskLoopRead
 393++8C84 ~            	ld		bc, MAX_AU_RAM
 394++8C84 ~
 395++8C84 ~            CopyDiskLoopRead:
 396++8C84 ~            	ld		b, c
 397++8C84 ~            	ld		de, CopyDiskBuf
 398++8C84 ~            	;save initial counter and initial block number array position
 399++8C84 ~            	push	bc
 400++8C84 ~            	push	ix
 401++8C84 ~
 402++8C84 ~            CopyDiskLoopReadLoop:
 403++8C84 ~            		ld		l, (ix)
 404++8C84 ~            		ld		h, (ix+1)
 405++8C84 ~            		inc		ix
 406++8C84 ~            		inc		ix
 407++8C84 ~
 408++8C84 ~            		push	de
 409++8C84 ~            		push	bc
 410++8C84 ~            			call	ReadFSBlock			;Stop on error or continue?
 411++8C84 ~            		pop		bc
 412++8C84 ~            		pop		de
 413++8C84 ~
 414++8C84 ~            		;+2048
 415++8C84 ~            		ld		a, d
 416++8C84 ~            		add		8
 417++8C84 ~            		ld		d, a
 418++8C84 ~
 419++8C84 ~            		djnz	CopyDiskLoopReadLoop
 420++8C84 ~
 421++8C84 ~            		;alternate drive
 422++8C84 ~            		ld		a, (RWTSDrive)
 423++8C84 ~            		xor		%11
 424++8C84 ~            		ld		(RWTSDrive), a
 425++8C84 ~
 426++8C84 ~            	;restore initial counter and initial block number array position
 427++8C84 ~            	pop		ix
 428++8C84 ~            	pop		bc
 429++8C84 ~            	ld		de, CopyDiskBuf
 430++8C84 ~            	push	bc
 431++8C84 ~
 432++8C84 ~            CopyDiskLoopWriteLoop:
 433++8C84 ~            		ld		l, (ix)
 434++8C84 ~            		ld		h, (ix+1)
 435++8C84 ~            		inc		ix
 436++8C84 ~            		inc		ix
 437++8C84 ~
 438++8C84 ~            		push	de
 439++8C84 ~            		push	bc
 440++8C84 ~            			call	WriteFSBlock		;Stop on error or continue?
 441++8C84 ~            		pop		bc
 442++8C84 ~            		pop		de
 443++8C84 ~
 444++8C84 ~            		;+2048
 445++8C84 ~            		ld		a, d
 446++8C84 ~            		add		8
 447++8C84 ~            		ld		d, a
 448++8C84 ~
 449++8C84 ~            		djnz	CopyDiskLoopWriteLoop
 450++8C84 ~
 451++8C84 ~            		;alternate drive again
 452++8C84 ~            		ld		a, (RWTSDrive)
 453++8C84 ~            		xor		%11
 454++8C84 ~            		ld		(RWTSDrive), a
 455++8C84 ~
 456++8C84 ~            	pop		bc
 457++8C84 ~            	ld		c, b
 458++8C84 ~            	ld		b, 0
 459++8C84 ~
 460++8C84 ~            	;Decrease number of blocks read by now.
 461++8C84 ~            	ld		hl, (UsedBlockListCnt)
 462++8C84 ~            	or		a
 463++8C84 ~            	sbc		hl, bc
 464++8C84 ~            	ld		(UsedBlockListCnt), hl
 465++8C84 ~
 466++8C84 ~            	ld		a, l
 467++8C84 ~            	or		h
 468++8C84 ~            	jp		nz, CopyDiskLoop
 469++8C84 ~
 470++8C84 ~            	ret
 471++8C84 ~
 472++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473++8C84 ~            ;Copies the current disk blocks to COM port.
 474++8C84 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475++8C84 ~            CopyDiskToCOM:
 476++8C84 ~            	;Get list of used blocks in current disk, max 632 bytes
 477++8C84 ~            	call	ReadUsedBlocksList
 478++8C84 ~
 479++8C84 ~            	;Send block count and block indexes
 480++8C84 ~            	ld		hl, (UsedBlockListCnt)
 481++8C84 ~            	add		hl, hl
 482++8C84 ~            	inc		hl
 483++8C84 ~            	inc		hl
 484++8C84 ~            	ld		b, h
 485++8C84 ~            	ld		c, l
 486++8C84 ~            	ld		hl, UsedBlockListCnt
 487++8C84 ~            	call	SERTB
 488++8C84 ~
 489++8C84 ~            	ld		ix, UsedBlockListBlk
 490++8C84 ~
 491++8C84 ~            CopyDiskToCOMLoop:
 492++8C84 ~            	;Print block count left
 493++8C84 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494++8C84 ~            	ld		de, MsgBlocksLeft
 495++8C84 ~            	call	Byte2Txt
 496++8C84 ~            	ld		hl, MsgBlocksLeft
 497++8C84 ~            	ld		de, LST_LINE_MSG + 1 << 8
 498++8C84 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 499++8C84 ~            	call	PrintStrClr
 500++8C84 ~
 501++8C84 ~            	;Read block into buffer
 502++8C84 ~            	ld		l, (ix)
 503++8C84 ~            	ld		h, (ix+1)
 504++8C84 ~            	ld		de, CopyDiskBuf
 505++8C84 ~            	push	ix
 506++8C84 ~            		call	ReadFSBlock
 507++8C84 ~            	pop		ix
 508++8C84 ~            	inc		ix
 509++8C84 ~            	inc		ix
 510++8C84 ~
 511++8C84 ~            	;Send block buffer
 512++8C84 ~            	ld		hl, CopyDiskBuf
 513++8C84 ~            	ld		bc, AU_SZ
 514++8C84 ~            	call	SERTB
 515++8C84 ~
 516++8C84 ~            	ld		bc, (UsedBlockListCnt)
 517++8C84 ~            	dec		bc
 518++8C84 ~            	ld		(UsedBlockListCnt), bc
 519++8C84 ~
 520++8C84 ~            	push	ix
 521++8C84 ~            		call	KbdHit
 522++8C84 ~            	pop		ix
 523++8C84 ~            	ret		c
 524++8C84 ~
 525++8C84 ~            	ld		a, b
 526++8C84 ~            	or		c
 527++8C84 ~            	jr		nz, CopyDiskToCOMLoop
 528++8C84 ~
 529++8C84 ~            	ret
 530++8C84 ~
 531++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532++8C84 ~            CopyDiskFromCOM:
 533++8C84 ~            	;Receive block count.
 534++8C84 ~            	ld		hl, UsedBlockListCnt
 535++8C84 ~            	ld		bc, 2
 536++8C84 ~            	ld		e, 0
 537++8C84 ~            	call	SERRB
 538++8C84 ~
 539++8C84 ~            	;Receive block indexes.
 540++8C84 ~            	ld		hl, (UsedBlockListCnt)
 541++8C84 ~            	add		hl, hl
 542++8C84 ~            	ld		b, h
 543++8C84 ~            	ld		c, l
 544++8C84 ~            	ld		hl, UsedBlockListBlk
 545++8C84 ~            	ld		e, 0
 546++8C84 ~            	call	SERRB
 547++8C84 ~
 548++8C84 ~            	;Read each block by index and write to disk
 549++8C84 ~            	ld		ix, UsedBlockListBlk
 550++8C84 ~
 551++8C84 ~            CopyDiskFromCOMLoop:
 552++8C84 ~            	;Print block count left
 553++8C84 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554++8C84 ~            	ld		de, MsgBlocksLeft
 555++8C84 ~            	call	Byte2Txt
 556++8C84 ~            	ld		hl, MsgBlocksLeft
 557++8C84 ~            	ld		de, LST_LINE_MSG + 1 << 8
 558++8C84 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 559++8C84 ~            	call	PrintStrClr
 560++8C84 ~
 561++8C84 ~            	;Read block buffer
 562++8C84 ~            	ld		hl, CopyDiskBuf
 563++8C84 ~            	ld		bc, AU_SZ
 564++8C84 ~            	ld		e, 0
 565++8C84 ~            	call	SERRB
 566++8C84 ~
 567++8C84 ~            	;Write block to disk
 568++8C84 ~            	ld		l, (ix)
 569++8C84 ~            	ld		h, (ix+1)
 570++8C84 ~            	ld		de, CopyDiskBuf
 571++8C84 ~            	push	ix
 572++8C84 ~            		call	WriteFSBlock			;Stop on error or continue?
 573++8C84 ~            	pop		ix
 574++8C84 ~            	inc		ix
 575++8C84 ~            	inc		ix
 576++8C84 ~
 577++8C84 ~            	ld		bc, (UsedBlockListCnt)
 578++8C84 ~            	dec		bc
 579++8C84 ~            	ld		(UsedBlockListCnt), bc
 580++8C84 ~
 581++8C84 ~            	push	ix
 582++8C84 ~            		call	KbdHit
 583++8C84 ~            	pop		ix
 584++8C84 ~            	ret		c
 585++8C84 ~
 586++8C84 ~            	ld		a, b
 587++8C84 ~            	or		c
 588++8C84 ~            	jr		nz, CopyDiskFromCOMLoop
 589++8C84 ~            	ret
 590++8C84 ~
 591++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592++8C84 ~
 593++8C84 ~            ;Compare string at HL with the one at DE, max length B
 594++8C84 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595++8C84 ~            ;OUT: z flag, set = match, reset = mismatch
 596++8C84 ~            StrCmp:
 597++8C84 ~            	push hl
 598++8C84 ~            	push de
 599++8C84 ~            Compare:
 600++8C84 ~            		ld a, (de)
 601++8C84 ~            		cp (hl)
 602++8C84 ~            		jr nz, MisMatch
 603++8C84 ~            		inc hl
 604++8C84 ~            		inc de
 605++8C84 ~            		djnz Compare
 606++8C84 ~            MisMatch:
 607++8C84 ~            	pop de
 608++8C84 ~            	pop hl
 609++8C84 ~            	ret
 610++8C84 ~
 611++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612++8C84 ~
 613++8C84 ~            ;Read a file into a buffer, sector by sector.
 614++8C84 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 615++8C84 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 616++8C84 ~            ;In: HL = Name address, DE = buffer
 617++8C84 ~            IF1FileLoad:
 618++8C84 ~            	push	de
 619++8C84 ~            		ld (FSTR1), hl
 620++8C84 ~            		ld h, 0
 621++8C84 ~            		ld a, (RWTSDrive)
 622++8C84 ~            		inc  a			;CP/M drive number to BASIC drive number
 623++8C84 ~            		ld	l, a
 624++8C84 ~            		ld (DSTR1), hl
 625++8C84 ~            		ld l,NAMELEN
 626++8C84 ~            		ld (NSTR1), hl
 627++8C84 ~            		rst 08
 628++8C84 ~            		DEFB 51			;open disk channel
 629++8C84 ~
 630++8C84 ~            		rst		8
 631++8C84 ~            		defb	53		;read sector
 632++8C84 ~            	pop		de
 633++8C84 ~            	jr		nc, FileFree
 634++8C84 ~
 635++8C84 ~            	ld		a, (ix + CH_DATA)
 636++8C84 ~            	cp		TEXT_TYPE
 637++8C84 ~            	jr		nc, FileLoadNoHeader
 638++8C84 ~
 639++8C84 ~            FileLoadHeader:
 640++8C84 ~            	push	ix
 641++8C84 ~            	pop		hl
 642++8C84 ~            	ld		bc, CH_DATA + HDR_SZ
 643++8C84 ~            	add		hl, bc
 644++8C84 ~            	ld		bc, SECT_SZ - HDR_SZ
 645++8C84 ~            	ldir
 646++8C84 ~
 647++8C84 ~            FileReadLoop:
 648++8C84 ~            	push	de
 649++8C84 ~            		rst		8
 650++8C84 ~            		defb	53		;read sector
 651++8C84 ~            	pop		de
 652++8C84 ~            	jr		nc, FileFree
 653++8C84 ~
 654++8C84 ~            FileLoadNoHeader:
 655++8C84 ~            	push	ix
 656++8C84 ~            	pop		hl
 657++8C84 ~            	ld		bc, CH_DATA
 658++8C84 ~            	add		hl, bc
 659++8C84 ~            	ld		bc, SECT_SZ
 660++8C84 ~            	ldir
 661++8C84 ~            	jr		FileReadLoop
 662++8C84 ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663++8C84 ~            IF1FileLoadEnd:
 664++8C84 ~
 665++8C84 ~            FileFree:
 666++8C84 ~            	push	de
 667++8C84 ~            	rst		8
 668++8C84 ~            	defb	56			;close channel (52) or detroy channel (56)
 669++8C84 ~            	pop		de
 670++8C84 ~            	ret
 671++8C84 ~
 672++8C84 ~
 673++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674++8C84 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 675++8C84 ~            ;Out: A = error code, 0=OK
 676++8C84 ~            ReadDiskSectors:
 677++8C84 ~            	push bc
 678++8C84 ~            		push hl
 679++8C84 ~            			push de
 680++8C84 ~            				call ReadOneDiskSector
 681++8C84 ~            			pop de
 682++8C84 ~            		pop hl
 683++8C84 ~
 684++8C84 ~            		inc d
 685++8C84 ~            		inc h
 686++8C84 ~            	pop bc
 687++8C84 ~
 688++8C84 ~            	ld	a, (RWTSRes)
 689++8C84 ~            	or	a
 690++8C84 ~            	ret nz
 691++8C84 ~
 692++8C84 ~            	djnz ReadDiskSectors
 693++8C84 ~            	ret
 694++8C84 ~
 695++8C84 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 696++8C84 ~            ;Out: A = error code, 0=OK
 697++8C84 ~            WriteDiskSectors:
 698++8C84 ~            	push bc
 699++8C84 ~            		push hl
 700++8C84 ~            			push de
 701++8C84 ~            				call WriteOneDiskSector
 702++8C84 ~            			pop de
 703++8C84 ~            		pop hl
 704++8C84 ~
 705++8C84 ~            		inc d
 706++8C84 ~            		inc h
 707++8C84 ~            	pop bc
 708++8C84 ~
 709++8C84 ~            	ld	a, (RWTSRes)
 710++8C84 ~            	or	a
 711++8C84 ~            	ret nz
 712++8C84 ~
 713++8C84 ~            	djnz WriteDiskSectors
 714++8C84 ~            	ret
 715++8C84 ~
 716++8C84 ~
 717++8C84 ~            ;Reads disk catalog
 718++8C84 ~            ReadCatalogTrack:
 719++8C84 ~            	ld hl, TrackBuf
 720++8C84 ~            	ld de, 0
 721++8C84 ~            	ld b, SPT
 722++8C84 ~
 723++8C84 ~            	call ReadDiskSectors
 724++8C84 ~            	or   a
 725++8C84 ~            	ret  nz
 726++8C84 ~
 727++8C84 ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 728++8C84 ~            	push  af
 729++8C84 ~            		ld  a, (RWTSDrive)
 730++8C84 ~            		call BDOSSelectDisk
 731++8C84 ~            		call BDOSInit
 732++8C84 ~            	pop   af
 733++8C84 ~            	ret
 734++8C84 ~
 735++8C84 ~
 736++8C84 ~
 737++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738++8C84 ~
 739++8C84 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740++8C84 ~            FindCache:
 741++8C84 ~            	ld		b, NAMELEN
 742++8C84 ~            	call	StrCmp			;find the file to wich this extension belongs
 743++8C84 ~            	ret		z
 744++8C84 ~
 745++8C84 ~            	dec		c
 746++8C84 ~            	jr		nz, CacheNotFinished
 747++8C84 ~            	or		c
 748++8C84 ~            	ret
 749++8C84 ~
 750++8C84 ~            CacheNotFinished:
 751++8C84 ~            	ld		bc, CACHE_SZ
 752++8C84 ~            	add		hl, bc			;to the next cache line
 753++8C84 ~            	jr		FindCache
 754++8C84 ~
 755++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756++8C84 ~
 757++8C84 ~            	;ld		ix, (SelFileCache)
 758++8C84 ~            ReadFileHeader:
 759++8C84 ~            	ld		a, (ix + CACHE_FLAG)
 760++8C84 ~            	or		a
 761++8C84 ~            	ret		nz				;return if already read
 762++8C84 ~
 763++8C84 ~            	ld		l, (ix + CACHE_FIRST_AU)
 764++8C84 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 765++8C84 ~            	ld		a, h
 766++8C84 ~            	or		l
 767++8C84 ~            	jr		z, ReadHeaderEnd
 768++8C84 ~
 769++8C84 ~            	call	AU2TS
 770++8C84 ~            	ld		d, b
 771++8C84 ~            	ld		e, c
 772++8C84 ~            	ld		hl, DataBuf
 773++8C84 ~            	push	ix
 774++8C84 ~            	push	ix
 775++8C84 ~            		call	ReadOneDiskSector
 776++8C84 ~            	pop		hl
 777++8C84 ~            	pop		ix
 778++8C84 ~
 779++8C84 ~            	push	hl
 780++8C84 ~            		ld		hl, DataBuf
 781++8C84 ~            		call	IsFileHeaderValid
 782++8C84 ~            	pop		hl
 783++8C84 ~            	or		a
 784++8C84 ~            	jr		z, ReadFileHeaderIsTextFile
 785++8C84 ~
 786++8C84 ~            	ld		bc, CACHE_HDR
 787++8C84 ~            	add		hl, bc
 788++8C84 ~            	ex		hl, de
 789++8C84 ~            	ld		hl, DataBuf
 790++8C84 ~            	ld		bc, HDR_SZ
 791++8C84 ~            	ldir
 792++8C84 ~
 793++8C84 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 794++8C84 ~            	ld		a, BYTE_TYPE
 795++8C84 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 796++8C84 ~            	jr		nc, ReadHeaderEnd
 797++8C84 ~
 798++8C84 ~            ReadFileHeaderIsTextFile:
 799++8C84 ~            	push	ix
 800++8C84 ~            	push	ix
 801++8C84 ~            	pop		hl
 802++8C84 ~            		call	GetFileSize
 803++8C84 ~            	pop		ix
 804++8C84 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 805++8C84 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806++8C84 ~            	ld		a, TEXT_TYPE
 807++8C84 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808++8C84 ~
 809++8C84 ~            ReadHeaderEnd:
 810++8C84 ~            	inc		(ix + CACHE_FLAG)
 811++8C84 ~            	ret
 812++8C84 ~
 813++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814++8C84 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 815++8C84 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816++8C84 ~            ;In: HL = header
 817++8C84 ~            ;Out: A > 0 if valid
 818++8C84 ~            IsFileHeaderValid:
 819++8C84 ~            	IFUSED
 820++8C84 ~            	xor		a
 821++8C84 ~            	ld		b, HDR_SZ
 822++8C84 ~            IsFileHeaderValidLoop:
 823++8C84 ~            	or		(hl)
 824++8C84 ~            	inc		hl
 825++8C84 ~            	djnz	IsFileHeaderValidLoop
 826++8C84 ~
 827++8C84 ~            	ret
 828++8C84 ~            	ENDIF
 829++8C84 ~
 830++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831++8C84 ~
 832++8C84 ~            ;IN: HL = address from IF1 to call
 833++8C84 ~            IF1Call:
 834++8C84 ~            	LD   (HD11), HL
 835++8C84 ~            	RST  8
 836++8C84 ~            	DEFB 50
 837++8C84 ~            	RET
 838++8C84 ~
 839++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840++8C84 ~
 841++8C84 ~            ;Load a program from disk
 842++8C84 ~            ;IN: HL = file name addr
 843++8C84 ~            LoadProgram:
 844++8C84 ~            	LD   (FSTR1), HL
 845++8C84 ~            	LD   H, 0
 846++8C84 ~            	LD   L, NAMELEN
 847++8C84 ~            	LD   (NSTR1), HL
 848++8C84 ~            	LD	 A, (RWTSDrive)
 849++8C84 ~            	INC  A					;Adapt for BASIC drive number
 850++8C84 ~            	LD   L, A
 851++8C84 ~            	LD   (DSTR1), HL
 852++8C84 ~            	LD   HL, LOAD_ADDR
 853++8C84 ~            	CALL IF1Call
 854++8C84 ~            	RET
 855++8C84 ~
 856++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857++8C84 ~
 858++8C84 ~            SetFastKeys:
 859++8C84 ~            	ld		hl, REPDEL
 860++8C84 ~            	ld		de, (1 << 8) | 15
 861++8C84 ~            	ld		(hl), de
 862++8C84 ~
 863++8C84 ~            	ret
 864++8C84 ~
 865++8C84 ~
 866++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867++8C84 ~            ;Reads the error message string from IF1 ROM.
 868++8C84 ~            GetErrMsg:
 869++8C84 ~            	inc		a
 870++8C84 ~            	ex		af, af'
 871++8C84 ~
 872++8C84 ~            	ld		hl, IF1Paged			;page-in IF1
 873++8C84 ~            	jp		IF1Call
 874++8C84 ~
 875++8C84 ~            IF1Paged:
 876++8C84 ~            	ld		hl, ERRMSG
 877++8C84 ~            	ex		af, af'
 878++8C84 ~            	or		a
 879++8C84 ~            	jr		z, SaveMsg
 880++8C84 ~
 881++8C84 ~            	ld		b, 0
 882++8C84 ~            SearchMsgEnd:
 883++8C84 ~            	bit		7, (hl)
 884++8C84 ~            	inc		hl
 885++8C84 ~            	jr		z, SearchMsgEnd
 886++8C84 ~
 887++8C84 ~            	inc		b
 888++8C84 ~            	cp		b
 889++8C84 ~            	jr		nz, SearchMsgEnd
 890++8C84 ~
 891++8C84 ~            SaveMsg:
 892++8C84 ~            	ld		de, DataBuf
 893++8C84 ~            CopyMsg:
 894++8C84 ~            	ld		a, (hl)
 895++8C84 ~            	bit		7, a
 896++8C84 ~            	ld		(de), a
 897++8C84 ~            	inc		hl
 898++8C84 ~            	inc		de
 899++8C84 ~            	jr		z, CopyMsg
 900++8C84 ~
 901++8C84 ~            	ret
 902++8C84 ~
 903++8C84 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904++8C84 ~
 905++8C84 ~            ;RWTS routine I/O block
 906++8C84 ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 907++8C84 ~            RWTSParams:
 908++8C84 ~            RWTSBlockType	DEFB	1							;?
 909++8C84 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 910++8C84 ~            RWTSVolNo		DEFB	0							;?
 911++8C84 ~            RWTSTrack		DEFB	0
 912++8C84 ~            RWTSSector		DEFB	0
 913++8C84 ~            RWTSDMA			DEFW	0
 914++8C84 ~            RWTSExtBuf		DEFW	$2932
 915++8C84 ~            RWTSPrmTbl		DEFW	$1f2a
 916++8C84 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 917++8C84 ~            ;Results
 918++8C84 ~            RWTSRes			DEFB	0
 919++8C84 ~            RWTSResVolNo	DEFB	0
 920++8C84 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 921++8C84 ~
 922++8C84 ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 923++8C84 ~            /*
 924++8C84 ~            BasPrmTbl:
 925++8C84 ~            PrmDevType		DEFB	$01			;$01
 926++8C84 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 927++8C84 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 928++8C84 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 929++8C84 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 930++8C84 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 931++8C84 ~            */
 932++8C84 ~
 933++8C84              	endif
# file closed: if1.asm
  15+ 8C84
  16+ 8C84              BDOSInit:
  17+ 8C84 AF           	xor		a
  18+ 8C85 18 3D        	jr		BDOS
  19+ 8C87
  20+ 8C87
  21+ 8C87              ;IN: A = Drive to select
  22+ 8C87              BDOSSelectDisk:
  23+ 8C87              	IFUSED
  24+ 8C87 DD 6F        	ld		ixl, a
  25+ 8C89 DD 26 00     	ld		ixh, 0
  26+ 8C8C 3E 01        	ld		a, 1
  27+ 8C8E 18 34        	jr		BDOS
  28+ 8C90              	ENDIF
  29+ 8C90
  30+ 8C90
  31+ 8C90              BDOSMakeDiskRO:
  32+ 8C90              	IFUSED
  33+ 8C90 ~            	ld		a, 15
  34+ 8C90 ~            	jr		BDOS
  35+ 8C90              	ENDIF
  36+ 8C90
  37+ 8C90              ;Get Read Only flag
  38+ 8C90              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 8C90              BDOSGetDiskRO:
  40+ 8C90              	IFUSED
  41+ 8C90 ~            	ld	a, 16
  42+ 8C90 ~            	jr	BDOS
  43+ 8C90              	ENDIF
  44+ 8C90
  45+ 8C90              BDOSGetCurrentDisk:
  46+ 8C90              	IFUSED
  47+ 8C90 ~            	ld		a, 12
  48+ 8C90 ~            	jr		BDOS
  49+ 8C90              	ENDIF
  50+ 8C90
  51+ 8C90
  52+ 8C90              ;Create a disk channel for BDOS access (does not open the file)
  53+ 8C90              ;IN: HL=name addr, A=drive
  54+ 8C90              ;OUT: IX=FCB
  55+ 8C90              CreateChannel:
  56+ 8C90 22 DC 5C     	ld (FSTR1), hl
  57+ 8C93 26 00        	ld h,0
  58+ 8C95 6F           	ld l,a
  59+ 8C96 22 D6 5C     	ld (DSTR1), hl
  60+ 8C99 2E 0B        	ld l,NAMELEN
  61+ 8C9B 22 DA 5C     	ld (NSTR1), hl
  62+ 8C9E CF           	rst 08
  63+ 8C9F 37           	DEFB 55
  64+ 8CA0 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 8CA3 DD 09        	add ix, bc
  66+ 8CA5 C9           	ret
  67+ 8CA6
  68+ 8CA6
  69+ 8CA6              ;Destroy a BDOS channel
  70+ 8CA6              ;IN: IX=FCB
  71+ 8CA6              DestroyChannel:
  72+ 8CA6 C5           	push bc
  73+ 8CA7 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 8CAA DD 09        	add ix, bc
  75+ 8CAC CF           	rst 08
  76+ 8CAD 38           	DEFB 56
  77+ 8CAE C1           	pop bc
  78+ 8CAF C9           	ret
  79+ 8CB0
  80+ 8CB0
  81+ 8CB0              ;Input: IX=FCB
  82+ 8CB0              CreateFile:
  83+ 8CB0 3E 09        	ld	a, 9
  84+ 8CB2 18 10        	jr	BDOS
  85+ 8CB4
  86+ 8CB4              ;Input: IX=FCB
  87+ 8CB4              OpenFile:
  88+ 8CB4 3E 02        	ld	a, 2
  89+ 8CB6 18 0C        	jr	BDOS
  90+ 8CB8
  91+ 8CB8              ;IN: IX=FCB
  92+ 8CB8              CloseFile:
  93+ 8CB8 3E 03        	ld	a, 3
  94+ 8CBA 18 08        	jr	BDOS
  95+ 8CBC
  96+ 8CBC              ;IN: IX=FCB
  97+ 8CBC              ReadFileBlock:
  98+ 8CBC 3E 07        	ld	a, 7
  99+ 8CBE 18 04        	jr	BDOS
 100+ 8CC0
 101+ 8CC0              ;IN: IX=FCB
 102+ 8CC0              WriteFileBlock:
 103+ 8CC0 3E 08        	ld	a, 8
 104+ 8CC2 18 00        	jr	BDOS
 105+ 8CC4
 106+ 8CC4              ;Generic BDOS call
 107+ 8CC4              ;IX=arg, A=function
 108+ 8CC4              BDOS:
 109+ 8CC4 DD 22 ED 5C  	ld (HD11), ix
 110+ 8CC8 32 EF 5C     	ld (COPIES), a
 111+ 8CCB CF           	rst 08
 112+ 8CCC 39           	DEFB 57
 113+ 8CCD C9           	ret
 114+ 8CCE
 115+ 8CCE              ;Set DMA address for BDOS
 116+ 8CCE              ;IX=DMA
 117+ 8CCE              BDOSSetDMA:
 118+ 8CCE 3E 0D        	ld a, 13
 119+ 8CD0 18 F2        	jr BDOS
 120+ 8CD2
 121+ 8CD2
 122+ 8CD2              ;In: HL=filename
 123+ 8CD2              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 124+ 8CD2              GetFileSize:
 125+ 8CD2              	IFUSED
 126+ 8CD2
 127+ 8CD2 3A 72 8C     	ld 		a, (RWTSDrive)
 128+ 8CD5 3C           	inc		a					;Convert to BASIC drive number: 1,2
 129+ 8CD6 CD 90 8C     	call	CreateChannel
 130+ 8CD9
 131+ 8CD9 3E 14        	ld		a, 20
 132+ 8CDB CD C4 8C     	call	BDOS
 133+ 8CDE              	;inc		a
 134+ 8CDE              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 135+ 8CDE
 136+ 8CDE DD 6E 21     	ld		l, (ix + FCB_R0)
 137+ 8CE1 DD 66 22     	ld		h, (ix + FCB_R1)
 138+ 8CE4
 139+ 8CE4              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 140+ 8CE4 3E 01        	ld		a, 1
 141+ 8CE6 BC           	cp		h
 142+ 8CE7 30 05        	jr		nc, GetFileSizeOK
 143+ 8CE9 21 00 00     	ld		hl, 0
 144+ 8CEC 18 08        	jr		GetFileSizeEnd
 145+ 8CEE
 146+ 8CEE              GetFileSizeOK:
 147+ 8CEE              	;*128 == 2^7
 148+ 8CEE 06 07        	ld		b, 7
 149+ 8CF0              GetFileSizeMul:
 150+ 8CF0 CB 15        	rl		l
 151+ 8CF2 CB 14        	rl		h
 152+ 8CF4 10 FA        	djnz	GetFileSizeMul
 153+ 8CF6
 154+ 8CF6              GetFileSizeEnd:
 155+ 8CF6 E5           	push	hl
 156+ 8CF7 CD A6 8C     		call	DestroyChannel
 157+ 8CFA E1           	pop		hl
 158+ 8CFB
 159+ 8CFB C9           	ret
 160+ 8CFC              	ENDIF
 161+ 8CFC
 162+ 8CFC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 163+ 8CFC              ;HL=file name, A=drive
 164+ 8CFC              DeleteFile:
 165+ 8CFC CD 90 8C     	call	CreateChannel
 166+ 8CFF
 167+ 8CFF 3E 06        	ld		a, 6
 168+ 8D01 CD C4 8C     	call	BDOS
 169+ 8D04
 170+ 8D04 CD A6 8C     	call	DestroyChannel
 171+ 8D07 C9           	ret
 172+ 8D08
 173+ 8D08              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 8D08              ;Returns A > 0 if the file exists
 175+ 8D08              ;HL=file name, A=drive
 176+ 8D08              DoesFileExist:
 177+ 8D08              	IFUSED
 178+ 8D08 CD 90 8C     	call	CreateChannel
 179+ 8D0B
 180+ 8D0B 3E 04        	ld		a, 4
 181+ 8D0D CD C4 8C     	call	BDOS
 182+ 8D10
 183+ 8D10 F5           	push	af
 184+ 8D11 CD A6 8C     		call	DestroyChannel
 185+ 8D14 F1           	pop		af
 186+ 8D15 C9           	ret
 187+ 8D16              	ENDIF
 188+ 8D16
 189+ 8D16              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 190+ 8D16              ;IN: E0 = RO, E1 = SYS, HL=filename
 191+ 8D16              ChangeFileAttrib:
 192+ 8D16 3A 72 8C     	ld 		a, (RWTSDrive)
 193+ 8D19 3C           	inc		a					;Convert to BASIC drive number: 1,2
 194+ 8D1A D5           	push	de
 195+ 8D1B CD 90 8C     	call	CreateChannel
 196+ 8D1E D1           	pop		de
 197+ 8D1F
 198+ 8D1F DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 199+ 8D22 CB 27        	sla		a								;reset existing attribute flag
 200+ 8D24 CB 1B        	rr		e								;put wanted flag in Carry flag
 201+ 8D26 CB 1F        	rr		a								;put Carry flag in register L
 202+ 8D28 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 203+ 8D2B
 204+ 8D2B DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 205+ 8D2E CB 27        	sla		a
 206+ 8D30 CB 1B        	rr		e
 207+ 8D32 CB 1F        	rr		a
 208+ 8D34 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 209+ 8D37
 210+ 8D37              FileAttribSet:
 211+ 8D37 3E 11        	ld		a, 17
 212+ 8D39 CD C4 8C     	call	BDOS
 213+ 8D3C
 214+ 8D3C CD A6 8C     	call	DestroyChannel
 215+ 8D3F C9           	ret
 216+ 8D40
 217+ 8D40              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 8D40
 219+ 8D40              ;HL=original name, DE = new name
 220+ 8D40              ;Works only on the same drive.
 221+ 8D40              RenameFile:
 222+ 8D40 3A 72 8C     	ld 		a, (RWTSDrive)
 223+ 8D43 3C           	inc		a					;Convert to BASIC drive number: 1,2
 224+ 8D44 D5           	push	de
 225+ 8D45 CD 90 8C     	call	CreateChannel
 226+ 8D48 D1           	pop		de
 227+ 8D49
 228+ 8D49 DD E5        	push	ix					;IX == FCB
 229+ 8D4B E1           	pop		hl
 230+ 8D4C 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 231+ 8D4F 09           	add		hl, bc
 232+ 8D50 EB           	ex		de, hl
 233+ 8D51 3A 72 8C     	ld		a, (RWTSDrive)
 234+ 8D54 12           	ld		(de), a
 235+ 8D55 01 0B 00     	ld		bc, NAMELEN
 236+ 8D58 ED B0        	ldir
 237+ 8D5A
 238+ 8D5A 3E 0A        	ld		a, 10
 239+ 8D5C CD C4 8C     	call	BDOS
 240+ 8D5F
 241+ 8D5F CD A6 8C     	call	DestroyChannel
 242+ 8D62 C9           	ret
 243+ 8D63
 244+ 8D63              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 8D63
 246+ 8D63              ;Will copy a file from A: to B: or vice versa.
 247+ 8D63              ;HL=source file name
 248+ 8D63              CopyFile:
 249+ 8D63              	;Prepare source file
 250+ 8D63 E5           	push hl
 251+ 8D64 3A 72 8C     		ld 		a, (RWTSDrive)
 252+ 8D67 3C           		inc		a					;Convert to BASIC drive number: 1,2
 253+ 8D68 CD 90 8C     		call	CreateChannel
 254+ 8D6B CD B4 8C     		call 	OpenFile
 255+ 8D6E DD 22 AF A5  		ld		(CopyFileFCBSrc), ix
 256+ 8D72 E1           	pop hl
 257+ 8D73 3C           	inc  	a						;Cancel if A==$FF
 258+ 8D74 28 75        	jr   	z, CopyFileEnd
 259+ 8D76
 260+ 8D76              	;Create destination file
 261+ 8D76 DD 7E 00     	ld		a, (ix)
 262+ 8D79 EE 03        	xor		%11						;Alternate drive, A->B, B-A
 263+ 8D7B F5           	push	af
 264+ 8D7C E5           	push	hl
 265+ 8D7D CD FC 8C     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 266+ 8D80 E1           	pop		hl
 267+ 8D81 F1           	pop		af
 268+ 8D82 CD 90 8C     	call	CreateChannel
 269+ 8D85 CD B0 8C     	call 	CreateFile
 270+ 8D88 DD 22 B1 A5  	ld		(CopyFileFCBDst), ix
 271+ 8D8C 3C           	inc  	a						;Cancel if A==$FF
 272+ 8D8D 28 5C        	jr   	z, CopyFileEnd
 273+ 8D8F
 274+ 8D8F              FileCopyLoop:
 275+ 8D8F 06 59        	ld		b, MAX_SECT_RAM
 276+ 8D91 DD 21 B5 A5  	ld		ix, CopyFileDMAAddr
 277+ 8D95 21 B7 A5     	ld		hl, CopyFileDMA
 278+ 8D98 DD 75 00     	ld		(ix), l
 279+ 8D9B DD 74 01     	ld		(ix+1), h
 280+ 8D9E              FileCopyReadLoop:
 281+ 8D9E C5           	push	bc
 282+ 8D9F DD 2A B5 A5  		ld		ix, (CopyFileDMAAddr)
 283+ 8DA3 CD CE 8C     		call 	BDOSSetDMA
 284+ 8DA6 DD 24        		inc		ixh
 285+ 8DA8 DD 22 B5 A5  		ld		(CopyFileDMAAddr), ix
 286+ 8DAC
 287+ 8DAC DD 2A AF A5  		ld		ix, (CopyFileFCBSrc)
 288+ 8DB0 CD BC 8C     		call 	ReadFileBlock
 289+ 8DB3 B7           		or		a
 290+ 8DB4 32 B3 A5     		ld		(CopyFileResRead), a
 291+ 8DB7 C1           	pop		bc
 292+ 8DB8 20 02        	jr		nz, FileCopyWrite
 293+ 8DBA 10 E2        	djnz	FileCopyReadLoop
 294+ 8DBC
 295+ 8DBC              FileCopyWrite:
 296+ 8DBC DD 21 B5 A5  	ld		ix, CopyFileDMAAddr
 297+ 8DC0 21 B7 A5     	ld		hl, CopyFileDMA
 298+ 8DC3 DD 75 00     	ld		(ix), l
 299+ 8DC6 DD 74 01     	ld		(ix+1), h
 300+ 8DC9
 301+ 8DC9              	;Calculate how many sectors were read.
 302+ 8DC9 3E 59        	ld		a, MAX_SECT_RAM
 303+ 8DCB 90           	sub		b
 304+ 8DCC 47           	ld		b, a
 305+ 8DCD
 306+ 8DCD              FileCopyWriteLoop:
 307+ 8DCD C5           	push	bc
 308+ 8DCE DD 2A B5 A5  		ld		ix, (CopyFileDMAAddr)
 309+ 8DD2 CD CE 8C     		call 	BDOSSetDMA
 310+ 8DD5 DD 24        		inc		ixh
 311+ 8DD7 DD 22 B5 A5  		ld		(CopyFileDMAAddr), ix
 312+ 8DDB
 313+ 8DDB DD 2A B1 A5  		ld		ix, (CopyFileFCBDst)
 314+ 8DDF CD C0 8C     		call	WriteFileBlock
 315+ 8DE2 B7           		or		a
 316+ 8DE3 32 B4 A5     		ld		(CopyFileResWrite), a
 317+ 8DE6 C1           	pop		bc
 318+ 8DE7 20 02        	jr		nz, CopyFileEnd
 319+ 8DE9 10 E2        	djnz	FileCopyWriteLoop
 320+ 8DEB
 321+ 8DEB              CopyFileEnd:
 322+ 8DEB              	;Check if file ended, if not, continue copying.
 323+ 8DEB 3A B3 A5     	ld		a, (CopyFileResRead)
 324+ 8DEE B7           	or		a
 325+ 8DEF 28 9E        	jr		z, FileCopyLoop
 326+ 8DF1
 327+ 8DF1 DD 2A B1 A5  	ld		ix, (CopyFileFCBDst)
 328+ 8DF5 CD B8 8C     	call 	CloseFile				;close destination file
 329+ 8DF8 CD A6 8C     	call 	DestroyChannel
 330+ 8DFB
 331+ 8DFB              	;Don't need to close source file, but must free channel
 332+ 8DFB DD 2A AF A5  	ld		ix, (CopyFileFCBSrc)
 333+ 8DFF CD A6 8C     	call 	DestroyChannel
 334+ 8E02
 335+ 8E02 3A B4 A5     	ld		a, (CopyFileResWrite)
 336+ 8E05
 337+ 8E05 C9           	ret
 338+ 8E06
 339+ 8E06              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 340+ 8E06              ;Reads part of a file
 341+ 8E06              ;In: HL = name, DE = file offset in bytes
 342+ 8E06              ;Out: FileData = read buffer, DE = end of file
 343+ 8E06              ReadFileSection:
 344+ 8E06 3A 72 8C     	ld 		a, (RWTSDrive)
 345+ 8E09 3C           	inc		a					;Convert to BASIC drive number: 1,2
 346+ 8E0A CD 90 8C     	call	CreateChannel
 347+ 8E0D CD B4 8C     	call 	OpenFile
 348+ 8E10 DD 22 AF A5  	ld		(CopyFileFCBSrc), ix
 349+ 8E14 3C           	inc  	a						;Cancel if A==$FF
 350+ 8E15 C8           	ret		z
 351+ 8E16
 352+ 8E16              	;Limit max sectors to read to leave space for the index too.
 353+ 8E16 06 51        	ld		b, FileDataSize/SECT_SZ
 354+ 8E18              	;Set destination memory pointer.
 355+ 8E18 DD 21 B5 A5  	ld		ix, CopyFileDMAAddr
 356+ 8E1C 21 AF A6     	ld		hl, FileData
 357+ 8E1F DD 75 00     	ld		(ix), l
 358+ 8E22 DD 74 01     	ld		(ix+1), h
 359+ 8E25              ReadFileSectionLoop:
 360+ 8E25 C5           	push	bc
 361+ 8E26 DD 2A B5 A5  		ld		ix, (CopyFileDMAAddr)
 362+ 8E2A CD CE 8C     		call 	BDOSSetDMA
 363+ 8E2D DD 24        		inc		ixh
 364+ 8E2F DD 22 B5 A5  		ld		(CopyFileDMAAddr), ix
 365+ 8E33
 366+ 8E33 DD 2A AF A5  		ld		ix, (CopyFileFCBSrc)
 367+ 8E37 CD BC 8C     		call 	ReadFileBlock
 368+ 8E3A B7           		or		a
 369+ 8E3B 32 B3 A5     		ld		(CopyFileResRead), a
 370+ 8E3E C1           	pop		bc
 371+ 8E3F 20 02        	jr		nz, ReadFileSectionEnd
 372+ 8E41 10 E2        	djnz	ReadFileSectionLoop
 373+ 8E43
 374+ 8E43              ReadFileSectionEnd:
 375+ 8E43 DD 2A AF A5  	ld		ix, (CopyFileFCBSrc)
 376+ 8E47 CD A6 8C     	call 	DestroyChannel
 377+ 8E4A
 378+ 8E4A ED 5B B5 A5  	ld		de, (CopyFileDMAAddr)
 379+ 8E4E 15           	dec		d
 380+ 8E4F C9           	ret
 381+ 8E50
 382+ 8E50              	ENDIF
 383+ 8E50
# file closed: bdos.asm
1325  8E50              	include "ui.asm"
# file opened: ui.asm
   1+ 8E50              ;UI related functions
   2+ 8E50
   3+ 8E50              	ifndef	_UI_
   4+ 8E50              	define	_UI_
   5+ 8E50
   6+ 8E50              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++8E50              	ifndef	_HCCFG_
   2++8E50 ~            	define	_HCCFG_
   3++8E50 ~
   4++8E50 ~            ;HC specific code, for configuration
   5++8E50 ~
   6++8E50 ~            HC_CFG_PORT			EQU	$7E
   7++8E50 ~
   8++8E50 ~            ;BASIC/CPM ROM selection
   9++8E50 ~            HC_CFG_ROM_BAS		EQU	%0
  10++8E50 ~            HC_CFG_ROM_CPM		EQU	%1
  11++8E50 ~
  12++8E50 ~            ;Address for ROM paging: 0 or $E000
  13++8E50 ~            HC_CFG_ROM_0000		EQU %00
  14++8E50 ~            HC_CFG_ROM_E000		EQU %10
  15++8E50 ~
  16++8E50 ~            ;Cfg. port Enable/Disable
  17++8E50 ~            HC_CFG_PORT_DIS		EQU %000
  18++8E50 ~            HC_CFG_PORT_EN		EQU	%100
  19++8E50 ~
  20++8E50 ~            ;Video memory bank: $4000 or $C000
  21++8E50 ~            HC_CFG_VID_4000		EQU	%0000
  22++8E50 ~            HC_CFG_VID_C000		EQU	%1000
  23++8E50 ~
  24++8E50 ~
  25++8E50 ~            ;Standar BASIC config
  26++8E50 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++8E50 ~            ;Standar CP/M config
  28++8E50 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++8E50 ~
  30++8E50 ~
  31++8E50 ~            HC_VID_BANK0		EQU	$4000
  32++8E50 ~            HC_VID_BANK1		EQU	$C000
  33++8E50 ~
  34++8E50              	endif
# file closed: hccfg.asm
   7+ 8E50
   8+ 8E50              COL             EQU 23728
   9+ 8E50              LINE            EQU 23729               ;Coordinates
  10+ 8E50              LineCol			EQU	COL
  11+ 8E50              CODE			EQU 23681               ;Char to print
  12+ 8E50
  13+ 8E50              CPM_FNT         EQU $25AB
  14+ 8E50
  15+ 8E50              PORT_ZX			EQU	$FE
  16+ 8E50
  17+ 8E50              ;COLORS
  18+ 8E50              CLR_BLACK		EQU 0
  19+ 8E50              CLR_BLUE		EQU 1
  20+ 8E50              CLR_RED			EQU 2
  21+ 8E50              CLR_MAGENTA		EQU 3
  22+ 8E50              CLR_GREEN		EQU 4
  23+ 8E50              CLR_CYAN		EQU	5
  24+ 8E50              CLR_YELLOW		EQU	6
  25+ 8E50              CLR_WHITE		EQU	7
  26+ 8E50              CLR_BRIGHT		EQU	%01000000
  27+ 8E50              CLR_FLASH		EQU	%10000000
  28+ 8E50
  29+ 8E50              ;PAPER
  30+ 8E50              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 8E50              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 8E50              PAPER_RED		EQU (CLR_RED << 3)
  33+ 8E50              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 8E50              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 8E50              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 8E50              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 8E50              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 8E50
  39+ 8E50              ;INK
  40+ 8E50              INK_BLACK		EQU CLR_BLACK
  41+ 8E50              INK_BLUE		EQU CLR_BLUE
  42+ 8E50              INK_RED			EQU CLR_RED
  43+ 8E50              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 8E50              INK_GREEN		EQU CLR_GREEN
  45+ 8E50              INK_CYAN		EQU	CLR_CYAN
  46+ 8E50              INK_YELLOW		EQU	CLR_YELLOW
  47+ 8E50              INK_WHITE		EQU	CLR_WHITE
  48+ 8E50
  49+ 8E50
  50+ 8E50              ;SCR_ATTR_ADDR	EQU 22528
  51+ 8E50              SCR_PIX_LEN		EQU	6144
  52+ 8E50              SCR_ATTR_LEN	EQU	768
  53+ 8E50              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 8E50              SCR_BYTES_PER_LINE	EQU	32
  55+ 8E50
  56+ 8E50              SCR_COLS		EQU	64
  57+ 8E50              SCR_LINES		EQU 24
  58+ 8E50
  59+ 8E50              ;used for file names list positioning
  60+ 8E50              LST_LINES_CNT	EQU	23
  61+ 8E50              LST_FIRST_LINE	EQU	0
  62+ 8E50              LST_PROG_INFO	EQU LST_FIRST_LINE
  63+ 8E50              LST_DISK_INFO	EQU LST_PROG_INFO + 6
  64+ 8E50              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  65+ 8E50              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  66+ 8E50              LST_FIRST_COL	EQU	16
  67+ 8E50              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  68+ 8E50
  69+ 8E50              ;key codes
  70+ 8E50              KEY_ESC			EQU	7
  71+ 8E50              KEY_LEFT		EQU	8
  72+ 8E50              KEY_RIGHT		EQU	9
  73+ 8E50              KEY_DOWN		EQU	10
  74+ 8E50              KEY_UP			EQU	11
  75+ 8E50              KEY_BACKSP		EQU 12
  76+ 8E50              KEY_ENTER		EQU	13
  77+ 8E50              KEY_CTRL		EQU	14
  78+ 8E50
  79+ 8E50              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  80+ 8E50              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  81+ 8E50              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  82+ 8E50
  83+ 8E50              ;Special formating chars
  84+ 8E50              CHR_CR			EQU	13
  85+ 8E50              CHR_LF			EQU	10
  86+ 8E50              CHR_TAB			EQU	09
  87+ 8E50              CHR_EOF			EQU $1A
  88+ 8E50
  89+ 8E50
  90+ 8E50              ;Semi-graphical chars
  91+ 8E50              ;           UC
  92+ 8E50              ;     UL +H-+--+UR
  93+ 8E50              ;        |  |  |
  94+ 8E50              ;     ML +--+--+MR
  95+ 8E50              ;        V C|  |
  96+ 8E50              ;     LL +--+--+LR
  97+ 8E50              ;           DC
  98+ 8E50              CHR_GRID        EQU 127
  99+ 8E50              CHR_V           EQU	128
 100+ 8E50              CHR_MR          EQU	129
 101+ 8E50              CHR_UR          EQU 130
 102+ 8E50              CHR_DL          EQU 131
 103+ 8E50              CHR_DC          EQU 132
 104+ 8E50              CHR_UC          EQU 133
 105+ 8E50              CHR_ML          EQU 134
 106+ 8E50              CHR_H           EQU 135
 107+ 8E50              CHR_C           EQU 136
 108+ 8E50              CHR_LR          EQU 137
 109+ 8E50              CHR_UL          EQU 138
 110+ 8E50              CHR_FULL        EQU 139
 111+ 8E50              CHR_HALF        EQU 140
 112+ 8E50
 113+ 8E50              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 114+ 8E50
 115+ 8E50              ;Return read char in A
 116+ 8E50              ReadChar:
 117+ 8E50 CF           	rst 08
 118+ 8E51 1B           	DEFB 27
 119+ 8E52 C9           	ret
 120+ 8E53
 121+ 8E53              ;Checks if a key is pressed
 122+ 8E53              ;Cy=1 if key is pressed
 123+ 8E53              KbdHit:
 124+ 8E53 CF           	rst 08
 125+ 8E54 20           	DEFB 32
 126+ 8E55 C9           	ret
 127+ 8E56              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 128+ 8E56
 129+ 8E56              InitFonts:
 130+ 8E56              	IFUSED
 131+ 8E56                  ;page-in CPM ROM to get fonts
 132+ 8E56 F3               di
 133+ 8E57 3E 01            ld a, HC_CFG_ROM_CPM
 134+ 8E59 D3 7E            out	(HC_CFG_PORT), a
 135+ 8E5B
 136+ 8E5B 21 AB 25     	ld		hl, CPM_FNT
 137+ 8E5E 11 47 A2     	ld		de, FontTable
 138+ 8E61 01 68 03     	ld		bc, 872
 139+ 8E64 ED B0        	ldir
 140+ 8E66
 141+ 8E66                  ;restore BASIC ROM
 142+ 8E66 3E 00            ld a, HC_CFG_ROM_BAS
 143+ 8E68 D3 7E            out	(HC_CFG_PORT), a
 144+ 8E6A FB               ei
 145+ 8E6B
 146+ 8E6B C9           	ret
 147+ 8E6C              	ENDIF
 148+ 8E6C
 149+ 8E6C              ClrScr:
 150+ 8E6C 2A 0F 90     	ld		hl, (CurrScrAddr)
 151+ 8E6F 54           	ld		d, h
 152+ 8E70 5D           	ld		e, l
 153+ 8E71 13           	inc		de
 154+ 8E72 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 155+ 8E75 36 00        	ld		(hl), 0
 156+ 8E77 ED B0        	ldir
 157+ 8E79
 158+ 8E79 23           	inc 	hl
 159+ 8E7A 13           	inc		de
 160+ 8E7B
 161+ 8E7B 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 162+ 8E7E 36 0F        	ld		(hl), SCR_DEF_CLR
 163+ 8E80 ED B0        	ldir
 164+ 8E82
 165+ 8E82              	;also set border color
 166+ 8E82 3E 01        	ld		a, SCR_DEF_CLR >> 3
 167+ 8E84 D3 FE        	out		(PORT_ZX), a
 168+ 8E86
 169+ 8E86 3E 0F        	ld		a, SCR_DEF_CLR
 170+ 8E88 32 48 5C     	ld		(23624), a
 171+ 8E8B C9           	ret
 172+ 8E8C
 173+ 8E8C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 8E8C              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 175+ 8E8C              PrintStr:
 176+ 8E8C 7E           	ld		a, (hl)
 177+ 8E8D FE 20        	cp		' '
 178+ 8E8F 30 02        	jr		nc, GoodChar
 179+ 8E91 3E 3F        	ld		a, '?'
 180+ 8E93              GoodChar:
 181+ 8E93 CB 7F        	bit		7, a
 182+ 8E95 CB BF        	res		7, a
 183+ 8E97 32 81 5C     	ld		(CODE), a
 184+ 8E9A ED 53 B0 5C  	ld		(LineCol), de
 185+ 8E9E 08           	ex		af, af'
 186+ 8E9F D9           	exx
 187+ 8EA0 E5           	push	hl
 188+ 8EA1 CD 8F 8F     	call 	PrintChar
 189+ 8EA4 E1           	pop		hl
 190+ 8EA5 D9           	exx
 191+ 8EA6 08           	ex		af, af'
 192+ 8EA7 C0           	ret		nz
 193+ 8EA8
 194+ 8EA8 1C           	inc		e
 195+ 8EA9 23           	inc		hl
 196+ 8EAA
 197+ 8EAA 7B           	ld		a, e
 198+ 8EAB FE 40        	cp		64
 199+ 8EAD 38 DD        	jr		c, PrintStr
 200+ 8EAF 1E 00        	ld		e, 0
 201+ 8EB1 14           	inc		d
 202+ 8EB2
 203+ 8EB2 18 D8        	jr		PrintStr
 204+ 8EB4
 205+ 8EB4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 206+ 8EB4
 207+ 8EB4              ;IN: HL = string, DE = coords, A = color
 208+ 8EB4              PrintStrClr:
 209+ 8EB4 32 E0 8E     	ld		(StrClr), a
 210+ 8EB7 D5           	push	de
 211+ 8EB8 CD 8C 8E     		call	PrintStr
 212+ 8EBB E1           	pop		hl
 213+ 8EBC              	;get string len.
 214+ 8EBC 7B           	ld		a, e
 215+ 8EBD 95           	sub		l
 216+ 8EBE 1F           	rra
 217+ 8EBF 08           	ex		af, af'
 218+ 8EC0              		;line * 32
 219+ 8EC0 7C           		ld		a, h
 220+ 8EC1 17           		rla
 221+ 8EC2 17           		rla
 222+ 8EC3 11 00 00     		ld	de, 0
 223+ 8EC6 17           		rla
 224+ 8EC7 CB 12        		rl	d
 225+ 8EC9 17           		rla
 226+ 8ECA CB 12        		rl	d
 227+ 8ECC 17           		rla
 228+ 8ECD CB 12        		rl	d
 229+ 8ECF 5F           		ld	e, a
 230+ 8ED0
 231+ 8ED0 26 00        		ld		h, 0
 232+ 8ED2 19           		add		hl, de
 233+ 8ED3 ED 5B 11 90  		ld		de, (CurrScrAttrAddr)
 234+ 8ED7 19           		add		hl, de
 235+ 8ED8 08           	ex		af, af'
 236+ 8ED9 4F           	ld		c, a
 237+ 8EDA 06 00        	ld		b, 0
 238+ 8EDC 54           	ld		d, h
 239+ 8EDD 5D           	ld		e, l
 240+ 8EDE 13           	inc 	de
 241+ 8EDF              StrClr	EQU	$ + 1
 242+ 8EDF 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 243+ 8EE1 ED B0        	ldir
 244+ 8EE3 C9           	ret
 245+ 8EE4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 246+ 8EE4
 247+ 8EE4              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 248+ 8EE4              DrawLine:
 249+ 8EE4 32 81 5C     	ld		(CODE), a
 250+ 8EE7
 251+ 8EE7 38 04        	jr		c, VertDir
 252+ 8EE9 3E 1C        	ld		a, $1C
 253+ 8EEB 18 02        	jr		StoreDir
 254+ 8EED              VertDir:
 255+ 8EED 3E 14        	ld		a, $14
 256+ 8EEF              StoreDir:
 257+ 8EEF 32 FF 8E     	ld		(LineDir), a
 258+ 8EF2
 259+ 8EF2              DrawLineLoop:
 260+ 8EF2 ED 53 B0 5C  	ld		(LineCol), de
 261+ 8EF6 D5           	push	de
 262+ 8EF7 D9           		exx
 263+ 8EF8 E5           		push	hl
 264+ 8EF9 CD 8F 8F     		call 	PrintChar
 265+ 8EFC E1           		pop		hl
 266+ 8EFD D9           		exx
 267+ 8EFE D1           	pop		de
 268+ 8EFF              LineDir:
 269+ 8EFF 1C           	inc		e
 270+ 8F00 10 F0        	djnz	DrawLineLoop
 271+ 8F02
 272+ 8F02 C9           	ret
 273+ 8F03
 274+ 8F03              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 275+ 8F03
 276+ 8F03              DrawHLine:
 277+ 8F03 32 12 8F     	ld		(ChrParam), a
 278+ 8F06
 279+ 8F06 06 10        	ld		b, 16
 280+ 8F08 3E 87        	ld		a, CHR_H
 281+ 8F0A B7           	or		a
 282+ 8F0B CD E4 8E     	call	DrawLine
 283+ 8F0E
 284+ 8F0E 06 04        	ld		b, 4
 285+ 8F10              DrawUpLine:
 286+ 8F10 C5           	push	bc
 287+ 8F11              ChrParam	EQU		$ + 1
 288+ 8F11 3E 85        		ld		a, CHR_UC
 289+ 8F13 D5           		push	de
 290+ 8F14 CD 45 8F     			call	PrintChar2
 291+ 8F17 D1           		pop		de
 292+ 8F18 13           		inc		de
 293+ 8F19
 294+ 8F19 06 0B        		ld		b, NAMELEN
 295+ 8F1B 3E 87        		ld		a, CHR_H
 296+ 8F1D B7           		or		a
 297+ 8F1E CD E4 8E     		call	DrawLine
 298+ 8F21 C1           	pop		bc
 299+ 8F22 10 EC        	djnz	DrawUpLine
 300+ 8F24
 301+ 8F24 06 04        	ld		b, 4
 302+ 8F26 3E 87        	ld		a, CHR_H
 303+ 8F28 B7           	or		a
 304+ 8F29 CD E4 8E     	call	DrawLine
 305+ 8F2C C9           	ret
 306+ 8F2D
 307+ 8F2D
 308+ 8F2D              DrawVLines:
 309+ 8F2D 06 04        	ld		b, 4
 310+ 8F2F 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 311+ 8F32              DrawVLinesLoop:
 312+ 8F32 C5           	push 	bc
 313+ 8F33 D5           	push	de
 314+ 8F34 06 17        		ld		b, LST_LINES_CNT
 315+ 8F36 3E 80        		ld		a, CHR_V
 316+ 8F38 37           		scf
 317+ 8F39 CD E4 8E     		call	DrawLine
 318+ 8F3C D1           	pop		de
 319+ 8F3D C1           	pop	bc
 320+ 8F3E 7B           	ld		a, e
 321+ 8F3F C6 0C        	add		NAMELEN+1
 322+ 8F41 5F           	ld		e, a
 323+ 8F42 10 EE        	djnz	DrawVLinesLoop
 324+ 8F44 C9           	ret
 325+ 8F45
 326+ 8F45              PrintChar2:
 327+ 8F45 32 81 5C     	ld		(CODE), a
 328+ 8F48 ED 53 B0 5C  	ld		(LineCol), de
 329+ 8F4C
 330+ 8F4C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 331+ 8F4C
 332+ 8F4C              ;IN: A = color mask
 333+ 8F4C              DrawCursor:
 334+ 8F4C ED 5B C3 96  	ld	de, (CursorAddr)
 335+ 8F50 06 06        	ld	b, 	(NAMELEN + 1)/2
 336+ 8F52              DrawCursorLoop:
 337+ 8F52 12           	ld	(de), a
 338+ 8F53 13           	inc de
 339+ 8F54 10 FC        	djnz DrawCursorLoop
 340+ 8F56 C9           	ret
 341+ 8F57
 342+ 8F57              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 343+ 8F57
 344+ 8F57              ;IN:	A = file idx.
 345+ 8F57              MoveCursor:
 346+ 8F57              	;File idx / SCR_LINES => cursor line & column
 347+ 8F57 6F           	ld		l, a
 348+ 8F58 26 00        	ld		h, 0
 349+ 8F5A 0E 17        	ld		c, LST_LINES_CNT
 350+ 8F5C CD A9 88     	call	Div					;HL = file column, A = line
 351+ 8F5F
 352+ 8F5F              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 353+ 8F5F C6 00        	add		LST_FIRST_LINE
 354+ 8F61
 355+ 8F61
 356+ 8F61 54           	ld d, h
 357+ 8F62 5D           	ld e, l
 358+ 8F63 21 00 00     	ld	hl, 0
 359+ 8F66
 360+ 8F66              	;line*32
 361+ 8F66 17           	rla
 362+ 8F67 17           	rla
 363+ 8F68 17           	rla
 364+ 8F69 17           	rla
 365+ 8F6A CB 14        	rl h
 366+ 8F6C 17           	rla
 367+ 8F6D CB 14        	rl h
 368+ 8F6F 6F           	ld l, a
 369+ 8F70
 370+ 8F70
 371+ 8F70              	;col * 6
 372+ 8F70 E5           	push	hl					;save line * 32
 373+ 8F71 3E 06        		ld		a, (NAMELEN + 1)/2
 374+ 8F73 CD C9 88     		call	Mul				;HL = column * 12/2
 375+ 8F76 D1           	pop		de
 376+ 8F77 19           	add		hl, de
 377+ 8F78
 378+ 8F78 11 08 00     	ld		de, LST_FIRST_COL/2
 379+ 8F7B ED 4B 11 90  	ld		bc, (CurrScrAttrAddr)
 380+ 8F7F 19           	add		hl, de
 381+ 8F80 09           	add		hl, bc
 382+ 8F81
 383+ 8F81              	;clear old cursor
 384+ 8F81 3E 0F        	ld		a, SCR_DEF_CLR
 385+ 8F83 CD 4C 8F     	call	DrawCursor
 386+ 8F86
 387+ 8F86              	;draw new one
 388+ 8F86 22 C3 96     	ld		(CursorAddr), hl
 389+ 8F89 3E 28        	ld		a, SCR_SEL_CLR
 390+ 8F8B CD 4C 8F     	call	DrawCursor
 391+ 8F8E
 392+ 8F8E C9           	ret
 393+ 8F8F
 394+ 8F8F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 395+ 8F8F
 396+ 8F8F              PrintChar:
 397+ 8F8F ED 5B B0 5C      ld		de, (LineCol)
 398+ 8F93
 399+ 8F93                  ;calculate 64 column screen address
 400+ 8F93              	;IN: D = line, E = col
 401+ 8F93              	;OUT: HL = screen address
 402+ 8F93
 403+ 8F93 CB 3B            SRL     E                                       ;col = col/2
 404+ 8F95 CB 19            RR      C                                       ;mark odd/even column
 405+ 8F97 7A               LD      A, D                            ;A = line
 406+ 8F98 E6 18            AND 24                                  ;keep only %00011000
 407+ 8F9A 2A 0F 90         ld		hl, (CurrScrAddr)
 408+ 8F9D B4               OR      h								;add screen start address
 409+ 8F9E 67               LD      H, A                            ;save H
 410+ 8F9F 7A               LD      A, D                            ;A = line
 411+ 8FA0 E6 07            AND 7                                   ;keep only %00000111
 412+ 8FA2 0F               RRCA                                    ;%10000011
 413+ 8FA3 0F               RRCA                                    ;%11000001
 414+ 8FA4 0F               RRCA                                    ;%11100000
 415+ 8FA5 B3               OR      E                                       ;add column
 416+ 8FA6 6F               LD      L, A                            ;HL = screen address
 417+ 8FA7
 418+ 8FA7              PrintChar3:
 419+ 8FA7                  ;get font address
 420+ 8FA7 E5               PUSH HL
 421+ 8FA8 AF                   XOR A
 422+ 8FA9 67                   LD  H, A
 423+ 8FAA 3A 81 5C             LD  A, (CODE)
 424+ 8FAD D6 20                SUB ' '
 425+ 8FAF 6F                   LD  L, A
 426+ 8FB0 29                   ADD     HL, HL                  ;char code = char code * 8
 427+ 8FB1 29                   ADD     HL, HL                  ;i.e. offset into font table
 428+ 8FB2 29                   ADD     HL, HL
 429+ 8FB3 11 47 A2             LD      DE, FontTable             ;get font table
 430+ 8FB6 19                   ADD     HL, DE
 431+ 8FB7 EB                   EX      DE, HL                  ;DE = our char font address
 432+ 8FB8 E1               POP     HL
 433+ 8FB9
 434+ 8FB9
 435+ 8FB9                  ;print a char
 436+ 8FB9 06 08            LD      B, 8                            ;char height is 8 lines
 437+ 8FBB              PrintCharLine:
 438+ 8FBB 1A                   LD      A, (DE)                         ;load char line in A
 439+ 8FBC
 440+ 8FBC CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 441+ 8FBE 20 06                JR  	NZ, NoTurn
 442+ 8FC0
 443+ 8FC0 07                   RLCA
 444+ 8FC1 07                   RLCA
 445+ 8FC2 07                   RLCA
 446+ 8FC3 07                   RLCA
 447+ 8FC4 18 01                JR      Store
 448+ 8FC6              NoTurn:
 449+ 8FC6 B6                   OR (HL)
 450+ 8FC7              Store:
 451+ 8FC7 77                   LD (HL), A
 452+ 8FC8
 453+ 8FC8 13                   INC     DE                                      ;next char line in font table
 454+ 8FC9 24                   INC     H                                       ;next char line on screen
 455+ 8FCA 10 EF            DJNZ PrintCharLine                  ;last line of char?
 456+ 8FCC
 457+ 8FCC C9               ret
 458+ 8FCD
 459+ 8FCD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 460+ 8FCD
 461+ 8FCD              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 462+ 8FCD              ReadString:
 463+ 8FCD 21 AF A5     	ld		hl, DataBuf
 464+ 8FD0 D5           	push	de
 465+ 8FD1 DD E1        	pop		ix
 466+ 8FD3
 467+ 8FD3              ReadStringLoop:
 468+ 8FD3 D5           	push	de
 469+ 8FD4 E5           	push	hl
 470+ 8FD5 CD 50 8E     		call ReadChar
 471+ 8FD8 E1           	pop		hl
 472+ 8FD9 D1           	pop		de
 473+ 8FDA
 474+ 8FDA FE 0D        	cp	KEY_ENTER
 475+ 8FDC C8           	ret z
 476+ 8FDD
 477+ 8FDD FE 0C        	cp  KEY_BACKSP
 478+ 8FDF 20 0F        	jr	nz, ReadStrChar
 479+ 8FE1
 480+ 8FE1 E5           	push hl
 481+ 8FE2 01 B0 A5     	ld   bc, DataBuf+1
 482+ 8FE5 ED 42        	sbc	 hl, bc
 483+ 8FE7 E1           	pop  hl
 484+ 8FE8 38 16        	jr   c, ReadStrPrint
 485+ 8FEA
 486+ 8FEA 1B           	dec	de
 487+ 8FEB 2B           	dec	hl
 488+ 8FEC 36 20        	ld	(hl), ' '
 489+ 8FEE 18 10        	jr	ReadStrPrint
 490+ 8FF0
 491+ 8FF0              ReadStrChar:
 492+ 8FF0 FE 20        	cp	' '
 493+ 8FF2 38 DF        	jr	c, ReadStringLoop
 494+ 8FF4 FE 7F        	cp  127
 495+ 8FF6 30 DB        	jr	nc, ReadStringLoop
 496+ 8FF8
 497+ 8FF8              	;Check end of string and go back if found.
 498+ 8FF8 46           	ld	b, (hl)
 499+ 8FF9 CB 78        	bit 7, b
 500+ 8FFB 20 03        	jr	nz, ReadStrPrint
 501+ 8FFD
 502+ 8FFD 77           	ld	(hl), a
 503+ 8FFE 23           	inc	hl
 504+ 8FFF 13           	inc	de
 505+ 9000
 506+ 9000              ReadStrPrint:
 507+ 9000 E5           	push	hl
 508+ 9001 D5           	push	de
 509+ 9002 21 AF A5     	ld		hl, DataBuf
 510+ 9005 DD E5        	push	ix
 511+ 9007 D1           	pop		de
 512+ 9008 CD 8C 8E     	call	PrintStr
 513+ 900B D1           	pop		de
 514+ 900C E1           	pop		hl
 515+ 900D
 516+ 900D 18 C4        	jr		ReadStringLoop
 517+ 900F
 518+ 900F 00 40        CurrScrAddr		DEFW	16384
 519+ 9011 00 58        CurrScrAttrAddr	DEFW	22528
 520+ 9013
 521+ 9013                 	endif
# file closed: ui.asm
1326  9013              	include "math.asm"
# file opened: math.asm
   1+ 9013              	ifndef	_MATH_
   2+ 9013 ~            	define	_MATH_
   3+ 9013 ~
   4+ 9013 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 9013 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 9013 ~
   7+ 9013 ~
   8+ 9013 ~            Word2Txt:
   9+ 9013 ~            	IFUSED
  10+ 9013 ~            	push	de
  11+ 9013 ~            		call	Word2Txt_
  12+ 9013 ~            	pop		de
  13+ 9013 ~
  14+ 9013 ~            	ld		b, 4
  15+ 9013 ~            	call	StrippLeading0
  16+ 9013 ~            	ret
  17+ 9013 ~
  18+ 9013 ~            Byte2Txt:
  19+ 9013 ~            	push	de
  20+ 9013 ~            		call	Byte2Txt_
  21+ 9013 ~            	pop		de
  22+ 9013 ~
  23+ 9013 ~            	ld		b, 2
  24+ 9013 ~            	call	StrippLeading0
  25+ 9013 ~            	ret
  26+ 9013 ~            	ENDIF
  27+ 9013 ~
  28+ 9013 ~
  29+ 9013 ~            StrippLeading0:
  30+ 9013 ~            	ld		a, (de)
  31+ 9013 ~            	cp		'1'
  32+ 9013 ~            	ret		nc
  33+ 9013 ~
  34+ 9013 ~            	ld		a, ' '
  35+ 9013 ~            	ld		(de), a
  36+ 9013 ~            	inc		de
  37+ 9013 ~            	djnz	StrippLeading0
  38+ 9013 ~            	ret
  39+ 9013 ~
  40+ 9013 ~
  41+ 9013 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 9013 ~            Word2Txt_:
  43+ 9013 ~            	ld bc, -10000
  44+ 9013 ~            	call DigitLoop
  45+ 9013 ~            	ld bc, -1000
  46+ 9013 ~            	call DigitLoop
  47+ 9013 ~            Byte2Txt_:
  48+ 9013 ~            	ld bc, -100
  49+ 9013 ~            	call DigitLoop
  50+ 9013 ~            	ld bc, -10
  51+ 9013 ~            	call DigitLoop
  52+ 9013 ~            	ld bc, -1
  53+ 9013 ~
  54+ 9013 ~            DigitLoop:
  55+ 9013 ~            	ld	a, '0' - 1
  56+ 9013 ~            DivNrLoop:
  57+ 9013 ~            	inc	a			;increase reminder
  58+ 9013 ~            	add	hl, bc		;substract divizor
  59+ 9013 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 9013 ~            	sbc	hl, bc		;nope, restore
  61+ 9013 ~
  62+ 9013 ~            	ld (de), a
  63+ 9013 ~            	inc de
  64+ 9013 ~            	ret
  65+ 9013 ~
  66+ 9013 ~
  67+ 9013 ~            ;Input: HL = Dividend, C = Divisor
  68+ 9013 ~            ;Output: HL = Quotient, A = Remainder
  69+ 9013 ~            ;Warning: doesn't work with divisor >= $80
  70+ 9013 ~            Div:
  71+ 9013 ~            	IFUSED
  72+ 9013 ~            	xor a
  73+ 9013 ~            	ld b, 16
  74+ 9013 ~
  75+ 9013 ~            DivLoop:
  76+ 9013 ~            	add	hl,hl
  77+ 9013 ~            	rla
  78+ 9013 ~            	cp	c
  79+ 9013 ~            	jr	c, NoSub
  80+ 9013 ~            	sub	c
  81+ 9013 ~            	inc	l
  82+ 9013 ~            NoSub:
  83+ 9013 ~            	djnz DivLoop
  84+ 9013 ~
  85+ 9013 ~            	ret
  86+ 9013 ~            	ENDIF
  87+ 9013 ~
  88+ 9013 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 9013 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 9013 ~            Div2:
  91+ 9013 ~            	ld hl, 0
  92+ 9013 ~            	ld b, 16
  93+ 9013 ~            Div2Loop:
  94+ 9013 ~            	sll c		; unroll 16 times
  95+ 9013 ~            	rla			; ...
  96+ 9013 ~            	adc	hl,hl		; ...
  97+ 9013 ~            	sbc	hl,de		; ...
  98+ 9013 ~            	jr	nc,$+4		; ...
  99+ 9013 ~            	add	hl,de		; ...
 100+ 9013 ~            	dec	c		; ...
 101+ 9013 ~            	djnz Div2Loop
 102+ 9013 ~            	ret
 103+ 9013 ~
 104+ 9013 ~
 105+ 9013 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 9013 ~            ;Output: A:HL = Product
 107+ 9013 ~            Mul:
 108+ 9013 ~            	IFUSED
 109+ 9013 ~            	ld hl, 0
 110+ 9013 ~            	ld bc, $0700
 111+ 9013 ~
 112+ 9013 ~            	add	a, a		; optimised 1st iteration
 113+ 9013 ~            	jr	nc, MulLoop
 114+ 9013 ~            	ld	h, d
 115+ 9013 ~            	ld	l, e
 116+ 9013 ~
 117+ 9013 ~            MulLoop:
 118+ 9013 ~            	add	hl,hl
 119+ 9013 ~            	rla
 120+ 9013 ~            	jr	nc, NoAdd
 121+ 9013 ~            	add	hl,de
 122+ 9013 ~            	adc	a,c
 123+ 9013 ~            NoAdd:
 124+ 9013 ~            	djnz MulLoop
 125+ 9013 ~
 126+ 9013 ~            	ret
 127+ 9013 ~            	ENDIF
 128+ 9013 ~
 129+ 9013              	endif
# file closed: math.asm
1327  9013              	include "txtview.asm"
# file opened: txtview.asm
   1+ 9013              ; 	DEVICE ZXSPECTRUM48
   2+ 9013
   3+ 9013              LINE_CNT	EQU	23
   4+ 9013              COL_CNT		EQU	64
   5+ 9013
   6+ 9013              CHAR_CR		EQU	$0D
   7+ 9013              CHAR_LF		EQU	$0A
   8+ 9013              CHAR_TAB	EQU	$09
   9+ 9013              EOF_MARKER		EQU	$1A
  10+ 9013
  11+ 9013              COORDS		EQU	23728		;Coordinates
  12+ 9013
  13+ 9013
  14+ 9013              InitViewer:
  15+ 9013 22 5F 93     	ld		 (FileBegin), hl
  16+ 9016 09           	add		hl, bc
  17+ 9017              	;must filter any EOF chars, max 256 of them.
  18+ 9017 25           	dec		h
  19+ 9018 3E 1A        	ld		a, EOF_MARKER
  20+ 901A ED B1        	cpir
  21+ 901C 2B           	dec		hl
  22+ 901D 22 63 93     	ld		(FileEnd), hl
  23+ 9020 ED 5B 5F 93  	ld		de, (FileBegin)
  24+ 9024 B7           	or		a
  25+ 9025 ED 52        	sbc		hl, de
  26+ 9027 22 61 93     	ld		(FileLen), hl
  27+ 902A
  28+ 902A 3E 0D        	ld		a, CHAR_CR
  29+ 902C 77           	ld		(hl), a
  30+ 902D
  31+ 902D
  32+ 902D 21 04 02     	ld		hl, (2 << 8) | 4
  33+ 9030 22 09 5C     	ld		(23561), hl
  34+ 9033
  35+ 9033 21 00 00     	ld		hl, 0
  36+ 9036 22 B0 5C     	ld		(COORDS), hl
  37+ 9039
  38+ 9039 21 00 58     	ld		hl, 16384 + 6144
  39+ 903C 54           	ld		d, h
  40+ 903D 5D           	ld		e, l
  41+ 903E 13           	inc		de
  42+ 903F 01 FF 02     	ld		bc, 767
  43+ 9042 36 0F        	ld		(hl), (1 << 3) | 7
  44+ 9044 ED B0        	ldir
  45+ 9046
  46+ 9046 CD 65 92     	call	ScrollInit
  47+ 9049
  48+ 9049 11 00 00     	ld		de, 0
  49+ 904C ED 53 5A 93  	ld		(CurLine), de
  50+ 9050
  51+ 9050              	;prepare file progress %
  52+ 9050 2A 61 93     	ld		hl, (FileLen)
  53+ 9053 7C           	ld		a, h
  54+ 9054 4D           	ld		c, l
  55+ 9055 11 64 00     	ld		de, 100
  56+ 9058 CD B6 88     	call	Div2
  57+ 905B 67           	ld		h, a
  58+ 905C 69           	ld		l, c
  59+ 905D 22 65 93     	ld		(PROGR_PERC), hl
  60+ 9060
  61+ 9060 CD F4 91     	call	PrintMsg
  62+ 9063
  63+ 9063 DD 21 AD F7  	ld		ix, FileIdx	- 2
  64+ 9067 06 17        	ld		b, LINE_CNT
  65+ 9069 2A 5F 93     	ld		hl, (FileBegin)
  66+ 906C
  67+ 906C C9           	ret
  68+ 906D
  69+ 906D              PrintLoop:
  70+ 906D C5           	push	bc
  71+ 906E DD 23        		inc		ix
  72+ 9070 DD 23        		inc		ix
  73+ 9072 DD 75 00     		ld		(ix), l
  74+ 9075 DD 74 01     		ld		(ix + 1), h
  75+ 9078
  76+ 9078 CD 8F 91     		call	GetLine
  77+ 907B CD 61 91     		call	PrintLine
  78+ 907E
  79+ 907E ED 5B 5A 93  		ld		de, (CurLine)
  80+ 9082 13           		inc		de
  81+ 9083 ED 53 5A 93  		ld		(CurLine), de
  82+ 9087 C1           	pop		bc
  83+ 9088 CD 56 91     	call	CheckEnd
  84+ 908B 28 13        	jr		z, EOF
  85+ 908D
  86+ 908D 10 DE        	djnz	PrintLoop
  87+ 908F 18 17        	jr		PrintLoop2
  88+ 9091
  89+ 9091              GetKey:
  90+ 9091 76           	halt
  91+ 9092 FD CB 01 6E  	bit		5, (iy + 1);
  92+ 9096 28 F9        	jr		z, GetKey
  93+ 9098 FD CB 01 AE  	res		5, (iy + 1)
  94+ 909C FD 7E CE     	ld		a, (iy - $32)
  95+ 909F C9           	ret
  96+ 90A0
  97+ 90A0              EOF:
  98+ 90A0 CD 91 90     	call	GetKey
  99+ 90A3 FE 30        	cp		'0'
 100+ 90A5 20 F9        	jr		nz, EOF
 101+ 90A7 C9           	ret
 102+ 90A8
 103+ 90A8              PrintLoop2:
 104+ 90A8 CD F4 91     	call	PrintMsg
 105+ 90AB
 106+ 90AB CD 91 90     	call	GetKey
 107+ 90AE FE 30        	cp		'0'					;Exit on 0
 108+ 90B0 C8           	ret		z
 109+ 90B1
 110+ 90B1 FE 0A        	cp		KEY_DOWN
 111+ 90B3 28 5C        	jr		z, Down
 112+ 90B5
 113+ 90B5 FE 0B        	cp		KEY_UP
 114+ 90B7 28 2D        	jr		z, Up
 115+ 90B9
 116+ 90B9 FE 32        	cp		'2'
 117+ 90BB 20 EB        	jr		nz, PrintLoop2
 118+ 90BD
 119+ 90BD 3A 5E 93     	ld		a, (WrapFlag)
 120+ 90C0 EE 01        	xor		1
 121+ 90C2 32 5E 93     	ld		(WrapFlag), a
 122+ 90C5 B7           	or		a
 123+ 90C6 28 0F        	jr		z, NoWrap
 124+ 90C8
 125+ 90C8 11 4F 6E     	ld		de, 'nO'
 126+ 90CB ED 53 10 93  	ld		(MsgLineWrF), de
 127+ 90CF 3E 20        	ld		a, ' '
 128+ 90D1 32 12 93     	ld		(MsgLineWrF + 2), a
 129+ 90D4 C3 A8 90     	jp		PrintLoop2
 130+ 90D7
 131+ 90D7              NoWrap:
 132+ 90D7 11 4F 66     	ld		de, 'fO'
 133+ 90DA ED 53 10 93  	ld		(MsgLineWrF), de
 134+ 90DE 3E 66        	ld		a, 'f'
 135+ 90E0 32 12 93     	ld		(MsgLineWrF + 2), a
 136+ 90E3
 137+ 90E3 C3 A8 90     	jp		PrintLoop2
 138+ 90E6
 139+ 90E6
 140+ 90E6              Up:
 141+ 90E6 CD 46 91     	call	CheckBegin
 142+ 90E9 28 BD        	jr		z, PrintLoop2
 143+ 90EB
 144+ 90EB CD 93 92     	call	ScrollUp
 145+ 90EE
 146+ 90EE DD 2B        	dec		ix
 147+ 90F0 DD 2B        	dec		ix
 148+ 90F2 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 149+ 90F5 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 150+ 90F8 CD 8F 91     	call	GetLine						;extract previous line to display
 151+ 90FB
 152+ 90FB 11 00 00     	ld		de, 0
 153+ 90FE ED 53 B0 5C  	ld		(COORDS), de
 154+ 9102 CD 61 91     	call	PrintLine
 155+ 9105
 156+ 9105 2A 5A 93     	ld		hl, (CurLine)
 157+ 9108 2B           	dec		hl
 158+ 9109 22 5A 93     	ld		(CurLine), hl
 159+ 910C CD F4 91     	call	PrintMsg
 160+ 910F 18 97        	jr		PrintLoop2
 161+ 9111
 162+ 9111
 163+ 9111              Down:
 164+ 9111 DD 6E 00     	ld		l, (ix)
 165+ 9114 DD 66 01     	ld		h, (ix + 1)
 166+ 9117 CD 8F 91     	call	GetLine						;get next line pointer
 167+ 911A
 168+ 911A CD 56 91     	call	CheckEnd					;check if HL == file end
 169+ 911D 38 89        	jr		c, PrintLoop2
 170+ 911F
 171+ 911F DD 23        	inc		ix								;save next line pointer
 172+ 9121 DD 23        	inc		ix
 173+ 9123 DD 75 00     	ld		(ix), l
 174+ 9126 DD 74 01     	ld		(ix + 1), h
 175+ 9129
 176+ 9129 CD 8F 91     	call	GetLine						;extract next line in buffer for display
 177+ 912C
 178+ 912C CD 98 92     	call	ScrollDown
 179+ 912F
 180+ 912F 11 00 16     	ld		de, (LINE_CNT-1) << 8
 181+ 9132 ED 53 B0 5C  	ld		(COORDS), de
 182+ 9136 CD 61 91     	call	PrintLine
 183+ 9139
 184+ 9139 2A 5A 93     	ld		hl, (CurLine)
 185+ 913C 23           	inc		hl
 186+ 913D 22 5A 93     	ld		(CurLine), hl
 187+ 9140 CD F4 91     	call	PrintMsg
 188+ 9143
 189+ 9143 C3 A8 90     	jp		PrintLoop2
 190+ 9146
 191+ 9146
 192+ 9146              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 9146              ;check begining of buffer
 194+ 9146              CheckBegin:
 195+ 9146 E5           	push	hl
 196+ 9147 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 197+ 914A DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 198+ 914D ED 5B 5F 93  		ld		de, (FileBegin)
 199+ 9151 B7           		or		a
 200+ 9152 ED 52        		sbc		hl, de
 201+ 9154 E1           	pop		hl
 202+ 9155 C9           	ret
 203+ 9156
 204+ 9156              ;check end of buffer
 205+ 9156              CheckEnd:
 206+ 9156 E5           	push	hl
 207+ 9157 ED 5B 63 93  		ld		de, (FileEnd)
 208+ 915B EB           		ex		de, hl
 209+ 915C B7           		or		a
 210+ 915D ED 52        		sbc		hl, de
 211+ 915F E1           	pop		hl
 212+ 9160 C9           	ret
 213+ 9161
 214+ 9161              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 215+ 9161              ;Print a line
 216+ 9161              PrintLine:
 217+ 9161 11 1A 93     	ld		de, LineBuf
 218+ 9164 06 40        	ld		b, COL_CNT
 219+ 9166
 220+ 9166 CD 75 91     	call	PrintStrTxt
 221+ 9169
 222+ 9169              	;go to the next screen line
 223+ 9169 ED 5B B0 5C  	ld		de, (COORDS)
 224+ 916D 14           	inc		d
 225+ 916E 1E 00        	ld		e, 0
 226+ 9170 ED 53 B0 5C  	ld		(COORDS), de
 227+ 9174 C9           	ret
 228+ 9175
 229+ 9175              PrintStrTxt:
 230+ 9175 1A           	ld		a, (de)
 231+ 9176 13           	inc		de
 232+ 9177 D5           	push	de
 233+ 9178 32 81 5C     		ld		(CODE), a
 234+ 917B C5           		push	bc
 235+ 917C E5           			push	hl
 236+ 917D CD 8F 8F     				call	PrintChar
 237+ 9180 E1           			pop		hl
 238+ 9181 C1           		pop		bc
 239+ 9182
 240+ 9182 ED 5B B0 5C  		ld		de, (COORDS)
 241+ 9186 1C           		inc		e
 242+ 9187 ED 53 B0 5C  		ld		(COORDS), de
 243+ 918B D1           	pop		de
 244+ 918C 10 E7        	djnz	PrintStrTxt
 245+ 918E C9           	ret
 246+ 918F
 247+ 918F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 248+ 918F              ;Extract a line of text to fit exactly on a 64 screen line
 249+ 918F              ;IN:	HL = current file pointer
 250+ 918F              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 251+ 918F              GetLine:
 252+ 918F 11 1A 93     	ld		de, LineBuf
 253+ 9192 06 40        	ld		b, COL_CNT
 254+ 9194              GetLineLoop:
 255+ 9194 7E           	ld		a, (hl)
 256+ 9195 23           	inc		hl
 257+ 9196
 258+ 9196 FE 0D        	cp		CHAR_CR
 259+ 9198 28 29        	jr		z, GetLineSkip0A
 260+ 919A
 261+ 919A FE 0A        	cp		CHAR_LF
 262+ 919C 28 25        	jr		z, GetLineSkip0A
 263+ 919E
 264+ 919E FE 09        	cp		CHAR_TAB
 265+ 91A0 20 07        	jr		nz, GetLineNext
 266+ 91A2
 267+ 91A2 3E 20        	ld		a, ' '
 268+ 91A4 12           	ld		(de), a
 269+ 91A5 13           	inc		de
 270+ 91A6 05           	dec		b
 271+ 91A7 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 272+ 91A9
 273+ 91A9              GetLineNext:
 274+ 91A9 FE 20        	cp		' '
 275+ 91AB 38 06        	jr		c, NotValid
 276+ 91AD
 277+ 91AD FE 80        	cp		128
 278+ 91AF 30 02        	jr		nc, NotValid
 279+ 91B1 18 03        	jr		Valid
 280+ 91B3
 281+ 91B3              NotValid:
 282+ 91B3 CD 43 92     	call	ReplaceChars
 283+ 91B6
 284+ 91B6              Valid:
 285+ 91B6 12           	ld		(de), a
 286+ 91B7 13           	inc		de
 287+ 91B8 10 DA        	djnz	GetLineLoop
 288+ 91BA
 289+ 91BA              ;if line is exactly 64 char long, must skip the new line char(s)
 290+ 91BA              GetLineSkip0D:
 291+ 91BA 0E 00        	ld		c, 0
 292+ 91BC 3E 0D        	ld		a, CHAR_CR						;skip 0D
 293+ 91BE BE           	cp		(hl)
 294+ 91BF 20 02        	jr		nz, GetLineSkip0A
 295+ 91C1 23           	inc		hl
 296+ 91C2 0C           	inc		c
 297+ 91C3
 298+ 91C3              GetLineSkip0A:						;skip 0A
 299+ 91C3 3E 0A        	ld		a, CHAR_LF
 300+ 91C5 BE           	cp		(hl)
 301+ 91C6 20 02        	jr		nz, GetLineFill
 302+ 91C8 23           	inc		hl
 303+ 91C9 0C           	inc		c
 304+ 91CA
 305+ 91CA              GetLineFill:
 306+ 91CA 78           	ld		a, b
 307+ 91CB B7           	or		a
 308+ 91CC 20 1F        	jr		nz, GetLineFillLoop
 309+ 91CE
 310+ 91CE 79           	ld		a, c
 311+ 91CF B7           	or		a
 312+ 91D0 C0           	ret		nz
 313+ 91D1
 314+ 91D1              	;wrap or not
 315+ 91D1 3A 5E 93     	ld		a, (WrapFlag)
 316+ 91D4 B7           	or		a
 317+ 91D5 C0           	ret		nz
 318+ 91D6
 319+ 91D6 ED 5B 63 93  	ld		de, (FileEnd)
 320+ 91DA E5           	push	hl
 321+ 91DB EB           	ex		de, hl
 322+ 91DC B7           	or		a
 323+ 91DD ED 52        	sbc		hl, de
 324+ 91DF 44           	ld		b, h
 325+ 91E0 4D           	ld		c, l
 326+ 91E1 3E 0D        	ld		a, CHAR_CR
 327+ 91E3 E1           	pop		hl
 328+ 91E4 ED B1        	cpir
 329+ 91E6 C0           	ret		nz
 330+ 91E7 3E 0A        	ld		a, CHAR_LF
 331+ 91E9 BE           	cp		(hl)
 332+ 91EA C0           	ret		nz
 333+ 91EB 23           	inc		hl
 334+ 91EC
 335+ 91EC C9           	ret
 336+ 91ED
 337+ 91ED              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 338+ 91ED 3E 20        	ld		a, ' '
 339+ 91EF 12           	ld		(de), a
 340+ 91F0 13           	inc		de
 341+ 91F1 10 FA        	djnz	GetLineFillLoop
 342+ 91F3 C9           	ret
 343+ 91F4
 344+ 91F4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 345+ 91F4              PrintMsg:
 346+ 91F4 ED 5B B0 5C  	ld		de, (COORDS)
 347+ 91F8 D5           	push	de
 348+ 91F9 11 00 17     	ld		de, LINE_CNT<<8
 349+ 91FC ED 53 B0 5C  	ld		(COORDS), de
 350+ 9200
 351+ 9200              	;Get current file pointer
 352+ 9200 DD 6E 00     	ld		l, (ix)
 353+ 9203 DD 66 01     	ld		h, (ix + 1)
 354+ 9206 ED 4B 5F 93  	ld		bc, (FileBegin)
 355+ 920A B7           	or		a
 356+ 920B ED 42        	sbc		hl, bc
 357+ 920D
 358+ 920D              	;Divide by one percent length
 359+ 920D 7C           	ld		a, h
 360+ 920E 4D           	ld		c, l
 361+ 920F ED 5B 65 93  	ld		de, (PROGR_PERC)
 362+ 9213 CD B6 88     	call	Div2
 363+ 9216
 364+ 9216              	;Display %
 365+ 9216 11 F6 92     	ld		de, MsgLinePr
 366+ 9219 67           	ld		h, a
 367+ 921A 69           	ld		l, c
 368+ 921B CD 6D 88     	call	Byte2Txt
 369+ 921E
 370+ 921E
 371+ 921E 2A 5A 93     	ld		hl, (CurLine)
 372+ 9221 11 02 93     	ld		de, MsgLineNo
 373+ 9224 CD 62 88     	call	Word2Txt
 374+ 9227
 375+ 9227 11 ED 92     	ld		de, MsgLine
 376+ 922A 06 2D        	ld		b, MsgLineLen
 377+ 922C CD 75 91     	call	PrintStrTxt
 378+ 922F D1           	pop		de
 379+ 9230 ED 53 B0 5C  	ld		(COORDS), DE
 380+ 9234
 381+ 9234 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 382+ 9237 54           	ld		d, h
 383+ 9238 5D           	ld		e, l
 384+ 9239 13           	inc		de
 385+ 923A 3E 28        	ld		a, (5 << 3) | 0
 386+ 923C 77           	ld		(hl), a
 387+ 923D 01 1F 00     	ld		bc, 31
 388+ 9240 ED B0        	ldir
 389+ 9242 C9           	ret
 390+ 9243
 391+ 9243
 392+ 9243              ReplaceChars:
 393+ 9243 E5           	push	hl
 394+ 9244 C5           	push	bc
 395+ 9245 21 D3 92     		ld		hl, CharReplaceTbl
 396+ 9248 06 0D        		ld		b, CharReplTblLen
 397+ 924A              ReplaceSGCLoop:
 398+ 924A BE           		cp		(hl)
 399+ 924B 28 09        		jr		z, ReplaceMatch
 400+ 924D 23           		inc		hl
 401+ 924E 23           		inc		hl
 402+ 924F 10 F9        		djnz	ReplaceSGCLoop
 403+ 9251
 404+ 9251 3E 3F        		ld		a, '?'
 405+ 9253 C1           		pop		bc
 406+ 9254 E1           		pop		hl
 407+ 9255 C9           	ret
 408+ 9256
 409+ 9256              ReplaceMatch:
 410+ 9256 23           		inc		hl
 411+ 9257 7E           		ld		a, (hl)
 412+ 9258 C1           	pop		bc
 413+ 9259 E1           	pop		hl
 414+ 925A C9           	ret
 415+ 925B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 416+ 925B
 417+ 925B              	include	"scroll.asm"
# file opened: scroll.asm
   1++925B              ;Scrolling routines for UP/DOWN
   2++925B              ;They use 2 tables of pointers of screen cell rows.
   3++925B              ;One table has addresses in increasing order, for scroll down,
   4++925B              ;the other in decreasing order, for scroll up, so the same
   5++925B              ;scroll routine is used in both cases.
   6++925B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++925B
   8++925B              ; Char Down
   9++925B              ; Adjusts screen address HL to move eight pixels down on the display.
  10++925B              ; enter: HL = valid screen address
  11++925B              ; exit : HL = moves one character down
  12++925B              ; used : AF, HL
  13++925B              GetCellDown:
  14++925B 7D           	ld a,l
  15++925C C6 20        	add a,$20
  16++925E 6F           	ld l,a
  17++925F D0           	ret nc
  18++9260 7C           	ld a,h
  19++9261 C6 08        	add a,$08
  20++9263 67           	ld h,a
  21++9264 C9           	ret
  22++9265
  23++9265              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++9265              ;Fills the two tables with pointers.
  25++9265              ScrollInit:
  26++9265 21 00 40     	ld		hl, 16384
  27++9268 06 17        	ld		b, LINE_CNT
  28++926A              FillScrLinesLoop:
  29++926A              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++926A 22 00 5B     	ld		(SCRLinesDown), hl
  31++926D              	;inc. pointer in destination table (of pointers to lines)
  32++926D ED 5B 6B 92  	ld		de, (FillScrLinesPtr)
  33++9271 13           	inc		de
  34++9272 13           	inc		de
  35++9273 ED 53 6B 92  	ld		(FillScrLinesPtr), de
  36++9277 CD 5B 92     	call	GetCellDown
  37++927A 10 EE        	djnz	FillScrLinesLoop
  38++927C
  39++927C              	;now fill the table in reverse
  40++927C ED 73 90 92  	ld		(FillScrLinesSPStore), sp
  41++9280 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++9283 06 17        	ld		b, LINE_CNT
  43++9285 21 00 5B     	ld		hl, SCRLinesDown
  44++9288              FillScrLinesRev:
  45++9288 5E           	ld		e, (hl)
  46++9289 23           	inc		hl
  47++928A 56           	ld		d, (hl)
  48++928B 23           	inc		hl
  49++928C D5           	push	de
  50++928D 10 F9        	djnz	FillScrLinesRev
  51++928F              FillScrLinesSPStore	EQU	$ + 1
  52++928F 31 00 00     	ld		sp, 0
  53++9292 C9           	ret
  54++9293
  55++9293              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++9293              ScrollUp:
  57++9293 21 2E 5B     	ld		hl, SCRLinesUp
  58++9296 18 03        	jr		Scroll
  59++9298
  60++9298              ScrollDown:
  61++9298 21 00 5B     	ld		hl, SCRLinesDown
  62++929B
  63++929B              Scroll:
  64++929B 22 A9 92     	ld		(ScrollDownPtrDest), hl
  65++929E 23           	inc		hl
  66++929F 23           	inc		hl
  67++92A0 22 AC 92     	ld		(ScrollDownPtrSrc), hl
  68++92A3 0E 16        	ld		c, LINE_CNT - 1
  69++92A5
  70++92A5              ScrollDownLoop2:
  71++92A5 06 04        	ld		b, 4
  72++92A7              ScrollDownPtrDest	EQU	$ + 2
  73++92A7 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++92AB              ScrollDownPtrSrc	EQU	$ + 1
  75++92AB 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++92AE
  77++92AE              ScrollDownLoop:					;copy a single char line
  78++92AE C5           	push	bc
  79++92AF 01 20 00     	ld		bc, 32
  80++92B2 ED B0        	ldir
  81++92B4 2B           	dec		hl
  82++92B5 1B           	dec		de
  83++92B6 24           	inc		h
  84++92B7 14           	inc		d
  85++92B8 01 20 00     	ld		bc, 32
  86++92BB ED B8        	lddr
  87++92BD 23           	inc		hl
  88++92BE 13           	inc		de
  89++92BF 24           	inc		h
  90++92C0 14           	inc		d
  91++92C1 C1           	pop		bc
  92++92C2 10 EA        	djnz	ScrollDownLoop
  93++92C4
  94++92C4 0D           	dec		c
  95++92C5 C8           	ret		z
  96++92C6
  97++92C6 2A AC 92     	ld		hl, (ScrollDownPtrSrc)
  98++92C9 22 A9 92     	ld		(ScrollDownPtrDest), hl
  99++92CC 23           	inc		hl
 100++92CD 23           	inc		hl
 101++92CE 22 AC 92     	ld		(ScrollDownPtrSrc), hl
 102++92D1 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 418+ 92D3
 419+ 92D3              CharReplaceTbl:
 420+ 92D3 B3 80        	defb	179, 128
 421+ 92D5 B4 81        	defb	180, 129
 422+ 92D7 BF 82        	defb	191, 130
 423+ 92D9 C0 83        	defb	192, 131
 424+ 92DB C1 84        	defb	193, 132
 425+ 92DD C2 85        	defb	194, 133
 426+ 92DF C3 86        	defb	195, 134
 427+ 92E1 C4 87        	defb	196, 135
 428+ 92E3 C5 88        	defb	197, 136
 429+ 92E5 D9 89        	defb	217, 137
 430+ 92E7 DA 8A        	defb	218, 138
 431+ 92E9 DB 8B        	defb	219, 139
 432+ 92EB DC 8C        	defb	220, 140
 433+ 92ED              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 434+ 92ED
 435+ 92ED 50 72 6F 67  MsgLine		defb	'Progress:'
 435+ 92F1 72 65 73 73
 435+ 92F5 3A
 436+ 92F6 20 20 20 25  MsgLinePr	defb	'   %; '
 436+ 92FA 3B 20
 437+ 92FC 4C 69 6E 65  			defb	'Line: '
 437+ 9300 3A 20
 438+ 9302 20 20 20 20  MsgLineNo	defb	'     ; '
 438+ 9306 20 3B 20
 439+ 9309 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 439+ 930D 61 70 20
 440+ 9310 20 4F 6E     MsgLineWrF	defb	' On'
 441+ 9313 20 30 2D 45  			defb	' 0-Exit'
 441+ 9317 78 69 74
 442+ 931A              MsgLineLen	EQU		$ - MsgLine
 443+ 931A
 444+ 931A 20 20 20 20  LineBuf		defb	'                                                                '
 444+ 931E 20 20 20 20
 444+ 9322 20 20 20 20
 444+ 9326 20 20 20 20
 444+ 932A 20 20 20 20
 444+ 932E 20 20 20 20
 444+ 9332 20 20 20 20
 444+ 9336 20 20 20 20
 444+ 933A 20 20 20 20
 444+ 933E 20 20 20 20
 444+ 9342 20 20 20 20
 444+ 9346 20 20 20 20
 444+ 934A 20 20 20 20
 444+ 934E 20 20 20 20
 444+ 9352 20 20 20 20
 444+ 9356 20 20 20 20
 445+ 935A 00 00        CurLine		defw	0
 446+ 935C 00 00        MaxLine		defw	0
 447+ 935E 01           WrapFlag	defb	1
 448+ 935F 00 00        FileBegin	defw	0
 449+ 9361 00 00        FileLen		defw	0
 450+ 9363 00 00        FileEnd		defw	0
 451+ 9365 00 00        PROGR_PERC	defw	0
 452+ 9367
 453+ 9367              SCRLinesDown	EQU $5b00
 454+ 9367              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 455+ 9367              End:
 456+ 9367
# file closed: txtview.asm
1328  9367              	include "serial.asm"
# file opened: serial.asm
   1+ 9367              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 9367              ;They work with 19200 theoretical speed.
   3+ 9367              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 9367
   5+ 9367              CBAUD	EQU	10	; CBAUD for 19200
   6+ 9367              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 9367
   8+ 9367
   9+ 9367              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 9367              ; A=1 IF FRAMING ERROR
  11+ 9367              ; USES BC,D _DOES NOT USE E!_
  12+ 9367              SERRXI:
  12+ 9367
  13+ 9367 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 936A 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 936C D3 EF        	OUT	(0EFH),A
  16+ 936E
  17+ 936E              	; WAIT FOR START
  18+ 936E              SERWSL:
  19+ 936E 0B           	DEC	BC
  20+ 936F AF           	XOR	A
  21+ 9370 B8           	CP	B
  22+ 9371 20 03        	JR	NZ,SERWS
  23+ 9373 B9           	CP	C
  24+ 9374 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 9376 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 9378 CB 7F        	BIT	7,A
  27+ 937A 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 937C
  29+ 937C              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 937C              ; OF BIT 0
  31+ 937C 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 937E 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 9380
  34+ 9380              ; GET AND SHIFT BITS
  35+ 9380              SERRL:
  36+ 9380 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 9382 00           	NOP			; 4 (TIMING)
  38+ 9383 00           	NOP			; 4 (TIMING)
  39+ 9384 00           	NOP			; 4 (TIMING)
  40+ 9385 DB F7        	IN	A,(0F7H)	; 11
  41+ 9387 17           	RLA			; 4
  42+ 9388 CB 1A        	RR	D		; 8
  43+ 938A 06 0A        	LD	B,CBAUD		; 7
  44+ 938C 0D           	DEC	C		; 4
  45+ 938D 20 F1        	JR	NZ,SERRL	; 12
  46+ 938F
  47+ 938F              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 938F              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 938F              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 938F              ; IDLE UNTIL NEXT START BIT
  51+ 938F 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 9391 D3 EF        	OUT	(0EFH),A
  53+ 9393
  54+ 9393 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 9395              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 9395              SERWIL:
  57+ 9395 05           	DEC	B
  58+ 9396 28 0E        	JR	Z,SERRTF
  59+ 9398 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 939A CB 7F        	BIT	7,A
  61+ 939C 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 939E
  63+ 939E              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 939E 7A           	LD	A,D
  65+ 939F 2F           	CPL			; INVERT BITS
  66+ 93A0 57           	LD	D,A
  67+ 93A1 AF           	XOR	A		; 0 = SUCCESS
  68+ 93A2 C9           	RET
  69+ 93A3
  70+ 93A3              ; TIMEOUT
  71+ 93A3              SERRTO:
  72+ 93A3 3E FF        	LD	A,0FFH
  73+ 93A5 C9           	RET
  74+ 93A6
  75+ 93A6              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 93A6              SERRTF:
  77+ 93A6 3E 01        	LD	A,01H
  78+ 93A8 C9           	RET
  79+ 93A9
  80+ 93A9
  81+ 93A9
  82+ 93A9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 93A9              SERRB:
  83+ 93A9
  84+ 93A9              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 93A9              ; BITMAPPED OPTIONS IN E:
  86+ 93A9              ; XXXXXXIT
  87+ 93A9              ; I SET = leave Interrupts disabled at exit
  88+ 93A9              ; T SET = return after Timeout
  89+ 93A9              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 93A9              ; BC=NUMBER OF BYTES RECEIVED
  91+ 93A9              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 93A9 F3           	DI
  93+ 93AA C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 93AB              				; OF RECEIVED BYTES
  95+ 93AB
  96+ 93AB              SERRBL:
  97+ 93AB C5           	PUSH	BC
  98+ 93AC CD 67 93     	CALL	SERRXI
  99+ 93AF C1           	POP	BC
 100+ 93B0 B7           	OR	A
 101+ 93B1 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 93B3 72           	LD	(HL),D
 103+ 93B4 23           	INC	HL
 104+ 93B5 0B           	DEC	BC
 105+ 93B6 AF           	XOR	A
 106+ 93B7 B8           	CP	B
 107+ 93B8 20 F1        	JR	NZ,SERRBL
 108+ 93BA B9           	CP	C
 109+ 93BB 20 EE        	JR	NZ,SERRBL
 110+ 93BD              ; FULL RECEIVE
 111+ 93BD C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 93BE
 113+ 93BE              SERRBX:				; EXIT
 114+ 93BE CB 4B        	BIT	1,E
 115+ 93C0 C0           	RET	NZ
 116+ 93C1 FB           	EI
 117+ 93C2 C9           	RET
 118+ 93C3
 119+ 93C3              SERRBT:
 120+ 93C3 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 93C5 28 04        	JR	Z,SERRBC
 122+ 93C7 CB 43        	BIT	0,E
 123+ 93C9 28 E0        	JR	Z,SERRBL
 124+ 93CB
 125+ 93CB              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 93CB EB           	EX	DE,HL		; PRESERVE HL
 127+ 93CC E1           	POP	HL		; GET INITIAL COUNT
 128+ 93CD 37           	SCF
 129+ 93CE 3F           	CCF
 130+ 93CF ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 93D1 44           	LD	B,H
 132+ 93D2 4D           	LD	C,L		; BC = COUNT
 133+ 93D3 EB           	EX	DE,HL		; RESTORE HL
 134+ 93D4
 135+ 93D4 18 E8        	JR	SERRBX
 136+ 93D6
 137+ 93D6              SERRX:
 137+ 93D6
 138+ 93D6              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 93D6              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 93D6              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 93D6 F3           	DI
 142+ 93D7 CD 67 93     	CALL	SERRXI
 143+ 93DA FB           	EI
 144+ 93DB C9           	RET
 145+ 93DC
 146+ 93DC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 93DC              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 93DC              SERTB:
 148+ 93DC
 149+ 93DC 7E           	LD	A,(HL)
 150+ 93DD C5           	PUSH	BC
 151+ 93DE CD E9 93     		CALL	SERTX
 152+ 93E1 C1           	POP	BC
 153+ 93E2 23           	INC	HL
 154+ 93E3 0B           	DEC BC
 155+ 93E4 78           	LD	A, B
 156+ 93E5 B1           	OR	C
 157+ 93E6 20 F4        	JR	NZ, SERTB
 158+ 93E8 C9           	RET
 159+ 93E9
 160+ 93E9              ; SEND CHAR ROUTINE
 161+ 93E9              SERTX:
 161+ 93E9
 162+ 93E9 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 93EA 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 93EB F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 93EC 3E 01        	LD	A,01H
 166+ 93EE D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 93F0 1E 20        	LD	E,20H	; PORT MASK
 168+ 93F2 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 93F4 3E 01        	LD	A,1
 170+ 93F6 C3 FD 93     	JP	SBIT
 171+ 93F9
 172+ 93F9 AF           SHLOOP:	XOR	A		; 4
 173+ 93FA CB 3A        	SRL	D		; 8
 174+ 93FC 17           	RLA			; 4
 175+ 93FD              SBIT:
 176+ 93FD B3           	OR	E		; 4
 177+ 93FE D3 EF        	OUT	(0EFH),A	; 11
 178+ 9400 06 0A        	LD	B,CBAUD		; 7
 179+ 9402              SBITDL:
 180+ 9402 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 9404 00           	NOP			; 4 (TIMING)
 182+ 9405 0D           	DEC	C		; 4
 183+ 9406 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 9408              ; STOP BIT
 185+ 9408 3E 20        	LD	A,20H
 186+ 940A D3 EF        	OUT	(0EFH),A
 187+ 940C 06 0A        	LD	B,CBAUD
 188+ 940E 10 FE        STOPL:	DJNZ	STOPL
 189+ 9410 FB           	EI
 190+ 9411 C9           	RET
# file closed: serial.asm
1329  9412
1330  9412              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1331  9412 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1331  9416 6F 6D 6D 61
1331  941A 6E 64 65 72
1331  941E 20 31 2E B0
1332  9422 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1332  9426 67 65 2E 63
1332  942A 68 69 72 74
1332  942E 6F 61 63 E1
1333  9432 40 67 6D 61  VerMsg3			DEFM	'@gmail.com, 202', '3' + $80
1333  9436 69 6C 2E 63
1333  943A 6F 6D 2C 20
1333  943E 32 30 32 B3
1334  9442 53 79 73 74  MsgSysInf		DEFM	'System Info    ', ' ' + $80
1334  9446 65 6D 20 49
1334  944A 6E 66 6F 20
1334  944E 20 20 20 A0
1335  9452 4D 6F 64 65  MsgCompModel	DEFB	'Model: '
1335  9456 6C 3A 20
1336  9459 20 20 20 20  MsgCompModelName DEFB	'        ', ' ' | $80
1336  945D 20 20 20 20
1336  9461 A0
1337  9462 49 46 31 20  MsgIF1Version	DEFB	'IF1  : '
1337  9466 20 3A 20
1338  9469 20 20 20 20  MsgIF1Date		DEFB	'       ', ' ' | $80
1338  946D 20 20 20 A0
1339  9471 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1339  9475 20 49 6E 66
1339  9479 6F 20 20 20
1339  947D 20 20 20 A0
1340  9481 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1340  9485 20 49 6E 66
1340  9489 6F 20 20 20
1340  948D 20 20 20 A0
1341  9491 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1341  9495 61 67 65 73
1341  9499 20 20 20 20
1341  949D 20 20 20 A0
1342  94A1 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1342  94A5 20 32 2D 42
1342  94A9 3A 20 33 2D
1342  94AD 56 69 65 77
1342  94B1 20 34 2D 50
1342  94B5 72 6F 70 20
1342  94B9 35 2D 43 6F
1342  94BD 70 79 20 36
1342  94C1 2D 52 65 6E
1342  94C5 20 37 2D 41
1342  94C9 74 74 72 20
1342  94CD 38 2D 44 65
1342  94D1 6C 20 39 2D
1342  94D5 44 69 73 6B
1342  94D9 20 30 2D 45
1342  94DD 78 69 F4
1343  94E0 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1343  94E4 65 20 20 20
1343  94E8 3A 20 20 20
1343  94EC 20 20 20
1344  94EF C1           MsgDriveLet		DEFM	'A' + $80
1345  94F0 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1345  94F4 73 20 20 20
1345  94F8 3A
1346  94F9 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1346  94FD 31 32 B8
1347  9500 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1347  9504 20 4B 42 20
1347  9508 3A
1348  9509 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1348  950D 36 33 B6
1349  9510 45 72 72 6F  MsgErr			DEFM	'Error code '
1349  9514 72 20 63 6F
1349  9518 64 65 20
1350  951B 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1350  951F A0
1351  9520 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1351  9524 69 6E 67 20
1351  9528 50 72 6F 67
1351  952C 72 61 ED
1352  952F 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1352  9533 69 6E 67 20
1352  9537 53 43 52 45
1352  953B 45 4E A4
1353  953E 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1353  9542 69 6E 67 20
1353  9546 43 4F 44 45
1353  954A 20 28 21 A9
1354  954E 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1354  9552 20 4C 65 6E
1354  9556 3A
1355  9557 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1355  955B 30 20 CB
1356  955E 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1356  9562 69 62 20 20
1356  9566 3A
1357  9567 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1357  956B 48 49 C4
1358  956E 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1358  9572 54 79 70 65
1358  9576 3A
1359  9577 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1359  957B 20 20 20 20
1359  957F 20 A0
1360  9581 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1360  9585 72 61 ED
1361  9588 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1361  958C 73 20 A0
1362  958F 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1362  9593 45 4E A4
1363  9596 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1363  959A 41 72 F2
1364  959D 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1364  95A1 41 72 F2
1365  95A4 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1365  95A8 20 20 A0
1366  95AB 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1366  95AF 20 20 A0
1367  95B2 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1367  95B6 74 68 20 20
1367  95BA 3A
1368  95BB 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1368  95BF 35 20 C2
1369  95C2 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1369  95C6 74 20 20 20
1369  95CA 3A
1370  95CB 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1370  95CF 35 20 A0
1371  95D2 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1371  95D6 69 6E 67 20
1371  95DA 68 65 61 64
1371  95DE 65 F2
1372  95E0 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1372  95E4 20 20 20 20
1372  95E8 20 20 20 20
1372  95EC 20 20 20 A0
1373  95F0 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1373  95F4 66 69 6C 65
1373  95F8 20 28 79 2F
1373  95FC 6E 29 BF
1374  95FF 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1374  9603 52 2F 4F 20
1374  9607 28 79 2F 6E
1374  960B 29 BF
1375  960D 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1375  9611 48 49 44 20
1375  9615 28 79 2F 6E
1375  9619 29 BF
1376  961B 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1376  961F 2C 6E 6F 6E
1376  9623 65 3D 61 62
1376  9627 6F 72 74 BA
1377  962B 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1377  962F 69 6E 67 20
1377  9633 74 6F 20
1378  9636 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1379  9638 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1379  963C 20 6F 70 74
1379  9640 69 6F 6E 73
1379  9644 BA
1380  9645 30 2E 20 42  MsgMenu1		DEFM	'0. Bac', 'k' | $80
1380  9649 61 63 EB
1381  964C 31 2E 20 46  MsgMenu2		DEFM	'1. Format '
1381  9650 6F 72 6D 61
1381  9654 74 20
1382  9656 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1383  9658 32 2E 20 43  MsgMenu3		DEFM	'2. Copy '
1383  965C 6F 70 79 20
1384  9660 41 3A 2D 3E  MsgMenu3Drv1	DEFM	'A:->'
1385  9664 42 BA        MsgMenu3Drv2	DEFM	'B', ':' | $80
1386  9666 33 2E 20 43  MsgMenu4		DEFM	'3. Copy '
1386  966A 6F 70 79 20
1387  966E 41 3A 2D 3E  MsgMenu4Drv1	DEFM	'A:->CO', 'M' | $80
1387  9672 43 4F CD
1388  9675 34 2E 20 43  MsgMenu5		DEFM	'4. Copy COM->'
1388  9679 6F 70 79 20
1388  967D 43 4F 4D 2D
1388  9681 3E
1389  9682 41 BA        MsgMenu5Drv1	DEFM	'A', ':' | $80
1390  9684 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1390  9688 61 74 74 69
1390  968C 6E 67 20
1391  968F 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1392  9691 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1392  9695 62 6C 6F 63
1392  9699 6B 73 20 6C
1392  969D 65 66 F4
1393  96A0 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite (y/n)', '?' | $80
1393  96A4 77 72 69 74
1393  96A8 65 20 28 79
1393  96AC 2F 6E 29 BF
1394  96B0 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1394  96B4 20 6E 61 6D
1394  96B8 65 20 65 78
1394  96BC 69 73 74 F3
1395  96C0
1396  96C0              	IFNDEF	_ROM_FNT_
1397  96C0 ~            FontTable:
1398  96C0 ~            	incbin "cpmfnt.bin"
1399  96C0              	ENDIF
1400  96C0              EndCode:
1401  96C0
1402  96C0              ;Unalocated variables
1403  96C0              UnallocStart	EQU		EndCode
1404  96C0              FileCnt			EQU		UnallocStart			;File counter, 1B
1405  96C0              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1406  96C0              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1407  96C0              CursorAddr		EQU		SelFile + 1				;2 B
1408  96C0              AUCnt			EQU		CursorAddr + 2			;2 B
1409  96C0              SelFileCache	EQU		AUCnt + 2				;2 B
1410  96C0
1411  96C0              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1412  96C0              ;FS block list constants
1413  96C0              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1414  96C0              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1415  96C0              UsedBlockListSz		EQU 320 * 2 + 2							;640
1416  96C0
1417  96C0              	IFDEF	_ROM_FNT_
1418  96C0              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1419  96C0              DataBuf			EQU		FontTable + 872
1420  96C0              	ELSE
1421  96C0 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1422  96C0              	ENDIF
1423  96C0
1424  96C0              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1425  96C0
1426  96C0              CopyFileFCBSrc	EQU	DataBuf
1427  96C0              CopyFileFCBDst	EQU	DataBuf + 2
1428  96C0              CopyFileResRead	EQU DataBuf + 4
1429  96C0              CopyFileResWrite EQU DataBuf + 5
1430  96C0              CopyFileDMAAddr	EQU	DataBuf + 6
1431  96C0              CopyFileDMA		EQU	DataBuf + 8
1432  96C0
1433  96C0              ;File viewer constants
1434  96C0              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1435  96C0              ;File buffer size, without index
1436  96C0              FileIdxSize		EQU		2 * 1024
1437  96C0              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1438  96C0              ;Set a few KB aside for file indexing
1439  96C0              FileIdx			EQU		FileData + FileDataSize
1440  96C0
1441  96C0
1442  96C0              ;Copy buffer size, follows
1443  96C0              CopyDiskBuf			EQU DataBuf
1444  96C0
1445  96C0              ;We can use up to about 30KB free space if we load at address 24000.
1446  96C0              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1447  96C0              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1448  96C0              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1449  96C0              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1450  96C0              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1451  96C0
1452  96C0              	DISPLAY "DataBuf: ", /D,DataBuf
1453  96C0              	DISPLAY "BinSize: ", /D, EndCode - Start
1454  96C0              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1455  96C0              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x88B3   NoSub
0x88AC   DivLoop
0x5951   MAX_RAM_FREE
0x0800   FileIdxSize
0x0282   UsedBlockListSz
0x96C0   UnallocStart
0x96C0   EndCode
0x940E   STOPL
0x93F9   SHLOOP
0x93FD   SBIT
0x9402   SBITDL
0x93E9   SERTX
0x93D6 X SERRX
0x93CB   SERRBC
0x93BE   SERRBX
0x93C3   SERRBT
0x93AB   SERRBL
0x9398 X SERWI
0x93A6   SERRTF
0x9395   SERWIL
0x9380   SERRL
0x93A3   SERRTO
0x9376   SERWS
0x936E   SERWSL
0x9367   SERRXI
0x000A   CBAUD
0x9367 X End
0x935C X MaxLine
0x9309 X MsgLineWrap
0x92AE   ScrollDownLoop
0x92A5   ScrollDownLoop2
0x92AC   ScrollDownPtrSrc
0x92A9   ScrollDownPtrDest
0x929B   Scroll
0x9288   FillScrLinesRev
0x5B2E   SCRLinesUp
0x9290   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x926B   FillScrLinesPtr
0x926A   FillScrLinesLoop
0x925B   GetCellDown
0x9256   ReplaceMatch
0x924A   ReplaceSGCLoop
0x000D   CharReplTblLen
0x92D3   CharReplaceTbl
0x002D   MsgLineLen
0x92ED   MsgLine
0x9302   MsgLineNo
0x92F6   MsgLinePr
0x91ED   GetLineFillLoop
0x91CA   GetLineFill
0x9243   ReplaceChars
0x91B6   Valid
0x91B3   NotValid
0x91BA   GetLineSkip0D
0x91A9   GetLineNext
0x91C3   GetLineSkip0A
0x9194   GetLineLoop
0x9175   PrintStrTxt
0x931A   LineBuf
0x9298   ScrollDown
0x9293   ScrollUp
0x9146   CheckBegin
0x9310   MsgLineWrF
0x90D7   NoWrap
0x935E   WrapFlag
0x90E6   Up
0x9111   Down
0x9091   GetKey
0x90A8   PrintLoop2
0x90A0   EOF
0x9156   CheckEnd
0x9161   PrintLine
0x918F   GetLine
0xF7AF   FileIdx
0x91F4   PrintMsg
0x9365   PROGR_PERC
0x935A   CurLine
0x9265   ScrollInit
0x9361   FileLen
0x9363   FileEnd
0x935F   FileBegin
0x5CB0   COORDS
0x001A   EOF_MARKER
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x9000   ReadStrPrint
0x8FF0   ReadStrChar
0x8FD3   ReadStringLoop
0x8FC7   Store
0x8FC6   NoTurn
0x8FBB   PrintCharLine
0x8FA7 X PrintChar3
0x8F52   DrawCursorLoop
0x8F32   DrawVLinesLoop
0x8F45   PrintChar2
0x8F10   DrawUpLine
0x8F12   ChrParam
0x8F03 X DrawHLine
0x8EF2   DrawLineLoop
0x8EFF   LineDir
0x8EEF   StoreDir
0x8EED   VertDir
0x8EE4   DrawLine
0x8EE0   StrClr
0x8E93   GoodChar
0x900F   CurrScrAddr
0xA247   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x8E43   ReadFileSectionEnd
0x8E25   ReadFileSectionLoop
0x5100   FileDataSize
0xA5B4   CopyFileResWrite
0x8DCD   FileCopyWriteLoop
0x8DBC   FileCopyWrite
0xA5B3   CopyFileResRead
0x8D9E   FileCopyReadLoop
0xA5B7   CopyFileDMA
0xA5B5   CopyFileDMAAddr
0x0059   MAX_SECT_RAM
0x8D8F   FileCopyLoop
0xA5B1   CopyFileFCBDst
0x8DEB   CopyFileEnd
0xA5AF   CopyFileFCBSrc
0x8D37 X FileAttribSet
0x8CF0   GetFileSizeMul
0x8CF6   GetFileSizeEnd
0x8CEE   GetFileSizeOK
0x8CCE   BDOSSetDMA
0x8CC0   WriteFileBlock
0x8CBC   ReadFileBlock
0x8CB8   CloseFile
0x8CB4   OpenFile
0x8CB0   CreateFile
0x8CA6   DestroyChannel
0x8C90   CreateChannel
0x8C90 X BDOSGetCurrentDisk
0x8C90 X BDOSGetDiskRO
0x8C90 X BDOSMakeDiskRO
0x8CC4   BDOS
0x8C7F X RWTSResTmp
0x8C7E X RWTSResVolNo
0x8C7A X RWTSPrmTbl
0x8C78 X RWTSExtBuf
0x8C75 X RWTSSector
0x8C73 X RWTSVolNo
0x8C71 X RWTSBlockType
0x8C68   CopyMsg
0x8C5C   SearchMsgEnd
0x8C65   SaveMsg
0x8C53   IF1Paged
0x8C1C   IsFileHeaderValidLoop
0x8CD2   GetFileSize
0x8C00   ReadFileHeaderIsTextFile
0x8C19   IsFileHeaderValid
0x8C15   ReadHeaderEnd
0x8BBA   CacheNotFinished
0x8C84   BDOSInit
0x8C87   BDOSSelectDisk
0x8B57   FileReadLoop
0x8B4B X FileLoadHeader
0x8B5D   FileLoadNoHeader
0x8B6B   FileFree
0x8B27   MisMatch
0x8B1F   Compare
0x8B1D   StrCmp
0x8AD4   CopyDiskFromCOMLoop
0x93A9   SERRB
0x8A70   CopyDiskToCOMLoop
0x93DC   SERTB
0x8A29   CopyDiskLoopWriteLoop
0x8A03   CopyDiskLoopReadLoop
0xA5AF   CopyDiskBuf
0x89FC   CopyDiskLoopRead
0x000B   MAX_AU_RAM
0x9691   MsgBlocksLeft
0x89D9   CopyDiskLoop
0x9FC7   UsedBlockListBlk
0x8B83   WriteDiskSectors
0x89CE X WriteFSBlockLoop
0x89C5   WriteFSBlock
0x8B70   ReadDiskSectors
0x89C1 X ReadFSBlockLoop
0x89B8   ReadFSBlock
0x89AA   ReadUsedBlocksSkip
0x898D   ReadUsedBlocksLoop2
0x89AD   ReadUsedBlocksSkip2
0x897D   ReadUsedBlocksLoop
0x9FC5   UsedBlockListCnt
0x8960   ReadUsedBlocksList
0x8959   CheckAUEnd
0x8945   CheckAU
0x892E   FirstAU
0x8928   Track0
0x8913   AU2TS
0x8C7D   RWTSRes
0x88F7   WriteOneDiskSector
0x8C74   RWTSTrack
0x8C76   RWTSDMA
0x88EC   ReadOneDiskSector
0x8C71   RWTSParams
0x8C7C   RWTSCmd
0x88E0   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x001F X STR_MSG_IF1_LEN
0x0020 X STR_MSG_BASIC_LEN
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x88DA   NoAdd
0x88D4   MulLoop
0x88BB   Div2Loop
0x88B6   Div2
0x88A9   Div
0x88A0   DivNrLoop
0x889E   DigitLoop
0x888F   Byte2Txt_
0x8878   StrippLeading0
0x8883   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x9462   MsgIF1Version
0x9452   MsgCompModel
0x883C X GetIF1StringLoop
0x9469   MsgIF1Date
0x23F0   STR_MSG_IF1_91
0x8C21   IF1Call
0x884F   PrintCompInfo
0x27F0   STR_MSG_IF1_2000
0x8834   GetIF1String
0x881F   HC2000Store
0x881D   HC2000v1
0x882A   PrintComputerInfoIF1
0x8802   PrintComputerInfoSkip
0x87FB   PrintComputerInfoLoop
0x9459   MsgCompModelName
0x1539   STR_MSG_BASIC
0x9432   VerMsg3
0x9422   VerMsg2
0x9412   VerMsg1
0x87D5   DontInc
0x87C9   ReadAllHeadersEnd
0x87B4   AKey
0x8E53   KbdHit
0x8799   NextFile
0x95B2   MsgFileLen
0x956E   MsgFileType
0x95C2   MsgFileStart
0x8758   PrintStartStr
0x95CB   MsgFileStartN
0x95AB   MsgNA
0x874A   PrintStart
0x0007   HDR_LINE
0x8725   PrintByteStart
0x871D   PrintProgStart
0x95BB   MsgFileLenN
0x8703 X PrepFileLenText
0x95A4   MsgFileTypeText
0x9588   MsgFileTypeByte
0x958F   MsgFileTypeSCR
0x86E9   NotScr
0x86F4   CheckText
0x9596   MsgFileTypeChrA
0x86CC   CheckByte
0x0002   CHAR_TYPE
0x959D   MsgFileTypeNoA
0x86BD   CheckChrArr
0x0001   NUMB_TYPE
0x86FD   PrepFileLen
0x8776   MoveMsg
0x9577   MsgFileTypeN
0x9581   MsgFileTypePrg
0x86AE   CheckNoArr
0x000B   CACHE_FIRST_AU
0x872D   HeadNotRead
0x955E   MsgFileAttr
0x867F   AttrEnd
0x8673   NotSYS
0x865F   CheckSys
0x864D   NotRO
0x9567   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x873F   PrintStartNotRead
0x954E   MsgFileSzDsk
0x9557   MsgFileSzDskN
0x8609 X ViewFileEnd
0x906D   PrintLoop
0x9013   InitViewer
0xA6AF   FileData
0x8E06   ReadFileSection
0x8C27   LoadProgram
0x9520   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x952F   MsgLoadingSCR
0x0003   HDR_ADDR
0x8B6B   IF1FileLoadEnd
0x5B00   PRN_BUF
0x8B2A   IF1FileLoad
0x953E   MsgLoadingCODE
0x8597 X HandleFileCODE
0x85C0   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x85EE   HandleFileText
0x0003   BYTE_TYPE
0x85DE   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x8561   FindExtEnd
0x8BAF   FindCache
0x8570   GetFileNamesEnd
0x0009   HDR_SZ
0x853C   FindExt
0x000C   EXT_IDX
0x8931   CheckExtAlloc
0x8563   NextExt
0x0000   EXT_DEL_FLAG
0x84EB   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x84C8   DisplayFilenamesLoop
0x84AE   LineOK
0x5CB1   LINE
0x5CB0   COL
0x8F8F   PrintChar
0x5C81   CODE
0x8488   DispLoop
0x8486   DisplayFilename
0x8F57   MoveCursor
0x8AB7   CopyDiskFromCOM
0x8A5B   CopyDiskToCOM
0x846A   CheckExtra4
0x89D2   CopyDisk
0x8460   CheckExtra3
0x8902   FormatDisk
0x9684   MsgFormat
0x8457   CheckExtra2
0x8475   ExtraMenuExit
0x8423 X CheckKeyDiskMenuLoop
0x9675   MsgMenu5
0x9666   MsgMenu4
0x9658   MsgMenu3
0x964C   MsgMenu2
0x9645   MsgMenu1
0x83C4 X CheckKeyDiskMenu
0x9664   MsgMenu3Drv2
0x9682   MsgMenu5Drv1
0x966E   MsgMenu4Drv1
0x9660   MsgMenu3Drv1
0x968F   MsgFormatDrv
0x9656   MsgMenu2Drv
0x9638   MsgMenu0
0x8478   CheckKeyExit
0x8D16   ChangeFileAttrib
0x8386   AttrChange
0x960D   MsgSetSYS
0x836E   CheckSYS
0x95FF   MsgSetRO
0x8395   CheckKeyExtra
0x8CFC   DeleteFile
0x8340   DoFileDelete
0x95F0   MsgDelete
0x834D   CheckKeyAttrib
0x8D40   RenameFile
0x96B0   MsgFileExists
0x82F0   RenameFileNotExist
0x82FC   RenameCanceled
0x8FCD   ReadString
0x000B   NAMELEN
0x961B   MsgNewFileName
0x8315   CheckKeyDel
0x85EF   ViewFile
0x8294   CheckKeyRename
0x0001   DRIVE_B_CPM
0x8283   CheckKeyView
0x838F   SelectDrive
0x827A   CheckKeyDriveB
0x877C   ReadAllHeaders
0x8271   CheckKeyDriveA
0x8247   CopyFileOK
0x8D63   CopyFile
0x8247   CopyFileDontOverwrite
0x96A0   MsgFileOverwrite
0x8227   CopyFileDestNotExist
0x8D08   DoesFileExist
0x962B   MsgCopyFile
0x9636   MsgCopyFileDrv
0x8260   CheckKeyFileInfo
0x95E0   MsgClear
0x8BC0   ReadFileHeader
0x95D2   MsgReadingExt
0x81E3   CheckKeyCopy
0x8571   HandleFile
0x81B8   CheckKeyInfo
0x000D   KEY_ENTER
0x81AD   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x819C   CheckLeft
0x0009   KEY_RIGHT
0x8186   CheckRight
0x000B   KEY_UP
0x8480   MoveIt
0x8175   CheckUp
0x000A   KEY_DOWN
0x860A   DisplayFileInfo
0x96C7   SelFileCache
0x88C9   Mul
0x8146   CalcFileCache
0x9500   MsgFreeSpace
0x8862   Word2Txt
0x9509   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x96C5   AUCnt
0x94F0   MsgFilesCnt
0x94F9   MsgFilesCntNo
0x96C0   FileCnt
0x8E8C   PrintStr
0x94E0   MsgDrive
0x94EF   MsgDriveLet
0x8C40   SetFastKeys
0x8F4C   DrawCursor
0x0028   SCR_SEL_CLR
0x9491   MsgMessages
0x000A   LST_FILE_INFO
0x9481   MsgFileInf
0x0006   LST_DISK_INFO
0x9471   MsgDskInf
0x0000   LST_PROG_INFO
0x9442   MsgSysInf
0x94A1   BtnBar
0x0028   SCR_LBL_CLR
0x8F2D   DrawVLines
0x0084   CHR_DC
0x96C3   CursorAddr
0x9011   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x8E6C   ClrScr
0x5CB0   LineCol
0x0000   LST_FIRST_LINE
0x96C1   NameCol
0x0010   LST_FIRST_COL
0x96C2   SelFile
0xA5AF   DataBuf
0x8C4B   GetErrMsg
0x5C3A   ERRNR
0x8062   HCRunEnd
0x8157   ReadKeyLoop
0x80FD   DisplayDiskInfo
0x84B8   DisplayFilenames
0x87D8   PrintIntro
0x809A   InitUI
0x8053   HCRunMain
0x84D8   GetFileNames
0x8C72   RWTSDrive
0x0000   DRIVE_A_CPM
0x8E50   ReadChar
0x8EB4   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x0010   LST_LINE_MSG
0x9510   MsgErr
0x886D   Byte2Txt
0x951B   MsgErrCode
0x8050   HCRunCacheFiles
0x8B96   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0x96C9   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0xA5AF   TrackBuf
0x8012   HCRunInitDisk
0x8068   ErrorHandler
0x5C3D   ERRSP
0x88DD   IF1Init
0x8E56   InitFonts
0x8000   Start
