# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 32768
  12  8000
  13  8000              Start:
  14  8000              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  8000 CD E6 8D     		call InitFonts
  16  8003              	ENDIF
  17  8003 CD 6D 88     	call IF1Init
  18  8006
  19  8006              	;install error handler
  20  8006 2A 3D 5C     	ld		hl, (ERRSP)
  21  8009 E5           	push	hl
  22  800A 21 68 80     	ld		hl, ErrorHandler
  23  800D E5           	push	hl
  24  800E ED 73 3D 5C  	ld		(ERRSP), sp
  25  8012
  26  8012              HCRunInitDisk:
  27  8012              	;Set track buffer to del marker
  28  8012 21 20 A5     	ld		hl, TrackBuf
  29  8015 54           	ld		d, h
  30  8016 5D           	ld		e, l
  31  8017 13           	inc		de
  32  8018 01 00 10     	ld		bc, SPT*SECT_SZ
  33  801B 36 E5        	ld		(hl), DEL_MARKER
  34  801D ED B0        	ldir
  35  801F
  36  801F              	;Invalidate file cache
  37  801F 21 3A 96     	ld		hl, FileCache
  38  8022 54           	ld		d, h
  39  8023 5D           	ld		e, l
  40  8024 13           	inc		de
  41  8025 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  8028 36 00        	ld		(hl), 0
  43  802A ED B0        	ldir
  44  802C
  45  802C              	;main program
  46  802C CD 26 8B     	call 	ReadCatalogTrack
  47  802F B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  8030 28 1E        	jr		z, HCRunCacheFiles
  49  8032
  50  8032 6F           	ld		l, a
  51  8033 26 00        	ld		h, 0
  52  8035 11 8C 94     	ld		de, MsgErrCode
  53  8038 CD FD 87     	call	Byte2Txt
  54  803B 21 81 94     	ld		hl, MsgErr
  55  803E 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  56  8041 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  8043 CD 44 8E     	call	PrintStrClr
  58  8046 CD E0 8D     	call	ReadChar
  59  8049 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  804B 32 02 8C     	ld		(RWTSDrive), a
  61  804E 18 C2        	jr		HCRunInitDisk
  62  8050
  63  8050              HCRunCacheFiles:
  64  8050 CD D7 84     	call 	GetFileNames
  65  8053
  66  8053              HCRunMain:
  67  8053 CD 9A 80     	call 	InitUI
  68  8056 CD D7 87     	call	PrintIntro
  69  8059 CD B7 84     	call	DisplayFilenames
  70  805C CD FD 80     	call	DisplayDiskInfo
  71  805F C3 57 81     	jp		ReadKeyLoop
  72  8062
  73  8062              HCRunEnd:
  74  8062              	;restore error handler
  75  8062 E1           	pop		hl
  76  8063 E1           	pop		hl
  77  8064 22 3D 5C     	ld		(ERRSP), hl
  78  8067
  79  8067 C9           	ret
  80  8068
  81  8068              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  82  8068
  83  8068              ErrorHandler:
  84  8068 E1           	pop		hl
  85  8069 22 3D 5C     	ld		(ERRSP), hl
  86  806C
  87  806C 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  88  806F 6F           	ld		l, a
  89  8070 26 00        	ld		h, 0
  90  8072 11 8C 94     	ld		de, MsgErrCode
  91  8075 CD FD 87     	call	Byte2Txt
  92  8078 21 81 94     	ld		hl, MsgErr
  93  807B 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  94  807E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  95  8080 CD 44 8E     	call	PrintStrClr
  96  8083
  97  8083 3A 3A 5C     	ld		a, (ERRNR)
  98  8086 CD DB 8B     	call	GetErrMsg
  99  8089
 100  8089 21 20 A5     	ld		hl, DataBuf
 101  808C 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 102  808F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 103  8091 CD 44 8E     	call	PrintStrClr
 104  8094
 105  8094 CD E0 8D     	call	ReadChar
 106  8097 C3 00 80     	jp	Start
 107  809A
 108  809A
 109  809A
 110  809A
 111  809A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 112  809A
 113  809A              InitUI:
 114  809A AF           	xor		a
 115  809B 32 33 96     	ld		(SelFile), A
 116  809E 3E 11        	ld		a, LST_FIRST_COL + 1
 117  80A0 32 32 96     	ld		(NameCol), A
 118  80A3 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 119  80A6 ED 53 B0 5C  	ld		(LineCol), de
 120  80AA
 121  80AA CD FC 8D     	call	ClrScr
 122  80AD
 123  80AD 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 124  80B0 ED 4B A1 8F  	ld		bc, (CurrScrAttrAddr)
 125  80B4 09           	add		hl, bc
 126  80B5 22 34 96     	ld		(CursorAddr), hl
 127  80B8
 128  80B8 3E 84        	ld		a, CHR_DC
 129  80BA CD BD 8E     	call	DrawVLines
 130  80BD
 131  80BD 3E 28        	ld		a, SCR_LBL_CLR
 132  80BF 11 00 17     	ld		de, 23 << 8
 133  80C2 21 12 94     	ld		hl, BtnBar
 134  80C5 CD 44 8E     	call	PrintStrClr
 135  80C8
 136  80C8 3E 28        	ld		a, SCR_LBL_CLR
 137  80CA 21 D2 93     	ld		hl, MsgSysInf
 138  80CD 11 00 00     	ld		de, LST_PROG_INFO << 8
 139  80D0 CD 44 8E     	call	PrintStrClr
 140  80D3
 141  80D3 3E 28        	ld		a, SCR_LBL_CLR
 142  80D5 21 E2 93     	ld		hl, MsgDskInf
 143  80D8 11 00 04     	ld		de, LST_DISK_INFO << 8
 144  80DB CD 44 8E     	call	PrintStrClr
 145  80DE
 146  80DE 3E 28        	ld		a, SCR_LBL_CLR
 147  80E0 21 F2 93     	ld		hl, MsgFileInf
 148  80E3 11 00 08     	ld		de, LST_FILE_INFO << 8
 149  80E6 CD 44 8E     	call	PrintStrClr
 150  80E9
 151  80E9 3E 28        	ld		a, SCR_LBL_CLR
 152  80EB 21 02 94     	ld		hl, MsgMessages
 153  80EE 11 00 0E     	ld		de, LST_LINE_MSG << 8
 154  80F1 CD 44 8E     	call	PrintStrClr
 155  80F4
 156  80F4 3E 28        	ld		a, SCR_SEL_CLR
 157  80F6 CD DC 8E     	call	DrawCursor
 158  80F9
 159  80F9 CD D0 8B     	call	SetFastKeys
 160  80FC
 161  80FC C9           	ret
 162  80FD
 163  80FD
 164  80FD              DisplayDiskInfo:
 165  80FD 3A 02 8C     	ld		a, (RWTSDrive)
 166  8100 C6 C1        	add		'A' + $80
 167  8102 32 60 94     	ld		(MsgDriveLet), a
 168  8105 21 51 94     	ld		hl, MsgDrive
 169  8108 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 170  810B CD 1C 8E     	call	PrintStr
 171  810E
 172  810E 3A 31 96     	ld		a, (FileCnt)
 173  8111 6F           	ld		l, a
 174  8112 26 00        	ld		h, 0
 175  8114 11 6A 94     	ld		de, MsgFilesCntNo
 176  8117 CD FD 87     	call	Byte2Txt
 177  811A 21 61 94     	ld		hl, MsgFilesCnt
 178  811D 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 179  8120 CD 1C 8E     	call	PrintStr
 180  8123
 181  8123 ED 5B 36 96  	ld		de, (AUCnt)
 182  8127 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 183  812A B7           	or		a
 184  812B ED 52        	sbc		hl, de
 185  812D CB 15        	rl		l								;*2, 2K/AU
 186  812F CB 14        	rl		h
 187  8131 11 78 94     	ld		de, MsgFreeSpaceNo - 2
 188  8134 CD F2 87     	call	Word2Txt
 189  8137 3E 3A        	ld		a, ':'
 190  8139 32 79 94     	ld		(MsgFreeSpaceNo -1), a
 191  813C 21 71 94     	ld		hl, MsgFreeSpace
 192  813F 11 00 07     	ld		de, LST_DISK_INFO + 3 << 8
 193  8142 CD 1C 8E     	call	PrintStr
 194  8145
 195  8145 C9           	ret
 196  8146
 197  8146              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198  8146
 199  8146              CalcFileCache:
 200  8146 3A 33 96     	ld		a, (SelFile)
 201  8149 11 19 00     	ld		de, CACHE_SZ
 202  814C CD 59 88     	call	Mul
 203  814F 01 3A 96     	ld		bc, FileCache
 204  8152 09           	add		hl, bc					;HL = file AU cnt
 205  8153 22 38 96     	ld		(SelFileCache), hl
 206  8156 C9           	ret
 207  8157
 208  8157              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209  8157
 210  8157
 211  8157              ReadKeyLoop:
 212  8157 CD 46 81     	call	CalcFileCache
 213  815A CD 09 86     	call	DisplayFileInfo
 214  815D
 215  815D CD E0 8D     	call	ReadChar
 216  8160
 217  8160 FE 0A        	cp		KEY_DOWN
 218  8162 20 11        	jr		nz, CheckUp
 219  8164
 220  8164 3A 31 96     	ld		a, (FileCnt)
 221  8167 47           	ld		b, a
 222  8168 3A 33 96     	ld		a, (SelFile)
 223  816B 3C           	inc		a
 224  816C B8           	cp		b
 225  816D 30 E8        	jr		nc, ReadKeyLoop
 226  816F 32 33 96     	ld		(SelFile), a
 227  8172 C3 7F 84     	jp		MoveIt
 228  8175
 229  8175              CheckUp:
 230  8175 FE 0B        	cp		KEY_UP
 231  8177 20 0D        	jr		nz, CheckRight
 232  8179
 233  8179 3A 33 96     	ld		a, (SelFile)
 234  817C B7           	or		a
 235  817D 28 D8        	jr		z, ReadKeyLoop
 236  817F
 237  817F 3D           	dec		a
 238  8180 32 33 96     	ld		(SelFile), a
 239  8183 C3 7F 84     	jp		MoveIt
 240  8186
 241  8186              CheckRight:
 242  8186 FE 09        	cp		KEY_RIGHT
 243  8188 20 12        	jr		nz, CheckLeft
 244  818A
 245  818A 3A 31 96     	ld		a, (FileCnt)
 246  818D 47           	ld		b, a
 247  818E 3A 33 96     	ld		a, (SelFile)
 248  8191 C6 17        	add		LST_LINES_CNT
 249  8193 B8           	cp		b
 250  8194 30 C1        	jr		nc, ReadKeyLoop
 251  8196
 252  8196 32 33 96     	ld		(SelFile), a
 253  8199 C3 7F 84     	jp		MoveIt
 254  819C
 255  819C              CheckLeft:
 256  819C FE 08        	cp		KEY_LEFT
 257  819E 20 0D        	jr		nz, CheckEnter
 258  81A0
 259  81A0 3A 33 96     	ld		a, (SelFile)
 260  81A3 D6 17        	sub		LST_LINES_CNT
 261  81A5 38 B0        	jr		c, ReadKeyLoop
 262  81A7
 263  81A7 32 33 96     	ld		(SelFile), a
 264  81AA C3 7F 84     	jp		MoveIt
 265  81AD
 266  81AD              CheckEnter:
 267  81AD FE 0D        	cp		KEY_ENTER
 268  81AF C2 B8 81     	jp		nz, CheckKeyInfo
 269  81B2 CD 70 85     	call	HandleFile
 270  81B5 C3 53 80     	jp		HCRunMain
 271  81B8
 272  81B8              CheckKeyInfo:
 273  81B8 FE 34        	cp		'4'
 274  81BA 20 27        	jr		nz, CheckKeyCopy
 275  81BC
 276  81BC 3A 31 96     	ld		a, (FileCnt)
 277  81BF B7           	or		a
 278  81C0 CA 57 81     	jp		z, ReadKeyLoop
 279  81C3
 280  81C3 DD 2A 38 96  	ld		ix, (SelFileCache)
 281  81C7 21 43 95     	ld		hl, MsgReadingExt
 282  81CA 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 283  81CD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 284  81CF CD 44 8E     	call	PrintStrClr
 285  81D2 CD 50 8B     	call	ReadFileHeader
 286  81D5 21 51 95     	ld		hl, MsgClear
 287  81D8 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
 288  81DB 3E 0F        	ld		a, SCR_DEF_CLR
 289  81DD CD 44 8E     	call	PrintStrClr
 290  81E0 C3 57 81     	jp		ReadKeyLoop
 291  81E3
 292  81E3              CheckKeyCopy:
 293  81E3 FE 35        	cp		'5'
 294  81E5 C2 5F 82     	jp		nz, CheckKeyFileInfo
 295  81E8
 296  81E8 3A 31 96     	ld		a, (FileCnt)
 297  81EB B7           	or		a
 298  81EC CA 57 81     	jp		z, ReadKeyLoop
 299  81EF
 300  81EF 3A 02 8C     	ld 		a, (RWTSDrive)
 301  81F2 3C           	inc		a
 302  81F3 EE 03        	xor		%11
 303  81F5 C6 40        	add		'A' - 1
 304  81F7 32 A7 95     	ld		(MsgCopyFileDrv), a
 305  81FA 21 9C 95     	ld		hl, MsgCopyFile
 306  81FD 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 307  8200 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 308  8202 CD 44 8E     	call	PrintStrClr
 309  8205
 310  8205 2A 38 96     	ld		hl, (SelFileCache)
 311  8208 3A 02 8C     	ld 		a, (RWTSDrive)
 312  820B 3C           	inc		a
 313  820C EE 03        	xor		%11
 314  820E CD 98 8C     	call	DoesFileExist
 315  8211 3C           	inc		a
 316  8212 28 12        	jr		z, CopyFileDestNotExist
 317  8214
 318  8214 21 11 96     	ld		hl, MsgFileOverwrite
 319  8217 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 320  821A 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 321  821C CD 44 8E     	call	PrintStrClr
 322  821F CD E0 8D     	call	ReadChar
 323  8222 FE 79        	cp		'y'
 324  8224 20 20        	jr		nz, CopyFileDontOverwrite
 325  8226
 326  8226              CopyFileDestNotExist:
 327  8226 2A 38 96     	ld		hl, (SelFileCache)
 328  8229 CD F3 8C     	call	CopyFile
 329  822C B7           	or		a
 330  822D 28 17        	jr		z, CopyFileOK
 331  822F
 332  822F 6F           	ld		l, a
 333  8230 26 00        	ld		h, 0
 334  8232 11 8C 94     	ld		de, MsgErrCode
 335  8235 CD FD 87     	call	Byte2Txt
 336  8238 21 81 94     	ld		hl, MsgErr
 337  823B 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 338  823E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 339  8240 CD 44 8E     	call	PrintStrClr
 340  8243 CD E0 8D     	call	ReadChar
 341  8246
 342  8246              CopyFileOK:
 343  8246              CopyFileDontOverwrite:
 344  8246 21 51 95     	ld		hl, MsgClear
 345  8249 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
 346  824C 3E 0F        	ld		a, SCR_DEF_CLR
 347  824E CD 44 8E     	call	PrintStrClr
 348  8251 21 51 95     	ld		hl, MsgClear
 349  8254 11 00 10     	ld		de, LST_LINE_MSG+2 << 8
 350  8257 3E 0F        	ld		a, SCR_DEF_CLR
 351  8259 CD 44 8E     	call	PrintStrClr
 352  825C C3 12 80     	jp		HCRunInitDisk
 353  825F
 354  825F              CheckKeyFileInfo:
 355  825F FE 20        	cp		' '
 356  8261 20 0D        	jr		nz, CheckKeyDriveA
 357  8263
 358  8263 3A 31 96     	ld		a, (FileCnt)
 359  8266 B7           	or		a
 360  8267 CA 57 81     	jp		z, ReadKeyLoop
 361  826A
 362  826A CD 7B 87     	call	ReadAllHeaders
 363  826D C3 57 81     	jp		ReadKeyLoop
 364  8270
 365  8270              CheckKeyDriveA:
 366  8270 FE 31        	cp		'1'
 367  8272 20 05        	jr		nz, CheckKeyDriveB
 368  8274 3E 00        	ld		a, DRIVE_A_CPM
 369  8276 C3 8E 83     	jp		SelectDrive
 370  8279
 371  8279              CheckKeyDriveB:
 372  8279 FE 32        	cp		'2'
 373  827B 20 05        	jr		nz, CheckKeyView
 374  827D 3E 01        	ld		a, DRIVE_B_CPM
 375  827F C3 8E 83     	jp		SelectDrive
 376  8282
 377  8282              CheckKeyView:
 378  8282 FE 33        	cp		'3'
 379  8284 20 0D        	jr		nz, CheckKeyRename
 380  8286
 381  8286 3A 31 96     	ld		a, (FileCnt)
 382  8289 B7           	or		a
 383  828A CA 57 81     	jp		z, ReadKeyLoop
 384  828D
 385  828D CD EE 85     	call	ViewFile
 386  8290 C3 53 80     	jp		HCRunMain
 387  8293
 388  8293              CheckKeyRename:
 389  8293 FE 36        	cp		'6'
 390  8295 20 7D        	jr		nz, CheckKeyDel
 391  8297
 392  8297 3A 31 96     	ld		a, (FileCnt)
 393  829A B7           	or		a
 394  829B CA 57 81     	jp		z, ReadKeyLoop
 395  829E
 396  829E 21 8C 95     	ld		hl, MsgNewFileName
 397  82A1 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 398  82A4 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 399  82A6 CD 44 8E     	call	PrintStrClr
 400  82A9
 401  82A9 21 51 95     	ld		hl, MsgClear
 402  82AC 11 20 A5     	ld		de, DataBuf
 403  82AF 01 0B 00     	ld		bc, NAMELEN
 404  82B2 ED B0        	ldir
 405  82B4 3E A0        	ld		a, $80 | ' '
 406  82B6 12           	ld		(de), a
 407  82B7 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 408  82BA 21 20 A5     	ld		hl, DataBuf
 409  82BD CD 1C 8E     	call	PrintStr
 410  82C0
 411  82C0 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 412  82C3 01 0B 00     	ld		bc, NAMELEN
 413  82C6 CD 5D 8F     	call	ReadString
 414  82C9
 415  82C9 11 20 A5     	ld		de, DataBuf
 416  82CC 1A           	ld		a, (de)
 417  82CD FE 20        	cp		' '					;If starting with space, input was canceled.
 418  82CF CA FB 82     	jp		z, RenameCanceled
 419  82D2
 420  82D2              	;Check if new name doesn't exist already. Cancel if so.
 421  82D2 21 20 A5     	ld		hl, DataBuf
 422  82D5 3A 02 8C     	ld 		a, (RWTSDrive)
 423  82D8 3C           	inc		a
 424  82D9 CD 98 8C     	call	DoesFileExist
 425  82DC 3C           	inc		a
 426  82DD 28 10        	jr		z, RenameFileNotExist
 427  82DF
 428  82DF 21 21 96     	ld		hl, MsgFileExists
 429  82E2 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 430  82E5 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 431  82E7 CD 44 8E     	call	PrintStrClr
 432  82EA CD E0 8D     	call	ReadChar
 433  82ED 18 0C        	jr		RenameCanceled
 434  82EF
 435  82EF              RenameFileNotExist:
 436  82EF 11 20 A5     	ld		de, DataBuf
 437  82F2 2A 38 96     	ld		hl, (SelFileCache)
 438  82F5 CD D0 8C     	call	RenameFile
 439  82F8 C3 12 80     	jp		HCRunInitDisk
 440  82FB
 441  82FB              RenameCanceled:
 442  82FB 21 51 95     	ld		hl, MsgClear
 443  82FE 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 444  8301 3E 0F        	ld		a, SCR_DEF_CLR
 445  8303 CD 44 8E     	call	PrintStrClr
 446  8306 21 51 95     	ld		hl, MsgClear
 447  8309 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 448  830C 3E 0F        	ld		a, SCR_DEF_CLR
 449  830E CD 44 8E     	call	PrintStrClr
 450  8311 C3 57 81     	jp		ReadKeyLoop
 451  8314
 452  8314              CheckKeyDel:
 453  8314 FE 38        	cp		'8'
 454  8316 20 34        	jr		nz, CheckKeyAttrib
 455  8318
 456  8318 3A 31 96     	ld		a, (FileCnt)
 457  831B B7           	or		a
 458  831C CA 57 81     	jp		z, ReadKeyLoop
 459  831F
 460  831F 21 61 95     	ld		hl, MsgDelete
 461  8322 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 462  8325 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 463  8327 CD 44 8E     	call	PrintStrClr
 464  832A CD E0 8D     	call	ReadChar
 465  832D FE 79        	cp		'y'
 466  832F 28 0E        	jr		z, DoFileDelete
 467  8331 21 51 95     	ld		hl, MsgClear
 468  8334 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 469  8337 3E 0F        	ld		a, SCR_DEF_CLR
 470  8339 CD 44 8E     	call	PrintStrClr
 471  833C C3 57 81     	jp		ReadKeyLoop
 472  833F              DoFileDelete:
 473  833F 2A 38 96     	ld		hl, (SelFileCache)
 474  8342 3A 02 8C     	ld 		a, (RWTSDrive)
 475  8345 3C           	inc		a					;Convert to BASIC drive number: 1,2
 476  8346 CD 8C 8C     	call	DeleteFile
 477  8349 C3 12 80     	jp		HCRunInitDisk
 478  834C
 479  834C              CheckKeyAttrib:
 480  834C FE 37        	cp		'7'
 481  834E 20 44        	jr		nz, CheckKeyExtra
 482  8350
 483  8350 3A 31 96     	ld		a, (FileCnt)
 484  8353 B7           	or		a
 485  8354 CA 57 81     	jp		z, ReadKeyLoop
 486  8357
 487  8357 21 70 95     	ld		hl, MsgSetRO
 488  835A 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 489  835D 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 490  835F CD 44 8E     	call	PrintStrClr
 491  8362 CD E0 8D     	call	ReadChar
 492  8365 1E 00        	ld		e, 0
 493  8367 FE 79        	cp		'y'
 494  8369 20 02        	jr		nz, CheckSYS
 495  836B 1E 01        	ld		e, 1
 496  836D
 497  836D              CheckSYS:
 498  836D D5           	push	de
 499  836E 21 7E 95     		ld		hl, MsgSetSYS
 500  8371 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 501  8374 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 502  8376 CD 44 8E     		call	PrintStrClr
 503  8379 CD E0 8D     		call	ReadChar
 504  837C FE 79        		cp		'y'
 505  837E D1           	pop		de
 506  837F 20 04        	jr		nz, AttrChange
 507  8381 3E 02        	ld		a, %10
 508  8383 B3           	or		e
 509  8384 5F           	ld		e, a
 510  8385
 511  8385              AttrChange:
 512  8385 2A 38 96     	ld		hl, (SelFileCache)
 513  8388 CD A6 8C     	call	ChangeFileAttrib
 514  838B C3 12 80     	jp		HCRunInitDisk
 515  838E
 516  838E              SelectDrive:
 517  838E 32 02 8C     	ld 		(RWTSDrive), a
 518  8391 C3 12 80     	jp		HCRunInitDisk
 519  8394
 520  8394              CheckKeyExtra:
 521  8394 FE 39        	cp		'9'
 522  8396 C2 77 84     	jp		nz, CheckKeyExit
 523  8399
 524  8399 21 A9 95     	ld		hl, MsgMenu0
 525  839C 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 526  839F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 527  83A1 CD 44 8E     	call	PrintStrClr
 528  83A4 3A 02 8C     	ld		a, (RWTSDrive)
 529  83A7 C6 41        	add		'A'
 530  83A9 32 C7 95     	ld		(MsgMenu2Drv), a
 531  83AC 32 00 96     	ld		(MsgFormatDrv), a
 532  83AF 32 D1 95     	ld		(MsgMenu3Drv1), a
 533  83B2 32 DF 95     	ld		(MsgMenu4Drv1), a
 534  83B5 32 F3 95     	ld		(MsgMenu5Drv1), a
 535  83B8 3A 02 8C     	ld		a, (RWTSDrive)
 536  83BB 3C           	inc		a
 537  83BC EE 03        	xor		%11
 538  83BE C6 40        	add		'A'-1
 539  83C0 32 D5 95     	ld		(MsgMenu3Drv2), a
 540  83C3
 541  83C3              CheckKeyDiskMenu:
 542  83C3 21 B6 95     	ld		hl, MsgMenu1
 543  83C6 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 544  83C9 CD 1C 8E     	call	PrintStr
 545  83CC 21 BD 95     	ld		hl, MsgMenu2
 546  83CF 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 547  83D2 CD 1C 8E     	call	PrintStr
 548  83D5 21 C9 95     	ld		hl, MsgMenu3
 549  83D8 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 550  83DB CD 1C 8E     	call	PrintStr
 551  83DE 21 D7 95     	ld		hl, MsgMenu4
 552  83E1 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 553  83E4 CD 1C 8E     	call	PrintStr
 554  83E7 21 E6 95     	ld		hl, MsgMenu5
 555  83EA 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 556  83ED CD 1C 8E     	call	PrintStr
 557  83F0 CD E0 8D     	call	ReadChar
 558  83F3 F5           	push	af
 559  83F4
 560  83F4 21 51 95     		ld		hl, MsgClear
 561  83F7 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 562  83FA CD 1C 8E     		call	PrintStr
 563  83FD 21 51 95     		ld		hl, MsgClear
 564  8400 11 00 11     		ld		de, LST_LINE_MSG + 3 << 8
 565  8403 CD 1C 8E     		call	PrintStr
 566  8406 21 51 95     		ld		hl, MsgClear
 567  8409 11 00 12     		ld		de, LST_LINE_MSG + 4 << 8
 568  840C CD 1C 8E     		call	PrintStr
 569  840F 21 51 95     		ld		hl, MsgClear
 570  8412 11 00 13     		ld		de, LST_LINE_MSG + 5 << 8
 571  8415 CD 1C 8E     		call	PrintStr
 572  8418 21 51 95     		ld		hl, MsgClear
 573  841B 11 00 14     		ld		de, LST_LINE_MSG + 6 << 8
 574  841E CD 1C 8E     		call	PrintStr
 575  8421
 576  8421 F1           	pop		af
 577  8422
 578  8422              CheckKeyDiskMenuLoop:
 579  8422 FE 30        	cp		'0'
 580  8424 28 4E        	jr		z, ExtraMenuExit
 581  8426
 582  8426 FE 31        	cp		'1'
 583  8428 20 2C        	jr		nz, CheckExtra2
 584  842A
 585  842A 21 F5 95     	ld		hl, MsgFormat
 586  842D 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 587  8430 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 588  8432 CD 44 8E     	call	PrintStrClr
 589  8435
 590  8435 CD 92 88     	call	FormatDisk
 591  8438 B7           	or		a
 592  8439 CA 12 80     	jp		z, HCRunInitDisk
 593  843C
 594  843C              	;Display error for format
 595  843C 6F           	ld		l, a
 596  843D 26 00        	ld		h, 0
 597  843F 11 8C 94     	ld		de, MsgErrCode
 598  8442 CD FD 87     	call	Byte2Txt
 599  8445 21 81 94     	ld		hl, MsgErr
 600  8448 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 601  844B 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 602  844D CD 44 8E     	call	PrintStrClr
 603  8450 CD E0 8D     	call	ReadChar
 604  8453 C3 12 80     	jp		HCRunInitDisk
 605  8456
 606  8456              CheckExtra2:
 607  8456 FE 32        	cp		'2'
 608  8458 20 05        	jr		nz, CheckExtra3
 609  845A
 610  845A CD 62 89     	call	CopyDisk
 611  845D 18 15        	jr		ExtraMenuExit
 612  845F
 613  845F              CheckExtra3:
 614  845F FE 33        	cp		'3'
 615  8461 C2 69 84     	jp		nz, CheckExtra4
 616  8464 CD EB 89     	call	CopyDiskToCOM
 617  8467 18 0B        	jr		ExtraMenuExit
 618  8469
 619  8469              CheckExtra4:
 620  8469 FE 34        	cp		'4'
 621  846B C2 74 84     	jp		nz, ExtraMenuExit
 622  846E CD 47 8A     	call	CopyDiskFromCOM
 623  8471 C3 12 80     	jp		HCRunInitDisk
 624  8474
 625  8474              ExtraMenuExit:
 626  8474 C3 53 80     	jp		HCRunMain
 627  8477
 628  8477              CheckKeyExit:
 629  8477 FE 30        	cp		'0'
 630  8479 C2 57 81     	jp		nz, ReadKeyLoop
 631  847C C3 62 80     	jp		HCRunEnd
 632  847F
 633  847F              MoveIt:
 634  847F CD E7 8E     	call 	MoveCursor
 635  8482 C3 57 81     	jp		ReadKeyLoop
 636  8485
 637  8485              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638  8485
 639  8485
 640  8485              DisplayFilename:
 641  8485 06 0B        	LD		B, NAMELEN
 642  8487              DispLoop:
 643  8487 1A           	LD		A, (DE)
 644  8488
 645  8488              	;clear bit 7
 646  8488 CB BF        	RES 	7, A
 647  848A 32 81 5C     	LD		(CODE), A
 648  848D
 649  848D 13           	INC		DE
 650  848E D5           	PUSH	DE
 651  848F C5           	PUSH	BC
 652  8490 CD 1F 8F     		CALL	PrintChar
 653  8493 C1           	POP		BC
 654  8494 D1           	POP 	DE
 655  8495
 656  8495 21 B0 5C     	LD		HL, COL
 657  8498 34           	INC		(HL)
 658  8499 10 EC        	DJNZ	DispLoop
 659  849B              	;now a name is displayed
 660  849B
 661  849B              	;check bounds
 662  849B 3A B1 5C     	LD		A, (LINE)
 663  849E 3C           	INC		A
 664  849F FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 665  84A1 38 0A        	JR		C, LineOK
 666  84A3
 667  84A3              	;set names column to the next one
 668  84A3 3A 32 96     	LD		A, (NameCol)
 669  84A6 C6 0C        	ADD		NAMELEN + 1
 670  84A8 32 32 96     	LD		(NameCol), A
 671  84AB
 672  84AB 3E 00        	LD		A, LST_FIRST_LINE
 673  84AD              LineOK:
 674  84AD 32 B1 5C     	LD		(LINE), A
 675  84B0
 676  84B0 3A 32 96     	LD		A, (NameCol)
 677  84B3 32 B0 5C     	LD		(COL), A
 678  84B6
 679  84B6 C9           	RET
 680  84B7
 681  84B7
 682  84B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 683  84B7
 684  84B7              DisplayFilenames:
 685  84B7 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 686  84BA ED 53 B0 5C  	ld		(LineCol), de
 687  84BE
 688  84BE 11 3A 96     	ld		de, FileCache
 689  84C1 3A 31 96     	ld		a, (FileCnt)
 690  84C4 B7           	or		a
 691  84C5 C8           	ret		z
 692  84C6
 693  84C6 47           	ld		b,	a
 694  84C7
 695  84C7              DisplayFilenamesLoop:
 696  84C7 C5           	push	bc
 697  84C8 D5           		push	de
 698  84C9 CD 85 84     			call	DisplayFilename
 699  84CC D1           		pop		de
 700  84CD EB           		ex		de, hl
 701  84CE 01 19 00     		ld		bc, CACHE_SZ
 702  84D1 09           		add		hl, bc
 703  84D2 EB           		ex		de, hl
 704  84D3 C1           	pop		bc
 705  84D4 10 F1        	djnz	DisplayFilenamesLoop
 706  84D6
 707  84D6 C9           	ret
 708  84D7
 709  84D7
 710  84D7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 711  84D7              ;Selects only valid filenames (not deleted and only from first extension)
 712  84D7              GetFileNames:
 713  84D7 DD 21 20 A5  	ld		ix, TrackBuf
 714  84DB 11 3A 96     	ld		de, FileCache
 715  84DE 06 80        	ld		b, MAX_EXT_CNT
 716  84E0 AF           	xor		a
 717  84E1 32 31 96     	ld		(FileCnt), a
 718  84E4 21 36 96     	ld		hl, AUCnt
 719  84E7 77           	ld		(hl), a
 720  84E8 23           	inc		hl
 721  84E9 77           	ld		(hl), a
 722  84EA
 723  84EA              StoreFilenamesLoop:
 724  84EA AF           	xor a
 725  84EB DD BE 00     	cp (ix + EXT_DEL_FLAG)
 726  84EE C2 62 85     	jp nz, NextExt
 727  84F1
 728  84F1              	;count AU
 729  84F1 D9           	exx
 730  84F2 E5           	push hl
 731  84F3 CD C1 88     		call CheckExtAlloc
 732  84F6 EB           		ex de, hl			;save first AU no.
 733  84F7
 734  84F7              		;store disk alocated AU count
 735  84F7 2A 36 96     		ld hl, (AUCnt)
 736  84FA 48           		ld c, b
 737  84FB 06 00        		ld b, 0
 738  84FD 09           		add hl, bc
 739  84FE 22 36 96     		ld (AUCnt), hl
 740  8501 E1           	pop hl
 741  8502 D9           	exx
 742  8503
 743  8503 AF           	xor	a
 744  8504 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 745  8507 20 32        	jr nz, FindExt
 746  8509
 747  8509 DD E5        	push ix
 748  850B E1           	pop hl
 749  850C 23           	inc hl					;skip del flag
 750  850D
 751  850D C5           	push bc
 752  850E ~            		/*
 753  850E ~            		push de
 754  850E ~            			push hl
 755  850E ~            				ex de, hl
 756  850E ~            				call DisplayFilename
 757  850E ~            			pop hl
 758  850E ~            		pop de
 759  850E ~            		*/
 760  850E 01 0B 00     		ld bc, NAMELEN
 761  8511 ED B0        		ldir				;save file name
 762  8513
 763  8513 D9           		exx
 764  8514 D5           		push 	de			;de = first AU
 765  8515 D9           		exx
 766  8516 E1           		pop		hl
 767  8517 EB           		ex		de, hl
 768  8518 73 23 72 2B  		ld		(hl), de	;save first AU
 769  851C
 770  851C 23           		inc		hl
 771  851D 23           		inc		hl
 772  851E
 773  851E D9           		exx					;save AU cnt for file
 774  851F C5           		push	bc
 775  8520 D9           		exx
 776  8521 C1           		pop		bc
 777  8522 71 23 70 2B  		ld		(hl), bc
 778  8526
 779  8526 23           		inc		hl
 780  8527 23           		inc		hl
 781  8528
 782  8528              		;xor		a			;make flag 0 to signal that header is not read yet
 783  8528              		;ld		(hl), a
 784  8528
 785  8528 01 0A 00     		ld		bc, HDR_SZ + 1
 786  852B 09           		add		hl, bc
 787  852C
 788  852C EB           		ex		de, hl
 789  852D C1           	pop bc
 790  852E
 791  852E
 792  852E 3A 31 96     	ld 		a, (FileCnt)			;inc file counter
 793  8531 3C           	inc		a
 794  8532 32 31 96     	ld 		(FileCnt), a
 795  8535 FE 5C        	cp		LST_MAX_FILES
 796  8537 38 29        	jr		c, NextExt
 797  8539 18 34        	jr		GetFileNamesEnd
 798  853B
 799  853B
 800  853B              FindExt:					;BC' = AU cnt for this ext
 801  853B C5           	push	bc
 802  853C D5           		push 	de
 803  853D DD E5        			push	ix
 804  853F D1           			pop		de
 805  8540 13           			inc		de				;DE = name to find
 806  8541
 807  8541 21 3A 96     			ld		hl, FileCache
 808  8544 3A 31 96     			ld		a, (FileCnt)
 809  8547 4F           			ld		c, a
 810  8548 CD 3F 8B     			call	FindCache
 811  854B 20 13        			jr		nz, FindExtEnd
 812  854D
 813  854D 01 0D 00     			ld		bc, CACHE_AU_CNT
 814  8550 09           			add		hl, bc
 815  8551 D9           			exx
 816  8552 C5           			push	bc
 817  8553 D9           			exx
 818  8554 C1           			pop		bc
 819  8555
 820  8555 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 821  8559 EB           			ex		de, hl
 822  855A 09           			add		hl, bc
 823  855B EB           			ex		de, hl
 824  855C 73 23 72 2B  			ld		(hl), de
 825  8560              FindExtEnd:
 826  8560 D1           		pop		de
 827  8561 C1           	pop		bc
 828  8562
 829  8562              NextExt:
 830  8562 C5           	push bc
 831  8563 01 20 00     		ld bc, EXT_SZ
 832  8566 DD 09        		add ix, bc
 833  8568 C1           	pop	bc
 834  8569
 835  8569 05           	dec	b
 836  856A 78           	ld	a, b
 837  856B B7           	or	a
 838  856C C2 EA 84     	jp	nz, StoreFilenamesLoop
 839  856F              GetFileNamesEnd:
 840  856F C9           	ret
 841  8570
 842  8570              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 843  8570
 844  8570              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 845  8570              ;IN: HL = file name
 846  8570              HandleFile:
 847  8570              	;Make HL point to the selected file
 848  8570 DD 2A 38 96  	ld		ix, (SelFileCache)
 849  8574 DD E5        	push	ix
 850  8576 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 851  8579 B7           		or		a
 852  857A CC 50 8B     		call	z, ReadFileHeader
 853  857D
 854  857D DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 855  8580 FE 00        		cp		PROG_TYPE
 856  8582 28 59        		jr		z, HandleFileProg
 857  8584
 858  8584 FE 03        		cp		BYTE_TYPE
 859  8586 20 65        		jr		nz, HandleFileText
 860  8588
 861  8588 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 861  858C 66 12
 862  858E 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 863  8591 19           		add		hl, de
 864  8592 7C           		ld		a, h
 865  8593 B5           		or		l
 866  8594 28 29        		jr		z, HandleFileSCR
 867  8596
 868  8596
 869  8596              HandleFileCODE:
 870  8596 21 AF 94     		ld		hl, MsgLoadingCODE
 871  8599 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 872  859C 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 873  859E CD 44 8E     		call	PrintStrClr
 874  85A1
 875  85A1              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 876  85A1 21 BA 8A     		ld		hl, IF1FileLoad
 877  85A4 11 00 5B     		ld		de, PRN_BUF
 878  85A7 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 879  85AA ED B0        		ldir
 880  85AC 3E C9        		ld		a, $C9
 881  85AE 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 882  85AF
 883  85AF E1           	pop		hl
 884  85B0 ED 5B 23 A5  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 885  85B4 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 886  85B5 C1           	pop		bc						;2nd, 3rd call for error handler
 887  85B6 C1           	pop		bc
 888  85B7 ED 43 3D 5C  	ld		(ERRSP), bc
 889  85BB D5           	push	de						;push CODE address to return to = start of CODE block
 890  85BC C3 00 5B     	jp		PRN_BUF
 891  85BF
 892  85BF
 893  85BF
 894  85BF
 895  85BF              HandleFileSCR:
 896  85BF 21 A0 94     		ld		hl, MsgLoadingSCR
 897  85C2 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 898  85C5 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 899  85C7 CD 44 8E     		call	PrintStrClr
 900  85CA
 901  85CA E1           	pop		hl
 902  85CB
 903  85CB              	IFDEF _ROM_FNT_
 904  85CB              		;Load to alternate SCREEN$ memory
 905  85CB 11 00 C0     		ld		de, HC_VID_BANK1
 906  85CE CD BA 8A     		call	IF1FileLoad
 907  85D1
 908  85D1              		;Set display to alternate SCREEN$ memory
 909  85D1 3E 08        		ld		a, HC_CFG_VID_C000
 910  85D3 D3 7E        		out 	(HC_CFG_PORT), a
 911  85D5 CD E0 8D     		call	ReadChar
 912  85D8
 913  85D8              		;Set back to regular SCREEN$ memory
 914  85D8 3E 00        		ld		a, HC_CFG_VID_4000
 915  85DA D3 7E        		out 	(HC_CFG_PORT), a
 916  85DC              	ELSE
 917  85DC ~            		ld		de, HC_VID_BANK0
 918  85DC ~            		call	IF1FileLoad
 919  85DC ~            		call	ReadChar
 920  85DC              	ENDIF
 921  85DC
 922  85DC C9           	ret
 923  85DD
 924  85DD              HandleFileProg:
 925  85DD 21 91 94     		ld		hl, MsgLoadingPrg
 926  85E0 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 927  85E3 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 928  85E5 CD 44 8E     		call	PrintStrClr
 929  85E8 E1           	pop		hl
 930  85E9 CD B7 8B     	call	LoadProgram
 931  85EC C9           	ret
 932  85ED
 933  85ED
 934  85ED              HandleFileText:
 935  85ED E1           	pop		hl
 936  85EE
 937  85EE
 938  85EE              ViewFile:
 939  85EE CD FC 8D     	call	ClrScr
 940  85F1 2A 38 96     	ld		hl, (SelFileCache)
 941  85F4 CD 96 8D     	call	ReadFileSection					;DE = last address read
 942  85F7 21 20 A6     	ld		hl, FileData
 943  85FA              	;Calculate size of read buffer
 944  85FA E5           	push	hl
 945  85FB EB           		ex	de, hl
 946  85FC B7           		or	a
 947  85FD ED 52        		sbc	hl, de
 948  85FF 44           		ld	b, h
 949  8600 4B           		ld	c, e
 950  8601 E1           	pop		hl
 951  8602 CD A3 8F     	call	InitViewer
 952  8605 CD FD 8F     	call	PrintLoop
 953  8608              ViewFileEnd:
 954  8608 C9           	ret
 955  8609
 956  8609              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 957  8609
 958  8609
 959  8609              DisplayFileInfo:
 960  8609 2A 38 96     	ld		hl, (SelFileCache)
 961  860C E5           	push	hl
 962  860D              		;disk size - at least 2KB ==1  AU
 963  860D 01 0D 00     		ld		bc, CACHE_AU_CNT
 964  8610 09           		add		hl, bc
 965  8611 5E 23 56 2B  		ld		de, (hl)
 966  8615 EB           		ex		de, hl
 967  8616              		;*2, since one block (AU) is 2KB.
 968  8616 CB 15        		rl	l
 969  8618 CB 14        		rl	h
 970  861A
 971  861A 11 C8 94     		ld		de, MsgFileSzDskN
 972  861D CD F2 87     		call	Word2Txt
 973  8620 21 BF 94     		ld		hl, MsgFileSzDsk
 974  8623 11 00 09     		ld		de, LST_FILE_INFO + 1 << 8
 975  8626 CD 1C 8E     		call	PrintStr
 976  8629 E1           	pop		hl
 977  862A E5           	push	hl
 978  862B              		;attributes
 979  862B 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 980  862E 09           		add		hl, bc
 981  862F EB           		ex		de, hl
 982  8630 21 D8 94     		ld		hl, MsgFileAttrN
 983  8633 1A           		ld		a, (de)
 984  8634 E6 80        		and		%10000000
 985  8636 28 14        		jr		z, NotRO
 986  8638
 987  8638 01 52 2F     		ld		bc, '/R'
 988  863B 71 23 70 2B  		ld		(hl), bc
 989  863F 23           		inc		hl
 990  8640 23           		inc		hl
 991  8641 01 4F 2C     		ld		bc, ',O'
 992  8644 71 23 70 2B  		ld		(hl), bc
 993  8648 23           		inc		hl
 994  8649 23           		inc		hl
 995  864A 18 12        		jr		CheckSys
 996  864C              NotRO:
 997  864C 01 2D 2D     		ld		bc, '--'
 998  864F 71 23 70 2B  		ld		(hl), bc
 999  8653 23           		inc		hl
1000  8654 23           		inc		hl
1001  8655 01 2D 2C     		ld		bc, ',-'
1002  8658 71 23 70 2B  		ld		(hl), bc
1003  865C 23           		inc		hl
1004  865D 23           		inc		hl
1005  865E
1006  865E              CheckSys:
1007  865E 13           		inc		de
1008  865F 1A           		ld		a, (de)
1009  8660 E6 80        		and		%10000000
1010  8662 28 0E        		jr		z, NotSYS
1011  8664
1012  8664 01 48 49     		ld		bc, 'IH'
1013  8667 71 23 70 2B  		ld		(hl), bc
1014  866B 23           		inc		hl
1015  866C 23           		inc		hl
1016  866D 3E C4        		ld		a, 'D' + $80
1017  866F 77           		ld		(hl), a
1018  8670 18 0C        		jr		AttrEnd
1019  8672              NotSYS:
1020  8672 01 2D 2D     		ld		bc, '--'
1021  8675 71 23 70 2B  		ld		(hl), bc
1022  8679 23           		inc		hl
1023  867A 23           		inc		hl
1024  867B 3E AD        		ld		a, '-' + $80
1025  867D 77           		ld		(hl), a
1026  867E              AttrEnd:
1027  867E 11 00 0A     		ld		de, LST_FILE_INFO + 2 << 8
1028  8681 21 CF 94     		ld		hl, MsgFileAttr
1029  8684 CD 1C 8E     		call	PrintStr
1030  8687 DD E1        	pop		ix
1031  8689 DD E5        	push	ix
1032  868B DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1033  868E B7           		or		a
1034  868F CA 2C 87             jp		z, HeadNotRead
1035  8692
1036  8692 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1037  8695 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1038  8698 CA 2C 87             jp		z, HeadNotRead
1039  869B
1040  869B DD 7E 10     		ld		a, (ix + CACHE_HDR)
1041  869E FE 00        		cp		PROG_TYPE
1042  86A0 20 0B        		jr		nz, CheckNoArr
1043  86A2
1044  86A2 21 F2 94     		ld		hl, MsgFileTypePrg
1045  86A5 11 E8 94     		ld		de, MsgFileTypeN
1046  86A8 CD 75 87     		call	MoveMsg
1047  86AB 18 4F        		jr		PrepFileLen
1048  86AD
1049  86AD              CheckNoArr:
1050  86AD FE 01        		cp		NUMB_TYPE
1051  86AF 20 0B        		jr		nz, CheckChrArr
1052  86B1
1053  86B1 21 0E 95     		ld		hl, MsgFileTypeNoA
1054  86B4 11 E8 94     		ld		de, MsgFileTypeN
1055  86B7 CD 75 87     		call	MoveMsg
1056  86BA 18 40        		jr		PrepFileLen
1057  86BC
1058  86BC              CheckChrArr:
1059  86BC FE 02        		cp		CHAR_TYPE
1060  86BE 20 0B        		jr		nz, CheckByte
1061  86C0
1062  86C0 21 07 95     		ld		hl, MsgFileTypeChrA
1063  86C3 11 E8 94     		ld		de, MsgFileTypeN
1064  86C6 CD 75 87     		call	MoveMsg
1065  86C9 18 31        		jr		PrepFileLen
1066  86CB
1067  86CB              CheckByte:
1068  86CB FE 03        		cp		BYTE_TYPE
1069  86CD 20 24        		jr		nz, CheckText
1070  86CF
1071  86CF DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1071  86D3 66 12
1072  86D5 01 00 E5     		ld		bc, -SCR_LEN
1073  86D8 09           		add		hl, bc
1074  86D9 7C           		ld		a, h
1075  86DA B5           		or		l
1076  86DB 20 0B        		jr		nz, NotScr
1077  86DD
1078  86DD 21 00 95     		ld		hl, MsgFileTypeSCR
1079  86E0 11 E8 94     		ld		de, MsgFileTypeN
1080  86E3 CD 75 87     		call	MoveMsg
1081  86E6 18 14        		jr		PrepFileLen
1082  86E8              NotScr:
1083  86E8 21 F9 94     		ld		hl, MsgFileTypeByte
1084  86EB 11 E8 94     		ld		de, MsgFileTypeN
1085  86EE CD 75 87     		call	MoveMsg
1086  86F1 18 09        		jr		PrepFileLen
1087  86F3
1088  86F3              CheckText:
1089  86F3 21 15 95     		ld		hl, MsgFileTypeText
1090  86F6 11 E8 94     		ld		de, MsgFileTypeN
1091  86F9 CD 75 87     		call	MoveMsg
1092  86FC
1093  86FC              PrepFileLen:
1094  86FC              		;File len
1095  86FC DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1096  86FF DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1097  8702              PrepFileLenText:
1098  8702 11 2C 95     		ld		de, MsgFileLenN
1099  8705 CD F2 87     		call	Word2Txt
1100  8708 26 C2        		ld		h, 'B' | $80
1101  870A 2E 20        		ld		l, ' '
1102  870C 22 31 95     		ld		(MsgFileLenN + 5), hl
1103  870F
1104  870F DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1105  8712 FE 00        		cp		PROG_TYPE
1106  8714 28 06        		jr		z, PrintProgStart
1107  8716
1108  8716 FE 03        		cp		BYTE_TYPE
1109  8718 28 0A        		jr		z, PrintByteStart
1110  871A
1111  871A 18 22        		jr		PrintStartNotRead
1112  871C
1113  871C              PrintProgStart:
1114  871C DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1115  871F DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1116  8722 18 25        		jr		PrintStart
1117  8724
1118  8724              PrintByteStart:
1119  8724 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1120  8727 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1121  872A 18 1D        		jr		PrintStart
1122  872C
1123  872C              HeadNotRead:
1124  872C 21 1C 95             ld        hl, MsgNA
1125  872F 11 E8 94             ld        de, MsgFileTypeN
1126  8732 CD 75 87             call    MoveMsg
1127  8735
1128  8735 21 1C 95     		ld		hl, MsgNA
1129  8738 11 2C 95     		ld		de, MsgFileLenN
1130  873B CD 75 87     		call	MoveMsg
1131  873E
1132  873E              PrintStartNotRead:
1133  873E 21 1C 95     		ld		hl, MsgNA
1134  8741 11 3C 95     		ld		de, MsgFileStartN
1135  8744 CD 75 87     		call	MoveMsg
1136  8747 18 0E        		jr		PrintStartStr
1137  8749
1138  8749              PrintStart:
1139  8749 1E 20        	ld		e, ' '
1140  874B 16 A0        	ld		d, ' ' | $80
1141  874D ED 53 41 95  	ld		(MsgFileStartN + 5), de
1142  8751 11 3C 95     	ld		de, MsgFileStartN
1143  8754 CD F2 87     	call	Word2Txt
1144  8757              PrintStartStr:
1145  8757 11 00 0C     	ld		de, LST_FILE_INFO + 4 << 8
1146  875A 21 33 95     	ld		hl, MsgFileStart
1147  875D CD 1C 8E     	call	PrintStr
1148  8760
1149  8760 DD E1        	pop		ix
1150  8762 11 00 0B     	ld		de, LST_FILE_INFO + 3 << 8
1151  8765 21 DF 94     	ld		hl, MsgFileType
1152  8768 CD 1C 8E     	call	PrintStr
1153  876B
1154  876B 11 00 0D     	ld		de, LST_FILE_INFO + 5 << 8
1155  876E 21 23 95     	ld		hl, MsgFileLen
1156  8771 CD 1C 8E     	call	PrintStr
1157  8774
1158  8774 C9           	ret
1159  8775
1160  8775              MoveMsg:
1161  8775 01 07 00     	ld		bc, 7
1162  8778 ED B0        	ldir
1163  877A C9           	ret
1164  877B
1165  877B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1166  877B
1167  877B              ReadAllHeaders:
1168  877B 21 43 95     	ld		hl, MsgReadingExt
1169  877E 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1170  8781 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1171  8783 CD 44 8E     	call	PrintStrClr
1172  8786
1173  8786 CD 46 81     	call	CalcFileCache
1174  8789
1175  8789 3A 33 96     	ld		a, (SelFile)
1176  878C 47           	ld		b, a
1177  878D 3A 31 96     	ld		a, (FileCnt)
1178  8790 90           	sub		b
1179  8791 B7           	or		a
1180  8792 C8           	ret		z
1181  8793
1182  8793 47           	ld		b, a
1183  8794
1184  8794 DD 2A 38 96  	ld		ix, (SelFileCache)
1185  8798              NextFile:
1186  8798 C5           	push	bc
1187  8799 CD 50 8B     		call	ReadFileHeader
1188  879C 01 19 00     		ld		bc, CACHE_SZ
1189  879F DD 09        		add		ix, bc
1190  87A1 DD E5        		push	ix
1191  87A3 CD 46 81     			call	CalcFileCache
1192  87A6 CD 09 86     			call	DisplayFileInfo
1193  87A9 DD E1        		pop		ix
1194  87AB
1195  87AB CD E3 8D     		call	KbdHit
1196  87AE 38 03        		jr		c, AKey
1197  87B0 C1           	pop		bc
1198  87B1 18 15        	jr		ReadAllHeadersEnd
1199  87B3
1200  87B3              AKey:
1201  87B3 3A 33 96     		ld		a, (SelFile)
1202  87B6 3C           		inc		a
1203  87B7 47           		ld		b, a
1204  87B8 3A 31 96     		ld		a, (FileCnt)
1205  87BB B8           		cp		b
1206  87BC 28 16        		jr		z, DontInc
1207  87BE 78           		ld		a, b
1208  87BF 32 33 96     		ld		(SelFile), a
1209  87C2 CD E7 8E     		call	MoveCursor
1210  87C5 C1           	pop		bc
1211  87C6 10 D0        	djnz	NextFile
1212  87C8
1213  87C8              ReadAllHeadersEnd:
1214  87C8 21 51 95     	ld		hl, MsgClear
1215  87CB 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1216  87CE 3E 0F        	ld		a, SCR_DEF_CLR
1217  87D0 CD 44 8E     	call	PrintStrClr
1218  87D3 C9           	ret
1219  87D4
1220  87D4              DontInc:
1221  87D4 C1           	pop		bc
1222  87D5 18 F1        	jr		ReadAllHeadersEnd
1223  87D7
1224  87D7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1225  87D7              ;Will report HC version based on copyright string. For HC2000 will report v1/v2. For IF1 will report v1/v2.
1226  87D7              ;Versions:
1227  87D7              ;"HC - 85", 6, 32, 32, 32, 32, "I.C.E FELIX"
1228  87D7              ;"HC - 90", 6, 32, 32, 32, 32, "I.C.E FELIX"
1229  87D7              ;"HC - 91", 6, 32, 32, 32, 32, "I.C.E FELIX"
1230  87D7              ;"HC2000 ICE FELIX COMPUTER SA" - v1
1231  87D7              ;"HC2000", 6, 32, 32, 32, 32, "I.C.E FELIX" - v2
1232  87D7              PrintIntro:
1233  87D7 21 A2 93     	ld		hl, VerMsg1
1234  87DA 11 00 01     	ld		de, LST_PROG_INFO + 1 << 8
1235  87DD CD 1C 8E     	call	PrintStr
1236  87E0 21 B2 93     	ld		hl, VerMsg2
1237  87E3 11 00 02     	ld		de, LST_PROG_INFO + 2 << 8
1238  87E6 CD 1C 8E     	call	PrintStr
1239  87E9 21 C2 93     	ld		hl, VerMsg3
1240  87EC 11 00 03     	ld		de, LST_PROG_INFO + 3 << 8
1241  87EF CD 1C 8E     	call	PrintStr
1242  87F2
1243  87F2 ~            	/*
1244  87F2 ~            	ld		hl, STR_MSG_BASIC
1245  87F2 ~            	ld		de, MsgCompModelName
1246  87F2 ~            	ld		b, 7
1247  87F2 ~            PrintComputerInfoLoop:
1248  87F2 ~            	ld		a, (hl)
1249  87F2 ~            	cp		' '
1250  87F2 ~            	jr		z, PrintComputerInfoSkip
1251  87F2 ~            	ld		(de), a
1252  87F2 ~            	inc		de
1253  87F2 ~            PrintComputerInfoSkip:
1254  87F2 ~            	inc		hl
1255  87F2 ~            	djnz	PrintComputerInfoLoop
1256  87F2 ~
1257  87F2 ~            	ld		a, (STR_MSG_BASIC + 2)
1258  87F2 ~            	cp		'2'
1259  87F2 ~            	jr		nz, PrintComputerInfoIF1
1260  87F2 ~
1261  87F2 ~            	;HC2000
1262  87F2 ~            	ld		a, ' '
1263  87F2 ~            	ld		(de), a
1264  87F2 ~            	inc		de
1265  87F2 ~            	ld		a, 'v'
1266  87F2 ~            	ld		(de), a
1267  87F2 ~            	inc		de
1268  87F2 ~
1269  87F2 ~            	ld		a, (hl)
1270  87F2 ~            	cp		'I'
1271  87F2 ~            	jr		z, HC2000v1
1272  87F2 ~            	ld		a, '2' | $80
1273  87F2 ~            	jr		HC2000Store
1274  87F2 ~            HC2000v1:
1275  87F2 ~            	ld		a, '1' | $80
1276  87F2 ~            HC2000Store:
1277  87F2 ~            	ld		(de), a
1278  87F2 ~            	inc		de
1279  87F2 ~            	;Patch code to look for HC2000 IF1 string at a different address.
1280  87F2 ~            	ld		hl, GetIF1String+1
1281  87F2 ~            	ld		de, STR_MSG_IF1_2000
1282  87F2 ~            	ld		(hl), e
1283  87F2 ~            	inc		hl
1284  87F2 ~            	ld		(hl), d
1285  87F2 ~
1286  87F2 ~            PrintComputerInfoIF1:
1287  87F2 ~            	ld		hl, GetIF1String
1288  87F2 ~            	ld		de, PrintCompInfo
1289  87F2 ~            	push	de
1290  87F2 ~            	jp		IF1Call
1291  87F2 ~
1292  87F2 ~            GetIF1String:
1293  87F2 ~            	ld		hl, STR_MSG_IF1_91
1294  87F2 ~            	ld		de, MsgIF1Date
1295  87F2 ~            	ld		a, '.'
1296  87F2 ~            GetIF1StringLoop:
1297  87F2 ~            	ldi
1298  87F2 ~            	ldi
1299  87F2 ~            	ld		(de), a
1300  87F2 ~            	inc		de
1301  87F2 ~            	ldi
1302  87F2 ~            	ldi
1303  87F2 ~            	ld		(de), a
1304  87F2 ~            	inc		de
1305  87F2 ~            	ldi
1306  87F2 ~            	ld		a, (hl)
1307  87F2 ~            	or		$80
1308  87F2 ~            	ld		(de), a
1309  87F2 ~            	ret
1310  87F2 ~
1311  87F2 ~            PrintCompInfo:
1312  87F2 ~            	ld		hl, MsgCompModel
1313  87F2 ~            	ld		de, LST_PROG_INFO + 4 << 8
1314  87F2 ~            	call	PrintStr
1315  87F2 ~
1316  87F2 ~            	ld		hl, MsgIF1Version
1317  87F2 ~            	ld		de, LST_PROG_INFO + 5 << 8
1318  87F2 ~            	call	PrintStr
1319  87F2 ~
1320  87F2 ~            	ret
1321  87F2 ~            	*/
1322  87F2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1323  87F2
1324  87F2              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 87F2              	ifndef	_HCCFG_
   2+ 87F2              	define	_HCCFG_
   3+ 87F2
   4+ 87F2              ;HC specific code, for configuration
   5+ 87F2
   6+ 87F2              HC_CFG_PORT			EQU	$7E
   7+ 87F2
   8+ 87F2              ;BASIC/CPM ROM selection
   9+ 87F2              HC_CFG_ROM_BAS		EQU	%0
  10+ 87F2              HC_CFG_ROM_CPM		EQU	%1
  11+ 87F2
  12+ 87F2              ;Address for ROM paging: 0 or $E000
  13+ 87F2              HC_CFG_ROM_0000		EQU %00
  14+ 87F2              HC_CFG_ROM_E000		EQU %10
  15+ 87F2
  16+ 87F2              ;Cfg. port Enable/Disable
  17+ 87F2              HC_CFG_PORT_DIS		EQU %000
  18+ 87F2              HC_CFG_PORT_EN		EQU	%100
  19+ 87F2
  20+ 87F2              ;Video memory bank: $4000 or $C000
  21+ 87F2              HC_CFG_VID_4000		EQU	%0000
  22+ 87F2              HC_CFG_VID_C000		EQU	%1000
  23+ 87F2
  24+ 87F2
  25+ 87F2              ;Standar BASIC config
  26+ 87F2              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 87F2              ;Standar CP/M config
  28+ 87F2              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 87F2
  30+ 87F2
  31+ 87F2              HC_VID_BANK0		EQU	$4000
  32+ 87F2              HC_VID_BANK1		EQU	$C000
  33+ 87F2
  34+ 87F2              	endif
# file closed: hccfg.asm
1325  87F2              	include "if1.asm"
# file opened: if1.asm
   1+ 87F2              ;HC IF1 routines and constants
   2+ 87F2
   3+ 87F2              ;IF1 routines error codes, also returned by BASIC commands
   4+ 87F2              ;12 = Writing to a 'read' file
   5+ 87F2              ;13 = Reading a 'write' file
   6+ 87F2              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 87F2              ;15 = Disk full (disk or catalog full)
   8+ 87F2              ;16 = Disk error (hardware error)
   9+ 87F2              ;17 = File not found
  10+ 87F2              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 87F2              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 87F2
  13+ 87F2              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 87F2              ;00h = OK
  15+ 87F2              ;08h = cannot format disk
  16+ 87F2              ;10h = disk protected (read-only?)
  17+ 87F2              ;20h = volume error
  18+ 87F2              ;40h = drive error
  19+ 87F2              ;80h = reading error
  20+ 87F2              ;Codes I encountered:
  21+ 87F2              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 87F2
  23+ 87F2
  24+ 87F2              	ifndef	_DISK_
  25+ 87F2              	define	_DISK_
  26+ 87F2
  27+ 87F2              	include	"math.asm"
# file opened: math.asm
   1++87F2              	ifndef	_MATH_
   2++87F2              	define	_MATH_
   3++87F2
   4++87F2              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++87F2              ;http://map.tni.nl/sources/external/z80bits.html
   6++87F2
   7++87F2
   8++87F2              Word2Txt:
   9++87F2              	IFUSED
  10++87F2 D5           	push	de
  11++87F3 CD 13 88     		call	Word2Txt_
  12++87F6 D1           	pop		de
  13++87F7
  14++87F7 06 04        	ld		b, 4
  15++87F9 CD 08 88     	call	StrippLeading0
  16++87FC C9           	ret
  17++87FD
  18++87FD              Byte2Txt:
  19++87FD D5           	push	de
  20++87FE CD 1F 88     		call	Byte2Txt_
  21++8801 D1           	pop		de
  22++8802
  23++8802 06 02        	ld		b, 2
  24++8804 CD 08 88     	call	StrippLeading0
  25++8807 C9           	ret
  26++8808              	ENDIF
  27++8808
  28++8808
  29++8808              StrippLeading0:
  30++8808 1A           	ld		a, (de)
  31++8809 FE 31        	cp		'1'
  32++880B D0           	ret		nc
  33++880C
  34++880C 3E 20        	ld		a, ' '
  35++880E 12           	ld		(de), a
  36++880F 13           	inc		de
  37++8810 10 F6        	djnz	StrippLeading0
  38++8812 C9           	ret
  39++8813
  40++8813
  41++8813              ;Converts the number in HL to ASCII in decimal string at DE
  42++8813              Word2Txt_:
  43++8813 01 F0 D8     	ld bc, -10000
  44++8816 CD 2E 88     	call DigitLoop
  45++8819 01 18 FC     	ld bc, -1000
  46++881C CD 2E 88     	call DigitLoop
  47++881F              Byte2Txt_:
  48++881F 01 9C FF     	ld bc, -100
  49++8822 CD 2E 88     	call DigitLoop
  50++8825 01 F6 FF     	ld bc, -10
  51++8828 CD 2E 88     	call DigitLoop
  52++882B 01 FF FF     	ld bc, -1
  53++882E
  54++882E              DigitLoop:
  55++882E 3E 2F        	ld	a, '0' - 1
  56++8830              DivNrLoop:
  57++8830 3C           	inc	a			;increase reminder
  58++8831 09           	add	hl, bc		;substract divizor
  59++8832 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++8834 ED 42        	sbc	hl, bc		;nope, restore
  61++8836
  62++8836 12           	ld (de), a
  63++8837 13           	inc de
  64++8838 C9           	ret
  65++8839
  66++8839
  67++8839              ;Input: HL = Dividend, C = Divisor
  68++8839              ;Output: HL = Quotient, A = Remainder
  69++8839              ;Warning: doesn't work with divisor >= $80
  70++8839              Div:
  71++8839              	IFUSED
  72++8839 AF           	xor a
  73++883A 06 10        	ld b, 16
  74++883C
  75++883C              DivLoop:
  76++883C 29           	add	hl,hl
  77++883D 17           	rla
  78++883E B9           	cp	c
  79++883F 38 02        	jr	c, NoSub
  80++8841 91           	sub	c
  81++8842 2C           	inc	l
  82++8843              NoSub:
  83++8843 10 F7        	djnz DivLoop
  84++8845
  85++8845 C9           	ret
  86++8846              	ENDIF
  87++8846
  88++8846              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++8846              ;Output: A:C = Quotient, HL = Remainder
  90++8846              Div2:
  91++8846 21 00 00     	ld hl, 0
  92++8849 06 10        	ld b, 16
  93++884B              Div2Loop:
  94++884B CB 31        	sll c		; unroll 16 times
  95++884D 17           	rla			; ...
  96++884E ED 6A        	adc	hl,hl		; ...
  97++8850 ED 52        	sbc	hl,de		; ...
  98++8852 30 02        	jr	nc,$+4		; ...
  99++8854 19           	add	hl,de		; ...
 100++8855 0D           	dec	c		; ...
 101++8856 10 F3        	djnz Div2Loop
 102++8858 C9           	ret
 103++8859
 104++8859
 105++8859              ;Input: A = Multiplier, DE = Multiplicand
 106++8859              ;Output: A:HL = Product
 107++8859              Mul:
 108++8859              	IFUSED
 109++8859 21 00 00     	ld hl, 0
 110++885C 01 00 07     	ld bc, $0700
 111++885F
 112++885F 87           	add	a, a		; optimised 1st iteration
 113++8860 30 02        	jr	nc, MulLoop
 114++8862 62           	ld	h, d
 115++8863 6B           	ld	l, e
 116++8864
 117++8864              MulLoop:
 118++8864 29           	add	hl,hl
 119++8865 17           	rla
 120++8866 30 02        	jr	nc, NoAdd
 121++8868 19           	add	hl,de
 122++8869 89           	adc	a,c
 123++886A              NoAdd:
 124++886A 10 F8        	djnz MulLoop
 125++886C
 126++886C C9           	ret
 127++886D              	ENDIF
 128++886D
 129++886D              	endif
# file closed: math.asm
  28+ 886D
  29+ 886D              DRIVE_CUR_BAS	EQU 0
  30+ 886D              DRIVE_A_BAS		EQU	1
  31+ 886D              DRIVE_B_BAS		EQU	2
  32+ 886D              DRIVE_A_CPM		EQU	0
  33+ 886D              DRIVE_B_CPM		EQU	1
  34+ 886D              ;Disk geometry stuff
  35+ 886D              SPT				EQU	16			;sectors per track
  36+ 886D              SECT_SZ			EQU	256			;sector size in bytes
  37+ 886D              TRACK_CNT		EQU	80			;track count
  38+ 886D              HEAD_CNT		EQU	2			;disk face count
  39+ 886D              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 886D              EXT_SZ			EQU	32			;directory entry size
  41+ 886D              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 886D              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 886D              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 886D              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 886D              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 886D              REC_SZ			EQU 128			;cp/m record size
  47+ 886D              DEL_MARKER		EQU	$E5
  48+ 886D
  49+ 886D
  50+ 886D              ;Extension structure (directory entry)
  51+ 886D              EXT_DEL_FLAG	EQU	0
  52+ 886D              EXT_NAME		EQU 1
  53+ 886D              EXT_IDX			EQU 12
  54+ 886D              EXT_S1			EQU 13
  55+ 886D              EXT_S2			EQU 14
  56+ 886D              EXT_RC			EQU	15
  57+ 886D              EXT_AU0			EQU	16
  58+ 886D              EXT_AU1			EQU	18
  59+ 886D              EXT_AU2			EQU	20
  60+ 886D              EXT_AU3			EQU	22
  61+ 886D              EXT_AU4			EQU	24
  62+ 886D              EXT_AU5			EQU	26
  63+ 886D              EXT_AU6			EQU	28
  64+ 886D              EXT_AU7			EQU	30
  65+ 886D              EXT_SIZE		EQU 32
  66+ 886D
  67+ 886D              ;FCB structure
  68+ 886D              FCB_DRIVE		EQU 0
  69+ 886D              FCB_NAME		EQU EXT_NAME
  70+ 886D              FCB_EX_IDX		EQU EXT_IDX
  71+ 886D              FCB_S1			EQU EXT_S1
  72+ 886D              FCB_S2			EQU EXT_S2
  73+ 886D              FCB_RC			EQU	EXT_RC
  74+ 886D              FCB_AU			EQU	EXT_AU0
  75+ 886D              FCB_CR			EQU	32
  76+ 886D              FCB_R0			EQU 33
  77+ 886D              FCB_R1			EQU 34
  78+ 886D              FCB_R2			EQU 35
  79+ 886D              FCB_SIZE		EQU 36
  80+ 886D
  81+ 886D
  82+ 886D
  83+ 886D              ;System variables for disk
  84+ 886D              DSTR1			EQU	$5CD6		;drive
  85+ 886D              FSTR1			EQU	$5CDC		;file name
  86+ 886D              NSTR1			EQU	$5CDA		;name length
  87+ 886D              HD11			EQU	$5CED		;BDOS argument
  88+ 886D              COPIES			EQU	$5CEF		;BDOS function
  89+ 886D
  90+ 886D              ERRSP			EQU $5C3D
  91+ 886D              ERRNR			EQU $5C3A
  92+ 886D              ERRMSG			EQU	$0260
  93+ 886D
  94+ 886D              PROG			EQU $5C53
  95+ 886D              VARS			EQU	$5C4B
  96+ 886D              STKEND			EQU	$5C65
  97+ 886D
  98+ 886D              PRN_BUF			EQU	23296
  99+ 886D
 100+ 886D              STR_MSG_BASIC	EQU	$1539
 101+ 886D              STR_MSG_BASIC_LEN EQU 32
 102+ 886D              STR_MSG_IF1_2000	EQU $27F0
 103+ 886D              STR_MSG_IF1_91		EQU $23F0
 104+ 886D              STR_MSG_IF1_LEN EQU 31
 105+ 886D
 106+ 886D              REPDEL			EQU	23561
 107+ 886D              REPPER			EQU	23562
 108+ 886D              PIP				EQU	23609
 109+ 886D
 110+ 886D
 111+ 886D              ;RWTS routine commands
 112+ 886D              RWTS_CMD_POS	EQU	0			;position head
 113+ 886D              RWTS_CMD_READ	EQU	1			;read sector
 114+ 886D              RWTS_CMD_WRITE	EQU	2			;write sector
 115+ 886D              RWTS_CMD_FMT	EQU	4			;format all tracks
 116+ 886D
 117+ 886D
 118+ 886D              ;File name stuff
 119+ 886D              NAMELEN			EQU	11			;name length
 120+ 886D              RO_POS			EQU	8			;read-only attribute position in name
 121+ 886D              SYS_POS			EQU	9			;system attribute position in name
 122+ 886D
 123+ 886D              ;File types (first byte in header)
 124+ 886D              PROG_TYPE		EQU	0			;program
 125+ 886D              NUMB_TYPE		EQU	1			;number array
 126+ 886D              CHAR_TYPE		EQU	2			;char array
 127+ 886D              BYTE_TYPE		EQU	3			;bytes
 128+ 886D              TEXT_TYPE		EQU	4			;text, >= 4
 129+ 886D
 130+ 886D              ;File header offsets
 131+ 886D              HDR_TYPE		EQU	0
 132+ 886D              HDR_LEN			EQU 1
 133+ 886D              HDR_ADDR		EQU 3
 134+ 886D              HDR_PLEN		EQU	5
 135+ 886D              HDR_LINE		EQU 7
 136+ 886D              HDR_SZ			EQU	9
 137+ 886D
 138+ 886D              ;BASIC disk channel structure
 139+ 886D              CH_RW_FLAG		EQU 11
 140+ 886D              CH_FCB			EQU	12
 141+ 886D              CH_DATA			EQU	50
 142+ 886D              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143+ 886D
 144+ 886D              CACHE_NAME		EQU	0					;11B
 145+ 886D              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146+ 886D              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147+ 886D              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148+ 886D              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149+ 886D              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150+ 886D
 151+ 886D              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152+ 886D
 153+ 886D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154+ 886D              IF1Init:
 155+ 886D CF           	rst		08
 156+ 886E 31           	defb	49		;create system variables
 157+ 886F C9           	ret
 158+ 8870
 159+ 8870              ;ReadWriteTrackSector
 160+ 8870              ;A=command: 0, 1, 2, 4
 161+ 8870              RWTS:
 162+ 8870 32 0C 8C     	ld (RWTSCmd), a
 163+ 8873 21 01 8C     	ld hl, RWTSParams
 164+ 8876 22 ED 5C     	ld (HD11), hl
 165+ 8879 CF           	rst 08
 166+ 887A 3A           	DEFB 58
 167+ 887B C9           	ret
 168+ 887C
 169+ 887C
 170+ 887C              ;D = sector, E = track
 171+ 887C              ;HL = dma
 172+ 887C              ReadOneDiskSector:
 173+ 887C 22 06 8C     	ld (RWTSDMA), hl
 174+ 887F ED 53 04 8C  	ld (RWTSTrack), de
 175+ 8883              	;ld (RWTSDrive), a
 176+ 8883 3E 01        	ld a, RWTS_CMD_READ
 177+ 8885 18 E9        	jr	RWTS
 178+ 8887
 179+ 8887              ;D = sector, E = track
 180+ 8887              ;HL = dma
 181+ 8887              WriteOneDiskSector:
 182+ 8887 22 06 8C     	ld (RWTSDMA), hl
 183+ 888A ED 53 04 8C  	ld (RWTSTrack), de
 184+ 888E              	;ld (RWTSDrive), a
 185+ 888E 3E 02        	ld a, RWTS_CMD_WRITE
 186+ 8890 18 DE        	jr	RWTS
 187+ 8892
 188+ 8892              FormatDisk:
 189+ 8892 21 20 A5     	ld		hl, DataBuf
 190+ 8895 36 E5        	ld		(hl), DEL_MARKER
 191+ 8897 22 06 8C     	ld 		(RWTSDMA), hl
 192+ 889A 3E 04        	ld 		a, RWTS_CMD_FMT
 193+ 889C CD 70 88     	call	RWTS
 194+ 889F 3A 0D 8C     	ld		a, (RWTSRes)
 195+ 88A2 C9           	ret
 196+ 88A3
 197+ 88A3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198+ 88A3
 199+ 88A3              ;Allocation unit no. to track/sector
 200+ 88A3              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201+ 88A3              ;IN:  HL=alloc. unit no.
 202+ 88A3              ;OUT: B=sector; C=track (head is determined by the sector number)
 203+ 88A3              AU2TS:
 204+ 88A3 0E 02        	ld c, SPT/SPAL
 205+ 88A5 CD 39 88     	call Div					;A = sector
 206+ 88A8 F5           	push af
 207+ 88A9 ~            		/*
 208+ 88A9 ~            		ld c, HEAD_CNT
 209+ 88A9 ~            		call Div				;L = track, A = head (0 or 1)
 210+ 88A9 ~            		*/
 211+ 88A9 AF           		xor a
 212+ 88AA CB 1C        		rr h
 213+ 88AC CB 1D        		rr l
 214+ 88AE CB 1F        		rr a
 215+ 88B0
 216+ 88B0 4D           		ld c, l
 217+ 88B1 06 00        		ld b, 0
 218+ 88B3 B7           		or a
 219+ 88B4 28 02        		jr z, Track0
 220+ 88B6 06 10        		ld b, SPT
 221+ 88B8              Track0:
 222+ 88B8 F1           	pop af
 223+ 88B9 B7           	or a
 224+ 88BA 28 02        	jr z, FirstAU
 225+ 88BC 3E 08        	ld a, SPAL
 226+ 88BE              FirstAU:
 227+ 88BE 80           	add a, b
 228+ 88BF 47           	ld  b, a
 229+ 88C0 C9           	ret
 230+ 88C1
 231+ 88C1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232+ 88C1
 233+ 88C1              ;Checks the allocation units number used in extension
 234+ 88C1              ;IN:	IX = extension addr
 235+ 88C1              ;OUT:	B = no. of allocation units used
 236+ 88C1              ;		C = no. of records used in ext.
 237+ 88C1              ;		HL = first alloc. unit no.
 238+ 88C1              ;		DE = last alloc. unit no.
 239+ 88C1              CheckExtAlloc:
 240+ 88C1 DD E5        	push ix
 241+ 88C3 01 0F 00     		ld bc, EXT_RC
 242+ 88C6 DD 09        		add ix, bc
 243+ 88C8 DD 4E 00     		ld c, (ix)			;save rec. no.
 244+ 88CB DD 23        		inc ix
 245+ 88CD DD 6E 00     		ld l, (ix)
 246+ 88D0 DD 66 01     		ld h, (ix + 1)
 247+ 88D3 06 08        		ld b, EXT_AU_CNT
 248+ 88D5              CheckAU:
 249+ 88D5 DD 7E 00     		ld a, (ix)
 250+ 88D8 DD B6 01     		or (ix + 1)
 251+ 88DB 28 0C        		jr z, CheckAUEnd
 252+ 88DD DD 5E 00     		ld e, (ix)
 253+ 88E0 DD 56 01     		ld d, (ix + 1)
 254+ 88E3 DD 23        		inc ix
 255+ 88E5 DD 23        		inc ix
 256+ 88E7 10 EC        		djnz CheckAU
 257+ 88E9              CheckAUEnd:
 258+ 88E9 3E 08        		ld a, EXT_AU_CNT
 259+ 88EB 90           		sub b
 260+ 88EC 47           		ld b, a
 261+ 88ED DD E1        	pop ix
 262+ 88EF C9           	ret
 263+ 88F0
 264+ 88F0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265+ 88F0
 266+ 88F0              ;Input: TrackBuffer
 267+ 88F0              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268+ 88F0              ReadUsedBlocksList:
 269+ 88F0 DD 21 20 A5  	ld		ix, TrackBuf			;source buffer
 270+ 88F4 21 36 9F     	ld		hl, UsedBlockListCnt 	;destination buffer
 271+ 88F7 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272+ 88FA 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 273+ 88FD 73           	ld		(hl), e
 274+ 88FE 23           	inc		hl
 275+ 88FF 72           	ld		(hl), d
 276+ 8900 23           	inc		hl
 277+ 8901
 278+ 8901              	;Add blocks 0 and 1 for directory
 279+ 8901 11 00 00     	ld		de, 0
 280+ 8904 73           	ld		(hl), e
 281+ 8905 23           	inc		hl
 282+ 8906 72           	ld		(hl), d
 283+ 8907 23           	inc		hl
 284+ 8908
 285+ 8908 13           	inc		de
 286+ 8909 73           	ld		(hl), e
 287+ 890A 23           	inc		hl
 288+ 890B 72           	ld		(hl), d
 289+ 890C 23           	inc		hl
 290+ 890D
 291+ 890D              ReadUsedBlocksLoop:
 292+ 890D AF           	xor		a
 293+ 890E DD BE 00     	cp		(ix)
 294+ 8911 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295+ 8913
 296+ 8913 DD E5        	push	ix
 297+ 8915 C5           	push	bc
 298+ 8916 06 08        		ld		b, EXT_AU_CNT
 299+ 8918 11 10 00     		ld		de, EXT_AU0
 300+ 891B DD 19        		add		ix, de
 301+ 891D
 302+ 891D              ReadUsedBlocksLoop2:
 303+ 891D DD 5E 00     		ld		e, (ix)
 304+ 8920 DD 56 01     		ld		d, (ix+1)
 305+ 8923 7B           		ld		a, e
 306+ 8924 B2           		or		d
 307+ 8925 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308+ 8927
 309+ 8927 73           		ld		(hl), e
 310+ 8928 23           		inc		hl
 311+ 8929 72           		ld		(hl), d
 312+ 892A 23           		inc		hl
 313+ 892B
 314+ 892B DD 23        		inc		ix
 315+ 892D DD 23        		inc		ix
 316+ 892F
 317+ 892F ED 5B 36 9F  		ld		de, (UsedBlockListCnt)
 318+ 8933 13           		inc		de
 319+ 8934 ED 53 36 9F  		ld		(UsedBlockListCnt), de
 320+ 8938
 321+ 8938 10 E3        		djnz	ReadUsedBlocksLoop2
 322+ 893A
 323+ 893A
 324+ 893A              ReadUsedBlocksSkip:
 325+ 893A C1           	pop		bc
 326+ 893B DD E1        	pop		ix
 327+ 893D              ReadUsedBlocksSkip2:
 328+ 893D 11 20 00     	ld		de, EXT_SZ
 329+ 8940 DD 19        	add		ix, de
 330+ 8942
 331+ 8942 0B           	dec		bc
 332+ 8943 78           	ld		a, b
 333+ 8944 B1           	or		c
 334+ 8945 20 C6        	jr		nz, ReadUsedBlocksLoop
 335+ 8947
 336+ 8947 C9           	ret
 337+ 8948
 338+ 8948              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339+ 8948              ;Reads 8 sectors for an AU
 340+ 8948              ;HL = block number, DE = destination buffer
 341+ 8948              ReadFSBlock:
 342+ 8948 D5           	push	de
 343+ 8949 CD A3 88     		call	AU2TS		;B=sector, C=track
 344+ 894C E1           	pop		hl				;HL=dest
 345+ 894D
 346+ 894D 50           	ld		d, b
 347+ 894E 59           	ld		e, c
 348+ 894F 06 08        	ld		b, SPAL
 349+ 8951
 350+ 8951              ReadFSBlockLoop:
 351+ 8951 CD 00 8B     	call	ReadDiskSectors
 352+ 8954 C9           	ret
 353+ 8955
 354+ 8955
 355+ 8955              ;Write 8 sectors for an AU
 356+ 8955              ;HL = block number, DE = source buffer
 357+ 8955              WriteFSBlock:
 358+ 8955 D5           	push	de
 359+ 8956 CD A3 88     		call	AU2TS		;B=sector, C=track
 360+ 8959 E1           	pop		hl				;HL=dest
 361+ 895A
 362+ 895A 50           	ld		d, b
 363+ 895B 59           	ld		e, c
 364+ 895C 06 08        	ld		b, SPAL
 365+ 895E
 366+ 895E              WriteFSBlockLoop:
 367+ 895E CD 13 8B     	call	WriteDiskSectors
 368+ 8961 C9           	ret
 369+ 8962
 370+ 8962              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371+ 8962              ;Copies the allocated blocks from one disk to another, dual drive.
 372+ 8962              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373+ 8962              CopyDisk:
 374+ 8962              	;Get list of used blocks in current disk, max 632 bytes
 375+ 8962 CD F0 88     	call	ReadUsedBlocksList
 376+ 8965 DD 21 38 9F  	ld		ix, UsedBlockListBlk
 377+ 8969
 378+ 8969              CopyDiskLoop:
 379+ 8969 2A 36 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380+ 896C 11 02 96     	ld		de, MsgBlocksLeft
 381+ 896F CD FD 87     	call	Byte2Txt
 382+ 8972 21 02 96     	ld		hl, MsgBlocksLeft
 383+ 8975 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 384+ 8978 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 385+ 897A CD 44 8E     	call	PrintStrClr
 386+ 897D
 387+ 897D              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388+ 897D 21 0B 00     	ld		hl, MAX_AU_RAM
 389+ 8980 ED 4B 36 9F  	ld		bc, (UsedBlockListCnt)
 390+ 8984 B7           	or		a
 391+ 8985 ED 42        	sbc		hl, bc
 392+ 8987 30 03        	jr		nc, CopyDiskLoopRead
 393+ 8989 01 0B 00     	ld		bc, MAX_AU_RAM
 394+ 898C
 395+ 898C              CopyDiskLoopRead:
 396+ 898C 41           	ld		b, c
 397+ 898D 11 20 A5     	ld		de, CopyDiskBuf
 398+ 8990              	;save initial counter and initial block number array position
 399+ 8990 C5           	push	bc
 400+ 8991 DD E5        	push	ix
 401+ 8993
 402+ 8993              CopyDiskLoopReadLoop:
 403+ 8993 DD 6E 00     		ld		l, (ix)
 404+ 8996 DD 66 01     		ld		h, (ix+1)
 405+ 8999 DD 23        		inc		ix
 406+ 899B DD 23        		inc		ix
 407+ 899D
 408+ 899D D5           		push	de
 409+ 899E C5           		push	bc
 410+ 899F CD 48 89     			call	ReadFSBlock			;Stop on error or continue?
 411+ 89A2 C1           		pop		bc
 412+ 89A3 D1           		pop		de
 413+ 89A4
 414+ 89A4              		;+2048
 415+ 89A4 7A           		ld		a, d
 416+ 89A5 C6 08        		add		8
 417+ 89A7 57           		ld		d, a
 418+ 89A8
 419+ 89A8 10 E9        		djnz	CopyDiskLoopReadLoop
 420+ 89AA
 421+ 89AA              		;alternate drive
 422+ 89AA 3A 02 8C     		ld		a, (RWTSDrive)
 423+ 89AD EE 03        		xor		%11
 424+ 89AF 32 02 8C     		ld		(RWTSDrive), a
 425+ 89B2
 426+ 89B2              	;restore initial counter and initial block number array position
 427+ 89B2 DD E1        	pop		ix
 428+ 89B4 C1           	pop		bc
 429+ 89B5 11 20 A5     	ld		de, CopyDiskBuf
 430+ 89B8 C5           	push	bc
 431+ 89B9
 432+ 89B9              CopyDiskLoopWriteLoop:
 433+ 89B9 DD 6E 00     		ld		l, (ix)
 434+ 89BC DD 66 01     		ld		h, (ix+1)
 435+ 89BF DD 23        		inc		ix
 436+ 89C1 DD 23        		inc		ix
 437+ 89C3
 438+ 89C3 D5           		push	de
 439+ 89C4 C5           		push	bc
 440+ 89C5 CD 55 89     			call	WriteFSBlock		;Stop on error or continue?
 441+ 89C8 C1           		pop		bc
 442+ 89C9 D1           		pop		de
 443+ 89CA
 444+ 89CA              		;+2048
 445+ 89CA 7A           		ld		a, d
 446+ 89CB C6 08        		add		8
 447+ 89CD 57           		ld		d, a
 448+ 89CE
 449+ 89CE 10 E9        		djnz	CopyDiskLoopWriteLoop
 450+ 89D0
 451+ 89D0              		;alternate drive again
 452+ 89D0 3A 02 8C     		ld		a, (RWTSDrive)
 453+ 89D3 EE 03        		xor		%11
 454+ 89D5 32 02 8C     		ld		(RWTSDrive), a
 455+ 89D8
 456+ 89D8 C1           	pop		bc
 457+ 89D9 48           	ld		c, b
 458+ 89DA 06 00        	ld		b, 0
 459+ 89DC
 460+ 89DC              	;Decrease number of blocks read by now.
 461+ 89DC 2A 36 9F     	ld		hl, (UsedBlockListCnt)
 462+ 89DF B7           	or		a
 463+ 89E0 ED 42        	sbc		hl, bc
 464+ 89E2 22 36 9F     	ld		(UsedBlockListCnt), hl
 465+ 89E5
 466+ 89E5 7D           	ld		a, l
 467+ 89E6 B4           	or		h
 468+ 89E7 C2 69 89     	jp		nz, CopyDiskLoop
 469+ 89EA
 470+ 89EA C9           	ret
 471+ 89EB
 472+ 89EB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473+ 89EB              ;Copies the current disk blocks to COM port.
 474+ 89EB              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475+ 89EB              CopyDiskToCOM:
 476+ 89EB              	;Get list of used blocks in current disk, max 632 bytes
 477+ 89EB CD F0 88     	call	ReadUsedBlocksList
 478+ 89EE
 479+ 89EE              	;Send block count and block indexes
 480+ 89EE 2A 36 9F     	ld		hl, (UsedBlockListCnt)
 481+ 89F1 29           	add		hl, hl
 482+ 89F2 23           	inc		hl
 483+ 89F3 23           	inc		hl
 484+ 89F4 44           	ld		b, h
 485+ 89F5 4D           	ld		c, l
 486+ 89F6 21 36 9F     	ld		hl, UsedBlockListCnt
 487+ 89F9 CD 6C 93     	call	SERTB
 488+ 89FC
 489+ 89FC DD 21 38 9F  	ld		ix, UsedBlockListBlk
 490+ 8A00
 491+ 8A00              CopyDiskToCOMLoop:
 492+ 8A00              	;Print block count left
 493+ 8A00 2A 36 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494+ 8A03 11 02 96     	ld		de, MsgBlocksLeft
 495+ 8A06 CD FD 87     	call	Byte2Txt
 496+ 8A09 21 02 96     	ld		hl, MsgBlocksLeft
 497+ 8A0C 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 498+ 8A0F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 499+ 8A11 CD 44 8E     	call	PrintStrClr
 500+ 8A14
 501+ 8A14              	;Read block into buffer
 502+ 8A14 DD 6E 00     	ld		l, (ix)
 503+ 8A17 DD 66 01     	ld		h, (ix+1)
 504+ 8A1A 11 20 A5     	ld		de, CopyDiskBuf
 505+ 8A1D DD E5        	push	ix
 506+ 8A1F CD 48 89     		call	ReadFSBlock
 507+ 8A22 DD E1        	pop		ix
 508+ 8A24 DD 23        	inc		ix
 509+ 8A26 DD 23        	inc		ix
 510+ 8A28
 511+ 8A28              	;Send block buffer
 512+ 8A28 21 20 A5     	ld		hl, CopyDiskBuf
 513+ 8A2B 01 00 08     	ld		bc, AU_SZ
 514+ 8A2E CD 6C 93     	call	SERTB
 515+ 8A31
 516+ 8A31 ED 4B 36 9F  	ld		bc, (UsedBlockListCnt)
 517+ 8A35 0B           	dec		bc
 518+ 8A36 ED 43 36 9F  	ld		(UsedBlockListCnt), bc
 519+ 8A3A
 520+ 8A3A DD E5        	push	ix
 521+ 8A3C CD E3 8D     		call	KbdHit
 522+ 8A3F DD E1        	pop		ix
 523+ 8A41 D8           	ret		c
 524+ 8A42
 525+ 8A42 78           	ld		a, b
 526+ 8A43 B1           	or		c
 527+ 8A44 20 BA        	jr		nz, CopyDiskToCOMLoop
 528+ 8A46
 529+ 8A46 C9           	ret
 530+ 8A47
 531+ 8A47              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532+ 8A47              CopyDiskFromCOM:
 533+ 8A47              	;Receive block count.
 534+ 8A47 21 36 9F     	ld		hl, UsedBlockListCnt
 535+ 8A4A 01 02 00     	ld		bc, 2
 536+ 8A4D 1E 00        	ld		e, 0
 537+ 8A4F CD 39 93     	call	SERRB
 538+ 8A52
 539+ 8A52              	;Receive block indexes.
 540+ 8A52 2A 36 9F     	ld		hl, (UsedBlockListCnt)
 541+ 8A55 29           	add		hl, hl
 542+ 8A56 44           	ld		b, h
 543+ 8A57 4D           	ld		c, l
 544+ 8A58 21 38 9F     	ld		hl, UsedBlockListBlk
 545+ 8A5B 1E 00        	ld		e, 0
 546+ 8A5D CD 39 93     	call	SERRB
 547+ 8A60
 548+ 8A60              	;Read each block by index and write to disk
 549+ 8A60 DD 21 38 9F  	ld		ix, UsedBlockListBlk
 550+ 8A64
 551+ 8A64              CopyDiskFromCOMLoop:
 552+ 8A64              	;Print block count left
 553+ 8A64 2A 36 9F     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554+ 8A67 11 02 96     	ld		de, MsgBlocksLeft
 555+ 8A6A CD FD 87     	call	Byte2Txt
 556+ 8A6D 21 02 96     	ld		hl, MsgBlocksLeft
 557+ 8A70 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 558+ 8A73 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 559+ 8A75 CD 44 8E     	call	PrintStrClr
 560+ 8A78
 561+ 8A78              	;Read block buffer
 562+ 8A78 21 20 A5     	ld		hl, CopyDiskBuf
 563+ 8A7B 01 00 08     	ld		bc, AU_SZ
 564+ 8A7E 1E 00        	ld		e, 0
 565+ 8A80 CD 39 93     	call	SERRB
 566+ 8A83
 567+ 8A83              	;Write block to disk
 568+ 8A83 DD 6E 00     	ld		l, (ix)
 569+ 8A86 DD 66 01     	ld		h, (ix+1)
 570+ 8A89 11 20 A5     	ld		de, CopyDiskBuf
 571+ 8A8C DD E5        	push	ix
 572+ 8A8E CD 55 89     		call	WriteFSBlock			;Stop on error or continue?
 573+ 8A91 DD E1        	pop		ix
 574+ 8A93 DD 23        	inc		ix
 575+ 8A95 DD 23        	inc		ix
 576+ 8A97
 577+ 8A97 ED 4B 36 9F  	ld		bc, (UsedBlockListCnt)
 578+ 8A9B 0B           	dec		bc
 579+ 8A9C ED 43 36 9F  	ld		(UsedBlockListCnt), bc
 580+ 8AA0
 581+ 8AA0 DD E5        	push	ix
 582+ 8AA2 CD E3 8D     		call	KbdHit
 583+ 8AA5 DD E1        	pop		ix
 584+ 8AA7 D8           	ret		c
 585+ 8AA8
 586+ 8AA8 78           	ld		a, b
 587+ 8AA9 B1           	or		c
 588+ 8AAA 20 B8        	jr		nz, CopyDiskFromCOMLoop
 589+ 8AAC C9           	ret
 590+ 8AAD
 591+ 8AAD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592+ 8AAD
 593+ 8AAD              ;Compare string at HL with the one at DE, max length B
 594+ 8AAD              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595+ 8AAD              ;OUT: z flag, set = match, reset = mismatch
 596+ 8AAD              StrCmp:
 597+ 8AAD E5           	push hl
 598+ 8AAE D5           	push de
 599+ 8AAF              Compare:
 600+ 8AAF 1A           		ld a, (de)
 601+ 8AB0 BE           		cp (hl)
 602+ 8AB1 20 04        		jr nz, MisMatch
 603+ 8AB3 23           		inc hl
 604+ 8AB4 13           		inc de
 605+ 8AB5 10 F8        		djnz Compare
 606+ 8AB7              MisMatch:
 607+ 8AB7 D1           	pop de
 608+ 8AB8 E1           	pop hl
 609+ 8AB9 C9           	ret
 610+ 8ABA
 611+ 8ABA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612+ 8ABA
 613+ 8ABA              ;Read a file into a buffer, sector by sector.
 614+ 8ABA              ;It's relocatable, to moved and be used when loading a CODE block.
 615+ 8ABA              ;It's not using BDOS, but using similar calls provided by IF1.
 616+ 8ABA              ;In: HL = Name address, DE = buffer
 617+ 8ABA              IF1FileLoad:
 618+ 8ABA D5           	push	de
 619+ 8ABB 22 DC 5C     		ld (FSTR1), hl
 620+ 8ABE 26 00        		ld h, 0
 621+ 8AC0 3A 02 8C     		ld a, (RWTSDrive)
 622+ 8AC3 3C           		inc  a			;CP/M drive number to BASIC drive number
 623+ 8AC4 6F           		ld	l, a
 624+ 8AC5 22 D6 5C     		ld (DSTR1), hl
 625+ 8AC8 2E 0B        		ld l,NAMELEN
 626+ 8ACA 22 DA 5C     		ld (NSTR1), hl
 627+ 8ACD CF           		rst 08
 628+ 8ACE 33           		DEFB 51			;open disk channel
 629+ 8ACF
 630+ 8ACF CF           		rst		8
 631+ 8AD0 35           		defb	53		;read sector
 632+ 8AD1 D1           	pop		de
 633+ 8AD2 30 27        	jr		nc, FileFree
 634+ 8AD4
 635+ 8AD4 DD 7E 32     	ld		a, (ix + CH_DATA)
 636+ 8AD7 FE 04        	cp		TEXT_TYPE
 637+ 8AD9 30 12        	jr		nc, FileLoadNoHeader
 638+ 8ADB
 639+ 8ADB              FileLoadHeader:
 640+ 8ADB DD E5        	push	ix
 641+ 8ADD E1           	pop		hl
 642+ 8ADE 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 643+ 8AE1 09           	add		hl, bc
 644+ 8AE2 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 645+ 8AE5 ED B0        	ldir
 646+ 8AE7
 647+ 8AE7              FileReadLoop:
 648+ 8AE7 D5           	push	de
 649+ 8AE8 CF           		rst		8
 650+ 8AE9 35           		defb	53		;read sector
 651+ 8AEA D1           	pop		de
 652+ 8AEB 30 0E        	jr		nc, FileFree
 653+ 8AED
 654+ 8AED              FileLoadNoHeader:
 655+ 8AED DD E5        	push	ix
 656+ 8AEF E1           	pop		hl
 657+ 8AF0 01 32 00     	ld		bc, CH_DATA
 658+ 8AF3 09           	add		hl, bc
 659+ 8AF4 01 00 01     	ld		bc, SECT_SZ
 660+ 8AF7 ED B0        	ldir
 661+ 8AF9 18 EC        	jr		FileReadLoop
 662+ 8AFB              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663+ 8AFB              IF1FileLoadEnd:
 664+ 8AFB
 665+ 8AFB              FileFree:
 666+ 8AFB D5           	push	de
 667+ 8AFC CF           	rst		8
 668+ 8AFD 38           	defb	56			;close channel (52) or detroy channel (56)
 669+ 8AFE D1           	pop		de
 670+ 8AFF C9           	ret
 671+ 8B00
 672+ 8B00
 673+ 8B00              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674+ 8B00              ;HL = destination buffer, B = count of sectors, DE = track/sector
 675+ 8B00              ;Out: A = error code, 0=OK
 676+ 8B00              ReadDiskSectors:
 677+ 8B00 C5           	push bc
 678+ 8B01 E5           		push hl
 679+ 8B02 D5           			push de
 680+ 8B03 CD 7C 88     				call ReadOneDiskSector
 681+ 8B06 D1           			pop de
 682+ 8B07 E1           		pop hl
 683+ 8B08
 684+ 8B08 14           		inc d
 685+ 8B09 24           		inc h
 686+ 8B0A C1           	pop bc
 687+ 8B0B
 688+ 8B0B 3A 0D 8C     	ld	a, (RWTSRes)
 689+ 8B0E B7           	or	a
 690+ 8B0F C0           	ret nz
 691+ 8B10
 692+ 8B10 10 EE        	djnz ReadDiskSectors
 693+ 8B12 C9           	ret
 694+ 8B13
 695+ 8B13              ;HL = source buffer, B = count of sectors, DE = track/sector
 696+ 8B13              ;Out: A = error code, 0=OK
 697+ 8B13              WriteDiskSectors:
 698+ 8B13 C5           	push bc
 699+ 8B14 E5           		push hl
 700+ 8B15 D5           			push de
 701+ 8B16 CD 87 88     				call WriteOneDiskSector
 702+ 8B19 D1           			pop de
 703+ 8B1A E1           		pop hl
 704+ 8B1B
 705+ 8B1B 14           		inc d
 706+ 8B1C 24           		inc h
 707+ 8B1D C1           	pop bc
 708+ 8B1E
 709+ 8B1E 3A 0D 8C     	ld	a, (RWTSRes)
 710+ 8B21 B7           	or	a
 711+ 8B22 C0           	ret nz
 712+ 8B23
 713+ 8B23 10 EE        	djnz WriteDiskSectors
 714+ 8B25 C9           	ret
 715+ 8B26
 716+ 8B26
 717+ 8B26              ;Reads disk catalog
 718+ 8B26              ReadCatalogTrack:
 719+ 8B26 21 20 A5     	ld hl, TrackBuf
 720+ 8B29 11 00 00     	ld de, 0
 721+ 8B2C 06 10        	ld b, SPT
 722+ 8B2E
 723+ 8B2E CD 00 8B     	call ReadDiskSectors
 724+ 8B31 B7           	or   a
 725+ 8B32 C0           	ret  nz
 726+ 8B33
 727+ 8B33              	;Sync with BDOS, to avoid disk R/O error on disk change
 728+ 8B33 F5           	push  af
 729+ 8B34 3A 02 8C     		ld  a, (RWTSDrive)
 730+ 8B37 CD 17 8C     		call BDOSSelectDisk
 731+ 8B3A CD 14 8C     		call BDOSInit
 732+ 8B3D F1           	pop   af
 733+ 8B3E C9           	ret
 734+ 8B3F
 735+ 8B3F
 736+ 8B3F
 737+ 8B3F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738+ 8B3F
 739+ 8B3F              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740+ 8B3F              FindCache:
 741+ 8B3F 06 0B        	ld		b, NAMELEN
 742+ 8B41 CD AD 8A     	call	StrCmp			;find the file to wich this extension belongs
 743+ 8B44 C8           	ret		z
 744+ 8B45
 745+ 8B45 0D           	dec		c
 746+ 8B46 20 02        	jr		nz, CacheNotFinished
 747+ 8B48 B1           	or		c
 748+ 8B49 C9           	ret
 749+ 8B4A
 750+ 8B4A              CacheNotFinished:
 751+ 8B4A 01 19 00     	ld		bc, CACHE_SZ
 752+ 8B4D 09           	add		hl, bc			;to the next cache line
 753+ 8B4E 18 EF        	jr		FindCache
 754+ 8B50
 755+ 8B50              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756+ 8B50
 757+ 8B50              	;ld		ix, (SelFileCache)
 758+ 8B50              ReadFileHeader:
 759+ 8B50 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 760+ 8B53 B7           	or		a
 761+ 8B54 C0           	ret		nz				;return if already read
 762+ 8B55
 763+ 8B55 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 764+ 8B58 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 765+ 8B5B 7C           	ld		a, h
 766+ 8B5C B5           	or		l
 767+ 8B5D 28 46        	jr		z, ReadHeaderEnd
 768+ 8B5F
 769+ 8B5F CD A3 88     	call	AU2TS
 770+ 8B62 50           	ld		d, b
 771+ 8B63 59           	ld		e, c
 772+ 8B64 21 20 A5     	ld		hl, DataBuf
 773+ 8B67 DD E5        	push	ix
 774+ 8B69 DD E5        	push	ix
 775+ 8B6B CD 7C 88     		call	ReadOneDiskSector
 776+ 8B6E E1           	pop		hl
 777+ 8B6F DD E1        	pop		ix
 778+ 8B71
 779+ 8B71 E5           	push	hl
 780+ 8B72 21 20 A5     		ld		hl, DataBuf
 781+ 8B75 CD A9 8B     		call	IsFileHeaderValid
 782+ 8B78 E1           	pop		hl
 783+ 8B79 B7           	or		a
 784+ 8B7A 28 14        	jr		z, ReadFileHeaderIsTextFile
 785+ 8B7C
 786+ 8B7C 01 10 00     	ld		bc, CACHE_HDR
 787+ 8B7F 09           	add		hl, bc
 788+ 8B80 EB           	ex		hl, de
 789+ 8B81 21 20 A5     	ld		hl, DataBuf
 790+ 8B84 01 09 00     	ld		bc, HDR_SZ
 791+ 8B87 ED B0        	ldir
 792+ 8B89
 793+ 8B89              	;For text files, read file size as reported by BDOS, since we don't have a header.
 794+ 8B89 3E 03        	ld		a, BYTE_TYPE
 795+ 8B8B DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 796+ 8B8E 30 15        	jr		nc, ReadHeaderEnd
 797+ 8B90
 798+ 8B90              ReadFileHeaderIsTextFile:
 799+ 8B90 DD E5        	push	ix
 800+ 8B92 DD E5        	push	ix
 801+ 8B94 E1           	pop		hl
 802+ 8B95 CD 62 8C     		call	GetFileSize
 803+ 8B98 DD E1        	pop		ix
 804+ 8B9A DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 805+ 8B9D DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806+ 8BA0 3E 04        	ld		a, TEXT_TYPE
 807+ 8BA2 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808+ 8BA5
 809+ 8BA5              ReadHeaderEnd:
 810+ 8BA5 DD 34 0F     	inc		(ix + CACHE_FLAG)
 811+ 8BA8 C9           	ret
 812+ 8BA9
 813+ 8BA9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814+ 8BA9              ;Checks if the file header is valid. For now it checks to not have all 0s.
 815+ 8BA9              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816+ 8BA9              ;In: HL = header
 817+ 8BA9              ;Out: A > 0 if valid
 818+ 8BA9              IsFileHeaderValid:
 819+ 8BA9              	IFUSED
 820+ 8BA9 AF           	xor		a
 821+ 8BAA 06 09        	ld		b, HDR_SZ
 822+ 8BAC              IsFileHeaderValidLoop:
 823+ 8BAC B6           	or		(hl)
 824+ 8BAD 23           	inc		hl
 825+ 8BAE 10 FC        	djnz	IsFileHeaderValidLoop
 826+ 8BB0
 827+ 8BB0 C9           	ret
 828+ 8BB1              	ENDIF
 829+ 8BB1
 830+ 8BB1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831+ 8BB1
 832+ 8BB1              ;IN: HL = address from IF1 to call
 833+ 8BB1              IF1Call:
 834+ 8BB1 22 ED 5C     	LD   (HD11), HL
 835+ 8BB4 CF           	RST  8
 836+ 8BB5 32           	DEFB 50
 837+ 8BB6 C9           	RET
 838+ 8BB7
 839+ 8BB7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840+ 8BB7
 841+ 8BB7              ;Load a program from disk
 842+ 8BB7              ;IN: HL = file name addr
 843+ 8BB7              LoadProgram:
 844+ 8BB7 22 DC 5C     	LD   (FSTR1), HL
 845+ 8BBA 26 00        	LD   H, 0
 846+ 8BBC 2E 0B        	LD   L, NAMELEN
 847+ 8BBE 22 DA 5C     	LD   (NSTR1), HL
 848+ 8BC1 3A 02 8C     	LD	 A, (RWTSDrive)
 849+ 8BC4 3C           	INC  A					;Adapt for BASIC drive number
 850+ 8BC5 6F           	LD   L, A
 851+ 8BC6 22 D6 5C     	LD   (DSTR1), HL
 852+ 8BC9 21 41 0A     	LD   HL, LOAD_ADDR
 853+ 8BCC CD B1 8B     	CALL IF1Call
 854+ 8BCF C9           	RET
 855+ 8BD0
 856+ 8BD0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857+ 8BD0
 858+ 8BD0              SetFastKeys:
 859+ 8BD0 21 09 5C     	ld		hl, REPDEL
 860+ 8BD3 11 0F 01     	ld		de, (1 << 8) | 15
 861+ 8BD6 73 23 72 2B  	ld		(hl), de
 862+ 8BDA
 863+ 8BDA C9           	ret
 864+ 8BDB
 865+ 8BDB
 866+ 8BDB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867+ 8BDB              ;Reads the error message string from IF1 ROM.
 868+ 8BDB              GetErrMsg:
 869+ 8BDB 3C           	inc		a
 870+ 8BDC 08           	ex		af, af'
 871+ 8BDD
 872+ 8BDD 21 E3 8B     	ld		hl, IF1Paged			;page-in IF1
 873+ 8BE0 C3 B1 8B     	jp		IF1Call
 874+ 8BE3
 875+ 8BE3              IF1Paged:
 876+ 8BE3 21 60 02     	ld		hl, ERRMSG
 877+ 8BE6 08           	ex		af, af'
 878+ 8BE7 B7           	or		a
 879+ 8BE8 28 0B        	jr		z, SaveMsg
 880+ 8BEA
 881+ 8BEA 06 00        	ld		b, 0
 882+ 8BEC              SearchMsgEnd:
 883+ 8BEC CB 7E        	bit		7, (hl)
 884+ 8BEE 23           	inc		hl
 885+ 8BEF 28 FB        	jr		z, SearchMsgEnd
 886+ 8BF1
 887+ 8BF1 04           	inc		b
 888+ 8BF2 B8           	cp		b
 889+ 8BF3 20 F7        	jr		nz, SearchMsgEnd
 890+ 8BF5
 891+ 8BF5              SaveMsg:
 892+ 8BF5 11 20 A5     	ld		de, DataBuf
 893+ 8BF8              CopyMsg:
 894+ 8BF8 7E           	ld		a, (hl)
 895+ 8BF9 CB 7F        	bit		7, a
 896+ 8BFB 12           	ld		(de), a
 897+ 8BFC 23           	inc		hl
 898+ 8BFD 13           	inc		de
 899+ 8BFE 28 F8        	jr		z, CopyMsg
 900+ 8C00
 901+ 8C00 C9           	ret
 902+ 8C01
 903+ 8C01              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904+ 8C01
 905+ 8C01              ;RWTS routine I/O block
 906+ 8C01              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 907+ 8C01              RWTSParams:
 908+ 8C01 01           RWTSBlockType	DEFB	1							;?
 909+ 8C02 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 910+ 8C03 00           RWTSVolNo		DEFB	0							;?
 911+ 8C04 00           RWTSTrack		DEFB	0
 912+ 8C05 00           RWTSSector		DEFB	0
 913+ 8C06 00 00        RWTSDMA			DEFW	0
 914+ 8C08 32 29        RWTSExtBuf		DEFW	$2932
 915+ 8C0A 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 916+ 8C0C 01           RWTSCmd			DEFB	RWTS_CMD_READ
 917+ 8C0D              ;Results
 918+ 8C0D 00           RWTSRes			DEFB	0
 919+ 8C0E 00           RWTSResVolNo	DEFB	0
 920+ 8C0F 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 920+ 8C13 00
 921+ 8C14
 922+ 8C14              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 923+ 8C14 ~            /*
 924+ 8C14 ~            BasPrmTbl:
 925+ 8C14 ~            PrmDevType		DEFB	$01			;$01
 926+ 8C14 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 927+ 8C14 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 928+ 8C14 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 929+ 8C14 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 930+ 8C14 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 931+ 8C14 ~            */
 932+ 8C14
 933+ 8C14              	endif
# file closed: if1.asm
1326  8C14              	include "bdos.asm"
# file opened: bdos.asm
   1+ 8C14              ;BDOS functions - similar to CP/M
   2+ 8C14
   3+ 8C14              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 8C14              ;0 OK,
   5+ 8C14              ;1 directory full,
   6+ 8C14              ;2 disc full,
   7+ 8C14              ;9 invalid FCB,
   8+ 8C14              ;10(CP/M) media changed;
   9+ 8C14              ;0FFh hardware error.
  10+ 8C14
  11+ 8C14              	IFNDEF	_BDOS_
  12+ 8C14              	DEFINE	_BDOS_
  13+ 8C14
  14+ 8C14              	include "if1.asm"
# file opened: if1.asm
   1++8C14              ;HC IF1 routines and constants
   2++8C14
   3++8C14              ;IF1 routines error codes, also returned by BASIC commands
   4++8C14              ;12 = Writing to a 'read' file
   5++8C14              ;13 = Reading a 'write' file
   6++8C14              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++8C14              ;15 = Disk full (disk or catalog full)
   8++8C14              ;16 = Disk error (hardware error)
   9++8C14              ;17 = File not found
  10++8C14              ;23 = Disk R/O (disk change detected, software R/O)
  11++8C14              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++8C14
  13++8C14              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++8C14              ;00h = OK
  15++8C14              ;08h = cannot format disk
  16++8C14              ;10h = disk protected (read-only?)
  17++8C14              ;20h = volume error
  18++8C14              ;40h = drive error
  19++8C14              ;80h = reading error
  20++8C14              ;Codes I encountered:
  21++8C14              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++8C14
  23++8C14
  24++8C14              	ifndef	_DISK_
  25++8C14 ~            	define	_DISK_
  26++8C14 ~
  27++8C14 ~            	include	"math.asm"
  28++8C14 ~
  29++8C14 ~            DRIVE_CUR_BAS	EQU 0
  30++8C14 ~            DRIVE_A_BAS		EQU	1
  31++8C14 ~            DRIVE_B_BAS		EQU	2
  32++8C14 ~            DRIVE_A_CPM		EQU	0
  33++8C14 ~            DRIVE_B_CPM		EQU	1
  34++8C14 ~            ;Disk geometry stuff
  35++8C14 ~            SPT				EQU	16			;sectors per track
  36++8C14 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++8C14 ~            TRACK_CNT		EQU	80			;track count
  38++8C14 ~            HEAD_CNT		EQU	2			;disk face count
  39++8C14 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++8C14 ~            EXT_SZ			EQU	32			;directory entry size
  41++8C14 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++8C14 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++8C14 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++8C14 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++8C14 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++8C14 ~            REC_SZ			EQU 128			;cp/m record size
  47++8C14 ~            DEL_MARKER		EQU	$E5
  48++8C14 ~
  49++8C14 ~
  50++8C14 ~            ;Extension structure (directory entry)
  51++8C14 ~            EXT_DEL_FLAG	EQU	0
  52++8C14 ~            EXT_NAME		EQU 1
  53++8C14 ~            EXT_IDX			EQU 12
  54++8C14 ~            EXT_S1			EQU 13
  55++8C14 ~            EXT_S2			EQU 14
  56++8C14 ~            EXT_RC			EQU	15
  57++8C14 ~            EXT_AU0			EQU	16
  58++8C14 ~            EXT_AU1			EQU	18
  59++8C14 ~            EXT_AU2			EQU	20
  60++8C14 ~            EXT_AU3			EQU	22
  61++8C14 ~            EXT_AU4			EQU	24
  62++8C14 ~            EXT_AU5			EQU	26
  63++8C14 ~            EXT_AU6			EQU	28
  64++8C14 ~            EXT_AU7			EQU	30
  65++8C14 ~            EXT_SIZE		EQU 32
  66++8C14 ~
  67++8C14 ~            ;FCB structure
  68++8C14 ~            FCB_DRIVE		EQU 0
  69++8C14 ~            FCB_NAME		EQU EXT_NAME
  70++8C14 ~            FCB_EX_IDX		EQU EXT_IDX
  71++8C14 ~            FCB_S1			EQU EXT_S1
  72++8C14 ~            FCB_S2			EQU EXT_S2
  73++8C14 ~            FCB_RC			EQU	EXT_RC
  74++8C14 ~            FCB_AU			EQU	EXT_AU0
  75++8C14 ~            FCB_CR			EQU	32
  76++8C14 ~            FCB_R0			EQU 33
  77++8C14 ~            FCB_R1			EQU 34
  78++8C14 ~            FCB_R2			EQU 35
  79++8C14 ~            FCB_SIZE		EQU 36
  80++8C14 ~
  81++8C14 ~
  82++8C14 ~
  83++8C14 ~            ;System variables for disk
  84++8C14 ~            DSTR1			EQU	$5CD6		;drive
  85++8C14 ~            FSTR1			EQU	$5CDC		;file name
  86++8C14 ~            NSTR1			EQU	$5CDA		;name length
  87++8C14 ~            HD11			EQU	$5CED		;BDOS argument
  88++8C14 ~            COPIES			EQU	$5CEF		;BDOS function
  89++8C14 ~
  90++8C14 ~            ERRSP			EQU $5C3D
  91++8C14 ~            ERRNR			EQU $5C3A
  92++8C14 ~            ERRMSG			EQU	$0260
  93++8C14 ~
  94++8C14 ~            PROG			EQU $5C53
  95++8C14 ~            VARS			EQU	$5C4B
  96++8C14 ~            STKEND			EQU	$5C65
  97++8C14 ~
  98++8C14 ~            PRN_BUF			EQU	23296
  99++8C14 ~
 100++8C14 ~            STR_MSG_BASIC	EQU	$1539
 101++8C14 ~            STR_MSG_BASIC_LEN EQU 32
 102++8C14 ~            STR_MSG_IF1_2000	EQU $27F0
 103++8C14 ~            STR_MSG_IF1_91		EQU $23F0
 104++8C14 ~            STR_MSG_IF1_LEN EQU 31
 105++8C14 ~
 106++8C14 ~            REPDEL			EQU	23561
 107++8C14 ~            REPPER			EQU	23562
 108++8C14 ~            PIP				EQU	23609
 109++8C14 ~
 110++8C14 ~
 111++8C14 ~            ;RWTS routine commands
 112++8C14 ~            RWTS_CMD_POS	EQU	0			;position head
 113++8C14 ~            RWTS_CMD_READ	EQU	1			;read sector
 114++8C14 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 115++8C14 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 116++8C14 ~
 117++8C14 ~
 118++8C14 ~            ;File name stuff
 119++8C14 ~            NAMELEN			EQU	11			;name length
 120++8C14 ~            RO_POS			EQU	8			;read-only attribute position in name
 121++8C14 ~            SYS_POS			EQU	9			;system attribute position in name
 122++8C14 ~
 123++8C14 ~            ;File types (first byte in header)
 124++8C14 ~            PROG_TYPE		EQU	0			;program
 125++8C14 ~            NUMB_TYPE		EQU	1			;number array
 126++8C14 ~            CHAR_TYPE		EQU	2			;char array
 127++8C14 ~            BYTE_TYPE		EQU	3			;bytes
 128++8C14 ~            TEXT_TYPE		EQU	4			;text, >= 4
 129++8C14 ~
 130++8C14 ~            ;File header offsets
 131++8C14 ~            HDR_TYPE		EQU	0
 132++8C14 ~            HDR_LEN			EQU 1
 133++8C14 ~            HDR_ADDR		EQU 3
 134++8C14 ~            HDR_PLEN		EQU	5
 135++8C14 ~            HDR_LINE		EQU 7
 136++8C14 ~            HDR_SZ			EQU	9
 137++8C14 ~
 138++8C14 ~            ;BASIC disk channel structure
 139++8C14 ~            CH_RW_FLAG		EQU 11
 140++8C14 ~            CH_FCB			EQU	12
 141++8C14 ~            CH_DATA			EQU	50
 142++8C14 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143++8C14 ~
 144++8C14 ~            CACHE_NAME		EQU	0					;11B
 145++8C14 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146++8C14 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147++8C14 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148++8C14 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149++8C14 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150++8C14 ~
 151++8C14 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152++8C14 ~
 153++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154++8C14 ~            IF1Init:
 155++8C14 ~            	rst		08
 156++8C14 ~            	defb	49		;create system variables
 157++8C14 ~            	ret
 158++8C14 ~
 159++8C14 ~            ;ReadWriteTrackSector
 160++8C14 ~            ;A=command: 0, 1, 2, 4
 161++8C14 ~            RWTS:
 162++8C14 ~            	ld (RWTSCmd), a
 163++8C14 ~            	ld hl, RWTSParams
 164++8C14 ~            	ld (HD11), hl
 165++8C14 ~            	rst 08
 166++8C14 ~            	DEFB 58
 167++8C14 ~            	ret
 168++8C14 ~
 169++8C14 ~
 170++8C14 ~            ;D = sector, E = track
 171++8C14 ~            ;HL = dma
 172++8C14 ~            ReadOneDiskSector:
 173++8C14 ~            	ld (RWTSDMA), hl
 174++8C14 ~            	ld (RWTSTrack), de
 175++8C14 ~            	;ld (RWTSDrive), a
 176++8C14 ~            	ld a, RWTS_CMD_READ
 177++8C14 ~            	jr	RWTS
 178++8C14 ~
 179++8C14 ~            ;D = sector, E = track
 180++8C14 ~            ;HL = dma
 181++8C14 ~            WriteOneDiskSector:
 182++8C14 ~            	ld (RWTSDMA), hl
 183++8C14 ~            	ld (RWTSTrack), de
 184++8C14 ~            	;ld (RWTSDrive), a
 185++8C14 ~            	ld a, RWTS_CMD_WRITE
 186++8C14 ~            	jr	RWTS
 187++8C14 ~
 188++8C14 ~            FormatDisk:
 189++8C14 ~            	ld		hl, DataBuf
 190++8C14 ~            	ld		(hl), DEL_MARKER
 191++8C14 ~            	ld 		(RWTSDMA), hl
 192++8C14 ~            	ld 		a, RWTS_CMD_FMT
 193++8C14 ~            	call	RWTS
 194++8C14 ~            	ld		a, (RWTSRes)
 195++8C14 ~            	ret
 196++8C14 ~
 197++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198++8C14 ~
 199++8C14 ~            ;Allocation unit no. to track/sector
 200++8C14 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201++8C14 ~            ;IN:  HL=alloc. unit no.
 202++8C14 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 203++8C14 ~            AU2TS:
 204++8C14 ~            	ld c, SPT/SPAL
 205++8C14 ~            	call Div					;A = sector
 206++8C14 ~            	push af
 207++8C14 ~            		/*
 208++8C14 ~            		ld c, HEAD_CNT
 209++8C14 ~            		call Div				;L = track, A = head (0 or 1)
 210++8C14 ~            		*/
 211++8C14 ~            		xor a
 212++8C14 ~            		rr h
 213++8C14 ~            		rr l
 214++8C14 ~            		rr a
 215++8C14 ~
 216++8C14 ~            		ld c, l
 217++8C14 ~            		ld b, 0
 218++8C14 ~            		or a
 219++8C14 ~            		jr z, Track0
 220++8C14 ~            		ld b, SPT
 221++8C14 ~            Track0:
 222++8C14 ~            	pop af
 223++8C14 ~            	or a
 224++8C14 ~            	jr z, FirstAU
 225++8C14 ~            	ld a, SPAL
 226++8C14 ~            FirstAU:
 227++8C14 ~            	add a, b
 228++8C14 ~            	ld  b, a
 229++8C14 ~            	ret
 230++8C14 ~
 231++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232++8C14 ~
 233++8C14 ~            ;Checks the allocation units number used in extension
 234++8C14 ~            ;IN:	IX = extension addr
 235++8C14 ~            ;OUT:	B = no. of allocation units used
 236++8C14 ~            ;		C = no. of records used in ext.
 237++8C14 ~            ;		HL = first alloc. unit no.
 238++8C14 ~            ;		DE = last alloc. unit no.
 239++8C14 ~            CheckExtAlloc:
 240++8C14 ~            	push ix
 241++8C14 ~            		ld bc, EXT_RC
 242++8C14 ~            		add ix, bc
 243++8C14 ~            		ld c, (ix)			;save rec. no.
 244++8C14 ~            		inc ix
 245++8C14 ~            		ld l, (ix)
 246++8C14 ~            		ld h, (ix + 1)
 247++8C14 ~            		ld b, EXT_AU_CNT
 248++8C14 ~            CheckAU:
 249++8C14 ~            		ld a, (ix)
 250++8C14 ~            		or (ix + 1)
 251++8C14 ~            		jr z, CheckAUEnd
 252++8C14 ~            		ld e, (ix)
 253++8C14 ~            		ld d, (ix + 1)
 254++8C14 ~            		inc ix
 255++8C14 ~            		inc ix
 256++8C14 ~            		djnz CheckAU
 257++8C14 ~            CheckAUEnd:
 258++8C14 ~            		ld a, EXT_AU_CNT
 259++8C14 ~            		sub b
 260++8C14 ~            		ld b, a
 261++8C14 ~            	pop ix
 262++8C14 ~            	ret
 263++8C14 ~
 264++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265++8C14 ~
 266++8C14 ~            ;Input: TrackBuffer
 267++8C14 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268++8C14 ~            ReadUsedBlocksList:
 269++8C14 ~            	ld		ix, TrackBuf			;source buffer
 270++8C14 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 271++8C14 ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272++8C14 ~            	ld		de, 2					;counter of used blocks, start with 2
 273++8C14 ~            	ld		(hl), e
 274++8C14 ~            	inc		hl
 275++8C14 ~            	ld		(hl), d
 276++8C14 ~            	inc		hl
 277++8C14 ~
 278++8C14 ~            	;Add blocks 0 and 1 for directory
 279++8C14 ~            	ld		de, 0
 280++8C14 ~            	ld		(hl), e
 281++8C14 ~            	inc		hl
 282++8C14 ~            	ld		(hl), d
 283++8C14 ~            	inc		hl
 284++8C14 ~
 285++8C14 ~            	inc		de
 286++8C14 ~            	ld		(hl), e
 287++8C14 ~            	inc		hl
 288++8C14 ~            	ld		(hl), d
 289++8C14 ~            	inc		hl
 290++8C14 ~
 291++8C14 ~            ReadUsedBlocksLoop:
 292++8C14 ~            	xor		a
 293++8C14 ~            	cp		(ix)
 294++8C14 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295++8C14 ~
 296++8C14 ~            	push	ix
 297++8C14 ~            	push	bc
 298++8C14 ~            		ld		b, EXT_AU_CNT
 299++8C14 ~            		ld		de, EXT_AU0
 300++8C14 ~            		add		ix, de
 301++8C14 ~
 302++8C14 ~            ReadUsedBlocksLoop2:
 303++8C14 ~            		ld		e, (ix)
 304++8C14 ~            		ld		d, (ix+1)
 305++8C14 ~            		ld		a, e
 306++8C14 ~            		or		d
 307++8C14 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308++8C14 ~
 309++8C14 ~            		ld		(hl), e
 310++8C14 ~            		inc		hl
 311++8C14 ~            		ld		(hl), d
 312++8C14 ~            		inc		hl
 313++8C14 ~
 314++8C14 ~            		inc		ix
 315++8C14 ~            		inc		ix
 316++8C14 ~
 317++8C14 ~            		ld		de, (UsedBlockListCnt)
 318++8C14 ~            		inc		de
 319++8C14 ~            		ld		(UsedBlockListCnt), de
 320++8C14 ~
 321++8C14 ~            		djnz	ReadUsedBlocksLoop2
 322++8C14 ~
 323++8C14 ~
 324++8C14 ~            ReadUsedBlocksSkip:
 325++8C14 ~            	pop		bc
 326++8C14 ~            	pop		ix
 327++8C14 ~            ReadUsedBlocksSkip2:
 328++8C14 ~            	ld		de, EXT_SZ
 329++8C14 ~            	add		ix, de
 330++8C14 ~
 331++8C14 ~            	dec		bc
 332++8C14 ~            	ld		a, b
 333++8C14 ~            	or		c
 334++8C14 ~            	jr		nz, ReadUsedBlocksLoop
 335++8C14 ~
 336++8C14 ~            	ret
 337++8C14 ~
 338++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339++8C14 ~            ;Reads 8 sectors for an AU
 340++8C14 ~            ;HL = block number, DE = destination buffer
 341++8C14 ~            ReadFSBlock:
 342++8C14 ~            	push	de
 343++8C14 ~            		call	AU2TS		;B=sector, C=track
 344++8C14 ~            	pop		hl				;HL=dest
 345++8C14 ~
 346++8C14 ~            	ld		d, b
 347++8C14 ~            	ld		e, c
 348++8C14 ~            	ld		b, SPAL
 349++8C14 ~
 350++8C14 ~            ReadFSBlockLoop:
 351++8C14 ~            	call	ReadDiskSectors
 352++8C14 ~            	ret
 353++8C14 ~
 354++8C14 ~
 355++8C14 ~            ;Write 8 sectors for an AU
 356++8C14 ~            ;HL = block number, DE = source buffer
 357++8C14 ~            WriteFSBlock:
 358++8C14 ~            	push	de
 359++8C14 ~            		call	AU2TS		;B=sector, C=track
 360++8C14 ~            	pop		hl				;HL=dest
 361++8C14 ~
 362++8C14 ~            	ld		d, b
 363++8C14 ~            	ld		e, c
 364++8C14 ~            	ld		b, SPAL
 365++8C14 ~
 366++8C14 ~            WriteFSBlockLoop:
 367++8C14 ~            	call	WriteDiskSectors
 368++8C14 ~            	ret
 369++8C14 ~
 370++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371++8C14 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 372++8C14 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373++8C14 ~            CopyDisk:
 374++8C14 ~            	;Get list of used blocks in current disk, max 632 bytes
 375++8C14 ~            	call	ReadUsedBlocksList
 376++8C14 ~            	ld		ix, UsedBlockListBlk
 377++8C14 ~
 378++8C14 ~            CopyDiskLoop:
 379++8C14 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380++8C14 ~            	ld		de, MsgBlocksLeft
 381++8C14 ~            	call	Byte2Txt
 382++8C14 ~            	ld		hl, MsgBlocksLeft
 383++8C14 ~            	ld		de, LST_LINE_MSG + 1 << 8
 384++8C14 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 385++8C14 ~            	call	PrintStrClr
 386++8C14 ~
 387++8C14 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388++8C14 ~            	ld		hl, MAX_AU_RAM
 389++8C14 ~            	ld		bc, (UsedBlockListCnt)
 390++8C14 ~            	or		a
 391++8C14 ~            	sbc		hl, bc
 392++8C14 ~            	jr		nc, CopyDiskLoopRead
 393++8C14 ~            	ld		bc, MAX_AU_RAM
 394++8C14 ~
 395++8C14 ~            CopyDiskLoopRead:
 396++8C14 ~            	ld		b, c
 397++8C14 ~            	ld		de, CopyDiskBuf
 398++8C14 ~            	;save initial counter and initial block number array position
 399++8C14 ~            	push	bc
 400++8C14 ~            	push	ix
 401++8C14 ~
 402++8C14 ~            CopyDiskLoopReadLoop:
 403++8C14 ~            		ld		l, (ix)
 404++8C14 ~            		ld		h, (ix+1)
 405++8C14 ~            		inc		ix
 406++8C14 ~            		inc		ix
 407++8C14 ~
 408++8C14 ~            		push	de
 409++8C14 ~            		push	bc
 410++8C14 ~            			call	ReadFSBlock			;Stop on error or continue?
 411++8C14 ~            		pop		bc
 412++8C14 ~            		pop		de
 413++8C14 ~
 414++8C14 ~            		;+2048
 415++8C14 ~            		ld		a, d
 416++8C14 ~            		add		8
 417++8C14 ~            		ld		d, a
 418++8C14 ~
 419++8C14 ~            		djnz	CopyDiskLoopReadLoop
 420++8C14 ~
 421++8C14 ~            		;alternate drive
 422++8C14 ~            		ld		a, (RWTSDrive)
 423++8C14 ~            		xor		%11
 424++8C14 ~            		ld		(RWTSDrive), a
 425++8C14 ~
 426++8C14 ~            	;restore initial counter and initial block number array position
 427++8C14 ~            	pop		ix
 428++8C14 ~            	pop		bc
 429++8C14 ~            	ld		de, CopyDiskBuf
 430++8C14 ~            	push	bc
 431++8C14 ~
 432++8C14 ~            CopyDiskLoopWriteLoop:
 433++8C14 ~            		ld		l, (ix)
 434++8C14 ~            		ld		h, (ix+1)
 435++8C14 ~            		inc		ix
 436++8C14 ~            		inc		ix
 437++8C14 ~
 438++8C14 ~            		push	de
 439++8C14 ~            		push	bc
 440++8C14 ~            			call	WriteFSBlock		;Stop on error or continue?
 441++8C14 ~            		pop		bc
 442++8C14 ~            		pop		de
 443++8C14 ~
 444++8C14 ~            		;+2048
 445++8C14 ~            		ld		a, d
 446++8C14 ~            		add		8
 447++8C14 ~            		ld		d, a
 448++8C14 ~
 449++8C14 ~            		djnz	CopyDiskLoopWriteLoop
 450++8C14 ~
 451++8C14 ~            		;alternate drive again
 452++8C14 ~            		ld		a, (RWTSDrive)
 453++8C14 ~            		xor		%11
 454++8C14 ~            		ld		(RWTSDrive), a
 455++8C14 ~
 456++8C14 ~            	pop		bc
 457++8C14 ~            	ld		c, b
 458++8C14 ~            	ld		b, 0
 459++8C14 ~
 460++8C14 ~            	;Decrease number of blocks read by now.
 461++8C14 ~            	ld		hl, (UsedBlockListCnt)
 462++8C14 ~            	or		a
 463++8C14 ~            	sbc		hl, bc
 464++8C14 ~            	ld		(UsedBlockListCnt), hl
 465++8C14 ~
 466++8C14 ~            	ld		a, l
 467++8C14 ~            	or		h
 468++8C14 ~            	jp		nz, CopyDiskLoop
 469++8C14 ~
 470++8C14 ~            	ret
 471++8C14 ~
 472++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473++8C14 ~            ;Copies the current disk blocks to COM port.
 474++8C14 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475++8C14 ~            CopyDiskToCOM:
 476++8C14 ~            	;Get list of used blocks in current disk, max 632 bytes
 477++8C14 ~            	call	ReadUsedBlocksList
 478++8C14 ~
 479++8C14 ~            	;Send block count and block indexes
 480++8C14 ~            	ld		hl, (UsedBlockListCnt)
 481++8C14 ~            	add		hl, hl
 482++8C14 ~            	inc		hl
 483++8C14 ~            	inc		hl
 484++8C14 ~            	ld		b, h
 485++8C14 ~            	ld		c, l
 486++8C14 ~            	ld		hl, UsedBlockListCnt
 487++8C14 ~            	call	SERTB
 488++8C14 ~
 489++8C14 ~            	ld		ix, UsedBlockListBlk
 490++8C14 ~
 491++8C14 ~            CopyDiskToCOMLoop:
 492++8C14 ~            	;Print block count left
 493++8C14 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494++8C14 ~            	ld		de, MsgBlocksLeft
 495++8C14 ~            	call	Byte2Txt
 496++8C14 ~            	ld		hl, MsgBlocksLeft
 497++8C14 ~            	ld		de, LST_LINE_MSG + 1 << 8
 498++8C14 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 499++8C14 ~            	call	PrintStrClr
 500++8C14 ~
 501++8C14 ~            	;Read block into buffer
 502++8C14 ~            	ld		l, (ix)
 503++8C14 ~            	ld		h, (ix+1)
 504++8C14 ~            	ld		de, CopyDiskBuf
 505++8C14 ~            	push	ix
 506++8C14 ~            		call	ReadFSBlock
 507++8C14 ~            	pop		ix
 508++8C14 ~            	inc		ix
 509++8C14 ~            	inc		ix
 510++8C14 ~
 511++8C14 ~            	;Send block buffer
 512++8C14 ~            	ld		hl, CopyDiskBuf
 513++8C14 ~            	ld		bc, AU_SZ
 514++8C14 ~            	call	SERTB
 515++8C14 ~
 516++8C14 ~            	ld		bc, (UsedBlockListCnt)
 517++8C14 ~            	dec		bc
 518++8C14 ~            	ld		(UsedBlockListCnt), bc
 519++8C14 ~
 520++8C14 ~            	push	ix
 521++8C14 ~            		call	KbdHit
 522++8C14 ~            	pop		ix
 523++8C14 ~            	ret		c
 524++8C14 ~
 525++8C14 ~            	ld		a, b
 526++8C14 ~            	or		c
 527++8C14 ~            	jr		nz, CopyDiskToCOMLoop
 528++8C14 ~
 529++8C14 ~            	ret
 530++8C14 ~
 531++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532++8C14 ~            CopyDiskFromCOM:
 533++8C14 ~            	;Receive block count.
 534++8C14 ~            	ld		hl, UsedBlockListCnt
 535++8C14 ~            	ld		bc, 2
 536++8C14 ~            	ld		e, 0
 537++8C14 ~            	call	SERRB
 538++8C14 ~
 539++8C14 ~            	;Receive block indexes.
 540++8C14 ~            	ld		hl, (UsedBlockListCnt)
 541++8C14 ~            	add		hl, hl
 542++8C14 ~            	ld		b, h
 543++8C14 ~            	ld		c, l
 544++8C14 ~            	ld		hl, UsedBlockListBlk
 545++8C14 ~            	ld		e, 0
 546++8C14 ~            	call	SERRB
 547++8C14 ~
 548++8C14 ~            	;Read each block by index and write to disk
 549++8C14 ~            	ld		ix, UsedBlockListBlk
 550++8C14 ~
 551++8C14 ~            CopyDiskFromCOMLoop:
 552++8C14 ~            	;Print block count left
 553++8C14 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554++8C14 ~            	ld		de, MsgBlocksLeft
 555++8C14 ~            	call	Byte2Txt
 556++8C14 ~            	ld		hl, MsgBlocksLeft
 557++8C14 ~            	ld		de, LST_LINE_MSG + 1 << 8
 558++8C14 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 559++8C14 ~            	call	PrintStrClr
 560++8C14 ~
 561++8C14 ~            	;Read block buffer
 562++8C14 ~            	ld		hl, CopyDiskBuf
 563++8C14 ~            	ld		bc, AU_SZ
 564++8C14 ~            	ld		e, 0
 565++8C14 ~            	call	SERRB
 566++8C14 ~
 567++8C14 ~            	;Write block to disk
 568++8C14 ~            	ld		l, (ix)
 569++8C14 ~            	ld		h, (ix+1)
 570++8C14 ~            	ld		de, CopyDiskBuf
 571++8C14 ~            	push	ix
 572++8C14 ~            		call	WriteFSBlock			;Stop on error or continue?
 573++8C14 ~            	pop		ix
 574++8C14 ~            	inc		ix
 575++8C14 ~            	inc		ix
 576++8C14 ~
 577++8C14 ~            	ld		bc, (UsedBlockListCnt)
 578++8C14 ~            	dec		bc
 579++8C14 ~            	ld		(UsedBlockListCnt), bc
 580++8C14 ~
 581++8C14 ~            	push	ix
 582++8C14 ~            		call	KbdHit
 583++8C14 ~            	pop		ix
 584++8C14 ~            	ret		c
 585++8C14 ~
 586++8C14 ~            	ld		a, b
 587++8C14 ~            	or		c
 588++8C14 ~            	jr		nz, CopyDiskFromCOMLoop
 589++8C14 ~            	ret
 590++8C14 ~
 591++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592++8C14 ~
 593++8C14 ~            ;Compare string at HL with the one at DE, max length B
 594++8C14 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595++8C14 ~            ;OUT: z flag, set = match, reset = mismatch
 596++8C14 ~            StrCmp:
 597++8C14 ~            	push hl
 598++8C14 ~            	push de
 599++8C14 ~            Compare:
 600++8C14 ~            		ld a, (de)
 601++8C14 ~            		cp (hl)
 602++8C14 ~            		jr nz, MisMatch
 603++8C14 ~            		inc hl
 604++8C14 ~            		inc de
 605++8C14 ~            		djnz Compare
 606++8C14 ~            MisMatch:
 607++8C14 ~            	pop de
 608++8C14 ~            	pop hl
 609++8C14 ~            	ret
 610++8C14 ~
 611++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612++8C14 ~
 613++8C14 ~            ;Read a file into a buffer, sector by sector.
 614++8C14 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 615++8C14 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 616++8C14 ~            ;In: HL = Name address, DE = buffer
 617++8C14 ~            IF1FileLoad:
 618++8C14 ~            	push	de
 619++8C14 ~            		ld (FSTR1), hl
 620++8C14 ~            		ld h, 0
 621++8C14 ~            		ld a, (RWTSDrive)
 622++8C14 ~            		inc  a			;CP/M drive number to BASIC drive number
 623++8C14 ~            		ld	l, a
 624++8C14 ~            		ld (DSTR1), hl
 625++8C14 ~            		ld l,NAMELEN
 626++8C14 ~            		ld (NSTR1), hl
 627++8C14 ~            		rst 08
 628++8C14 ~            		DEFB 51			;open disk channel
 629++8C14 ~
 630++8C14 ~            		rst		8
 631++8C14 ~            		defb	53		;read sector
 632++8C14 ~            	pop		de
 633++8C14 ~            	jr		nc, FileFree
 634++8C14 ~
 635++8C14 ~            	ld		a, (ix + CH_DATA)
 636++8C14 ~            	cp		TEXT_TYPE
 637++8C14 ~            	jr		nc, FileLoadNoHeader
 638++8C14 ~
 639++8C14 ~            FileLoadHeader:
 640++8C14 ~            	push	ix
 641++8C14 ~            	pop		hl
 642++8C14 ~            	ld		bc, CH_DATA + HDR_SZ
 643++8C14 ~            	add		hl, bc
 644++8C14 ~            	ld		bc, SECT_SZ - HDR_SZ
 645++8C14 ~            	ldir
 646++8C14 ~
 647++8C14 ~            FileReadLoop:
 648++8C14 ~            	push	de
 649++8C14 ~            		rst		8
 650++8C14 ~            		defb	53		;read sector
 651++8C14 ~            	pop		de
 652++8C14 ~            	jr		nc, FileFree
 653++8C14 ~
 654++8C14 ~            FileLoadNoHeader:
 655++8C14 ~            	push	ix
 656++8C14 ~            	pop		hl
 657++8C14 ~            	ld		bc, CH_DATA
 658++8C14 ~            	add		hl, bc
 659++8C14 ~            	ld		bc, SECT_SZ
 660++8C14 ~            	ldir
 661++8C14 ~            	jr		FileReadLoop
 662++8C14 ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663++8C14 ~            IF1FileLoadEnd:
 664++8C14 ~
 665++8C14 ~            FileFree:
 666++8C14 ~            	push	de
 667++8C14 ~            	rst		8
 668++8C14 ~            	defb	56			;close channel (52) or detroy channel (56)
 669++8C14 ~            	pop		de
 670++8C14 ~            	ret
 671++8C14 ~
 672++8C14 ~
 673++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674++8C14 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 675++8C14 ~            ;Out: A = error code, 0=OK
 676++8C14 ~            ReadDiskSectors:
 677++8C14 ~            	push bc
 678++8C14 ~            		push hl
 679++8C14 ~            			push de
 680++8C14 ~            				call ReadOneDiskSector
 681++8C14 ~            			pop de
 682++8C14 ~            		pop hl
 683++8C14 ~
 684++8C14 ~            		inc d
 685++8C14 ~            		inc h
 686++8C14 ~            	pop bc
 687++8C14 ~
 688++8C14 ~            	ld	a, (RWTSRes)
 689++8C14 ~            	or	a
 690++8C14 ~            	ret nz
 691++8C14 ~
 692++8C14 ~            	djnz ReadDiskSectors
 693++8C14 ~            	ret
 694++8C14 ~
 695++8C14 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 696++8C14 ~            ;Out: A = error code, 0=OK
 697++8C14 ~            WriteDiskSectors:
 698++8C14 ~            	push bc
 699++8C14 ~            		push hl
 700++8C14 ~            			push de
 701++8C14 ~            				call WriteOneDiskSector
 702++8C14 ~            			pop de
 703++8C14 ~            		pop hl
 704++8C14 ~
 705++8C14 ~            		inc d
 706++8C14 ~            		inc h
 707++8C14 ~            	pop bc
 708++8C14 ~
 709++8C14 ~            	ld	a, (RWTSRes)
 710++8C14 ~            	or	a
 711++8C14 ~            	ret nz
 712++8C14 ~
 713++8C14 ~            	djnz WriteDiskSectors
 714++8C14 ~            	ret
 715++8C14 ~
 716++8C14 ~
 717++8C14 ~            ;Reads disk catalog
 718++8C14 ~            ReadCatalogTrack:
 719++8C14 ~            	ld hl, TrackBuf
 720++8C14 ~            	ld de, 0
 721++8C14 ~            	ld b, SPT
 722++8C14 ~
 723++8C14 ~            	call ReadDiskSectors
 724++8C14 ~            	or   a
 725++8C14 ~            	ret  nz
 726++8C14 ~
 727++8C14 ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 728++8C14 ~            	push  af
 729++8C14 ~            		ld  a, (RWTSDrive)
 730++8C14 ~            		call BDOSSelectDisk
 731++8C14 ~            		call BDOSInit
 732++8C14 ~            	pop   af
 733++8C14 ~            	ret
 734++8C14 ~
 735++8C14 ~
 736++8C14 ~
 737++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738++8C14 ~
 739++8C14 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740++8C14 ~            FindCache:
 741++8C14 ~            	ld		b, NAMELEN
 742++8C14 ~            	call	StrCmp			;find the file to wich this extension belongs
 743++8C14 ~            	ret		z
 744++8C14 ~
 745++8C14 ~            	dec		c
 746++8C14 ~            	jr		nz, CacheNotFinished
 747++8C14 ~            	or		c
 748++8C14 ~            	ret
 749++8C14 ~
 750++8C14 ~            CacheNotFinished:
 751++8C14 ~            	ld		bc, CACHE_SZ
 752++8C14 ~            	add		hl, bc			;to the next cache line
 753++8C14 ~            	jr		FindCache
 754++8C14 ~
 755++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756++8C14 ~
 757++8C14 ~            	;ld		ix, (SelFileCache)
 758++8C14 ~            ReadFileHeader:
 759++8C14 ~            	ld		a, (ix + CACHE_FLAG)
 760++8C14 ~            	or		a
 761++8C14 ~            	ret		nz				;return if already read
 762++8C14 ~
 763++8C14 ~            	ld		l, (ix + CACHE_FIRST_AU)
 764++8C14 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 765++8C14 ~            	ld		a, h
 766++8C14 ~            	or		l
 767++8C14 ~            	jr		z, ReadHeaderEnd
 768++8C14 ~
 769++8C14 ~            	call	AU2TS
 770++8C14 ~            	ld		d, b
 771++8C14 ~            	ld		e, c
 772++8C14 ~            	ld		hl, DataBuf
 773++8C14 ~            	push	ix
 774++8C14 ~            	push	ix
 775++8C14 ~            		call	ReadOneDiskSector
 776++8C14 ~            	pop		hl
 777++8C14 ~            	pop		ix
 778++8C14 ~
 779++8C14 ~            	push	hl
 780++8C14 ~            		ld		hl, DataBuf
 781++8C14 ~            		call	IsFileHeaderValid
 782++8C14 ~            	pop		hl
 783++8C14 ~            	or		a
 784++8C14 ~            	jr		z, ReadFileHeaderIsTextFile
 785++8C14 ~
 786++8C14 ~            	ld		bc, CACHE_HDR
 787++8C14 ~            	add		hl, bc
 788++8C14 ~            	ex		hl, de
 789++8C14 ~            	ld		hl, DataBuf
 790++8C14 ~            	ld		bc, HDR_SZ
 791++8C14 ~            	ldir
 792++8C14 ~
 793++8C14 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 794++8C14 ~            	ld		a, BYTE_TYPE
 795++8C14 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 796++8C14 ~            	jr		nc, ReadHeaderEnd
 797++8C14 ~
 798++8C14 ~            ReadFileHeaderIsTextFile:
 799++8C14 ~            	push	ix
 800++8C14 ~            	push	ix
 801++8C14 ~            	pop		hl
 802++8C14 ~            		call	GetFileSize
 803++8C14 ~            	pop		ix
 804++8C14 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 805++8C14 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806++8C14 ~            	ld		a, TEXT_TYPE
 807++8C14 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808++8C14 ~
 809++8C14 ~            ReadHeaderEnd:
 810++8C14 ~            	inc		(ix + CACHE_FLAG)
 811++8C14 ~            	ret
 812++8C14 ~
 813++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814++8C14 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 815++8C14 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816++8C14 ~            ;In: HL = header
 817++8C14 ~            ;Out: A > 0 if valid
 818++8C14 ~            IsFileHeaderValid:
 819++8C14 ~            	IFUSED
 820++8C14 ~            	xor		a
 821++8C14 ~            	ld		b, HDR_SZ
 822++8C14 ~            IsFileHeaderValidLoop:
 823++8C14 ~            	or		(hl)
 824++8C14 ~            	inc		hl
 825++8C14 ~            	djnz	IsFileHeaderValidLoop
 826++8C14 ~
 827++8C14 ~            	ret
 828++8C14 ~            	ENDIF
 829++8C14 ~
 830++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831++8C14 ~
 832++8C14 ~            ;IN: HL = address from IF1 to call
 833++8C14 ~            IF1Call:
 834++8C14 ~            	LD   (HD11), HL
 835++8C14 ~            	RST  8
 836++8C14 ~            	DEFB 50
 837++8C14 ~            	RET
 838++8C14 ~
 839++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840++8C14 ~
 841++8C14 ~            ;Load a program from disk
 842++8C14 ~            ;IN: HL = file name addr
 843++8C14 ~            LoadProgram:
 844++8C14 ~            	LD   (FSTR1), HL
 845++8C14 ~            	LD   H, 0
 846++8C14 ~            	LD   L, NAMELEN
 847++8C14 ~            	LD   (NSTR1), HL
 848++8C14 ~            	LD	 A, (RWTSDrive)
 849++8C14 ~            	INC  A					;Adapt for BASIC drive number
 850++8C14 ~            	LD   L, A
 851++8C14 ~            	LD   (DSTR1), HL
 852++8C14 ~            	LD   HL, LOAD_ADDR
 853++8C14 ~            	CALL IF1Call
 854++8C14 ~            	RET
 855++8C14 ~
 856++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857++8C14 ~
 858++8C14 ~            SetFastKeys:
 859++8C14 ~            	ld		hl, REPDEL
 860++8C14 ~            	ld		de, (1 << 8) | 15
 861++8C14 ~            	ld		(hl), de
 862++8C14 ~
 863++8C14 ~            	ret
 864++8C14 ~
 865++8C14 ~
 866++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867++8C14 ~            ;Reads the error message string from IF1 ROM.
 868++8C14 ~            GetErrMsg:
 869++8C14 ~            	inc		a
 870++8C14 ~            	ex		af, af'
 871++8C14 ~
 872++8C14 ~            	ld		hl, IF1Paged			;page-in IF1
 873++8C14 ~            	jp		IF1Call
 874++8C14 ~
 875++8C14 ~            IF1Paged:
 876++8C14 ~            	ld		hl, ERRMSG
 877++8C14 ~            	ex		af, af'
 878++8C14 ~            	or		a
 879++8C14 ~            	jr		z, SaveMsg
 880++8C14 ~
 881++8C14 ~            	ld		b, 0
 882++8C14 ~            SearchMsgEnd:
 883++8C14 ~            	bit		7, (hl)
 884++8C14 ~            	inc		hl
 885++8C14 ~            	jr		z, SearchMsgEnd
 886++8C14 ~
 887++8C14 ~            	inc		b
 888++8C14 ~            	cp		b
 889++8C14 ~            	jr		nz, SearchMsgEnd
 890++8C14 ~
 891++8C14 ~            SaveMsg:
 892++8C14 ~            	ld		de, DataBuf
 893++8C14 ~            CopyMsg:
 894++8C14 ~            	ld		a, (hl)
 895++8C14 ~            	bit		7, a
 896++8C14 ~            	ld		(de), a
 897++8C14 ~            	inc		hl
 898++8C14 ~            	inc		de
 899++8C14 ~            	jr		z, CopyMsg
 900++8C14 ~
 901++8C14 ~            	ret
 902++8C14 ~
 903++8C14 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904++8C14 ~
 905++8C14 ~            ;RWTS routine I/O block
 906++8C14 ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 907++8C14 ~            RWTSParams:
 908++8C14 ~            RWTSBlockType	DEFB	1							;?
 909++8C14 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 910++8C14 ~            RWTSVolNo		DEFB	0							;?
 911++8C14 ~            RWTSTrack		DEFB	0
 912++8C14 ~            RWTSSector		DEFB	0
 913++8C14 ~            RWTSDMA			DEFW	0
 914++8C14 ~            RWTSExtBuf		DEFW	$2932
 915++8C14 ~            RWTSPrmTbl		DEFW	$1f2a
 916++8C14 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 917++8C14 ~            ;Results
 918++8C14 ~            RWTSRes			DEFB	0
 919++8C14 ~            RWTSResVolNo	DEFB	0
 920++8C14 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 921++8C14 ~
 922++8C14 ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 923++8C14 ~            /*
 924++8C14 ~            BasPrmTbl:
 925++8C14 ~            PrmDevType		DEFB	$01			;$01
 926++8C14 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 927++8C14 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 928++8C14 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 929++8C14 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 930++8C14 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 931++8C14 ~            */
 932++8C14 ~
 933++8C14              	endif
# file closed: if1.asm
  15+ 8C14
  16+ 8C14              BDOSInit:
  17+ 8C14 AF           	xor		a
  18+ 8C15 18 3D        	jr		BDOS
  19+ 8C17
  20+ 8C17
  21+ 8C17              ;IN: A = Drive to select
  22+ 8C17              BDOSSelectDisk:
  23+ 8C17              	IFUSED
  24+ 8C17 DD 6F        	ld		ixl, a
  25+ 8C19 DD 26 00     	ld		ixh, 0
  26+ 8C1C 3E 01        	ld		a, 1
  27+ 8C1E 18 34        	jr		BDOS
  28+ 8C20              	ENDIF
  29+ 8C20
  30+ 8C20
  31+ 8C20              BDOSMakeDiskRO:
  32+ 8C20              	IFUSED
  33+ 8C20 ~            	ld		a, 15
  34+ 8C20 ~            	jr		BDOS
  35+ 8C20              	ENDIF
  36+ 8C20
  37+ 8C20              ;Get Read Only flag
  38+ 8C20              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 8C20              BDOSGetDiskRO:
  40+ 8C20              	IFUSED
  41+ 8C20 ~            	ld	a, 16
  42+ 8C20 ~            	jr	BDOS
  43+ 8C20              	ENDIF
  44+ 8C20
  45+ 8C20              BDOSGetCurrentDisk:
  46+ 8C20              	IFUSED
  47+ 8C20 ~            	ld		a, 12
  48+ 8C20 ~            	jr		BDOS
  49+ 8C20              	ENDIF
  50+ 8C20
  51+ 8C20
  52+ 8C20              ;Create a disk channel for BDOS access (does not open the file)
  53+ 8C20              ;IN: HL=name addr, A=drive
  54+ 8C20              ;OUT: IX=FCB
  55+ 8C20              CreateChannel:
  56+ 8C20 22 DC 5C     	ld (FSTR1), hl
  57+ 8C23 26 00        	ld h,0
  58+ 8C25 6F           	ld l,a
  59+ 8C26 22 D6 5C     	ld (DSTR1), hl
  60+ 8C29 2E 0B        	ld l,NAMELEN
  61+ 8C2B 22 DA 5C     	ld (NSTR1), hl
  62+ 8C2E CF           	rst 08
  63+ 8C2F 37           	DEFB 55
  64+ 8C30 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 8C33 DD 09        	add ix, bc
  66+ 8C35 C9           	ret
  67+ 8C36
  68+ 8C36
  69+ 8C36              ;Destroy a BDOS channel
  70+ 8C36              ;IN: IX=FCB
  71+ 8C36              DestroyChannel:
  72+ 8C36 C5           	push bc
  73+ 8C37 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 8C3A DD 09        	add ix, bc
  75+ 8C3C CF           	rst 08
  76+ 8C3D 38           	DEFB 56
  77+ 8C3E C1           	pop bc
  78+ 8C3F C9           	ret
  79+ 8C40
  80+ 8C40
  81+ 8C40              ;Input: IX=FCB
  82+ 8C40              CreateFile:
  83+ 8C40 3E 09        	ld	a, 9
  84+ 8C42 18 10        	jr	BDOS
  85+ 8C44
  86+ 8C44              ;Input: IX=FCB
  87+ 8C44              OpenFile:
  88+ 8C44 3E 02        	ld	a, 2
  89+ 8C46 18 0C        	jr	BDOS
  90+ 8C48
  91+ 8C48              ;IN: IX=FCB
  92+ 8C48              CloseFile:
  93+ 8C48 3E 03        	ld	a, 3
  94+ 8C4A 18 08        	jr	BDOS
  95+ 8C4C
  96+ 8C4C              ;IN: IX=FCB
  97+ 8C4C              ReadFileBlock:
  98+ 8C4C 3E 07        	ld	a, 7
  99+ 8C4E 18 04        	jr	BDOS
 100+ 8C50
 101+ 8C50              ;IN: IX=FCB
 102+ 8C50              WriteFileBlock:
 103+ 8C50 3E 08        	ld	a, 8
 104+ 8C52 18 00        	jr	BDOS
 105+ 8C54
 106+ 8C54              ;Generic BDOS call
 107+ 8C54              ;IX=arg, A=function
 108+ 8C54              BDOS:
 109+ 8C54 DD 22 ED 5C  	ld (HD11), ix
 110+ 8C58 32 EF 5C     	ld (COPIES), a
 111+ 8C5B CF           	rst 08
 112+ 8C5C 39           	DEFB 57
 113+ 8C5D C9           	ret
 114+ 8C5E
 115+ 8C5E              ;Set DMA address for BDOS
 116+ 8C5E              ;IX=DMA
 117+ 8C5E              BDOSSetDMA:
 118+ 8C5E 3E 0D        	ld a, 13
 119+ 8C60 18 F2        	jr BDOS
 120+ 8C62
 121+ 8C62
 122+ 8C62              ;In: HL=filename
 123+ 8C62              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 124+ 8C62              GetFileSize:
 125+ 8C62              	IFUSED
 126+ 8C62
 127+ 8C62 3A 02 8C     	ld 		a, (RWTSDrive)
 128+ 8C65 3C           	inc		a					;Convert to BASIC drive number: 1,2
 129+ 8C66 CD 20 8C     	call	CreateChannel
 130+ 8C69
 131+ 8C69 3E 14        	ld		a, 20
 132+ 8C6B CD 54 8C     	call	BDOS
 133+ 8C6E              	;inc		a
 134+ 8C6E              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 135+ 8C6E
 136+ 8C6E DD 6E 21     	ld		l, (ix + FCB_R0)
 137+ 8C71 DD 66 22     	ld		h, (ix + FCB_R1)
 138+ 8C74
 139+ 8C74              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 140+ 8C74 3E 01        	ld		a, 1
 141+ 8C76 BC           	cp		h
 142+ 8C77 30 05        	jr		nc, GetFileSizeOK
 143+ 8C79 21 00 00     	ld		hl, 0
 144+ 8C7C 18 08        	jr		GetFileSizeEnd
 145+ 8C7E
 146+ 8C7E              GetFileSizeOK:
 147+ 8C7E              	;*128 == 2^7
 148+ 8C7E 06 07        	ld		b, 7
 149+ 8C80              GetFileSizeMul:
 150+ 8C80 CB 15        	rl		l
 151+ 8C82 CB 14        	rl		h
 152+ 8C84 10 FA        	djnz	GetFileSizeMul
 153+ 8C86
 154+ 8C86              GetFileSizeEnd:
 155+ 8C86 E5           	push	hl
 156+ 8C87 CD 36 8C     		call	DestroyChannel
 157+ 8C8A E1           	pop		hl
 158+ 8C8B
 159+ 8C8B C9           	ret
 160+ 8C8C              	ENDIF
 161+ 8C8C
 162+ 8C8C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 163+ 8C8C              ;HL=file name, A=drive
 164+ 8C8C              DeleteFile:
 165+ 8C8C CD 20 8C     	call	CreateChannel
 166+ 8C8F
 167+ 8C8F 3E 06        	ld		a, 6
 168+ 8C91 CD 54 8C     	call	BDOS
 169+ 8C94
 170+ 8C94 CD 36 8C     	call	DestroyChannel
 171+ 8C97 C9           	ret
 172+ 8C98
 173+ 8C98              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 8C98              ;Returns A > 0 if the file exists
 175+ 8C98              ;HL=file name, A=drive
 176+ 8C98              DoesFileExist:
 177+ 8C98              	IFUSED
 178+ 8C98 CD 20 8C     	call	CreateChannel
 179+ 8C9B
 180+ 8C9B 3E 04        	ld		a, 4
 181+ 8C9D CD 54 8C     	call	BDOS
 182+ 8CA0
 183+ 8CA0 F5           	push	af
 184+ 8CA1 CD 36 8C     		call	DestroyChannel
 185+ 8CA4 F1           	pop		af
 186+ 8CA5 C9           	ret
 187+ 8CA6              	ENDIF
 188+ 8CA6
 189+ 8CA6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 190+ 8CA6              ;IN: E0 = RO, E1 = SYS, HL=filename
 191+ 8CA6              ChangeFileAttrib:
 192+ 8CA6 3A 02 8C     	ld 		a, (RWTSDrive)
 193+ 8CA9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 194+ 8CAA D5           	push	de
 195+ 8CAB CD 20 8C     	call	CreateChannel
 196+ 8CAE D1           	pop		de
 197+ 8CAF
 198+ 8CAF DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 199+ 8CB2 CB 27        	sla		a								;reset existing attribute flag
 200+ 8CB4 CB 1B        	rr		e								;put wanted flag in Carry flag
 201+ 8CB6 CB 1F        	rr		a								;put Carry flag in register L
 202+ 8CB8 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 203+ 8CBB
 204+ 8CBB DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 205+ 8CBE CB 27        	sla		a
 206+ 8CC0 CB 1B        	rr		e
 207+ 8CC2 CB 1F        	rr		a
 208+ 8CC4 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 209+ 8CC7
 210+ 8CC7              FileAttribSet:
 211+ 8CC7 3E 11        	ld		a, 17
 212+ 8CC9 CD 54 8C     	call	BDOS
 213+ 8CCC
 214+ 8CCC CD 36 8C     	call	DestroyChannel
 215+ 8CCF C9           	ret
 216+ 8CD0
 217+ 8CD0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 8CD0
 219+ 8CD0              ;HL=original name, DE = new name
 220+ 8CD0              ;Works only on the same drive.
 221+ 8CD0              RenameFile:
 222+ 8CD0 3A 02 8C     	ld 		a, (RWTSDrive)
 223+ 8CD3 3C           	inc		a					;Convert to BASIC drive number: 1,2
 224+ 8CD4 D5           	push	de
 225+ 8CD5 CD 20 8C     	call	CreateChannel
 226+ 8CD8 D1           	pop		de
 227+ 8CD9
 228+ 8CD9 DD E5        	push	ix					;IX == FCB
 229+ 8CDB E1           	pop		hl
 230+ 8CDC 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 231+ 8CDF 09           	add		hl, bc
 232+ 8CE0 EB           	ex		de, hl
 233+ 8CE1 3A 02 8C     	ld		a, (RWTSDrive)
 234+ 8CE4 12           	ld		(de), a
 235+ 8CE5 01 0B 00     	ld		bc, NAMELEN
 236+ 8CE8 ED B0        	ldir
 237+ 8CEA
 238+ 8CEA 3E 0A        	ld		a, 10
 239+ 8CEC CD 54 8C     	call	BDOS
 240+ 8CEF
 241+ 8CEF CD 36 8C     	call	DestroyChannel
 242+ 8CF2 C9           	ret
 243+ 8CF3
 244+ 8CF3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 8CF3
 246+ 8CF3              ;Will copy a file from A: to B: or vice versa.
 247+ 8CF3              ;HL=source file name
 248+ 8CF3              CopyFile:
 249+ 8CF3              	;Prepare source file
 250+ 8CF3 E5           	push hl
 251+ 8CF4 3A 02 8C     		ld 		a, (RWTSDrive)
 252+ 8CF7 3C           		inc		a					;Convert to BASIC drive number: 1,2
 253+ 8CF8 CD 20 8C     		call	CreateChannel
 254+ 8CFB CD 44 8C     		call 	OpenFile
 255+ 8CFE DD 22 20 A5  		ld		(CopyFileFCBSrc), ix
 256+ 8D02 E1           	pop hl
 257+ 8D03 3C           	inc  	a						;Cancel if A==$FF
 258+ 8D04 28 75        	jr   	z, CopyFileEnd
 259+ 8D06
 260+ 8D06              	;Create destination file
 261+ 8D06 DD 7E 00     	ld		a, (ix)
 262+ 8D09 EE 03        	xor		%11						;Alternate drive, A->B, B-A
 263+ 8D0B F5           	push	af
 264+ 8D0C E5           	push	hl
 265+ 8D0D CD 8C 8C     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 266+ 8D10 E1           	pop		hl
 267+ 8D11 F1           	pop		af
 268+ 8D12 CD 20 8C     	call	CreateChannel
 269+ 8D15 CD 40 8C     	call 	CreateFile
 270+ 8D18 DD 22 22 A5  	ld		(CopyFileFCBDst), ix
 271+ 8D1C 3C           	inc  	a						;Cancel if A==$FF
 272+ 8D1D 28 5C        	jr   	z, CopyFileEnd
 273+ 8D1F
 274+ 8D1F              FileCopyLoop:
 275+ 8D1F 06 59        	ld		b, MAX_SECT_RAM
 276+ 8D21 DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 277+ 8D25 21 28 A5     	ld		hl, CopyFileDMA
 278+ 8D28 DD 75 00     	ld		(ix), l
 279+ 8D2B DD 74 01     	ld		(ix+1), h
 280+ 8D2E              FileCopyReadLoop:
 281+ 8D2E C5           	push	bc
 282+ 8D2F DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 283+ 8D33 CD 5E 8C     		call 	BDOSSetDMA
 284+ 8D36 DD 24        		inc		ixh
 285+ 8D38 DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 286+ 8D3C
 287+ 8D3C DD 2A 20 A5  		ld		ix, (CopyFileFCBSrc)
 288+ 8D40 CD 4C 8C     		call 	ReadFileBlock
 289+ 8D43 B7           		or		a
 290+ 8D44 32 24 A5     		ld		(CopyFileResRead), a
 291+ 8D47 C1           	pop		bc
 292+ 8D48 20 02        	jr		nz, FileCopyWrite
 293+ 8D4A 10 E2        	djnz	FileCopyReadLoop
 294+ 8D4C
 295+ 8D4C              FileCopyWrite:
 296+ 8D4C DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 297+ 8D50 21 28 A5     	ld		hl, CopyFileDMA
 298+ 8D53 DD 75 00     	ld		(ix), l
 299+ 8D56 DD 74 01     	ld		(ix+1), h
 300+ 8D59
 301+ 8D59              	;Calculate how many sectors were read.
 302+ 8D59 3E 59        	ld		a, MAX_SECT_RAM
 303+ 8D5B 90           	sub		b
 304+ 8D5C 47           	ld		b, a
 305+ 8D5D
 306+ 8D5D              FileCopyWriteLoop:
 307+ 8D5D C5           	push	bc
 308+ 8D5E DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 309+ 8D62 CD 5E 8C     		call 	BDOSSetDMA
 310+ 8D65 DD 24        		inc		ixh
 311+ 8D67 DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 312+ 8D6B
 313+ 8D6B DD 2A 22 A5  		ld		ix, (CopyFileFCBDst)
 314+ 8D6F CD 50 8C     		call	WriteFileBlock
 315+ 8D72 B7           		or		a
 316+ 8D73 32 25 A5     		ld		(CopyFileResWrite), a
 317+ 8D76 C1           	pop		bc
 318+ 8D77 20 02        	jr		nz, CopyFileEnd
 319+ 8D79 10 E2        	djnz	FileCopyWriteLoop
 320+ 8D7B
 321+ 8D7B              CopyFileEnd:
 322+ 8D7B              	;Check if file ended, if not, continue copying.
 323+ 8D7B 3A 24 A5     	ld		a, (CopyFileResRead)
 324+ 8D7E B7           	or		a
 325+ 8D7F 28 9E        	jr		z, FileCopyLoop
 326+ 8D81
 327+ 8D81 DD 2A 22 A5  	ld		ix, (CopyFileFCBDst)
 328+ 8D85 CD 48 8C     	call 	CloseFile				;close destination file
 329+ 8D88 CD 36 8C     	call 	DestroyChannel
 330+ 8D8B
 331+ 8D8B              	;Don't need to close source file, but must free channel
 332+ 8D8B DD 2A 20 A5  	ld		ix, (CopyFileFCBSrc)
 333+ 8D8F CD 36 8C     	call 	DestroyChannel
 334+ 8D92
 335+ 8D92 3A 25 A5     	ld		a, (CopyFileResWrite)
 336+ 8D95
 337+ 8D95 C9           	ret
 338+ 8D96
 339+ 8D96              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 340+ 8D96              ;Reads part of a file
 341+ 8D96              ;In: HL = name, DE = file offset in bytes
 342+ 8D96              ;Out: FileData = read buffer, DE = end of file
 343+ 8D96              ReadFileSection:
 344+ 8D96 3A 02 8C     	ld 		a, (RWTSDrive)
 345+ 8D99 3C           	inc		a					;Convert to BASIC drive number: 1,2
 346+ 8D9A CD 20 8C     	call	CreateChannel
 347+ 8D9D CD 44 8C     	call 	OpenFile
 348+ 8DA0 DD 22 20 A5  	ld		(CopyFileFCBSrc), ix
 349+ 8DA4 3C           	inc  	a						;Cancel if A==$FF
 350+ 8DA5 C8           	ret		z
 351+ 8DA6
 352+ 8DA6              	;Limit max sectors to read to leave space for the index too.
 353+ 8DA6 06 51        	ld		b, FileDataSize/SECT_SZ
 354+ 8DA8              	;Set destination memory pointer.
 355+ 8DA8 DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 356+ 8DAC 21 20 A6     	ld		hl, FileData
 357+ 8DAF DD 75 00     	ld		(ix), l
 358+ 8DB2 DD 74 01     	ld		(ix+1), h
 359+ 8DB5              ReadFileSectionLoop:
 360+ 8DB5 C5           	push	bc
 361+ 8DB6 DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 362+ 8DBA CD 5E 8C     		call 	BDOSSetDMA
 363+ 8DBD DD 24        		inc		ixh
 364+ 8DBF DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 365+ 8DC3
 366+ 8DC3 DD 2A 20 A5  		ld		ix, (CopyFileFCBSrc)
 367+ 8DC7 CD 4C 8C     		call 	ReadFileBlock
 368+ 8DCA B7           		or		a
 369+ 8DCB 32 24 A5     		ld		(CopyFileResRead), a
 370+ 8DCE C1           	pop		bc
 371+ 8DCF 20 02        	jr		nz, ReadFileSectionEnd
 372+ 8DD1 10 E2        	djnz	ReadFileSectionLoop
 373+ 8DD3
 374+ 8DD3              ReadFileSectionEnd:
 375+ 8DD3 DD 2A 20 A5  	ld		ix, (CopyFileFCBSrc)
 376+ 8DD7 CD 36 8C     	call 	DestroyChannel
 377+ 8DDA
 378+ 8DDA ED 5B 26 A5  	ld		de, (CopyFileDMAAddr)
 379+ 8DDE 15           	dec		d
 380+ 8DDF C9           	ret
 381+ 8DE0
 382+ 8DE0              	ENDIF
 383+ 8DE0
# file closed: bdos.asm
1327  8DE0              	include "ui.asm"
# file opened: ui.asm
   1+ 8DE0              ;UI related functions
   2+ 8DE0
   3+ 8DE0              	ifndef	_UI_
   4+ 8DE0              	define	_UI_
   5+ 8DE0
   6+ 8DE0              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++8DE0              	ifndef	_HCCFG_
   2++8DE0 ~            	define	_HCCFG_
   3++8DE0 ~
   4++8DE0 ~            ;HC specific code, for configuration
   5++8DE0 ~
   6++8DE0 ~            HC_CFG_PORT			EQU	$7E
   7++8DE0 ~
   8++8DE0 ~            ;BASIC/CPM ROM selection
   9++8DE0 ~            HC_CFG_ROM_BAS		EQU	%0
  10++8DE0 ~            HC_CFG_ROM_CPM		EQU	%1
  11++8DE0 ~
  12++8DE0 ~            ;Address for ROM paging: 0 or $E000
  13++8DE0 ~            HC_CFG_ROM_0000		EQU %00
  14++8DE0 ~            HC_CFG_ROM_E000		EQU %10
  15++8DE0 ~
  16++8DE0 ~            ;Cfg. port Enable/Disable
  17++8DE0 ~            HC_CFG_PORT_DIS		EQU %000
  18++8DE0 ~            HC_CFG_PORT_EN		EQU	%100
  19++8DE0 ~
  20++8DE0 ~            ;Video memory bank: $4000 or $C000
  21++8DE0 ~            HC_CFG_VID_4000		EQU	%0000
  22++8DE0 ~            HC_CFG_VID_C000		EQU	%1000
  23++8DE0 ~
  24++8DE0 ~
  25++8DE0 ~            ;Standar BASIC config
  26++8DE0 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++8DE0 ~            ;Standar CP/M config
  28++8DE0 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++8DE0 ~
  30++8DE0 ~
  31++8DE0 ~            HC_VID_BANK0		EQU	$4000
  32++8DE0 ~            HC_VID_BANK1		EQU	$C000
  33++8DE0 ~
  34++8DE0              	endif
# file closed: hccfg.asm
   7+ 8DE0
   8+ 8DE0              COL             EQU 23728
   9+ 8DE0              LINE            EQU 23729               ;Coordinates
  10+ 8DE0              LineCol			EQU	COL
  11+ 8DE0              CODE			EQU 23681               ;Char to print
  12+ 8DE0
  13+ 8DE0              CPM_FNT         EQU $25AB
  14+ 8DE0
  15+ 8DE0              PORT_ZX			EQU	$FE
  16+ 8DE0
  17+ 8DE0              ;COLORS
  18+ 8DE0              CLR_BLACK		EQU 0
  19+ 8DE0              CLR_BLUE		EQU 1
  20+ 8DE0              CLR_RED			EQU 2
  21+ 8DE0              CLR_MAGENTA		EQU 3
  22+ 8DE0              CLR_GREEN		EQU 4
  23+ 8DE0              CLR_CYAN		EQU	5
  24+ 8DE0              CLR_YELLOW		EQU	6
  25+ 8DE0              CLR_WHITE		EQU	7
  26+ 8DE0              CLR_BRIGHT		EQU	%01000000
  27+ 8DE0              CLR_FLASH		EQU	%10000000
  28+ 8DE0
  29+ 8DE0              ;PAPER
  30+ 8DE0              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 8DE0              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 8DE0              PAPER_RED		EQU (CLR_RED << 3)
  33+ 8DE0              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 8DE0              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 8DE0              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 8DE0              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 8DE0              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 8DE0
  39+ 8DE0              ;INK
  40+ 8DE0              INK_BLACK		EQU CLR_BLACK
  41+ 8DE0              INK_BLUE		EQU CLR_BLUE
  42+ 8DE0              INK_RED			EQU CLR_RED
  43+ 8DE0              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 8DE0              INK_GREEN		EQU CLR_GREEN
  45+ 8DE0              INK_CYAN		EQU	CLR_CYAN
  46+ 8DE0              INK_YELLOW		EQU	CLR_YELLOW
  47+ 8DE0              INK_WHITE		EQU	CLR_WHITE
  48+ 8DE0
  49+ 8DE0
  50+ 8DE0              ;SCR_ATTR_ADDR	EQU 22528
  51+ 8DE0              SCR_PIX_LEN		EQU	6144
  52+ 8DE0              SCR_ATTR_LEN	EQU	768
  53+ 8DE0              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 8DE0              SCR_BYTES_PER_LINE	EQU	32
  55+ 8DE0
  56+ 8DE0              SCR_COLS		EQU	64
  57+ 8DE0              SCR_LINES		EQU 24
  58+ 8DE0
  59+ 8DE0              ;used for file names list positioning
  60+ 8DE0              LST_LINES_CNT	EQU	23
  61+ 8DE0              LST_FIRST_LINE	EQU	0
  62+ 8DE0              LST_PROG_INFO	EQU LST_FIRST_LINE
  63+ 8DE0              LST_DISK_INFO	EQU LST_PROG_INFO + 4
  64+ 8DE0              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  65+ 8DE0              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  66+ 8DE0              LST_FIRST_COL	EQU	16
  67+ 8DE0              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  68+ 8DE0
  69+ 8DE0              ;key codes
  70+ 8DE0              KEY_ESC			EQU	7
  71+ 8DE0              KEY_LEFT		EQU	8
  72+ 8DE0              KEY_RIGHT		EQU	9
  73+ 8DE0              KEY_DOWN		EQU	10
  74+ 8DE0              KEY_UP			EQU	11
  75+ 8DE0              KEY_BACKSP		EQU 12
  76+ 8DE0              KEY_ENTER		EQU	13
  77+ 8DE0              KEY_CTRL		EQU	14
  78+ 8DE0
  79+ 8DE0              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  80+ 8DE0              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  81+ 8DE0              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  82+ 8DE0
  83+ 8DE0              ;Special formating chars
  84+ 8DE0              CHR_CR			EQU	13
  85+ 8DE0              CHR_LF			EQU	10
  86+ 8DE0              CHR_TAB			EQU	09
  87+ 8DE0              CHR_EOF			EQU $1A
  88+ 8DE0
  89+ 8DE0
  90+ 8DE0              ;Semi-graphical chars
  91+ 8DE0              ;           UC
  92+ 8DE0              ;     UL +H-+--+UR
  93+ 8DE0              ;        |  |  |
  94+ 8DE0              ;     ML +--+--+MR
  95+ 8DE0              ;        V C|  |
  96+ 8DE0              ;     LL +--+--+LR
  97+ 8DE0              ;           DC
  98+ 8DE0              CHR_GRID        EQU 127
  99+ 8DE0              CHR_V           EQU	128
 100+ 8DE0              CHR_MR          EQU	129
 101+ 8DE0              CHR_UR          EQU 130
 102+ 8DE0              CHR_DL          EQU 131
 103+ 8DE0              CHR_DC          EQU 132
 104+ 8DE0              CHR_UC          EQU 133
 105+ 8DE0              CHR_ML          EQU 134
 106+ 8DE0              CHR_H           EQU 135
 107+ 8DE0              CHR_C           EQU 136
 108+ 8DE0              CHR_LR          EQU 137
 109+ 8DE0              CHR_UL          EQU 138
 110+ 8DE0              CHR_FULL        EQU 139
 111+ 8DE0              CHR_HALF        EQU 140
 112+ 8DE0
 113+ 8DE0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 114+ 8DE0
 115+ 8DE0              ;Return read char in A
 116+ 8DE0              ReadChar:
 117+ 8DE0 CF           	rst 08
 118+ 8DE1 1B           	DEFB 27
 119+ 8DE2 C9           	ret
 120+ 8DE3
 121+ 8DE3              ;Checks if a key is pressed
 122+ 8DE3              ;Cy=1 if key is pressed
 123+ 8DE3              KbdHit:
 124+ 8DE3 CF           	rst 08
 125+ 8DE4 20           	DEFB 32
 126+ 8DE5 C9           	ret
 127+ 8DE6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 128+ 8DE6
 129+ 8DE6              InitFonts:
 130+ 8DE6              	IFUSED
 131+ 8DE6                  ;page-in CPM ROM to get fonts
 132+ 8DE6 F3               di
 133+ 8DE7 3E 01            ld a, HC_CFG_ROM_CPM
 134+ 8DE9 D3 7E            out	(HC_CFG_PORT), a
 135+ 8DEB
 136+ 8DEB 21 AB 25     	ld		hl, CPM_FNT
 137+ 8DEE 11 B8 A1     	ld		de, FontTable
 138+ 8DF1 01 68 03     	ld		bc, 872
 139+ 8DF4 ED B0        	ldir
 140+ 8DF6
 141+ 8DF6                  ;restore BASIC ROM
 142+ 8DF6 3E 00            ld a, HC_CFG_ROM_BAS
 143+ 8DF8 D3 7E            out	(HC_CFG_PORT), a
 144+ 8DFA FB               ei
 145+ 8DFB
 146+ 8DFB C9           	ret
 147+ 8DFC              	ENDIF
 148+ 8DFC
 149+ 8DFC              ClrScr:
 150+ 8DFC 2A 9F 8F     	ld		hl, (CurrScrAddr)
 151+ 8DFF 54           	ld		d, h
 152+ 8E00 5D           	ld		e, l
 153+ 8E01 13           	inc		de
 154+ 8E02 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 155+ 8E05 36 00        	ld		(hl), 0
 156+ 8E07 ED B0        	ldir
 157+ 8E09
 158+ 8E09 23           	inc 	hl
 159+ 8E0A 13           	inc		de
 160+ 8E0B
 161+ 8E0B 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 162+ 8E0E 36 0F        	ld		(hl), SCR_DEF_CLR
 163+ 8E10 ED B0        	ldir
 164+ 8E12
 165+ 8E12              	;also set border color
 166+ 8E12 3E 01        	ld		a, SCR_DEF_CLR >> 3
 167+ 8E14 D3 FE        	out		(PORT_ZX), a
 168+ 8E16
 169+ 8E16 3E 0F        	ld		a, SCR_DEF_CLR
 170+ 8E18 32 48 5C     	ld		(23624), a
 171+ 8E1B C9           	ret
 172+ 8E1C
 173+ 8E1C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 8E1C              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 175+ 8E1C              PrintStr:
 176+ 8E1C 7E           	ld		a, (hl)
 177+ 8E1D FE 20        	cp		' '
 178+ 8E1F 30 02        	jr		nc, GoodChar
 179+ 8E21 3E 3F        	ld		a, '?'
 180+ 8E23              GoodChar:
 181+ 8E23 CB 7F        	bit		7, a
 182+ 8E25 CB BF        	res		7, a
 183+ 8E27 32 81 5C     	ld		(CODE), a
 184+ 8E2A ED 53 B0 5C  	ld		(LineCol), de
 185+ 8E2E 08           	ex		af, af'
 186+ 8E2F D9           	exx
 187+ 8E30 E5           	push	hl
 188+ 8E31 CD 1F 8F     	call 	PrintChar
 189+ 8E34 E1           	pop		hl
 190+ 8E35 D9           	exx
 191+ 8E36 08           	ex		af, af'
 192+ 8E37 C0           	ret		nz
 193+ 8E38
 194+ 8E38 1C           	inc		e
 195+ 8E39 23           	inc		hl
 196+ 8E3A
 197+ 8E3A 7B           	ld		a, e
 198+ 8E3B FE 40        	cp		64
 199+ 8E3D 38 DD        	jr		c, PrintStr
 200+ 8E3F 1E 00        	ld		e, 0
 201+ 8E41 14           	inc		d
 202+ 8E42
 203+ 8E42 18 D8        	jr		PrintStr
 204+ 8E44
 205+ 8E44              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 206+ 8E44
 207+ 8E44              ;IN: HL = string, DE = coords, A = color
 208+ 8E44              PrintStrClr:
 209+ 8E44 32 70 8E     	ld		(StrClr), a
 210+ 8E47 D5           	push	de
 211+ 8E48 CD 1C 8E     		call	PrintStr
 212+ 8E4B E1           	pop		hl
 213+ 8E4C              	;get string len.
 214+ 8E4C 7B           	ld		a, e
 215+ 8E4D 95           	sub		l
 216+ 8E4E 1F           	rra
 217+ 8E4F 08           	ex		af, af'
 218+ 8E50              		;line * 32
 219+ 8E50 7C           		ld		a, h
 220+ 8E51 17           		rla
 221+ 8E52 17           		rla
 222+ 8E53 11 00 00     		ld	de, 0
 223+ 8E56 17           		rla
 224+ 8E57 CB 12        		rl	d
 225+ 8E59 17           		rla
 226+ 8E5A CB 12        		rl	d
 227+ 8E5C 17           		rla
 228+ 8E5D CB 12        		rl	d
 229+ 8E5F 5F           		ld	e, a
 230+ 8E60
 231+ 8E60 26 00        		ld		h, 0
 232+ 8E62 19           		add		hl, de
 233+ 8E63 ED 5B A1 8F  		ld		de, (CurrScrAttrAddr)
 234+ 8E67 19           		add		hl, de
 235+ 8E68 08           	ex		af, af'
 236+ 8E69 4F           	ld		c, a
 237+ 8E6A 06 00        	ld		b, 0
 238+ 8E6C 54           	ld		d, h
 239+ 8E6D 5D           	ld		e, l
 240+ 8E6E 13           	inc 	de
 241+ 8E6F              StrClr	EQU	$ + 1
 242+ 8E6F 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 243+ 8E71 ED B0        	ldir
 244+ 8E73 C9           	ret
 245+ 8E74              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 246+ 8E74
 247+ 8E74              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 248+ 8E74              DrawLine:
 249+ 8E74 32 81 5C     	ld		(CODE), a
 250+ 8E77
 251+ 8E77 38 04        	jr		c, VertDir
 252+ 8E79 3E 1C        	ld		a, $1C
 253+ 8E7B 18 02        	jr		StoreDir
 254+ 8E7D              VertDir:
 255+ 8E7D 3E 14        	ld		a, $14
 256+ 8E7F              StoreDir:
 257+ 8E7F 32 8F 8E     	ld		(LineDir), a
 258+ 8E82
 259+ 8E82              DrawLineLoop:
 260+ 8E82 ED 53 B0 5C  	ld		(LineCol), de
 261+ 8E86 D5           	push	de
 262+ 8E87 D9           		exx
 263+ 8E88 E5           		push	hl
 264+ 8E89 CD 1F 8F     		call 	PrintChar
 265+ 8E8C E1           		pop		hl
 266+ 8E8D D9           		exx
 267+ 8E8E D1           	pop		de
 268+ 8E8F              LineDir:
 269+ 8E8F 1C           	inc		e
 270+ 8E90 10 F0        	djnz	DrawLineLoop
 271+ 8E92
 272+ 8E92 C9           	ret
 273+ 8E93
 274+ 8E93              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 275+ 8E93
 276+ 8E93              DrawHLine:
 277+ 8E93 32 A2 8E     	ld		(ChrParam), a
 278+ 8E96
 279+ 8E96 06 10        	ld		b, 16
 280+ 8E98 3E 87        	ld		a, CHR_H
 281+ 8E9A B7           	or		a
 282+ 8E9B CD 74 8E     	call	DrawLine
 283+ 8E9E
 284+ 8E9E 06 04        	ld		b, 4
 285+ 8EA0              DrawUpLine:
 286+ 8EA0 C5           	push	bc
 287+ 8EA1              ChrParam	EQU		$ + 1
 288+ 8EA1 3E 85        		ld		a, CHR_UC
 289+ 8EA3 D5           		push	de
 290+ 8EA4 CD D5 8E     			call	PrintChar2
 291+ 8EA7 D1           		pop		de
 292+ 8EA8 13           		inc		de
 293+ 8EA9
 294+ 8EA9 06 0B        		ld		b, NAMELEN
 295+ 8EAB 3E 87        		ld		a, CHR_H
 296+ 8EAD B7           		or		a
 297+ 8EAE CD 74 8E     		call	DrawLine
 298+ 8EB1 C1           	pop		bc
 299+ 8EB2 10 EC        	djnz	DrawUpLine
 300+ 8EB4
 301+ 8EB4 06 04        	ld		b, 4
 302+ 8EB6 3E 87        	ld		a, CHR_H
 303+ 8EB8 B7           	or		a
 304+ 8EB9 CD 74 8E     	call	DrawLine
 305+ 8EBC C9           	ret
 306+ 8EBD
 307+ 8EBD
 308+ 8EBD              DrawVLines:
 309+ 8EBD 06 04        	ld		b, 4
 310+ 8EBF 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 311+ 8EC2              DrawVLinesLoop:
 312+ 8EC2 C5           	push 	bc
 313+ 8EC3 D5           	push	de
 314+ 8EC4 06 17        		ld		b, LST_LINES_CNT
 315+ 8EC6 3E 80        		ld		a, CHR_V
 316+ 8EC8 37           		scf
 317+ 8EC9 CD 74 8E     		call	DrawLine
 318+ 8ECC D1           	pop		de
 319+ 8ECD C1           	pop	bc
 320+ 8ECE 7B           	ld		a, e
 321+ 8ECF C6 0C        	add		NAMELEN+1
 322+ 8ED1 5F           	ld		e, a
 323+ 8ED2 10 EE        	djnz	DrawVLinesLoop
 324+ 8ED4 C9           	ret
 325+ 8ED5
 326+ 8ED5              PrintChar2:
 327+ 8ED5 32 81 5C     	ld		(CODE), a
 328+ 8ED8 ED 53 B0 5C  	ld		(LineCol), de
 329+ 8EDC
 330+ 8EDC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 331+ 8EDC
 332+ 8EDC              ;IN: A = color mask
 333+ 8EDC              DrawCursor:
 334+ 8EDC ED 5B 34 96  	ld	de, (CursorAddr)
 335+ 8EE0 06 06        	ld	b, 	(NAMELEN + 1)/2
 336+ 8EE2              DrawCursorLoop:
 337+ 8EE2 12           	ld	(de), a
 338+ 8EE3 13           	inc de
 339+ 8EE4 10 FC        	djnz DrawCursorLoop
 340+ 8EE6 C9           	ret
 341+ 8EE7
 342+ 8EE7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 343+ 8EE7
 344+ 8EE7              ;IN:	A = file idx.
 345+ 8EE7              MoveCursor:
 346+ 8EE7              	;File idx / SCR_LINES => cursor line & column
 347+ 8EE7 6F           	ld		l, a
 348+ 8EE8 26 00        	ld		h, 0
 349+ 8EEA 0E 17        	ld		c, LST_LINES_CNT
 350+ 8EEC CD 39 88     	call	Div					;HL = file column, A = line
 351+ 8EEF
 352+ 8EEF              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 353+ 8EEF C6 00        	add		LST_FIRST_LINE
 354+ 8EF1
 355+ 8EF1
 356+ 8EF1 54           	ld d, h
 357+ 8EF2 5D           	ld e, l
 358+ 8EF3 21 00 00     	ld	hl, 0
 359+ 8EF6
 360+ 8EF6              	;line*32
 361+ 8EF6 17           	rla
 362+ 8EF7 17           	rla
 363+ 8EF8 17           	rla
 364+ 8EF9 17           	rla
 365+ 8EFA CB 14        	rl h
 366+ 8EFC 17           	rla
 367+ 8EFD CB 14        	rl h
 368+ 8EFF 6F           	ld l, a
 369+ 8F00
 370+ 8F00
 371+ 8F00              	;col * 6
 372+ 8F00 E5           	push	hl					;save line * 32
 373+ 8F01 3E 06        		ld		a, (NAMELEN + 1)/2
 374+ 8F03 CD 59 88     		call	Mul				;HL = column * 12/2
 375+ 8F06 D1           	pop		de
 376+ 8F07 19           	add		hl, de
 377+ 8F08
 378+ 8F08 11 08 00     	ld		de, LST_FIRST_COL/2
 379+ 8F0B ED 4B A1 8F  	ld		bc, (CurrScrAttrAddr)
 380+ 8F0F 19           	add		hl, de
 381+ 8F10 09           	add		hl, bc
 382+ 8F11
 383+ 8F11              	;clear old cursor
 384+ 8F11 3E 0F        	ld		a, SCR_DEF_CLR
 385+ 8F13 CD DC 8E     	call	DrawCursor
 386+ 8F16
 387+ 8F16              	;draw new one
 388+ 8F16 22 34 96     	ld		(CursorAddr), hl
 389+ 8F19 3E 28        	ld		a, SCR_SEL_CLR
 390+ 8F1B CD DC 8E     	call	DrawCursor
 391+ 8F1E
 392+ 8F1E C9           	ret
 393+ 8F1F
 394+ 8F1F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 395+ 8F1F
 396+ 8F1F              PrintChar:
 397+ 8F1F ED 5B B0 5C      ld		de, (LineCol)
 398+ 8F23
 399+ 8F23                  ;calculate 64 column screen address
 400+ 8F23              	;IN: D = line, E = col
 401+ 8F23              	;OUT: HL = screen address
 402+ 8F23
 403+ 8F23 CB 3B            SRL     E                                       ;col = col/2
 404+ 8F25 CB 19            RR      C                                       ;mark odd/even column
 405+ 8F27 7A               LD      A, D                            ;A = line
 406+ 8F28 E6 18            AND 24                                  ;keep only %00011000
 407+ 8F2A 2A 9F 8F         ld		hl, (CurrScrAddr)
 408+ 8F2D B4               OR      h								;add screen start address
 409+ 8F2E 67               LD      H, A                            ;save H
 410+ 8F2F 7A               LD      A, D                            ;A = line
 411+ 8F30 E6 07            AND 7                                   ;keep only %00000111
 412+ 8F32 0F               RRCA                                    ;%10000011
 413+ 8F33 0F               RRCA                                    ;%11000001
 414+ 8F34 0F               RRCA                                    ;%11100000
 415+ 8F35 B3               OR      E                                       ;add column
 416+ 8F36 6F               LD      L, A                            ;HL = screen address
 417+ 8F37
 418+ 8F37              PrintChar3:
 419+ 8F37                  ;get font address
 420+ 8F37 E5               PUSH HL
 421+ 8F38 AF                   XOR A
 422+ 8F39 67                   LD  H, A
 423+ 8F3A 3A 81 5C             LD  A, (CODE)
 424+ 8F3D D6 20                SUB ' '
 425+ 8F3F 6F                   LD  L, A
 426+ 8F40 29                   ADD     HL, HL                  ;char code = char code * 8
 427+ 8F41 29                   ADD     HL, HL                  ;i.e. offset into font table
 428+ 8F42 29                   ADD     HL, HL
 429+ 8F43 11 B8 A1             LD      DE, FontTable             ;get font table
 430+ 8F46 19                   ADD     HL, DE
 431+ 8F47 EB                   EX      DE, HL                  ;DE = our char font address
 432+ 8F48 E1               POP     HL
 433+ 8F49
 434+ 8F49
 435+ 8F49                  ;print a char
 436+ 8F49 06 08            LD      B, 8                            ;char height is 8 lines
 437+ 8F4B              PrintCharLine:
 438+ 8F4B 1A                   LD      A, (DE)                         ;load char line in A
 439+ 8F4C
 440+ 8F4C CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 441+ 8F4E 20 06                JR  	NZ, NoTurn
 442+ 8F50
 443+ 8F50 07                   RLCA
 444+ 8F51 07                   RLCA
 445+ 8F52 07                   RLCA
 446+ 8F53 07                   RLCA
 447+ 8F54 18 01                JR      Store
 448+ 8F56              NoTurn:
 449+ 8F56 B6                   OR (HL)
 450+ 8F57              Store:
 451+ 8F57 77                   LD (HL), A
 452+ 8F58
 453+ 8F58 13                   INC     DE                                      ;next char line in font table
 454+ 8F59 24                   INC     H                                       ;next char line on screen
 455+ 8F5A 10 EF            DJNZ PrintCharLine                  ;last line of char?
 456+ 8F5C
 457+ 8F5C C9               ret
 458+ 8F5D
 459+ 8F5D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 460+ 8F5D
 461+ 8F5D              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 462+ 8F5D              ReadString:
 463+ 8F5D 21 20 A5     	ld		hl, DataBuf
 464+ 8F60 D5           	push	de
 465+ 8F61 DD E1        	pop		ix
 466+ 8F63
 467+ 8F63              ReadStringLoop:
 468+ 8F63 D5           	push	de
 469+ 8F64 E5           	push	hl
 470+ 8F65 CD E0 8D     		call ReadChar
 471+ 8F68 E1           	pop		hl
 472+ 8F69 D1           	pop		de
 473+ 8F6A
 474+ 8F6A FE 0D        	cp	KEY_ENTER
 475+ 8F6C C8           	ret z
 476+ 8F6D
 477+ 8F6D FE 0C        	cp  KEY_BACKSP
 478+ 8F6F 20 0F        	jr	nz, ReadStrChar
 479+ 8F71
 480+ 8F71 E5           	push hl
 481+ 8F72 01 21 A5     	ld   bc, DataBuf+1
 482+ 8F75 ED 42        	sbc	 hl, bc
 483+ 8F77 E1           	pop  hl
 484+ 8F78 38 16        	jr   c, ReadStrPrint
 485+ 8F7A
 486+ 8F7A 1B           	dec	de
 487+ 8F7B 2B           	dec	hl
 488+ 8F7C 36 20        	ld	(hl), ' '
 489+ 8F7E 18 10        	jr	ReadStrPrint
 490+ 8F80
 491+ 8F80              ReadStrChar:
 492+ 8F80 FE 20        	cp	' '
 493+ 8F82 38 DF        	jr	c, ReadStringLoop
 494+ 8F84 FE 7F        	cp  127
 495+ 8F86 30 DB        	jr	nc, ReadStringLoop
 496+ 8F88
 497+ 8F88              	;Check end of string and go back if found.
 498+ 8F88 46           	ld	b, (hl)
 499+ 8F89 CB 78        	bit 7, b
 500+ 8F8B 20 03        	jr	nz, ReadStrPrint
 501+ 8F8D
 502+ 8F8D 77           	ld	(hl), a
 503+ 8F8E 23           	inc	hl
 504+ 8F8F 13           	inc	de
 505+ 8F90
 506+ 8F90              ReadStrPrint:
 507+ 8F90 E5           	push	hl
 508+ 8F91 D5           	push	de
 509+ 8F92 21 20 A5     	ld		hl, DataBuf
 510+ 8F95 DD E5        	push	ix
 511+ 8F97 D1           	pop		de
 512+ 8F98 CD 1C 8E     	call	PrintStr
 513+ 8F9B D1           	pop		de
 514+ 8F9C E1           	pop		hl
 515+ 8F9D
 516+ 8F9D 18 C4        	jr		ReadStringLoop
 517+ 8F9F
 518+ 8F9F 00 40        CurrScrAddr		DEFW	16384
 519+ 8FA1 00 58        CurrScrAttrAddr	DEFW	22528
 520+ 8FA3
 521+ 8FA3                 	endif
# file closed: ui.asm
1328  8FA3              	include "math.asm"
# file opened: math.asm
   1+ 8FA3              	ifndef	_MATH_
   2+ 8FA3 ~            	define	_MATH_
   3+ 8FA3 ~
   4+ 8FA3 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 8FA3 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 8FA3 ~
   7+ 8FA3 ~
   8+ 8FA3 ~            Word2Txt:
   9+ 8FA3 ~            	IFUSED
  10+ 8FA3 ~            	push	de
  11+ 8FA3 ~            		call	Word2Txt_
  12+ 8FA3 ~            	pop		de
  13+ 8FA3 ~
  14+ 8FA3 ~            	ld		b, 4
  15+ 8FA3 ~            	call	StrippLeading0
  16+ 8FA3 ~            	ret
  17+ 8FA3 ~
  18+ 8FA3 ~            Byte2Txt:
  19+ 8FA3 ~            	push	de
  20+ 8FA3 ~            		call	Byte2Txt_
  21+ 8FA3 ~            	pop		de
  22+ 8FA3 ~
  23+ 8FA3 ~            	ld		b, 2
  24+ 8FA3 ~            	call	StrippLeading0
  25+ 8FA3 ~            	ret
  26+ 8FA3 ~            	ENDIF
  27+ 8FA3 ~
  28+ 8FA3 ~
  29+ 8FA3 ~            StrippLeading0:
  30+ 8FA3 ~            	ld		a, (de)
  31+ 8FA3 ~            	cp		'1'
  32+ 8FA3 ~            	ret		nc
  33+ 8FA3 ~
  34+ 8FA3 ~            	ld		a, ' '
  35+ 8FA3 ~            	ld		(de), a
  36+ 8FA3 ~            	inc		de
  37+ 8FA3 ~            	djnz	StrippLeading0
  38+ 8FA3 ~            	ret
  39+ 8FA3 ~
  40+ 8FA3 ~
  41+ 8FA3 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 8FA3 ~            Word2Txt_:
  43+ 8FA3 ~            	ld bc, -10000
  44+ 8FA3 ~            	call DigitLoop
  45+ 8FA3 ~            	ld bc, -1000
  46+ 8FA3 ~            	call DigitLoop
  47+ 8FA3 ~            Byte2Txt_:
  48+ 8FA3 ~            	ld bc, -100
  49+ 8FA3 ~            	call DigitLoop
  50+ 8FA3 ~            	ld bc, -10
  51+ 8FA3 ~            	call DigitLoop
  52+ 8FA3 ~            	ld bc, -1
  53+ 8FA3 ~
  54+ 8FA3 ~            DigitLoop:
  55+ 8FA3 ~            	ld	a, '0' - 1
  56+ 8FA3 ~            DivNrLoop:
  57+ 8FA3 ~            	inc	a			;increase reminder
  58+ 8FA3 ~            	add	hl, bc		;substract divizor
  59+ 8FA3 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 8FA3 ~            	sbc	hl, bc		;nope, restore
  61+ 8FA3 ~
  62+ 8FA3 ~            	ld (de), a
  63+ 8FA3 ~            	inc de
  64+ 8FA3 ~            	ret
  65+ 8FA3 ~
  66+ 8FA3 ~
  67+ 8FA3 ~            ;Input: HL = Dividend, C = Divisor
  68+ 8FA3 ~            ;Output: HL = Quotient, A = Remainder
  69+ 8FA3 ~            ;Warning: doesn't work with divisor >= $80
  70+ 8FA3 ~            Div:
  71+ 8FA3 ~            	IFUSED
  72+ 8FA3 ~            	xor a
  73+ 8FA3 ~            	ld b, 16
  74+ 8FA3 ~
  75+ 8FA3 ~            DivLoop:
  76+ 8FA3 ~            	add	hl,hl
  77+ 8FA3 ~            	rla
  78+ 8FA3 ~            	cp	c
  79+ 8FA3 ~            	jr	c, NoSub
  80+ 8FA3 ~            	sub	c
  81+ 8FA3 ~            	inc	l
  82+ 8FA3 ~            NoSub:
  83+ 8FA3 ~            	djnz DivLoop
  84+ 8FA3 ~
  85+ 8FA3 ~            	ret
  86+ 8FA3 ~            	ENDIF
  87+ 8FA3 ~
  88+ 8FA3 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 8FA3 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 8FA3 ~            Div2:
  91+ 8FA3 ~            	ld hl, 0
  92+ 8FA3 ~            	ld b, 16
  93+ 8FA3 ~            Div2Loop:
  94+ 8FA3 ~            	sll c		; unroll 16 times
  95+ 8FA3 ~            	rla			; ...
  96+ 8FA3 ~            	adc	hl,hl		; ...
  97+ 8FA3 ~            	sbc	hl,de		; ...
  98+ 8FA3 ~            	jr	nc,$+4		; ...
  99+ 8FA3 ~            	add	hl,de		; ...
 100+ 8FA3 ~            	dec	c		; ...
 101+ 8FA3 ~            	djnz Div2Loop
 102+ 8FA3 ~            	ret
 103+ 8FA3 ~
 104+ 8FA3 ~
 105+ 8FA3 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 8FA3 ~            ;Output: A:HL = Product
 107+ 8FA3 ~            Mul:
 108+ 8FA3 ~            	IFUSED
 109+ 8FA3 ~            	ld hl, 0
 110+ 8FA3 ~            	ld bc, $0700
 111+ 8FA3 ~
 112+ 8FA3 ~            	add	a, a		; optimised 1st iteration
 113+ 8FA3 ~            	jr	nc, MulLoop
 114+ 8FA3 ~            	ld	h, d
 115+ 8FA3 ~            	ld	l, e
 116+ 8FA3 ~
 117+ 8FA3 ~            MulLoop:
 118+ 8FA3 ~            	add	hl,hl
 119+ 8FA3 ~            	rla
 120+ 8FA3 ~            	jr	nc, NoAdd
 121+ 8FA3 ~            	add	hl,de
 122+ 8FA3 ~            	adc	a,c
 123+ 8FA3 ~            NoAdd:
 124+ 8FA3 ~            	djnz MulLoop
 125+ 8FA3 ~
 126+ 8FA3 ~            	ret
 127+ 8FA3 ~            	ENDIF
 128+ 8FA3 ~
 129+ 8FA3              	endif
# file closed: math.asm
1329  8FA3              	include "txtview.asm"
# file opened: txtview.asm
   1+ 8FA3              ; 	DEVICE ZXSPECTRUM48
   2+ 8FA3
   3+ 8FA3              LINE_CNT	EQU	23
   4+ 8FA3              COL_CNT		EQU	64
   5+ 8FA3
   6+ 8FA3              CHAR_CR		EQU	$0D
   7+ 8FA3              CHAR_LF		EQU	$0A
   8+ 8FA3              CHAR_TAB	EQU	$09
   9+ 8FA3              EOF_MARKER		EQU	$1A
  10+ 8FA3
  11+ 8FA3              COORDS		EQU	23728		;Coordinates
  12+ 8FA3
  13+ 8FA3
  14+ 8FA3              InitViewer:
  15+ 8FA3 22 EF 92     	ld		 (FileBegin), hl
  16+ 8FA6 09           	add		hl, bc
  17+ 8FA7              	;must filter any EOF chars, max 256 of them.
  18+ 8FA7 25           	dec		h
  19+ 8FA8 3E 1A        	ld		a, EOF_MARKER
  20+ 8FAA ED B1        	cpir
  21+ 8FAC 2B           	dec		hl
  22+ 8FAD 22 F3 92     	ld		(FileEnd), hl
  23+ 8FB0 ED 5B EF 92  	ld		de, (FileBegin)
  24+ 8FB4 B7           	or		a
  25+ 8FB5 ED 52        	sbc		hl, de
  26+ 8FB7 22 F1 92     	ld		(FileLen), hl
  27+ 8FBA
  28+ 8FBA 3E 0D        	ld		a, CHAR_CR
  29+ 8FBC 77           	ld		(hl), a
  30+ 8FBD
  31+ 8FBD
  32+ 8FBD 21 04 02     	ld		hl, (2 << 8) | 4
  33+ 8FC0 22 09 5C     	ld		(23561), hl
  34+ 8FC3
  35+ 8FC3 21 00 00     	ld		hl, 0
  36+ 8FC6 22 B0 5C     	ld		(COORDS), hl
  37+ 8FC9
  38+ 8FC9 21 00 58     	ld		hl, 16384 + 6144
  39+ 8FCC 54           	ld		d, h
  40+ 8FCD 5D           	ld		e, l
  41+ 8FCE 13           	inc		de
  42+ 8FCF 01 FF 02     	ld		bc, 767
  43+ 8FD2 36 0F        	ld		(hl), (1 << 3) | 7
  44+ 8FD4 ED B0        	ldir
  45+ 8FD6
  46+ 8FD6 CD F5 91     	call	ScrollInit
  47+ 8FD9
  48+ 8FD9 11 00 00     	ld		de, 0
  49+ 8FDC ED 53 EA 92  	ld		(CurLine), de
  50+ 8FE0
  51+ 8FE0              	;prepare file progress %
  52+ 8FE0 2A F1 92     	ld		hl, (FileLen)
  53+ 8FE3 7C           	ld		a, h
  54+ 8FE4 4D           	ld		c, l
  55+ 8FE5 11 64 00     	ld		de, 100
  56+ 8FE8 CD 46 88     	call	Div2
  57+ 8FEB 67           	ld		h, a
  58+ 8FEC 69           	ld		l, c
  59+ 8FED 22 F5 92     	ld		(PROGR_PERC), hl
  60+ 8FF0
  61+ 8FF0 CD 84 91     	call	PrintMsg
  62+ 8FF3
  63+ 8FF3 DD 21 1E F7  	ld		ix, FileIdx	- 2
  64+ 8FF7 06 17        	ld		b, LINE_CNT
  65+ 8FF9 2A EF 92     	ld		hl, (FileBegin)
  66+ 8FFC
  67+ 8FFC C9           	ret
  68+ 8FFD
  69+ 8FFD              PrintLoop:
  70+ 8FFD C5           	push	bc
  71+ 8FFE DD 23        		inc		ix
  72+ 9000 DD 23        		inc		ix
  73+ 9002 DD 75 00     		ld		(ix), l
  74+ 9005 DD 74 01     		ld		(ix + 1), h
  75+ 9008
  76+ 9008 CD 1F 91     		call	GetLine
  77+ 900B CD F1 90     		call	PrintLine
  78+ 900E
  79+ 900E ED 5B EA 92  		ld		de, (CurLine)
  80+ 9012 13           		inc		de
  81+ 9013 ED 53 EA 92  		ld		(CurLine), de
  82+ 9017 C1           	pop		bc
  83+ 9018 CD E6 90     	call	CheckEnd
  84+ 901B 28 13        	jr		z, EOF
  85+ 901D
  86+ 901D 10 DE        	djnz	PrintLoop
  87+ 901F 18 17        	jr		PrintLoop2
  88+ 9021
  89+ 9021              GetKey:
  90+ 9021 76           	halt
  91+ 9022 FD CB 01 6E  	bit		5, (iy + 1);
  92+ 9026 28 F9        	jr		z, GetKey
  93+ 9028 FD CB 01 AE  	res		5, (iy + 1)
  94+ 902C FD 7E CE     	ld		a, (iy - $32)
  95+ 902F C9           	ret
  96+ 9030
  97+ 9030              EOF:
  98+ 9030 CD 21 90     	call	GetKey
  99+ 9033 FE 30        	cp		'0'
 100+ 9035 20 F9        	jr		nz, EOF
 101+ 9037 C9           	ret
 102+ 9038
 103+ 9038              PrintLoop2:
 104+ 9038 CD 84 91     	call	PrintMsg
 105+ 903B
 106+ 903B CD 21 90     	call	GetKey
 107+ 903E FE 30        	cp		'0'					;Exit on 0
 108+ 9040 C8           	ret		z
 109+ 9041
 110+ 9041 FE 0A        	cp		KEY_DOWN
 111+ 9043 28 5C        	jr		z, Down
 112+ 9045
 113+ 9045 FE 0B        	cp		KEY_UP
 114+ 9047 28 2D        	jr		z, Up
 115+ 9049
 116+ 9049 FE 32        	cp		'2'
 117+ 904B 20 EB        	jr		nz, PrintLoop2
 118+ 904D
 119+ 904D 3A EE 92     	ld		a, (WrapFlag)
 120+ 9050 EE 01        	xor		1
 121+ 9052 32 EE 92     	ld		(WrapFlag), a
 122+ 9055 B7           	or		a
 123+ 9056 28 0F        	jr		z, NoWrap
 124+ 9058
 125+ 9058 11 4F 6E     	ld		de, 'nO'
 126+ 905B ED 53 A0 92  	ld		(MsgLineWrF), de
 127+ 905F 3E 20        	ld		a, ' '
 128+ 9061 32 A2 92     	ld		(MsgLineWrF + 2), a
 129+ 9064 C3 38 90     	jp		PrintLoop2
 130+ 9067
 131+ 9067              NoWrap:
 132+ 9067 11 4F 66     	ld		de, 'fO'
 133+ 906A ED 53 A0 92  	ld		(MsgLineWrF), de
 134+ 906E 3E 66        	ld		a, 'f'
 135+ 9070 32 A2 92     	ld		(MsgLineWrF + 2), a
 136+ 9073
 137+ 9073 C3 38 90     	jp		PrintLoop2
 138+ 9076
 139+ 9076
 140+ 9076              Up:
 141+ 9076 CD D6 90     	call	CheckBegin
 142+ 9079 28 BD        	jr		z, PrintLoop2
 143+ 907B
 144+ 907B CD 23 92     	call	ScrollUp
 145+ 907E
 146+ 907E DD 2B        	dec		ix
 147+ 9080 DD 2B        	dec		ix
 148+ 9082 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 149+ 9085 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 150+ 9088 CD 1F 91     	call	GetLine						;extract previous line to display
 151+ 908B
 152+ 908B 11 00 00     	ld		de, 0
 153+ 908E ED 53 B0 5C  	ld		(COORDS), de
 154+ 9092 CD F1 90     	call	PrintLine
 155+ 9095
 156+ 9095 2A EA 92     	ld		hl, (CurLine)
 157+ 9098 2B           	dec		hl
 158+ 9099 22 EA 92     	ld		(CurLine), hl
 159+ 909C CD 84 91     	call	PrintMsg
 160+ 909F 18 97        	jr		PrintLoop2
 161+ 90A1
 162+ 90A1
 163+ 90A1              Down:
 164+ 90A1 DD 6E 00     	ld		l, (ix)
 165+ 90A4 DD 66 01     	ld		h, (ix + 1)
 166+ 90A7 CD 1F 91     	call	GetLine						;get next line pointer
 167+ 90AA
 168+ 90AA CD E6 90     	call	CheckEnd					;check if HL == file end
 169+ 90AD 38 89        	jr		c, PrintLoop2
 170+ 90AF
 171+ 90AF DD 23        	inc		ix								;save next line pointer
 172+ 90B1 DD 23        	inc		ix
 173+ 90B3 DD 75 00     	ld		(ix), l
 174+ 90B6 DD 74 01     	ld		(ix + 1), h
 175+ 90B9
 176+ 90B9 CD 1F 91     	call	GetLine						;extract next line in buffer for display
 177+ 90BC
 178+ 90BC CD 28 92     	call	ScrollDown
 179+ 90BF
 180+ 90BF 11 00 16     	ld		de, (LINE_CNT-1) << 8
 181+ 90C2 ED 53 B0 5C  	ld		(COORDS), de
 182+ 90C6 CD F1 90     	call	PrintLine
 183+ 90C9
 184+ 90C9 2A EA 92     	ld		hl, (CurLine)
 185+ 90CC 23           	inc		hl
 186+ 90CD 22 EA 92     	ld		(CurLine), hl
 187+ 90D0 CD 84 91     	call	PrintMsg
 188+ 90D3
 189+ 90D3 C3 38 90     	jp		PrintLoop2
 190+ 90D6
 191+ 90D6
 192+ 90D6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 90D6              ;check begining of buffer
 194+ 90D6              CheckBegin:
 195+ 90D6 E5           	push	hl
 196+ 90D7 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 197+ 90DA DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 198+ 90DD ED 5B EF 92  		ld		de, (FileBegin)
 199+ 90E1 B7           		or		a
 200+ 90E2 ED 52        		sbc		hl, de
 201+ 90E4 E1           	pop		hl
 202+ 90E5 C9           	ret
 203+ 90E6
 204+ 90E6              ;check end of buffer
 205+ 90E6              CheckEnd:
 206+ 90E6 E5           	push	hl
 207+ 90E7 ED 5B F3 92  		ld		de, (FileEnd)
 208+ 90EB EB           		ex		de, hl
 209+ 90EC B7           		or		a
 210+ 90ED ED 52        		sbc		hl, de
 211+ 90EF E1           	pop		hl
 212+ 90F0 C9           	ret
 213+ 90F1
 214+ 90F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 215+ 90F1              ;Print a line
 216+ 90F1              PrintLine:
 217+ 90F1 11 AA 92     	ld		de, LineBuf
 218+ 90F4 06 40        	ld		b, COL_CNT
 219+ 90F6
 220+ 90F6 CD 05 91     	call	PrintStrTxt
 221+ 90F9
 222+ 90F9              	;go to the next screen line
 223+ 90F9 ED 5B B0 5C  	ld		de, (COORDS)
 224+ 90FD 14           	inc		d
 225+ 90FE 1E 00        	ld		e, 0
 226+ 9100 ED 53 B0 5C  	ld		(COORDS), de
 227+ 9104 C9           	ret
 228+ 9105
 229+ 9105              PrintStrTxt:
 230+ 9105 1A           	ld		a, (de)
 231+ 9106 13           	inc		de
 232+ 9107 D5           	push	de
 233+ 9108 32 81 5C     		ld		(CODE), a
 234+ 910B C5           		push	bc
 235+ 910C E5           			push	hl
 236+ 910D CD 1F 8F     				call	PrintChar
 237+ 9110 E1           			pop		hl
 238+ 9111 C1           		pop		bc
 239+ 9112
 240+ 9112 ED 5B B0 5C  		ld		de, (COORDS)
 241+ 9116 1C           		inc		e
 242+ 9117 ED 53 B0 5C  		ld		(COORDS), de
 243+ 911B D1           	pop		de
 244+ 911C 10 E7        	djnz	PrintStrTxt
 245+ 911E C9           	ret
 246+ 911F
 247+ 911F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 248+ 911F              ;Extract a line of text to fit exactly on a 64 screen line
 249+ 911F              ;IN:	HL = current file pointer
 250+ 911F              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 251+ 911F              GetLine:
 252+ 911F 11 AA 92     	ld		de, LineBuf
 253+ 9122 06 40        	ld		b, COL_CNT
 254+ 9124              GetLineLoop:
 255+ 9124 7E           	ld		a, (hl)
 256+ 9125 23           	inc		hl
 257+ 9126
 258+ 9126 FE 0D        	cp		CHAR_CR
 259+ 9128 28 29        	jr		z, GetLineSkip0A
 260+ 912A
 261+ 912A FE 0A        	cp		CHAR_LF
 262+ 912C 28 25        	jr		z, GetLineSkip0A
 263+ 912E
 264+ 912E FE 09        	cp		CHAR_TAB
 265+ 9130 20 07        	jr		nz, GetLineNext
 266+ 9132
 267+ 9132 3E 20        	ld		a, ' '
 268+ 9134 12           	ld		(de), a
 269+ 9135 13           	inc		de
 270+ 9136 05           	dec		b
 271+ 9137 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 272+ 9139
 273+ 9139              GetLineNext:
 274+ 9139 FE 20        	cp		' '
 275+ 913B 38 06        	jr		c, NotValid
 276+ 913D
 277+ 913D FE 80        	cp		128
 278+ 913F 30 02        	jr		nc, NotValid
 279+ 9141 18 03        	jr		Valid
 280+ 9143
 281+ 9143              NotValid:
 282+ 9143 CD D3 91     	call	ReplaceChars
 283+ 9146
 284+ 9146              Valid:
 285+ 9146 12           	ld		(de), a
 286+ 9147 13           	inc		de
 287+ 9148 10 DA        	djnz	GetLineLoop
 288+ 914A
 289+ 914A              ;if line is exactly 64 char long, must skip the new line char(s)
 290+ 914A              GetLineSkip0D:
 291+ 914A 0E 00        	ld		c, 0
 292+ 914C 3E 0D        	ld		a, CHAR_CR						;skip 0D
 293+ 914E BE           	cp		(hl)
 294+ 914F 20 02        	jr		nz, GetLineSkip0A
 295+ 9151 23           	inc		hl
 296+ 9152 0C           	inc		c
 297+ 9153
 298+ 9153              GetLineSkip0A:						;skip 0A
 299+ 9153 3E 0A        	ld		a, CHAR_LF
 300+ 9155 BE           	cp		(hl)
 301+ 9156 20 02        	jr		nz, GetLineFill
 302+ 9158 23           	inc		hl
 303+ 9159 0C           	inc		c
 304+ 915A
 305+ 915A              GetLineFill:
 306+ 915A 78           	ld		a, b
 307+ 915B B7           	or		a
 308+ 915C 20 1F        	jr		nz, GetLineFillLoop
 309+ 915E
 310+ 915E 79           	ld		a, c
 311+ 915F B7           	or		a
 312+ 9160 C0           	ret		nz
 313+ 9161
 314+ 9161              	;wrap or not
 315+ 9161 3A EE 92     	ld		a, (WrapFlag)
 316+ 9164 B7           	or		a
 317+ 9165 C0           	ret		nz
 318+ 9166
 319+ 9166 ED 5B F3 92  	ld		de, (FileEnd)
 320+ 916A E5           	push	hl
 321+ 916B EB           	ex		de, hl
 322+ 916C B7           	or		a
 323+ 916D ED 52        	sbc		hl, de
 324+ 916F 44           	ld		b, h
 325+ 9170 4D           	ld		c, l
 326+ 9171 3E 0D        	ld		a, CHAR_CR
 327+ 9173 E1           	pop		hl
 328+ 9174 ED B1        	cpir
 329+ 9176 C0           	ret		nz
 330+ 9177 3E 0A        	ld		a, CHAR_LF
 331+ 9179 BE           	cp		(hl)
 332+ 917A C0           	ret		nz
 333+ 917B 23           	inc		hl
 334+ 917C
 335+ 917C C9           	ret
 336+ 917D
 337+ 917D              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 338+ 917D 3E 20        	ld		a, ' '
 339+ 917F 12           	ld		(de), a
 340+ 9180 13           	inc		de
 341+ 9181 10 FA        	djnz	GetLineFillLoop
 342+ 9183 C9           	ret
 343+ 9184
 344+ 9184              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 345+ 9184              PrintMsg:
 346+ 9184 ED 5B B0 5C  	ld		de, (COORDS)
 347+ 9188 D5           	push	de
 348+ 9189 11 00 17     	ld		de, LINE_CNT<<8
 349+ 918C ED 53 B0 5C  	ld		(COORDS), de
 350+ 9190
 351+ 9190              	;Get current file pointer
 352+ 9190 DD 6E 00     	ld		l, (ix)
 353+ 9193 DD 66 01     	ld		h, (ix + 1)
 354+ 9196 ED 4B EF 92  	ld		bc, (FileBegin)
 355+ 919A B7           	or		a
 356+ 919B ED 42        	sbc		hl, bc
 357+ 919D
 358+ 919D              	;Divide by one percent length
 359+ 919D 7C           	ld		a, h
 360+ 919E 4D           	ld		c, l
 361+ 919F ED 5B F5 92  	ld		de, (PROGR_PERC)
 362+ 91A3 CD 46 88     	call	Div2
 363+ 91A6
 364+ 91A6              	;Display %
 365+ 91A6 11 86 92     	ld		de, MsgLinePr
 366+ 91A9 67           	ld		h, a
 367+ 91AA 69           	ld		l, c
 368+ 91AB CD FD 87     	call	Byte2Txt
 369+ 91AE
 370+ 91AE
 371+ 91AE 2A EA 92     	ld		hl, (CurLine)
 372+ 91B1 11 92 92     	ld		de, MsgLineNo
 373+ 91B4 CD F2 87     	call	Word2Txt
 374+ 91B7
 375+ 91B7 11 7D 92     	ld		de, MsgLine
 376+ 91BA 06 2D        	ld		b, MsgLineLen
 377+ 91BC CD 05 91     	call	PrintStrTxt
 378+ 91BF D1           	pop		de
 379+ 91C0 ED 53 B0 5C  	ld		(COORDS), DE
 380+ 91C4
 381+ 91C4 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 382+ 91C7 54           	ld		d, h
 383+ 91C8 5D           	ld		e, l
 384+ 91C9 13           	inc		de
 385+ 91CA 3E 28        	ld		a, (5 << 3) | 0
 386+ 91CC 77           	ld		(hl), a
 387+ 91CD 01 1F 00     	ld		bc, 31
 388+ 91D0 ED B0        	ldir
 389+ 91D2 C9           	ret
 390+ 91D3
 391+ 91D3
 392+ 91D3              ReplaceChars:
 393+ 91D3 E5           	push	hl
 394+ 91D4 C5           	push	bc
 395+ 91D5 21 63 92     		ld		hl, CharReplaceTbl
 396+ 91D8 06 0D        		ld		b, CharReplTblLen
 397+ 91DA              ReplaceSGCLoop:
 398+ 91DA BE           		cp		(hl)
 399+ 91DB 28 09        		jr		z, ReplaceMatch
 400+ 91DD 23           		inc		hl
 401+ 91DE 23           		inc		hl
 402+ 91DF 10 F9        		djnz	ReplaceSGCLoop
 403+ 91E1
 404+ 91E1 3E 3F        		ld		a, '?'
 405+ 91E3 C1           		pop		bc
 406+ 91E4 E1           		pop		hl
 407+ 91E5 C9           	ret
 408+ 91E6
 409+ 91E6              ReplaceMatch:
 410+ 91E6 23           		inc		hl
 411+ 91E7 7E           		ld		a, (hl)
 412+ 91E8 C1           	pop		bc
 413+ 91E9 E1           	pop		hl
 414+ 91EA C9           	ret
 415+ 91EB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 416+ 91EB
 417+ 91EB              	include	"scroll.asm"
# file opened: scroll.asm
   1++91EB              ;Scrolling routines for UP/DOWN
   2++91EB              ;They use 2 tables of pointers of screen cell rows.
   3++91EB              ;One table has addresses in increasing order, for scroll down,
   4++91EB              ;the other in decreasing order, for scroll up, so the same
   5++91EB              ;scroll routine is used in both cases.
   6++91EB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++91EB
   8++91EB              ; Char Down
   9++91EB              ; Adjusts screen address HL to move eight pixels down on the display.
  10++91EB              ; enter: HL = valid screen address
  11++91EB              ; exit : HL = moves one character down
  12++91EB              ; used : AF, HL
  13++91EB              GetCellDown:
  14++91EB 7D           	ld a,l
  15++91EC C6 20        	add a,$20
  16++91EE 6F           	ld l,a
  17++91EF D0           	ret nc
  18++91F0 7C           	ld a,h
  19++91F1 C6 08        	add a,$08
  20++91F3 67           	ld h,a
  21++91F4 C9           	ret
  22++91F5
  23++91F5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++91F5              ;Fills the two tables with pointers.
  25++91F5              ScrollInit:
  26++91F5 21 00 40     	ld		hl, 16384
  27++91F8 06 17        	ld		b, LINE_CNT
  28++91FA              FillScrLinesLoop:
  29++91FA              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++91FA 22 00 5B     	ld		(SCRLinesDown), hl
  31++91FD              	;inc. pointer in destination table (of pointers to lines)
  32++91FD ED 5B FB 91  	ld		de, (FillScrLinesPtr)
  33++9201 13           	inc		de
  34++9202 13           	inc		de
  35++9203 ED 53 FB 91  	ld		(FillScrLinesPtr), de
  36++9207 CD EB 91     	call	GetCellDown
  37++920A 10 EE        	djnz	FillScrLinesLoop
  38++920C
  39++920C              	;now fill the table in reverse
  40++920C ED 73 20 92  	ld		(FillScrLinesSPStore), sp
  41++9210 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++9213 06 17        	ld		b, LINE_CNT
  43++9215 21 00 5B     	ld		hl, SCRLinesDown
  44++9218              FillScrLinesRev:
  45++9218 5E           	ld		e, (hl)
  46++9219 23           	inc		hl
  47++921A 56           	ld		d, (hl)
  48++921B 23           	inc		hl
  49++921C D5           	push	de
  50++921D 10 F9        	djnz	FillScrLinesRev
  51++921F              FillScrLinesSPStore	EQU	$ + 1
  52++921F 31 00 00     	ld		sp, 0
  53++9222 C9           	ret
  54++9223
  55++9223              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++9223              ScrollUp:
  57++9223 21 2E 5B     	ld		hl, SCRLinesUp
  58++9226 18 03        	jr		Scroll
  59++9228
  60++9228              ScrollDown:
  61++9228 21 00 5B     	ld		hl, SCRLinesDown
  62++922B
  63++922B              Scroll:
  64++922B 22 39 92     	ld		(ScrollDownPtrDest), hl
  65++922E 23           	inc		hl
  66++922F 23           	inc		hl
  67++9230 22 3C 92     	ld		(ScrollDownPtrSrc), hl
  68++9233 0E 16        	ld		c, LINE_CNT - 1
  69++9235
  70++9235              ScrollDownLoop2:
  71++9235 06 04        	ld		b, 4
  72++9237              ScrollDownPtrDest	EQU	$ + 2
  73++9237 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++923B              ScrollDownPtrSrc	EQU	$ + 1
  75++923B 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++923E
  77++923E              ScrollDownLoop:					;copy a single char line
  78++923E C5           	push	bc
  79++923F 01 20 00     	ld		bc, 32
  80++9242 ED B0        	ldir
  81++9244 2B           	dec		hl
  82++9245 1B           	dec		de
  83++9246 24           	inc		h
  84++9247 14           	inc		d
  85++9248 01 20 00     	ld		bc, 32
  86++924B ED B8        	lddr
  87++924D 23           	inc		hl
  88++924E 13           	inc		de
  89++924F 24           	inc		h
  90++9250 14           	inc		d
  91++9251 C1           	pop		bc
  92++9252 10 EA        	djnz	ScrollDownLoop
  93++9254
  94++9254 0D           	dec		c
  95++9255 C8           	ret		z
  96++9256
  97++9256 2A 3C 92     	ld		hl, (ScrollDownPtrSrc)
  98++9259 22 39 92     	ld		(ScrollDownPtrDest), hl
  99++925C 23           	inc		hl
 100++925D 23           	inc		hl
 101++925E 22 3C 92     	ld		(ScrollDownPtrSrc), hl
 102++9261 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 418+ 9263
 419+ 9263              CharReplaceTbl:
 420+ 9263 B3 80        	defb	179, 128
 421+ 9265 B4 81        	defb	180, 129
 422+ 9267 BF 82        	defb	191, 130
 423+ 9269 C0 83        	defb	192, 131
 424+ 926B C1 84        	defb	193, 132
 425+ 926D C2 85        	defb	194, 133
 426+ 926F C3 86        	defb	195, 134
 427+ 9271 C4 87        	defb	196, 135
 428+ 9273 C5 88        	defb	197, 136
 429+ 9275 D9 89        	defb	217, 137
 430+ 9277 DA 8A        	defb	218, 138
 431+ 9279 DB 8B        	defb	219, 139
 432+ 927B DC 8C        	defb	220, 140
 433+ 927D              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 434+ 927D
 435+ 927D 50 72 6F 67  MsgLine		defb	'Progress:'
 435+ 9281 72 65 73 73
 435+ 9285 3A
 436+ 9286 20 20 20 25  MsgLinePr	defb	'   %; '
 436+ 928A 3B 20
 437+ 928C 4C 69 6E 65  			defb	'Line: '
 437+ 9290 3A 20
 438+ 9292 20 20 20 20  MsgLineNo	defb	'     ; '
 438+ 9296 20 3B 20
 439+ 9299 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 439+ 929D 61 70 20
 440+ 92A0 20 4F 6E     MsgLineWrF	defb	' On'
 441+ 92A3 20 30 2D 45  			defb	' 0-Exit'
 441+ 92A7 78 69 74
 442+ 92AA              MsgLineLen	EQU		$ - MsgLine
 443+ 92AA
 444+ 92AA 20 20 20 20  LineBuf		defb	'                                                                '
 444+ 92AE 20 20 20 20
 444+ 92B2 20 20 20 20
 444+ 92B6 20 20 20 20
 444+ 92BA 20 20 20 20
 444+ 92BE 20 20 20 20
 444+ 92C2 20 20 20 20
 444+ 92C6 20 20 20 20
 444+ 92CA 20 20 20 20
 444+ 92CE 20 20 20 20
 444+ 92D2 20 20 20 20
 444+ 92D6 20 20 20 20
 444+ 92DA 20 20 20 20
 444+ 92DE 20 20 20 20
 444+ 92E2 20 20 20 20
 444+ 92E6 20 20 20 20
 445+ 92EA 00 00        CurLine		defw	0
 446+ 92EC 00 00        MaxLine		defw	0
 447+ 92EE 01           WrapFlag	defb	1
 448+ 92EF 00 00        FileBegin	defw	0
 449+ 92F1 00 00        FileLen		defw	0
 450+ 92F3 00 00        FileEnd		defw	0
 451+ 92F5 00 00        PROGR_PERC	defw	0
 452+ 92F7
 453+ 92F7              SCRLinesDown	EQU $5b00
 454+ 92F7              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 455+ 92F7              End:
 456+ 92F7
# file closed: txtview.asm
1330  92F7              	include "serial.asm"
# file opened: serial.asm
   1+ 92F7              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 92F7              ;They work with 19200 theoretical speed.
   3+ 92F7              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 92F7
   5+ 92F7              CBAUD	EQU	10	; CBAUD for 19200
   6+ 92F7              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 92F7
   8+ 92F7
   9+ 92F7              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 92F7              ; A=1 IF FRAMING ERROR
  11+ 92F7              ; USES BC,D _DOES NOT USE E!_
  12+ 92F7              SERRXI:
  12+ 92F7
  13+ 92F7 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 92FA 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 92FC D3 EF        	OUT	(0EFH),A
  16+ 92FE
  17+ 92FE              	; WAIT FOR START
  18+ 92FE              SERWSL:
  19+ 92FE 0B           	DEC	BC
  20+ 92FF AF           	XOR	A
  21+ 9300 B8           	CP	B
  22+ 9301 20 03        	JR	NZ,SERWS
  23+ 9303 B9           	CP	C
  24+ 9304 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 9306 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 9308 CB 7F        	BIT	7,A
  27+ 930A 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 930C
  29+ 930C              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 930C              ; OF BIT 0
  31+ 930C 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 930E 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 9310
  34+ 9310              ; GET AND SHIFT BITS
  35+ 9310              SERRL:
  36+ 9310 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 9312 00           	NOP			; 4 (TIMING)
  38+ 9313 00           	NOP			; 4 (TIMING)
  39+ 9314 00           	NOP			; 4 (TIMING)
  40+ 9315 DB F7        	IN	A,(0F7H)	; 11
  41+ 9317 17           	RLA			; 4
  42+ 9318 CB 1A        	RR	D		; 8
  43+ 931A 06 0A        	LD	B,CBAUD		; 7
  44+ 931C 0D           	DEC	C		; 4
  45+ 931D 20 F1        	JR	NZ,SERRL	; 12
  46+ 931F
  47+ 931F              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 931F              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 931F              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 931F              ; IDLE UNTIL NEXT START BIT
  51+ 931F 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 9321 D3 EF        	OUT	(0EFH),A
  53+ 9323
  54+ 9323 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 9325              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 9325              SERWIL:
  57+ 9325 05           	DEC	B
  58+ 9326 28 0E        	JR	Z,SERRTF
  59+ 9328 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 932A CB 7F        	BIT	7,A
  61+ 932C 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 932E
  63+ 932E              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 932E 7A           	LD	A,D
  65+ 932F 2F           	CPL			; INVERT BITS
  66+ 9330 57           	LD	D,A
  67+ 9331 AF           	XOR	A		; 0 = SUCCESS
  68+ 9332 C9           	RET
  69+ 9333
  70+ 9333              ; TIMEOUT
  71+ 9333              SERRTO:
  72+ 9333 3E FF        	LD	A,0FFH
  73+ 9335 C9           	RET
  74+ 9336
  75+ 9336              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 9336              SERRTF:
  77+ 9336 3E 01        	LD	A,01H
  78+ 9338 C9           	RET
  79+ 9339
  80+ 9339
  81+ 9339
  82+ 9339              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 9339              SERRB:
  83+ 9339
  84+ 9339              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 9339              ; BITMAPPED OPTIONS IN E:
  86+ 9339              ; XXXXXXIT
  87+ 9339              ; I SET = leave Interrupts disabled at exit
  88+ 9339              ; T SET = return after Timeout
  89+ 9339              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 9339              ; BC=NUMBER OF BYTES RECEIVED
  91+ 9339              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 9339 F3           	DI
  93+ 933A C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 933B              				; OF RECEIVED BYTES
  95+ 933B
  96+ 933B              SERRBL:
  97+ 933B C5           	PUSH	BC
  98+ 933C CD F7 92     	CALL	SERRXI
  99+ 933F C1           	POP	BC
 100+ 9340 B7           	OR	A
 101+ 9341 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 9343 72           	LD	(HL),D
 103+ 9344 23           	INC	HL
 104+ 9345 0B           	DEC	BC
 105+ 9346 AF           	XOR	A
 106+ 9347 B8           	CP	B
 107+ 9348 20 F1        	JR	NZ,SERRBL
 108+ 934A B9           	CP	C
 109+ 934B 20 EE        	JR	NZ,SERRBL
 110+ 934D              ; FULL RECEIVE
 111+ 934D C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 934E
 113+ 934E              SERRBX:				; EXIT
 114+ 934E CB 4B        	BIT	1,E
 115+ 9350 C0           	RET	NZ
 116+ 9351 FB           	EI
 117+ 9352 C9           	RET
 118+ 9353
 119+ 9353              SERRBT:
 120+ 9353 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 9355 28 04        	JR	Z,SERRBC
 122+ 9357 CB 43        	BIT	0,E
 123+ 9359 28 E0        	JR	Z,SERRBL
 124+ 935B
 125+ 935B              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 935B EB           	EX	DE,HL		; PRESERVE HL
 127+ 935C E1           	POP	HL		; GET INITIAL COUNT
 128+ 935D 37           	SCF
 129+ 935E 3F           	CCF
 130+ 935F ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 9361 44           	LD	B,H
 132+ 9362 4D           	LD	C,L		; BC = COUNT
 133+ 9363 EB           	EX	DE,HL		; RESTORE HL
 134+ 9364
 135+ 9364 18 E8        	JR	SERRBX
 136+ 9366
 137+ 9366              SERRX:
 137+ 9366
 138+ 9366              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 9366              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 9366              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 9366 F3           	DI
 142+ 9367 CD F7 92     	CALL	SERRXI
 143+ 936A FB           	EI
 144+ 936B C9           	RET
 145+ 936C
 146+ 936C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 936C              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 936C              SERTB:
 148+ 936C
 149+ 936C 7E           	LD	A,(HL)
 150+ 936D C5           	PUSH	BC
 151+ 936E CD 79 93     		CALL	SERTX
 152+ 9371 C1           	POP	BC
 153+ 9372 23           	INC	HL
 154+ 9373 0B           	DEC BC
 155+ 9374 78           	LD	A, B
 156+ 9375 B1           	OR	C
 157+ 9376 20 F4        	JR	NZ, SERTB
 158+ 9378 C9           	RET
 159+ 9379
 160+ 9379              ; SEND CHAR ROUTINE
 161+ 9379              SERTX:
 161+ 9379
 162+ 9379 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 937A 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 937B F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 937C 3E 01        	LD	A,01H
 166+ 937E D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 9380 1E 20        	LD	E,20H	; PORT MASK
 168+ 9382 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 9384 3E 01        	LD	A,1
 170+ 9386 C3 8D 93     	JP	SBIT
 171+ 9389
 172+ 9389 AF           SHLOOP:	XOR	A		; 4
 173+ 938A CB 3A        	SRL	D		; 8
 174+ 938C 17           	RLA			; 4
 175+ 938D              SBIT:
 176+ 938D B3           	OR	E		; 4
 177+ 938E D3 EF        	OUT	(0EFH),A	; 11
 178+ 9390 06 0A        	LD	B,CBAUD		; 7
 179+ 9392              SBITDL:
 180+ 9392 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 9394 00           	NOP			; 4 (TIMING)
 182+ 9395 0D           	DEC	C		; 4
 183+ 9396 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 9398              ; STOP BIT
 185+ 9398 3E 20        	LD	A,20H
 186+ 939A D3 EF        	OUT	(0EFH),A
 187+ 939C 06 0A        	LD	B,CBAUD
 188+ 939E 10 FE        STOPL:	DJNZ	STOPL
 189+ 93A0 FB           	EI
 190+ 93A1 C9           	RET
# file closed: serial.asm
1331  93A2
1332  93A2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1333  93A2 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1333  93A6 6F 6D 6D 61
1333  93AA 6E 64 65 72
1333  93AE 20 31 2E B0
1334  93B2 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1334  93B6 67 65 2E 63
1334  93BA 68 69 72 74
1334  93BE 6F 61 63 E1
1335  93C2 40 67 6D 61  VerMsg3			DEFM	'@gmail.com MAY2', '3' + $80
1335  93C6 69 6C 2E 63
1335  93CA 6F 6D 20 4D
1335  93CE 41 59 32 B3
1336  93D2 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1336  93D6 72 61 6D 20
1336  93DA 49 6E 66 6F
1336  93DE 20 20 20 A0
1337  93E2              ;MsgCompModel	DEFB	'Model: '
1338  93E2              ;MsgCompModelName DEFB	'        ', ' ' | $80
1339  93E2              ;MsgIF1Version	DEFB	'IF1  : '
1340  93E2              ;MsgIF1Date		DEFB	'       ', ' ' | $80
1341  93E2 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1341  93E6 20 49 6E 66
1341  93EA 6F 20 20 20
1341  93EE 20 20 20 A0
1342  93F2 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1342  93F6 20 49 6E 66
1342  93FA 6F 20 20 20
1342  93FE 20 20 20 A0
1343  9402 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1343  9406 61 67 65 73
1343  940A 20 20 20 20
1343  940E 20 20 20 A0
1344  9412 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1344  9416 20 32 2D 42
1344  941A 3A 20 33 2D
1344  941E 56 69 65 77
1344  9422 20 34 2D 50
1344  9426 72 6F 70 20
1344  942A 35 2D 43 6F
1344  942E 70 79 20 36
1344  9432 2D 52 65 6E
1344  9436 20 37 2D 41
1344  943A 74 74 72 20
1344  943E 38 2D 44 65
1344  9442 6C 20 39 2D
1344  9446 44 69 73 6B
1344  944A 20 30 2D 45
1344  944E 78 69 F4
1345  9451 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1345  9455 65 20 20 20
1345  9459 3A 20 20 20
1345  945D 20 20 20
1346  9460 C1           MsgDriveLet		DEFM	'A' + $80
1347  9461 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1347  9465 73 20 20 20
1347  9469 3A
1348  946A 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1348  946E 31 32 B8
1349  9471 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1349  9475 20 4B 42 20
1349  9479 3A
1350  947A 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1350  947E 36 33 B6
1351  9481 45 72 72 6F  MsgErr			DEFM	'Error code '
1351  9485 72 20 63 6F
1351  9489 64 65 20
1352  948C 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1352  9490 A0
1353  9491 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1353  9495 69 6E 67 20
1353  9499 50 72 6F 67
1353  949D 72 61 ED
1354  94A0 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1354  94A4 69 6E 67 20
1354  94A8 53 43 52 45
1354  94AC 45 4E A4
1355  94AF 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1355  94B3 69 6E 67 20
1355  94B7 43 4F 44 45
1355  94BB 20 28 21 A9
1356  94BF 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1356  94C3 20 4C 65 6E
1356  94C7 3A
1357  94C8 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1357  94CC 30 20 CB
1358  94CF 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1358  94D3 69 62 20 20
1358  94D7 3A
1359  94D8 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1359  94DC 48 49 C4
1360  94DF 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1360  94E3 54 79 70 65
1360  94E7 3A
1361  94E8 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1361  94EC 20 20 20 20
1361  94F0 20 A0
1362  94F2 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1362  94F6 72 61 ED
1363  94F9 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1363  94FD 73 20 A0
1364  9500 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1364  9504 45 4E A4
1365  9507 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1365  950B 41 72 F2
1366  950E 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1366  9512 41 72 F2
1367  9515 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1367  9519 20 20 A0
1368  951C 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1368  9520 20 20 A0
1369  9523 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1369  9527 74 68 20 20
1369  952B 3A
1370  952C 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1370  9530 35 20 C2
1371  9533 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1371  9537 74 20 20 20
1371  953B 3A
1372  953C 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1372  9540 35 20 A0
1373  9543 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1373  9547 69 6E 67 20
1373  954B 68 65 61 64
1373  954F 65 F2
1374  9551 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1374  9555 20 20 20 20
1374  9559 20 20 20 20
1374  955D 20 20 20 A0
1375  9561 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1375  9565 66 69 6C 65
1375  9569 20 28 79 2F
1375  956D 6E 29 BF
1376  9570 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1376  9574 52 2F 4F 20
1376  9578 28 79 2F 6E
1376  957C 29 BF
1377  957E 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1377  9582 48 49 44 20
1377  9586 28 79 2F 6E
1377  958A 29 BF
1378  958C 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1378  9590 2C 6E 6F 6E
1378  9594 65 3D 61 62
1378  9598 6F 72 74 BA
1379  959C 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1379  95A0 69 6E 67 20
1379  95A4 74 6F 20
1380  95A7 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1381  95A9 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1381  95AD 20 6F 70 74
1381  95B1 69 6F 6E 73
1381  95B5 BA
1382  95B6 30 2E 20 42  MsgMenu1		DEFM	'0. Bac', 'k' | $80
1382  95BA 61 63 EB
1383  95BD 31 2E 20 46  MsgMenu2		DEFM	'1. Format '
1383  95C1 6F 72 6D 61
1383  95C5 74 20
1384  95C7 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1385  95C9 32 2E 20 43  MsgMenu3		DEFM	'2. Copy '
1385  95CD 6F 70 79 20
1386  95D1 41 3A 2D 3E  MsgMenu3Drv1	DEFM	'A:->'
1387  95D5 42 BA        MsgMenu3Drv2	DEFM	'B', ':' | $80
1388  95D7 33 2E 20 43  MsgMenu4		DEFM	'3. Copy '
1388  95DB 6F 70 79 20
1389  95DF 41 3A 2D 3E  MsgMenu4Drv1	DEFM	'A:->CO', 'M' | $80
1389  95E3 43 4F CD
1390  95E6 34 2E 20 43  MsgMenu5		DEFM	'4. Copy COM->'
1390  95EA 6F 70 79 20
1390  95EE 43 4F 4D 2D
1390  95F2 3E
1391  95F3 41 BA        MsgMenu5Drv1	DEFM	'A', ':' | $80
1392  95F5 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1392  95F9 61 74 74 69
1392  95FD 6E 67 20
1393  9600 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1394  9602 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1394  9606 62 6C 6F 63
1394  960A 6B 73 20 6C
1394  960E 65 66 F4
1395  9611 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite (y/n)', '?' | $80
1395  9615 77 72 69 74
1395  9619 65 20 28 79
1395  961D 2F 6E 29 BF
1396  9621 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1396  9625 20 6E 61 6D
1396  9629 65 20 65 78
1396  962D 69 73 74 F3
1397  9631
1398  9631              	IFNDEF	_ROM_FNT_
1399  9631 ~            FontTable:
1400  9631 ~            	incbin "cpmfnt.bin"
1401  9631              	ENDIF
1402  9631              EndCode:
1403  9631
1404  9631              ;Unalocated variables
1405  9631              UnallocStart	EQU		EndCode
1406  9631              FileCnt			EQU		UnallocStart			;File counter, 1B
1407  9631              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1408  9631              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1409  9631              CursorAddr		EQU		SelFile + 1				;2 B
1410  9631              AUCnt			EQU		CursorAddr + 2			;2 B
1411  9631              SelFileCache	EQU		AUCnt + 2				;2 B
1412  9631
1413  9631              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1414  9631              ;FS block list constants
1415  9631              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1416  9631              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1417  9631              UsedBlockListSz		EQU 320 * 2 + 2							;640
1418  9631
1419  9631              	IFDEF	_ROM_FNT_
1420  9631              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1421  9631              DataBuf			EQU		FontTable + 872
1422  9631              	ELSE
1423  9631 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1424  9631              	ENDIF
1425  9631
1426  9631              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1427  9631
1428  9631              CopyFileFCBSrc	EQU	DataBuf
1429  9631              CopyFileFCBDst	EQU	DataBuf + 2
1430  9631              CopyFileResRead	EQU DataBuf + 4
1431  9631              CopyFileResWrite EQU DataBuf + 5
1432  9631              CopyFileDMAAddr	EQU	DataBuf + 6
1433  9631              CopyFileDMA		EQU	DataBuf + 8
1434  9631
1435  9631              ;File viewer constants
1436  9631              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1437  9631              ;File buffer size, without index
1438  9631              FileIdxSize		EQU		2 * 1024
1439  9631              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1440  9631              ;Set a few KB aside for file indexing
1441  9631              FileIdx			EQU		FileData + FileDataSize
1442  9631
1443  9631
1444  9631              ;Copy buffer size, follows
1445  9631              CopyDiskBuf			EQU DataBuf
1446  9631
1447  9631              ;We can use up to about 30KB free space if we load at address 24000.
1448  9631              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1449  9631              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1450  9631              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1451  9631              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1452  9631              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1453  9631
1454  9631              	DISPLAY "DataBuf: ", /D,DataBuf
1455  9631              	DISPLAY "BinSize: ", /D, EndCode - Start
1456  9631              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1457  9631              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x8843   NoSub
0x883C   DivLoop
0x59E0   MAX_RAM_FREE
0x0800   FileIdxSize
0x0282   UsedBlockListSz
0x9631   UnallocStart
0x9631   EndCode
0x939E   STOPL
0x9389   SHLOOP
0x938D   SBIT
0x9392   SBITDL
0x9379   SERTX
0x9366 X SERRX
0x935B   SERRBC
0x934E   SERRBX
0x9353   SERRBT
0x933B   SERRBL
0x9328 X SERWI
0x9336   SERRTF
0x9325   SERWIL
0x9310   SERRL
0x9333   SERRTO
0x9306   SERWS
0x92FE   SERWSL
0x92F7   SERRXI
0x000A   CBAUD
0x92F7 X End
0x92EC X MaxLine
0x9299 X MsgLineWrap
0x923E   ScrollDownLoop
0x9235   ScrollDownLoop2
0x923C   ScrollDownPtrSrc
0x9239   ScrollDownPtrDest
0x922B   Scroll
0x9218   FillScrLinesRev
0x5B2E   SCRLinesUp
0x9220   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x91FB   FillScrLinesPtr
0x91FA   FillScrLinesLoop
0x91EB   GetCellDown
0x91E6   ReplaceMatch
0x91DA   ReplaceSGCLoop
0x000D   CharReplTblLen
0x9263   CharReplaceTbl
0x002D   MsgLineLen
0x927D   MsgLine
0x9292   MsgLineNo
0x9286   MsgLinePr
0x917D   GetLineFillLoop
0x915A   GetLineFill
0x91D3   ReplaceChars
0x9146   Valid
0x9143   NotValid
0x914A   GetLineSkip0D
0x9139   GetLineNext
0x9153   GetLineSkip0A
0x9124   GetLineLoop
0x9105   PrintStrTxt
0x92AA   LineBuf
0x9228   ScrollDown
0x9223   ScrollUp
0x90D6   CheckBegin
0x92A0   MsgLineWrF
0x9067   NoWrap
0x92EE   WrapFlag
0x9076   Up
0x90A1   Down
0x9021   GetKey
0x9038   PrintLoop2
0x9030   EOF
0x90E6   CheckEnd
0x90F1   PrintLine
0x911F   GetLine
0xF720   FileIdx
0x9184   PrintMsg
0x92F5   PROGR_PERC
0x92EA   CurLine
0x91F5   ScrollInit
0x92F1   FileLen
0x92F3   FileEnd
0x92EF   FileBegin
0x5CB0   COORDS
0x001A   EOF_MARKER
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x8F90   ReadStrPrint
0x8F80   ReadStrChar
0x8F63   ReadStringLoop
0x8F57   Store
0x8F56   NoTurn
0x8F4B   PrintCharLine
0x8F37 X PrintChar3
0x8EE2   DrawCursorLoop
0x8EC2   DrawVLinesLoop
0x8ED5   PrintChar2
0x8EA0   DrawUpLine
0x8EA2   ChrParam
0x8E93 X DrawHLine
0x8E82   DrawLineLoop
0x8E8F   LineDir
0x8E7F   StoreDir
0x8E7D   VertDir
0x8E74   DrawLine
0x8E70   StrClr
0x8E23   GoodChar
0x8F9F   CurrScrAddr
0xA1B8   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x8DD3   ReadFileSectionEnd
0x8DB5   ReadFileSectionLoop
0x5100   FileDataSize
0xA525   CopyFileResWrite
0x8D5D   FileCopyWriteLoop
0x8D4C   FileCopyWrite
0xA524   CopyFileResRead
0x8D2E   FileCopyReadLoop
0xA528   CopyFileDMA
0xA526   CopyFileDMAAddr
0x0059   MAX_SECT_RAM
0x8D1F   FileCopyLoop
0xA522   CopyFileFCBDst
0x8D7B   CopyFileEnd
0xA520   CopyFileFCBSrc
0x8CC7 X FileAttribSet
0x8C80   GetFileSizeMul
0x8C86   GetFileSizeEnd
0x8C7E   GetFileSizeOK
0x8C5E   BDOSSetDMA
0x8C50   WriteFileBlock
0x8C4C   ReadFileBlock
0x8C48   CloseFile
0x8C44   OpenFile
0x8C40   CreateFile
0x8C36   DestroyChannel
0x8C20   CreateChannel
0x8C20 X BDOSGetCurrentDisk
0x8C20 X BDOSGetDiskRO
0x8C20 X BDOSMakeDiskRO
0x8C54   BDOS
0x8C0F X RWTSResTmp
0x8C0E X RWTSResVolNo
0x8C0A X RWTSPrmTbl
0x8C08 X RWTSExtBuf
0x8C05 X RWTSSector
0x8C03 X RWTSVolNo
0x8C01 X RWTSBlockType
0x8BF8   CopyMsg
0x8BEC   SearchMsgEnd
0x8BF5   SaveMsg
0x8BE3   IF1Paged
0x8BB1   IF1Call
0x8BAC   IsFileHeaderValidLoop
0x8C62   GetFileSize
0x8B90   ReadFileHeaderIsTextFile
0x8BA9   IsFileHeaderValid
0x8BA5   ReadHeaderEnd
0x8B4A   CacheNotFinished
0x8C14   BDOSInit
0x8C17   BDOSSelectDisk
0x8AE7   FileReadLoop
0x8ADB X FileLoadHeader
0x8AED   FileLoadNoHeader
0x8AFB   FileFree
0x8AB7   MisMatch
0x8AAF   Compare
0x8AAD   StrCmp
0x8A64   CopyDiskFromCOMLoop
0x9339   SERRB
0x8A00   CopyDiskToCOMLoop
0x936C   SERTB
0x89B9   CopyDiskLoopWriteLoop
0x8993   CopyDiskLoopReadLoop
0xA520   CopyDiskBuf
0x898C   CopyDiskLoopRead
0x000B   MAX_AU_RAM
0x9602   MsgBlocksLeft
0x8969   CopyDiskLoop
0x9F38   UsedBlockListBlk
0x8B13   WriteDiskSectors
0x895E X WriteFSBlockLoop
0x8955   WriteFSBlock
0x8B00   ReadDiskSectors
0x8951 X ReadFSBlockLoop
0x8948   ReadFSBlock
0x893A   ReadUsedBlocksSkip
0x891D   ReadUsedBlocksLoop2
0x893D   ReadUsedBlocksSkip2
0x890D   ReadUsedBlocksLoop
0x9F36   UsedBlockListCnt
0x88F0   ReadUsedBlocksList
0x88E9   CheckAUEnd
0x88D5   CheckAU
0x88BE   FirstAU
0x88B8   Track0
0x88A3   AU2TS
0x8C0D   RWTSRes
0x8887   WriteOneDiskSector
0x8C04   RWTSTrack
0x8C06   RWTSDMA
0x887C   ReadOneDiskSector
0x8C01   RWTSParams
0x8C0C   RWTSCmd
0x8870   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x001F X STR_MSG_IF1_LEN
0x23F0 X STR_MSG_IF1_91
0x27F0 X STR_MSG_IF1_2000
0x0020 X STR_MSG_BASIC_LEN
0x1539 X STR_MSG_BASIC
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x886A   NoAdd
0x8864   MulLoop
0x884B   Div2Loop
0x8846   Div2
0x8839   Div
0x8830   DivNrLoop
0x882E   DigitLoop
0x881F   Byte2Txt_
0x8808   StrippLeading0
0x8813   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x93C2   VerMsg3
0x93B2   VerMsg2
0x93A2   VerMsg1
0x87D4   DontInc
0x87C8   ReadAllHeadersEnd
0x87B3   AKey
0x8DE3   KbdHit
0x8798   NextFile
0x9523   MsgFileLen
0x94DF   MsgFileType
0x9533   MsgFileStart
0x8757   PrintStartStr
0x953C   MsgFileStartN
0x951C   MsgNA
0x8749   PrintStart
0x0007   HDR_LINE
0x8724   PrintByteStart
0x871C   PrintProgStart
0x952C   MsgFileLenN
0x8702 X PrepFileLenText
0x9515   MsgFileTypeText
0x94F9   MsgFileTypeByte
0x9500   MsgFileTypeSCR
0x86E8   NotScr
0x86F3   CheckText
0x9507   MsgFileTypeChrA
0x86CB   CheckByte
0x0002   CHAR_TYPE
0x950E   MsgFileTypeNoA
0x86BC   CheckChrArr
0x0001   NUMB_TYPE
0x86FC   PrepFileLen
0x8775   MoveMsg
0x94E8   MsgFileTypeN
0x94F2   MsgFileTypePrg
0x86AD   CheckNoArr
0x000B   CACHE_FIRST_AU
0x872C   HeadNotRead
0x94CF   MsgFileAttr
0x867E   AttrEnd
0x8672   NotSYS
0x865E   CheckSys
0x864C   NotRO
0x94D8   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x873E   PrintStartNotRead
0x94BF   MsgFileSzDsk
0x94C8   MsgFileSzDskN
0x8608 X ViewFileEnd
0x8FFD   PrintLoop
0x8FA3   InitViewer
0xA620   FileData
0x8D96   ReadFileSection
0x8BB7   LoadProgram
0x9491   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x94A0   MsgLoadingSCR
0x0003   HDR_ADDR
0x8AFB   IF1FileLoadEnd
0x5B00   PRN_BUF
0x8ABA   IF1FileLoad
0x94AF   MsgLoadingCODE
0x8596 X HandleFileCODE
0x85BF   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x85ED   HandleFileText
0x0003   BYTE_TYPE
0x85DD   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x8560   FindExtEnd
0x8B3F   FindCache
0x856F   GetFileNamesEnd
0x0009   HDR_SZ
0x853B   FindExt
0x000C   EXT_IDX
0x88C1   CheckExtAlloc
0x8562   NextExt
0x0000   EXT_DEL_FLAG
0x84EA   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x84C7   DisplayFilenamesLoop
0x84AD   LineOK
0x5CB1   LINE
0x5CB0   COL
0x8F1F   PrintChar
0x5C81   CODE
0x8487   DispLoop
0x8485   DisplayFilename
0x8EE7   MoveCursor
0x8A47   CopyDiskFromCOM
0x89EB   CopyDiskToCOM
0x8469   CheckExtra4
0x8962   CopyDisk
0x845F   CheckExtra3
0x8892   FormatDisk
0x95F5   MsgFormat
0x8456   CheckExtra2
0x8474   ExtraMenuExit
0x8422 X CheckKeyDiskMenuLoop
0x95E6   MsgMenu5
0x95D7   MsgMenu4
0x95C9   MsgMenu3
0x95BD   MsgMenu2
0x95B6   MsgMenu1
0x83C3 X CheckKeyDiskMenu
0x95D5   MsgMenu3Drv2
0x95F3   MsgMenu5Drv1
0x95DF   MsgMenu4Drv1
0x95D1   MsgMenu3Drv1
0x9600   MsgFormatDrv
0x95C7   MsgMenu2Drv
0x95A9   MsgMenu0
0x8477   CheckKeyExit
0x8CA6   ChangeFileAttrib
0x8385   AttrChange
0x957E   MsgSetSYS
0x836D   CheckSYS
0x9570   MsgSetRO
0x8394   CheckKeyExtra
0x8C8C   DeleteFile
0x833F   DoFileDelete
0x9561   MsgDelete
0x834C   CheckKeyAttrib
0x8CD0   RenameFile
0x9621   MsgFileExists
0x82EF   RenameFileNotExist
0x82FB   RenameCanceled
0x8F5D   ReadString
0x000B   NAMELEN
0x958C   MsgNewFileName
0x8314   CheckKeyDel
0x85EE   ViewFile
0x8293   CheckKeyRename
0x0001   DRIVE_B_CPM
0x8282   CheckKeyView
0x838E   SelectDrive
0x8279   CheckKeyDriveB
0x877B   ReadAllHeaders
0x8270   CheckKeyDriveA
0x8246   CopyFileOK
0x8CF3   CopyFile
0x8246   CopyFileDontOverwrite
0x9611   MsgFileOverwrite
0x8226   CopyFileDestNotExist
0x8C98   DoesFileExist
0x959C   MsgCopyFile
0x95A7   MsgCopyFileDrv
0x825F   CheckKeyFileInfo
0x9551   MsgClear
0x8B50   ReadFileHeader
0x9543   MsgReadingExt
0x81E3   CheckKeyCopy
0x8570   HandleFile
0x81B8   CheckKeyInfo
0x000D   KEY_ENTER
0x81AD   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x819C   CheckLeft
0x0009   KEY_RIGHT
0x8186   CheckRight
0x000B   KEY_UP
0x847F   MoveIt
0x8175   CheckUp
0x000A   KEY_DOWN
0x8609   DisplayFileInfo
0x9638   SelFileCache
0x8859   Mul
0x8146   CalcFileCache
0x9471   MsgFreeSpace
0x87F2   Word2Txt
0x947A   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x9636   AUCnt
0x9461   MsgFilesCnt
0x946A   MsgFilesCntNo
0x9631   FileCnt
0x8E1C   PrintStr
0x9451   MsgDrive
0x9460   MsgDriveLet
0x8BD0   SetFastKeys
0x8EDC   DrawCursor
0x0028   SCR_SEL_CLR
0x9402   MsgMessages
0x0008   LST_FILE_INFO
0x93F2   MsgFileInf
0x0004   LST_DISK_INFO
0x93E2   MsgDskInf
0x0000   LST_PROG_INFO
0x93D2   MsgSysInf
0x9412   BtnBar
0x0028   SCR_LBL_CLR
0x8EBD   DrawVLines
0x0084   CHR_DC
0x9634   CursorAddr
0x8FA1   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x8DFC   ClrScr
0x5CB0   LineCol
0x0000   LST_FIRST_LINE
0x9632   NameCol
0x0010   LST_FIRST_COL
0x9633   SelFile
0xA520   DataBuf
0x8BDB   GetErrMsg
0x5C3A   ERRNR
0x8062   HCRunEnd
0x8157   ReadKeyLoop
0x80FD   DisplayDiskInfo
0x84B7   DisplayFilenames
0x87D7   PrintIntro
0x809A   InitUI
0x8053   HCRunMain
0x84D7   GetFileNames
0x8C02   RWTSDrive
0x0000   DRIVE_A_CPM
0x8DE0   ReadChar
0x8E44   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x000E   LST_LINE_MSG
0x9481   MsgErr
0x87FD   Byte2Txt
0x948C   MsgErrCode
0x8050   HCRunCacheFiles
0x8B26   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0x963A   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0xA520   TrackBuf
0x8012   HCRunInitDisk
0x8068   ErrorHandler
0x5C3D   ERRSP
0x886D   IF1Init
0x8DE6   InitFonts
0x8000   Start
