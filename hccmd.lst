# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM, hence 32768.
  11  0000              	ORG 30000
  12  7530
  13  7530              Start:
  14  7530              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  7530 CD BA 80     		call InitFonts
  16  7533              	ENDIF
  17  7533 CD B3 7C     	call IF1Init
  18  7536
  19  7536              	;install error handler
  20  7536 2A 3D 5C     	ld		hl, (ERRSP)
  21  7539 E5           	push	hl
  22  753A 21 90 75     	ld		hl, ErrorHandler
  23  753D E5           	push	hl
  24  753E ED 73 3D 5C  	ld		(ERRSP), sp
  25  7542
  26  7542              HCRunInitDisk:
  27  7542              	;Set track buffer to del marker
  28  7542 21 81 94     	ld		hl, TrackBuf
  29  7545 54           	ld		d, h
  30  7546 5D           	ld		e, l
  31  7547 13           	inc		de
  32  7548 01 00 10     	ld		bc, SPT*SECT_SZ
  33  754B 36 E5        	ld		(hl), DEL_MARKER
  34  754D ED B0        	ldir
  35  754F
  36  754F              	;Invalidate file cache
  37  754F 21 1D 88     	ld		hl, FileCache
  38  7552 54           	ld		d, h
  39  7553 5D           	ld		e, l
  40  7554 13           	inc		de
  41  7555 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  7558 36 00        	ld		(hl), 0
  43  755A ED B0        	ldir
  44  755C
  45  755C              	;main program
  46  755C CD AA 7E     	call 	ReadCatalogTrack
  47  755F B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  7560 28 1C        	jr		z, HCRunMain
  49  7562
  50  7562 6F           	ld		l, a
  51  7563 26 00        	ld		h, 0
  52  7565 11 A5 86     	ld		de, MsgErrCode
  53  7568 CD 43 7C     	call	Byte2Txt
  54  756B 21 9A 86     	ld		hl, MsgErr
  55  756E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  56  7571 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  7573 CD 18 81     	call	PrintStrClr
  58  7576 CD B4 80     	call	ReadChar
  59  7579 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  757B 32 5A 7F     	ld		(RWTSDrive), a
  61  757E
  62  757E              HCRunMain:
  63  757E CD C2 75     	call 	InitUI
  64  7581 CD 35 79     	call 	GetFileNames
  65  7584 CD 42 76     	call	DisplayDiskInfo
  66  7587 C3 9C 76     	jp		ReadKeyLoop
  67  758A
  68  758A              HCRunEnd:
  69  758A              	;restore error handler
  70  758A E1           	pop		hl
  71  758B E1           	pop		hl
  72  758C 22 3D 5C     	ld		(ERRSP), hl
  73  758F
  74  758F C9           	ret
  75  7590
  76  7590              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  77  7590
  78  7590              ErrorHandler:
  79  7590 E1           	pop		hl
  80  7591 22 3D 5C     	ld		(ERRSP), hl
  81  7594
  82  7594 3A 3A 5C     	ld		a, (ERRNR)		;make something with the error code, display the error message maybe.
  83  7597 6F           	ld		l, a
  84  7598 26 00        	ld		h, 0
  85  759A 11 A5 86     	ld		de, MsgErrCode
  86  759D CD 43 7C     	call	Byte2Txt
  87  75A0 21 9A 86     	ld		hl, MsgErr
  88  75A3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  89  75A6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  90  75A8 CD 18 81     	call	PrintStrClr
  91  75AB
  92  75AB 3A 3A 5C     	ld		a, (ERRNR)
  93  75AE CD 30 7F     	call	GetErrMsg
  94  75B1
  95  75B1 21 81 A4     	ld		hl, DataBuf
  96  75B4 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
  97  75B7 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  98  75B9 CD 18 81     	call	PrintStrClr
  99  75BC
 100  75BC CD B4 80     	call	ReadChar
 101  75BF C3 30 75     	jp	Start
 102  75C2
 103  75C2
 104  75C2
 105  75C2
 106  75C2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 107  75C2
 108  75C2              InitUI:
 109  75C2 AF           	xor		a
 110  75C3 32 16 88     	ld		(SelFile), A
 111  75C6 32 14 88     	ld		(FileCnt), A
 112  75C9 3E 11        	ld		a, LST_FIRST_COL + 1
 113  75CB 32 15 88     	ld		(NameCol), A
 114  75CE
 115  75CE 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 116  75D1 ED 4B 75 82  	ld		bc, (CurrScrAttrAddr)
 117  75D5 09           	add		hl, bc
 118  75D6 22 17 88     	ld		(CursorAddr), hl
 119  75D9
 120  75D9 CD D0 80     	call	ClrScr
 121  75DC
 122  75DC 3E 84        	ld		a, CHR_DC
 123  75DE CD 91 81     	call	DrawVLines
 124  75E1
 125  75E1 3E 28        	ld		a, SCR_LBL_CLR
 126  75E3 11 00 17     	ld		de, 23 << 8
 127  75E6 21 2B 86     	ld		hl, BtnBar
 128  75E9 CD 18 81     	call	PrintStrClr
 129  75EC
 130  75EC
 131  75EC 21 CB 85     	ld		hl, VerMsg1
 132  75EF 11 00 00     	ld		de, LST_FIRST_LINE << 8
 133  75F2 CD F0 80     	call	PrintStr
 134  75F5 21 DB 85     	ld		hl, VerMsg2
 135  75F8 11 00 01     	ld		de, LST_FIRST_LINE + 1 << 8
 136  75FB CD F0 80     	call	PrintStr
 137  75FE 21 EB 85     	ld		hl, VerMsg3
 138  7601 11 00 02     	ld		de, LST_FIRST_LINE + 2 << 8
 139  7604 CD F0 80     	call	PrintStr
 140  7607
 141  7607
 142  7607 3E 28        	ld		a, SCR_LBL_CLR
 143  7609 21 FB 85     	ld		hl, MsgDskInf
 144  760C 11 00 03     	ld		de, LST_DISK_INFO << 8
 145  760F CD 18 81     	call	PrintStrClr
 146  7612
 147  7612 3E 28        	ld		a, SCR_LBL_CLR
 148  7614 21 0B 86     	ld		hl, MsgFileInf
 149  7617 11 00 07     	ld		de, LST_FILE_INFO << 8
 150  761A CD 18 81     	call	PrintStrClr
 151  761D
 152  761D 3E 28        	ld		a, SCR_LBL_CLR
 153  761F 21 1B 86     	ld		hl, MsgMessages
 154  7622 11 00 0D     	ld		de, LST_LINE_MSG << 8
 155  7625 CD 18 81     	call	PrintStrClr
 156  7628
 157  7628 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 158  762B ED 53 B0 5C  	ld		(LineCol), de
 159  762F 21 19 88     	ld		hl, AUCnt
 160  7632 11 00 00     	ld		de, 0
 161  7635 73 23 72 2B  	ld		(hl), de
 162  7639
 163  7639 3E 28        	ld		a, SCR_SEL_CLR
 164  763B CD B0 81     	call	DrawCursor
 165  763E
 166  763E CD 25 7F     	call	SetFastKeys
 167  7641
 168  7641 C9           	ret
 169  7642
 170  7642
 171  7642              DisplayDiskInfo:
 172  7642 3A 5A 7F     	ld		a, (RWTSDrive)
 173  7645 C6 C1        	add		'A' + $80
 174  7647 32 79 86     	ld		(MsgDriveLet), a
 175  764A 21 6A 86     	ld		hl, MsgDrive
 176  764D 11 00 04     	ld		de, LST_DISK_INFO + 1 << 8
 177  7650 CD F0 80     	call	PrintStr
 178  7653
 179  7653 3A 14 88     	ld		a, (FileCnt)
 180  7656 6F           	ld		l, a
 181  7657 26 00        	ld		h, 0
 182  7659 11 83 86     	ld		de, MsgFilesCntNo
 183  765C CD 43 7C     	call	Byte2Txt
 184  765F 21 7A 86     	ld		hl, MsgFilesCnt
 185  7662 11 00 05     	ld		de, LST_DISK_INFO + 2 << 8
 186  7665 CD F0 80     	call	PrintStr
 187  7668
 188  7668 ED 5B 19 88  	ld		de, (AUCnt)
 189  766C 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 190  766F B7           	or		a
 191  7670 ED 52        	sbc		hl, de
 192  7672 CB 15        	rl		l								;*2, 2K/AU
 193  7674 CB 14        	rl		h
 194  7676 11 91 86     	ld		de, MsgFreeSpaceNo - 2
 195  7679 CD 38 7C     	call	Word2Txt
 196  767C 3E 3A        	ld		a, ':'
 197  767E 32 92 86     	ld		(MsgFreeSpaceNo -1), a
 198  7681 21 8A 86     	ld		hl, MsgFreeSpace
 199  7684 11 00 06     	ld		de, LST_DISK_INFO + 3 << 8
 200  7687 CD F0 80     	call	PrintStr
 201  768A
 202  768A C9           	ret
 203  768B
 204  768B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205  768B
 206  768B              CalcFileCache:
 207  768B 3A 16 88     	ld		a, (SelFile)
 208  768E 11 19 00     	ld		de, CACHE_SZ
 209  7691 CD 9F 7C     	call	Mul
 210  7694 01 1D 88     	ld		bc, FileCache
 211  7697 09           	add		hl, bc					;HL = file AU cnt
 212  7698 22 1B 88     	ld		(SelFileCache), hl
 213  769B C9           	ret
 214  769C
 215  769C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 216  769C
 217  769C
 218  769C              ReadKeyLoop:
 219  769C CD 8B 76     	call	CalcFileCache
 220  769F CD 67 7A     	call	DisplayFileInfo
 221  76A2
 222  76A2 CD B4 80     	call	ReadChar
 223  76A5
 224  76A5 FE 0A        	cp		KEY_DOWN
 225  76A7 20 11        	jr		nz, CheckUp
 226  76A9
 227  76A9 3A 14 88     	ld		a, (FileCnt)
 228  76AC 47           	ld		b, a
 229  76AD 3A 16 88     	ld		a, (SelFile)
 230  76B0 3C           	inc		a
 231  76B1 B8           	cp		b
 232  76B2 30 E8        	jr		nc, ReadKeyLoop
 233  76B4 32 16 88     	ld		(SelFile), a
 234  76B7 C3 E6 78     	jp		MoveIt
 235  76BA
 236  76BA              CheckUp:
 237  76BA FE 0B        	cp		KEY_UP
 238  76BC 20 0D        	jr		nz, CheckRight
 239  76BE
 240  76BE 3A 16 88     	ld		a, (SelFile)
 241  76C1 B7           	or		a
 242  76C2 28 D8        	jr		z, ReadKeyLoop
 243  76C4
 244  76C4 3D           	dec		a
 245  76C5 32 16 88     	ld		(SelFile), a
 246  76C8 C3 E6 78     	jp		MoveIt
 247  76CB
 248  76CB              CheckRight:
 249  76CB FE 09        	cp		KEY_RIGHT
 250  76CD 20 12        	jr		nz, CheckLeft
 251  76CF
 252  76CF 3A 14 88     	ld		a, (FileCnt)
 253  76D2 47           	ld		b, a
 254  76D3 3A 16 88     	ld		a, (SelFile)
 255  76D6 C6 17        	add		LST_LINES_CNT
 256  76D8 B8           	cp		b
 257  76D9 30 C1        	jr		nc, ReadKeyLoop
 258  76DB
 259  76DB 32 16 88     	ld		(SelFile), a
 260  76DE C3 E6 78     	jp		MoveIt
 261  76E1
 262  76E1              CheckLeft:
 263  76E1 FE 08        	cp		KEY_LEFT
 264  76E3 20 0D        	jr		nz, CheckEnter
 265  76E5
 266  76E5 3A 16 88     	ld		a, (SelFile)
 267  76E8 D6 17        	sub		LST_LINES_CNT
 268  76EA 38 B0        	jr		c, ReadKeyLoop
 269  76EC
 270  76EC 32 16 88     	ld		(SelFile), a
 271  76EF C3 E6 78     	jp		MoveIt
 272  76F2
 273  76F2              CheckEnter:
 274  76F2 FE 0D        	cp		KEY_ENTER
 275  76F4 C2 FD 76     	jp		nz, CheckKeyInfo
 276  76F7 CD CC 79     	call	HandleFile
 277  76FA C3 7E 75     	jp		HCRunMain
 278  76FD
 279  76FD              CheckKeyInfo:
 280  76FD FE 34        	cp		'4'
 281  76FF 20 20        	jr		nz, CheckKeyCopy
 282  7701 DD 2A 1B 88  	ld		ix, (SelFileCache)
 283  7705 21 5C 87     	ld		hl, MsgReadingExt
 284  7708 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 285  770B 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 286  770D CD 18 81     	call	PrintStrClr
 287  7710 CD D4 7E     	call	ReadFileHeader
 288  7713 21 6A 87     	ld		hl, MsgClear
 289  7716 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
 290  7719 3E 0F        	ld		a, SCR_DEF_CLR
 291  771B CD 18 81     	call	PrintStrClr
 292  771E C3 9C 76     	jp		ReadKeyLoop
 293  7721
 294  7721              CheckKeyCopy:
 295  7721 FE 35        	cp		'5'
 296  7723 20 39        	jr		nz, CheckKeyFileInfo
 297  7725
 298  7725 3A 5A 7F     	ld 		a, (RWTSDrive)
 299  7728 3C           	inc		a
 300  7729 EE 03        	xor		%11
 301  772B C6 40        	add		'A' - 1
 302  772D 32 C0 87     	ld		(MsgCopyFileDrv), a
 303  7730 21 B5 87     	ld		hl, MsgCopyFile
 304  7733 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 305  7736 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 306  7738 CD 18 81     	call	PrintStrClr
 307  773B 2A 1B 88     	ld	hl, (SelFileCache)
 308  773E CD 13 80     	call	CopyFile
 309  7741 B7           	or		a
 310  7742 28 17        	jr		z, CopyFileOK
 311  7744
 312  7744 6F           	ld		l, a
 313  7745 26 00        	ld		h, 0
 314  7747 11 A5 86     	ld		de, MsgErrCode
 315  774A CD 43 7C     	call	Byte2Txt
 316  774D 21 9A 86     	ld		hl, MsgErr
 317  7750 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 318  7753 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319  7755 CD 18 81     	call	PrintStrClr
 320  7758 CD B4 80     	call	ReadChar
 321  775B
 322  775B              CopyFileOK:
 323  775B C3 42 75     	jp		HCRunInitDisk
 324  775E
 325  775E              CheckKeyFileInfo:
 326  775E FE 20        	cp		' '
 327  7760 20 06        	jr		nz, CheckKeyDriveA
 328  7762 CD DC 7B     	call	ReadAllHeaders
 329  7765 C3 9C 76     	jp		ReadKeyLoop
 330  7768
 331  7768              CheckKeyDriveA:
 332  7768 FE 31        	cp		'1'
 333  776A 20 05        	jr		nz, CheckKeyDriveB
 334  776C 3E 00        	ld		a, DRIVE_A_CPM
 335  776E C3 3F 78     	jp		SelectDrive
 336  7771
 337  7771              CheckKeyDriveB:
 338  7771 FE 32        	cp		'2'
 339  7773 20 05        	jr		nz, CheckKeyView
 340  7775 3E 01        	ld		a, DRIVE_B_CPM
 341  7777 C3 3F 78     	jp		SelectDrive
 342  777A
 343  777A              CheckKeyView:
 344  777A FE 33        	cp		'3'
 345  777C 20 06        	jr		nz, CheckKeyRename
 346  777E CD 4A 7A     	call	ViewFile
 347  7781 C3 7E 75     	jp		HCRunMain
 348  7784
 349  7784              CheckKeyRename:
 350  7784 FE 36        	cp		'6'
 351  7786 20 4B        	jr		nz, CheckKeyDel
 352  7788
 353  7788 21 A5 87     	ld		hl, MsgNewFileName
 354  778B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 355  778E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 356  7790 CD 18 81     	call	PrintStrClr
 357  7793
 358  7793 21 6A 87     	ld		hl, MsgClear
 359  7796 11 81 A4     	ld		de, DataBuf
 360  7799 01 0B 00     	ld		bc, NAMELEN
 361  779C ED B0        	ldir
 362  779E 3E A0        	ld		a, $80 | ' '
 363  77A0 12           	ld		(de), a
 364  77A1 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 365  77A4 21 81 A4     	ld		hl, DataBuf
 366  77A7 CD F0 80     	call	PrintStr
 367  77AA
 368  77AA 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 369  77AD 01 0B 00     	ld		bc, NAMELEN
 370  77B0 CD 31 82     	call	ReadString
 371  77B3
 372  77B3 11 81 A4     	ld		de, DataBuf
 373  77B6 1A           	ld		a, (de)
 374  77B7 FE 20        	cp		' '					;If starting with space, input was canceled.
 375  77B9 CA C5 77     	jp		z, RenameCanceled
 376  77BC 2A 1B 88     	ld		hl, (SelFileCache)
 377  77BF CD F0 7F     	call	RenameFile
 378  77C2 C3 42 75     	jp		HCRunInitDisk
 379  77C5
 380  77C5              RenameCanceled:
 381  77C5 21 6A 87     	ld		hl, MsgClear
 382  77C8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 383  77CB 3E 0F        	ld		a, SCR_DEF_CLR
 384  77CD CD 18 81     	call	PrintStrClr
 385  77D0 C3 9C 76     	jp		ReadKeyLoop
 386  77D3
 387  77D3              CheckKeyDel:
 388  77D3 FE 38        	cp		'8'
 389  77D5 20 2D        	jr		nz, CheckKeyAttrib
 390  77D7
 391  77D7 21 7A 87     	ld		hl, MsgDelete
 392  77DA 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 393  77DD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 394  77DF CD 18 81     	call	PrintStrClr
 395  77E2 CD B4 80     	call	ReadChar
 396  77E5 FE 79        	cp		'y'
 397  77E7 28 0E        	jr		z, DoFileDelete
 398  77E9 21 6A 87     	ld		hl, MsgClear
 399  77EC 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 400  77EF 3E 0F        	ld		a, SCR_DEF_CLR
 401  77F1 CD 18 81     	call	PrintStrClr
 402  77F4 C3 9C 76     	jp		ReadKeyLoop
 403  77F7              DoFileDelete:
 404  77F7 2A 1B 88     	ld		hl, (SelFileCache)
 405  77FA 3A 5A 7F     	ld 		a, (RWTSDrive)
 406  77FD 3C           	inc		a					;Convert to BASIC drive number: 1,2
 407  77FE CD BA 7F     	call	DeleteFile
 408  7801 C3 42 75     	jp		HCRunInitDisk
 409  7804
 410  7804              CheckKeyAttrib:
 411  7804 FE 37        	cp		'7'
 412  7806 20 3D        	jr		nz, CheckKeyExtra
 413  7808
 414  7808 21 89 87     	ld		hl, MsgSetRO
 415  780B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 416  780E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 417  7810 CD 18 81     	call	PrintStrClr
 418  7813 CD B4 80     	call	ReadChar
 419  7816 1E 00        	ld		e, 0
 420  7818 FE 79        	cp		'y'
 421  781A 20 02        	jr		nz, CheckSYS
 422  781C 1E 01        	ld		e, 1
 423  781E
 424  781E              CheckSYS:
 425  781E D5           	push	de
 426  781F 21 97 87     		ld		hl, MsgSetSYS
 427  7822 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 428  7825 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 429  7827 CD 18 81     		call	PrintStrClr
 430  782A CD B4 80     		call	ReadChar
 431  782D FE 79        		cp		'y'
 432  782F D1           	pop		de
 433  7830 20 04        	jr		nz, AttrChange
 434  7832 3E 02        	ld		a, %10
 435  7834 B3           	or		e
 436  7835 5F           	ld		e, a
 437  7836
 438  7836              AttrChange:
 439  7836 2A 1B 88     	ld		hl, (SelFileCache)
 440  7839 CD C6 7F     	call	ChangeFileAttrib
 441  783C C3 42 75     	jp		HCRunInitDisk
 442  783F
 443  783F              SelectDrive:
 444  783F 32 5A 7F     	ld 		(RWTSDrive), a
 445  7842 C3 42 75     	jp		HCRunInitDisk
 446  7845
 447  7845              CheckKeyExtra:
 448  7845 FE 39        	cp		'9'
 449  7847 C2 DE 78     	jp		nz, CheckKeyExit
 450  784A 21 C2 87     	ld		hl, MsgMenu0
 451  784D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 452  7850 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 453  7852 CD 18 81     	call	PrintStrClr
 454  7855 3A 5A 7F     	ld		a, (RWTSDrive)
 455  7858 C6 41        	add		'A'
 456  785A 32 DD 87     	ld		(MsgMenu1Drv), a
 457  785D 32 03 88     	ld		(MsgFormatDrv), a
 458  7860 32 EB 87     	ld		(MsgMenu2Drv), a
 459  7863
 460  7863              CheckKeyExtraMenu:
 461  7863 21 CF 87     	ld		hl, MsgMenu1
 462  7866 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 463  7869 CD F0 80     	call	PrintStr
 464  786C 21 DF 87     	ld		hl, MsgMenu2
 465  786F 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 466  7872 CD F0 80     	call	PrintStr
 467  7875 21 ED 87     	ld		hl, MsgMenu3
 468  7878 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 469  787B CD F0 80     	call	PrintStr
 470  787E CD B4 80     	call	ReadChar
 471  7881 F5           	push	af
 472  7882
 473  7882 21 6A 87     		ld		hl, MsgClear
 474  7885 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 475  7888 CD F0 80     		call	PrintStr
 476  788B 21 6A 87     		ld		hl, MsgClear
 477  788E 11 00 10     		ld		de, LST_LINE_MSG + 3 << 8
 478  7891 CD F0 80     		call	PrintStr
 479  7894 21 6A 87     		ld		hl, MsgClear
 480  7897 11 00 11     		ld		de, LST_LINE_MSG + 4 << 8
 481  789A CD F0 80     		call	PrintStr
 482  789D
 483  789D F1           	pop		af
 484  789E FE 33        	cp		'3'
 485  78A0 28 39        	jr		z, ExtraMenuExit
 486  78A2
 487  78A2 FE 31        	cp		'1'
 488  78A4 20 2C        	jr		nz, CheckExtra2
 489  78A6
 490  78A6 21 F8 87     	ld		hl, MsgFormat
 491  78A9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 492  78AC 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 493  78AE CD 18 81     	call	PrintStrClr
 494  78B1
 495  78B1 CD D8 7C     	call	FormatDisk
 496  78B4 B7           	or		a
 497  78B5 CA 42 75     	jp		z, HCRunInitDisk
 498  78B8
 499  78B8              	;Display error for format
 500  78B8 6F           	ld		l, a
 501  78B9 26 00        	ld		h, 0
 502  78BB 11 A5 86     	ld		de, MsgErrCode
 503  78BE CD 43 7C     	call	Byte2Txt
 504  78C1 21 9A 86     	ld		hl, MsgErr
 505  78C4 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 506  78C7 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 507  78C9 CD 18 81     	call	PrintStrClr
 508  78CC CD B4 80     	call	ReadChar
 509  78CF C3 42 75     	jp		HCRunInitDisk
 510  78D2
 511  78D2              CheckExtra2:
 512  78D2 FE 32        	cp		'2'
 513  78D4 20 8D        	jr		nz, CheckKeyExtraMenu
 514  78D6
 515  78D6 CD A8 7D     	call	CopyDisk
 516  78D9 18 00        	jr		ExtraMenuExit
 517  78DB
 518  78DB              ExtraMenuExit:
 519  78DB C3 7E 75     	jp		HCRunMain
 520  78DE
 521  78DE              CheckKeyExit:
 522  78DE FE 30        	cp		'0'
 523  78E0 C2 9C 76     	jp		nz, ReadKeyLoop
 524  78E3 C3 8A 75     	jp		HCRunEnd
 525  78E6
 526  78E6              MoveIt:
 527  78E6 CD BB 81     	call 	MoveCursor
 528  78E9 C3 9C 76     	jp		ReadKeyLoop
 529  78EC
 530  78EC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 531  78EC
 532  78EC
 533  78EC              DisplayFilename:
 534  78EC 06 0B        	LD		B, NAMELEN
 535  78EE              DispLoop:
 536  78EE 1A           	LD		A, (DE)
 537  78EF
 538  78EF              	;clear bit 7
 539  78EF CB BF        	RES 	7, A
 540  78F1 32 81 5C     	LD		(CODE), A
 541  78F4
 542  78F4 13           	INC		DE
 543  78F5 D5           	PUSH	DE
 544  78F6 C5           	PUSH	BC
 545  78F7 CD F3 81     		CALL	PrintChar
 546  78FA C1           	POP		BC
 547  78FB D1           	POP 	DE
 548  78FC
 549  78FC 21 B0 5C     	LD		HL, COL
 550  78FF 34           	INC		(HL)
 551  7900 10 EC        	DJNZ	DispLoop
 552  7902              	;now a name is displayed
 553  7902
 554  7902              	;check bounds
 555  7902 3A B1 5C     	LD		A, (LINE)
 556  7905 3C           	INC		A
 557  7906 FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 558  7908 38 0A        	JR		C, LineOK
 559  790A
 560  790A              	;set names column to the next one
 561  790A 3A 15 88     	LD		A, (NameCol)
 562  790D C6 0C        	ADD		NAMELEN + 1
 563  790F 32 15 88     	LD		(NameCol), A
 564  7912
 565  7912 3E 00        	LD		A, LST_FIRST_LINE
 566  7914              LineOK:
 567  7914 32 B1 5C     	LD		(LINE), A
 568  7917
 569  7917 3A 15 88     	LD		A, (NameCol)
 570  791A 32 B0 5C     	LD		(COL), A
 571  791D
 572  791D C9           	RET
 573  791E
 574  791E
 575  791E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 576  791E
 577  791E              DisplayFilenames:
 578  791E 11 1D 88     	ld		de, FileCache
 579  7921 3A 14 88     	ld		a, (FileCnt)
 580  7924 47           	ld		b,	a
 581  7925
 582  7925              DisplayFilenamesLoop:
 583  7925 C5           	push	bc
 584  7926 D5           		push	de
 585  7927 CD EC 78     			call	DisplayFilename
 586  792A D1           		pop		de
 587  792B EB           		ex		de, hl
 588  792C 01 19 00     		ld		bc, CACHE_SZ
 589  792F 09           		add		hl, bc
 590  7930 EB           		ex		de, hl
 591  7931 C1           	pop		bc
 592  7932 10 F1        	djnz	DisplayFilenamesLoop
 593  7934
 594  7934 C9           	ret
 595  7935
 596  7935
 597  7935              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 598  7935              ;Selects only valid filenames (not deleted and only from first extension)
 599  7935              GetFileNames:
 600  7935 DD 21 81 94  	ld ix, TrackBuf
 601  7939 11 1D 88     	ld de, FileCache
 602  793C 06 80        	ld b, MAX_EXT_CNT
 603  793E
 604  793E              StoreFilenamesLoop:
 605  793E AF           	xor a
 606  793F DD BE 00     	cp (ix + EXT_DEL_FLAG)
 607  7942 C2 BE 79     	jp nz, NextExt			;check for deleted
 608  7945
 609  7945              	;count AU
 610  7945 D9           	exx
 611  7946 E5           	push hl
 612  7947 CD 07 7D     		call CheckExtAlloc
 613  794A EB           		ex de, hl			;save first AU no.
 614  794B
 615  794B              		;store disk alocated AU count
 616  794B 2A 19 88     		ld hl, (AUCnt)
 617  794E 48           		ld c, b
 618  794F 06 00        		ld b, 0
 619  7951 09           		add hl, bc
 620  7952 22 19 88     		ld (AUCnt), hl
 621  7955 E1           	pop hl
 622  7956 D9           	exx
 623  7957
 624  7957 AF           	xor	a
 625  7958 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 626  795B 20 3A        	jr nz, FindExt
 627  795D
 628  795D DD E5        	push ix
 629  795F E1           	pop hl
 630  7960 23           	inc hl					;skip del flag
 631  7961
 632  7961 C5           	push bc
 633  7962 D5           		push de
 634  7963 E5           			push hl
 635  7964 EB           				ex de, hl
 636  7965 CD EC 78     				call DisplayFilename
 637  7968 E1           			pop hl
 638  7969 D1           		pop de
 639  796A 01 0B 00     		ld bc, NAMELEN
 640  796D ED B0        		ldir				;save file name
 641  796F
 642  796F D9           		exx
 643  7970 D5           		push 	de			;de = first AU
 644  7971 D9           		exx
 645  7972 E1           		pop		hl
 646  7973 EB           		ex		de, hl
 647  7974 73 23 72 2B  		ld		(hl), de	;save first AU
 648  7978
 649  7978 23           		inc		hl
 650  7979 23           		inc		hl
 651  797A
 652  797A D9           		exx					;save AU cnt for file
 653  797B C5           		push	bc
 654  797C D9           		exx
 655  797D C1           		pop		bc
 656  797E 71 23 70 2B  		ld		(hl), bc
 657  7982
 658  7982 23           		inc		hl
 659  7983 23           		inc		hl
 660  7984
 661  7984              		;xor		a			;make flag 0 to signal that header is not read yet
 662  7984              		;ld		(hl), a
 663  7984
 664  7984 01 0A 00     		ld		bc, HDR_SZ + 1
 665  7987 09           		add		hl, bc
 666  7988
 667  7988 EB           		ex		de, hl
 668  7989 C1           	pop bc
 669  798A
 670  798A
 671  798A 3A 14 88     	ld 		a, (FileCnt)			;inc file counter
 672  798D 3C           	inc		a
 673  798E 32 14 88     	ld 		(FileCnt), a
 674  7991 FE 5C        	cp		LST_MAX_FILES
 675  7993 38 29        	jr		c, NextExt
 676  7995 18 34        	jr		GetFileNamesEnd
 677  7997
 678  7997
 679  7997              FindExt:					;BC' = AU cnt for this ext
 680  7997 C5           	push	bc
 681  7998 D5           		push 	de
 682  7999 DD E5        			push	ix
 683  799B D1           			pop		de
 684  799C 13           			inc		de				;DE = name to find
 685  799D
 686  799D 21 1D 88     			ld		hl, FileCache
 687  79A0 3A 14 88     			ld		a, (FileCnt)
 688  79A3 4F           			ld		c, a
 689  79A4 CD C3 7E     			call	FindCache
 690  79A7 20 13        			jr		nz, FindExtEnd
 691  79A9
 692  79A9 01 0D 00     			ld		bc, CACHE_AU_CNT
 693  79AC 09           			add		hl, bc
 694  79AD D9           			exx
 695  79AE C5           			push	bc
 696  79AF D9           			exx
 697  79B0 C1           			pop		bc
 698  79B1
 699  79B1 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 700  79B5 EB           			ex		de, hl
 701  79B6 09           			add		hl, bc
 702  79B7 EB           			ex		de, hl
 703  79B8 73 23 72 2B  			ld		(hl), de
 704  79BC              FindExtEnd:
 705  79BC D1           		pop		de
 706  79BD C1           	pop		bc
 707  79BE
 708  79BE              NextExt:
 709  79BE C5           	push bc
 710  79BF 01 20 00     		ld bc, EXT_SZ
 711  79C2 DD 09        		add ix, bc
 712  79C4 C1           	pop	bc
 713  79C5
 714  79C5 05           	dec	b
 715  79C6 78           	ld	a, b
 716  79C7 B7           	or	a
 717  79C8 C2 3E 79     	jp	nz, StoreFilenamesLoop
 718  79CB              GetFileNamesEnd:
 719  79CB C9           	ret
 720  79CC
 721  79CC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 722  79CC
 723  79CC              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 724  79CC              ;IN: HL = file name
 725  79CC              HandleFile:
 726  79CC              	;Make HL point to the selected file
 727  79CC DD 2A 1B 88  	ld		ix, (SelFileCache)
 728  79D0 DD E5        	push	ix
 729  79D2 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 730  79D5 B7           		or		a
 731  79D6 CC D4 7E     		call	z, ReadFileHeader
 732  79D9
 733  79D9 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 734  79DC FE 00        		cp		PROG_TYPE
 735  79DE 28 59        		jr		z, HandleFileProg
 736  79E0
 737  79E0 FE 03        		cp		BYTE_TYPE
 738  79E2 20 65        		jr		nz, HandleFileText
 739  79E4
 740  79E4 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 740  79E8 66 12
 741  79EA 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 742  79ED 19           		add		hl, de
 743  79EE 7C           		ld		a, h
 744  79EF B5           		or		l
 745  79F0 28 29        		jr		z, HandleFileSCR
 746  79F2
 747  79F2
 748  79F2              HandleFileCODE:
 749  79F2 21 C8 86     		ld		hl, MsgLoadingCODE
 750  79F5 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 751  79F8 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 752  79FA CD 18 81     		call	PrintStrClr
 753  79FD
 754  79FD              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 755  79FD 21 3E 7E     		ld		hl, IF1FileLoad
 756  7A00 11 00 5B     		ld		de, PRN_BUF
 757  7A03 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 758  7A06 ED B0        		ldir
 759  7A08 3E C9        		ld		a, $C9
 760  7A0A 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 761  7A0B
 762  7A0B E1           	pop		hl
 763  7A0C ED 5B 84 A4  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 764  7A10 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 765  7A11 C1           	pop		bc						;2nd, 3rd call for error handler
 766  7A12 C1           	pop		bc
 767  7A13 ED 43 3D 5C  	ld		(ERRSP), bc
 768  7A17 D5           	push	de						;push CODE address to return to = start of CODE block
 769  7A18 C3 00 5B     	jp		PRN_BUF
 770  7A1B
 771  7A1B
 772  7A1B
 773  7A1B
 774  7A1B              HandleFileSCR:
 775  7A1B 21 B9 86     		ld		hl, MsgLoadingSCR
 776  7A1E 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 777  7A21 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 778  7A23 CD 18 81     		call	PrintStrClr
 779  7A26
 780  7A26 E1           	pop		hl
 781  7A27
 782  7A27              	IFDEF _ROM_FNT_
 783  7A27              		;Load to alternate SCREEN$ memory
 784  7A27 11 00 C0     		ld		de, HC_VID_BANK1
 785  7A2A CD 3E 7E     		call	IF1FileLoad
 786  7A2D
 787  7A2D              		;Set display to alternate SCREEN$ memory
 788  7A2D 3E 08        		ld		a, HC_CFG_VID_C000
 789  7A2F D3 7E        		out 	(HC_CFG_PORT), a
 790  7A31 CD B4 80     		call	ReadChar
 791  7A34
 792  7A34              		;Set back to regular SCREEN$ memory
 793  7A34 3E 00        		ld		a, HC_CFG_VID_4000
 794  7A36 D3 7E        		out 	(HC_CFG_PORT), a
 795  7A38              	ELSE
 796  7A38 ~            		ld		de, HC_VID_BANK0
 797  7A38 ~            		call	IF1FileLoad
 798  7A38 ~            		call	ReadChar
 799  7A38              	ENDIF
 800  7A38
 801  7A38 C9           	ret
 802  7A39
 803  7A39              HandleFileProg:
 804  7A39 21 AA 86     		ld		hl, MsgLoadingPrg
 805  7A3C 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 806  7A3F 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 807  7A41 CD 18 81     		call	PrintStrClr
 808  7A44 E1           	pop		hl
 809  7A45 CD 0C 7F     	call	LoadProgram
 810  7A48 C9           	ret
 811  7A49
 812  7A49
 813  7A49              HandleFileText:
 814  7A49 E1           	pop		hl
 815  7A4A
 816  7A4A
 817  7A4A              ViewFile:
 818  7A4A CD D0 80     	call	ClrScr
 819  7A4D 2A 1B 88     	ld		hl, (SelFileCache)
 820  7A50 11 81 AC     	ld		de, FileData			;File buffer, after the index
 821  7A53
 822  7A53 D5           	push	de
 823  7A54 D5           		push	de
 824  7A55 CD 3E 7E     			call	IF1FileLoad		;DE = last addr.
 825  7A58 EB           			ex		de, hl
 826  7A59 D1           		pop		de
 827  7A5A B7           		or		a
 828  7A5B ED 52        		sbc		hl, de
 829  7A5D 44           		ld		b, h
 830  7A5E 4D           		ld		c, l
 831  7A5F E1           	pop		hl
 832  7A60 CD 77 82     	call	InitViewer
 833  7A63 CD D1 82     	call	PrintLoop
 834  7A66 C9           	ret
 835  7A67
 836  7A67              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 837  7A67
 838  7A67
 839  7A67              DisplayFileInfo:
 840  7A67 2A 1B 88     	ld		hl, (SelFileCache)
 841  7A6A E5           	push	hl
 842  7A6B              		;disk size
 843  7A6B 01 0D 00     		ld		bc, CACHE_AU_CNT
 844  7A6E 09           		add		hl, bc
 845  7A6F 5E 23 56 2B  		ld		de, (hl)
 846  7A73 EB           		ex		de, hl
 847  7A74 11 E1 86     		ld		de, MsgFileSzDskN
 848  7A77
 849  7A77 06 0B        		ld		b, 11
 850  7A79              MultKb:
 851  7A79 29           		add		hl, hl
 852  7A7A 10 FD        		djnz	MultKb
 853  7A7C
 854  7A7C
 855  7A7C CD 38 7C     		call	Word2Txt
 856  7A7F 21 D8 86     		ld		hl, MsgFileSzDsk
 857  7A82 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
 858  7A85 CD F0 80     		call	PrintStr
 859  7A88 E1           	pop		hl
 860  7A89 E5           	push	hl
 861  7A8A              		;attributes
 862  7A8A 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 863  7A8D 09           		add		hl, bc
 864  7A8E EB           		ex		de, hl
 865  7A8F 21 F1 86     		ld		hl, MsgFileAttrN
 866  7A92 1A           		ld		a, (de)
 867  7A93 E6 80        		and		%10000000
 868  7A95 28 14        		jr		z, NotRO
 869  7A97
 870  7A97 01 52 2F     		ld		bc, '/R'
 871  7A9A 71 23 70 2B  		ld		(hl), bc
 872  7A9E 23           		inc		hl
 873  7A9F 23           		inc		hl
 874  7AA0 01 4F 2C     		ld		bc, ',O'
 875  7AA3 71 23 70 2B  		ld		(hl), bc
 876  7AA7 23           		inc		hl
 877  7AA8 23           		inc		hl
 878  7AA9 18 12        		jr		CheckSys
 879  7AAB              NotRO:
 880  7AAB 01 2D 2D     		ld		bc, '--'
 881  7AAE 71 23 70 2B  		ld		(hl), bc
 882  7AB2 23           		inc		hl
 883  7AB3 23           		inc		hl
 884  7AB4 01 2D 2C     		ld		bc, ',-'
 885  7AB7 71 23 70 2B  		ld		(hl), bc
 886  7ABB 23           		inc		hl
 887  7ABC 23           		inc		hl
 888  7ABD
 889  7ABD              CheckSys:
 890  7ABD 13           		inc		de
 891  7ABE 1A           		ld		a, (de)
 892  7ABF E6 80        		and		%10000000
 893  7AC1 28 0E        		jr		z, NotSYS
 894  7AC3
 895  7AC3 01 48 49     		ld		bc, 'IH'
 896  7AC6 71 23 70 2B  		ld		(hl), bc
 897  7ACA 23           		inc		hl
 898  7ACB 23           		inc		hl
 899  7ACC 3E C4        		ld		a, 'D' + $80
 900  7ACE 77           		ld		(hl), a
 901  7ACF 18 0C        		jr		AttrEnd
 902  7AD1              NotSYS:
 903  7AD1 01 2D 2D     		ld		bc, '--'
 904  7AD4 71 23 70 2B  		ld		(hl), bc
 905  7AD8 23           		inc		hl
 906  7AD9 23           		inc		hl
 907  7ADA 3E AD        		ld		a, '-' + $80
 908  7ADC 77           		ld		(hl), a
 909  7ADD              AttrEnd:
 910  7ADD 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
 911  7AE0 21 E8 86     		ld		hl, MsgFileAttr
 912  7AE3 CD F0 80     		call	PrintStr
 913  7AE6 DD E1        	pop		ix
 914  7AE8 DD E5        	push	ix
 915  7AEA DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 916  7AED B7           		or		a
 917  7AEE CA 8D 7B             jp		z, HeadNotRead
 918  7AF1
 919  7AF1 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
 920  7AF4 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
 921  7AF7 CA 8D 7B             jp		z, HeadNotRead
 922  7AFA
 923  7AFA DD 7E 10     		ld		a, (ix + CACHE_HDR)
 924  7AFD FE 00        		cp		PROG_TYPE
 925  7AFF 20 0B        		jr		nz, CheckNoArr
 926  7B01
 927  7B01 21 0B 87     		ld		hl, MsgFileTypePrg
 928  7B04 11 01 87     		ld		de, MsgFileTypeN
 929  7B07 CD D6 7B     		call	MoveMsg
 930  7B0A 18 51        		jr		PrepFileLen
 931  7B0C
 932  7B0C              CheckNoArr:
 933  7B0C FE 01        		cp		NUMB_TYPE
 934  7B0E 20 0B        		jr		nz, CheckChrArr
 935  7B10
 936  7B10 21 27 87     		ld		hl, MsgFileTypeNoA
 937  7B13 11 01 87     		ld		de, MsgFileTypeN
 938  7B16 CD D6 7B     		call	MoveMsg
 939  7B19 18 42        		jr		PrepFileLen
 940  7B1B
 941  7B1B              CheckChrArr:
 942  7B1B FE 02        		cp		CHAR_TYPE
 943  7B1D 20 0B        		jr		nz, CheckByte
 944  7B1F
 945  7B1F 21 20 87     		ld		hl, MsgFileTypeChrA
 946  7B22 11 01 87     		ld		de, MsgFileTypeN
 947  7B25 CD D6 7B     		call	MoveMsg
 948  7B28 18 33        		jr		PrepFileLen
 949  7B2A
 950  7B2A              CheckByte:
 951  7B2A FE 03        		cp		BYTE_TYPE
 952  7B2C 20 24        		jr		nz, CheckText
 953  7B2E
 954  7B2E DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
 954  7B32 66 12
 955  7B34 01 00 E5     		ld		bc, -SCR_LEN
 956  7B37 09           		add		hl, bc
 957  7B38 7C           		ld		a, h
 958  7B39 B5           		or		l
 959  7B3A 20 0B        		jr		nz, NotScr
 960  7B3C
 961  7B3C 21 19 87     		ld		hl, MsgFileTypeSCR
 962  7B3F 11 01 87     		ld		de, MsgFileTypeN
 963  7B42 CD D6 7B     		call	MoveMsg
 964  7B45 18 16        		jr		PrepFileLen
 965  7B47              NotScr:
 966  7B47 21 12 87     		ld		hl, MsgFileTypeByte
 967  7B4A 11 01 87     		ld		de, MsgFileTypeN
 968  7B4D CD D6 7B     		call	MoveMsg
 969  7B50 18 0B        		jr		PrepFileLen
 970  7B52
 971  7B52              CheckText:
 972  7B52 21 2E 87     		ld		hl, MsgFileTypeText
 973  7B55 11 01 87     		ld		de, MsgFileTypeN
 974  7B58 CD D6 7B     		call	MoveMsg
 975  7B5B 18 39        		jr		NoHeader
 976  7B5D
 977  7B5D              PrepFileLen:
 978  7B5D              		;File len
 979  7B5D DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
 980  7B60 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 981  7B63 11 45 87     		ld		de, MsgFileLenN
 982  7B66 CD 38 7C     		call	Word2Txt
 983  7B69 26 C2        		ld		h, 'B' | $80
 984  7B6B 2E 20        		ld		l, ' '
 985  7B6D 22 4A 87     		ld		(MsgFileLenN + 5), hl
 986  7B70
 987  7B70 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 988  7B73 FE 00        		cp		PROG_TYPE
 989  7B75 28 06        		jr		z, PrintProgStart
 990  7B77
 991  7B77 FE 03        		cp		BYTE_TYPE
 992  7B79 28 0A        		jr		z, PrintByteStart
 993  7B7B 18 22        		jr		PrintStartNotRead
 994  7B7D
 995  7B7D              PrintProgStart:
 996  7B7D DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
 997  7B80 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
 998  7B83 18 25        		jr		PrintStart
 999  7B85
1000  7B85              PrintByteStart:
1001  7B85 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1002  7B88 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1003  7B8B 18 1D        		jr		PrintStart
1004  7B8D
1005  7B8D              HeadNotRead:
1006  7B8D 21 35 87             ld        hl, MsgFileTypeUnkn
1007  7B90 11 01 87             ld        de, MsgFileTypeN
1008  7B93 CD D6 7B             call    MoveMsg
1009  7B96
1010  7B96              NoHeader:
1011  7B96 21 35 87     		ld		hl, MsgFileTypeUnkn
1012  7B99 11 45 87     		ld		de, MsgFileLenN
1013  7B9C CD D6 7B     		call	MoveMsg
1014  7B9F
1015  7B9F              PrintStartNotRead:
1016  7B9F 21 35 87     		ld		hl, MsgFileTypeUnkn
1017  7BA2 11 55 87     		ld		de, MsgFileStartN
1018  7BA5 CD D6 7B     		call	MoveMsg
1019  7BA8 18 0E        		jr		PrintStartStr
1020  7BAA
1021  7BAA              PrintStart:
1022  7BAA 1E 20        	ld		e, ' '
1023  7BAC 16 A0        	ld		d, ' ' | $80
1024  7BAE ED 53 5A 87  	ld		(MsgFileStartN + 5), de
1025  7BB2 11 55 87     	ld		de, MsgFileStartN
1026  7BB5 CD 38 7C     	call	Word2Txt
1027  7BB8              PrintStartStr:
1028  7BB8 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1029  7BBB 21 4C 87     	ld		hl, MsgFileStart
1030  7BBE CD F0 80     	call	PrintStr
1031  7BC1
1032  7BC1 DD E1        	pop		ix
1033  7BC3 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1034  7BC6 21 F8 86     	ld		hl, MsgFileType
1035  7BC9 CD F0 80     	call	PrintStr
1036  7BCC
1037  7BCC 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1038  7BCF 21 3C 87     	ld		hl, MsgFileLen
1039  7BD2 CD F0 80     	call	PrintStr
1040  7BD5
1041  7BD5 C9           	ret
1042  7BD6
1043  7BD6              MoveMsg:
1044  7BD6 01 07 00     	ld		bc, 7
1045  7BD9 ED B0        	ldir
1046  7BDB C9           	ret
1047  7BDC
1048  7BDC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1049  7BDC
1050  7BDC              ReadAllHeaders:
1051  7BDC 21 5C 87     	ld		hl, MsgReadingExt
1052  7BDF 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1053  7BE2 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1054  7BE4 CD 18 81     	call	PrintStrClr
1055  7BE7
1056  7BE7 CD 8B 76     	call	CalcFileCache
1057  7BEA
1058  7BEA 3A 16 88     	ld		a, (SelFile)
1059  7BED 47           	ld		b, a
1060  7BEE 3A 14 88     	ld		a, (FileCnt)
1061  7BF1 90           	sub		b
1062  7BF2 B7           	or		a
1063  7BF3 C8           	ret		z
1064  7BF4
1065  7BF4 47           	ld		b, a
1066  7BF5
1067  7BF5 DD 2A 1B 88  	ld		ix, (SelFileCache)
1068  7BF9              NextFile:
1069  7BF9 C5           	push	bc
1070  7BFA CD D4 7E     		call	ReadFileHeader
1071  7BFD 01 19 00     		ld		bc, CACHE_SZ
1072  7C00 DD 09        		add		ix, bc
1073  7C02 DD E5        		push	ix
1074  7C04 CD 8B 76     			call	CalcFileCache
1075  7C07 CD 67 7A     			call	DisplayFileInfo
1076  7C0A DD E1        		pop		ix
1077  7C0C
1078  7C0C CD B7 80     		call	KbdHit
1079  7C0F 38 03        		jr		c, AKey
1080  7C11 C1           	pop		bc
1081  7C12 18 15        	jr		ReadAllHeadersEnd
1082  7C14
1083  7C14              AKey:
1084  7C14 3A 16 88     		ld		a, (SelFile)
1085  7C17 3C           		inc		a
1086  7C18 47           		ld		b, a
1087  7C19 3A 14 88     		ld		a, (FileCnt)
1088  7C1C B8           		cp		b
1089  7C1D 28 16        		jr		z, DontInc
1090  7C1F 78           		ld		a, b
1091  7C20 32 16 88     		ld		(SelFile), a
1092  7C23 CD BB 81     		call	MoveCursor
1093  7C26 C1           	pop		bc
1094  7C27 10 D0        	djnz	NextFile
1095  7C29
1096  7C29              ReadAllHeadersEnd:
1097  7C29 21 6A 87     	ld		hl, MsgClear
1098  7C2C 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1099  7C2F 3E 0F        	ld		a, SCR_DEF_CLR
1100  7C31 CD 18 81     	call	PrintStrClr
1101  7C34 C9           	ret
1102  7C35
1103  7C35              DontInc:
1104  7C35 C1           	pop		bc
1105  7C36 18 F1        	jr		ReadAllHeadersEnd
1106  7C38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1107  7C38
1108  7C38              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 7C38              	ifndef	_HCCFG_
   2+ 7C38              	define	_HCCFG_
   3+ 7C38
   4+ 7C38              ;HC specific code, for configuration
   5+ 7C38
   6+ 7C38              HC_CFG_PORT			EQU	$7E
   7+ 7C38
   8+ 7C38              ;BASIC/CPM ROM selection
   9+ 7C38              HC_CFG_ROM_BAS		EQU	%0
  10+ 7C38              HC_CFG_ROM_CPM		EQU	%1
  11+ 7C38
  12+ 7C38              ;Address for ROM paging: 0 or $E000
  13+ 7C38              HC_CFG_ROM_0000		EQU %00
  14+ 7C38              HC_CFG_ROM_E000		EQU %10
  15+ 7C38
  16+ 7C38              ;Cfg. port Enable/Disable
  17+ 7C38              HC_CFG_PORT_DIS		EQU %000
  18+ 7C38              HC_CFG_PORT_EN		EQU	%100
  19+ 7C38
  20+ 7C38              ;Video memory bank: $4000 or $C000
  21+ 7C38              HC_CFG_VID_4000		EQU	%0000
  22+ 7C38              HC_CFG_VID_C000		EQU	%1000
  23+ 7C38
  24+ 7C38
  25+ 7C38              ;Standar BASIC config
  26+ 7C38              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 7C38              ;Standar CP/M config
  28+ 7C38              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 7C38
  30+ 7C38
  31+ 7C38              HC_VID_BANK0		EQU	$4000
  32+ 7C38              HC_VID_BANK1		EQU	$C000
  33+ 7C38
  34+ 7C38              	endif
# file closed: hccfg.asm
1109  7C38              	include "disk.asm"
# file opened: disk.asm
   1+ 7C38              ;HC IF1 routines and constants
   2+ 7C38
   3+ 7C38              ;IF1 routines error codes, also returned by BASIC commands
   4+ 7C38              ;12 = Writing to a 'read' file
   5+ 7C38              ;13 = Reading a 'write' file
   6+ 7C38              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 7C38              ;15 = Disk full (disk or catalog full)
   8+ 7C38              ;16 = Disk error (hardware error)
   9+ 7C38              ;17 = File not found
  10+ 7C38              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 7C38              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 7C38
  13+ 7C38              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 7C38              ;00h = OK
  15+ 7C38              ;08h = cannot format disk
  16+ 7C38              ;10h = disk protected (read-only?)
  17+ 7C38              ;20h = volume error
  18+ 7C38              ;40h = drive error
  19+ 7C38              ;80h = reading error
  20+ 7C38              ;Codes I encountered:
  21+ 7C38              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 7C38
  23+ 7C38
  24+ 7C38              	ifndef	_DISK_
  25+ 7C38              	define	_DISK_
  26+ 7C38
  27+ 7C38              	include	"math.asm"
# file opened: math.asm
   1++7C38              	ifndef	_MATH_
   2++7C38              	define	_MATH_
   3++7C38
   4++7C38              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++7C38              ;http://map.tni.nl/sources/external/z80bits.html
   6++7C38
   7++7C38
   8++7C38              Word2Txt:
   9++7C38              	IFUSED
  10++7C38 D5           	push	de
  11++7C39 CD 59 7C     		call	Word2Txt_
  12++7C3C D1           	pop		de
  13++7C3D
  14++7C3D 06 04        	ld		b, 4
  15++7C3F CD 4E 7C     	call	StrippLeading0
  16++7C42 C9           	ret
  17++7C43
  18++7C43              Byte2Txt:
  19++7C43 D5           	push	de
  20++7C44 CD 65 7C     		call	Byte2Txt_
  21++7C47 D1           	pop		de
  22++7C48
  23++7C48 06 02        	ld		b, 2
  24++7C4A CD 4E 7C     	call	StrippLeading0
  25++7C4D C9           	ret
  26++7C4E              	ENDIF
  27++7C4E
  28++7C4E
  29++7C4E              StrippLeading0:
  30++7C4E 1A           	ld		a, (de)
  31++7C4F FE 31        	cp		'1'
  32++7C51 D0           	ret		nc
  33++7C52
  34++7C52 3E 20        	ld		a, ' '
  35++7C54 12           	ld		(de), a
  36++7C55 13           	inc		de
  37++7C56 10 F6        	djnz	StrippLeading0
  38++7C58 C9           	ret
  39++7C59
  40++7C59
  41++7C59              ;Converts the number in HL to ASCII in decimal string at DE
  42++7C59              Word2Txt_:
  43++7C59 01 F0 D8     	ld bc, -10000
  44++7C5C CD 74 7C     	call DigitLoop
  45++7C5F 01 18 FC     	ld bc, -1000
  46++7C62 CD 74 7C     	call DigitLoop
  47++7C65              Byte2Txt_:
  48++7C65 01 9C FF     	ld bc, -100
  49++7C68 CD 74 7C     	call DigitLoop
  50++7C6B 01 F6 FF     	ld bc, -10
  51++7C6E CD 74 7C     	call DigitLoop
  52++7C71 01 FF FF     	ld bc, -1
  53++7C74
  54++7C74              DigitLoop:
  55++7C74 3E 2F        	ld	a, '0' - 1
  56++7C76              DivNrLoop:
  57++7C76 3C           	inc	a			;increase reminder
  58++7C77 09           	add	hl, bc		;substract divizor
  59++7C78 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++7C7A ED 42        	sbc	hl, bc		;nope, restore
  61++7C7C
  62++7C7C 12           	ld (de), a
  63++7C7D 13           	inc de
  64++7C7E C9           	ret
  65++7C7F
  66++7C7F
  67++7C7F              ;Input: HL = Dividend, C = Divisor
  68++7C7F              ;Output: HL = Quotient, A = Remainder
  69++7C7F              ;Warning: doesn't work with divisor >= $80
  70++7C7F              Div:
  71++7C7F              	IFUSED
  72++7C7F AF           	xor a
  73++7C80 06 10        	ld b, 16
  74++7C82
  75++7C82              DivLoop:
  76++7C82 29           	add	hl,hl
  77++7C83 17           	rla
  78++7C84 B9           	cp	c
  79++7C85 38 02        	jr	c, NoSub
  80++7C87 91           	sub	c
  81++7C88 2C           	inc	l
  82++7C89              NoSub:
  83++7C89 10 F7        	djnz DivLoop
  84++7C8B
  85++7C8B C9           	ret
  86++7C8C              	ENDIF
  87++7C8C
  88++7C8C              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++7C8C              ;Output: A:C = Quotient, HL = Remainder
  90++7C8C              Div2:
  91++7C8C 21 00 00     	ld hl, 0
  92++7C8F 06 10        	ld b, 16
  93++7C91              Div2Loop:
  94++7C91 CB 31        	sll c		; unroll 16 times
  95++7C93 17           	rla			; ...
  96++7C94 ED 6A        	adc	hl,hl		; ...
  97++7C96 ED 52        	sbc	hl,de		; ...
  98++7C98 30 02        	jr	nc,$+4		; ...
  99++7C9A 19           	add	hl,de		; ...
 100++7C9B 0D           	dec	c		; ...
 101++7C9C 10 F3        	djnz Div2Loop
 102++7C9E C9           	ret
 103++7C9F
 104++7C9F
 105++7C9F              ;Input: A = Multiplier, DE = Multiplicand
 106++7C9F              ;Output: A:HL = Product
 107++7C9F              Mul:
 108++7C9F              	IFUSED
 109++7C9F 21 00 00     	ld hl, 0
 110++7CA2 01 00 07     	ld bc, $0700
 111++7CA5
 112++7CA5 87           	add	a, a		; optimised 1st iteration
 113++7CA6 30 02        	jr	nc, MulLoop
 114++7CA8 62           	ld	h, d
 115++7CA9 6B           	ld	l, e
 116++7CAA
 117++7CAA              MulLoop:
 118++7CAA 29           	add	hl,hl
 119++7CAB 17           	rla
 120++7CAC 30 02        	jr	nc, NoAdd
 121++7CAE 19           	add	hl,de
 122++7CAF 89           	adc	a,c
 123++7CB0              NoAdd:
 124++7CB0 10 F8        	djnz MulLoop
 125++7CB2
 126++7CB2 C9           	ret
 127++7CB3              	ENDIF
 128++7CB3
 129++7CB3              	endif
# file closed: math.asm
  28+ 7CB3
  29+ 7CB3              DRIVE_CUR_BAS	EQU 0
  30+ 7CB3              DRIVE_A_BAS		EQU	1
  31+ 7CB3              DRIVE_B_BAS		EQU	2
  32+ 7CB3              DRIVE_A_CPM		EQU	0
  33+ 7CB3              DRIVE_B_CPM		EQU	1
  34+ 7CB3              ;Disk geometry stuff
  35+ 7CB3              SPT				EQU	16			;sectors per track
  36+ 7CB3              SECT_SZ			EQU	256			;sector size in bytes
  37+ 7CB3              TRACK_CNT		EQU	80			;track count
  38+ 7CB3              HEAD_CNT		EQU	2			;disk face count
  39+ 7CB3              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 7CB3              EXT_SZ			EQU	32			;directory entry size
  41+ 7CB3              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 7CB3              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 7CB3              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 7CB3              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 7CB3              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 7CB3              REC_SZ			EQU 128			;cp/m record size
  47+ 7CB3              DEL_MARKER		EQU	$E5
  48+ 7CB3              EOF_MARKER		EQU	$1B
  49+ 7CB3
  50+ 7CB3
  51+ 7CB3              ;Extension structure (directory entry)
  52+ 7CB3              EXT_DEL_FLAG	EQU	0
  53+ 7CB3              EXT_NAME		EQU 1
  54+ 7CB3              EXT_IDX			EQU 12
  55+ 7CB3              EXT_S1			EQU 13
  56+ 7CB3              EXT_S2			EQU 14
  57+ 7CB3              EXT_RC			EQU	15
  58+ 7CB3              EXT_AU0			EQU	16
  59+ 7CB3              EXT_AU1			EQU	18
  60+ 7CB3              EXT_AU2			EQU	20
  61+ 7CB3              EXT_AU3			EQU	22
  62+ 7CB3              EXT_AU4			EQU	24
  63+ 7CB3              EXT_AU5			EQU	26
  64+ 7CB3              EXT_AU6			EQU	28
  65+ 7CB3              EXT_AU7			EQU	30
  66+ 7CB3              EXT_SIZE		EQU 32
  67+ 7CB3
  68+ 7CB3              ;FCB structure
  69+ 7CB3              FCB_DRIVE		EQU 0
  70+ 7CB3              FCB_NAME		EQU EXT_NAME
  71+ 7CB3              FCB_EX_IDX		EQU EXT_IDX
  72+ 7CB3              FCB_S1			EQU EXT_S1
  73+ 7CB3              FCB_S2			EQU EXT_S2
  74+ 7CB3              FCB_RC			EQU	EXT_RC
  75+ 7CB3              FCB_AU			EQU	EXT_AU0
  76+ 7CB3              FCB_CR			EQU	32
  77+ 7CB3              FCB_R0			EQU 33
  78+ 7CB3              FCB_R1			EQU 34
  79+ 7CB3              FCB_R2			EQU 35
  80+ 7CB3              FCB_SIZE		EQU 36
  81+ 7CB3
  82+ 7CB3
  83+ 7CB3
  84+ 7CB3              ;System variables for disk
  85+ 7CB3              DSTR1			EQU	$5CD6		;drive
  86+ 7CB3              FSTR1			EQU	$5CDC		;file name
  87+ 7CB3              NSTR1			EQU	$5CDA		;name length
  88+ 7CB3              HD11			EQU	$5CED		;BDOS argument
  89+ 7CB3              COPIES			EQU	$5CEF		;BDOS function
  90+ 7CB3
  91+ 7CB3              ERRSP			EQU $5C3D
  92+ 7CB3              ERRNR			EQU $5C3A
  93+ 7CB3              ERRMSG			EQU	$0260
  94+ 7CB3
  95+ 7CB3              PROG			EQU $5C53
  96+ 7CB3              VARS			EQU	$5C4B
  97+ 7CB3              STKEND			EQU	$5C65
  98+ 7CB3
  99+ 7CB3              PRN_BUF			EQU	23296
 100+ 7CB3
 101+ 7CB3              ;STR_COPYRIGHT	EQU	$1539
 102+ 7CB3
 103+ 7CB3              REPDEL			EQU	23561
 104+ 7CB3              REPPER			EQU	23562
 105+ 7CB3              PIP				EQU	23609
 106+ 7CB3
 107+ 7CB3
 108+ 7CB3              ;RWTS routine commands
 109+ 7CB3              RWTS_CMD_POS	EQU	0			;position head
 110+ 7CB3              RWTS_CMD_READ	EQU	1			;read sector
 111+ 7CB3              RWTS_CMD_WRITE	EQU	2			;write sector
 112+ 7CB3              RWTS_CMD_FMT	EQU	4			;format all tracks
 113+ 7CB3
 114+ 7CB3
 115+ 7CB3              ;File name stuff
 116+ 7CB3              NAMELEN			EQU	11			;name length
 117+ 7CB3              RO_POS			EQU	8			;read-only attribute position in name
 118+ 7CB3              SYS_POS			EQU	9			;system attribute position in name
 119+ 7CB3
 120+ 7CB3              ;File types (first byte in header)
 121+ 7CB3              PROG_TYPE		EQU	0			;program
 122+ 7CB3              NUMB_TYPE		EQU	1			;number array
 123+ 7CB3              CHAR_TYPE		EQU	2			;char array
 124+ 7CB3              BYTE_TYPE		EQU	3			;bytes
 125+ 7CB3              TEXT_TYPE		EQU	4			;text, >= 4
 126+ 7CB3
 127+ 7CB3              ;File header offsets
 128+ 7CB3              HDR_TYPE		EQU	0
 129+ 7CB3              HDR_LEN			EQU 1
 130+ 7CB3              HDR_ADDR		EQU 3
 131+ 7CB3              HDR_PLEN		EQU	5
 132+ 7CB3              HDR_LINE		EQU 7
 133+ 7CB3              HDR_SZ			EQU	9
 134+ 7CB3
 135+ 7CB3              ;BASIC disk channel structure
 136+ 7CB3              CH_RW_FLAG		EQU 11
 137+ 7CB3              CH_FCB			EQU	12
 138+ 7CB3              CH_DATA			EQU	50
 139+ 7CB3              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 140+ 7CB3
 141+ 7CB3              CACHE_NAME		EQU	0					;11B
 142+ 7CB3              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 143+ 7CB3              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 144+ 7CB3              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 145+ 7CB3              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 146+ 7CB3              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 147+ 7CB3
 148+ 7CB3              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 149+ 7CB3
 150+ 7CB3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 151+ 7CB3              IF1Init:
 152+ 7CB3 CF           	rst		08
 153+ 7CB4 31           	defb	49		;create system variables
 154+ 7CB5 C9           	ret
 155+ 7CB6
 156+ 7CB6              ;ReadWriteTrackSector
 157+ 7CB6              ;A=command: 0, 1, 2, 4
 158+ 7CB6              RWTS:
 159+ 7CB6 32 64 7F     	ld (RWTSCmd), a
 160+ 7CB9 21 59 7F     	ld hl, RWTSParams
 161+ 7CBC 22 ED 5C     	ld (HD11), hl
 162+ 7CBF CF           	rst 08
 163+ 7CC0 3A           	DEFB 58
 164+ 7CC1 C9           	ret
 165+ 7CC2
 166+ 7CC2
 167+ 7CC2              ;D = sector, E = track
 168+ 7CC2              ;HL = dma
 169+ 7CC2              ReadOneDiskSector:
 170+ 7CC2 22 5E 7F     	ld (RWTSDMA), hl
 171+ 7CC5 ED 53 5C 7F  	ld (RWTSTrack), de
 172+ 7CC9              	;ld (RWTSDrive), a
 173+ 7CC9 3E 01        	ld a, RWTS_CMD_READ
 174+ 7CCB 18 E9        	jr	RWTS
 175+ 7CCD
 176+ 7CCD              ;D = sector, E = track
 177+ 7CCD              ;HL = dma
 178+ 7CCD              WriteOneDiskSector:
 179+ 7CCD 22 5E 7F     	ld (RWTSDMA), hl
 180+ 7CD0 ED 53 5C 7F  	ld (RWTSTrack), de
 181+ 7CD4              	;ld (RWTSDrive), a
 182+ 7CD4 3E 02        	ld a, RWTS_CMD_WRITE
 183+ 7CD6 18 DE        	jr	RWTS
 184+ 7CD8
 185+ 7CD8              FormatDisk:
 186+ 7CD8 21 81 A4     	ld		hl, DataBuf
 187+ 7CDB 36 E5        	ld		(hl), DEL_MARKER
 188+ 7CDD 22 5E 7F     	ld 		(RWTSDMA), hl
 189+ 7CE0 3E 04        	ld 		a, RWTS_CMD_FMT
 190+ 7CE2 CD B6 7C     	call	RWTS
 191+ 7CE5 3A 65 7F     	ld		a, (RWTSRes)
 192+ 7CE8 C9           	ret
 193+ 7CE9
 194+ 7CE9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 195+ 7CE9
 196+ 7CE9              ;Allocation unit no. to track/sector
 197+ 7CE9              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 198+ 7CE9              ;IN:  HL=alloc. unit no.
 199+ 7CE9              ;OUT: B=sector; C=track (head is determined by the sector number)
 200+ 7CE9              AU2TS:
 201+ 7CE9 0E 02        	ld c, SPT/SPAL
 202+ 7CEB CD 7F 7C     	call Div					;A = sector
 203+ 7CEE F5           	push af
 204+ 7CEF ~            		/*
 205+ 7CEF ~            		ld c, HEAD_CNT
 206+ 7CEF ~            		call Div				;L = track, A = head (0 or 1)
 207+ 7CEF ~            		*/
 208+ 7CEF AF           		xor a
 209+ 7CF0 CB 1C        		rr h
 210+ 7CF2 CB 1D        		rr l
 211+ 7CF4 CB 1F        		rr a
 212+ 7CF6
 213+ 7CF6 4D           		ld c, l
 214+ 7CF7 06 00        		ld b, 0
 215+ 7CF9 B7           		or a
 216+ 7CFA 28 02        		jr z, Track0
 217+ 7CFC 06 10        		ld b, SPT
 218+ 7CFE              Track0:
 219+ 7CFE F1           	pop af
 220+ 7CFF B7           	or a
 221+ 7D00 28 02        	jr z, FirstAU
 222+ 7D02 3E 08        	ld a, SPAL
 223+ 7D04              FirstAU:
 224+ 7D04 80           	add a, b
 225+ 7D05 47           	ld  b, a
 226+ 7D06 C9           	ret
 227+ 7D07
 228+ 7D07              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 229+ 7D07
 230+ 7D07              ;Checks the allocation units number used in extension
 231+ 7D07              ;IN:	IX = extension addr
 232+ 7D07              ;OUT:	B = no. of allocation units used
 233+ 7D07              ;		C = no. of records used in ext.
 234+ 7D07              ;		HL = first alloc. unit no.
 235+ 7D07              ;		DE = last alloc. unit no.
 236+ 7D07              CheckExtAlloc:
 237+ 7D07 DD E5        	push ix
 238+ 7D09 01 0F 00     		ld bc, EXT_RC
 239+ 7D0C DD 09        		add ix, bc
 240+ 7D0E DD 4E 00     		ld c, (ix)			;save rec. no.
 241+ 7D11 DD 23        		inc ix
 242+ 7D13 DD 6E 00     		ld l, (ix)
 243+ 7D16 DD 66 01     		ld h, (ix + 1)
 244+ 7D19 06 08        		ld b, EXT_AU_CNT
 245+ 7D1B              CheckAU:
 246+ 7D1B DD 7E 00     		ld a, (ix)
 247+ 7D1E DD B6 01     		or (ix + 1)
 248+ 7D21 28 0C        		jr z, CheckAUEnd
 249+ 7D23 DD 5E 00     		ld e, (ix)
 250+ 7D26 DD 56 01     		ld d, (ix + 1)
 251+ 7D29 DD 23        		inc ix
 252+ 7D2B DD 23        		inc ix
 253+ 7D2D 10 EC        		djnz CheckAU
 254+ 7D2F              CheckAUEnd:
 255+ 7D2F 3E 08        		ld a, EXT_AU_CNT
 256+ 7D31 90           		sub b
 257+ 7D32 47           		ld b, a
 258+ 7D33 DD E1        	pop ix
 259+ 7D35 C9           	ret
 260+ 7D36
 261+ 7D36              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 262+ 7D36
 263+ 7D36              ;Input: TrackBuffer
 264+ 7D36              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 265+ 7D36              ReadUsedBlocksList:
 266+ 7D36 DD 21 81 94  	ld		ix, TrackBuf			;source buffer
 267+ 7D3A 21 81 A4     	ld		hl, UsedBlockListCnt 	;destination buffer
 268+ 7D3D 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 269+ 7D40 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 270+ 7D43 73           	ld		(hl), e
 271+ 7D44 23           	inc		hl
 272+ 7D45 72           	ld		(hl), d
 273+ 7D46 23           	inc		hl
 274+ 7D47
 275+ 7D47              	;Add blocks 0 and 1 for directory
 276+ 7D47 11 00 00     	ld		de, 0
 277+ 7D4A 73           	ld		(hl), e
 278+ 7D4B 23           	inc		hl
 279+ 7D4C 72           	ld		(hl), d
 280+ 7D4D 23           	inc		hl
 281+ 7D4E
 282+ 7D4E 13           	inc		de
 283+ 7D4F 73           	ld		(hl), e
 284+ 7D50 23           	inc		hl
 285+ 7D51 72           	ld		(hl), d
 286+ 7D52 23           	inc		hl
 287+ 7D53
 288+ 7D53              ReadUsedBlocksLoop:
 289+ 7D53 AF           	xor		a
 290+ 7D54 DD BE 00     	cp		(ix)
 291+ 7D57 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 292+ 7D59
 293+ 7D59 DD E5        	push	ix
 294+ 7D5B C5           	push	bc
 295+ 7D5C 06 08        		ld		b, EXT_AU_CNT
 296+ 7D5E 11 10 00     		ld		de, EXT_AU0
 297+ 7D61 DD 19        		add		ix, de
 298+ 7D63
 299+ 7D63              ReadUsedBlocksLoop2:
 300+ 7D63 DD 5E 00     		ld		e, (ix)
 301+ 7D66 DD 56 01     		ld		d, (ix+1)
 302+ 7D69 7B           		ld		a, e
 303+ 7D6A B2           		or		d
 304+ 7D6B 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 305+ 7D6D
 306+ 7D6D 73           		ld		(hl), e
 307+ 7D6E 23           		inc		hl
 308+ 7D6F 72           		ld		(hl), d
 309+ 7D70 23           		inc		hl
 310+ 7D71
 311+ 7D71 DD 23        		inc		ix
 312+ 7D73 DD 23        		inc		ix
 313+ 7D75
 314+ 7D75 ED 5B 81 A4  		ld		de, (UsedBlockListCnt)
 315+ 7D79 13           		inc		de
 316+ 7D7A ED 53 81 A4  		ld		(UsedBlockListCnt), de
 317+ 7D7E
 318+ 7D7E 10 E3        		djnz	ReadUsedBlocksLoop2
 319+ 7D80
 320+ 7D80
 321+ 7D80              ReadUsedBlocksSkip:
 322+ 7D80 C1           	pop		bc
 323+ 7D81 DD E1        	pop		ix
 324+ 7D83              ReadUsedBlocksSkip2:
 325+ 7D83 11 20 00     	ld		de, EXT_SZ
 326+ 7D86 DD 19        	add		ix, de
 327+ 7D88
 328+ 7D88 0B           	dec		bc
 329+ 7D89 78           	ld		a, b
 330+ 7D8A B1           	or		c
 331+ 7D8B 20 C6        	jr		nz, ReadUsedBlocksLoop
 332+ 7D8D
 333+ 7D8D C9           	ret
 334+ 7D8E
 335+ 7D8E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 336+ 7D8E              ;Reads 8 sectors for an AU
 337+ 7D8E              ;HL = block number, DE = destination buffer
 338+ 7D8E              ReadFSBlock:
 339+ 7D8E D5           	push	de
 340+ 7D8F CD E9 7C     		call	AU2TS		;B=sector, C=track
 341+ 7D92 E1           	pop		hl				;HL=dest
 342+ 7D93
 343+ 7D93 50           	ld		d, b
 344+ 7D94 59           	ld		e, c
 345+ 7D95 06 08        	ld		b, SPAL
 346+ 7D97
 347+ 7D97              ReadFSBlockLoop:
 348+ 7D97 CD 84 7E     	call	ReadDiskSectors
 349+ 7D9A C9           	ret
 350+ 7D9B
 351+ 7D9B
 352+ 7D9B              ;Write 8 sectors for an AU
 353+ 7D9B              ;HL = block number, DE = source buffer
 354+ 7D9B              WriteFSBlock:
 355+ 7D9B D5           	push	de
 356+ 7D9C CD E9 7C     		call	AU2TS		;B=sector, C=track
 357+ 7D9F E1           	pop		hl				;HL=dest
 358+ 7DA0
 359+ 7DA0 50           	ld		d, b
 360+ 7DA1 59           	ld		e, c
 361+ 7DA2 06 08        	ld		b, SPAL
 362+ 7DA4
 363+ 7DA4              WriteFSBlockLoop:
 364+ 7DA4 CD 97 7E     	call	WriteDiskSectors
 365+ 7DA7 C9           	ret
 366+ 7DA8
 367+ 7DA8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 368+ 7DA8              ;Copies the allocated blocks from one disk to another.
 369+ 7DA8              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 370+ 7DA8              CopyDisk:
 371+ 7DA8              	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 372+ 7DA8 CD 36 7D     	call	ReadUsedBlocksList
 373+ 7DAB DD 21 83 A4  	ld		ix, UsedBlockListBlk
 374+ 7DAF
 375+ 7DAF              CopyDiskLoop:
 376+ 7DAF 2A 81 A4     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 377+ 7DB2 11 05 88     	ld		de, MsgBlocksLeft
 378+ 7DB5 CD 43 7C     	call	Byte2Txt
 379+ 7DB8 21 05 88     	ld		hl, MsgBlocksLeft
 380+ 7DBB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 381+ 7DBE 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 382+ 7DC0 CD 18 81     	call	PrintStrClr
 383+ 7DC3
 384+ 7DC3              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 385+ 7DC3 21 0A 00     	ld		hl, MAX_AU_RAM
 386+ 7DC6 ED 4B 81 A4  	ld		bc, (UsedBlockListCnt)
 387+ 7DCA B7           	or		a
 388+ 7DCB ED 42        	sbc		hl, bc
 389+ 7DCD 30 03        	jr		nc, CopyDiskLoopRead
 390+ 7DCF 01 0A 00     	ld		bc, MAX_AU_RAM
 391+ 7DD2
 392+ 7DD2              CopyDiskLoopRead:
 393+ 7DD2 41           	ld		b, c
 394+ 7DD3 11 03 A7     	ld		de, CopyDiskBuf
 395+ 7DD6              	;save initial counter and initial block number array position
 396+ 7DD6 C5           	push	bc
 397+ 7DD7 DD E5        	push	ix
 398+ 7DD9
 399+ 7DD9              CopyDiskLoopReadLoop:
 400+ 7DD9 DD 6E 00     		ld		l, (ix)
 401+ 7DDC DD 66 01     		ld		h, (ix+1)
 402+ 7DDF DD 23        		inc		ix
 403+ 7DE1 DD 23        		inc		ix
 404+ 7DE3
 405+ 7DE3 D5           		push	de
 406+ 7DE4 C5           		push	bc
 407+ 7DE5 CD 8E 7D     			call	ReadFSBlock			;Stop on error or continue?
 408+ 7DE8 C1           		pop		bc
 409+ 7DE9 D1           		pop		de
 410+ 7DEA
 411+ 7DEA              		;+2048
 412+ 7DEA 7A           		ld		a, d
 413+ 7DEB C6 08        		add		8
 414+ 7DED 57           		ld		d, a
 415+ 7DEE
 416+ 7DEE 10 E9        		djnz	CopyDiskLoopReadLoop
 417+ 7DF0
 418+ 7DF0              		;alternate drive
 419+ 7DF0 3A 5A 7F     		ld		a, (RWTSDrive)
 420+ 7DF3 EE 03        		xor		%11
 421+ 7DF5 32 5A 7F     		ld		(RWTSDrive), a
 422+ 7DF8
 423+ 7DF8              	;restore initial counter and initial block number array position
 424+ 7DF8 DD E1        	pop		ix
 425+ 7DFA C1           	pop		bc
 426+ 7DFB 11 03 A7     	ld		de, CopyDiskBuf
 427+ 7DFE C5           	push	bc
 428+ 7DFF
 429+ 7DFF              CopyDiskLoopWriteLoop:
 430+ 7DFF DD 6E 00     		ld		l, (ix)
 431+ 7E02 DD 66 01     		ld		h, (ix+1)
 432+ 7E05 DD 23        		inc		ix
 433+ 7E07 DD 23        		inc		ix
 434+ 7E09
 435+ 7E09 D5           		push	de
 436+ 7E0A C5           		push	bc
 437+ 7E0B CD 9B 7D     			call	WriteFSBlock		;Stop on error or continue?
 438+ 7E0E C1           		pop		bc
 439+ 7E0F D1           		pop		de
 440+ 7E10
 441+ 7E10              		;+2048
 442+ 7E10 7A           		ld		a, d
 443+ 7E11 C6 08        		add		8
 444+ 7E13 57           		ld		d, a
 445+ 7E14
 446+ 7E14 10 E9        		djnz	CopyDiskLoopWriteLoop
 447+ 7E16
 448+ 7E16              		;alternate drive again
 449+ 7E16 3A 5A 7F     		ld		a, (RWTSDrive)
 450+ 7E19 EE 03        		xor		%11
 451+ 7E1B 32 5A 7F     		ld		(RWTSDrive), a
 452+ 7E1E
 453+ 7E1E C1           	pop		bc
 454+ 7E1F 48           	ld		c, b
 455+ 7E20 06 00        	ld		b, 0
 456+ 7E22
 457+ 7E22              	;Decrease number of blocks read by now.
 458+ 7E22 2A 81 A4     	ld		hl, (UsedBlockListCnt)
 459+ 7E25 B7           	or		a
 460+ 7E26 ED 42        	sbc		hl, bc
 461+ 7E28 22 81 A4     	ld		(UsedBlockListCnt), hl
 462+ 7E2B
 463+ 7E2B 7D           	ld		a, l
 464+ 7E2C B4           	or		h
 465+ 7E2D C2 AF 7D     	jp		nz, CopyDiskLoop
 466+ 7E30
 467+ 7E30 C9           	ret
 468+ 7E31
 469+ 7E31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 470+ 7E31
 471+ 7E31              ;Compare string at HL with the one at DE, max length B
 472+ 7E31              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 473+ 7E31              ;OUT: z flag, set = match, reset = mismatch
 474+ 7E31              StrCmp:
 475+ 7E31 E5           	push hl
 476+ 7E32 D5           	push de
 477+ 7E33              Compare:
 478+ 7E33 1A           		ld a, (de)
 479+ 7E34 BE           		cp (hl)
 480+ 7E35 20 04        		jr nz, MisMatch
 481+ 7E37 23           		inc hl
 482+ 7E38 13           		inc de
 483+ 7E39 10 F8        		djnz Compare
 484+ 7E3B              MisMatch:
 485+ 7E3B D1           	pop de
 486+ 7E3C E1           	pop hl
 487+ 7E3D C9           	ret
 488+ 7E3E
 489+ 7E3E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 490+ 7E3E
 491+ 7E3E              ;Read a file into a buffer, sector by sector.
 492+ 7E3E              ;It's relocatable, to moved and be used when loading a CODE block.
 493+ 7E3E              ;It's not using BDOS, but using similar calls provided by IF1.
 494+ 7E3E              ;In: HL = Name address, DE = buffer
 495+ 7E3E              IF1FileLoad:
 496+ 7E3E D5           	push	de
 497+ 7E3F 22 DC 5C     		ld (FSTR1), hl
 498+ 7E42 26 00        		ld h, 0
 499+ 7E44 3A 5A 7F     		ld a, (RWTSDrive)
 500+ 7E47 3C           		inc  a			;CP/M drive number to BASIC drive number
 501+ 7E48 6F           		ld	l, a
 502+ 7E49 22 D6 5C     		ld (DSTR1), hl
 503+ 7E4C 2E 0B        		ld l,NAMELEN
 504+ 7E4E 22 DA 5C     		ld (NSTR1), hl
 505+ 7E51 CF           		rst 08
 506+ 7E52 33           		DEFB 51			;open disk channel
 507+ 7E53
 508+ 7E53 CF           		rst		8
 509+ 7E54 35           		defb	53		;read sector
 510+ 7E55 D1           	pop		de
 511+ 7E56 30 27        	jr		nc, FileFree
 512+ 7E58
 513+ 7E58 DD 7E 32     	ld		a, (ix + CH_DATA)
 514+ 7E5B FE 04        	cp		TEXT_TYPE
 515+ 7E5D 30 12        	jr		nc, FileLoadNoHeader
 516+ 7E5F
 517+ 7E5F              FileLoadHeader:
 518+ 7E5F DD E5        	push	ix
 519+ 7E61 E1           	pop		hl
 520+ 7E62 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 521+ 7E65 09           	add		hl, bc
 522+ 7E66 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 523+ 7E69 ED B0        	ldir
 524+ 7E6B
 525+ 7E6B              FileReadLoop:
 526+ 7E6B D5           	push	de
 527+ 7E6C CF           		rst		8
 528+ 7E6D 35           		defb	53		;read sector
 529+ 7E6E D1           	pop		de
 530+ 7E6F 30 0E        	jr		nc, FileFree
 531+ 7E71
 532+ 7E71              FileLoadNoHeader:
 533+ 7E71 DD E5        	push	ix
 534+ 7E73 E1           	pop		hl
 535+ 7E74 01 32 00     	ld		bc, CH_DATA
 536+ 7E77 09           	add		hl, bc
 537+ 7E78 01 00 01     	ld		bc, SECT_SZ
 538+ 7E7B ED B0        	ldir
 539+ 7E7D 18 EC        	jr		FileReadLoop
 540+ 7E7F              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 541+ 7E7F              IF1FileLoadEnd:
 542+ 7E7F
 543+ 7E7F              FileFree:
 544+ 7E7F D5           	push	de
 545+ 7E80 CF           	rst		8
 546+ 7E81 38           	defb	56			;close channel (52) or detroy channel (56)
 547+ 7E82 D1           	pop		de
 548+ 7E83 C9           	ret
 549+ 7E84
 550+ 7E84
 551+ 7E84              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 552+ 7E84              ;HL = destination buffer, B = count of sectors, DE = track/sector
 553+ 7E84              ;Out: A = error code, 0=OK
 554+ 7E84              ReadDiskSectors:
 555+ 7E84 C5           	push bc
 556+ 7E85 E5           		push hl
 557+ 7E86 D5           			push de
 558+ 7E87 CD C2 7C     				call ReadOneDiskSector
 559+ 7E8A D1           			pop de
 560+ 7E8B E1           		pop hl
 561+ 7E8C
 562+ 7E8C 14           		inc d
 563+ 7E8D 24           		inc h
 564+ 7E8E C1           	pop bc
 565+ 7E8F
 566+ 7E8F 3A 65 7F     	ld	a, (RWTSRes)
 567+ 7E92 B7           	or	a
 568+ 7E93 C0           	ret nz
 569+ 7E94
 570+ 7E94 10 EE        	djnz ReadDiskSectors
 571+ 7E96 C9           	ret
 572+ 7E97
 573+ 7E97              ;HL = source buffer, B = count of sectors, DE = track/sector
 574+ 7E97              ;Out: A = error code, 0=OK
 575+ 7E97              WriteDiskSectors:
 576+ 7E97 C5           	push bc
 577+ 7E98 E5           		push hl
 578+ 7E99 D5           			push de
 579+ 7E9A CD CD 7C     				call WriteOneDiskSector
 580+ 7E9D D1           			pop de
 581+ 7E9E E1           		pop hl
 582+ 7E9F
 583+ 7E9F 14           		inc d
 584+ 7EA0 24           		inc h
 585+ 7EA1 C1           	pop bc
 586+ 7EA2
 587+ 7EA2 3A 65 7F     	ld	a, (RWTSRes)
 588+ 7EA5 B7           	or	a
 589+ 7EA6 C0           	ret nz
 590+ 7EA7
 591+ 7EA7 10 EE        	djnz WriteDiskSectors
 592+ 7EA9 C9           	ret
 593+ 7EAA
 594+ 7EAA
 595+ 7EAA              ;Reads disk catalog
 596+ 7EAA              ReadCatalogTrack:
 597+ 7EAA 21 81 94     	ld hl, TrackBuf
 598+ 7EAD 11 00 00     	ld de, 0
 599+ 7EB0 06 10        	ld b, SPT
 600+ 7EB2
 601+ 7EB2 CD 84 7E     	call ReadDiskSectors
 602+ 7EB5 B7           	or   a
 603+ 7EB6 C0           	ret  nz
 604+ 7EB7
 605+ 7EB7              	;Sync with BDOS, to avoid disk R/O error on disk change
 606+ 7EB7 F5           	push  af
 607+ 7EB8 3A 5A 7F     		ld  a, (RWTSDrive)
 608+ 7EBB CD 6F 7F     		call BDOSSelectDisk
 609+ 7EBE CD 6C 7F     		call BDOSInit
 610+ 7EC1 F1           	pop   af
 611+ 7EC2 C9           	ret
 612+ 7EC3
 613+ 7EC3
 614+ 7EC3
 615+ 7EC3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 616+ 7EC3
 617+ 7EC3              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 618+ 7EC3              FindCache:
 619+ 7EC3 06 0B        	ld		b, NAMELEN
 620+ 7EC5 CD 31 7E     	call	StrCmp			;find the file to wich this extension belongs
 621+ 7EC8 C8           	ret		z
 622+ 7EC9
 623+ 7EC9 0D           	dec		c
 624+ 7ECA 20 02        	jr		nz, CacheNotFinished
 625+ 7ECC B1           	or		c
 626+ 7ECD C9           	ret
 627+ 7ECE
 628+ 7ECE              CacheNotFinished:
 629+ 7ECE 01 19 00     	ld		bc, CACHE_SZ
 630+ 7ED1 09           	add		hl, bc			;to the next cache line
 631+ 7ED2 18 EF        	jr		FindCache
 632+ 7ED4
 633+ 7ED4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 634+ 7ED4
 635+ 7ED4              	;ld		ix, (SelFileCache)
 636+ 7ED4              ReadFileHeader:
 637+ 7ED4 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 638+ 7ED7 B7           	or		a
 639+ 7ED8 C0           	ret		nz				;return if already read
 640+ 7ED9
 641+ 7ED9 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 642+ 7EDC DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 643+ 7EDF 7C           	ld		a, h
 644+ 7EE0 B5           	or		l
 645+ 7EE1 28 1F        	jr		z, ReadHeaderEnd
 646+ 7EE3 CD E9 7C     	call	AU2TS
 647+ 7EE6 50           	ld		d, b
 648+ 7EE7 59           	ld		e, c
 649+ 7EE8 21 81 A4     	ld		hl, DataBuf
 650+ 7EEB DD E5        	push	ix
 651+ 7EED DD E5        	push	ix
 652+ 7EEF CD C2 7C     		call	ReadOneDiskSector
 653+ 7EF2 E1           	pop		hl
 654+ 7EF3 DD E1        	pop		ix
 655+ 7EF5 01 10 00     	ld		bc, CACHE_HDR
 656+ 7EF8 09           	add		hl, bc
 657+ 7EF9 EB           	ex		hl, de
 658+ 7EFA 21 81 A4     	ld		hl, DataBuf
 659+ 7EFD 01 09 00     	ld		bc, HDR_SZ
 660+ 7F00 ED B0        	ldir
 661+ 7F02              ReadHeaderEnd:
 662+ 7F02 DD 34 0F     	inc		(ix + CACHE_FLAG)
 663+ 7F05 C9           	ret
 664+ 7F06
 665+ 7F06              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 666+ 7F06
 667+ 7F06              ;IN: HL = address from IF1 to call
 668+ 7F06              IF1Call:
 669+ 7F06 22 ED 5C     	LD   (HD11), HL
 670+ 7F09 CF           	RST  8
 671+ 7F0A 32           	DEFB 50
 672+ 7F0B C9           	RET
 673+ 7F0C
 674+ 7F0C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 675+ 7F0C
 676+ 7F0C              ;Load a program from disk
 677+ 7F0C              ;IN: HL = file name addr
 678+ 7F0C              LoadProgram:
 679+ 7F0C 22 DC 5C     	LD   (FSTR1), HL
 680+ 7F0F 26 00        	LD   H, 0
 681+ 7F11 2E 0B        	LD   L, NAMELEN
 682+ 7F13 22 DA 5C     	LD   (NSTR1), HL
 683+ 7F16 3A 5A 7F     	LD	 A, (RWTSDrive)
 684+ 7F19 3C           	INC  A					;Adapt for BASIC drive number
 685+ 7F1A 6F           	LD   L, A
 686+ 7F1B 22 D6 5C     	LD   (DSTR1), HL
 687+ 7F1E 21 41 0A     	LD   HL, LOAD_ADDR
 688+ 7F21 CD 06 7F     	CALL IF1Call
 689+ 7F24 C9           	RET
 690+ 7F25
 691+ 7F25              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 692+ 7F25
 693+ 7F25              SetFastKeys:
 694+ 7F25 21 09 5C     	ld		hl, REPDEL
 695+ 7F28 11 0F 01     	ld		de, (1 << 8) | 15
 696+ 7F2B 73 23 72 2B  	ld		(hl), de
 697+ 7F2F
 698+ 7F2F C9           	ret
 699+ 7F30
 700+ 7F30
 701+ 7F30              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 702+ 7F30              ;Reads the error message string from IF1 ROM.
 703+ 7F30              GetErrMsg:
 704+ 7F30 3C           	inc		a
 705+ 7F31 08           	ex		af, af'
 706+ 7F32
 707+ 7F32 21 3B 7F     	ld		hl, IF1Paged			;page-in IF1
 708+ 7F35 22 ED 5C     	ld		(HD11), hl
 709+ 7F38 CF           	rst		8
 710+ 7F39 32           	defb	50
 711+ 7F3A C9           	ret								;return after accesing IF1
 712+ 7F3B
 713+ 7F3B              IF1Paged:
 714+ 7F3B 21 60 02     	ld		hl, ERRMSG
 715+ 7F3E 08           	ex		af, af'
 716+ 7F3F B7           	or		a
 717+ 7F40 28 0B        	jr		z, SaveMsg
 718+ 7F42
 719+ 7F42 06 00        	ld		b, 0
 720+ 7F44              SearchMsgEnd:
 721+ 7F44 CB 7E        	bit		7, (hl)
 722+ 7F46 23           	inc		hl
 723+ 7F47 28 FB        	jr		z, SearchMsgEnd
 724+ 7F49
 725+ 7F49 04           	inc		b
 726+ 7F4A B8           	cp		b
 727+ 7F4B 20 F7        	jr		nz, SearchMsgEnd
 728+ 7F4D
 729+ 7F4D              SaveMsg:
 730+ 7F4D 11 81 A4     	ld		de, DataBuf
 731+ 7F50              CopyMsg:
 732+ 7F50 7E           	ld		a, (hl)
 733+ 7F51 CB 7F        	bit		7, a
 734+ 7F53 12           	ld		(de), a
 735+ 7F54 23           	inc		hl
 736+ 7F55 13           	inc		de
 737+ 7F56 28 F8        	jr		z, CopyMsg
 738+ 7F58
 739+ 7F58 C9           	ret
 740+ 7F59
 741+ 7F59              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 742+ 7F59
 743+ 7F59              ;RWTS routine I/O block
 744+ 7F59              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 745+ 7F59              RWTSParams:
 746+ 7F59 01           RWTSBlockType	DEFB	1							;?
 747+ 7F5A 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 748+ 7F5B 00           RWTSVolNo		DEFB	0							;?
 749+ 7F5C 00           RWTSTrack		DEFB	0
 750+ 7F5D 00           RWTSSector		DEFB	0
 751+ 7F5E 00 00        RWTSDMA			DEFW	0
 752+ 7F60 32 29        RWTSExtBuf		DEFW	$2932
 753+ 7F62 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 754+ 7F64 01           RWTSCmd			DEFB	RWTS_CMD_READ
 755+ 7F65              ;Results
 756+ 7F65 00           RWTSRes			DEFB	0
 757+ 7F66 00           RWTSResVolNo	DEFB	0
 758+ 7F67 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 758+ 7F6B 00
 759+ 7F6C
 760+ 7F6C              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 761+ 7F6C ~            /*
 762+ 7F6C ~            BasPrmTbl:
 763+ 7F6C ~            PrmDevType		DEFB	$01			;$01
 764+ 7F6C ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 765+ 7F6C ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 766+ 7F6C ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 767+ 7F6C ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 768+ 7F6C ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 769+ 7F6C ~            */
 770+ 7F6C
 771+ 7F6C              	endif
# file closed: disk.asm
1110  7F6C              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7F6C              ;BDOS functions - similar to CP/M
   2+ 7F6C
   3+ 7F6C              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 7F6C              ;0 OK,
   5+ 7F6C              ;1 directory full,
   6+ 7F6C              ;2 disc full,
   7+ 7F6C              ;9 invalid FCB,
   8+ 7F6C              ;10(CP/M) media changed;
   9+ 7F6C              ;0FFh hardware error.
  10+ 7F6C
  11+ 7F6C              	ifndef	_BDOS_
  12+ 7F6C              	define	_BDOS_
  13+ 7F6C
  14+ 7F6C              	include "disk.asm"
# file opened: disk.asm
   1++7F6C              ;HC IF1 routines and constants
   2++7F6C
   3++7F6C              ;IF1 routines error codes, also returned by BASIC commands
   4++7F6C              ;12 = Writing to a 'read' file
   5++7F6C              ;13 = Reading a 'write' file
   6++7F6C              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7F6C              ;15 = Disk full (disk or catalog full)
   8++7F6C              ;16 = Disk error (hardware error)
   9++7F6C              ;17 = File not found
  10++7F6C              ;23 = Disk R/O (disk change detected, software R/O)
  11++7F6C              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7F6C
  13++7F6C              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7F6C              ;00h = OK
  15++7F6C              ;08h = cannot format disk
  16++7F6C              ;10h = disk protected (read-only?)
  17++7F6C              ;20h = volume error
  18++7F6C              ;40h = drive error
  19++7F6C              ;80h = reading error
  20++7F6C              ;Codes I encountered:
  21++7F6C              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7F6C
  23++7F6C
  24++7F6C              	ifndef	_DISK_
  25++7F6C ~            	define	_DISK_
  26++7F6C ~
  27++7F6C ~            	include	"math.asm"
  28++7F6C ~
  29++7F6C ~            DRIVE_CUR_BAS	EQU 0
  30++7F6C ~            DRIVE_A_BAS		EQU	1
  31++7F6C ~            DRIVE_B_BAS		EQU	2
  32++7F6C ~            DRIVE_A_CPM		EQU	0
  33++7F6C ~            DRIVE_B_CPM		EQU	1
  34++7F6C ~            ;Disk geometry stuff
  35++7F6C ~            SPT				EQU	16			;sectors per track
  36++7F6C ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7F6C ~            TRACK_CNT		EQU	80			;track count
  38++7F6C ~            HEAD_CNT		EQU	2			;disk face count
  39++7F6C ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7F6C ~            EXT_SZ			EQU	32			;directory entry size
  41++7F6C ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7F6C ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7F6C ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7F6C ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7F6C ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7F6C ~            REC_SZ			EQU 128			;cp/m record size
  47++7F6C ~            DEL_MARKER		EQU	$E5
  48++7F6C ~            EOF_MARKER		EQU	$1B
  49++7F6C ~
  50++7F6C ~
  51++7F6C ~            ;Extension structure (directory entry)
  52++7F6C ~            EXT_DEL_FLAG	EQU	0
  53++7F6C ~            EXT_NAME		EQU 1
  54++7F6C ~            EXT_IDX			EQU 12
  55++7F6C ~            EXT_S1			EQU 13
  56++7F6C ~            EXT_S2			EQU 14
  57++7F6C ~            EXT_RC			EQU	15
  58++7F6C ~            EXT_AU0			EQU	16
  59++7F6C ~            EXT_AU1			EQU	18
  60++7F6C ~            EXT_AU2			EQU	20
  61++7F6C ~            EXT_AU3			EQU	22
  62++7F6C ~            EXT_AU4			EQU	24
  63++7F6C ~            EXT_AU5			EQU	26
  64++7F6C ~            EXT_AU6			EQU	28
  65++7F6C ~            EXT_AU7			EQU	30
  66++7F6C ~            EXT_SIZE		EQU 32
  67++7F6C ~
  68++7F6C ~            ;FCB structure
  69++7F6C ~            FCB_DRIVE		EQU 0
  70++7F6C ~            FCB_NAME		EQU EXT_NAME
  71++7F6C ~            FCB_EX_IDX		EQU EXT_IDX
  72++7F6C ~            FCB_S1			EQU EXT_S1
  73++7F6C ~            FCB_S2			EQU EXT_S2
  74++7F6C ~            FCB_RC			EQU	EXT_RC
  75++7F6C ~            FCB_AU			EQU	EXT_AU0
  76++7F6C ~            FCB_CR			EQU	32
  77++7F6C ~            FCB_R0			EQU 33
  78++7F6C ~            FCB_R1			EQU 34
  79++7F6C ~            FCB_R2			EQU 35
  80++7F6C ~            FCB_SIZE		EQU 36
  81++7F6C ~
  82++7F6C ~
  83++7F6C ~
  84++7F6C ~            ;System variables for disk
  85++7F6C ~            DSTR1			EQU	$5CD6		;drive
  86++7F6C ~            FSTR1			EQU	$5CDC		;file name
  87++7F6C ~            NSTR1			EQU	$5CDA		;name length
  88++7F6C ~            HD11			EQU	$5CED		;BDOS argument
  89++7F6C ~            COPIES			EQU	$5CEF		;BDOS function
  90++7F6C ~
  91++7F6C ~            ERRSP			EQU $5C3D
  92++7F6C ~            ERRNR			EQU $5C3A
  93++7F6C ~            ERRMSG			EQU	$0260
  94++7F6C ~
  95++7F6C ~            PROG			EQU $5C53
  96++7F6C ~            VARS			EQU	$5C4B
  97++7F6C ~            STKEND			EQU	$5C65
  98++7F6C ~
  99++7F6C ~            PRN_BUF			EQU	23296
 100++7F6C ~
 101++7F6C ~            ;STR_COPYRIGHT	EQU	$1539
 102++7F6C ~
 103++7F6C ~            REPDEL			EQU	23561
 104++7F6C ~            REPPER			EQU	23562
 105++7F6C ~            PIP				EQU	23609
 106++7F6C ~
 107++7F6C ~
 108++7F6C ~            ;RWTS routine commands
 109++7F6C ~            RWTS_CMD_POS	EQU	0			;position head
 110++7F6C ~            RWTS_CMD_READ	EQU	1			;read sector
 111++7F6C ~            RWTS_CMD_WRITE	EQU	2			;write sector
 112++7F6C ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 113++7F6C ~
 114++7F6C ~
 115++7F6C ~            ;File name stuff
 116++7F6C ~            NAMELEN			EQU	11			;name length
 117++7F6C ~            RO_POS			EQU	8			;read-only attribute position in name
 118++7F6C ~            SYS_POS			EQU	9			;system attribute position in name
 119++7F6C ~
 120++7F6C ~            ;File types (first byte in header)
 121++7F6C ~            PROG_TYPE		EQU	0			;program
 122++7F6C ~            NUMB_TYPE		EQU	1			;number array
 123++7F6C ~            CHAR_TYPE		EQU	2			;char array
 124++7F6C ~            BYTE_TYPE		EQU	3			;bytes
 125++7F6C ~            TEXT_TYPE		EQU	4			;text, >= 4
 126++7F6C ~
 127++7F6C ~            ;File header offsets
 128++7F6C ~            HDR_TYPE		EQU	0
 129++7F6C ~            HDR_LEN			EQU 1
 130++7F6C ~            HDR_ADDR		EQU 3
 131++7F6C ~            HDR_PLEN		EQU	5
 132++7F6C ~            HDR_LINE		EQU 7
 133++7F6C ~            HDR_SZ			EQU	9
 134++7F6C ~
 135++7F6C ~            ;BASIC disk channel structure
 136++7F6C ~            CH_RW_FLAG		EQU 11
 137++7F6C ~            CH_FCB			EQU	12
 138++7F6C ~            CH_DATA			EQU	50
 139++7F6C ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 140++7F6C ~
 141++7F6C ~            CACHE_NAME		EQU	0					;11B
 142++7F6C ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 143++7F6C ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 144++7F6C ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 145++7F6C ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 146++7F6C ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 147++7F6C ~
 148++7F6C ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 149++7F6C ~
 150++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 151++7F6C ~            IF1Init:
 152++7F6C ~            	rst		08
 153++7F6C ~            	defb	49		;create system variables
 154++7F6C ~            	ret
 155++7F6C ~
 156++7F6C ~            ;ReadWriteTrackSector
 157++7F6C ~            ;A=command: 0, 1, 2, 4
 158++7F6C ~            RWTS:
 159++7F6C ~            	ld (RWTSCmd), a
 160++7F6C ~            	ld hl, RWTSParams
 161++7F6C ~            	ld (HD11), hl
 162++7F6C ~            	rst 08
 163++7F6C ~            	DEFB 58
 164++7F6C ~            	ret
 165++7F6C ~
 166++7F6C ~
 167++7F6C ~            ;D = sector, E = track
 168++7F6C ~            ;HL = dma
 169++7F6C ~            ReadOneDiskSector:
 170++7F6C ~            	ld (RWTSDMA), hl
 171++7F6C ~            	ld (RWTSTrack), de
 172++7F6C ~            	;ld (RWTSDrive), a
 173++7F6C ~            	ld a, RWTS_CMD_READ
 174++7F6C ~            	jr	RWTS
 175++7F6C ~
 176++7F6C ~            ;D = sector, E = track
 177++7F6C ~            ;HL = dma
 178++7F6C ~            WriteOneDiskSector:
 179++7F6C ~            	ld (RWTSDMA), hl
 180++7F6C ~            	ld (RWTSTrack), de
 181++7F6C ~            	;ld (RWTSDrive), a
 182++7F6C ~            	ld a, RWTS_CMD_WRITE
 183++7F6C ~            	jr	RWTS
 184++7F6C ~
 185++7F6C ~            FormatDisk:
 186++7F6C ~            	ld		hl, DataBuf
 187++7F6C ~            	ld		(hl), DEL_MARKER
 188++7F6C ~            	ld 		(RWTSDMA), hl
 189++7F6C ~            	ld 		a, RWTS_CMD_FMT
 190++7F6C ~            	call	RWTS
 191++7F6C ~            	ld		a, (RWTSRes)
 192++7F6C ~            	ret
 193++7F6C ~
 194++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 195++7F6C ~
 196++7F6C ~            ;Allocation unit no. to track/sector
 197++7F6C ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 198++7F6C ~            ;IN:  HL=alloc. unit no.
 199++7F6C ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 200++7F6C ~            AU2TS:
 201++7F6C ~            	ld c, SPT/SPAL
 202++7F6C ~            	call Div					;A = sector
 203++7F6C ~            	push af
 204++7F6C ~            		/*
 205++7F6C ~            		ld c, HEAD_CNT
 206++7F6C ~            		call Div				;L = track, A = head (0 or 1)
 207++7F6C ~            		*/
 208++7F6C ~            		xor a
 209++7F6C ~            		rr h
 210++7F6C ~            		rr l
 211++7F6C ~            		rr a
 212++7F6C ~
 213++7F6C ~            		ld c, l
 214++7F6C ~            		ld b, 0
 215++7F6C ~            		or a
 216++7F6C ~            		jr z, Track0
 217++7F6C ~            		ld b, SPT
 218++7F6C ~            Track0:
 219++7F6C ~            	pop af
 220++7F6C ~            	or a
 221++7F6C ~            	jr z, FirstAU
 222++7F6C ~            	ld a, SPAL
 223++7F6C ~            FirstAU:
 224++7F6C ~            	add a, b
 225++7F6C ~            	ld  b, a
 226++7F6C ~            	ret
 227++7F6C ~
 228++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 229++7F6C ~
 230++7F6C ~            ;Checks the allocation units number used in extension
 231++7F6C ~            ;IN:	IX = extension addr
 232++7F6C ~            ;OUT:	B = no. of allocation units used
 233++7F6C ~            ;		C = no. of records used in ext.
 234++7F6C ~            ;		HL = first alloc. unit no.
 235++7F6C ~            ;		DE = last alloc. unit no.
 236++7F6C ~            CheckExtAlloc:
 237++7F6C ~            	push ix
 238++7F6C ~            		ld bc, EXT_RC
 239++7F6C ~            		add ix, bc
 240++7F6C ~            		ld c, (ix)			;save rec. no.
 241++7F6C ~            		inc ix
 242++7F6C ~            		ld l, (ix)
 243++7F6C ~            		ld h, (ix + 1)
 244++7F6C ~            		ld b, EXT_AU_CNT
 245++7F6C ~            CheckAU:
 246++7F6C ~            		ld a, (ix)
 247++7F6C ~            		or (ix + 1)
 248++7F6C ~            		jr z, CheckAUEnd
 249++7F6C ~            		ld e, (ix)
 250++7F6C ~            		ld d, (ix + 1)
 251++7F6C ~            		inc ix
 252++7F6C ~            		inc ix
 253++7F6C ~            		djnz CheckAU
 254++7F6C ~            CheckAUEnd:
 255++7F6C ~            		ld a, EXT_AU_CNT
 256++7F6C ~            		sub b
 257++7F6C ~            		ld b, a
 258++7F6C ~            	pop ix
 259++7F6C ~            	ret
 260++7F6C ~
 261++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 262++7F6C ~
 263++7F6C ~            ;Input: TrackBuffer
 264++7F6C ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 265++7F6C ~            ReadUsedBlocksList:
 266++7F6C ~            	ld		ix, TrackBuf			;source buffer
 267++7F6C ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 268++7F6C ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 269++7F6C ~            	ld		de, 2					;counter of used blocks, start with 2
 270++7F6C ~            	ld		(hl), e
 271++7F6C ~            	inc		hl
 272++7F6C ~            	ld		(hl), d
 273++7F6C ~            	inc		hl
 274++7F6C ~
 275++7F6C ~            	;Add blocks 0 and 1 for directory
 276++7F6C ~            	ld		de, 0
 277++7F6C ~            	ld		(hl), e
 278++7F6C ~            	inc		hl
 279++7F6C ~            	ld		(hl), d
 280++7F6C ~            	inc		hl
 281++7F6C ~
 282++7F6C ~            	inc		de
 283++7F6C ~            	ld		(hl), e
 284++7F6C ~            	inc		hl
 285++7F6C ~            	ld		(hl), d
 286++7F6C ~            	inc		hl
 287++7F6C ~
 288++7F6C ~            ReadUsedBlocksLoop:
 289++7F6C ~            	xor		a
 290++7F6C ~            	cp		(ix)
 291++7F6C ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 292++7F6C ~
 293++7F6C ~            	push	ix
 294++7F6C ~            	push	bc
 295++7F6C ~            		ld		b, EXT_AU_CNT
 296++7F6C ~            		ld		de, EXT_AU0
 297++7F6C ~            		add		ix, de
 298++7F6C ~
 299++7F6C ~            ReadUsedBlocksLoop2:
 300++7F6C ~            		ld		e, (ix)
 301++7F6C ~            		ld		d, (ix+1)
 302++7F6C ~            		ld		a, e
 303++7F6C ~            		or		d
 304++7F6C ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 305++7F6C ~
 306++7F6C ~            		ld		(hl), e
 307++7F6C ~            		inc		hl
 308++7F6C ~            		ld		(hl), d
 309++7F6C ~            		inc		hl
 310++7F6C ~
 311++7F6C ~            		inc		ix
 312++7F6C ~            		inc		ix
 313++7F6C ~
 314++7F6C ~            		ld		de, (UsedBlockListCnt)
 315++7F6C ~            		inc		de
 316++7F6C ~            		ld		(UsedBlockListCnt), de
 317++7F6C ~
 318++7F6C ~            		djnz	ReadUsedBlocksLoop2
 319++7F6C ~
 320++7F6C ~
 321++7F6C ~            ReadUsedBlocksSkip:
 322++7F6C ~            	pop		bc
 323++7F6C ~            	pop		ix
 324++7F6C ~            ReadUsedBlocksSkip2:
 325++7F6C ~            	ld		de, EXT_SZ
 326++7F6C ~            	add		ix, de
 327++7F6C ~
 328++7F6C ~            	dec		bc
 329++7F6C ~            	ld		a, b
 330++7F6C ~            	or		c
 331++7F6C ~            	jr		nz, ReadUsedBlocksLoop
 332++7F6C ~
 333++7F6C ~            	ret
 334++7F6C ~
 335++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 336++7F6C ~            ;Reads 8 sectors for an AU
 337++7F6C ~            ;HL = block number, DE = destination buffer
 338++7F6C ~            ReadFSBlock:
 339++7F6C ~            	push	de
 340++7F6C ~            		call	AU2TS		;B=sector, C=track
 341++7F6C ~            	pop		hl				;HL=dest
 342++7F6C ~
 343++7F6C ~            	ld		d, b
 344++7F6C ~            	ld		e, c
 345++7F6C ~            	ld		b, SPAL
 346++7F6C ~
 347++7F6C ~            ReadFSBlockLoop:
 348++7F6C ~            	call	ReadDiskSectors
 349++7F6C ~            	ret
 350++7F6C ~
 351++7F6C ~
 352++7F6C ~            ;Write 8 sectors for an AU
 353++7F6C ~            ;HL = block number, DE = source buffer
 354++7F6C ~            WriteFSBlock:
 355++7F6C ~            	push	de
 356++7F6C ~            		call	AU2TS		;B=sector, C=track
 357++7F6C ~            	pop		hl				;HL=dest
 358++7F6C ~
 359++7F6C ~            	ld		d, b
 360++7F6C ~            	ld		e, c
 361++7F6C ~            	ld		b, SPAL
 362++7F6C ~
 363++7F6C ~            WriteFSBlockLoop:
 364++7F6C ~            	call	WriteDiskSectors
 365++7F6C ~            	ret
 366++7F6C ~
 367++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 368++7F6C ~            ;Copies the allocated blocks from one disk to another.
 369++7F6C ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 370++7F6C ~            CopyDisk:
 371++7F6C ~            	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 372++7F6C ~            	call	ReadUsedBlocksList
 373++7F6C ~            	ld		ix, UsedBlockListBlk
 374++7F6C ~
 375++7F6C ~            CopyDiskLoop:
 376++7F6C ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 377++7F6C ~            	ld		de, MsgBlocksLeft
 378++7F6C ~            	call	Byte2Txt
 379++7F6C ~            	ld		hl, MsgBlocksLeft
 380++7F6C ~            	ld		de, LST_LINE_MSG + 1 << 8
 381++7F6C ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 382++7F6C ~            	call	PrintStrClr
 383++7F6C ~
 384++7F6C ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 385++7F6C ~            	ld		hl, MAX_AU_RAM
 386++7F6C ~            	ld		bc, (UsedBlockListCnt)
 387++7F6C ~            	or		a
 388++7F6C ~            	sbc		hl, bc
 389++7F6C ~            	jr		nc, CopyDiskLoopRead
 390++7F6C ~            	ld		bc, MAX_AU_RAM
 391++7F6C ~
 392++7F6C ~            CopyDiskLoopRead:
 393++7F6C ~            	ld		b, c
 394++7F6C ~            	ld		de, CopyDiskBuf
 395++7F6C ~            	;save initial counter and initial block number array position
 396++7F6C ~            	push	bc
 397++7F6C ~            	push	ix
 398++7F6C ~
 399++7F6C ~            CopyDiskLoopReadLoop:
 400++7F6C ~            		ld		l, (ix)
 401++7F6C ~            		ld		h, (ix+1)
 402++7F6C ~            		inc		ix
 403++7F6C ~            		inc		ix
 404++7F6C ~
 405++7F6C ~            		push	de
 406++7F6C ~            		push	bc
 407++7F6C ~            			call	ReadFSBlock			;Stop on error or continue?
 408++7F6C ~            		pop		bc
 409++7F6C ~            		pop		de
 410++7F6C ~
 411++7F6C ~            		;+2048
 412++7F6C ~            		ld		a, d
 413++7F6C ~            		add		8
 414++7F6C ~            		ld		d, a
 415++7F6C ~
 416++7F6C ~            		djnz	CopyDiskLoopReadLoop
 417++7F6C ~
 418++7F6C ~            		;alternate drive
 419++7F6C ~            		ld		a, (RWTSDrive)
 420++7F6C ~            		xor		%11
 421++7F6C ~            		ld		(RWTSDrive), a
 422++7F6C ~
 423++7F6C ~            	;restore initial counter and initial block number array position
 424++7F6C ~            	pop		ix
 425++7F6C ~            	pop		bc
 426++7F6C ~            	ld		de, CopyDiskBuf
 427++7F6C ~            	push	bc
 428++7F6C ~
 429++7F6C ~            CopyDiskLoopWriteLoop:
 430++7F6C ~            		ld		l, (ix)
 431++7F6C ~            		ld		h, (ix+1)
 432++7F6C ~            		inc		ix
 433++7F6C ~            		inc		ix
 434++7F6C ~
 435++7F6C ~            		push	de
 436++7F6C ~            		push	bc
 437++7F6C ~            			call	WriteFSBlock		;Stop on error or continue?
 438++7F6C ~            		pop		bc
 439++7F6C ~            		pop		de
 440++7F6C ~
 441++7F6C ~            		;+2048
 442++7F6C ~            		ld		a, d
 443++7F6C ~            		add		8
 444++7F6C ~            		ld		d, a
 445++7F6C ~
 446++7F6C ~            		djnz	CopyDiskLoopWriteLoop
 447++7F6C ~
 448++7F6C ~            		;alternate drive again
 449++7F6C ~            		ld		a, (RWTSDrive)
 450++7F6C ~            		xor		%11
 451++7F6C ~            		ld		(RWTSDrive), a
 452++7F6C ~
 453++7F6C ~            	pop		bc
 454++7F6C ~            	ld		c, b
 455++7F6C ~            	ld		b, 0
 456++7F6C ~
 457++7F6C ~            	;Decrease number of blocks read by now.
 458++7F6C ~            	ld		hl, (UsedBlockListCnt)
 459++7F6C ~            	or		a
 460++7F6C ~            	sbc		hl, bc
 461++7F6C ~            	ld		(UsedBlockListCnt), hl
 462++7F6C ~
 463++7F6C ~            	ld		a, l
 464++7F6C ~            	or		h
 465++7F6C ~            	jp		nz, CopyDiskLoop
 466++7F6C ~
 467++7F6C ~            	ret
 468++7F6C ~
 469++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 470++7F6C ~
 471++7F6C ~            ;Compare string at HL with the one at DE, max length B
 472++7F6C ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 473++7F6C ~            ;OUT: z flag, set = match, reset = mismatch
 474++7F6C ~            StrCmp:
 475++7F6C ~            	push hl
 476++7F6C ~            	push de
 477++7F6C ~            Compare:
 478++7F6C ~            		ld a, (de)
 479++7F6C ~            		cp (hl)
 480++7F6C ~            		jr nz, MisMatch
 481++7F6C ~            		inc hl
 482++7F6C ~            		inc de
 483++7F6C ~            		djnz Compare
 484++7F6C ~            MisMatch:
 485++7F6C ~            	pop de
 486++7F6C ~            	pop hl
 487++7F6C ~            	ret
 488++7F6C ~
 489++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 490++7F6C ~
 491++7F6C ~            ;Read a file into a buffer, sector by sector.
 492++7F6C ~            ;It's relocatable, to moved and be used when loading a CODE block.
 493++7F6C ~            ;It's not using BDOS, but using similar calls provided by IF1.
 494++7F6C ~            ;In: HL = Name address, DE = buffer
 495++7F6C ~            IF1FileLoad:
 496++7F6C ~            	push	de
 497++7F6C ~            		ld (FSTR1), hl
 498++7F6C ~            		ld h, 0
 499++7F6C ~            		ld a, (RWTSDrive)
 500++7F6C ~            		inc  a			;CP/M drive number to BASIC drive number
 501++7F6C ~            		ld	l, a
 502++7F6C ~            		ld (DSTR1), hl
 503++7F6C ~            		ld l,NAMELEN
 504++7F6C ~            		ld (NSTR1), hl
 505++7F6C ~            		rst 08
 506++7F6C ~            		DEFB 51			;open disk channel
 507++7F6C ~
 508++7F6C ~            		rst		8
 509++7F6C ~            		defb	53		;read sector
 510++7F6C ~            	pop		de
 511++7F6C ~            	jr		nc, FileFree
 512++7F6C ~
 513++7F6C ~            	ld		a, (ix + CH_DATA)
 514++7F6C ~            	cp		TEXT_TYPE
 515++7F6C ~            	jr		nc, FileLoadNoHeader
 516++7F6C ~
 517++7F6C ~            FileLoadHeader:
 518++7F6C ~            	push	ix
 519++7F6C ~            	pop		hl
 520++7F6C ~            	ld		bc, CH_DATA + HDR_SZ
 521++7F6C ~            	add		hl, bc
 522++7F6C ~            	ld		bc, SECT_SZ - HDR_SZ
 523++7F6C ~            	ldir
 524++7F6C ~
 525++7F6C ~            FileReadLoop:
 526++7F6C ~            	push	de
 527++7F6C ~            		rst		8
 528++7F6C ~            		defb	53		;read sector
 529++7F6C ~            	pop		de
 530++7F6C ~            	jr		nc, FileFree
 531++7F6C ~
 532++7F6C ~            FileLoadNoHeader:
 533++7F6C ~            	push	ix
 534++7F6C ~            	pop		hl
 535++7F6C ~            	ld		bc, CH_DATA
 536++7F6C ~            	add		hl, bc
 537++7F6C ~            	ld		bc, SECT_SZ
 538++7F6C ~            	ldir
 539++7F6C ~            	jr		FileReadLoop
 540++7F6C ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 541++7F6C ~            IF1FileLoadEnd:
 542++7F6C ~
 543++7F6C ~            FileFree:
 544++7F6C ~            	push	de
 545++7F6C ~            	rst		8
 546++7F6C ~            	defb	56			;close channel (52) or detroy channel (56)
 547++7F6C ~            	pop		de
 548++7F6C ~            	ret
 549++7F6C ~
 550++7F6C ~
 551++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 552++7F6C ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 553++7F6C ~            ;Out: A = error code, 0=OK
 554++7F6C ~            ReadDiskSectors:
 555++7F6C ~            	push bc
 556++7F6C ~            		push hl
 557++7F6C ~            			push de
 558++7F6C ~            				call ReadOneDiskSector
 559++7F6C ~            			pop de
 560++7F6C ~            		pop hl
 561++7F6C ~
 562++7F6C ~            		inc d
 563++7F6C ~            		inc h
 564++7F6C ~            	pop bc
 565++7F6C ~
 566++7F6C ~            	ld	a, (RWTSRes)
 567++7F6C ~            	or	a
 568++7F6C ~            	ret nz
 569++7F6C ~
 570++7F6C ~            	djnz ReadDiskSectors
 571++7F6C ~            	ret
 572++7F6C ~
 573++7F6C ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 574++7F6C ~            ;Out: A = error code, 0=OK
 575++7F6C ~            WriteDiskSectors:
 576++7F6C ~            	push bc
 577++7F6C ~            		push hl
 578++7F6C ~            			push de
 579++7F6C ~            				call WriteOneDiskSector
 580++7F6C ~            			pop de
 581++7F6C ~            		pop hl
 582++7F6C ~
 583++7F6C ~            		inc d
 584++7F6C ~            		inc h
 585++7F6C ~            	pop bc
 586++7F6C ~
 587++7F6C ~            	ld	a, (RWTSRes)
 588++7F6C ~            	or	a
 589++7F6C ~            	ret nz
 590++7F6C ~
 591++7F6C ~            	djnz WriteDiskSectors
 592++7F6C ~            	ret
 593++7F6C ~
 594++7F6C ~
 595++7F6C ~            ;Reads disk catalog
 596++7F6C ~            ReadCatalogTrack:
 597++7F6C ~            	ld hl, TrackBuf
 598++7F6C ~            	ld de, 0
 599++7F6C ~            	ld b, SPT
 600++7F6C ~
 601++7F6C ~            	call ReadDiskSectors
 602++7F6C ~            	or   a
 603++7F6C ~            	ret  nz
 604++7F6C ~
 605++7F6C ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 606++7F6C ~            	push  af
 607++7F6C ~            		ld  a, (RWTSDrive)
 608++7F6C ~            		call BDOSSelectDisk
 609++7F6C ~            		call BDOSInit
 610++7F6C ~            	pop   af
 611++7F6C ~            	ret
 612++7F6C ~
 613++7F6C ~
 614++7F6C ~
 615++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 616++7F6C ~
 617++7F6C ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 618++7F6C ~            FindCache:
 619++7F6C ~            	ld		b, NAMELEN
 620++7F6C ~            	call	StrCmp			;find the file to wich this extension belongs
 621++7F6C ~            	ret		z
 622++7F6C ~
 623++7F6C ~            	dec		c
 624++7F6C ~            	jr		nz, CacheNotFinished
 625++7F6C ~            	or		c
 626++7F6C ~            	ret
 627++7F6C ~
 628++7F6C ~            CacheNotFinished:
 629++7F6C ~            	ld		bc, CACHE_SZ
 630++7F6C ~            	add		hl, bc			;to the next cache line
 631++7F6C ~            	jr		FindCache
 632++7F6C ~
 633++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 634++7F6C ~
 635++7F6C ~            	;ld		ix, (SelFileCache)
 636++7F6C ~            ReadFileHeader:
 637++7F6C ~            	ld		a, (ix + CACHE_FLAG)
 638++7F6C ~            	or		a
 639++7F6C ~            	ret		nz				;return if already read
 640++7F6C ~
 641++7F6C ~            	ld		l, (ix + CACHE_FIRST_AU)
 642++7F6C ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 643++7F6C ~            	ld		a, h
 644++7F6C ~            	or		l
 645++7F6C ~            	jr		z, ReadHeaderEnd
 646++7F6C ~            	call	AU2TS
 647++7F6C ~            	ld		d, b
 648++7F6C ~            	ld		e, c
 649++7F6C ~            	ld		hl, DataBuf
 650++7F6C ~            	push	ix
 651++7F6C ~            	push	ix
 652++7F6C ~            		call	ReadOneDiskSector
 653++7F6C ~            	pop		hl
 654++7F6C ~            	pop		ix
 655++7F6C ~            	ld		bc, CACHE_HDR
 656++7F6C ~            	add		hl, bc
 657++7F6C ~            	ex		hl, de
 658++7F6C ~            	ld		hl, DataBuf
 659++7F6C ~            	ld		bc, HDR_SZ
 660++7F6C ~            	ldir
 661++7F6C ~            ReadHeaderEnd:
 662++7F6C ~            	inc		(ix + CACHE_FLAG)
 663++7F6C ~            	ret
 664++7F6C ~
 665++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 666++7F6C ~
 667++7F6C ~            ;IN: HL = address from IF1 to call
 668++7F6C ~            IF1Call:
 669++7F6C ~            	LD   (HD11), HL
 670++7F6C ~            	RST  8
 671++7F6C ~            	DEFB 50
 672++7F6C ~            	RET
 673++7F6C ~
 674++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 675++7F6C ~
 676++7F6C ~            ;Load a program from disk
 677++7F6C ~            ;IN: HL = file name addr
 678++7F6C ~            LoadProgram:
 679++7F6C ~            	LD   (FSTR1), HL
 680++7F6C ~            	LD   H, 0
 681++7F6C ~            	LD   L, NAMELEN
 682++7F6C ~            	LD   (NSTR1), HL
 683++7F6C ~            	LD	 A, (RWTSDrive)
 684++7F6C ~            	INC  A					;Adapt for BASIC drive number
 685++7F6C ~            	LD   L, A
 686++7F6C ~            	LD   (DSTR1), HL
 687++7F6C ~            	LD   HL, LOAD_ADDR
 688++7F6C ~            	CALL IF1Call
 689++7F6C ~            	RET
 690++7F6C ~
 691++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 692++7F6C ~
 693++7F6C ~            SetFastKeys:
 694++7F6C ~            	ld		hl, REPDEL
 695++7F6C ~            	ld		de, (1 << 8) | 15
 696++7F6C ~            	ld		(hl), de
 697++7F6C ~
 698++7F6C ~            	ret
 699++7F6C ~
 700++7F6C ~
 701++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 702++7F6C ~            ;Reads the error message string from IF1 ROM.
 703++7F6C ~            GetErrMsg:
 704++7F6C ~            	inc		a
 705++7F6C ~            	ex		af, af'
 706++7F6C ~
 707++7F6C ~            	ld		hl, IF1Paged			;page-in IF1
 708++7F6C ~            	ld		(HD11), hl
 709++7F6C ~            	rst		8
 710++7F6C ~            	defb	50
 711++7F6C ~            	ret								;return after accesing IF1
 712++7F6C ~
 713++7F6C ~            IF1Paged:
 714++7F6C ~            	ld		hl, ERRMSG
 715++7F6C ~            	ex		af, af'
 716++7F6C ~            	or		a
 717++7F6C ~            	jr		z, SaveMsg
 718++7F6C ~
 719++7F6C ~            	ld		b, 0
 720++7F6C ~            SearchMsgEnd:
 721++7F6C ~            	bit		7, (hl)
 722++7F6C ~            	inc		hl
 723++7F6C ~            	jr		z, SearchMsgEnd
 724++7F6C ~
 725++7F6C ~            	inc		b
 726++7F6C ~            	cp		b
 727++7F6C ~            	jr		nz, SearchMsgEnd
 728++7F6C ~
 729++7F6C ~            SaveMsg:
 730++7F6C ~            	ld		de, DataBuf
 731++7F6C ~            CopyMsg:
 732++7F6C ~            	ld		a, (hl)
 733++7F6C ~            	bit		7, a
 734++7F6C ~            	ld		(de), a
 735++7F6C ~            	inc		hl
 736++7F6C ~            	inc		de
 737++7F6C ~            	jr		z, CopyMsg
 738++7F6C ~
 739++7F6C ~            	ret
 740++7F6C ~
 741++7F6C ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 742++7F6C ~
 743++7F6C ~            ;RWTS routine I/O block
 744++7F6C ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 745++7F6C ~            RWTSParams:
 746++7F6C ~            RWTSBlockType	DEFB	1							;?
 747++7F6C ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 748++7F6C ~            RWTSVolNo		DEFB	0							;?
 749++7F6C ~            RWTSTrack		DEFB	0
 750++7F6C ~            RWTSSector		DEFB	0
 751++7F6C ~            RWTSDMA			DEFW	0
 752++7F6C ~            RWTSExtBuf		DEFW	$2932
 753++7F6C ~            RWTSPrmTbl		DEFW	$1f2a
 754++7F6C ~            RWTSCmd			DEFB	RWTS_CMD_READ
 755++7F6C ~            ;Results
 756++7F6C ~            RWTSRes			DEFB	0
 757++7F6C ~            RWTSResVolNo	DEFB	0
 758++7F6C ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 759++7F6C ~
 760++7F6C ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 761++7F6C ~            /*
 762++7F6C ~            BasPrmTbl:
 763++7F6C ~            PrmDevType		DEFB	$01			;$01
 764++7F6C ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 765++7F6C ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 766++7F6C ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 767++7F6C ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 768++7F6C ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 769++7F6C ~            */
 770++7F6C ~
 771++7F6C              	endif
# file closed: disk.asm
  15+ 7F6C
  16+ 7F6C              BDOSInit:
  17+ 7F6C AF           	xor		a
  18+ 7F6D 18 3D        	jr		BDOS
  19+ 7F6F
  20+ 7F6F
  21+ 7F6F              ;IN: A = Drive to select
  22+ 7F6F              BDOSSelectDisk:
  23+ 7F6F              	IFUSED
  24+ 7F6F DD 6F        	ld		ixl, a
  25+ 7F71 DD 26 00     	ld		ixh, 0
  26+ 7F74 3E 01        	ld		a, 1
  27+ 7F76 18 34        	jr		BDOS
  28+ 7F78              	ENDIF
  29+ 7F78
  30+ 7F78
  31+ 7F78              BDOSMakeDiskRO:
  32+ 7F78              	IFUSED
  33+ 7F78 ~            	ld		a, 15
  34+ 7F78 ~            	jr		BDOS
  35+ 7F78              	ENDIF
  36+ 7F78
  37+ 7F78              ;Get Read Only flag
  38+ 7F78              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 7F78              BDOSGetDiskRO:
  40+ 7F78              	IFUSED
  41+ 7F78 ~            	ld	a, 16
  42+ 7F78 ~            	jr	BDOS
  43+ 7F78              	ENDIF
  44+ 7F78
  45+ 7F78              BDOSGetCurrentDisk:
  46+ 7F78              	IFUSED
  47+ 7F78 ~            	ld		a, 12
  48+ 7F78 ~            	jr		BDOS
  49+ 7F78              	ENDIF
  50+ 7F78
  51+ 7F78
  52+ 7F78              ;Create a disk channel for BDOS access (does not open the file)
  53+ 7F78              ;IN: HL=name addr, A=drive
  54+ 7F78              ;OUT: IX=FCB
  55+ 7F78              CreateChannel:
  56+ 7F78 22 DC 5C     	ld (FSTR1), hl
  57+ 7F7B 26 00        	ld h,0
  58+ 7F7D 6F           	ld l,a
  59+ 7F7E 22 D6 5C     	ld (DSTR1), hl
  60+ 7F81 2E 0B        	ld l,NAMELEN
  61+ 7F83 22 DA 5C     	ld (NSTR1), hl
  62+ 7F86 CF           	rst 08
  63+ 7F87 37           	DEFB 55
  64+ 7F88 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 7F8B DD 09        	add ix, bc
  66+ 7F8D C9           	ret
  67+ 7F8E
  68+ 7F8E
  69+ 7F8E              ;Destroy a BDOS channel
  70+ 7F8E              ;IN: IX=FCB
  71+ 7F8E              DestroyChannel:
  72+ 7F8E C5           	push bc
  73+ 7F8F 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 7F92 DD 09        	add ix, bc
  75+ 7F94 CF           	rst 08
  76+ 7F95 38           	DEFB 56
  77+ 7F96 C1           	pop bc
  78+ 7F97 C9           	ret
  79+ 7F98
  80+ 7F98
  81+ 7F98              ;Input: IX=FCB
  82+ 7F98              CreateFile:
  83+ 7F98 3E 09        	ld	a, 9
  84+ 7F9A 18 10        	jr	BDOS
  85+ 7F9C
  86+ 7F9C              ;Input: IX=FCB
  87+ 7F9C              OpenFile:
  88+ 7F9C 3E 02        	ld	a, 2
  89+ 7F9E 18 0C        	jr	BDOS
  90+ 7FA0
  91+ 7FA0              ;IN: IX=FCB
  92+ 7FA0              CloseFile:
  93+ 7FA0 3E 03        	ld	a, 3
  94+ 7FA2 18 08        	jr	BDOS
  95+ 7FA4
  96+ 7FA4              ;IN: IX=FCB
  97+ 7FA4              ReadFileBlock:
  98+ 7FA4 3E 07        	ld	a, 7
  99+ 7FA6 18 04        	jr	BDOS
 100+ 7FA8
 101+ 7FA8              ;IN: IX=FCB
 102+ 7FA8              WriteFileBlock:
 103+ 7FA8 3E 08        	ld	a, 8
 104+ 7FAA 18 00        	jr	BDOS
 105+ 7FAC
 106+ 7FAC              ;Generic BDOS call
 107+ 7FAC              ;IX=arg, A=function
 108+ 7FAC              BDOS:
 109+ 7FAC DD 22 ED 5C  	ld (HD11), ix
 110+ 7FB0 32 EF 5C     	ld (COPIES), a
 111+ 7FB3 CF           	rst 08
 112+ 7FB4 39           	DEFB 57
 113+ 7FB5 C9           	ret
 114+ 7FB6
 115+ 7FB6              ;FindFirst
 116+ 7FB6              ;IX=fcb
 117+ 7FB6              BDOSFindFirst:
 118+ 7FB6              	IFUSED
 119+ 7FB6 ~            	ld a, 4
 120+ 7FB6 ~            	jr BDOS
 121+ 7FB6              	ENDIF
 122+ 7FB6
 123+ 7FB6              ;FindNext
 124+ 7FB6              ;IX=fcb
 125+ 7FB6              BDOSFindNext:
 126+ 7FB6              	IFUSED
 127+ 7FB6 ~            	ld a, 5
 128+ 7FB6 ~            	jr BDOS
 129+ 7FB6              	ENDIF
 130+ 7FB6
 131+ 7FB6
 132+ 7FB6              ;Set DMA address for BDOS
 133+ 7FB6              ;IX=DMA
 134+ 7FB6              BDOSSetDMA:
 135+ 7FB6 3E 0D        	ld a, 13
 136+ 7FB8 18 F2        	jr BDOS
 137+ 7FBA
 138+ 7FBA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 139+ 7FBA              ;HL=file name, A=drive
 140+ 7FBA              DeleteFile:
 141+ 7FBA CD 78 7F     	call	CreateChannel
 142+ 7FBD
 143+ 7FBD 3E 06        	ld		a, 6
 144+ 7FBF CD AC 7F     	call	BDOS
 145+ 7FC2
 146+ 7FC2 CD 8E 7F     	call	DestroyChannel
 147+ 7FC5 C9           	ret
 148+ 7FC6
 149+ 7FC6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 150+ 7FC6              ;IN: E0 = RO, E1 = SYS, HL=filename
 151+ 7FC6              ChangeFileAttrib:
 152+ 7FC6 3A 5A 7F     	ld 		a, (RWTSDrive)
 153+ 7FC9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 154+ 7FCA D5           	push	de
 155+ 7FCB CD 78 7F     	call	CreateChannel
 156+ 7FCE D1           	pop		de
 157+ 7FCF
 158+ 7FCF DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 159+ 7FD2 CB 27        	sla		a								;reset existing attribute flag
 160+ 7FD4 CB 1B        	rr		e								;put wanted flag in Carry flag
 161+ 7FD6 CB 1F        	rr		a								;put Carry flag in register L
 162+ 7FD8 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 163+ 7FDB
 164+ 7FDB DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 165+ 7FDE CB 27        	sla		a
 166+ 7FE0 CB 1B        	rr		e
 167+ 7FE2 CB 1F        	rr		a
 168+ 7FE4 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 169+ 7FE7
 170+ 7FE7              FileAttribSet:
 171+ 7FE7 3E 11        	ld		a, 17
 172+ 7FE9 CD AC 7F     	call	BDOS
 173+ 7FEC
 174+ 7FEC CD 8E 7F     	call	DestroyChannel
 175+ 7FEF C9           	ret
 176+ 7FF0
 177+ 7FF0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 178+ 7FF0
 179+ 7FF0              ;HL=original name, DE = new name
 180+ 7FF0              ;Works only on the same drive.
 181+ 7FF0              RenameFile:
 182+ 7FF0 3A 5A 7F     	ld 		a, (RWTSDrive)
 183+ 7FF3 3C           	inc		a					;Convert to BASIC drive number: 1,2
 184+ 7FF4 D5           	push	de
 185+ 7FF5 CD 78 7F     	call	CreateChannel
 186+ 7FF8 D1           	pop		de
 187+ 7FF9
 188+ 7FF9 DD E5        	push	ix					;IX == FCB
 189+ 7FFB E1           	pop		hl
 190+ 7FFC 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 191+ 7FFF 09           	add		hl, bc
 192+ 8000 EB           	ex		de, hl
 193+ 8001 3A 5A 7F     	ld		a, (RWTSDrive)
 194+ 8004 12           	ld		(de), a
 195+ 8005 01 0B 00     	ld		bc, NAMELEN
 196+ 8008 ED B0        	ldir
 197+ 800A
 198+ 800A 3E 0A        	ld		a, 10
 199+ 800C CD AC 7F     	call	BDOS
 200+ 800F
 201+ 800F CD 8E 7F     	call	DestroyChannel
 202+ 8012 C9           	ret
 203+ 8013
 204+ 8013              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205+ 8013
 206+ 8013              ;Will copy a file from A: to B: or vice versa.
 207+ 8013              ;HL=source file name
 208+ 8013              CopyFile:
 209+ 8013              	;Prepare source file
 210+ 8013 E5           	push hl
 211+ 8014 3A 5A 7F     		ld 		a, (RWTSDrive)
 212+ 8017 3C           		inc		a					;Convert to BASIC drive number: 1,2
 213+ 8018 CD 78 7F     		call	CreateChannel
 214+ 801B CD 9C 7F     		call 	OpenFile
 215+ 801E DD 22 81 A4  		ld		(CopyFileFCBSrc), ix
 216+ 8022 E1           	pop hl
 217+ 8023 3C           	inc  	a						;Cancel if A==$FF
 218+ 8024 28 73        	jr   	z, CopyFileEnd
 219+ 8026
 220+ 8026              	;Create destination file
 221+ 8026 DD 7E 00     	ld		a, (ix)
 222+ 8029 EE 03        	xor		%11						;Alternate drive, A->B, B-A
 223+ 802B F5           	push	af
 224+ 802C E5           	push	hl
 225+ 802D CD BA 7F     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 226+ 8030 E1           	pop		hl
 227+ 8031 F1           	pop		af
 228+ 8032 CD 78 7F     	call	CreateChannel
 229+ 8035 CD 98 7F     	call 	CreateFile
 230+ 8038 DD 22 83 A4  	ld		(CopyFileFCBDst), ix
 231+ 803C 3C           	inc  	a						;Cancel if A==$FF
 232+ 803D 28 5A        	jr   	z, CopyFileEnd
 233+ 803F
 234+ 803F              FileCopyLoop:
 235+ 803F 06 56        	ld		b, MAX_SECT_RAM
 236+ 8041 DD 21 87 A4  	ld		ix, CopyFileDMAAddr
 237+ 8045 DD 36 00 2E  	ld		(ix), CopyFileDMA % $FF
 238+ 8049 DD 36 01 A5  	ld		(ix+1), CopyFileDMA / $FF
 239+ 804D              FileCopyReadLoop:
 240+ 804D C5           	push	bc
 241+ 804E DD 2A 87 A4  		ld		ix, (CopyFileDMAAddr)
 242+ 8052 CD B6 7F     		call 	BDOSSetDMA
 243+ 8055 DD 24        		inc		ixh
 244+ 8057 DD 22 87 A4  		ld		(CopyFileDMAAddr), ix
 245+ 805B
 246+ 805B DD 2A 81 A4  		ld		ix, (CopyFileFCBSrc)
 247+ 805F CD A4 7F     		call 	ReadFileBlock
 248+ 8062 B7           		or		a
 249+ 8063 32 85 A4     		ld		(CopyFileResRead), a
 250+ 8066 C1           	pop		bc
 251+ 8067 20 02        	jr		nz, FileCopyWrite
 252+ 8069 10 E2        	djnz	FileCopyReadLoop
 253+ 806B
 254+ 806B              FileCopyWrite:
 255+ 806B DD 21 87 A4  	ld		ix, CopyFileDMAAddr
 256+ 806F DD 36 00 2E  	ld		(ix), CopyFileDMA % $FF
 257+ 8073 DD 36 01 A5  	ld		(ix+1), CopyFileDMA / $FF
 258+ 8077
 259+ 8077              	;Calculate how many sectors were read.
 260+ 8077 3E 56        	ld		a, MAX_SECT_RAM
 261+ 8079 90           	sub		b
 262+ 807A 47           	ld		b, a
 263+ 807B
 264+ 807B              FileCopyWriteLoop:
 265+ 807B C5           	push	bc
 266+ 807C DD 2A 87 A4  		ld		ix, (CopyFileDMAAddr)
 267+ 8080 CD B6 7F     		call 	BDOSSetDMA
 268+ 8083 DD 24        		inc		ixh
 269+ 8085 DD 22 87 A4  		ld		(CopyFileDMAAddr), ix
 270+ 8089
 271+ 8089 DD 2A 83 A4  		ld		ix, (CopyFileFCBDst)
 272+ 808D CD A8 7F     		call	WriteFileBlock
 273+ 8090 B7           		or		a
 274+ 8091 32 86 A4     		ld		(CopyFileResWrite), a
 275+ 8094 C1           	pop		bc
 276+ 8095 20 02        	jr		nz, CopyFileEnd
 277+ 8097 10 E2        	djnz	FileCopyWriteLoop
 278+ 8099
 279+ 8099              CopyFileEnd:
 280+ 8099              	;Check if copy loop was stopped because buffer ran out, continue copy in that case. Otherwise, it's file end.
 281+ 8099 3A 85 A4     	ld		a, (CopyFileResRead)
 282+ 809C B7           	or		a
 283+ 809D 28 A0        	jr		z, FileCopyLoop
 284+ 809F
 285+ 809F DD 2A 83 A4  	ld		ix, (CopyFileFCBDst)
 286+ 80A3 CD A0 7F     	call 	CloseFile				;close destination file
 287+ 80A6 CD 8E 7F     	call 	DestroyChannel
 288+ 80A9
 289+ 80A9              	;Don't need to close source file, but must free channel
 290+ 80A9 DD 2A 81 A4  	ld		ix, (CopyFileFCBSrc)
 291+ 80AD CD 8E 7F     	call 	DestroyChannel
 292+ 80B0
 293+ 80B0 3A 86 A4     	ld		a, (CopyFileResWrite)
 294+ 80B3
 295+ 80B3 C9           	ret
 296+ 80B4
 297+ 80B4              	endif
 298+ 80B4
# file closed: bdos.asm
1111  80B4              	include "ui.asm"
# file opened: ui.asm
   1+ 80B4              ;UI related functions
   2+ 80B4
   3+ 80B4              	ifndef	_UI_
   4+ 80B4              	define	_UI_
   5+ 80B4
   6+ 80B4              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++80B4              	ifndef	_HCCFG_
   2++80B4 ~            	define	_HCCFG_
   3++80B4 ~
   4++80B4 ~            ;HC specific code, for configuration
   5++80B4 ~
   6++80B4 ~            HC_CFG_PORT			EQU	$7E
   7++80B4 ~
   8++80B4 ~            ;BASIC/CPM ROM selection
   9++80B4 ~            HC_CFG_ROM_BAS		EQU	%0
  10++80B4 ~            HC_CFG_ROM_CPM		EQU	%1
  11++80B4 ~
  12++80B4 ~            ;Address for ROM paging: 0 or $E000
  13++80B4 ~            HC_CFG_ROM_0000		EQU %00
  14++80B4 ~            HC_CFG_ROM_E000		EQU %10
  15++80B4 ~
  16++80B4 ~            ;Cfg. port Enable/Disable
  17++80B4 ~            HC_CFG_PORT_DIS		EQU %000
  18++80B4 ~            HC_CFG_PORT_EN		EQU	%100
  19++80B4 ~
  20++80B4 ~            ;Video memory bank: $4000 or $C000
  21++80B4 ~            HC_CFG_VID_4000		EQU	%0000
  22++80B4 ~            HC_CFG_VID_C000		EQU	%1000
  23++80B4 ~
  24++80B4 ~
  25++80B4 ~            ;Standar BASIC config
  26++80B4 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++80B4 ~            ;Standar CP/M config
  28++80B4 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++80B4 ~
  30++80B4 ~
  31++80B4 ~            HC_VID_BANK0		EQU	$4000
  32++80B4 ~            HC_VID_BANK1		EQU	$C000
  33++80B4 ~
  34++80B4              	endif
# file closed: hccfg.asm
   7+ 80B4
   8+ 80B4              COL             EQU 23728
   9+ 80B4              LINE            EQU 23729               ;Coordinates
  10+ 80B4              LineCol			EQU	COL
  11+ 80B4              CODE			EQU 23681               ;Char to print
  12+ 80B4
  13+ 80B4              CPM_FNT         EQU $25AB
  14+ 80B4
  15+ 80B4              PORT_ZX			EQU	$FE
  16+ 80B4
  17+ 80B4              ;COLORS
  18+ 80B4              CLR_BLACK		EQU 0
  19+ 80B4              CLR_BLUE		EQU 1
  20+ 80B4              CLR_RED			EQU 2
  21+ 80B4              CLR_MAGENTA		EQU 3
  22+ 80B4              CLR_GREEN		EQU 4
  23+ 80B4              CLR_CYAN		EQU	5
  24+ 80B4              CLR_YELLOW		EQU	6
  25+ 80B4              CLR_WHITE		EQU	7
  26+ 80B4              CLR_BRIGHT		EQU	%01000000
  27+ 80B4              CLR_FLASH		EQU	%10000000
  28+ 80B4
  29+ 80B4              ;PAPER
  30+ 80B4              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 80B4              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 80B4              PAPER_RED		EQU (CLR_RED << 3)
  33+ 80B4              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 80B4              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 80B4              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 80B4              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 80B4              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 80B4
  39+ 80B4              ;INK
  40+ 80B4              INK_BLACK		EQU CLR_BLACK
  41+ 80B4              INK_BLUE		EQU CLR_BLUE
  42+ 80B4              INK_RED			EQU CLR_RED
  43+ 80B4              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 80B4              INK_GREEN		EQU CLR_GREEN
  45+ 80B4              INK_CYAN		EQU	CLR_CYAN
  46+ 80B4              INK_YELLOW		EQU	CLR_YELLOW
  47+ 80B4              INK_WHITE		EQU	CLR_WHITE
  48+ 80B4
  49+ 80B4
  50+ 80B4              ;SCR_ATTR_ADDR	EQU 22528
  51+ 80B4              SCR_PIX_LEN		EQU	6144
  52+ 80B4              SCR_ATTR_LEN	EQU	768
  53+ 80B4              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 80B4              SCR_BYTES_PER_LINE	EQU	32
  55+ 80B4
  56+ 80B4              SCR_COLS		EQU	64
  57+ 80B4              SCR_LINES		EQU 24
  58+ 80B4
  59+ 80B4              ;used for file names list positioning
  60+ 80B4              LST_LINES_CNT	EQU	23
  61+ 80B4              LST_FIRST_LINE	EQU	0
  62+ 80B4              LST_DISK_INFO	EQU 3
  63+ 80B4              LST_FILE_INFO	EQU 7
  64+ 80B4              LST_LINE_MSG	EQU 13
  65+ 80B4              LST_FIRST_COL	EQU	16
  66+ 80B4              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  67+ 80B4
  68+ 80B4              ;key codes
  69+ 80B4              KEY_ESC			EQU	7
  70+ 80B4              KEY_LEFT		EQU	8
  71+ 80B4              KEY_RIGHT		EQU	9
  72+ 80B4              KEY_DOWN		EQU	10
  73+ 80B4              KEY_UP			EQU	11
  74+ 80B4              KEY_BACKSP		EQU 12
  75+ 80B4              KEY_ENTER		EQU	13
  76+ 80B4              KEY_CTRL		EQU	14
  77+ 80B4
  78+ 80B4              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  79+ 80B4              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  80+ 80B4              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  81+ 80B4
  82+ 80B4              ;Special formating chars
  83+ 80B4              CHR_CR			EQU	13
  84+ 80B4              CHR_LF			EQU	10
  85+ 80B4              CHR_TAB			EQU	09
  86+ 80B4              CHR_EOF			EQU $1A
  87+ 80B4
  88+ 80B4
  89+ 80B4              ;Semi-graphical chars
  90+ 80B4              ;           UC
  91+ 80B4              ;     UL +H-+--+UR
  92+ 80B4              ;        |  |  |
  93+ 80B4              ;     ML +--+--+MR
  94+ 80B4              ;        V C|  |
  95+ 80B4              ;     LL +--+--+LR
  96+ 80B4              ;           DC
  97+ 80B4              CHR_GRID        EQU 127
  98+ 80B4              CHR_V           EQU	128
  99+ 80B4              CHR_MR          EQU	129
 100+ 80B4              CHR_UR          EQU 130
 101+ 80B4              CHR_DL          EQU 131
 102+ 80B4              CHR_DC          EQU 132
 103+ 80B4              CHR_UC          EQU 133
 104+ 80B4              CHR_ML          EQU 134
 105+ 80B4              CHR_H           EQU 135
 106+ 80B4              CHR_C           EQU 136
 107+ 80B4              CHR_LR          EQU 137
 108+ 80B4              CHR_UL          EQU 138
 109+ 80B4              CHR_FULL        EQU 139
 110+ 80B4              CHR_HALF        EQU 140
 111+ 80B4
 112+ 80B4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 113+ 80B4
 114+ 80B4              ;Return read char in A
 115+ 80B4              ReadChar:
 116+ 80B4 CF           	rst 08
 117+ 80B5 1B           	DEFB 27
 118+ 80B6 C9           	ret
 119+ 80B7
 120+ 80B7              ;Checks if a key is pressed
 121+ 80B7              ;Cy=1 if key is pressed
 122+ 80B7              KbdHit:
 123+ 80B7 CF           	rst 08
 124+ 80B8 20           	DEFB 32
 125+ 80B9 C9           	ret
 126+ 80BA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 127+ 80BA
 128+ 80BA              InitFonts:
 129+ 80BA              	IFUSED
 130+ 80BA                  ;page-in CPM ROM to get fonts
 131+ 80BA F3               di
 132+ 80BB 3E 01            ld a, HC_CFG_ROM_CPM
 133+ 80BD D3 7E            out	(HC_CFG_PORT), a
 134+ 80BF
 135+ 80BF 21 AB 25     	ld		hl, CPM_FNT
 136+ 80C2 11 19 91     	ld		de, FontTable
 137+ 80C5 01 68 03     	ld		bc, 872
 138+ 80C8 ED B0        	ldir
 139+ 80CA
 140+ 80CA                  ;restore BASIC ROM
 141+ 80CA 3E 00            ld a, HC_CFG_ROM_BAS
 142+ 80CC D3 7E            out	(HC_CFG_PORT), a
 143+ 80CE FB               ei
 144+ 80CF
 145+ 80CF C9           	ret
 146+ 80D0              	ENDIF
 147+ 80D0
 148+ 80D0              ClrScr:
 149+ 80D0 2A 73 82     	ld		hl, (CurrScrAddr)
 150+ 80D3 54           	ld		d, h
 151+ 80D4 5D           	ld		e, l
 152+ 80D5 13           	inc		de
 153+ 80D6 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 154+ 80D9 36 00        	ld		(hl), 0
 155+ 80DB ED B0        	ldir
 156+ 80DD
 157+ 80DD 23           	inc 	hl
 158+ 80DE 13           	inc		de
 159+ 80DF
 160+ 80DF 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 161+ 80E2 36 0F        	ld		(hl), SCR_DEF_CLR
 162+ 80E4 ED B0        	ldir
 163+ 80E6
 164+ 80E6              	;also set border color
 165+ 80E6 3E 01        	ld		a, SCR_DEF_CLR >> 3
 166+ 80E8 D3 FE        	out		(PORT_ZX), a
 167+ 80EA
 168+ 80EA 3E 0F        	ld		a, SCR_DEF_CLR
 169+ 80EC 32 48 5C     	ld		(23624), a
 170+ 80EF C9           	ret
 171+ 80F0
 172+ 80F0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 173+ 80F0              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 174+ 80F0              PrintStr:
 175+ 80F0 7E           	ld		a, (hl)
 176+ 80F1 FE 20        	cp		' '
 177+ 80F3 30 02        	jr		nc, GoodChar
 178+ 80F5 3E 3F        	ld		a, '?'
 179+ 80F7              GoodChar:
 180+ 80F7 CB 7F        	bit		7, a
 181+ 80F9 CB BF        	res		7, a
 182+ 80FB 32 81 5C     	ld		(CODE), a
 183+ 80FE ED 53 B0 5C  	ld		(LineCol), de
 184+ 8102 08           	ex		af, af'
 185+ 8103 D9           	exx
 186+ 8104 E5           	push	hl
 187+ 8105 CD F3 81     	call 	PrintChar
 188+ 8108 E1           	pop		hl
 189+ 8109 D9           	exx
 190+ 810A 08           	ex		af, af'
 191+ 810B C0           	ret		nz
 192+ 810C
 193+ 810C 1C           	inc		e
 194+ 810D 23           	inc		hl
 195+ 810E
 196+ 810E 7B           	ld		a, e
 197+ 810F FE 40        	cp		64
 198+ 8111 38 DD        	jr		c, PrintStr
 199+ 8113 1E 00        	ld		e, 0
 200+ 8115 14           	inc		d
 201+ 8116
 202+ 8116 18 D8        	jr		PrintStr
 203+ 8118
 204+ 8118              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205+ 8118
 206+ 8118              ;IN: HL = string, DE = coords, A = color
 207+ 8118              PrintStrClr:
 208+ 8118 32 44 81     	ld		(StrClr), a
 209+ 811B D5           	push	de
 210+ 811C CD F0 80     		call	PrintStr
 211+ 811F E1           	pop		hl
 212+ 8120              	;get string len.
 213+ 8120 7B           	ld		a, e
 214+ 8121 95           	sub		l
 215+ 8122 1F           	rra
 216+ 8123 08           	ex		af, af'
 217+ 8124              		;line * 32
 218+ 8124 7C           		ld		a, h
 219+ 8125 17           		rla
 220+ 8126 17           		rla
 221+ 8127 11 00 00     		ld	de, 0
 222+ 812A 17           		rla
 223+ 812B CB 12        		rl	d
 224+ 812D 17           		rla
 225+ 812E CB 12        		rl	d
 226+ 8130 17           		rla
 227+ 8131 CB 12        		rl	d
 228+ 8133 5F           		ld	e, a
 229+ 8134
 230+ 8134 26 00        		ld		h, 0
 231+ 8136 19           		add		hl, de
 232+ 8137 ED 5B 75 82  		ld		de, (CurrScrAttrAddr)
 233+ 813B 19           		add		hl, de
 234+ 813C 08           	ex		af, af'
 235+ 813D 4F           	ld		c, a
 236+ 813E 06 00        	ld		b, 0
 237+ 8140 54           	ld		d, h
 238+ 8141 5D           	ld		e, l
 239+ 8142 13           	inc 	de
 240+ 8143              StrClr	EQU	$ + 1
 241+ 8143 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 242+ 8145 ED B0        	ldir
 243+ 8147 C9           	ret
 244+ 8148              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 8148
 246+ 8148              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 247+ 8148              DrawLine:
 248+ 8148 32 81 5C     	ld		(CODE), a
 249+ 814B
 250+ 814B 38 04        	jr		c, VertDir
 251+ 814D 3E 1C        	ld		a, $1C
 252+ 814F 18 02        	jr		StoreDir
 253+ 8151              VertDir:
 254+ 8151 3E 14        	ld		a, $14
 255+ 8153              StoreDir:
 256+ 8153 32 63 81     	ld		(LineDir), a
 257+ 8156
 258+ 8156              DrawLineLoop:
 259+ 8156 ED 53 B0 5C  	ld		(LineCol), de
 260+ 815A D5           	push	de
 261+ 815B D9           		exx
 262+ 815C E5           		push	hl
 263+ 815D CD F3 81     		call 	PrintChar
 264+ 8160 E1           		pop		hl
 265+ 8161 D9           		exx
 266+ 8162 D1           	pop		de
 267+ 8163              LineDir:
 268+ 8163 1C           	inc		e
 269+ 8164 10 F0        	djnz	DrawLineLoop
 270+ 8166
 271+ 8166 C9           	ret
 272+ 8167
 273+ 8167              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 274+ 8167
 275+ 8167              DrawHLine:
 276+ 8167 32 76 81     	ld		(ChrParam), a
 277+ 816A
 278+ 816A 06 10        	ld		b, 16
 279+ 816C 3E 87        	ld		a, CHR_H
 280+ 816E B7           	or		a
 281+ 816F CD 48 81     	call	DrawLine
 282+ 8172
 283+ 8172 06 04        	ld		b, 4
 284+ 8174              DrawUpLine:
 285+ 8174 C5           	push	bc
 286+ 8175              ChrParam	EQU		$ + 1
 287+ 8175 3E 85        		ld		a, CHR_UC
 288+ 8177 D5           		push	de
 289+ 8178 CD A9 81     			call	PrintChar2
 290+ 817B D1           		pop		de
 291+ 817C 13           		inc		de
 292+ 817D
 293+ 817D 06 0B        		ld		b, NAMELEN
 294+ 817F 3E 87        		ld		a, CHR_H
 295+ 8181 B7           		or		a
 296+ 8182 CD 48 81     		call	DrawLine
 297+ 8185 C1           	pop		bc
 298+ 8186 10 EC        	djnz	DrawUpLine
 299+ 8188
 300+ 8188 06 04        	ld		b, 4
 301+ 818A 3E 87        	ld		a, CHR_H
 302+ 818C B7           	or		a
 303+ 818D CD 48 81     	call	DrawLine
 304+ 8190 C9           	ret
 305+ 8191
 306+ 8191
 307+ 8191              DrawVLines:
 308+ 8191 06 04        	ld		b, 4
 309+ 8193 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 310+ 8196              DrawVLinesLoop:
 311+ 8196 C5           	push 	bc
 312+ 8197 D5           	push	de
 313+ 8198 06 17        		ld		b, LST_LINES_CNT
 314+ 819A 3E 80        		ld		a, CHR_V
 315+ 819C 37           		scf
 316+ 819D CD 48 81     		call	DrawLine
 317+ 81A0 D1           	pop		de
 318+ 81A1 C1           	pop	bc
 319+ 81A2 7B           	ld		a, e
 320+ 81A3 C6 0C        	add		NAMELEN+1
 321+ 81A5 5F           	ld		e, a
 322+ 81A6 10 EE        	djnz	DrawVLinesLoop
 323+ 81A8 C9           	ret
 324+ 81A9
 325+ 81A9              PrintChar2:
 326+ 81A9 32 81 5C     	ld		(CODE), a
 327+ 81AC ED 53 B0 5C  	ld		(LineCol), de
 328+ 81B0
 329+ 81B0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 330+ 81B0
 331+ 81B0              ;IN: A = color mask
 332+ 81B0              DrawCursor:
 333+ 81B0 ED 5B 17 88  	ld	de, (CursorAddr)
 334+ 81B4 06 06        	ld	b, 	(NAMELEN + 1)/2
 335+ 81B6              DrawCursorLoop:
 336+ 81B6 12           	ld	(de), a
 337+ 81B7 13           	inc de
 338+ 81B8 10 FC        	djnz DrawCursorLoop
 339+ 81BA C9           	ret
 340+ 81BB
 341+ 81BB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 342+ 81BB
 343+ 81BB              ;IN:	A = file idx.
 344+ 81BB              MoveCursor:
 345+ 81BB              	;File idx / SCR_LINES => cursor line & column
 346+ 81BB 6F           	ld		l, a
 347+ 81BC 26 00        	ld		h, 0
 348+ 81BE 0E 17        	ld		c, LST_LINES_CNT
 349+ 81C0 CD 7F 7C     	call	Div					;HL = file column, A = line
 350+ 81C3
 351+ 81C3              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 352+ 81C3 C6 00        	add		LST_FIRST_LINE
 353+ 81C5
 354+ 81C5
 355+ 81C5 54           	ld d, h
 356+ 81C6 5D           	ld e, l
 357+ 81C7 21 00 00     	ld	hl, 0
 358+ 81CA
 359+ 81CA              	;line*32
 360+ 81CA 17           	rla
 361+ 81CB 17           	rla
 362+ 81CC 17           	rla
 363+ 81CD 17           	rla
 364+ 81CE CB 14        	rl h
 365+ 81D0 17           	rla
 366+ 81D1 CB 14        	rl h
 367+ 81D3 6F           	ld l, a
 368+ 81D4
 369+ 81D4
 370+ 81D4              	;col * 6
 371+ 81D4 E5           	push	hl					;save line * 32
 372+ 81D5 3E 06        		ld		a, (NAMELEN + 1)/2
 373+ 81D7 CD 9F 7C     		call	Mul				;HL = column * 12/2
 374+ 81DA D1           	pop		de
 375+ 81DB 19           	add		hl, de
 376+ 81DC
 377+ 81DC 11 08 00     	ld		de, LST_FIRST_COL/2
 378+ 81DF ED 4B 75 82  	ld		bc, (CurrScrAttrAddr)
 379+ 81E3 19           	add		hl, de
 380+ 81E4 09           	add		hl, bc
 381+ 81E5
 382+ 81E5              	;clear old cursor
 383+ 81E5 3E 0F        	ld		a, SCR_DEF_CLR
 384+ 81E7 CD B0 81     	call	DrawCursor
 385+ 81EA
 386+ 81EA              	;draw new one
 387+ 81EA 22 17 88     	ld		(CursorAddr), hl
 388+ 81ED 3E 28        	ld		a, SCR_SEL_CLR
 389+ 81EF CD B0 81     	call	DrawCursor
 390+ 81F2
 391+ 81F2 C9           	ret
 392+ 81F3
 393+ 81F3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 394+ 81F3
 395+ 81F3              PrintChar:
 396+ 81F3 ED 5B B0 5C      ld		de, (LineCol)
 397+ 81F7
 398+ 81F7                  ;calculate 64 column screen address
 399+ 81F7              	;IN: D = line, E = col
 400+ 81F7              	;OUT: HL = screen address
 401+ 81F7
 402+ 81F7 CB 3B            SRL     E                                       ;col = col/2
 403+ 81F9 CB 19            RR      C                                       ;mark odd/even column
 404+ 81FB 7A               LD      A, D                            ;A = line
 405+ 81FC E6 18            AND 24                                  ;keep only %00011000
 406+ 81FE 2A 73 82         ld		hl, (CurrScrAddr)
 407+ 8201 B4               OR      h								;add screen start address
 408+ 8202 67               LD      H, A                            ;save H
 409+ 8203 7A               LD      A, D                            ;A = line
 410+ 8204 E6 07            AND 7                                   ;keep only %00000111
 411+ 8206 0F               RRCA                                    ;%10000011
 412+ 8207 0F               RRCA                                    ;%11000001
 413+ 8208 0F               RRCA                                    ;%11100000
 414+ 8209 B3               OR      E                                       ;add column
 415+ 820A 6F               LD      L, A                            ;HL = screen address
 416+ 820B
 417+ 820B              PrintChar3:
 418+ 820B                  ;get font address
 419+ 820B E5               PUSH HL
 420+ 820C AF                   XOR A
 421+ 820D 67                   LD  H, A
 422+ 820E 3A 81 5C             LD  A, (CODE)
 423+ 8211 D6 20                SUB ' '
 424+ 8213 6F                   LD  L, A
 425+ 8214 29                   ADD     HL, HL                  ;char code = char code * 8
 426+ 8215 29                   ADD     HL, HL                  ;i.e. offset into font table
 427+ 8216 29                   ADD     HL, HL
 428+ 8217 11 19 91             LD      DE, FontTable             ;get font table
 429+ 821A 19                   ADD     HL, DE
 430+ 821B EB                   EX      DE, HL                  ;DE = our char font address
 431+ 821C E1               POP     HL
 432+ 821D
 433+ 821D
 434+ 821D                  ;print a char
 435+ 821D 06 08            LD      B, 8                            ;char height is 8 lines
 436+ 821F              PrintCharLine:
 437+ 821F 1A                   LD      A, (DE)                         ;load char line in A
 438+ 8220
 439+ 8220 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 440+ 8222 20 06                JR  	NZ, NoTurn
 441+ 8224
 442+ 8224 07                   RLCA
 443+ 8225 07                   RLCA
 444+ 8226 07                   RLCA
 445+ 8227 07                   RLCA
 446+ 8228 18 01                JR      Store
 447+ 822A              NoTurn:
 448+ 822A B6                   OR (HL)
 449+ 822B              Store:
 450+ 822B 77                   LD (HL), A
 451+ 822C
 452+ 822C 13                   INC     DE                                      ;next char line in font table
 453+ 822D 24                   INC     H                                       ;next char line on screen
 454+ 822E 10 EF            DJNZ PrintCharLine                  ;last line of char?
 455+ 8230
 456+ 8230 C9               ret
 457+ 8231
 458+ 8231              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 459+ 8231
 460+ 8231              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 461+ 8231              ReadString:
 462+ 8231 21 81 A4     	ld		hl, DataBuf
 463+ 8234 D5           	push	de
 464+ 8235 DD E1        	pop		ix
 465+ 8237
 466+ 8237              ReadStringLoop:
 467+ 8237 D5           	push	de
 468+ 8238 E5           	push	hl
 469+ 8239 CD B4 80     		call ReadChar
 470+ 823C E1           	pop		hl
 471+ 823D D1           	pop		de
 472+ 823E
 473+ 823E FE 0D        	cp	KEY_ENTER
 474+ 8240 C8           	ret z
 475+ 8241
 476+ 8241 FE 0C        	cp  KEY_BACKSP
 477+ 8243 20 0F        	jr	nz, ReadStrChar
 478+ 8245
 479+ 8245 E5           	push hl
 480+ 8246 01 82 A4     	ld   bc, DataBuf+1
 481+ 8249 ED 42        	sbc	 hl, bc
 482+ 824B E1           	pop  hl
 483+ 824C 38 16        	jr   c, ReadStrPrint
 484+ 824E
 485+ 824E 1B           	dec	de
 486+ 824F 2B           	dec	hl
 487+ 8250 36 20        	ld	(hl), ' '
 488+ 8252 18 10        	jr	ReadStrPrint
 489+ 8254
 490+ 8254              ReadStrChar:
 491+ 8254 FE 20        	cp	' '
 492+ 8256 38 DF        	jr	c, ReadStringLoop
 493+ 8258 FE 7F        	cp  127
 494+ 825A 30 DB        	jr	nc, ReadStringLoop
 495+ 825C
 496+ 825C              	;Check end of string and go back if found.
 497+ 825C 46           	ld	b, (hl)
 498+ 825D CB 78        	bit 7, b
 499+ 825F 20 03        	jr	nz, ReadStrPrint
 500+ 8261
 501+ 8261 77           	ld	(hl), a
 502+ 8262 23           	inc	hl
 503+ 8263 13           	inc	de
 504+ 8264
 505+ 8264              ReadStrPrint:
 506+ 8264 E5           	push	hl
 507+ 8265 D5           	push	de
 508+ 8266 21 81 A4     	ld		hl, DataBuf
 509+ 8269 DD E5        	push	ix
 510+ 826B D1           	pop		de
 511+ 826C CD F0 80     	call	PrintStr
 512+ 826F D1           	pop		de
 513+ 8270 E1           	pop		hl
 514+ 8271
 515+ 8271 18 C4        	jr		ReadStringLoop
 516+ 8273
 517+ 8273 00 40        CurrScrAddr		DEFW	16384
 518+ 8275 00 58        CurrScrAttrAddr	DEFW	22528
 519+ 8277
 520+ 8277                 	endif
# file closed: ui.asm
1112  8277              	include "math.asm"
# file opened: math.asm
   1+ 8277              	ifndef	_MATH_
   2+ 8277 ~            	define	_MATH_
   3+ 8277 ~
   4+ 8277 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 8277 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 8277 ~
   7+ 8277 ~
   8+ 8277 ~            Word2Txt:
   9+ 8277 ~            	IFUSED
  10+ 8277 ~            	push	de
  11+ 8277 ~            		call	Word2Txt_
  12+ 8277 ~            	pop		de
  13+ 8277 ~
  14+ 8277 ~            	ld		b, 4
  15+ 8277 ~            	call	StrippLeading0
  16+ 8277 ~            	ret
  17+ 8277 ~
  18+ 8277 ~            Byte2Txt:
  19+ 8277 ~            	push	de
  20+ 8277 ~            		call	Byte2Txt_
  21+ 8277 ~            	pop		de
  22+ 8277 ~
  23+ 8277 ~            	ld		b, 2
  24+ 8277 ~            	call	StrippLeading0
  25+ 8277 ~            	ret
  26+ 8277 ~            	ENDIF
  27+ 8277 ~
  28+ 8277 ~
  29+ 8277 ~            StrippLeading0:
  30+ 8277 ~            	ld		a, (de)
  31+ 8277 ~            	cp		'1'
  32+ 8277 ~            	ret		nc
  33+ 8277 ~
  34+ 8277 ~            	ld		a, ' '
  35+ 8277 ~            	ld		(de), a
  36+ 8277 ~            	inc		de
  37+ 8277 ~            	djnz	StrippLeading0
  38+ 8277 ~            	ret
  39+ 8277 ~
  40+ 8277 ~
  41+ 8277 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 8277 ~            Word2Txt_:
  43+ 8277 ~            	ld bc, -10000
  44+ 8277 ~            	call DigitLoop
  45+ 8277 ~            	ld bc, -1000
  46+ 8277 ~            	call DigitLoop
  47+ 8277 ~            Byte2Txt_:
  48+ 8277 ~            	ld bc, -100
  49+ 8277 ~            	call DigitLoop
  50+ 8277 ~            	ld bc, -10
  51+ 8277 ~            	call DigitLoop
  52+ 8277 ~            	ld bc, -1
  53+ 8277 ~
  54+ 8277 ~            DigitLoop:
  55+ 8277 ~            	ld	a, '0' - 1
  56+ 8277 ~            DivNrLoop:
  57+ 8277 ~            	inc	a			;increase reminder
  58+ 8277 ~            	add	hl, bc		;substract divizor
  59+ 8277 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 8277 ~            	sbc	hl, bc		;nope, restore
  61+ 8277 ~
  62+ 8277 ~            	ld (de), a
  63+ 8277 ~            	inc de
  64+ 8277 ~            	ret
  65+ 8277 ~
  66+ 8277 ~
  67+ 8277 ~            ;Input: HL = Dividend, C = Divisor
  68+ 8277 ~            ;Output: HL = Quotient, A = Remainder
  69+ 8277 ~            ;Warning: doesn't work with divisor >= $80
  70+ 8277 ~            Div:
  71+ 8277 ~            	IFUSED
  72+ 8277 ~            	xor a
  73+ 8277 ~            	ld b, 16
  74+ 8277 ~
  75+ 8277 ~            DivLoop:
  76+ 8277 ~            	add	hl,hl
  77+ 8277 ~            	rla
  78+ 8277 ~            	cp	c
  79+ 8277 ~            	jr	c, NoSub
  80+ 8277 ~            	sub	c
  81+ 8277 ~            	inc	l
  82+ 8277 ~            NoSub:
  83+ 8277 ~            	djnz DivLoop
  84+ 8277 ~
  85+ 8277 ~            	ret
  86+ 8277 ~            	ENDIF
  87+ 8277 ~
  88+ 8277 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 8277 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 8277 ~            Div2:
  91+ 8277 ~            	ld hl, 0
  92+ 8277 ~            	ld b, 16
  93+ 8277 ~            Div2Loop:
  94+ 8277 ~            	sll c		; unroll 16 times
  95+ 8277 ~            	rla			; ...
  96+ 8277 ~            	adc	hl,hl		; ...
  97+ 8277 ~            	sbc	hl,de		; ...
  98+ 8277 ~            	jr	nc,$+4		; ...
  99+ 8277 ~            	add	hl,de		; ...
 100+ 8277 ~            	dec	c		; ...
 101+ 8277 ~            	djnz Div2Loop
 102+ 8277 ~            	ret
 103+ 8277 ~
 104+ 8277 ~
 105+ 8277 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 8277 ~            ;Output: A:HL = Product
 107+ 8277 ~            Mul:
 108+ 8277 ~            	IFUSED
 109+ 8277 ~            	ld hl, 0
 110+ 8277 ~            	ld bc, $0700
 111+ 8277 ~
 112+ 8277 ~            	add	a, a		; optimised 1st iteration
 113+ 8277 ~            	jr	nc, MulLoop
 114+ 8277 ~            	ld	h, d
 115+ 8277 ~            	ld	l, e
 116+ 8277 ~
 117+ 8277 ~            MulLoop:
 118+ 8277 ~            	add	hl,hl
 119+ 8277 ~            	rla
 120+ 8277 ~            	jr	nc, NoAdd
 121+ 8277 ~            	add	hl,de
 122+ 8277 ~            	adc	a,c
 123+ 8277 ~            NoAdd:
 124+ 8277 ~            	djnz MulLoop
 125+ 8277 ~
 126+ 8277 ~            	ret
 127+ 8277 ~            	ENDIF
 128+ 8277 ~
 129+ 8277              	endif
# file closed: math.asm
1113  8277              	include "txtview.asm"
# file opened: txtview.asm
   1+ 8277              ; 	DEVICE ZXSPECTRUM48
   2+ 8277
   3+ 8277              LINE_CNT	EQU	23
   4+ 8277              COL_CNT		EQU	64
   5+ 8277
   6+ 8277              CHAR_CR		EQU	$0D
   7+ 8277              CHAR_LF		EQU	$0A
   8+ 8277              CHAR_TAB	EQU	$09
   9+ 8277
  10+ 8277              COORDS		EQU	23728		;Coordinates
  11+ 8277
  12+ 8277
  13+ 8277              InitViewer:
  14+ 8277 22 C3 85     	ld		 (FileBegin), hl
  15+ 827A 09           	add		hl, bc
  16+ 827B              	;must filter any EOF chars, max 256 of them.
  17+ 827B 25           	dec		h
  18+ 827C 3E 1A        	ld		a, 0x1A
  19+ 827E ED B1        	cpir
  20+ 8280 2B           	dec		hl
  21+ 8281 22 C7 85     	ld		(FileEnd), hl
  22+ 8284 ED 5B C3 85  	ld		de, (FileBegin)
  23+ 8288 B7           	or		a
  24+ 8289 ED 52        	sbc		hl, de
  25+ 828B 22 C5 85     	ld		(FileLen), hl
  26+ 828E
  27+ 828E 3E 0D        	ld		a, 0x0D
  28+ 8290 77           	ld		(hl), a
  29+ 8291
  30+ 8291
  31+ 8291 21 04 02     	ld		hl, (2 << 8) | 4
  32+ 8294 22 09 5C     	ld		(23561), hl
  33+ 8297
  34+ 8297 21 00 00     	ld		hl, 0
  35+ 829A 22 B0 5C     	ld		(COORDS), hl
  36+ 829D
  37+ 829D 21 00 58     	ld		hl, 16384 + 6144
  38+ 82A0 54           	ld		d, h
  39+ 82A1 5D           	ld		e, l
  40+ 82A2 13           	inc		de
  41+ 82A3 01 FF 02     	ld		bc, 767
  42+ 82A6 36 0F        	ld		(hl), (1 << 3) | 7
  43+ 82A8 ED B0        	ldir
  44+ 82AA
  45+ 82AA CD C9 84     	call	ScrollInit
  46+ 82AD
  47+ 82AD 11 00 00     	ld		de, 0
  48+ 82B0 ED 53 BE 85  	ld		(CurLine), de
  49+ 82B4
  50+ 82B4              	;prepare file progress %
  51+ 82B4 2A C5 85     	ld		hl, (FileLen)
  52+ 82B7 7C           	ld		a, h
  53+ 82B8 4D           	ld		c, l
  54+ 82B9 11 64 00     	ld		de, 100
  55+ 82BC CD 8C 7C     	call	Div2
  56+ 82BF 67           	ld		h, a
  57+ 82C0 69           	ld		l, c
  58+ 82C1 22 C9 85     	ld		(PROGR_PERC), hl
  59+ 82C4
  60+ 82C4 CD 58 84     	call	PrintMsg
  61+ 82C7
  62+ 82C7 DD 21 7F A4  	ld		ix, FileIdx	- 2
  63+ 82CB 06 17        	ld		b, LINE_CNT
  64+ 82CD 2A C3 85     	ld		hl, (FileBegin)
  65+ 82D0
  66+ 82D0 C9           	ret
  67+ 82D1
  68+ 82D1              PrintLoop:
  69+ 82D1 C5           	push	bc
  70+ 82D2 DD 23        		inc		ix
  71+ 82D4 DD 23        		inc		ix
  72+ 82D6 DD 75 00     		ld		(ix), l
  73+ 82D9 DD 74 01     		ld		(ix + 1), h
  74+ 82DC
  75+ 82DC CD F3 83     		call	GetLine
  76+ 82DF CD C5 83     		call	PrintLine
  77+ 82E2
  78+ 82E2 ED 5B BE 85  		ld		de, (CurLine)
  79+ 82E6 13           		inc		de
  80+ 82E7 ED 53 BE 85  		ld		(CurLine), de
  81+ 82EB C1           	pop		bc
  82+ 82EC CD BA 83     	call	CheckEnd
  83+ 82EF 28 13        	jr		z, EOF
  84+ 82F1
  85+ 82F1 10 DE        	djnz	PrintLoop
  86+ 82F3 18 17        	jr		PrintLoop2
  87+ 82F5
  88+ 82F5              GetKey:
  89+ 82F5 76           	halt
  90+ 82F6 FD CB 01 6E  	bit		5, (iy + 1);
  91+ 82FA 28 F9        	jr		z, GetKey
  92+ 82FC FD CB 01 AE  	res		5, (iy + 1)
  93+ 8300 FD 7E CE     	ld		a, (iy - $32)
  94+ 8303 C9           	ret
  95+ 8304
  96+ 8304              EOF:
  97+ 8304 CD F5 82     	call	GetKey
  98+ 8307 FE 30        	cp		'0'
  99+ 8309 20 F9        	jr		nz, EOF
 100+ 830B C9           	ret
 101+ 830C
 102+ 830C              PrintLoop2:
 103+ 830C CD 58 84     	call	PrintMsg
 104+ 830F
 105+ 830F CD F5 82     	call	GetKey
 106+ 8312 FE 30        	cp		'0'					;Exit on 0
 107+ 8314 C8           	ret		z
 108+ 8315
 109+ 8315 FE 0A        	cp		KEY_DOWN
 110+ 8317 28 5C        	jr		z, Down
 111+ 8319
 112+ 8319 FE 0B        	cp		KEY_UP
 113+ 831B 28 2D        	jr		z, Up
 114+ 831D
 115+ 831D FE 32        	cp		'2'
 116+ 831F 20 EB        	jr		nz, PrintLoop2
 117+ 8321
 118+ 8321 3A C2 85     	ld		a, (WrapFlag)
 119+ 8324 EE 01        	xor		1
 120+ 8326 32 C2 85     	ld		(WrapFlag), a
 121+ 8329 B7           	or		a
 122+ 832A 28 0F        	jr		z, NoWrap
 123+ 832C
 124+ 832C 11 4F 6E     	ld		de, 'nO'
 125+ 832F ED 53 74 85  	ld		(MsgLineWrF), de
 126+ 8333 3E 20        	ld		a, ' '
 127+ 8335 32 76 85     	ld		(MsgLineWrF + 2), a
 128+ 8338 C3 0C 83     	jp		PrintLoop2
 129+ 833B
 130+ 833B              NoWrap:
 131+ 833B 11 4F 66     	ld		de, 'fO'
 132+ 833E ED 53 74 85  	ld		(MsgLineWrF), de
 133+ 8342 3E 66        	ld		a, 'f'
 134+ 8344 32 76 85     	ld		(MsgLineWrF + 2), a
 135+ 8347
 136+ 8347 C3 0C 83     	jp		PrintLoop2
 137+ 834A
 138+ 834A
 139+ 834A              Up:
 140+ 834A CD AA 83     	call	CheckBegin
 141+ 834D 28 BD        	jr		z, PrintLoop2
 142+ 834F
 143+ 834F CD F7 84     	call	ScrollUp
 144+ 8352
 145+ 8352 DD 2B        	dec		ix
 146+ 8354 DD 2B        	dec		ix
 147+ 8356 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 148+ 8359 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 149+ 835C CD F3 83     	call	GetLine						;extract previous line to display
 150+ 835F
 151+ 835F 11 00 00     	ld		de, 0
 152+ 8362 ED 53 B0 5C  	ld		(COORDS), de
 153+ 8366 CD C5 83     	call	PrintLine
 154+ 8369
 155+ 8369 2A BE 85     	ld		hl, (CurLine)
 156+ 836C 2B           	dec		hl
 157+ 836D 22 BE 85     	ld		(CurLine), hl
 158+ 8370 CD 58 84     	call	PrintMsg
 159+ 8373 18 97        	jr		PrintLoop2
 160+ 8375
 161+ 8375
 162+ 8375              Down:
 163+ 8375 DD 6E 00     	ld		l, (ix)
 164+ 8378 DD 66 01     	ld		h, (ix + 1)
 165+ 837B CD F3 83     	call	GetLine						;get next line pointer
 166+ 837E
 167+ 837E CD BA 83     	call	CheckEnd					;check if HL == file end
 168+ 8381 38 89        	jr		c, PrintLoop2
 169+ 8383
 170+ 8383 DD 23        	inc		ix								;save next line pointer
 171+ 8385 DD 23        	inc		ix
 172+ 8387 DD 75 00     	ld		(ix), l
 173+ 838A DD 74 01     	ld		(ix + 1), h
 174+ 838D
 175+ 838D CD F3 83     	call	GetLine						;extract next line in buffer for display
 176+ 8390
 177+ 8390 CD FC 84     	call	ScrollDown
 178+ 8393
 179+ 8393 11 00 16     	ld		de, (LINE_CNT-1) << 8
 180+ 8396 ED 53 B0 5C  	ld		(COORDS), de
 181+ 839A CD C5 83     	call	PrintLine
 182+ 839D
 183+ 839D 2A BE 85     	ld		hl, (CurLine)
 184+ 83A0 23           	inc		hl
 185+ 83A1 22 BE 85     	ld		(CurLine), hl
 186+ 83A4 CD 58 84     	call	PrintMsg
 187+ 83A7
 188+ 83A7 C3 0C 83     	jp		PrintLoop2
 189+ 83AA
 190+ 83AA
 191+ 83AA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 83AA              ;check begining of buffer
 193+ 83AA              CheckBegin:
 194+ 83AA E5           	push	hl
 195+ 83AB DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 196+ 83AE DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 197+ 83B1 ED 5B C3 85  		ld		de, (FileBegin)
 198+ 83B5 B7           		or		a
 199+ 83B6 ED 52        		sbc		hl, de
 200+ 83B8 E1           	pop		hl
 201+ 83B9 C9           	ret
 202+ 83BA
 203+ 83BA              ;check end of buffer
 204+ 83BA              CheckEnd:
 205+ 83BA E5           	push	hl
 206+ 83BB ED 5B C7 85  		ld		de, (FileEnd)
 207+ 83BF EB           		ex		de, hl
 208+ 83C0 B7           		or		a
 209+ 83C1 ED 52        		sbc		hl, de
 210+ 83C3 E1           	pop		hl
 211+ 83C4 C9           	ret
 212+ 83C5
 213+ 83C5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214+ 83C5              ;Print a line
 215+ 83C5              PrintLine:
 216+ 83C5 11 7E 85     	ld		de, LineBuf
 217+ 83C8 06 40        	ld		b, COL_CNT
 218+ 83CA
 219+ 83CA CD D9 83     	call	PrintStrTxt
 220+ 83CD
 221+ 83CD              	;go to the next screen line
 222+ 83CD ED 5B B0 5C  	ld		de, (COORDS)
 223+ 83D1 14           	inc		d
 224+ 83D2 1E 00        	ld		e, 0
 225+ 83D4 ED 53 B0 5C  	ld		(COORDS), de
 226+ 83D8 C9           	ret
 227+ 83D9
 228+ 83D9              PrintStrTxt:
 229+ 83D9 1A           	ld		a, (de)
 230+ 83DA 13           	inc		de
 231+ 83DB D5           	push	de
 232+ 83DC 32 81 5C     		ld		(CODE), a
 233+ 83DF C5           		push	bc
 234+ 83E0 E5           			push	hl
 235+ 83E1 CD F3 81     				call	PrintChar
 236+ 83E4 E1           			pop		hl
 237+ 83E5 C1           		pop		bc
 238+ 83E6
 239+ 83E6 ED 5B B0 5C  		ld		de, (COORDS)
 240+ 83EA 1C           		inc		e
 241+ 83EB ED 53 B0 5C  		ld		(COORDS), de
 242+ 83EF D1           	pop		de
 243+ 83F0 10 E7        	djnz	PrintStrTxt
 244+ 83F2 C9           	ret
 245+ 83F3
 246+ 83F3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 83F3              ;Extract a line of text to fit exactly on a 64 screen line
 248+ 83F3              ;IN:	HL = current file pointer
 249+ 83F3              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 250+ 83F3              GetLine:
 251+ 83F3 11 7E 85     	ld		de, LineBuf
 252+ 83F6 06 40        	ld		b, COL_CNT
 253+ 83F8              GetLineLoop:
 254+ 83F8 7E           	ld		a, (hl)
 255+ 83F9 23           	inc		hl
 256+ 83FA
 257+ 83FA FE 0D        	cp		CHAR_CR
 258+ 83FC 28 29        	jr		z, GetLineSkip0A
 259+ 83FE
 260+ 83FE FE 0A        	cp		CHAR_LF
 261+ 8400 28 25        	jr		z, GetLineSkip0A
 262+ 8402
 263+ 8402 FE 09        	cp		CHAR_TAB
 264+ 8404 20 07        	jr		nz, GetLineNext
 265+ 8406
 266+ 8406 3E 20        	ld		a, ' '
 267+ 8408 12           	ld		(de), a
 268+ 8409 13           	inc		de
 269+ 840A 05           	dec		b
 270+ 840B 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 271+ 840D
 272+ 840D              GetLineNext:
 273+ 840D FE 20        	cp		' '
 274+ 840F 38 06        	jr		c, NotValid
 275+ 8411
 276+ 8411 FE 80        	cp		128
 277+ 8413 30 02        	jr		nc, NotValid
 278+ 8415 18 03        	jr		Valid
 279+ 8417
 280+ 8417              NotValid:
 281+ 8417 CD A7 84     	call	ReplaceChars
 282+ 841A
 283+ 841A              Valid:
 284+ 841A 12           	ld		(de), a
 285+ 841B 13           	inc		de
 286+ 841C 10 DA        	djnz	GetLineLoop
 287+ 841E
 288+ 841E              ;if line is exactly 64 char long, must skip the new line char(s)
 289+ 841E              GetLineSkip0D:
 290+ 841E 0E 00        	ld		c, 0
 291+ 8420 3E 0D        	ld		a, CHAR_CR						;skip 0D
 292+ 8422 BE           	cp		(hl)
 293+ 8423 20 02        	jr		nz, GetLineSkip0A
 294+ 8425 23           	inc		hl
 295+ 8426 0C           	inc		c
 296+ 8427
 297+ 8427              GetLineSkip0A:						;skip 0A
 298+ 8427 3E 0A        	ld		a, CHAR_LF
 299+ 8429 BE           	cp		(hl)
 300+ 842A 20 02        	jr		nz, GetLineFill
 301+ 842C 23           	inc		hl
 302+ 842D 0C           	inc		c
 303+ 842E
 304+ 842E              GetLineFill:
 305+ 842E 78           	ld		a, b
 306+ 842F B7           	or		a
 307+ 8430 20 1F        	jr		nz, GetLineFillLoop
 308+ 8432
 309+ 8432 79           	ld		a, c
 310+ 8433 B7           	or		a
 311+ 8434 C0           	ret		nz
 312+ 8435
 313+ 8435              	;wrap or not
 314+ 8435 3A C2 85     	ld		a, (WrapFlag)
 315+ 8438 B7           	or		a
 316+ 8439 C0           	ret		nz
 317+ 843A
 318+ 843A ED 5B C7 85  	ld		de, (FileEnd)
 319+ 843E E5           	push	hl
 320+ 843F EB           	ex		de, hl
 321+ 8440 B7           	or		a
 322+ 8441 ED 52        	sbc		hl, de
 323+ 8443 44           	ld		b, h
 324+ 8444 4D           	ld		c, l
 325+ 8445 3E 0D        	ld		a, CHAR_CR
 326+ 8447 E1           	pop		hl
 327+ 8448 ED B1        	cpir
 328+ 844A C0           	ret		nz
 329+ 844B 3E 0A        	ld		a, CHAR_LF
 330+ 844D BE           	cp		(hl)
 331+ 844E C0           	ret		nz
 332+ 844F 23           	inc		hl
 333+ 8450
 334+ 8450 C9           	ret
 335+ 8451
 336+ 8451              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 337+ 8451 3E 20        	ld		a, ' '
 338+ 8453 12           	ld		(de), a
 339+ 8454 13           	inc		de
 340+ 8455 10 FA        	djnz	GetLineFillLoop
 341+ 8457 C9           	ret
 342+ 8458
 343+ 8458              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 344+ 8458              PrintMsg:
 345+ 8458 ED 5B B0 5C  	ld		de, (COORDS)
 346+ 845C D5           	push	de
 347+ 845D 11 00 17     	ld		de, LINE_CNT<<8
 348+ 8460 ED 53 B0 5C  	ld		(COORDS), de
 349+ 8464
 350+ 8464              	;Get current file pointer
 351+ 8464 DD 6E 00     	ld		l, (ix)
 352+ 8467 DD 66 01     	ld		h, (ix + 1)
 353+ 846A ED 4B C3 85  	ld		bc, (FileBegin)
 354+ 846E B7           	or		a
 355+ 846F ED 42        	sbc		hl, bc
 356+ 8471
 357+ 8471              	;Divide by one percent length
 358+ 8471 7C           	ld		a, h
 359+ 8472 4D           	ld		c, l
 360+ 8473 ED 5B C9 85  	ld		de, (PROGR_PERC)
 361+ 8477 CD 8C 7C     	call	Div2
 362+ 847A
 363+ 847A              	;Display %
 364+ 847A 11 5A 85     	ld		de, MsgLinePr
 365+ 847D 67           	ld		h, a
 366+ 847E 69           	ld		l, c
 367+ 847F CD 43 7C     	call	Byte2Txt
 368+ 8482
 369+ 8482
 370+ 8482 2A BE 85     	ld		hl, (CurLine)
 371+ 8485 11 66 85     	ld		de, MsgLineNo
 372+ 8488 CD 38 7C     	call	Word2Txt
 373+ 848B
 374+ 848B 11 51 85     	ld		de, MsgLine
 375+ 848E 06 2D        	ld		b, MsgLineLen
 376+ 8490 CD D9 83     	call	PrintStrTxt
 377+ 8493 D1           	pop		de
 378+ 8494 ED 53 B0 5C  	ld		(COORDS), DE
 379+ 8498
 380+ 8498 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 381+ 849B 54           	ld		d, h
 382+ 849C 5D           	ld		e, l
 383+ 849D 13           	inc		de
 384+ 849E 3E 28        	ld		a, (5 << 3) | 0
 385+ 84A0 77           	ld		(hl), a
 386+ 84A1 01 1F 00     	ld		bc, 31
 387+ 84A4 ED B0        	ldir
 388+ 84A6 C9           	ret
 389+ 84A7
 390+ 84A7
 391+ 84A7              ReplaceChars:
 392+ 84A7 E5           	push	hl
 393+ 84A8 C5           	push	bc
 394+ 84A9 21 37 85     		ld		hl, CharReplaceTbl
 395+ 84AC 06 0D        		ld		b, CharReplTblLen
 396+ 84AE              ReplaceSGCLoop:
 397+ 84AE BE           		cp		(hl)
 398+ 84AF 28 09        		jr		z, ReplaceMatch
 399+ 84B1 23           		inc		hl
 400+ 84B2 23           		inc		hl
 401+ 84B3 10 F9        		djnz	ReplaceSGCLoop
 402+ 84B5
 403+ 84B5 3E 3F        		ld		a, '?'
 404+ 84B7 C1           		pop		bc
 405+ 84B8 E1           		pop		hl
 406+ 84B9 C9           	ret
 407+ 84BA
 408+ 84BA              ReplaceMatch:
 409+ 84BA 23           		inc		hl
 410+ 84BB 7E           		ld		a, (hl)
 411+ 84BC C1           	pop		bc
 412+ 84BD E1           	pop		hl
 413+ 84BE C9           	ret
 414+ 84BF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 415+ 84BF
 416+ 84BF              	include	"scroll.asm"
# file opened: scroll.asm
   1++84BF              ;Scrolling routines for UP/DOWN
   2++84BF              ;They use 2 tables of pointers of screen cell rows.
   3++84BF              ;One table has addresses in increasing order, for scroll down,
   4++84BF              ;the other in decreasing order, for scroll up, so the same
   5++84BF              ;scroll routine is used in both cases.
   6++84BF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++84BF
   8++84BF              ; Char Down
   9++84BF              ; Adjusts screen address HL to move eight pixels down on the display.
  10++84BF              ; enter: HL = valid screen address
  11++84BF              ; exit : HL = moves one character down
  12++84BF              ; used : AF, HL
  13++84BF              GetCellDown:
  14++84BF 7D           	ld a,l
  15++84C0 C6 20        	add a,$20
  16++84C2 6F           	ld l,a
  17++84C3 D0           	ret nc
  18++84C4 7C           	ld a,h
  19++84C5 C6 08        	add a,$08
  20++84C7 67           	ld h,a
  21++84C8 C9           	ret
  22++84C9
  23++84C9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++84C9              ;Fills the two tables with pointers.
  25++84C9              ScrollInit:
  26++84C9 21 00 40     	ld		hl, 16384
  27++84CC 06 17        	ld		b, LINE_CNT
  28++84CE              FillScrLinesLoop:
  29++84CE              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++84CE 22 00 5B     	ld		(SCRLinesDown), hl
  31++84D1              	;inc. pointer in destination table (of pointers to lines)
  32++84D1 ED 5B CF 84  	ld		de, (FillScrLinesPtr)
  33++84D5 13           	inc		de
  34++84D6 13           	inc		de
  35++84D7 ED 53 CF 84  	ld		(FillScrLinesPtr), de
  36++84DB CD BF 84     	call	GetCellDown
  37++84DE 10 EE        	djnz	FillScrLinesLoop
  38++84E0
  39++84E0              	;now fill the table in reverse
  40++84E0 ED 73 F4 84  	ld		(FillScrLinesSPStore), sp
  41++84E4 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++84E7 06 17        	ld		b, LINE_CNT
  43++84E9 21 00 5B     	ld		hl, SCRLinesDown
  44++84EC              FillScrLinesRev:
  45++84EC 5E           	ld		e, (hl)
  46++84ED 23           	inc		hl
  47++84EE 56           	ld		d, (hl)
  48++84EF 23           	inc		hl
  49++84F0 D5           	push	de
  50++84F1 10 F9        	djnz	FillScrLinesRev
  51++84F3              FillScrLinesSPStore	EQU	$ + 1
  52++84F3 31 00 00     	ld		sp, 0
  53++84F6 C9           	ret
  54++84F7
  55++84F7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++84F7              ScrollUp:
  57++84F7 21 2E 5B     	ld		hl, SCRLinesUp
  58++84FA 18 03        	jr		Scroll
  59++84FC
  60++84FC              ScrollDown:
  61++84FC 21 00 5B     	ld		hl, SCRLinesDown
  62++84FF
  63++84FF              Scroll:
  64++84FF 22 0D 85     	ld		(ScrollDownPtrDest), hl
  65++8502 23           	inc		hl
  66++8503 23           	inc		hl
  67++8504 22 10 85     	ld		(ScrollDownPtrSrc), hl
  68++8507 0E 16        	ld		c, LINE_CNT - 1
  69++8509
  70++8509              ScrollDownLoop2:
  71++8509 06 04        	ld		b, 4
  72++850B              ScrollDownPtrDest	EQU	$ + 2
  73++850B ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++850F              ScrollDownPtrSrc	EQU	$ + 1
  75++850F 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++8512
  77++8512              ScrollDownLoop:					;copy a single char line
  78++8512 C5           	push	bc
  79++8513 01 20 00     	ld		bc, 32
  80++8516 ED B0        	ldir
  81++8518 2B           	dec		hl
  82++8519 1B           	dec		de
  83++851A 24           	inc		h
  84++851B 14           	inc		d
  85++851C 01 20 00     	ld		bc, 32
  86++851F ED B8        	lddr
  87++8521 23           	inc		hl
  88++8522 13           	inc		de
  89++8523 24           	inc		h
  90++8524 14           	inc		d
  91++8525 C1           	pop		bc
  92++8526 10 EA        	djnz	ScrollDownLoop
  93++8528
  94++8528 0D           	dec		c
  95++8529 C8           	ret		z
  96++852A
  97++852A 2A 10 85     	ld		hl, (ScrollDownPtrSrc)
  98++852D 22 0D 85     	ld		(ScrollDownPtrDest), hl
  99++8530 23           	inc		hl
 100++8531 23           	inc		hl
 101++8532 22 10 85     	ld		(ScrollDownPtrSrc), hl
 102++8535 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 417+ 8537
 418+ 8537              CharReplaceTbl:
 419+ 8537 B3 80        	defb	179, 128
 420+ 8539 B4 81        	defb	180, 129
 421+ 853B BF 82        	defb	191, 130
 422+ 853D C0 83        	defb	192, 131
 423+ 853F C1 84        	defb	193, 132
 424+ 8541 C2 85        	defb	194, 133
 425+ 8543 C3 86        	defb	195, 134
 426+ 8545 C4 87        	defb	196, 135
 427+ 8547 C5 88        	defb	197, 136
 428+ 8549 D9 89        	defb	217, 137
 429+ 854B DA 8A        	defb	218, 138
 430+ 854D DB 8B        	defb	219, 139
 431+ 854F DC 8C        	defb	220, 140
 432+ 8551              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 433+ 8551
 434+ 8551 50 72 6F 67  MsgLine		defb	'Progress:'
 434+ 8555 72 65 73 73
 434+ 8559 3A
 435+ 855A 20 20 20 25  MsgLinePr	defb	'   %; '
 435+ 855E 3B 20
 436+ 8560 4C 69 6E 65  			defb	'Line: '
 436+ 8564 3A 20
 437+ 8566 20 20 20 20  MsgLineNo	defb	'     ; '
 437+ 856A 20 3B 20
 438+ 856D 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 438+ 8571 61 70 20
 439+ 8574 20 4F 6E     MsgLineWrF	defb	' On'
 440+ 8577 20 30 2D 45  			defb	' 0-Exit'
 440+ 857B 78 69 74
 441+ 857E              MsgLineLen	EQU		$ - MsgLine
 442+ 857E
 443+ 857E 20 20 20 20  LineBuf		defb	'                                                                '
 443+ 8582 20 20 20 20
 443+ 8586 20 20 20 20
 443+ 858A 20 20 20 20
 443+ 858E 20 20 20 20
 443+ 8592 20 20 20 20
 443+ 8596 20 20 20 20
 443+ 859A 20 20 20 20
 443+ 859E 20 20 20 20
 443+ 85A2 20 20 20 20
 443+ 85A6 20 20 20 20
 443+ 85AA 20 20 20 20
 443+ 85AE 20 20 20 20
 443+ 85B2 20 20 20 20
 443+ 85B6 20 20 20 20
 443+ 85BA 20 20 20 20
 444+ 85BE 00 00        CurLine		defw	0
 445+ 85C0 00 00        MaxLine		defw	0
 446+ 85C2 01           WrapFlag	defb	1
 447+ 85C3 00 00        FileBegin	defw	0
 448+ 85C5 00 00        FileLen		defw	0
 449+ 85C7 00 00        FileEnd		defw	0
 450+ 85C9 00 00        PROGR_PERC	defw	0
 451+ 85CB
 452+ 85CB              SCRLinesDown	EQU $5b00
 453+ 85CB              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 454+ 85CB              End:
 455+ 85CB
# file closed: txtview.asm
1114  85CB
1115  85CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1116  85CB 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1116  85CF 6F 6D 6D 61
1116  85D3 6E 64 65 72
1116  85D7 20 31 2E B0
1117  85DB 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1117  85DF 67 65 2E 63
1117  85E3 68 69 72 74
1117  85E7 6F 61 63 E1
1118  85EB 40 67 6D 61  VerMsg3			DEFM	'@gmail.com, 202', '3' + $80
1118  85EF 69 6C 2E 63
1118  85F3 6F 6D 2C 20
1118  85F7 32 30 32 B3
1119  85FB 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1119  85FF 20 49 6E 66
1119  8603 6F 20 20 20
1119  8607 20 20 20 A0
1120  860B 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1120  860F 20 49 6E 66
1120  8613 6F 20 20 20
1120  8617 20 20 20 A0
1121  861B 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1121  861F 61 67 65 73
1121  8623 20 20 20 20
1121  8627 20 20 20 A0
1122  862B 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1122  862F 20 32 2D 42
1122  8633 3A 20 33 2D
1122  8637 56 69 65 77
1122  863B 20 34 2D 50
1122  863F 72 6F 70 20
1122  8643 35 2D 43 6F
1122  8647 70 79 20 36
1122  864B 2D 52 65 6E
1122  864F 20 37 2D 41
1122  8653 74 74 72 20
1122  8657 38 2D 44 65
1122  865B 6C 20 39 2D
1122  865F 44 69 73 6B
1122  8663 20 30 2D 45
1122  8667 78 69 F4
1123  866A 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1123  866E 65 20 20 20
1123  8672 3A 20 20 20
1123  8676 20 20 20
1124  8679 C1           MsgDriveLet		DEFM	'A' + $80
1125  867A 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1125  867E 73 20 20 20
1125  8682 3A
1126  8683 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1126  8687 31 32 B8
1127  868A 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1127  868E 20 4B 42 20
1127  8692 3A
1128  8693 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1128  8697 36 33 B6
1129  869A 45 72 72 6F  MsgErr			DEFM	'Error code '
1129  869E 72 20 63 6F
1129  86A2 64 65 20
1130  86A5 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1130  86A9 A0
1131  86AA 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1131  86AE 69 6E 67 20
1131  86B2 50 72 6F 67
1131  86B6 72 61 ED
1132  86B9 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1132  86BD 69 6E 67 20
1132  86C1 53 43 52 45
1132  86C5 45 4E A4
1133  86C8 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1133  86CC 69 6E 67 20
1133  86D0 43 4F 44 45
1133  86D4 20 28 21 A9
1134  86D8 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1134  86DC 20 4C 65 6E
1134  86E0 3A
1135  86E1 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'B' + $80
1135  86E5 30 20 C2
1136  86E8 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1136  86EC 69 62 20 20
1136  86F0 3A
1137  86F1 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1137  86F5 48 49 C4
1138  86F8 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1138  86FC 54 79 70 65
1138  8700 3A
1139  8701 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1139  8705 20 20 20 20
1139  8709 20 A0
1140  870B 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1140  870F 72 61 ED
1141  8712 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1141  8716 73 20 A0
1142  8719 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1142  871D 45 4E A4
1143  8720 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1143  8724 41 72 F2
1144  8727 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1144  872B 41 72 F2
1145  872E 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1145  8732 20 20 A0
1146  8735 4E 2F 41 20  MsgFileTypeUnkn	DEFM	'N/A   ', ' ' + $80
1146  8739 20 20 A0
1147  873C 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1147  8740 74 68 20 20
1147  8744 3A
1148  8745 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1148  8749 35 20 C2
1149  874C 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1149  8750 74 20 20 20
1149  8754 3A
1150  8755 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1150  8759 35 20 A0
1151  875C 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1151  8760 69 6E 67 20
1151  8764 68 65 61 64
1151  8768 65 F2
1152  876A 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1152  876E 20 20 20 20
1152  8772 20 20 20 20
1152  8776 20 20 20 A0
1153  877A 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1153  877E 66 69 6C 65
1153  8782 20 28 79 2F
1153  8786 6E 29 BF
1154  8789 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1154  878D 52 2F 4F 20
1154  8791 28 79 2F 6E
1154  8795 29 BF
1155  8797 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1155  879B 48 49 44 20
1155  879F 28 79 2F 6E
1155  87A3 29 BF
1156  87A5 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1156  87A9 2C 6E 6F 6E
1156  87AD 65 3D 61 62
1156  87B1 6F 72 74 BA
1157  87B5 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1157  87B9 69 6E 67 20
1157  87BD 74 6F 20
1158  87C0 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1159  87C2 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1159  87C6 20 6F 70 74
1159  87CA 69 6F 6E 73
1159  87CE BA
1160  87CF 31 2E 46 6F  MsgMenu1		DEFM	'1.Format disk '
1160  87D3 72 6D 61 74
1160  87D7 20 64 69 73
1160  87DB 6B 20
1161  87DD 41 BA        MsgMenu1Drv		DEFM	'A', ':' | $80
1162  87DF 32 2E 43 6F  MsgMenu2		DEFM	'2.Copy disk '
1162  87E3 70 79 20 64
1162  87E7 69 73 6B 20
1163  87EB 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1164  87ED 33 2E 45 78  MsgMenu3		DEFM	'3.Exit men', 'u' | $80
1164  87F1 69 74 20 6D
1164  87F5 65 6E F5
1165  87F8 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1165  87FC 61 74 74 69
1165  8800 6E 67 20
1166  8803 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1167  8805 30 30 30 20  MsgBlocksLeft	DEFB	'000 blocks lef', 't' | $80
1167  8809 62 6C 6F 63
1167  880D 6B 73 20 6C
1167  8811 65 66 F4
1168  8814
1169  8814              	IFNDEF	_ROM_FNT_
1170  8814 ~            FontTable:
1171  8814 ~            	incbin "cpmfnt.bin"
1172  8814              	ENDIF
1173  8814              EndCode:
1174  8814
1175  8814              ;Unalocated variables
1176  8814              UnallocStart	EQU		$
1177  8814              FileCnt			EQU		$						;File counter, 1B
1178  8814              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1179  8814              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1180  8814              CursorAddr		EQU		SelFile + 1				;2 B
1181  8814              AUCnt			EQU		CursorAddr + 2			;2 B
1182  8814              SelFileCache	EQU		AUCnt + 2				;2 B
1183  8814
1184  8814
1185  8814              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1186  8814              	IFDEF	_ROM_FNT_
1187  8814              FontTable		EQU		FileCache + LST_MAX_FILES*CACHE_SZ
1188  8814              TrackBuf		EQU		FontTable + 872						;size = 16 * 256 = 4096
1189  8814              	ELSE
1190  8814 ~            TrackBuf		EQU		FileCache + LST_MAX_FILES*CACHE_SZ	;size = 16 * 256 = 4096
1191  8814              	ENDIF
1192  8814              DataBuf			EQU		TrackBuf + SPT*SECT_SZ
1193  8814
1194  8814              CopyFileFCBSrc	EQU	DataBuf
1195  8814              CopyFileFCBDst	EQU	DataBuf + 2
1196  8814              CopyFileResRead	EQU DataBuf + 4
1197  8814              CopyFileResWrite EQU DataBuf + 5
1198  8814              CopyFileDMAAddr	EQU	DataBuf + 6
1199  8814              CopyFileDMA		EQU	DataBuf + 8
1200  8814
1201  8814              TheEnd			EQU		DataBuf
1202  8814              FileIdx			EQU		DataBuf
1203  8814              FileData		EQU		DataBuf + 2048
1204  8814
1205  8814              UsedBlockListCnt	EQU	DataBuf
1206  8814              UsedBlockListBlk	EQU	DataBuf + 2
1207  8814              UsedBlockListSz		EQU 320 * 2
1208  8814              ;Copy buffer size
1209  8814              CopyDiskBuf			EQU DataBuf + 2 + UsedBlockListSz
1210  8814
1211  8814              ;We can use up to about 30KB free space if we load at address 24000.
1212  8814              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1213  8814              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1214  8814              MAX_RAM_FREE	EQU		$FF00 - DataBuf - 1024
1215  8814              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1216  8814              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1217  8814
1218  8814              	DISPLAY "DataBuf: ",/D,DataBuf
1219  8814              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
1220  8814              	DISPLAY "MAX_AU_RAM: ",/D,MAX_AU_RAM
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x7C89   NoSub
0x7C82   DivLoop
0x567F   MAX_RAM_FREE
0x0280   UsedBlockListSz
0xA481 X TheEnd
0x8814 X UnallocStart
0x8814 X EndCode
0x85CB X End
0x85C0 X MaxLine
0x856D X MsgLineWrap
0x8512   ScrollDownLoop
0x8509   ScrollDownLoop2
0x8510   ScrollDownPtrSrc
0x850D   ScrollDownPtrDest
0x84FF   Scroll
0x84EC   FillScrLinesRev
0x5B2E   SCRLinesUp
0x84F4   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x84CF   FillScrLinesPtr
0x84CE   FillScrLinesLoop
0x84BF   GetCellDown
0x84BA   ReplaceMatch
0x84AE   ReplaceSGCLoop
0x000D   CharReplTblLen
0x8537   CharReplaceTbl
0x002D   MsgLineLen
0x8551   MsgLine
0x8566   MsgLineNo
0x855A   MsgLinePr
0x8451   GetLineFillLoop
0x842E   GetLineFill
0x84A7   ReplaceChars
0x841A   Valid
0x8417   NotValid
0x841E   GetLineSkip0D
0x840D   GetLineNext
0x8427   GetLineSkip0A
0x83F8   GetLineLoop
0x83D9   PrintStrTxt
0x857E   LineBuf
0x84FC   ScrollDown
0x84F7   ScrollUp
0x83AA   CheckBegin
0x8574   MsgLineWrF
0x833B   NoWrap
0x85C2   WrapFlag
0x834A   Up
0x8375   Down
0x82F5   GetKey
0x830C   PrintLoop2
0x8304   EOF
0x83BA   CheckEnd
0x83C5   PrintLine
0x83F3   GetLine
0xA481   FileIdx
0x8458   PrintMsg
0x85C9   PROGR_PERC
0x85BE   CurLine
0x84C9   ScrollInit
0x85C5   FileLen
0x85C7   FileEnd
0x85C3   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x8264   ReadStrPrint
0x8254   ReadStrChar
0x8237   ReadStringLoop
0x822B   Store
0x822A   NoTurn
0x821F   PrintCharLine
0x820B X PrintChar3
0x81B6   DrawCursorLoop
0x8196   DrawVLinesLoop
0x81A9   PrintChar2
0x8174   DrawUpLine
0x8176   ChrParam
0x8167 X DrawHLine
0x8156   DrawLineLoop
0x8163   LineDir
0x8153   StoreDir
0x8151   VertDir
0x8148   DrawLine
0x8144   StrClr
0x80F7   GoodChar
0x8273   CurrScrAddr
0x9119   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0xA486   CopyFileResWrite
0x807B   FileCopyWriteLoop
0x806B   FileCopyWrite
0xA485   CopyFileResRead
0x804D   FileCopyReadLoop
0xA489   CopyFileDMA
0xA487   CopyFileDMAAddr
0x0056   MAX_SECT_RAM
0x803F   FileCopyLoop
0xA483   CopyFileFCBDst
0x8099   CopyFileEnd
0xA481   CopyFileFCBSrc
0x7FE7 X FileAttribSet
0x7FB6   BDOSSetDMA
0x7FB6 X BDOSFindNext
0x7FB6 X BDOSFindFirst
0x7FA8   WriteFileBlock
0x7FA4   ReadFileBlock
0x7FA0   CloseFile
0x7F9C   OpenFile
0x7F98   CreateFile
0x7F8E   DestroyChannel
0x7F78   CreateChannel
0x7F78 X BDOSGetCurrentDisk
0x7F78 X BDOSGetDiskRO
0x7F78 X BDOSMakeDiskRO
0x7FAC   BDOS
0x7F67 X RWTSResTmp
0x7F66 X RWTSResVolNo
0x7F62 X RWTSPrmTbl
0x7F60 X RWTSExtBuf
0x7F5D X RWTSSector
0x7F5B X RWTSVolNo
0x7F59 X RWTSBlockType
0x7F50   CopyMsg
0x7F44   SearchMsgEnd
0x7F4D   SaveMsg
0x7F3B   IF1Paged
0x7F06   IF1Call
0x7F02   ReadHeaderEnd
0x7ECE   CacheNotFinished
0x7F6C   BDOSInit
0x7F6F   BDOSSelectDisk
0x7E6B   FileReadLoop
0x7E5F X FileLoadHeader
0x7E71   FileLoadNoHeader
0x7E7F   FileFree
0x7E3B   MisMatch
0x7E33   Compare
0x7E31   StrCmp
0x7DFF   CopyDiskLoopWriteLoop
0x7DD9   CopyDiskLoopReadLoop
0xA703   CopyDiskBuf
0x7DD2   CopyDiskLoopRead
0x000A   MAX_AU_RAM
0x8805   MsgBlocksLeft
0x7DAF   CopyDiskLoop
0xA483   UsedBlockListBlk
0x7E97   WriteDiskSectors
0x7DA4 X WriteFSBlockLoop
0x7D9B   WriteFSBlock
0x7E84   ReadDiskSectors
0x7D97 X ReadFSBlockLoop
0x7D8E   ReadFSBlock
0x7D80   ReadUsedBlocksSkip
0x7D63   ReadUsedBlocksLoop2
0x7D83   ReadUsedBlocksSkip2
0x7D53   ReadUsedBlocksLoop
0xA481   UsedBlockListCnt
0x7D36   ReadUsedBlocksList
0x7D2F   CheckAUEnd
0x7D1B   CheckAU
0x7D04   FirstAU
0x7CFE   Track0
0x7CE9   AU2TS
0x7F65   RWTSRes
0x7CCD   WriteOneDiskSector
0x7F5C   RWTSTrack
0x7F5E   RWTSDMA
0x7CC2   ReadOneDiskSector
0x7F59   RWTSParams
0x7F64   RWTSCmd
0x7CB6   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022 X FCB_R1
0x0021 X FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x001B X EOF_MARKER
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x7CB0   NoAdd
0x7CAA   MulLoop
0x7C91   Div2Loop
0x7C8C   Div2
0x7C7F   Div
0x7C76   DivNrLoop
0x7C74   DigitLoop
0x7C65   Byte2Txt_
0x7C4E   StrippLeading0
0x7C59   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x7C35   DontInc
0x7C29   ReadAllHeadersEnd
0x7C14   AKey
0x80B7   KbdHit
0x7BF9   NextFile
0x873C   MsgFileLen
0x86F8   MsgFileType
0x874C   MsgFileStart
0x7BB8   PrintStartStr
0x8755   MsgFileStartN
0x8735   MsgFileTypeUnkn
0x7BAA   PrintStart
0x0007   HDR_LINE
0x7B85   PrintByteStart
0x7B7D   PrintProgStart
0x8745   MsgFileLenN
0x7B96   NoHeader
0x872E   MsgFileTypeText
0x8712   MsgFileTypeByte
0x8719   MsgFileTypeSCR
0x7B47   NotScr
0x7B52   CheckText
0x8720   MsgFileTypeChrA
0x7B2A   CheckByte
0x0002   CHAR_TYPE
0x8727   MsgFileTypeNoA
0x7B1B   CheckChrArr
0x0001   NUMB_TYPE
0x7B5D   PrepFileLen
0x7BD6   MoveMsg
0x8701   MsgFileTypeN
0x870B   MsgFileTypePrg
0x7B0C   CheckNoArr
0x000B   CACHE_FIRST_AU
0x7B8D   HeadNotRead
0x86E8   MsgFileAttr
0x7ADD   AttrEnd
0x7AD1   NotSYS
0x7ABD   CheckSys
0x7AAB   NotRO
0x86F1   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x7B9F   PrintStartNotRead
0x86D8   MsgFileSzDsk
0x7A79   MultKb
0x86E1   MsgFileSzDskN
0x82D1   PrintLoop
0x8277   InitViewer
0xAC81   FileData
0x7F0C   LoadProgram
0x86AA   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x86B9   MsgLoadingSCR
0x0003   HDR_ADDR
0x7E7F   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7E3E   IF1FileLoad
0x86C8   MsgLoadingCODE
0x79F2 X HandleFileCODE
0x7A1B   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x7A49   HandleFileText
0x0003   BYTE_TYPE
0x7A39   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x79BC   FindExtEnd
0x7EC3   FindCache
0x79CB   GetFileNamesEnd
0x0009   HDR_SZ
0x7997   FindExt
0x000C   EXT_IDX
0x7D07   CheckExtAlloc
0x79BE   NextExt
0x0000   EXT_DEL_FLAG
0x793E   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x7925   DisplayFilenamesLoop
0x791E X DisplayFilenames
0x7914   LineOK
0x5CB1   LINE
0x5CB0   COL
0x81F3   PrintChar
0x5C81   CODE
0x78EE   DispLoop
0x78EC   DisplayFilename
0x81BB   MoveCursor
0x7DA8   CopyDisk
0x7CD8   FormatDisk
0x87F8   MsgFormat
0x78D2   CheckExtra2
0x78DB   ExtraMenuExit
0x87ED   MsgMenu3
0x87DF   MsgMenu2
0x87CF   MsgMenu1
0x7863   CheckKeyExtraMenu
0x87EB   MsgMenu2Drv
0x8803   MsgFormatDrv
0x87DD   MsgMenu1Drv
0x87C2   MsgMenu0
0x78DE   CheckKeyExit
0x7FC6   ChangeFileAttrib
0x7836   AttrChange
0x8797   MsgSetSYS
0x781E   CheckSYS
0x8789   MsgSetRO
0x7845   CheckKeyExtra
0x7FBA   DeleteFile
0x77F7   DoFileDelete
0x877A   MsgDelete
0x7804   CheckKeyAttrib
0x7FF0   RenameFile
0x77C5   RenameCanceled
0x8231   ReadString
0x000B   NAMELEN
0x87A5   MsgNewFileName
0x77D3   CheckKeyDel
0x7A4A   ViewFile
0x7784   CheckKeyRename
0x0001   DRIVE_B_CPM
0x777A   CheckKeyView
0x783F   SelectDrive
0x7771   CheckKeyDriveB
0x7BDC   ReadAllHeaders
0x7768   CheckKeyDriveA
0x775B   CopyFileOK
0x8013   CopyFile
0x87B5   MsgCopyFile
0x87C0   MsgCopyFileDrv
0x775E   CheckKeyFileInfo
0x876A   MsgClear
0x7ED4   ReadFileHeader
0x875C   MsgReadingExt
0x7721   CheckKeyCopy
0x79CC   HandleFile
0x76FD   CheckKeyInfo
0x000D   KEY_ENTER
0x76F2   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x76E1   CheckLeft
0x0009   KEY_RIGHT
0x76CB   CheckRight
0x000B   KEY_UP
0x78E6   MoveIt
0x76BA   CheckUp
0x000A   KEY_DOWN
0x7A67   DisplayFileInfo
0x881B   SelFileCache
0x7C9F   Mul
0x768B   CalcFileCache
0x868A   MsgFreeSpace
0x7C38   Word2Txt
0x8693   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x867A   MsgFilesCnt
0x8683   MsgFilesCntNo
0x866A   MsgDrive
0x8679   MsgDriveLet
0x7F25   SetFastKeys
0x81B0   DrawCursor
0x0028   SCR_SEL_CLR
0x8819   AUCnt
0x5CB0   LineCol
0x861B   MsgMessages
0x0007   LST_FILE_INFO
0x860B   MsgFileInf
0x0003   LST_DISK_INFO
0x85FB   MsgDskInf
0x85EB   VerMsg3
0x85DB   VerMsg2
0x80F0   PrintStr
0x85CB   VerMsg1
0x862B   BtnBar
0x0028   SCR_LBL_CLR
0x8191   DrawVLines
0x0084   CHR_DC
0x80D0   ClrScr
0x8817   CursorAddr
0x8275   CurrScrAttrAddr
0x0000   LST_FIRST_LINE
0x0020   SCR_BYTES_PER_LINE
0x8815   NameCol
0x0010   LST_FIRST_COL
0x8814   FileCnt
0x8816   SelFile
0xA481   DataBuf
0x7F30   GetErrMsg
0x5C3A   ERRNR
0x758A   HCRunEnd
0x769C   ReadKeyLoop
0x7642   DisplayDiskInfo
0x7935   GetFileNames
0x75C2   InitUI
0x7F5A   RWTSDrive
0x0000   DRIVE_A_CPM
0x80B4   ReadChar
0x8118   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x869A   MsgErr
0x7C43   Byte2Txt
0x86A5   MsgErrCode
0x757E   HCRunMain
0x7EAA   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0x881D   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x9481   TrackBuf
0x7542   HCRunInitDisk
0x7590   ErrorHandler
0x5C3D   ERRSP
0x7CB3   IF1Init
0x80BA   InitFonts
0x7530   Start
