# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 26500
  12  6784
  13  6784              Start:
  14  6784              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  6784 CD 07 78     		call InitFonts
  16  6787              	ENDIF
  17  6787 CD D2 6F     	call IF1Init
  18  678A
  19  678A              	;install error handler
  20  678A 2A 3D 5C     	ld		hl, (ERRSP)
  21  678D E5           	push	hl
  22  678E 21 E9 67     	ld		hl, ErrorHandler
  23  6791 E5           	push	hl
  24  6792 ED 73 3D 5C  	ld		(ERRSP), sp
  25  6796
  26  6796              HCRunInitDisk:
  27  6796              	;Set track buffer to del marker
  28  6796 21 FB 8E     	ld		hl, TrackBuf
  29  6799 54           	ld		d, h
  30  679A 5D           	ld		e, l
  31  679B 13           	inc		de
  32  679C 01 00 10     	ld		bc, SPT*SECT_SZ
  33  679F 36 E5        	ld		(hl), DEL_MARKER
  34  67A1 ED B0        	ldir
  35  67A3
  36  67A3              	;Invalidate file cache
  37  67A3 21 DD 80     	ld		hl, FileCache
  38  67A6 54           	ld		d, h
  39  67A7 5D           	ld		e, l
  40  67A8 13           	inc		de
  41  67A9 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  67AC 36 00        	ld		(hl), 0
  43  67AE ED B0        	ldir
  44  67B0
  45  67B0              	;main program
  46  67B0 CD BB 72     	call 	ReadCatalogTrack
  47  67B3 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  67B4 28 1E        	jr		z, HCRunCacheFiles
  49  67B6
  50  67B6 6F           	ld		l, a
  51  67B7 26 00        	ld		h, 0
  52  67B9 11 C8 7E     	ld		de, MsgErrCode
  53  67BC CD 62 6F     	call	Byte2Txt
  54  67BF 21 BD 7E     	ld		hl, MsgErr
  55  67C2 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  56  67C5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  67C7 CD 65 78     	call	PrintStrClr
  58  67CA CD 01 78     	call	ReadChar
  59  67CD 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  67CF 32 97 73     	ld		(RWTSDrive), a
  61  67D2 18 C2        	jr		HCRunInitDisk
  62  67D4
  63  67D4              HCRunCacheFiles:
  64  67D4 CD 4C 6C     	call 	GetFileNames
  65  67D7
  66  67D7              HCRunMain:
  67  67D7 CD 1B 68     	call 	InitUI
  68  67DA CD 2C 6C     	call	DisplayFilenames
  69  67DD CD 99 68     	call	DisplayDiskInfo
  70  67E0 C3 0C 69     	jp		ReadKeyLoop
  71  67E3
  72  67E3              HCRunEnd:
  73  67E3              	;restore error handler
  74  67E3 E1           	pop		hl
  75  67E4 E1           	pop		hl
  76  67E5 22 3D 5C     	ld		(ERRSP), hl
  77  67E8
  78  67E8 C9           	ret
  79  67E9
  80  67E9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  81  67E9
  82  67E9              ErrorHandler:
  83  67E9 E1           	pop		hl
  84  67EA 22 3D 5C     	ld		(ERRSP), hl
  85  67ED
  86  67ED 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  87  67F0 6F           	ld		l, a
  88  67F1 26 00        	ld		h, 0
  89  67F3 11 C8 7E     	ld		de, MsgErrCode
  90  67F6 CD 62 6F     	call	Byte2Txt
  91  67F9 21 BD 7E     	ld		hl, MsgErr
  92  67FC 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  93  67FF 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  94  6801 CD 65 78     	call	PrintStrClr
  95  6804
  96  6804 3A 3A 5C     	ld		a, (ERRNR)
  97  6807 CD 70 73     	call	GetErrMsg
  98  680A
  99  680A 21 FB 8E     	ld		hl, DataBuf
 100  680D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 101  6810 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 102  6812 CD 65 78     	call	PrintStrClr
 103  6815
 104  6815 CD 01 78     	call	ReadChar
 105  6818 C3 84 67     	jp	Start
 106  681B
 107  681B
 108  681B
 109  681B
 110  681B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 111  681B
 112  681B              InitUI:
 113  681B AF           	xor		a
 114  681C 32 B3 80     	ld		(SelFile), A
 115  681F 3E 11        	ld		a, LST_FIRST_COL + 1
 116  6821 32 B2 80     	ld		(NameCol), A
 117  6824 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 118  6827 ED 53 B0 5C  	ld		(LineCol), de
 119  682B
 120  682B CD 1D 78     	call	ClrScr
 121  682E
 122  682E 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 123  6831 ED 4B FE 79  	ld		bc, (CurrScrAttrAddr)
 124  6835 09           	add		hl, bc
 125  6836 22 B4 80     	ld		(CursorAddr), hl
 126  6839
 127  6839 CD 0E 79     	call	DrawVLines
 128  683C
 129  683C CD B4 78     	call	DrawHLines
 130  683F
 131  683F 21 FE 7D     	ld		hl, VerMsg1
 132  6842 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 133  6845 3A 0D 7E     	ld		a, (VerMsg1 + 15)
 134  6848 F6 80        	or		$80
 135  684A 32 0D 7E     	ld		(VerMsg1 + 15), a
 136  684D CD 3D 78     	call	PrintStr
 137  6850 21 0E 7E     	ld		hl, VerMsg2
 138  6853 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 139  6856 CD 3D 78     	call	PrintStr
 140  6859
 141  6859 3E 60        	ld		a, SCR_LBL_CLR
 142  685B 11 00 17     	ld		de, 23 << 8
 143  685E 21 5E 7E     	ld		hl, BtnBar
 144  6861 CD 65 78     	call	PrintStrClr
 145  6864
 146  6864 3E 60        	ld		a, SCR_LBL_CLR
 147  6866 21 1E 7E     	ld		hl, MsgSysInf
 148  6869 11 00 01     	ld		de, LST_PROG_INFO << 8
 149  686C CD 65 78     	call	PrintStrClr
 150  686F
 151  686F 3E 60        	ld		a, SCR_LBL_CLR
 152  6871 21 2E 7E     	ld		hl, MsgDskInf
 153  6874 11 00 04     	ld		de, LST_DISK_INFO << 8
 154  6877 CD 65 78     	call	PrintStrClr
 155  687A
 156  687A 3E 60        	ld		a, SCR_LBL_CLR
 157  687C 21 3E 7E     	ld		hl, MsgFileInf
 158  687F 11 00 07     	ld		de, LST_FILE_INFO << 8
 159  6882 CD 65 78     	call	PrintStrClr
 160  6885
 161  6885 3E 60        	ld		a, SCR_LBL_CLR
 162  6887 21 4E 7E     	ld		hl, MsgMessages
 163  688A 11 00 0D     	ld		de, LST_LINE_MSG << 8
 164  688D CD 65 78     	call	PrintStrClr
 165  6890
 166  6890 3E 60        	ld		a, SCR_SEL_CLR
 167  6892 CD 26 79     	call	DrawCursor
 168  6895
 169  6895 CD 65 73     	call	SetFastKeys
 170  6898
 171  6898 C9           	ret
 172  6899
 173  6899
 174  6899              DisplayDiskInfo:
 175  6899 ED 5B B6 80  	ld		de, (AUCnt)
 176  689D 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 177  68A0 B7           	or		a
 178  68A1 ED 52        	sbc		hl, de
 179  68A3 CB 15        	rl		l								;*2, 2K/AU
 180  68A5 CB 14        	rl		h
 181  68A7
 182  68A7 11 A8 7E     	ld		de, MsgDriveLet
 183  68AA CD 57 6F     	call	Word2Txt
 184  68AD 3A AC 7E     	ld		a, (MsgDriveLet+4)
 185  68B0 F6 80        	or		$80
 186  68B2 32 AC 7E     	ld		(MsgDriveLet+4), a
 187  68B5
 188  68B5 3A 97 73     	ld		a, (RWTSDrive)
 189  68B8 C6 41        	add		'A'
 190  68BA 32 A8 7E     	ld		(MsgDriveLet), a
 191  68BD 3E 2F        	ld		a, '/'
 192  68BF 32 A9 7E     	ld		(MsgDriveLet+1), a
 193  68C2
 194  68C2 21 9D 7E     	ld		hl, MsgDrive
 195  68C5 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 196  68C8 CD 3D 78     	call	PrintStr
 197  68CB
 198  68CB 2A B6 80     	ld		hl, (AUCnt)
 199  68CE CB 15        	rl		l								;*2, 2K/AU
 200  68D0 CB 14        	rl		h
 201  68D2 11 B8 7E     	ld		de, MsgFilesCntNo+2
 202  68D5 CD 57 6F     	call	Word2Txt
 203  68D8 3A BC 7E     	ld		a, (MsgFilesCntNo+6)
 204  68DB F6 80        	or		$80
 205  68DD 32 BC 7E     	ld		(MsgFilesCntNo+6), a
 206  68E0 3E 2F        	ld		a, '/'
 207  68E2 32 B9 7E     	ld		(MsgFilesCntNo+3), a
 208  68E5
 209  68E5 3A B1 80     	ld		a, (FileCnt)
 210  68E8 6F           	ld		l, a
 211  68E9 26 00        	ld		h, 0
 212  68EB 11 B6 7E     	ld		de, MsgFilesCntNo
 213  68EE CD 62 6F     	call	Byte2Txt
 214  68F1 21 AD 7E     	ld		hl, MsgFilesCnt
 215  68F4 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 216  68F7 CD 3D 78     	call	PrintStr
 217  68FA
 218  68FA C9           	ret
 219  68FB
 220  68FB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 221  68FB
 222  68FB              CalcFileCache:
 223  68FB 3A B3 80     	ld		a, (SelFile)
 224  68FE 11 19 00     	ld		de, CACHE_SZ
 225  6901 CD BE 6F     	call	Mul
 226  6904 01 DD 80     	ld		bc, FileCache
 227  6907 09           	add		hl, bc					;HL = file AU cnt
 228  6908 22 B8 80     	ld		(SelFileCache), hl
 229  690B C9           	ret
 230  690C
 231  690C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232  690C
 233  690C
 234  690C              ReadKeyLoop:
 235  690C CD FB 68     	call	CalcFileCache
 236  690F CD 8F 6D     	call	DisplayFileInfo
 237  6912
 238  6912 CD 01 78     	call	ReadChar
 239  6915
 240  6915 FE 0A        	cp		KEY_DOWN
 241  6917 28 04        	jr		z,  DoKeyDown
 242  6919 FE 61        	cp 		'a'
 243  691B 20 11        	jr		nz, CheckUp
 244  691D
 245  691D              DoKeyDown:
 246  691D 3A B1 80     	ld		a, (FileCnt)
 247  6920 47           	ld		b, a
 248  6921 3A B3 80     	ld		a, (SelFile)
 249  6924 3C           	inc		a
 250  6925 B8           	cp		b
 251  6926 30 E4        	jr		nc, ReadKeyLoop
 252  6928 32 B3 80     	ld		(SelFile), a
 253  692B C3 F4 6B     	jp		MoveIt
 254  692E
 255  692E              CheckUp:
 256  692E FE 0B        	cp		KEY_UP
 257  6930 28 04        	jr		z, DoKeyUp
 258  6932 FE 71        	cp 		'q'
 259  6934 20 0D        	jr		nz, CheckRight
 260  6936
 261  6936              DoKeyUp:
 262  6936 3A B3 80     	ld		a, (SelFile)
 263  6939 B7           	or		a
 264  693A 28 D0        	jr		z, ReadKeyLoop
 265  693C
 266  693C 3D           	dec		a
 267  693D 32 B3 80     	ld		(SelFile), a
 268  6940 C3 F4 6B     	jp		MoveIt
 269  6943
 270  6943              CheckRight:
 271  6943 FE 09        	cp		KEY_RIGHT
 272  6945 28 04        	jr		z, DoKeyRight
 273  6947 FE 70        	cp 		'p'
 274  6949 20 12        	jr		nz, CheckLeft
 275  694B
 276  694B              DoKeyRight:
 277  694B 3A B1 80     	ld		a, (FileCnt)
 278  694E 47           	ld		b, a
 279  694F 3A B3 80     	ld		a, (SelFile)
 280  6952 C6 15        	add		LST_LINES_CNT
 281  6954 B8           	cp		b
 282  6955 30 B5        	jr		nc, ReadKeyLoop
 283  6957
 284  6957 32 B3 80     	ld		(SelFile), a
 285  695A C3 F4 6B     	jp		MoveIt
 286  695D
 287  695D              CheckLeft:
 288  695D FE 08        	cp		KEY_LEFT
 289  695F 28 04        	jr		z, DoKeyLeft
 290  6961 FE 6F        	cp		'o'
 291  6963 20 0D        	jr		nz, CheckEnter
 292  6965
 293  6965              DoKeyLeft:
 294  6965 3A B3 80     	ld		a, (SelFile)
 295  6968 D6 15        	sub		LST_LINES_CNT
 296  696A 38 A0        	jr		c, ReadKeyLoop
 297  696C
 298  696C 32 B3 80     	ld		(SelFile), a
 299  696F C3 F4 6B     	jp		MoveIt
 300  6972
 301  6972              CheckEnter:
 302  6972 FE 0D        	cp		KEY_ENTER
 303  6974 28 05        	jr		z, DoKeyEnter
 304  6976 FE 6D        	cp		'm'
 305  6978 C2 81 69     	jp		nz, CheckKeyInfo
 306  697B
 307  697B              DoKeyEnter:
 308  697B CD E5 6C     	call	HandleFile
 309  697E C3 D7 67     	jp		HCRunMain
 310  6981
 311  6981              CheckKeyInfo:
 312  6981 FE 34        	cp		'4'
 313  6983 20 21        	jr		nz, CheckKeyCopy
 314  6985
 315  6985 3A B1 80     	ld		a, (FileCnt)
 316  6988 B7           	or		a
 317  6989 CA 0C 69     	jp		z, ReadKeyLoop
 318  698C
 319  698C DD 2A B8 80  	ld		ix, (SelFileCache)
 320  6990 21 7E 7F     	ld		hl, MsgReadingExt
 321  6993 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 322  6996 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 323  6998 CD 65 78     	call	PrintStrClr
 324  699B CD E5 72     	call	ReadFileHeader
 325  699E 06 01        	ld		b, 1
 326  69A0 CD E9 79     	call	ClearNMsgLines
 327  69A3 C3 0C 69     	jp		ReadKeyLoop
 328  69A6
 329  69A6              CheckKeyCopy:
 330  69A6 FE 35        	cp		'5'
 331  69A8 C2 EF 69     	jp		nz, CheckKeyFileInfo
 332  69AB
 333  69AB 3A B1 80     	ld		a, (FileCnt)
 334  69AE B7           	or		a
 335  69AF CA 0C 69     	jp		z, ReadKeyLoop
 336  69B2
 337  69B2 2A B8 80     	ld		hl, (SelFileCache)
 338  69B5 CD E9 74     	call	CopyFile
 339  69B8 3A BD 80     	ld		a, (CopyFileRes)
 340  69BB B7           	or		a
 341  69BC 28 1A        	jr		z, CopyFileOK
 342  69BE
 343  69BE 6F           	ld		l, a
 344  69BF 26 00        	ld		h, 0
 345  69C1 11 C8 7E     	ld		de, MsgErrCode
 346  69C4 CD 62 6F     	call	Byte2Txt
 347  69C7 21 BD 7E     	ld		hl, MsgErr
 348  69CA 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 349  69CD 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 350  69CF CD 65 78     	call	PrintStrClr
 351  69D2 CD 01 78     	call	ReadChar
 352  69D5 C3 0C 69     	jp		ReadKeyLoop
 353  69D8
 354  69D8              CopyFileOK:
 355  69D8 06 02        	ld		b, 2
 356  69DA CD E9 79     	call	ClearNMsgLines
 357  69DD              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 358  69DD 3A BA 80     	ld		a, (CopySelOption)
 359  69E0 FE 33        	cp		'3'
 360  69E2 CA 0C 69     	jp		z, ReadKeyLoop
 361  69E5 3A D1 80     	ld		a, (CopyFileDstDrv)
 362  69E8 3D           	dec		a
 363  69E9 32 97 73     	ld		(RWTSDrive), a
 364  69EC C3 96 67     	jp		HCRunInitDisk
 365  69EF
 366  69EF              CheckKeyFileInfo:
 367  69EF FE 20        	cp		' '
 368  69F1 20 0D        	jr		nz, CheckKeyDriveA
 369  69F3
 370  69F3 3A B1 80     	ld		a, (FileCnt)
 371  69F6 B7           	or		a
 372  69F7 CA 0C 69     	jp		z, ReadKeyLoop
 373  69FA
 374  69FA CD 01 6F     	call	ReadAllHeaders
 375  69FD C3 0C 69     	jp		ReadKeyLoop
 376  6A00
 377  6A00              CheckKeyDriveA:
 378  6A00 FE 31        	cp		'1'
 379  6A02 20 05        	jr		nz, CheckKeyDriveB
 380  6A04 3E 00        	ld		a, DRIVE_A_CPM
 381  6A06 C3 07 6B     	jp		SelectDrive
 382  6A09
 383  6A09              CheckKeyDriveB:
 384  6A09 FE 32        	cp		'2'
 385  6A0B 20 05        	jr		nz, CheckKeyView
 386  6A0D 3E 01        	ld		a, DRIVE_B_CPM
 387  6A0F C3 07 6B     	jp		SelectDrive
 388  6A12
 389  6A12              CheckKeyView:
 390  6A12 FE 33        	cp		'3'
 391  6A14 20 0D        	jr		nz, CheckKeyRename
 392  6A16
 393  6A16 3A B1 80     	ld		a, (FileCnt)
 394  6A19 B7           	or		a
 395  6A1A CA 0C 69     	jp		z, ReadKeyLoop
 396  6A1D
 397  6A1D CD 60 6D     	call	ViewFile
 398  6A20 C3 D7 67     	jp		HCRunMain
 399  6A23
 400  6A23              CheckKeyRename:
 401  6A23 FE 36        	cp		'6'
 402  6A25 20 6C        	jr		nz, CheckKeyDel
 403  6A27
 404  6A27 3A B1 80     	ld		a, (FileCnt)
 405  6A2A B7           	or		a
 406  6A2B CA 0C 69     	jp		z, ReadKeyLoop
 407  6A2E
 408  6A2E 21 C1 7F     	ld		hl, MsgNewFileName
 409  6A31 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 410  6A34 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 411  6A36 CD 65 78     	call	PrintStrClr
 412  6A39
 413  6A39 21 8C 7F     	ld		hl, MsgClear
 414  6A3C 11 FB 8E     	ld		de, FileData
 415  6A3F 01 0B 00     	ld		bc, NAMELEN
 416  6A42 ED B0        	ldir
 417  6A44 3E A0        	ld		a, $80 | ' '
 418  6A46 12           	ld		(de), a
 419  6A47 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 420  6A4A 21 FB 8E     	ld		hl, FileData
 421  6A4D CD 3D 78     	call	PrintStr
 422  6A50
 423  6A50 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 424  6A53 01 0B 00     	ld		bc, NAMELEN
 425  6A56 CD A7 79     	call	ReadString
 426  6A59
 427  6A59 11 FB 8E     	ld		de, FileData
 428  6A5C 1A           	ld		a, (de)
 429  6A5D FE 20        	cp		' '					;If starting with space, input was canceled.
 430  6A5F CA 8B 6A     	jp		z, RenameCanceled
 431  6A62
 432  6A62              	;Check if new name doesn't exist already. Cancel if so.
 433  6A62 21 FB 8E     	ld		hl, FileData
 434  6A65 3A 97 73     	ld 		a, (RWTSDrive)
 435  6A68 3C           	inc		a
 436  6A69 CD 4F 74     	call	DoesFileExist
 437  6A6C 3C           	inc		a
 438  6A6D 28 10        	jr		z, RenameFileNotExist
 439  6A6F
 440  6A6F 21 66 80     	ld		hl, MsgFileExists
 441  6A72 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 442  6A75 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 443  6A77 CD 65 78     	call	PrintStrClr
 444  6A7A CD 01 78     	call	ReadChar
 445  6A7D 18 0C        	jr		RenameCanceled
 446  6A7F
 447  6A7F              RenameFileNotExist:
 448  6A7F 11 FB 8E     	ld		de, FileData
 449  6A82 2A B8 80     	ld		hl, (SelFileCache)
 450  6A85 CD 92 74     	call	RenameFile
 451  6A88 C3 96 67     	jp		HCRunInitDisk
 452  6A8B
 453  6A8B              RenameCanceled:
 454  6A8B 06 02        	ld		b, 2
 455  6A8D CD E9 79     	call	ClearNMsgLines
 456  6A90 C3 0C 69     	jp		ReadKeyLoop
 457  6A93
 458  6A93              CheckKeyDel:
 459  6A93 FE 38        	cp		'8'
 460  6A95 20 2E        	jr		nz, CheckKeyAttrib
 461  6A97
 462  6A97 3A B1 80     	ld		a, (FileCnt)
 463  6A9A B7           	or		a
 464  6A9B CA 0C 69     	jp		z, ReadKeyLoop
 465  6A9E
 466  6A9E 21 9C 7F     	ld		hl, MsgDelete
 467  6AA1 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 468  6AA4 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 469  6AA6 CD 65 78     	call	PrintStrClr
 470  6AA9 CD 01 78     	call	ReadChar
 471  6AAC FE 79        	cp		'y'
 472  6AAE 28 08        	jr		z, DoFileDelete
 473  6AB0 06 01        	ld		b, 1
 474  6AB2 CD E9 79     	call	ClearNMsgLines
 475  6AB5 C3 0C 69     	jp		ReadKeyLoop
 476  6AB8              DoFileDelete:
 477  6AB8 2A B8 80     	ld		hl, (SelFileCache)
 478  6ABB 3A 97 73     	ld 		a, (RWTSDrive)
 479  6ABE 3C           	inc		a					;Convert to BASIC drive number: 1,2
 480  6ABF CD 43 74     	call	DeleteFile
 481  6AC2 C3 96 67     	jp		HCRunInitDisk
 482  6AC5
 483  6AC5              CheckKeyAttrib:
 484  6AC5 FE 37        	cp		'7'
 485  6AC7 20 44        	jr		nz, CheckKeyDiskMenu
 486  6AC9
 487  6AC9 3A B1 80     	ld		a, (FileCnt)
 488  6ACC B7           	or		a
 489  6ACD CA 0C 69     	jp		z, ReadKeyLoop
 490  6AD0
 491  6AD0 21 A9 7F     	ld		hl, MsgSetRO
 492  6AD3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 493  6AD6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 494  6AD8 CD 65 78     	call	PrintStrClr
 495  6ADB CD 01 78     	call	ReadChar
 496  6ADE 1E 00        	ld		e, 0
 497  6AE0 FE 79        	cp		'y'
 498  6AE2 20 02        	jr		nz, CheckSYS
 499  6AE4 1E 01        	ld		e, 1
 500  6AE6
 501  6AE6              CheckSYS:
 502  6AE6 D5           	push	de
 503  6AE7 21 B5 7F     		ld		hl, MsgSetSYS
 504  6AEA 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 505  6AED 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 506  6AEF CD 65 78     		call	PrintStrClr
 507  6AF2 CD 01 78     		call	ReadChar
 508  6AF5 FE 79        		cp		'y'
 509  6AF7 D1           	pop		de
 510  6AF8 20 04        	jr		nz, AttrChange
 511  6AFA 3E 02        	ld		a, %10
 512  6AFC B3           	or		e
 513  6AFD 5F           	ld		e, a
 514  6AFE
 515  6AFE              AttrChange:
 516  6AFE 2A B8 80     	ld		hl, (SelFileCache)
 517  6B01 CD 68 74     	call	ChangeFileAttrib
 518  6B04 C3 96 67     	jp		HCRunInitDisk
 519  6B07
 520  6B07              SelectDrive:
 521  6B07 32 97 73     	ld 		(RWTSDrive), a
 522  6B0A C3 96 67     	jp		HCRunInitDisk
 523  6B0D
 524  6B0D              CheckKeyDiskMenu:
 525  6B0D FE 39        	cp		'9'
 526  6B0F C2 EC 6B     	jp		nz, CheckKeyExit
 527  6B12
 528  6B12 3A 97 73     	ld		a, (RWTSDrive)
 529  6B15 C6 41        	add		'A'
 530  6B17              	;Update menu messages with current drive.
 531  6B17 32 FE 7F     	ld		(MsgMenuSingleDrv1), a
 532  6B1A 32 02 80     	ld		(MsgMenuSingleDrv2), a
 533  6B1D 32 0C 80     	ld		(MsgMenuDualDrv1), a
 534  6B20 32 1A 80     	ld		(MsgMenuToComDrv), a
 535  6B23 32 2E 80     	ld		(MsgMenuFromCOMDrv), a
 536  6B26 32 3A 80     	ld		(MsgMenuFmtDrv), a
 537  6B29 32 47 80     	ld		(MsgFormatDrv), a
 538  6B2C              	;Update menu messages with the alternate drive.
 539  6B2C 3A 97 73     	ld		a, (RWTSDrive)
 540  6B2F 3C           	inc		a
 541  6B30 EE 03        	xor		%11
 542  6B32 C6 40        	add		'A'-1
 543  6B34 32 10 80     	ld		(MsgMenuDualDrv2), a
 544  6B37
 545  6B37 21 D1 7F     	ld		hl, MsgMenuDiskCopy
 546  6B3A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 547  6B3D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 548  6B3F CD 65 78     	call	PrintStrClr
 549  6B42 21 EA 7F     	ld		hl, MsgMenuBack
 550  6B45 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 551  6B48 CD 3D 78     	call	PrintStr
 552  6B4B 21 F6 7F     	ld		hl, MsgMenuSingle
 553  6B4E 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 554  6B51 CD 3D 78     	call	PrintStr
 555  6B54 21 04 80     	ld		hl, MsgMenuDual
 556  6B57 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 557  6B5A CD 3D 78     	call	PrintStr
 558  6B5D 21 12 80     	ld		hl, MsgMenuToCOM
 559  6B60 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 560  6B63 CD 3D 78     	call	PrintStr
 561  6B66 21 21 80     	ld		hl, MsgMenuFromCOM
 562  6B69 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 563  6B6C CD 3D 78     	call	PrintStr
 564  6B6F 21 30 80     	ld		hl, MsgMenuFmt
 565  6B72 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 566  6B75 CD 3D 78     	call	PrintStr
 567  6B78
 568  6B78 CD 01 78     	call	ReadChar
 569  6B7B F5           	push	af
 570  6B7C 06 07        		ld		b, 7
 571  6B7E CD E9 79     		call	ClearNMsgLines
 572  6B81 F1           	pop		af
 573  6B82 32 BA 80     	ld		(CopySelOption), a
 574  6B85
 575  6B85              CheckKeyDiskMenuLoop:
 576  6B85 FE 30        	cp		'0'
 577  6B87 28 60        	jr		z, DiskMenuExit
 578  6B89
 579  6B89              	;Single drive copy
 580  6B89 FE 31        	cp		'1'
 581  6B8B 20 0A        	jr		nz, CheckDiskMenuDualDrive
 582  6B8D CD C7 70     	call	CopyDisk
 583  6B90 06 02        	ld		b, 2
 584  6B92 CD E9 79     	call	ClearNMsgLines
 585  6B95 18 52        	jr		DiskMenuExit
 586  6B97
 587  6B97              	;Dual drive copy
 588  6B97              CheckDiskMenuDualDrive:
 589  6B97 FE 32        	cp		'2'
 590  6B99 20 0A        	jr		nz, CheckDiskMenuToCOM
 591  6B9B CD C7 70     	call	CopyDisk
 592  6B9E 06 02        	ld		b, 2
 593  6BA0 CD E9 79     	call	ClearNMsgLines
 594  6BA3 18 44        	jr		DiskMenuExit
 595  6BA5
 596  6BA5              CheckDiskMenuToCOM:
 597  6BA5 FE 33        	cp		'3'
 598  6BA7 20 05        	jr		nz, CheckDiskMenuFromCOM
 599  6BA9 CD 80 71     	call	CopyDiskToCOM
 600  6BAC 18 3B        	jr		DiskMenuExit
 601  6BAE
 602  6BAE              CheckDiskMenuFromCOM:
 603  6BAE FE 34        	cp		'4'
 604  6BB0 20 06        	jr		nz, CheckDiskMenuFormat
 605  6BB2 CD DC 71     	call	CopyDiskFromCOM
 606  6BB5 C3 96 67     	jp		HCRunInitDisk
 607  6BB8
 608  6BB8              CheckDiskMenuFormat:
 609  6BB8 FE 35        	cp		'5'
 610  6BBA C2 D7 67     	jp		nz, HCRunMain
 611  6BBD
 612  6BBD 21 3C 80     	ld		hl, MsgFormat
 613  6BC0 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 614  6BC3 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 615  6BC5 CD 65 78     	call	PrintStrClr
 616  6BC8
 617  6BC8 CD F7 6F     	call	FormatDisk
 618  6BCB B7           	or		a
 619  6BCC CA 96 67     	jp		z, HCRunInitDisk
 620  6BCF
 621  6BCF              	;Display error for format
 622  6BCF 6F           	ld		l, a
 623  6BD0 26 00        	ld		h, 0
 624  6BD2 11 C8 7E     	ld		de, MsgErrCode
 625  6BD5 CD 62 6F     	call	Byte2Txt
 626  6BD8 21 BD 7E     	ld		hl, MsgErr
 627  6BDB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 628  6BDE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 629  6BE0 CD 65 78     	call	PrintStrClr
 630  6BE3 CD 01 78     	call	ReadChar
 631  6BE6 C3 96 67     	jp		HCRunInitDisk
 632  6BE9
 633  6BE9              DiskMenuExit:
 634  6BE9 C3 0C 69     	jp		ReadKeyLoop
 635  6BEC
 636  6BEC              CheckKeyExit:
 637  6BEC FE 30        	cp		'0'
 638  6BEE C2 0C 69     	jp		nz, ReadKeyLoop
 639  6BF1              	;jp		HCRunEnd
 640  6BF1 C3 00 00     	jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 641  6BF4
 642  6BF4              MoveIt:
 643  6BF4 CD 31 79     	call 	MoveCursor
 644  6BF7 C3 0C 69     	jp		ReadKeyLoop
 645  6BFA
 646  6BFA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 647  6BFA
 648  6BFA
 649  6BFA              DisplayFilename:
 650  6BFA 06 0B        	LD		B, NAMELEN
 651  6BFC              DispLoop:
 652  6BFC 1A           	LD		A, (DE)
 653  6BFD
 654  6BFD              	;clear bit 7
 655  6BFD CB BF        	RES 	7, A
 656  6BFF 32 81 5C     	LD		(CODE), A
 657  6C02
 658  6C02 13           	INC		DE
 659  6C03 D5           	PUSH	DE
 660  6C04 C5           	PUSH	BC
 661  6C05 CD 69 79     		CALL	PrintChar
 662  6C08 C1           	POP		BC
 663  6C09 D1           	POP 	DE
 664  6C0A
 665  6C0A 21 B0 5C     	LD		HL, COL
 666  6C0D 34           	INC		(HL)
 667  6C0E 10 EC        	DJNZ	DispLoop
 668  6C10              	;now a name is displayed
 669  6C10
 670  6C10              	;check bounds
 671  6C10 3A B1 5C     	LD		A, (LINE)
 672  6C13 3C           	INC		A
 673  6C14 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 674  6C16 38 0A        	JR		C, LineOK
 675  6C18
 676  6C18              	;set names column to the next one
 677  6C18 3A B2 80     	LD		A, (NameCol)
 678  6C1B C6 0C        	ADD		NAMELEN + 1
 679  6C1D 32 B2 80     	LD		(NameCol), A
 680  6C20
 681  6C20 3E 01        	LD		A, LST_FIRST_LINE
 682  6C22              LineOK:
 683  6C22 32 B1 5C     	LD		(LINE), A
 684  6C25
 685  6C25 3A B2 80     	LD		A, (NameCol)
 686  6C28 32 B0 5C     	LD		(COL), A
 687  6C2B
 688  6C2B C9           	RET
 689  6C2C
 690  6C2C
 691  6C2C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 692  6C2C
 693  6C2C              DisplayFilenames:
 694  6C2C 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 695  6C2F ED 53 B0 5C  	ld		(LineCol), de
 696  6C33
 697  6C33 11 DD 80     	ld		de, FileCache
 698  6C36 3A B1 80     	ld		a, (FileCnt)
 699  6C39 B7           	or		a
 700  6C3A C8           	ret		z
 701  6C3B
 702  6C3B 47           	ld		b,	a
 703  6C3C
 704  6C3C              DisplayFilenamesLoop:
 705  6C3C C5           	push	bc
 706  6C3D D5           		push	de
 707  6C3E CD FA 6B     			call	DisplayFilename
 708  6C41 D1           		pop		de
 709  6C42 EB           		ex		de, hl
 710  6C43 01 19 00     		ld		bc, CACHE_SZ
 711  6C46 09           		add		hl, bc
 712  6C47 EB           		ex		de, hl
 713  6C48 C1           	pop		bc
 714  6C49 10 F1        	djnz	DisplayFilenamesLoop
 715  6C4B
 716  6C4B C9           	ret
 717  6C4C
 718  6C4C
 719  6C4C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 720  6C4C              ;Selects only valid filenames (not deleted and only from first extension)
 721  6C4C              GetFileNames:
 722  6C4C DD 21 FB 8E  	ld		ix, TrackBuf
 723  6C50 11 DD 80     	ld		de, FileCache
 724  6C53 06 80        	ld		b, MAX_EXT_CNT
 725  6C55 AF           	xor		a
 726  6C56 32 B1 80     	ld		(FileCnt), a
 727  6C59 21 B6 80     	ld		hl, AUCnt
 728  6C5C 77           	ld		(hl), a
 729  6C5D 23           	inc		hl
 730  6C5E 77           	ld		(hl), a
 731  6C5F
 732  6C5F              StoreFilenamesLoop:
 733  6C5F AF           	xor a
 734  6C60 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 735  6C63 C2 D7 6C     	jp nz, NextExt
 736  6C66
 737  6C66              	;count AU
 738  6C66 D9           	exx
 739  6C67 E5           	push hl
 740  6C68 CD 26 70     		call CheckExtAlloc
 741  6C6B EB           		ex de, hl			;save first AU no.
 742  6C6C
 743  6C6C              		;store disk alocated AU count
 744  6C6C 2A B6 80     		ld hl, (AUCnt)
 745  6C6F 48           		ld c, b
 746  6C70 06 00        		ld b, 0
 747  6C72 09           		add hl, bc
 748  6C73 22 B6 80     		ld (AUCnt), hl
 749  6C76 E1           	pop hl
 750  6C77 D9           	exx
 751  6C78
 752  6C78 AF           	xor	a
 753  6C79 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 754  6C7C 20 32        	jr nz, FindExt
 755  6C7E
 756  6C7E DD E5        	push ix
 757  6C80 E1           	pop hl
 758  6C81 23           	inc hl					;skip del flag
 759  6C82
 760  6C82 C5           	push bc
 761  6C83 ~            		/*
 762  6C83 ~            		push de
 763  6C83 ~            			push hl
 764  6C83 ~            				ex de, hl
 765  6C83 ~            				call DisplayFilename
 766  6C83 ~            			pop hl
 767  6C83 ~            		pop de
 768  6C83 ~            		*/
 769  6C83 01 0B 00     		ld bc, NAMELEN
 770  6C86 ED B0        		ldir				;save file name
 771  6C88
 772  6C88 D9           		exx
 773  6C89 D5           		push 	de			;de = first AU
 774  6C8A D9           		exx
 775  6C8B E1           		pop		hl
 776  6C8C EB           		ex		de, hl
 777  6C8D 73 23 72 2B  		ld		(hl), de	;save first AU
 778  6C91
 779  6C91 23           		inc		hl
 780  6C92 23           		inc		hl
 781  6C93
 782  6C93 D9           		exx					;save AU cnt for file
 783  6C94 C5           		push	bc
 784  6C95 D9           		exx
 785  6C96 C1           		pop		bc
 786  6C97 71 23 70 2B  		ld		(hl), bc
 787  6C9B
 788  6C9B 23           		inc		hl
 789  6C9C 23           		inc		hl
 790  6C9D
 791  6C9D              		;xor		a			;make flag 0 to signal that header is not read yet
 792  6C9D              		;ld		(hl), a
 793  6C9D
 794  6C9D 01 0A 00     		ld		bc, HDR_SZ + 1
 795  6CA0 09           		add		hl, bc
 796  6CA1
 797  6CA1 EB           		ex		de, hl
 798  6CA2 C1           	pop bc
 799  6CA3
 800  6CA3
 801  6CA3 3A B1 80     	ld 		a, (FileCnt)			;inc file counter
 802  6CA6 3C           	inc		a
 803  6CA7 32 B1 80     	ld 		(FileCnt), a
 804  6CAA FE 54        	cp		LST_MAX_FILES
 805  6CAC 38 29        	jr		c, NextExt
 806  6CAE 18 34        	jr		GetFileNamesEnd
 807  6CB0
 808  6CB0
 809  6CB0              FindExt:					;BC' = AU cnt for this ext
 810  6CB0 C5           	push	bc
 811  6CB1 D5           		push 	de
 812  6CB2 DD E5        			push	ix
 813  6CB4 D1           			pop		de
 814  6CB5 13           			inc		de				;DE = name to find
 815  6CB6
 816  6CB6 21 DD 80     			ld		hl, FileCache
 817  6CB9 3A B1 80     			ld		a, (FileCnt)
 818  6CBC 4F           			ld		c, a
 819  6CBD CD D4 72     			call	FindCache
 820  6CC0 20 13        			jr		nz, FindExtEnd
 821  6CC2
 822  6CC2 01 0D 00     			ld		bc, CACHE_AU_CNT
 823  6CC5 09           			add		hl, bc
 824  6CC6 D9           			exx
 825  6CC7 C5           			push	bc
 826  6CC8 D9           			exx
 827  6CC9 C1           			pop		bc
 828  6CCA
 829  6CCA 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 830  6CCE EB           			ex		de, hl
 831  6CCF 09           			add		hl, bc
 832  6CD0 EB           			ex		de, hl
 833  6CD1 73 23 72 2B  			ld		(hl), de
 834  6CD5              FindExtEnd:
 835  6CD5 D1           		pop		de
 836  6CD6 C1           	pop		bc
 837  6CD7
 838  6CD7              NextExt:
 839  6CD7 C5           	push bc
 840  6CD8 01 20 00     		ld bc, EXT_SZ
 841  6CDB DD 09        		add ix, bc
 842  6CDD C1           	pop	bc
 843  6CDE
 844  6CDE 05           	dec	b
 845  6CDF 78           	ld	a, b
 846  6CE0 B7           	or	a
 847  6CE1 C2 5F 6C     	jp	nz, StoreFilenamesLoop
 848  6CE4              GetFileNamesEnd:
 849  6CE4 C9           	ret
 850  6CE5
 851  6CE5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852  6CE5
 853  6CE5              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 854  6CE5              ;IN: HL = file name
 855  6CE5              HandleFile:
 856  6CE5              	;Make HL point to the selected file
 857  6CE5 DD 2A B8 80  	ld		ix, (SelFileCache)
 858  6CE9 DD E5        	push	ix
 859  6CEB DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 860  6CEE B7           		or		a
 861  6CEF CC E5 72     		call	z, ReadFileHeader
 862  6CF2
 863  6CF2 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 864  6CF5 FE 00        		cp		PROG_TYPE
 865  6CF7 28 56        		jr		z, HandleFileProg
 866  6CF9
 867  6CF9 FE 03        		cp		BYTE_TYPE
 868  6CFB 20 62        		jr		nz, HandleFileText
 869  6CFD
 870  6CFD DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 870  6D01 66 12
 871  6D03 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 872  6D06 19           		add		hl, de
 873  6D07 7C           		ld		a, h
 874  6D08 B5           		or		l
 875  6D09 28 26        		jr		z, HandleFileSCR
 876  6D0B
 877  6D0B
 878  6D0B              HandleFileCODE:
 879  6D0B 21 EA 7E     		ld		hl, MsgLoadingCODE
 880  6D0E 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 881  6D11 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 882  6D13 CD 65 78     		call	PrintStrClr
 883  6D16
 884  6D16              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 885  6D16 21 4F 72     		ld		hl, IF1FileLoad
 886  6D19 11 00 5B     		ld		de, PRN_BUF
 887  6D1C 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 888  6D1F ED B0        		ldir
 889  6D21              		;ld		a, $C9
 890  6D21              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 891  6D21
 892  6D21 E1           	pop		hl
 893  6D22 ED 5B FE 8E  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 894  6D26 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 895  6D27 C1           	pop		bc						;2nd, 3rd call for error handler
 896  6D28 C1           	pop		bc
 897  6D29 ED 43 3D 5C  	ld		(ERRSP), bc
 898  6D2D D5           	push	de						;push CODE address to return to = start of CODE block
 899  6D2E C3 00 5B     	jp		PRN_BUF
 900  6D31
 901  6D31
 902  6D31
 903  6D31
 904  6D31              HandleFileSCR:
 905  6D31 21 DB 7E     		ld		hl, MsgLoadingSCR
 906  6D34 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 907  6D37 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 908  6D39 CD 65 78     		call	PrintStrClr
 909  6D3C
 910  6D3C E1           	pop		hl
 911  6D3D
 912  6D3D              	IFDEF _REAL_HW_
 913  6D3D              		;Load to alternate SCREEN$ memory
 914  6D3D 11 00 C0     		ld		de, HC_VID_BANK1
 915  6D40 CD 4F 72     		call	IF1FileLoad
 916  6D43
 917  6D43              		;Set display to alternate SCREEN$ memory
 918  6D43 3E 08        		ld		a, HC_CFG_VID_C000
 919  6D45 D3 7E        		out 	(HC_CFG_PORT), a
 920  6D47 CD 01 78     		call	ReadChar
 921  6D4A
 922  6D4A              		;Set back to regular SCREEN$ memory
 923  6D4A 3E 00        		ld		a, HC_CFG_VID_4000
 924  6D4C D3 7E        		out 	(HC_CFG_PORT), a
 925  6D4E              	ELSE
 926  6D4E ~            		ld		de, HC_VID_BANK0
 927  6D4E ~            		call	IF1FileLoad
 928  6D4E ~            		call	ReadChar
 929  6D4E              	ENDIF
 930  6D4E
 931  6D4E C9           	ret
 932  6D4F
 933  6D4F              HandleFileProg:
 934  6D4F 21 CC 7E     		ld		hl, MsgLoadingPrg
 935  6D52 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 936  6D55 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 937  6D57 CD 65 78     		call	PrintStrClr
 938  6D5A E1           	pop		hl
 939  6D5B CD 4C 73     	call	LoadProgram
 940  6D5E C9           	ret
 941  6D5F
 942  6D5F
 943  6D5F              HandleFileText:
 944  6D5F E1           	pop		hl
 945  6D60
 946  6D60
 947  6D60              ViewFile:
 948  6D60 CD 1D 78     	call	ClrScr
 949  6D63 21 00 00     	ld		hl, 0
 950  6D66 22 C0 80     	ld		(FilePosRead), hl
 951  6D69              ViewFileLoop:
 952  6D69 2A B8 80     	ld		hl, (SelFileCache)
 953  6D6C 3A 97 73     	ld 		a, (RWTSDrive)
 954  6D6F 3C           	inc		a
 955  6D70 CD 4E 77     	call	ReadFileSection					;DE = last address read
 956  6D73 21 FB 8E     	ld		hl, FileData
 957  6D76              	;Calculate size of read buffer
 958  6D76 E5           	push	hl
 959  6D77 EB           		ex	de, hl
 960  6D78 B7           		or	a
 961  6D79 ED 52        		sbc	hl, de
 962  6D7B 44           		ld	b, h
 963  6D7C 4B           		ld	c, e
 964  6D7D E1           	pop		hl
 965  6D7E CD 00 7A     	call	InitViewer
 966  6D81 CD 5E 7A     	call	PrintLoop
 967  6D84              	;Check if exited viewer because user wanted to.
 968  6D84 C8           	ret		z
 969  6D85
 970  6D85              	;Check if file ended -> we need to load the next file segment.
 971  6D85 3A BD 80     	ld		a, (CopyFileRes)
 972  6D88 B7           	or		a
 973  6D89 28 DE        	jr		z, ViewFileLoop
 974  6D8B C3 99 7A     	jp		PrintLoop2
 975  6D8E C9           	ret
 976  6D8F
 977  6D8F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 978  6D8F
 979  6D8F
 980  6D8F              DisplayFileInfo:
 981  6D8F 2A B8 80     	ld		hl, (SelFileCache)
 982  6D92 E5           	push	hl
 983  6D93              		;disk size - at least 2KB ==1  AU
 984  6D93 01 0D 00     		ld		bc, CACHE_AU_CNT
 985  6D96 09           		add		hl, bc
 986  6D97 5E 23 56 2B  		ld		de, (hl)
 987  6D9B EB           		ex		de, hl
 988  6D9C              		;*2, since one block (AU) is 2KB.
 989  6D9C CB 15        		rl	l
 990  6D9E CB 14        		rl	h
 991  6DA0
 992  6DA0 11 03 7F     		ld		de, MsgFileSzDskN
 993  6DA3 CD 57 6F     		call	Word2Txt
 994  6DA6 21 FA 7E     		ld		hl, MsgFileSzDsk
 995  6DA9 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
 996  6DAC CD 3D 78     		call	PrintStr
 997  6DAF E1           	pop		hl
 998  6DB0 E5           	push	hl
 999  6DB1              		;attributes
1000  6DB1 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1001  6DB4 09           		add		hl, bc
1002  6DB5 EB           		ex		de, hl
1003  6DB6 21 13 7F     		ld		hl, MsgFileAttrN
1004  6DB9 1A           		ld		a, (de)
1005  6DBA E6 80        		and		%10000000
1006  6DBC 28 14        		jr		z, NotRO
1007  6DBE
1008  6DBE 01 52 2F     		ld		bc, '/R'
1009  6DC1 71 23 70 2B  		ld		(hl), bc
1010  6DC5 23           		inc		hl
1011  6DC6 23           		inc		hl
1012  6DC7 01 4F 2C     		ld		bc, ',O'
1013  6DCA 71 23 70 2B  		ld		(hl), bc
1014  6DCE 23           		inc		hl
1015  6DCF 23           		inc		hl
1016  6DD0 18 12        		jr		CheckSys
1017  6DD2              NotRO:
1018  6DD2 01 2D 2D     		ld		bc, '--'
1019  6DD5 71 23 70 2B  		ld		(hl), bc
1020  6DD9 23           		inc		hl
1021  6DDA 23           		inc		hl
1022  6DDB 01 2D 2C     		ld		bc, ',-'
1023  6DDE 71 23 70 2B  		ld		(hl), bc
1024  6DE2 23           		inc		hl
1025  6DE3 23           		inc		hl
1026  6DE4
1027  6DE4              CheckSys:
1028  6DE4 13           		inc		de
1029  6DE5 1A           		ld		a, (de)
1030  6DE6 E6 80        		and		%10000000
1031  6DE8 28 0E        		jr		z, NotSYS
1032  6DEA
1033  6DEA 01 48 49     		ld		bc, 'IH'
1034  6DED 71 23 70 2B  		ld		(hl), bc
1035  6DF1 23           		inc		hl
1036  6DF2 23           		inc		hl
1037  6DF3 3E C4        		ld		a, 'D' + $80
1038  6DF5 77           		ld		(hl), a
1039  6DF6 18 0C        		jr		AttrEnd
1040  6DF8              NotSYS:
1041  6DF8 01 2D 2D     		ld		bc, '--'
1042  6DFB 71 23 70 2B  		ld		(hl), bc
1043  6DFF 23           		inc		hl
1044  6E00 23           		inc		hl
1045  6E01 3E AD        		ld		a, '-' + $80
1046  6E03 77           		ld		(hl), a
1047  6E04              AttrEnd:
1048  6E04 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1049  6E07 21 0A 7F     		ld		hl, MsgFileAttr
1050  6E0A CD 3D 78     		call	PrintStr
1051  6E0D DD E1        	pop		ix
1052  6E0F DD E5        	push	ix
1053  6E11 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1054  6E14 B7           		or		a
1055  6E15 CA B2 6E             jp		z, HeadNotRead
1056  6E18
1057  6E18 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1058  6E1B DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1059  6E1E CA B2 6E             jp		z, HeadNotRead
1060  6E21
1061  6E21 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1062  6E24 FE 00        		cp		PROG_TYPE
1063  6E26 20 0B        		jr		nz, CheckNoArr
1064  6E28
1065  6E28 21 2D 7F     		ld		hl, MsgFileTypePrg
1066  6E2B 11 23 7F     		ld		de, MsgFileTypeN
1067  6E2E CD FB 6E     		call	MoveMsg
1068  6E31 18 4F        		jr		PrepFileLen
1069  6E33
1070  6E33              CheckNoArr:
1071  6E33 FE 01        		cp		NUMB_TYPE
1072  6E35 20 0B        		jr		nz, CheckChrArr
1073  6E37
1074  6E37 21 49 7F     		ld		hl, MsgFileTypeNoA
1075  6E3A 11 23 7F     		ld		de, MsgFileTypeN
1076  6E3D CD FB 6E     		call	MoveMsg
1077  6E40 18 40        		jr		PrepFileLen
1078  6E42
1079  6E42              CheckChrArr:
1080  6E42 FE 02        		cp		CHAR_TYPE
1081  6E44 20 0B        		jr		nz, CheckByte
1082  6E46
1083  6E46 21 42 7F     		ld		hl, MsgFileTypeChrA
1084  6E49 11 23 7F     		ld		de, MsgFileTypeN
1085  6E4C CD FB 6E     		call	MoveMsg
1086  6E4F 18 31        		jr		PrepFileLen
1087  6E51
1088  6E51              CheckByte:
1089  6E51 FE 03        		cp		BYTE_TYPE
1090  6E53 20 24        		jr		nz, CheckText
1091  6E55
1092  6E55 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1092  6E59 66 12
1093  6E5B 01 00 E5     		ld		bc, -SCR_LEN
1094  6E5E 09           		add		hl, bc
1095  6E5F 7C           		ld		a, h
1096  6E60 B5           		or		l
1097  6E61 20 0B        		jr		nz, NotScr
1098  6E63
1099  6E63 21 3B 7F     		ld		hl, MsgFileTypeSCR
1100  6E66 11 23 7F     		ld		de, MsgFileTypeN
1101  6E69 CD FB 6E     		call	MoveMsg
1102  6E6C 18 14        		jr		PrepFileLen
1103  6E6E              NotScr:
1104  6E6E 21 34 7F     		ld		hl, MsgFileTypeByte
1105  6E71 11 23 7F     		ld		de, MsgFileTypeN
1106  6E74 CD FB 6E     		call	MoveMsg
1107  6E77 18 09        		jr		PrepFileLen
1108  6E79
1109  6E79              CheckText:
1110  6E79 21 50 7F     		ld		hl, MsgFileTypeText
1111  6E7C 11 23 7F     		ld		de, MsgFileTypeN
1112  6E7F CD FB 6E     		call	MoveMsg
1113  6E82
1114  6E82              PrepFileLen:
1115  6E82              		;File len
1116  6E82 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1117  6E85 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1118  6E88              PrepFileLenText:
1119  6E88 11 67 7F     		ld		de, MsgFileLenN
1120  6E8B CD 57 6F     		call	Word2Txt
1121  6E8E 26 C2        		ld		h, 'B' | $80
1122  6E90 2E 20        		ld		l, ' '
1123  6E92 22 6C 7F     		ld		(MsgFileLenN + 5), hl
1124  6E95
1125  6E95 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1126  6E98 FE 00        		cp		PROG_TYPE
1127  6E9A 28 06        		jr		z, PrintProgStart
1128  6E9C
1129  6E9C FE 03        		cp		BYTE_TYPE
1130  6E9E 28 0A        		jr		z, PrintByteStart
1131  6EA0
1132  6EA0 18 22        		jr		PrintStartNotRead
1133  6EA2
1134  6EA2              PrintProgStart:
1135  6EA2 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1136  6EA5 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1137  6EA8 18 25        		jr		PrintStart
1138  6EAA
1139  6EAA              PrintByteStart:
1140  6EAA DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1141  6EAD DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1142  6EB0 18 1D        		jr		PrintStart
1143  6EB2
1144  6EB2              HeadNotRead:
1145  6EB2 21 57 7F             ld        hl, MsgNA
1146  6EB5 11 23 7F             ld        de, MsgFileTypeN
1147  6EB8 CD FB 6E             call    MoveMsg
1148  6EBB
1149  6EBB 21 57 7F     		ld		hl, MsgNA
1150  6EBE 11 67 7F     		ld		de, MsgFileLenN
1151  6EC1 CD FB 6E     		call	MoveMsg
1152  6EC4
1153  6EC4              PrintStartNotRead:
1154  6EC4 21 57 7F     		ld		hl, MsgNA
1155  6EC7 11 77 7F     		ld		de, MsgFileStartN
1156  6ECA CD FB 6E     		call	MoveMsg
1157  6ECD 18 0E        		jr		PrintStartStr
1158  6ECF
1159  6ECF              PrintStart:
1160  6ECF 1E 20        	ld		e, ' '
1161  6ED1 16 A0        	ld		d, ' ' | $80
1162  6ED3 ED 53 7C 7F  	ld		(MsgFileStartN + 5), de
1163  6ED7 11 77 7F     	ld		de, MsgFileStartN
1164  6EDA CD 57 6F     	call	Word2Txt
1165  6EDD              PrintStartStr:
1166  6EDD 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1167  6EE0 21 6E 7F     	ld		hl, MsgFileStart
1168  6EE3 CD 3D 78     	call	PrintStr
1169  6EE6
1170  6EE6 DD E1        	pop		ix
1171  6EE8 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1172  6EEB 21 1A 7F     	ld		hl, MsgFileType
1173  6EEE CD 3D 78     	call	PrintStr
1174  6EF1
1175  6EF1 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1176  6EF4 21 5E 7F     	ld		hl, MsgFileLen
1177  6EF7 CD 3D 78     	call	PrintStr
1178  6EFA
1179  6EFA C9           	ret
1180  6EFB
1181  6EFB              MoveMsg:
1182  6EFB 01 07 00     	ld		bc, 7
1183  6EFE ED B0        	ldir
1184  6F00 C9           	ret
1185  6F01
1186  6F01              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1187  6F01
1188  6F01              ReadAllHeaders:
1189  6F01 21 7E 7F     	ld		hl, MsgReadingExt
1190  6F04 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1191  6F07 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1192  6F09 CD 65 78     	call	PrintStrClr
1193  6F0C
1194  6F0C CD FB 68     	call	CalcFileCache
1195  6F0F
1196  6F0F 3A B3 80     	ld		a, (SelFile)
1197  6F12 47           	ld		b, a
1198  6F13 3A B1 80     	ld		a, (FileCnt)
1199  6F16 90           	sub		b
1200  6F17 B7           	or		a
1201  6F18 C8           	ret		z
1202  6F19
1203  6F19 47           	ld		b, a
1204  6F1A
1205  6F1A DD 2A B8 80  	ld		ix, (SelFileCache)
1206  6F1E              NextFile:
1207  6F1E C5           	push	bc
1208  6F1F CD E5 72     		call	ReadFileHeader
1209  6F22 01 19 00     		ld		bc, CACHE_SZ
1210  6F25 DD 09        		add		ix, bc
1211  6F27 DD E5        		push	ix
1212  6F29 CD FB 68     			call	CalcFileCache
1213  6F2C CD 8F 6D     			call	DisplayFileInfo
1214  6F2F DD E1        		pop		ix
1215  6F31
1216  6F31 CD 04 78     		call	KbdHit
1217  6F34 38 03        		jr		c, AKey
1218  6F36 C1           	pop		bc
1219  6F37 18 15        	jr		ReadAllHeadersEnd
1220  6F39
1221  6F39              AKey:
1222  6F39 3A B3 80     		ld		a, (SelFile)
1223  6F3C 3C           		inc		a
1224  6F3D 47           		ld		b, a
1225  6F3E 3A B1 80     		ld		a, (FileCnt)
1226  6F41 B8           		cp		b
1227  6F42 28 10        		jr		z, DontInc
1228  6F44 78           		ld		a, b
1229  6F45 32 B3 80     		ld		(SelFile), a
1230  6F48 CD 31 79     		call	MoveCursor
1231  6F4B C1           	pop		bc
1232  6F4C 10 D0        	djnz	NextFile
1233  6F4E
1234  6F4E              ReadAllHeadersEnd:
1235  6F4E 06 01        	ld		b, 1
1236  6F50 CD E9 79     	call	ClearNMsgLines
1237  6F53 C9           	ret
1238  6F54
1239  6F54              DontInc:
1240  6F54 C1           	pop		bc
1241  6F55 18 F7        	jr		ReadAllHeadersEnd
1242  6F57
1243  6F57
1244  6F57              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1245  6F57
1246  6F57              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6F57              	ifndef	_HCCFG_
   2+ 6F57              	define	_HCCFG_
   3+ 6F57
   4+ 6F57              ;HC specific code, for configuration
   5+ 6F57
   6+ 6F57              HC_CFG_PORT			EQU	$7E
   7+ 6F57
   8+ 6F57              ;BASIC/CPM ROM selection
   9+ 6F57              HC_CFG_ROM_BAS		EQU	%0
  10+ 6F57              HC_CFG_ROM_CPM		EQU	%1
  11+ 6F57
  12+ 6F57              ;Address for ROM paging: 0 or $E000
  13+ 6F57              HC_CFG_ROM_0000		EQU %00
  14+ 6F57              HC_CFG_ROM_E000		EQU %10
  15+ 6F57
  16+ 6F57              ;Cfg. port Enable/Disable
  17+ 6F57              HC_CFG_PORT_DIS		EQU %000
  18+ 6F57              HC_CFG_PORT_EN		EQU	%100
  19+ 6F57
  20+ 6F57              ;Video memory bank: $4000 or $C000
  21+ 6F57              HC_CFG_VID_4000		EQU	%0000
  22+ 6F57              HC_CFG_VID_C000		EQU	%1000
  23+ 6F57
  24+ 6F57
  25+ 6F57              ;Standar BASIC config
  26+ 6F57              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 6F57              ;Standar CP/M config
  28+ 6F57              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 6F57
  30+ 6F57
  31+ 6F57              HC_VID_BANK0		EQU	$4000
  32+ 6F57              HC_VID_BANK1		EQU	$C000
  33+ 6F57
  34+ 6F57              	endif
# file closed: hccfg.asm
1247  6F57              	include "if1.asm"
# file opened: if1.asm
   1+ 6F57              ;HC IF1 routines and constants
   2+ 6F57
   3+ 6F57              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6F57              ;12 = Writing to a 'read' file
   5+ 6F57              ;13 = Reading a 'write' file
   6+ 6F57              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6F57              ;15 = Disk full (disk or catalog full)
   8+ 6F57              ;16 = Disk error (hardware error)
   9+ 6F57              ;17 = File not found
  10+ 6F57              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6F57              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6F57
  13+ 6F57              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6F57              ;00h = OK
  15+ 6F57              ;08h = cannot format disk
  16+ 6F57              ;10h = disk protected (read-only?)
  17+ 6F57              ;20h = volume error
  18+ 6F57              ;40h = drive error
  19+ 6F57              ;80h = reading error
  20+ 6F57              ;Codes I encountered:
  21+ 6F57              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6F57
  23+ 6F57
  24+ 6F57              	ifndef	_DISK_
  25+ 6F57              	define	_DISK_
  26+ 6F57
  27+ 6F57              	include	"math.asm"
# file opened: math.asm
   1++6F57              	ifndef	_MATH_
   2++6F57              	define	_MATH_
   3++6F57
   4++6F57              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6F57              ;http://map.tni.nl/sources/external/z80bits.html
   6++6F57
   7++6F57
   8++6F57              Word2Txt:
   9++6F57              	IFUSED
  10++6F57 D5           	push	de
  11++6F58 CD 78 6F     		call	Word2Txt_
  12++6F5B D1           	pop		de
  13++6F5C
  14++6F5C 06 04        	ld		b, 4
  15++6F5E CD 6D 6F     	call	StrippLeading0
  16++6F61 C9           	ret
  17++6F62
  18++6F62              Byte2Txt:
  19++6F62 D5           	push	de
  20++6F63 CD 84 6F     		call	Byte2Txt_
  21++6F66 D1           	pop		de
  22++6F67
  23++6F67 06 02        	ld		b, 2
  24++6F69 CD 6D 6F     	call	StrippLeading0
  25++6F6C C9           	ret
  26++6F6D              	ENDIF
  27++6F6D
  28++6F6D
  29++6F6D              StrippLeading0:
  30++6F6D 1A           	ld		a, (de)
  31++6F6E FE 31        	cp		'1'
  32++6F70 D0           	ret		nc
  33++6F71
  34++6F71 3E 20        	ld		a, ' '
  35++6F73 12           	ld		(de), a
  36++6F74 13           	inc		de
  37++6F75 10 F6        	djnz	StrippLeading0
  38++6F77 C9           	ret
  39++6F78
  40++6F78
  41++6F78              ;Converts the number in HL to ASCII in decimal string at DE
  42++6F78              Word2Txt_:
  43++6F78 01 F0 D8     	ld bc, -10000
  44++6F7B CD 93 6F     	call DigitLoop
  45++6F7E 01 18 FC     	ld bc, -1000
  46++6F81 CD 93 6F     	call DigitLoop
  47++6F84              Byte2Txt_:
  48++6F84 01 9C FF     	ld bc, -100
  49++6F87 CD 93 6F     	call DigitLoop
  50++6F8A 01 F6 FF     	ld bc, -10
  51++6F8D CD 93 6F     	call DigitLoop
  52++6F90 01 FF FF     	ld bc, -1
  53++6F93
  54++6F93              DigitLoop:
  55++6F93 3E 2F        	ld	a, '0' - 1
  56++6F95              DivNrLoop:
  57++6F95 3C           	inc	a			;increase reminder
  58++6F96 09           	add	hl, bc		;substract divizor
  59++6F97 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6F99 ED 42        	sbc	hl, bc		;nope, restore
  61++6F9B
  62++6F9B 12           	ld (de), a
  63++6F9C 13           	inc de
  64++6F9D C9           	ret
  65++6F9E
  66++6F9E
  67++6F9E              ;Input: HL = Dividend, C = Divisor
  68++6F9E              ;Output: HL = Quotient, A = Remainder
  69++6F9E              ;Warning: doesn't work with divisor >= $80
  70++6F9E              Div:
  71++6F9E              	IFUSED
  72++6F9E AF           	xor a
  73++6F9F 06 10        	ld b, 16
  74++6FA1
  75++6FA1              DivLoop:
  76++6FA1 29           	add	hl,hl
  77++6FA2 17           	rla
  78++6FA3 B9           	cp	c
  79++6FA4 38 02        	jr	c, NoSub
  80++6FA6 91           	sub	c
  81++6FA7 2C           	inc	l
  82++6FA8              NoSub:
  83++6FA8 10 F7        	djnz DivLoop
  84++6FAA
  85++6FAA C9           	ret
  86++6FAB              	ENDIF
  87++6FAB
  88++6FAB              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6FAB              ;Output: A:C = Quotient, HL = Remainder
  90++6FAB              Div2:
  91++6FAB 21 00 00     	ld hl, 0
  92++6FAE 06 10        	ld b, 16
  93++6FB0              Div2Loop:
  94++6FB0 CB 31        	sll c		; unroll 16 times
  95++6FB2 17           	rla			; ...
  96++6FB3 ED 6A        	adc	hl,hl		; ...
  97++6FB5 ED 52        	sbc	hl,de		; ...
  98++6FB7 30 02        	jr	nc,$+4		; ...
  99++6FB9 19           	add	hl,de		; ...
 100++6FBA 0D           	dec	c		; ...
 101++6FBB 10 F3        	djnz Div2Loop
 102++6FBD C9           	ret
 103++6FBE
 104++6FBE
 105++6FBE              ;Input: A = Multiplier, DE = Multiplicand
 106++6FBE              ;Output: A:HL = Product
 107++6FBE              Mul:
 108++6FBE              	IFUSED
 109++6FBE 21 00 00     	ld hl, 0
 110++6FC1 01 00 07     	ld bc, $0700
 111++6FC4
 112++6FC4 87           	add	a, a		; optimised 1st iteration
 113++6FC5 30 02        	jr	nc, MulLoop
 114++6FC7 62           	ld	h, d
 115++6FC8 6B           	ld	l, e
 116++6FC9
 117++6FC9              MulLoop:
 118++6FC9 29           	add	hl,hl
 119++6FCA 17           	rla
 120++6FCB 30 02        	jr	nc, NoAdd
 121++6FCD 19           	add	hl,de
 122++6FCE 89           	adc	a,c
 123++6FCF              NoAdd:
 124++6FCF 10 F8        	djnz MulLoop
 125++6FD1
 126++6FD1 C9           	ret
 127++6FD2              	ENDIF
 128++6FD2
 129++6FD2              	endif
# file closed: math.asm
  28+ 6FD2
  29+ 6FD2              DRIVE_CUR_BAS	EQU 0
  30+ 6FD2              DRIVE_A_BAS		EQU	1
  31+ 6FD2              DRIVE_B_BAS		EQU	2
  32+ 6FD2              DRIVE_A_CPM		EQU	0
  33+ 6FD2              DRIVE_B_CPM		EQU	1
  34+ 6FD2              ;Disk geometry stuff
  35+ 6FD2              SPT				EQU	16			;sectors per track
  36+ 6FD2              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6FD2              TRACK_CNT		EQU	80			;track count
  38+ 6FD2              HEAD_CNT		EQU	2			;disk face count
  39+ 6FD2              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6FD2              EXT_SZ			EQU	32			;directory entry size
  41+ 6FD2              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6FD2              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6FD2              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6FD2              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6FD2              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6FD2              REC_SZ			EQU 128			;cp/m record size
  47+ 6FD2              DEL_MARKER		EQU	$E5
  48+ 6FD2
  49+ 6FD2
  50+ 6FD2              ;Extension structure (directory entry)
  51+ 6FD2              EXT_DEL_FLAG	EQU	0
  52+ 6FD2              EXT_NAME		EQU 1
  53+ 6FD2              EXT_IDX			EQU 12
  54+ 6FD2              EXT_S1			EQU 13
  55+ 6FD2              EXT_S2			EQU 14
  56+ 6FD2              EXT_RC			EQU	15
  57+ 6FD2              EXT_AU0			EQU	16
  58+ 6FD2              EXT_AU1			EQU	18
  59+ 6FD2              EXT_AU2			EQU	20
  60+ 6FD2              EXT_AU3			EQU	22
  61+ 6FD2              EXT_AU4			EQU	24
  62+ 6FD2              EXT_AU5			EQU	26
  63+ 6FD2              EXT_AU6			EQU	28
  64+ 6FD2              EXT_AU7			EQU	30
  65+ 6FD2              EXT_SIZE		EQU 32
  66+ 6FD2
  67+ 6FD2              ;FCB structure
  68+ 6FD2              FCB_DRIVE		EQU 0
  69+ 6FD2              FCB_NAME		EQU EXT_NAME
  70+ 6FD2              FCB_EX_IDX		EQU EXT_IDX
  71+ 6FD2              FCB_S1			EQU EXT_S1
  72+ 6FD2              FCB_S2			EQU EXT_S2
  73+ 6FD2              FCB_RC			EQU	EXT_RC
  74+ 6FD2              FCB_AU			EQU	EXT_AU0
  75+ 6FD2              FCB_CR			EQU	32
  76+ 6FD2              FCB_R0			EQU 33
  77+ 6FD2              FCB_R1			EQU 34
  78+ 6FD2              FCB_R2			EQU 35
  79+ 6FD2              FCB_SIZE		EQU 36
  80+ 6FD2
  81+ 6FD2
  82+ 6FD2
  83+ 6FD2              ;System variables for disk
  84+ 6FD2              DSTR1			EQU	$5CD6		;drive
  85+ 6FD2              FSTR1			EQU	$5CDC		;file name
  86+ 6FD2              NSTR1			EQU	$5CDA		;name length
  87+ 6FD2              HD11			EQU	$5CED		;BDOS argument
  88+ 6FD2              COPIES			EQU	$5CEF		;BDOS function
  89+ 6FD2
  90+ 6FD2              ERRSP			EQU $5C3D
  91+ 6FD2              ERRNR			EQU $5C3A
  92+ 6FD2              ERRMSG			EQU	$0260
  93+ 6FD2
  94+ 6FD2              PROG			EQU $5C53
  95+ 6FD2              VARS			EQU	$5C4B
  96+ 6FD2              STKEND			EQU	$5C65
  97+ 6FD2
  98+ 6FD2              PRN_BUF			EQU	23296
  99+ 6FD2
 100+ 6FD2              REPDEL			EQU	23561
 101+ 6FD2              REPPER			EQU	23562
 102+ 6FD2              PIP				EQU	23609
 103+ 6FD2
 104+ 6FD2
 105+ 6FD2              ;RWTS routine commands
 106+ 6FD2              RWTS_CMD_POS	EQU	0			;position head
 107+ 6FD2              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6FD2              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6FD2              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6FD2
 111+ 6FD2
 112+ 6FD2              ;File name stuff
 113+ 6FD2              NAMELEN			EQU	11			;name length
 114+ 6FD2              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6FD2              SYS_POS			EQU	9			;system attribute position in name
 116+ 6FD2
 117+ 6FD2              ;File types (first byte in header)
 118+ 6FD2              PROG_TYPE		EQU	0			;program
 119+ 6FD2              NUMB_TYPE		EQU	1			;number array
 120+ 6FD2              CHAR_TYPE		EQU	2			;char array
 121+ 6FD2              BYTE_TYPE		EQU	3			;bytes
 122+ 6FD2              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6FD2
 124+ 6FD2              ;File header offsets
 125+ 6FD2              HDR_TYPE		EQU	0
 126+ 6FD2              HDR_LEN			EQU 1
 127+ 6FD2              HDR_ADDR		EQU 3
 128+ 6FD2              HDR_PLEN		EQU	5
 129+ 6FD2              HDR_LINE		EQU 7
 130+ 6FD2              HDR_SZ			EQU	9
 131+ 6FD2
 132+ 6FD2              ;BASIC disk channel structure
 133+ 6FD2              CH_RW_FLAG		EQU 11
 134+ 6FD2              CH_FCB			EQU	12
 135+ 6FD2              CH_DATA			EQU	50
 136+ 6FD2              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6FD2
 138+ 6FD2              CACHE_NAME		EQU	0					;11B
 139+ 6FD2              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6FD2              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6FD2              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6FD2              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6FD2              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6FD2
 145+ 6FD2              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6FD2
 147+ 6FD2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6FD2              IF1Init:
 149+ 6FD2 CF           	rst		08
 150+ 6FD3 31           	defb	49		;create system variables
 151+ 6FD4 C9           	ret
 152+ 6FD5
 153+ 6FD5              ;ReadWriteTrackSector
 154+ 6FD5              ;A=command: 0, 1, 2, 4
 155+ 6FD5              RWTS:
 156+ 6FD5 32 A1 73     	ld (RWTSCmd), a
 157+ 6FD8 21 96 73     	ld hl, RWTSParams
 158+ 6FDB 22 ED 5C     	ld (HD11), hl
 159+ 6FDE CF           	rst 08
 160+ 6FDF 3A           	DEFB 58
 161+ 6FE0 C9           	ret
 162+ 6FE1
 163+ 6FE1
 164+ 6FE1              ;D = sector, E = track
 165+ 6FE1              ;HL = dma
 166+ 6FE1              ReadOneDiskSector:
 167+ 6FE1 22 9B 73     	ld (RWTSDMA), hl
 168+ 6FE4 ED 53 99 73  	ld (RWTSTrack), de
 169+ 6FE8              	;ld (RWTSDrive), a
 170+ 6FE8 3E 01        	ld a, RWTS_CMD_READ
 171+ 6FEA 18 E9        	jr	RWTS
 172+ 6FEC
 173+ 6FEC              ;D = sector, E = track
 174+ 6FEC              ;HL = dma
 175+ 6FEC              WriteOneDiskSector:
 176+ 6FEC 22 9B 73     	ld (RWTSDMA), hl
 177+ 6FEF ED 53 99 73  	ld (RWTSTrack), de
 178+ 6FF3              	;ld (RWTSDrive), a
 179+ 6FF3 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6FF5 18 DE        	jr	RWTS
 181+ 6FF7
 182+ 6FF7              FormatDisk:
 183+ 6FF7 21 FB 8E     	ld		hl, DataBuf
 184+ 6FFA 36 E5        	ld		(hl), DEL_MARKER
 185+ 6FFC 22 9B 73     	ld 		(RWTSDMA), hl
 186+ 6FFF 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 7001 CD D5 6F     	call	RWTS
 188+ 7004 3A A2 73     	ld		a, (RWTSRes)
 189+ 7007 C9           	ret
 190+ 7008
 191+ 7008              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 7008
 193+ 7008              ;Allocation unit no. to track/sector
 194+ 7008              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 7008              ;IN:  HL=alloc. unit no.
 196+ 7008              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 7008              AU2TS:
 198+ 7008 0E 02        	ld c, SPT/SPAL
 199+ 700A CD 9E 6F     	call Div					;A = sector
 200+ 700D F5           	push af
 201+ 700E ~            		/*
 202+ 700E ~            		ld c, HEAD_CNT
 203+ 700E ~            		call Div				;L = track, A = head (0 or 1)
 204+ 700E ~            		*/
 205+ 700E AF           		xor a
 206+ 700F CB 1C        		rr h
 207+ 7011 CB 1D        		rr l
 208+ 7013 CB 1F        		rr a
 209+ 7015
 210+ 7015 4D           		ld c, l
 211+ 7016 06 00        		ld b, 0
 212+ 7018 B7           		or a
 213+ 7019 28 02        		jr z, Track0
 214+ 701B 06 10        		ld b, SPT
 215+ 701D              Track0:
 216+ 701D F1           	pop af
 217+ 701E B7           	or a
 218+ 701F 28 02        	jr z, FirstAU
 219+ 7021 3E 08        	ld a, SPAL
 220+ 7023              FirstAU:
 221+ 7023 80           	add a, b
 222+ 7024 47           	ld  b, a
 223+ 7025 C9           	ret
 224+ 7026
 225+ 7026              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 7026
 227+ 7026              ;Checks the allocation units number used in extension
 228+ 7026              ;IN:	IX = extension addr
 229+ 7026              ;OUT:	B = no. of allocation units used
 230+ 7026              ;		C = no. of records used in ext.
 231+ 7026              ;		HL = first alloc. unit no.
 232+ 7026              ;		DE = last alloc. unit no.
 233+ 7026              CheckExtAlloc:
 234+ 7026 DD E5        	push ix
 235+ 7028 01 0F 00     		ld bc, EXT_RC
 236+ 702B DD 09        		add ix, bc
 237+ 702D DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 7030 DD 23        		inc ix
 239+ 7032 DD 6E 00     		ld l, (ix)
 240+ 7035 DD 66 01     		ld h, (ix + 1)
 241+ 7038 06 08        		ld b, EXT_AU_CNT
 242+ 703A              CheckAU:
 243+ 703A DD 7E 00     		ld a, (ix)
 244+ 703D DD B6 01     		or (ix + 1)
 245+ 7040 28 0C        		jr z, CheckAUEnd
 246+ 7042 DD 5E 00     		ld e, (ix)
 247+ 7045 DD 56 01     		ld d, (ix + 1)
 248+ 7048 DD 23        		inc ix
 249+ 704A DD 23        		inc ix
 250+ 704C 10 EC        		djnz CheckAU
 251+ 704E              CheckAUEnd:
 252+ 704E 3E 08        		ld a, EXT_AU_CNT
 253+ 7050 90           		sub b
 254+ 7051 47           		ld b, a
 255+ 7052 DD E1        	pop ix
 256+ 7054 C9           	ret
 257+ 7055
 258+ 7055              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 7055
 260+ 7055              ;Input: TrackBuffer
 261+ 7055              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 7055              ReadUsedBlocksList:
 263+ 7055 DD 21 FB 8E  	ld		ix, TrackBuf			;source buffer
 264+ 7059 21 11 89     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 705C 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 266+ 705F 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 7062 73           	ld		(hl), e
 268+ 7063 23           	inc		hl
 269+ 7064 72           	ld		(hl), d
 270+ 7065 23           	inc		hl
 271+ 7066
 272+ 7066              	;Add blocks 0 and 1 for directory
 273+ 7066 11 00 00     	ld		de, 0
 274+ 7069 73           	ld		(hl), e
 275+ 706A 23           	inc		hl
 276+ 706B 72           	ld		(hl), d
 277+ 706C 23           	inc		hl
 278+ 706D
 279+ 706D 13           	inc		de
 280+ 706E 73           	ld		(hl), e
 281+ 706F 23           	inc		hl
 282+ 7070 72           	ld		(hl), d
 283+ 7071 23           	inc		hl
 284+ 7072
 285+ 7072              ReadUsedBlocksLoop:
 286+ 7072 AF           	xor		a
 287+ 7073 DD BE 00     	cp		(ix)
 288+ 7076 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 7078
 290+ 7078 DD E5        	push	ix
 291+ 707A C5           	push	bc
 292+ 707B 06 08        		ld		b, EXT_AU_CNT
 293+ 707D 11 10 00     		ld		de, EXT_AU0
 294+ 7080 DD 19        		add		ix, de
 295+ 7082
 296+ 7082              ReadUsedBlocksLoop2:
 297+ 7082 DD 5E 00     		ld		e, (ix)
 298+ 7085 DD 56 01     		ld		d, (ix+1)
 299+ 7088 7B           		ld		a, e
 300+ 7089 B2           		or		d
 301+ 708A 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 708C
 303+ 708C 73           		ld		(hl), e
 304+ 708D 23           		inc		hl
 305+ 708E 72           		ld		(hl), d
 306+ 708F 23           		inc		hl
 307+ 7090
 308+ 7090 DD 23        		inc		ix
 309+ 7092 DD 23        		inc		ix
 310+ 7094
 311+ 7094 ED 5B 11 89  		ld		de, (UsedBlockListCnt)
 312+ 7098 13           		inc		de
 313+ 7099 ED 53 11 89  		ld		(UsedBlockListCnt), de
 314+ 709D
 315+ 709D 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 709F
 317+ 709F
 318+ 709F              ReadUsedBlocksSkip:
 319+ 709F C1           	pop		bc
 320+ 70A0 DD E1        	pop		ix
 321+ 70A2              ReadUsedBlocksSkip2:
 322+ 70A2 11 20 00     	ld		de, EXT_SZ
 323+ 70A5 DD 19        	add		ix, de
 324+ 70A7
 325+ 70A7 0B           	dec		bc
 326+ 70A8 78           	ld		a, b
 327+ 70A9 B1           	or		c
 328+ 70AA 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 70AC
 330+ 70AC C9           	ret
 331+ 70AD
 332+ 70AD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 70AD              ;Reads 8 sectors for an AU
 334+ 70AD              ;HL = block number, DE = destination buffer
 335+ 70AD              ReadFSBlock:
 336+ 70AD D5           	push	de
 337+ 70AE CD 08 70     		call	AU2TS		;B=sector, C=track
 338+ 70B1 E1           	pop		hl				;HL=dest
 339+ 70B2
 340+ 70B2 50           	ld		d, b
 341+ 70B3 59           	ld		e, c
 342+ 70B4 06 08        	ld		b, SPAL
 343+ 70B6
 344+ 70B6 CD 95 72     	call	ReadDiskSectors
 345+ 70B9 C9           	ret
 346+ 70BA
 347+ 70BA
 348+ 70BA              ;Write 8 sectors for an AU
 349+ 70BA              ;HL = block number, DE = source buffer
 350+ 70BA              WriteFSBlock:
 351+ 70BA D5           	push	de
 352+ 70BB CD 08 70     		call	AU2TS		;B=sector, C=track
 353+ 70BE E1           	pop		hl				;HL=dest
 354+ 70BF
 355+ 70BF 50           	ld		d, b
 356+ 70C0 59           	ld		e, c
 357+ 70C1 06 08        	ld		b, SPAL
 358+ 70C3
 359+ 70C3 CD A8 72     	call	WriteDiskSectors
 360+ 70C6 C9           	ret
 361+ 70C7
 362+ 70C7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 70C7              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 70C7              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 70C7              CopyDisk:
 366+ 70C7              	;Get list of used blocks in current disk, max 632 bytes
 367+ 70C7 CD 55 70     	call	ReadUsedBlocksList
 368+ 70CA DD 21 13 89  	ld		ix, UsedBlockListBlk
 369+ 70CE
 370+ 70CE              CopyDiskLoop:
 371+ 70CE 2A 11 89     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 70D1 11 49 80     	ld		de, MsgBlocksLeft
 373+ 70D4 CD 62 6F     	call	Byte2Txt
 374+ 70D7 21 49 80     	ld		hl, MsgBlocksLeft
 375+ 70DA 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 70DD 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 70DF CD 65 78     	call	PrintStrClr
 378+ 70E2
 379+ 70E2              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 70E2 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 70E5 ED 4B 11 89  	ld		bc, (UsedBlockListCnt)
 382+ 70E9 B7           	or		a
 383+ 70EA ED 42        	sbc		hl, bc
 384+ 70EC 30 03        	jr		nc, CopyDiskLoopRead
 385+ 70EE 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 70F1
 387+ 70F1              CopyDiskLoopRead:
 388+ 70F1 41           	ld		b, c
 389+ 70F2 11 FB 8E     	ld		de, CopyDiskBuf
 390+ 70F5              	;save initial counter and initial block number array position
 391+ 70F5 C5           	push	bc
 392+ 70F6 DD E5        	push	ix
 393+ 70F8
 394+ 70F8              CopyDiskLoopReadLoop:
 395+ 70F8 DD 6E 00     		ld		l, (ix)
 396+ 70FB DD 66 01     		ld		h, (ix+1)
 397+ 70FE DD 23        		inc		ix
 398+ 7100 DD 23        		inc		ix
 399+ 7102
 400+ 7102 D5           		push	de
 401+ 7103 C5           		push	bc
 402+ 7104 CD AD 70     			call	ReadFSBlock			;Stop on error or continue?
 403+ 7107 C1           		pop		bc
 404+ 7108 D1           		pop		de
 405+ 7109
 406+ 7109              		;+2048
 407+ 7109 7A           		ld		a, d
 408+ 710A C6 08        		add		8
 409+ 710C 57           		ld		d, a
 410+ 710D
 411+ 710D 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 710F
 413+ 710F              		;Check if selection is 1=single drive or 2=dual drive
 414+ 710F 3A BA 80     		ld		a, (CopySelOption)
 415+ 7112 FE 31        		cp		'1'
 416+ 7114 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 7116
 418+ 7116              		;Prompt for disk change
 419+ 7116 CD B5 74     		call	PromptDiskChangeDst
 420+ 7119 3A 97 73     		ld		a, (RWTSDrive)
 421+ 711C CD BF 73     		call	BDOSInit
 422+ 711F 18 0A        		jr		CopyDiskReadEnd
 423+ 7121
 424+ 7121              CopyDiskDualDrive1:
 425+ 7121              		;alternate drive
 426+ 7121 3A 97 73     		ld		a, (RWTSDrive)
 427+ 7124 3C           		inc 	a
 428+ 7125 EE 03        		xor		%11
 429+ 7127 3D           		dec		a
 430+ 7128 32 97 73     		ld		(RWTSDrive), a
 431+ 712B
 432+ 712B              CopyDiskReadEnd:
 433+ 712B              	;restore initial counter and initial block number array position
 434+ 712B DD E1        	pop		ix
 435+ 712D C1           	pop		bc
 436+ 712E 11 FB 8E     	ld		de, CopyDiskBuf
 437+ 7131 C5           	push	bc
 438+ 7132
 439+ 7132              CopyDiskLoopWriteLoop:
 440+ 7132 DD 6E 00     		ld		l, (ix)
 441+ 7135 DD 66 01     		ld		h, (ix+1)
 442+ 7138 DD 23        		inc		ix
 443+ 713A DD 23        		inc		ix
 444+ 713C
 445+ 713C D5           		push	de
 446+ 713D C5           		push	bc
 447+ 713E CD BA 70     			call	WriteFSBlock		;Stop on error or continue?
 448+ 7141 C1           		pop		bc
 449+ 7142 D1           		pop		de
 450+ 7143
 451+ 7143              		;+2048
 452+ 7143 7A           		ld		a, d
 453+ 7144 C6 08        		add		8
 454+ 7146 57           		ld		d, a
 455+ 7147
 456+ 7147 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 7149
 458+ 7149              CopyDiskWriteEnd:
 459+ 7149 C1           	pop		bc
 460+ 714A 48           	ld		c, b
 461+ 714B 06 00        	ld		b, 0
 462+ 714D
 463+ 714D              	;Decrease number of blocks read by now.
 464+ 714D 2A 11 89     	ld		hl, (UsedBlockListCnt)
 465+ 7150 B7           	or		a
 466+ 7151 ED 42        	sbc		hl, bc
 467+ 7153 22 11 89     	ld		(UsedBlockListCnt), hl
 468+ 7156
 469+ 7156 7D           	ld		a, l
 470+ 7157 B4           	or		h
 471+ 7158 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 715A
 473+ 715A              	;Check if selection is 1=single drive or 2=dual drive
 474+ 715A 3A BA 80     	ld		a, (CopySelOption)
 475+ 715D FE 31        	cp		'1'
 476+ 715F 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 7161
 478+ 7161              	;Prompt for disk change
 479+ 7161 CD CF 74     	call	PromptDiskChangeSrc
 480+ 7164 3A 97 73     	ld		a, (RWTSDrive)
 481+ 7167 CD BF 73     	call	BDOSInit
 482+ 716A C3 CE 70     	jp		CopyDiskLoop
 483+ 716D
 484+ 716D              CopyDiskDualDrive2:
 485+ 716D              	;alternate drive again
 486+ 716D 3A 97 73     	ld		a, (RWTSDrive)
 487+ 7170 3C           	inc		a
 488+ 7171 EE 03        	xor		%11
 489+ 7173 3D           	dec		a
 490+ 7174 32 97 73     	ld		(RWTSDrive), a
 491+ 7177 C3 CE 70     	jp		CopyDiskLoop
 492+ 717A
 493+ 717A              CopyDiskEnd:
 494+ 717A 06 01        	ld		b, 1
 495+ 717C CD E9 79     	call	ClearNMsgLines
 496+ 717F C9           	ret
 497+ 7180
 498+ 7180              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 7180              ;Copies the current disk blocks to COM port.
 500+ 7180              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 7180              CopyDiskToCOM:
 502+ 7180              	;Get list of used blocks in current disk, max 632 bytes
 503+ 7180 CD 55 70     	call	ReadUsedBlocksList
 504+ 7183
 505+ 7183              	;Send block count and block indexes
 506+ 7183 2A 11 89     	ld		hl, (UsedBlockListCnt)
 507+ 7186 29           	add		hl, hl
 508+ 7187 23           	inc		hl
 509+ 7188 23           	inc		hl
 510+ 7189 44           	ld		b, h
 511+ 718A 4D           	ld		c, l
 512+ 718B 21 11 89     	ld		hl, UsedBlockListCnt
 513+ 718E CD C8 7D     	call	SERTB
 514+ 7191
 515+ 7191 DD 21 13 89  	ld		ix, UsedBlockListBlk
 516+ 7195
 517+ 7195              CopyDiskToCOMLoop:
 518+ 7195              	;Print block count left
 519+ 7195 2A 11 89     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 7198 11 49 80     	ld		de, MsgBlocksLeft
 521+ 719B CD 62 6F     	call	Byte2Txt
 522+ 719E 21 49 80     	ld		hl, MsgBlocksLeft
 523+ 71A1 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 71A4 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 71A6 CD 65 78     	call	PrintStrClr
 526+ 71A9
 527+ 71A9              	;Read block into buffer
 528+ 71A9 DD 6E 00     	ld		l, (ix)
 529+ 71AC DD 66 01     	ld		h, (ix+1)
 530+ 71AF 11 FB 8E     	ld		de, CopyDiskBuf
 531+ 71B2 DD E5        	push	ix
 532+ 71B4 CD AD 70     		call	ReadFSBlock
 533+ 71B7 DD E1        	pop		ix
 534+ 71B9 DD 23        	inc		ix
 535+ 71BB DD 23        	inc		ix
 536+ 71BD
 537+ 71BD              	;Send block buffer
 538+ 71BD 21 FB 8E     	ld		hl, CopyDiskBuf
 539+ 71C0 01 00 08     	ld		bc, AU_SZ
 540+ 71C3 CD C8 7D     	call	SERTB
 541+ 71C6
 542+ 71C6 ED 4B 11 89  	ld		bc, (UsedBlockListCnt)
 543+ 71CA 0B           	dec		bc
 544+ 71CB ED 43 11 89  	ld		(UsedBlockListCnt), bc
 545+ 71CF
 546+ 71CF DD E5        	push	ix
 547+ 71D1 CD 04 78     		call	KbdHit
 548+ 71D4 DD E1        	pop		ix
 549+ 71D6 D8           	ret		c
 550+ 71D7
 551+ 71D7 78           	ld		a, b
 552+ 71D8 B1           	or		c
 553+ 71D9 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 71DB
 555+ 71DB C9           	ret
 556+ 71DC
 557+ 71DC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 71DC              CopyDiskFromCOM:
 559+ 71DC              	;Receive block count.
 560+ 71DC 21 11 89     	ld		hl, UsedBlockListCnt
 561+ 71DF 01 02 00     	ld		bc, 2
 562+ 71E2 1E 00        	ld		e, 0
 563+ 71E4 CD 95 7D     	call	SERRB
 564+ 71E7
 565+ 71E7              	;Receive block indexes.
 566+ 71E7 2A 11 89     	ld		hl, (UsedBlockListCnt)
 567+ 71EA 29           	add		hl, hl
 568+ 71EB 44           	ld		b, h
 569+ 71EC 4D           	ld		c, l
 570+ 71ED 21 13 89     	ld		hl, UsedBlockListBlk
 571+ 71F0 1E 00        	ld		e, 0
 572+ 71F2 CD 95 7D     	call	SERRB
 573+ 71F5
 574+ 71F5              	;Read each block by index and write to disk
 575+ 71F5 DD 21 13 89  	ld		ix, UsedBlockListBlk
 576+ 71F9
 577+ 71F9              CopyDiskFromCOMLoop:
 578+ 71F9              	;Print block count left
 579+ 71F9 2A 11 89     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 71FC 11 49 80     	ld		de, MsgBlocksLeft
 581+ 71FF CD 62 6F     	call	Byte2Txt
 582+ 7202 21 49 80     	ld		hl, MsgBlocksLeft
 583+ 7205 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 7208 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 720A CD 65 78     	call	PrintStrClr
 586+ 720D
 587+ 720D              	;Read block buffer
 588+ 720D 21 FB 8E     	ld		hl, CopyDiskBuf
 589+ 7210 01 00 08     	ld		bc, AU_SZ
 590+ 7213 1E 00        	ld		e, 0
 591+ 7215 CD 95 7D     	call	SERRB
 592+ 7218
 593+ 7218              	;Write block to disk
 594+ 7218 DD 6E 00     	ld		l, (ix)
 595+ 721B DD 66 01     	ld		h, (ix+1)
 596+ 721E 11 FB 8E     	ld		de, CopyDiskBuf
 597+ 7221 DD E5        	push	ix
 598+ 7223 CD BA 70     		call	WriteFSBlock			;Stop on error or continue?
 599+ 7226 DD E1        	pop		ix
 600+ 7228 DD 23        	inc		ix
 601+ 722A DD 23        	inc		ix
 602+ 722C
 603+ 722C ED 4B 11 89  	ld		bc, (UsedBlockListCnt)
 604+ 7230 0B           	dec		bc
 605+ 7231 ED 43 11 89  	ld		(UsedBlockListCnt), bc
 606+ 7235
 607+ 7235 DD E5        	push	ix
 608+ 7237 CD 04 78     		call	KbdHit
 609+ 723A DD E1        	pop		ix
 610+ 723C D8           	ret		c
 611+ 723D
 612+ 723D 78           	ld		a, b
 613+ 723E B1           	or		c
 614+ 723F 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 7241 C9           	ret
 616+ 7242
 617+ 7242              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 7242
 619+ 7242              ;Compare string at HL with the one at DE, max length B
 620+ 7242              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 7242              ;OUT: z flag, set = match, reset = mismatch
 622+ 7242              StrCmp:
 623+ 7242 E5           	push hl
 624+ 7243 D5           	push de
 625+ 7244              Compare:
 626+ 7244 1A           		ld a, (de)
 627+ 7245 BE           		cp (hl)
 628+ 7246 20 04        		jr nz, MisMatch
 629+ 7248 23           		inc hl
 630+ 7249 13           		inc de
 631+ 724A 10 F8        		djnz Compare
 632+ 724C              MisMatch:
 633+ 724C D1           	pop de
 634+ 724D E1           	pop hl
 635+ 724E C9           	ret
 636+ 724F
 637+ 724F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 724F
 639+ 724F              ;Read a file into a buffer, sector by sector.
 640+ 724F              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 724F              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 724F              ;In: HL = Name address, DE = buffer
 643+ 724F              IF1FileLoad:
 644+ 724F D5           	push	de
 645+ 7250 22 DC 5C     		ld (FSTR1), hl
 646+ 7253 26 00        		ld h, 0
 647+ 7255 3A 97 73     		ld a, (RWTSDrive)
 648+ 7258 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 7259 6F           		ld	l, a
 650+ 725A 22 D6 5C     		ld (DSTR1), hl
 651+ 725D 2E 0B        		ld l,NAMELEN
 652+ 725F 22 DA 5C     		ld (NSTR1), hl
 653+ 7262 CF           		rst 08
 654+ 7263 33           		DEFB 51			;open disk channel
 655+ 7264
 656+ 7264 CF           		rst		8
 657+ 7265 35           		defb	53		;read sector
 658+ 7266 D1           	pop		de
 659+ 7267 30 27        	jr		nc, FileFree
 660+ 7269
 661+ 7269 DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 726C FE 04        	cp		TEXT_TYPE
 663+ 726E 30 12        	jr		nc, FileLoadNoHeader
 664+ 7270
 665+ 7270              FileLoadHeader:
 666+ 7270 DD E5        	push	ix
 667+ 7272 E1           	pop		hl
 668+ 7273 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 7276 09           	add		hl, bc
 670+ 7277 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 727A ED B0        	ldir
 672+ 727C
 673+ 727C              FileReadLoop:
 674+ 727C D5           	push	de
 675+ 727D CF           		rst		8
 676+ 727E 35           		defb	53		;read sector
 677+ 727F D1           	pop		de
 678+ 7280 30 0E        	jr		nc, FileFree
 679+ 7282
 680+ 7282              FileLoadNoHeader:
 681+ 7282 DD E5        	push	ix
 682+ 7284 E1           	pop		hl
 683+ 7285 01 32 00     	ld		bc, CH_DATA
 684+ 7288 09           	add		hl, bc
 685+ 7289 01 00 01     	ld		bc, SECT_SZ
 686+ 728C ED B0        	ldir
 687+ 728E 18 EC        	jr		FileReadLoop
 688+ 7290
 689+ 7290              FileFree:
 690+ 7290 D5           	push	de
 691+ 7291 CF           	rst		8
 692+ 7292 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 7293 D1           	pop		de
 694+ 7294 C9           	ret
 695+ 7295              IF1FileLoadEnd:
 696+ 7295
 697+ 7295              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 7295              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 7295              ;Out: A = error code, 0=OK
 700+ 7295              ReadDiskSectors:
 701+ 7295 C5           	push bc
 702+ 7296 E5           		push hl
 703+ 7297 D5           			push de
 704+ 7298 CD E1 6F     				call ReadOneDiskSector
 705+ 729B D1           			pop de
 706+ 729C E1           		pop hl
 707+ 729D
 708+ 729D 14           		inc d
 709+ 729E 24           		inc h
 710+ 729F C1           	pop bc
 711+ 72A0
 712+ 72A0 3A A2 73     	ld	a, (RWTSRes)
 713+ 72A3 B7           	or	a
 714+ 72A4 C0           	ret nz
 715+ 72A5
 716+ 72A5 10 EE        	djnz ReadDiskSectors
 717+ 72A7 C9           	ret
 718+ 72A8
 719+ 72A8              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 72A8              ;Out: A = error code, 0=OK
 721+ 72A8              WriteDiskSectors:
 722+ 72A8 C5           	push bc
 723+ 72A9 E5           		push hl
 724+ 72AA D5           			push de
 725+ 72AB CD EC 6F     				call WriteOneDiskSector
 726+ 72AE D1           			pop de
 727+ 72AF E1           		pop hl
 728+ 72B0
 729+ 72B0 14           		inc d
 730+ 72B1 24           		inc h
 731+ 72B2 C1           	pop bc
 732+ 72B3
 733+ 72B3 3A A2 73     	ld	a, (RWTSRes)
 734+ 72B6 B7           	or	a
 735+ 72B7 C0           	ret nz
 736+ 72B8
 737+ 72B8 10 EE        	djnz WriteDiskSectors
 738+ 72BA C9           	ret
 739+ 72BB
 740+ 72BB
 741+ 72BB              ;Reads disk catalog
 742+ 72BB              ReadCatalogTrack:
 743+ 72BB 21 FB 8E     	ld hl, TrackBuf
 744+ 72BE 11 00 00     	ld de, 0
 745+ 72C1 06 10        	ld b, SPT
 746+ 72C3
 747+ 72C3 CD 95 72     	call ReadDiskSectors
 748+ 72C6 B7           	or   a
 749+ 72C7 C0           	ret  nz
 750+ 72C8
 751+ 72C8              	;Sync with BDOS, to avoid disk R/O error on disk change
 752+ 72C8 F5           	push  af
 753+ 72C9 3A 97 73     		ld  a, (RWTSDrive)
 754+ 72CC CD C2 73     		call BDOSSelectDisk
 755+ 72CF CD BF 73     		call BDOSInit
 756+ 72D2 F1           	pop   af
 757+ 72D3 C9           	ret
 758+ 72D4
 759+ 72D4
 760+ 72D4
 761+ 72D4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 762+ 72D4
 763+ 72D4              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 764+ 72D4              FindCache:
 765+ 72D4 06 0B        	ld		b, NAMELEN
 766+ 72D6 CD 42 72     	call	StrCmp			;find the file to wich this extension belongs
 767+ 72D9 C8           	ret		z
 768+ 72DA
 769+ 72DA 0D           	dec		c
 770+ 72DB 20 02        	jr		nz, CacheNotFinished
 771+ 72DD B1           	or		c
 772+ 72DE C9           	ret
 773+ 72DF
 774+ 72DF              CacheNotFinished:
 775+ 72DF 01 19 00     	ld		bc, CACHE_SZ
 776+ 72E2 09           	add		hl, bc			;to the next cache line
 777+ 72E3 18 EF        	jr		FindCache
 778+ 72E5
 779+ 72E5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 780+ 72E5
 781+ 72E5              	;ld		ix, (SelFileCache)
 782+ 72E5              ReadFileHeader:
 783+ 72E5 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 784+ 72E8 B7           	or		a
 785+ 72E9 C0           	ret		nz				;return if already read
 786+ 72EA
 787+ 72EA DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 788+ 72ED DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 789+ 72F0 7C           	ld		a, h
 790+ 72F1 B5           	or		l
 791+ 72F2 28 46        	jr		z, ReadHeaderEnd
 792+ 72F4
 793+ 72F4 CD 08 70     	call	AU2TS
 794+ 72F7 50           	ld		d, b
 795+ 72F8 59           	ld		e, c
 796+ 72F9 21 FB 8E     	ld		hl, DataBuf
 797+ 72FC DD E5        	push	ix
 798+ 72FE DD E5        	push	ix
 799+ 7300 CD E1 6F     		call	ReadOneDiskSector
 800+ 7303 E1           	pop		hl
 801+ 7304 DD E1        	pop		ix
 802+ 7306
 803+ 7306 E5           	push	hl
 804+ 7307 21 FB 8E     		ld		hl, DataBuf
 805+ 730A CD 3E 73     		call	IsFileHeaderValid
 806+ 730D E1           	pop		hl
 807+ 730E B7           	or		a
 808+ 730F 28 14        	jr		z, ReadFileHeaderIsTextFile
 809+ 7311
 810+ 7311 01 10 00     	ld		bc, CACHE_HDR
 811+ 7314 09           	add		hl, bc
 812+ 7315 EB           	ex		hl, de
 813+ 7316 21 FB 8E     	ld		hl, DataBuf
 814+ 7319 01 09 00     	ld		bc, HDR_SZ
 815+ 731C ED B0        	ldir
 816+ 731E
 817+ 731E              	;For text files, read file size as reported by BDOS, since we don't have a header.
 818+ 731E 3E 03        	ld		a, BYTE_TYPE
 819+ 7320 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 820+ 7323 30 15        	jr		nc, ReadHeaderEnd
 821+ 7325
 822+ 7325              ReadFileHeaderIsTextFile:
 823+ 7325 DD E5        	push	ix
 824+ 7327 DD E5        	push	ix
 825+ 7329 E1           	pop		hl
 826+ 732A CD 19 74     		call	GetFileSize
 827+ 732D DD E1        	pop		ix
 828+ 732F DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 829+ 7332 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 830+ 7335 3E 04        	ld		a, TEXT_TYPE
 831+ 7337 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 832+ 733A
 833+ 733A              ReadHeaderEnd:
 834+ 733A DD 34 0F     	inc		(ix + CACHE_FLAG)
 835+ 733D C9           	ret
 836+ 733E
 837+ 733E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 838+ 733E              ;Checks if the file header is valid. For now it checks to not have all 0s.
 839+ 733E              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 840+ 733E              ;In: HL = header
 841+ 733E              ;Out: A > 0 if valid
 842+ 733E              IsFileHeaderValid:
 843+ 733E              	IFUSED
 844+ 733E AF           	xor		a
 845+ 733F 06 09        	ld		b, HDR_SZ
 846+ 7341              IsFileHeaderValidLoop:
 847+ 7341 B6           	or		(hl)
 848+ 7342 23           	inc		hl
 849+ 7343 10 FC        	djnz	IsFileHeaderValidLoop
 850+ 7345
 851+ 7345 C9           	ret
 852+ 7346              	ENDIF
 853+ 7346
 854+ 7346              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 855+ 7346
 856+ 7346              ;IN: HL = address from IF1 to call
 857+ 7346              IF1Call:
 858+ 7346 22 ED 5C     	LD   (HD11), HL
 859+ 7349 CF           	RST  8
 860+ 734A 32           	DEFB 50
 861+ 734B C9           	RET
 862+ 734C
 863+ 734C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864+ 734C
 865+ 734C              ;Load a program from disk
 866+ 734C              ;IN: HL = file name addr
 867+ 734C              LoadProgram:
 868+ 734C 22 DC 5C     	LD   (FSTR1), HL
 869+ 734F 26 00        	LD   H, 0
 870+ 7351 2E 0B        	LD   L, NAMELEN
 871+ 7353 22 DA 5C     	LD   (NSTR1), HL
 872+ 7356 3A 97 73     	LD	 A, (RWTSDrive)
 873+ 7359 3C           	INC  A					;Adapt for BASIC drive number
 874+ 735A 6F           	LD   L, A
 875+ 735B 22 D6 5C     	LD   (DSTR1), HL
 876+ 735E 21 41 0A     	LD   HL, LOAD_ADDR
 877+ 7361 CD 46 73     	CALL IF1Call
 878+ 7364 C9           	RET
 879+ 7365
 880+ 7365              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 881+ 7365
 882+ 7365              SetFastKeys:
 883+ 7365 21 09 5C     	ld		hl, REPDEL
 884+ 7368 11 0F 01     	ld		de, (1 << 8) | 15
 885+ 736B 73 23 72 2B  	ld		(hl), de
 886+ 736F
 887+ 736F C9           	ret
 888+ 7370
 889+ 7370
 890+ 7370              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 891+ 7370              ;Reads the error message string from IF1 ROM.
 892+ 7370              GetErrMsg:
 893+ 7370 3C           	inc		a
 894+ 7371 08           	ex		af, af'
 895+ 7372
 896+ 7372 21 78 73     	ld		hl, IF1Paged			;page-in IF1
 897+ 7375 C3 46 73     	jp		IF1Call
 898+ 7378
 899+ 7378              IF1Paged:
 900+ 7378 21 60 02     	ld		hl, ERRMSG
 901+ 737B 08           	ex		af, af'
 902+ 737C B7           	or		a
 903+ 737D 28 0B        	jr		z, SaveMsg
 904+ 737F
 905+ 737F 06 00        	ld		b, 0
 906+ 7381              SearchMsgEnd:
 907+ 7381 CB 7E        	bit		7, (hl)
 908+ 7383 23           	inc		hl
 909+ 7384 28 FB        	jr		z, SearchMsgEnd
 910+ 7386
 911+ 7386 04           	inc		b
 912+ 7387 B8           	cp		b
 913+ 7388 20 F7        	jr		nz, SearchMsgEnd
 914+ 738A
 915+ 738A              SaveMsg:
 916+ 738A 11 FB 8E     	ld		de, DataBuf
 917+ 738D              CopyMsg:
 918+ 738D 7E           	ld		a, (hl)
 919+ 738E CB 7F        	bit		7, a
 920+ 7390 12           	ld		(de), a
 921+ 7391 23           	inc		hl
 922+ 7392 13           	inc		de
 923+ 7393 28 F8        	jr		z, CopyMsg
 924+ 7395
 925+ 7395 C9           	ret
 926+ 7396
 927+ 7396              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 928+ 7396
 929+ 7396              ;RWTS routine I/O block
 930+ 7396              RWTSParams:
 931+ 7396 01           RWTSBlockType	DEFB	1							;?
 932+ 7397 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 933+ 7398 00           RWTSVolNo		DEFB	0							;?
 934+ 7399 00           RWTSTrack		DEFB	0
 935+ 739A 00           RWTSSector		DEFB	0
 936+ 739B 00 00        RWTSDMA			DEFW	0
 937+ 739D 32 29        RWTSExtBuf		DEFW	$2932
 938+ 739F              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 939+ 739F              	IFDEF _REAL_HW_
 940+ 739F A9 73        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 941+ 73A1              	ELSE
 942+ 73A1 ~            RWTSPrmTbl		DEFW	$1f2a
 943+ 73A1              	ENDIF
 944+ 73A1 01           RWTSCmd			DEFB	RWTS_CMD_READ
 945+ 73A2              ;Results
 946+ 73A2 00           RWTSRes			DEFB	0
 947+ 73A3 00           RWTSResVolNo	DEFB	0
 948+ 73A4 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 948+ 73A8 00
 949+ 73A9
 950+ 73A9              ;Param. table, usualy found in ROM.
 951+ 73A9              	IFDEF _REAL_HW_
 952+ 73A9              BasPrmTbl:
 953+ 73A9 01           PrmDevType		DEFB	$01		;$01
 954+ 73AA 01           PrmStepRate		DEFB	$01		;$0D	(milisec)
 955+ 73AB 01           PrmHeadLoad		DEFB	$01		;$23	(milisec)
 956+ 73AC 01           PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 957+ 73AD AF 73        PrmIntrlvTbl	DEFW	InterleaveTbl
 958+ 73AF 01 03 05 07  InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 958+ 73B3 09 0B 0D 0F
 958+ 73B7 02 04 06 08
 958+ 73BB 0A 0C 0E 10
 959+ 73BF              	ENDIF
 960+ 73BF
 961+ 73BF              	endif
# file closed: if1.asm
1248  73BF              	include "bdos.asm"
# file opened: bdos.asm
   1+ 73BF              ;BDOS functions - similar to CP/M
   2+ 73BF
   3+ 73BF              	IFNDEF	_BDOS_
   4+ 73BF              	DEFINE	_BDOS_
   5+ 73BF
   6+ 73BF              	include "if1.asm"
# file opened: if1.asm
   1++73BF              ;HC IF1 routines and constants
   2++73BF
   3++73BF              ;IF1 routines error codes, also returned by BASIC commands
   4++73BF              ;12 = Writing to a 'read' file
   5++73BF              ;13 = Reading a 'write' file
   6++73BF              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++73BF              ;15 = Disk full (disk or catalog full)
   8++73BF              ;16 = Disk error (hardware error)
   9++73BF              ;17 = File not found
  10++73BF              ;23 = Disk R/O (disk change detected, software R/O)
  11++73BF              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++73BF
  13++73BF              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++73BF              ;00h = OK
  15++73BF              ;08h = cannot format disk
  16++73BF              ;10h = disk protected (read-only?)
  17++73BF              ;20h = volume error
  18++73BF              ;40h = drive error
  19++73BF              ;80h = reading error
  20++73BF              ;Codes I encountered:
  21++73BF              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++73BF
  23++73BF
  24++73BF              	ifndef	_DISK_
  25++73BF ~            	define	_DISK_
  26++73BF ~
  27++73BF ~            	include	"math.asm"
  28++73BF ~
  29++73BF ~            DRIVE_CUR_BAS	EQU 0
  30++73BF ~            DRIVE_A_BAS		EQU	1
  31++73BF ~            DRIVE_B_BAS		EQU	2
  32++73BF ~            DRIVE_A_CPM		EQU	0
  33++73BF ~            DRIVE_B_CPM		EQU	1
  34++73BF ~            ;Disk geometry stuff
  35++73BF ~            SPT				EQU	16			;sectors per track
  36++73BF ~            SECT_SZ			EQU	256			;sector size in bytes
  37++73BF ~            TRACK_CNT		EQU	80			;track count
  38++73BF ~            HEAD_CNT		EQU	2			;disk face count
  39++73BF ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++73BF ~            EXT_SZ			EQU	32			;directory entry size
  41++73BF ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++73BF ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++73BF ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++73BF ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++73BF ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++73BF ~            REC_SZ			EQU 128			;cp/m record size
  47++73BF ~            DEL_MARKER		EQU	$E5
  48++73BF ~
  49++73BF ~
  50++73BF ~            ;Extension structure (directory entry)
  51++73BF ~            EXT_DEL_FLAG	EQU	0
  52++73BF ~            EXT_NAME		EQU 1
  53++73BF ~            EXT_IDX			EQU 12
  54++73BF ~            EXT_S1			EQU 13
  55++73BF ~            EXT_S2			EQU 14
  56++73BF ~            EXT_RC			EQU	15
  57++73BF ~            EXT_AU0			EQU	16
  58++73BF ~            EXT_AU1			EQU	18
  59++73BF ~            EXT_AU2			EQU	20
  60++73BF ~            EXT_AU3			EQU	22
  61++73BF ~            EXT_AU4			EQU	24
  62++73BF ~            EXT_AU5			EQU	26
  63++73BF ~            EXT_AU6			EQU	28
  64++73BF ~            EXT_AU7			EQU	30
  65++73BF ~            EXT_SIZE		EQU 32
  66++73BF ~
  67++73BF ~            ;FCB structure
  68++73BF ~            FCB_DRIVE		EQU 0
  69++73BF ~            FCB_NAME		EQU EXT_NAME
  70++73BF ~            FCB_EX_IDX		EQU EXT_IDX
  71++73BF ~            FCB_S1			EQU EXT_S1
  72++73BF ~            FCB_S2			EQU EXT_S2
  73++73BF ~            FCB_RC			EQU	EXT_RC
  74++73BF ~            FCB_AU			EQU	EXT_AU0
  75++73BF ~            FCB_CR			EQU	32
  76++73BF ~            FCB_R0			EQU 33
  77++73BF ~            FCB_R1			EQU 34
  78++73BF ~            FCB_R2			EQU 35
  79++73BF ~            FCB_SIZE		EQU 36
  80++73BF ~
  81++73BF ~
  82++73BF ~
  83++73BF ~            ;System variables for disk
  84++73BF ~            DSTR1			EQU	$5CD6		;drive
  85++73BF ~            FSTR1			EQU	$5CDC		;file name
  86++73BF ~            NSTR1			EQU	$5CDA		;name length
  87++73BF ~            HD11			EQU	$5CED		;BDOS argument
  88++73BF ~            COPIES			EQU	$5CEF		;BDOS function
  89++73BF ~
  90++73BF ~            ERRSP			EQU $5C3D
  91++73BF ~            ERRNR			EQU $5C3A
  92++73BF ~            ERRMSG			EQU	$0260
  93++73BF ~
  94++73BF ~            PROG			EQU $5C53
  95++73BF ~            VARS			EQU	$5C4B
  96++73BF ~            STKEND			EQU	$5C65
  97++73BF ~
  98++73BF ~            PRN_BUF			EQU	23296
  99++73BF ~
 100++73BF ~            REPDEL			EQU	23561
 101++73BF ~            REPPER			EQU	23562
 102++73BF ~            PIP				EQU	23609
 103++73BF ~
 104++73BF ~
 105++73BF ~            ;RWTS routine commands
 106++73BF ~            RWTS_CMD_POS	EQU	0			;position head
 107++73BF ~            RWTS_CMD_READ	EQU	1			;read sector
 108++73BF ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++73BF ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++73BF ~
 111++73BF ~
 112++73BF ~            ;File name stuff
 113++73BF ~            NAMELEN			EQU	11			;name length
 114++73BF ~            RO_POS			EQU	8			;read-only attribute position in name
 115++73BF ~            SYS_POS			EQU	9			;system attribute position in name
 116++73BF ~
 117++73BF ~            ;File types (first byte in header)
 118++73BF ~            PROG_TYPE		EQU	0			;program
 119++73BF ~            NUMB_TYPE		EQU	1			;number array
 120++73BF ~            CHAR_TYPE		EQU	2			;char array
 121++73BF ~            BYTE_TYPE		EQU	3			;bytes
 122++73BF ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++73BF ~
 124++73BF ~            ;File header offsets
 125++73BF ~            HDR_TYPE		EQU	0
 126++73BF ~            HDR_LEN			EQU 1
 127++73BF ~            HDR_ADDR		EQU 3
 128++73BF ~            HDR_PLEN		EQU	5
 129++73BF ~            HDR_LINE		EQU 7
 130++73BF ~            HDR_SZ			EQU	9
 131++73BF ~
 132++73BF ~            ;BASIC disk channel structure
 133++73BF ~            CH_RW_FLAG		EQU 11
 134++73BF ~            CH_FCB			EQU	12
 135++73BF ~            CH_DATA			EQU	50
 136++73BF ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++73BF ~
 138++73BF ~            CACHE_NAME		EQU	0					;11B
 139++73BF ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++73BF ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++73BF ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++73BF ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++73BF ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++73BF ~
 145++73BF ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++73BF ~
 147++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++73BF ~            IF1Init:
 149++73BF ~            	rst		08
 150++73BF ~            	defb	49		;create system variables
 151++73BF ~            	ret
 152++73BF ~
 153++73BF ~            ;ReadWriteTrackSector
 154++73BF ~            ;A=command: 0, 1, 2, 4
 155++73BF ~            RWTS:
 156++73BF ~            	ld (RWTSCmd), a
 157++73BF ~            	ld hl, RWTSParams
 158++73BF ~            	ld (HD11), hl
 159++73BF ~            	rst 08
 160++73BF ~            	DEFB 58
 161++73BF ~            	ret
 162++73BF ~
 163++73BF ~
 164++73BF ~            ;D = sector, E = track
 165++73BF ~            ;HL = dma
 166++73BF ~            ReadOneDiskSector:
 167++73BF ~            	ld (RWTSDMA), hl
 168++73BF ~            	ld (RWTSTrack), de
 169++73BF ~            	;ld (RWTSDrive), a
 170++73BF ~            	ld a, RWTS_CMD_READ
 171++73BF ~            	jr	RWTS
 172++73BF ~
 173++73BF ~            ;D = sector, E = track
 174++73BF ~            ;HL = dma
 175++73BF ~            WriteOneDiskSector:
 176++73BF ~            	ld (RWTSDMA), hl
 177++73BF ~            	ld (RWTSTrack), de
 178++73BF ~            	;ld (RWTSDrive), a
 179++73BF ~            	ld a, RWTS_CMD_WRITE
 180++73BF ~            	jr	RWTS
 181++73BF ~
 182++73BF ~            FormatDisk:
 183++73BF ~            	ld		hl, DataBuf
 184++73BF ~            	ld		(hl), DEL_MARKER
 185++73BF ~            	ld 		(RWTSDMA), hl
 186++73BF ~            	ld 		a, RWTS_CMD_FMT
 187++73BF ~            	call	RWTS
 188++73BF ~            	ld		a, (RWTSRes)
 189++73BF ~            	ret
 190++73BF ~
 191++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++73BF ~
 193++73BF ~            ;Allocation unit no. to track/sector
 194++73BF ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++73BF ~            ;IN:  HL=alloc. unit no.
 196++73BF ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++73BF ~            AU2TS:
 198++73BF ~            	ld c, SPT/SPAL
 199++73BF ~            	call Div					;A = sector
 200++73BF ~            	push af
 201++73BF ~            		/*
 202++73BF ~            		ld c, HEAD_CNT
 203++73BF ~            		call Div				;L = track, A = head (0 or 1)
 204++73BF ~            		*/
 205++73BF ~            		xor a
 206++73BF ~            		rr h
 207++73BF ~            		rr l
 208++73BF ~            		rr a
 209++73BF ~
 210++73BF ~            		ld c, l
 211++73BF ~            		ld b, 0
 212++73BF ~            		or a
 213++73BF ~            		jr z, Track0
 214++73BF ~            		ld b, SPT
 215++73BF ~            Track0:
 216++73BF ~            	pop af
 217++73BF ~            	or a
 218++73BF ~            	jr z, FirstAU
 219++73BF ~            	ld a, SPAL
 220++73BF ~            FirstAU:
 221++73BF ~            	add a, b
 222++73BF ~            	ld  b, a
 223++73BF ~            	ret
 224++73BF ~
 225++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++73BF ~
 227++73BF ~            ;Checks the allocation units number used in extension
 228++73BF ~            ;IN:	IX = extension addr
 229++73BF ~            ;OUT:	B = no. of allocation units used
 230++73BF ~            ;		C = no. of records used in ext.
 231++73BF ~            ;		HL = first alloc. unit no.
 232++73BF ~            ;		DE = last alloc. unit no.
 233++73BF ~            CheckExtAlloc:
 234++73BF ~            	push ix
 235++73BF ~            		ld bc, EXT_RC
 236++73BF ~            		add ix, bc
 237++73BF ~            		ld c, (ix)			;save rec. no.
 238++73BF ~            		inc ix
 239++73BF ~            		ld l, (ix)
 240++73BF ~            		ld h, (ix + 1)
 241++73BF ~            		ld b, EXT_AU_CNT
 242++73BF ~            CheckAU:
 243++73BF ~            		ld a, (ix)
 244++73BF ~            		or (ix + 1)
 245++73BF ~            		jr z, CheckAUEnd
 246++73BF ~            		ld e, (ix)
 247++73BF ~            		ld d, (ix + 1)
 248++73BF ~            		inc ix
 249++73BF ~            		inc ix
 250++73BF ~            		djnz CheckAU
 251++73BF ~            CheckAUEnd:
 252++73BF ~            		ld a, EXT_AU_CNT
 253++73BF ~            		sub b
 254++73BF ~            		ld b, a
 255++73BF ~            	pop ix
 256++73BF ~            	ret
 257++73BF ~
 258++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++73BF ~
 260++73BF ~            ;Input: TrackBuffer
 261++73BF ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++73BF ~            ReadUsedBlocksList:
 263++73BF ~            	ld		ix, TrackBuf			;source buffer
 264++73BF ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++73BF ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 266++73BF ~            	ld		de, 2					;counter of used blocks, start with 2
 267++73BF ~            	ld		(hl), e
 268++73BF ~            	inc		hl
 269++73BF ~            	ld		(hl), d
 270++73BF ~            	inc		hl
 271++73BF ~
 272++73BF ~            	;Add blocks 0 and 1 for directory
 273++73BF ~            	ld		de, 0
 274++73BF ~            	ld		(hl), e
 275++73BF ~            	inc		hl
 276++73BF ~            	ld		(hl), d
 277++73BF ~            	inc		hl
 278++73BF ~
 279++73BF ~            	inc		de
 280++73BF ~            	ld		(hl), e
 281++73BF ~            	inc		hl
 282++73BF ~            	ld		(hl), d
 283++73BF ~            	inc		hl
 284++73BF ~
 285++73BF ~            ReadUsedBlocksLoop:
 286++73BF ~            	xor		a
 287++73BF ~            	cp		(ix)
 288++73BF ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++73BF ~
 290++73BF ~            	push	ix
 291++73BF ~            	push	bc
 292++73BF ~            		ld		b, EXT_AU_CNT
 293++73BF ~            		ld		de, EXT_AU0
 294++73BF ~            		add		ix, de
 295++73BF ~
 296++73BF ~            ReadUsedBlocksLoop2:
 297++73BF ~            		ld		e, (ix)
 298++73BF ~            		ld		d, (ix+1)
 299++73BF ~            		ld		a, e
 300++73BF ~            		or		d
 301++73BF ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++73BF ~
 303++73BF ~            		ld		(hl), e
 304++73BF ~            		inc		hl
 305++73BF ~            		ld		(hl), d
 306++73BF ~            		inc		hl
 307++73BF ~
 308++73BF ~            		inc		ix
 309++73BF ~            		inc		ix
 310++73BF ~
 311++73BF ~            		ld		de, (UsedBlockListCnt)
 312++73BF ~            		inc		de
 313++73BF ~            		ld		(UsedBlockListCnt), de
 314++73BF ~
 315++73BF ~            		djnz	ReadUsedBlocksLoop2
 316++73BF ~
 317++73BF ~
 318++73BF ~            ReadUsedBlocksSkip:
 319++73BF ~            	pop		bc
 320++73BF ~            	pop		ix
 321++73BF ~            ReadUsedBlocksSkip2:
 322++73BF ~            	ld		de, EXT_SZ
 323++73BF ~            	add		ix, de
 324++73BF ~
 325++73BF ~            	dec		bc
 326++73BF ~            	ld		a, b
 327++73BF ~            	or		c
 328++73BF ~            	jr		nz, ReadUsedBlocksLoop
 329++73BF ~
 330++73BF ~            	ret
 331++73BF ~
 332++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++73BF ~            ;Reads 8 sectors for an AU
 334++73BF ~            ;HL = block number, DE = destination buffer
 335++73BF ~            ReadFSBlock:
 336++73BF ~            	push	de
 337++73BF ~            		call	AU2TS		;B=sector, C=track
 338++73BF ~            	pop		hl				;HL=dest
 339++73BF ~
 340++73BF ~            	ld		d, b
 341++73BF ~            	ld		e, c
 342++73BF ~            	ld		b, SPAL
 343++73BF ~
 344++73BF ~            	call	ReadDiskSectors
 345++73BF ~            	ret
 346++73BF ~
 347++73BF ~
 348++73BF ~            ;Write 8 sectors for an AU
 349++73BF ~            ;HL = block number, DE = source buffer
 350++73BF ~            WriteFSBlock:
 351++73BF ~            	push	de
 352++73BF ~            		call	AU2TS		;B=sector, C=track
 353++73BF ~            	pop		hl				;HL=dest
 354++73BF ~
 355++73BF ~            	ld		d, b
 356++73BF ~            	ld		e, c
 357++73BF ~            	ld		b, SPAL
 358++73BF ~
 359++73BF ~            	call	WriteDiskSectors
 360++73BF ~            	ret
 361++73BF ~
 362++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++73BF ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++73BF ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++73BF ~            CopyDisk:
 366++73BF ~            	;Get list of used blocks in current disk, max 632 bytes
 367++73BF ~            	call	ReadUsedBlocksList
 368++73BF ~            	ld		ix, UsedBlockListBlk
 369++73BF ~
 370++73BF ~            CopyDiskLoop:
 371++73BF ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++73BF ~            	ld		de, MsgBlocksLeft
 373++73BF ~            	call	Byte2Txt
 374++73BF ~            	ld		hl, MsgBlocksLeft
 375++73BF ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++73BF ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++73BF ~            	call	PrintStrClr
 378++73BF ~
 379++73BF ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++73BF ~            	ld		hl, MAX_AU_RAM
 381++73BF ~            	ld		bc, (UsedBlockListCnt)
 382++73BF ~            	or		a
 383++73BF ~            	sbc		hl, bc
 384++73BF ~            	jr		nc, CopyDiskLoopRead
 385++73BF ~            	ld		bc, MAX_AU_RAM
 386++73BF ~
 387++73BF ~            CopyDiskLoopRead:
 388++73BF ~            	ld		b, c
 389++73BF ~            	ld		de, CopyDiskBuf
 390++73BF ~            	;save initial counter and initial block number array position
 391++73BF ~            	push	bc
 392++73BF ~            	push	ix
 393++73BF ~
 394++73BF ~            CopyDiskLoopReadLoop:
 395++73BF ~            		ld		l, (ix)
 396++73BF ~            		ld		h, (ix+1)
 397++73BF ~            		inc		ix
 398++73BF ~            		inc		ix
 399++73BF ~
 400++73BF ~            		push	de
 401++73BF ~            		push	bc
 402++73BF ~            			call	ReadFSBlock			;Stop on error or continue?
 403++73BF ~            		pop		bc
 404++73BF ~            		pop		de
 405++73BF ~
 406++73BF ~            		;+2048
 407++73BF ~            		ld		a, d
 408++73BF ~            		add		8
 409++73BF ~            		ld		d, a
 410++73BF ~
 411++73BF ~            		djnz	CopyDiskLoopReadLoop
 412++73BF ~
 413++73BF ~            		;Check if selection is 1=single drive or 2=dual drive
 414++73BF ~            		ld		a, (CopySelOption)
 415++73BF ~            		cp		'1'
 416++73BF ~            		jr		nz, CopyDiskDualDrive1
 417++73BF ~
 418++73BF ~            		;Prompt for disk change
 419++73BF ~            		call	PromptDiskChangeDst
 420++73BF ~            		ld		a, (RWTSDrive)
 421++73BF ~            		call	BDOSInit
 422++73BF ~            		jr		CopyDiskReadEnd
 423++73BF ~
 424++73BF ~            CopyDiskDualDrive1:
 425++73BF ~            		;alternate drive
 426++73BF ~            		ld		a, (RWTSDrive)
 427++73BF ~            		inc 	a
 428++73BF ~            		xor		%11
 429++73BF ~            		dec		a
 430++73BF ~            		ld		(RWTSDrive), a
 431++73BF ~
 432++73BF ~            CopyDiskReadEnd:
 433++73BF ~            	;restore initial counter and initial block number array position
 434++73BF ~            	pop		ix
 435++73BF ~            	pop		bc
 436++73BF ~            	ld		de, CopyDiskBuf
 437++73BF ~            	push	bc
 438++73BF ~
 439++73BF ~            CopyDiskLoopWriteLoop:
 440++73BF ~            		ld		l, (ix)
 441++73BF ~            		ld		h, (ix+1)
 442++73BF ~            		inc		ix
 443++73BF ~            		inc		ix
 444++73BF ~
 445++73BF ~            		push	de
 446++73BF ~            		push	bc
 447++73BF ~            			call	WriteFSBlock		;Stop on error or continue?
 448++73BF ~            		pop		bc
 449++73BF ~            		pop		de
 450++73BF ~
 451++73BF ~            		;+2048
 452++73BF ~            		ld		a, d
 453++73BF ~            		add		8
 454++73BF ~            		ld		d, a
 455++73BF ~
 456++73BF ~            		djnz	CopyDiskLoopWriteLoop
 457++73BF ~
 458++73BF ~            CopyDiskWriteEnd:
 459++73BF ~            	pop		bc
 460++73BF ~            	ld		c, b
 461++73BF ~            	ld		b, 0
 462++73BF ~
 463++73BF ~            	;Decrease number of blocks read by now.
 464++73BF ~            	ld		hl, (UsedBlockListCnt)
 465++73BF ~            	or		a
 466++73BF ~            	sbc		hl, bc
 467++73BF ~            	ld		(UsedBlockListCnt), hl
 468++73BF ~
 469++73BF ~            	ld		a, l
 470++73BF ~            	or		h
 471++73BF ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++73BF ~
 473++73BF ~            	;Check if selection is 1=single drive or 2=dual drive
 474++73BF ~            	ld		a, (CopySelOption)
 475++73BF ~            	cp		'1'
 476++73BF ~            	jr		nz, CopyDiskDualDrive2
 477++73BF ~
 478++73BF ~            	;Prompt for disk change
 479++73BF ~            	call	PromptDiskChangeSrc
 480++73BF ~            	ld		a, (RWTSDrive)
 481++73BF ~            	call	BDOSInit
 482++73BF ~            	jp		CopyDiskLoop
 483++73BF ~
 484++73BF ~            CopyDiskDualDrive2:
 485++73BF ~            	;alternate drive again
 486++73BF ~            	ld		a, (RWTSDrive)
 487++73BF ~            	inc		a
 488++73BF ~            	xor		%11
 489++73BF ~            	dec		a
 490++73BF ~            	ld		(RWTSDrive), a
 491++73BF ~            	jp		CopyDiskLoop
 492++73BF ~
 493++73BF ~            CopyDiskEnd:
 494++73BF ~            	ld		b, 1
 495++73BF ~            	call	ClearNMsgLines
 496++73BF ~            	ret
 497++73BF ~
 498++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++73BF ~            ;Copies the current disk blocks to COM port.
 500++73BF ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++73BF ~            CopyDiskToCOM:
 502++73BF ~            	;Get list of used blocks in current disk, max 632 bytes
 503++73BF ~            	call	ReadUsedBlocksList
 504++73BF ~
 505++73BF ~            	;Send block count and block indexes
 506++73BF ~            	ld		hl, (UsedBlockListCnt)
 507++73BF ~            	add		hl, hl
 508++73BF ~            	inc		hl
 509++73BF ~            	inc		hl
 510++73BF ~            	ld		b, h
 511++73BF ~            	ld		c, l
 512++73BF ~            	ld		hl, UsedBlockListCnt
 513++73BF ~            	call	SERTB
 514++73BF ~
 515++73BF ~            	ld		ix, UsedBlockListBlk
 516++73BF ~
 517++73BF ~            CopyDiskToCOMLoop:
 518++73BF ~            	;Print block count left
 519++73BF ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++73BF ~            	ld		de, MsgBlocksLeft
 521++73BF ~            	call	Byte2Txt
 522++73BF ~            	ld		hl, MsgBlocksLeft
 523++73BF ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++73BF ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++73BF ~            	call	PrintStrClr
 526++73BF ~
 527++73BF ~            	;Read block into buffer
 528++73BF ~            	ld		l, (ix)
 529++73BF ~            	ld		h, (ix+1)
 530++73BF ~            	ld		de, CopyDiskBuf
 531++73BF ~            	push	ix
 532++73BF ~            		call	ReadFSBlock
 533++73BF ~            	pop		ix
 534++73BF ~            	inc		ix
 535++73BF ~            	inc		ix
 536++73BF ~
 537++73BF ~            	;Send block buffer
 538++73BF ~            	ld		hl, CopyDiskBuf
 539++73BF ~            	ld		bc, AU_SZ
 540++73BF ~            	call	SERTB
 541++73BF ~
 542++73BF ~            	ld		bc, (UsedBlockListCnt)
 543++73BF ~            	dec		bc
 544++73BF ~            	ld		(UsedBlockListCnt), bc
 545++73BF ~
 546++73BF ~            	push	ix
 547++73BF ~            		call	KbdHit
 548++73BF ~            	pop		ix
 549++73BF ~            	ret		c
 550++73BF ~
 551++73BF ~            	ld		a, b
 552++73BF ~            	or		c
 553++73BF ~            	jr		nz, CopyDiskToCOMLoop
 554++73BF ~
 555++73BF ~            	ret
 556++73BF ~
 557++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++73BF ~            CopyDiskFromCOM:
 559++73BF ~            	;Receive block count.
 560++73BF ~            	ld		hl, UsedBlockListCnt
 561++73BF ~            	ld		bc, 2
 562++73BF ~            	ld		e, 0
 563++73BF ~            	call	SERRB
 564++73BF ~
 565++73BF ~            	;Receive block indexes.
 566++73BF ~            	ld		hl, (UsedBlockListCnt)
 567++73BF ~            	add		hl, hl
 568++73BF ~            	ld		b, h
 569++73BF ~            	ld		c, l
 570++73BF ~            	ld		hl, UsedBlockListBlk
 571++73BF ~            	ld		e, 0
 572++73BF ~            	call	SERRB
 573++73BF ~
 574++73BF ~            	;Read each block by index and write to disk
 575++73BF ~            	ld		ix, UsedBlockListBlk
 576++73BF ~
 577++73BF ~            CopyDiskFromCOMLoop:
 578++73BF ~            	;Print block count left
 579++73BF ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++73BF ~            	ld		de, MsgBlocksLeft
 581++73BF ~            	call	Byte2Txt
 582++73BF ~            	ld		hl, MsgBlocksLeft
 583++73BF ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++73BF ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++73BF ~            	call	PrintStrClr
 586++73BF ~
 587++73BF ~            	;Read block buffer
 588++73BF ~            	ld		hl, CopyDiskBuf
 589++73BF ~            	ld		bc, AU_SZ
 590++73BF ~            	ld		e, 0
 591++73BF ~            	call	SERRB
 592++73BF ~
 593++73BF ~            	;Write block to disk
 594++73BF ~            	ld		l, (ix)
 595++73BF ~            	ld		h, (ix+1)
 596++73BF ~            	ld		de, CopyDiskBuf
 597++73BF ~            	push	ix
 598++73BF ~            		call	WriteFSBlock			;Stop on error or continue?
 599++73BF ~            	pop		ix
 600++73BF ~            	inc		ix
 601++73BF ~            	inc		ix
 602++73BF ~
 603++73BF ~            	ld		bc, (UsedBlockListCnt)
 604++73BF ~            	dec		bc
 605++73BF ~            	ld		(UsedBlockListCnt), bc
 606++73BF ~
 607++73BF ~            	push	ix
 608++73BF ~            		call	KbdHit
 609++73BF ~            	pop		ix
 610++73BF ~            	ret		c
 611++73BF ~
 612++73BF ~            	ld		a, b
 613++73BF ~            	or		c
 614++73BF ~            	jr		nz, CopyDiskFromCOMLoop
 615++73BF ~            	ret
 616++73BF ~
 617++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++73BF ~
 619++73BF ~            ;Compare string at HL with the one at DE, max length B
 620++73BF ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++73BF ~            ;OUT: z flag, set = match, reset = mismatch
 622++73BF ~            StrCmp:
 623++73BF ~            	push hl
 624++73BF ~            	push de
 625++73BF ~            Compare:
 626++73BF ~            		ld a, (de)
 627++73BF ~            		cp (hl)
 628++73BF ~            		jr nz, MisMatch
 629++73BF ~            		inc hl
 630++73BF ~            		inc de
 631++73BF ~            		djnz Compare
 632++73BF ~            MisMatch:
 633++73BF ~            	pop de
 634++73BF ~            	pop hl
 635++73BF ~            	ret
 636++73BF ~
 637++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++73BF ~
 639++73BF ~            ;Read a file into a buffer, sector by sector.
 640++73BF ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++73BF ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++73BF ~            ;In: HL = Name address, DE = buffer
 643++73BF ~            IF1FileLoad:
 644++73BF ~            	push	de
 645++73BF ~            		ld (FSTR1), hl
 646++73BF ~            		ld h, 0
 647++73BF ~            		ld a, (RWTSDrive)
 648++73BF ~            		inc  a			;CP/M drive number to BASIC drive number
 649++73BF ~            		ld	l, a
 650++73BF ~            		ld (DSTR1), hl
 651++73BF ~            		ld l,NAMELEN
 652++73BF ~            		ld (NSTR1), hl
 653++73BF ~            		rst 08
 654++73BF ~            		DEFB 51			;open disk channel
 655++73BF ~
 656++73BF ~            		rst		8
 657++73BF ~            		defb	53		;read sector
 658++73BF ~            	pop		de
 659++73BF ~            	jr		nc, FileFree
 660++73BF ~
 661++73BF ~            	ld		a, (ix + CH_DATA)
 662++73BF ~            	cp		TEXT_TYPE
 663++73BF ~            	jr		nc, FileLoadNoHeader
 664++73BF ~
 665++73BF ~            FileLoadHeader:
 666++73BF ~            	push	ix
 667++73BF ~            	pop		hl
 668++73BF ~            	ld		bc, CH_DATA + HDR_SZ
 669++73BF ~            	add		hl, bc
 670++73BF ~            	ld		bc, SECT_SZ - HDR_SZ
 671++73BF ~            	ldir
 672++73BF ~
 673++73BF ~            FileReadLoop:
 674++73BF ~            	push	de
 675++73BF ~            		rst		8
 676++73BF ~            		defb	53		;read sector
 677++73BF ~            	pop		de
 678++73BF ~            	jr		nc, FileFree
 679++73BF ~
 680++73BF ~            FileLoadNoHeader:
 681++73BF ~            	push	ix
 682++73BF ~            	pop		hl
 683++73BF ~            	ld		bc, CH_DATA
 684++73BF ~            	add		hl, bc
 685++73BF ~            	ld		bc, SECT_SZ
 686++73BF ~            	ldir
 687++73BF ~            	jr		FileReadLoop
 688++73BF ~
 689++73BF ~            FileFree:
 690++73BF ~            	push	de
 691++73BF ~            	rst		8
 692++73BF ~            	defb	56			;close channel (52) or detroy channel (56)
 693++73BF ~            	pop		de
 694++73BF ~            	ret
 695++73BF ~            IF1FileLoadEnd:
 696++73BF ~
 697++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++73BF ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++73BF ~            ;Out: A = error code, 0=OK
 700++73BF ~            ReadDiskSectors:
 701++73BF ~            	push bc
 702++73BF ~            		push hl
 703++73BF ~            			push de
 704++73BF ~            				call ReadOneDiskSector
 705++73BF ~            			pop de
 706++73BF ~            		pop hl
 707++73BF ~
 708++73BF ~            		inc d
 709++73BF ~            		inc h
 710++73BF ~            	pop bc
 711++73BF ~
 712++73BF ~            	ld	a, (RWTSRes)
 713++73BF ~            	or	a
 714++73BF ~            	ret nz
 715++73BF ~
 716++73BF ~            	djnz ReadDiskSectors
 717++73BF ~            	ret
 718++73BF ~
 719++73BF ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++73BF ~            ;Out: A = error code, 0=OK
 721++73BF ~            WriteDiskSectors:
 722++73BF ~            	push bc
 723++73BF ~            		push hl
 724++73BF ~            			push de
 725++73BF ~            				call WriteOneDiskSector
 726++73BF ~            			pop de
 727++73BF ~            		pop hl
 728++73BF ~
 729++73BF ~            		inc d
 730++73BF ~            		inc h
 731++73BF ~            	pop bc
 732++73BF ~
 733++73BF ~            	ld	a, (RWTSRes)
 734++73BF ~            	or	a
 735++73BF ~            	ret nz
 736++73BF ~
 737++73BF ~            	djnz WriteDiskSectors
 738++73BF ~            	ret
 739++73BF ~
 740++73BF ~
 741++73BF ~            ;Reads disk catalog
 742++73BF ~            ReadCatalogTrack:
 743++73BF ~            	ld hl, TrackBuf
 744++73BF ~            	ld de, 0
 745++73BF ~            	ld b, SPT
 746++73BF ~
 747++73BF ~            	call ReadDiskSectors
 748++73BF ~            	or   a
 749++73BF ~            	ret  nz
 750++73BF ~
 751++73BF ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 752++73BF ~            	push  af
 753++73BF ~            		ld  a, (RWTSDrive)
 754++73BF ~            		call BDOSSelectDisk
 755++73BF ~            		call BDOSInit
 756++73BF ~            	pop   af
 757++73BF ~            	ret
 758++73BF ~
 759++73BF ~
 760++73BF ~
 761++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 762++73BF ~
 763++73BF ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 764++73BF ~            FindCache:
 765++73BF ~            	ld		b, NAMELEN
 766++73BF ~            	call	StrCmp			;find the file to wich this extension belongs
 767++73BF ~            	ret		z
 768++73BF ~
 769++73BF ~            	dec		c
 770++73BF ~            	jr		nz, CacheNotFinished
 771++73BF ~            	or		c
 772++73BF ~            	ret
 773++73BF ~
 774++73BF ~            CacheNotFinished:
 775++73BF ~            	ld		bc, CACHE_SZ
 776++73BF ~            	add		hl, bc			;to the next cache line
 777++73BF ~            	jr		FindCache
 778++73BF ~
 779++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 780++73BF ~
 781++73BF ~            	;ld		ix, (SelFileCache)
 782++73BF ~            ReadFileHeader:
 783++73BF ~            	ld		a, (ix + CACHE_FLAG)
 784++73BF ~            	or		a
 785++73BF ~            	ret		nz				;return if already read
 786++73BF ~
 787++73BF ~            	ld		l, (ix + CACHE_FIRST_AU)
 788++73BF ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 789++73BF ~            	ld		a, h
 790++73BF ~            	or		l
 791++73BF ~            	jr		z, ReadHeaderEnd
 792++73BF ~
 793++73BF ~            	call	AU2TS
 794++73BF ~            	ld		d, b
 795++73BF ~            	ld		e, c
 796++73BF ~            	ld		hl, DataBuf
 797++73BF ~            	push	ix
 798++73BF ~            	push	ix
 799++73BF ~            		call	ReadOneDiskSector
 800++73BF ~            	pop		hl
 801++73BF ~            	pop		ix
 802++73BF ~
 803++73BF ~            	push	hl
 804++73BF ~            		ld		hl, DataBuf
 805++73BF ~            		call	IsFileHeaderValid
 806++73BF ~            	pop		hl
 807++73BF ~            	or		a
 808++73BF ~            	jr		z, ReadFileHeaderIsTextFile
 809++73BF ~
 810++73BF ~            	ld		bc, CACHE_HDR
 811++73BF ~            	add		hl, bc
 812++73BF ~            	ex		hl, de
 813++73BF ~            	ld		hl, DataBuf
 814++73BF ~            	ld		bc, HDR_SZ
 815++73BF ~            	ldir
 816++73BF ~
 817++73BF ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 818++73BF ~            	ld		a, BYTE_TYPE
 819++73BF ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 820++73BF ~            	jr		nc, ReadHeaderEnd
 821++73BF ~
 822++73BF ~            ReadFileHeaderIsTextFile:
 823++73BF ~            	push	ix
 824++73BF ~            	push	ix
 825++73BF ~            	pop		hl
 826++73BF ~            		call	GetFileSize
 827++73BF ~            	pop		ix
 828++73BF ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 829++73BF ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 830++73BF ~            	ld		a, TEXT_TYPE
 831++73BF ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 832++73BF ~
 833++73BF ~            ReadHeaderEnd:
 834++73BF ~            	inc		(ix + CACHE_FLAG)
 835++73BF ~            	ret
 836++73BF ~
 837++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 838++73BF ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 839++73BF ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 840++73BF ~            ;In: HL = header
 841++73BF ~            ;Out: A > 0 if valid
 842++73BF ~            IsFileHeaderValid:
 843++73BF ~            	IFUSED
 844++73BF ~            	xor		a
 845++73BF ~            	ld		b, HDR_SZ
 846++73BF ~            IsFileHeaderValidLoop:
 847++73BF ~            	or		(hl)
 848++73BF ~            	inc		hl
 849++73BF ~            	djnz	IsFileHeaderValidLoop
 850++73BF ~
 851++73BF ~            	ret
 852++73BF ~            	ENDIF
 853++73BF ~
 854++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 855++73BF ~
 856++73BF ~            ;IN: HL = address from IF1 to call
 857++73BF ~            IF1Call:
 858++73BF ~            	LD   (HD11), HL
 859++73BF ~            	RST  8
 860++73BF ~            	DEFB 50
 861++73BF ~            	RET
 862++73BF ~
 863++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864++73BF ~
 865++73BF ~            ;Load a program from disk
 866++73BF ~            ;IN: HL = file name addr
 867++73BF ~            LoadProgram:
 868++73BF ~            	LD   (FSTR1), HL
 869++73BF ~            	LD   H, 0
 870++73BF ~            	LD   L, NAMELEN
 871++73BF ~            	LD   (NSTR1), HL
 872++73BF ~            	LD	 A, (RWTSDrive)
 873++73BF ~            	INC  A					;Adapt for BASIC drive number
 874++73BF ~            	LD   L, A
 875++73BF ~            	LD   (DSTR1), HL
 876++73BF ~            	LD   HL, LOAD_ADDR
 877++73BF ~            	CALL IF1Call
 878++73BF ~            	RET
 879++73BF ~
 880++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 881++73BF ~
 882++73BF ~            SetFastKeys:
 883++73BF ~            	ld		hl, REPDEL
 884++73BF ~            	ld		de, (1 << 8) | 15
 885++73BF ~            	ld		(hl), de
 886++73BF ~
 887++73BF ~            	ret
 888++73BF ~
 889++73BF ~
 890++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 891++73BF ~            ;Reads the error message string from IF1 ROM.
 892++73BF ~            GetErrMsg:
 893++73BF ~            	inc		a
 894++73BF ~            	ex		af, af'
 895++73BF ~
 896++73BF ~            	ld		hl, IF1Paged			;page-in IF1
 897++73BF ~            	jp		IF1Call
 898++73BF ~
 899++73BF ~            IF1Paged:
 900++73BF ~            	ld		hl, ERRMSG
 901++73BF ~            	ex		af, af'
 902++73BF ~            	or		a
 903++73BF ~            	jr		z, SaveMsg
 904++73BF ~
 905++73BF ~            	ld		b, 0
 906++73BF ~            SearchMsgEnd:
 907++73BF ~            	bit		7, (hl)
 908++73BF ~            	inc		hl
 909++73BF ~            	jr		z, SearchMsgEnd
 910++73BF ~
 911++73BF ~            	inc		b
 912++73BF ~            	cp		b
 913++73BF ~            	jr		nz, SearchMsgEnd
 914++73BF ~
 915++73BF ~            SaveMsg:
 916++73BF ~            	ld		de, DataBuf
 917++73BF ~            CopyMsg:
 918++73BF ~            	ld		a, (hl)
 919++73BF ~            	bit		7, a
 920++73BF ~            	ld		(de), a
 921++73BF ~            	inc		hl
 922++73BF ~            	inc		de
 923++73BF ~            	jr		z, CopyMsg
 924++73BF ~
 925++73BF ~            	ret
 926++73BF ~
 927++73BF ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 928++73BF ~
 929++73BF ~            ;RWTS routine I/O block
 930++73BF ~            RWTSParams:
 931++73BF ~            RWTSBlockType	DEFB	1							;?
 932++73BF ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 933++73BF ~            RWTSVolNo		DEFB	0							;?
 934++73BF ~            RWTSTrack		DEFB	0
 935++73BF ~            RWTSSector		DEFB	0
 936++73BF ~            RWTSDMA			DEFW	0
 937++73BF ~            RWTSExtBuf		DEFW	$2932
 938++73BF ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 939++73BF ~            	IFDEF _REAL_HW_
 940++73BF ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 941++73BF ~            	ELSE
 942++73BF ~            RWTSPrmTbl		DEFW	$1f2a
 943++73BF ~            	ENDIF
 944++73BF ~            RWTSCmd			DEFB	RWTS_CMD_READ
 945++73BF ~            ;Results
 946++73BF ~            RWTSRes			DEFB	0
 947++73BF ~            RWTSResVolNo	DEFB	0
 948++73BF ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 949++73BF ~
 950++73BF ~            ;Param. table, usualy found in ROM.
 951++73BF ~            	IFDEF _REAL_HW_
 952++73BF ~            BasPrmTbl:
 953++73BF ~            PrmDevType		DEFB	$01		;$01
 954++73BF ~            PrmStepRate		DEFB	$01		;$0D	(milisec)
 955++73BF ~            PrmHeadLoad		DEFB	$01		;$23	(milisec)
 956++73BF ~            PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 957++73BF ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 958++73BF ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 959++73BF ~            	ENDIF
 960++73BF ~
 961++73BF              	endif
# file closed: if1.asm
   7+ 73BF
   8+ 73BF              BDOSInit:
   9+ 73BF AF           	xor		a
  10+ 73C0 18 45        	jr		BDOS
  11+ 73C2
  12+ 73C2
  13+ 73C2              ;IN: A = Drive to select
  14+ 73C2              BDOSSelectDisk:
  15+ 73C2              	IFUSED
  16+ 73C2 DD 6F        	ld		ixl, a
  17+ 73C4 DD 26 00     	ld		ixh, 0
  18+ 73C7 3E 01        	ld		a, 1
  19+ 73C9 18 3C        	jr		BDOS
  20+ 73CB              	ENDIF
  21+ 73CB
  22+ 73CB
  23+ 73CB              BDOSMakeDiskRO:
  24+ 73CB              	IFUSED
  25+ 73CB ~            	ld		a, 15
  26+ 73CB ~            	jr		BDOS
  27+ 73CB              	ENDIF
  28+ 73CB
  29+ 73CB              ;Get Read Only flag
  30+ 73CB              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 73CB              BDOSGetDiskRO:
  32+ 73CB              	IFUSED
  33+ 73CB ~            	ld	a, 16
  34+ 73CB ~            	jr	BDOS
  35+ 73CB              	ENDIF
  36+ 73CB
  37+ 73CB              BDOSGetCurrentDisk:
  38+ 73CB              	IFUSED
  39+ 73CB ~            	ld		a, 12
  40+ 73CB ~            	jr		BDOS
  41+ 73CB              	ENDIF
  42+ 73CB
  43+ 73CB
  44+ 73CB              ;Create a disk channel for BDOS access (does not open the file)
  45+ 73CB              ;IN: HL=name addr, A=drive
  46+ 73CB              ;OUT: IX=FCB
  47+ 73CB              CreateChannel:
  48+ 73CB 22 DC 5C     	ld (FSTR1), hl
  49+ 73CE 26 00        	ld h,0
  50+ 73D0 6F           	ld l,a
  51+ 73D1 22 D6 5C     	ld (DSTR1), hl
  52+ 73D4 2E 0B        	ld l,NAMELEN
  53+ 73D6 22 DA 5C     	ld (NSTR1), hl
  54+ 73D9 CF           	rst 08
  55+ 73DA 37           	DEFB 55
  56+ 73DB 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  57+ 73DE DD 09        	add ix, bc
  58+ 73E0 C9           	ret
  59+ 73E1
  60+ 73E1
  61+ 73E1              ;Destroy a BDOS channel
  62+ 73E1              ;IN: IX=FCB
  63+ 73E1              DestroyChannel:
  64+ 73E1 C5           	push bc
  65+ 73E2 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  66+ 73E5 DD 09        	add ix, bc
  67+ 73E7 CF           	rst 08
  68+ 73E8 38           	DEFB 56
  69+ 73E9 C1           	pop bc
  70+ 73EA C9           	ret
  71+ 73EB
  72+ 73EB
  73+ 73EB              ;Input: IX=FCB
  74+ 73EB              BDOSCreateFile:
  75+ 73EB 3E 09        	ld	a, 9
  76+ 73ED 18 18        	jr	BDOS
  77+ 73EF
  78+ 73EF              ;Input: IX=FCB
  79+ 73EF              BDOSOpenFile:
  80+ 73EF 3E 02        	ld	a, 2
  81+ 73F1 18 14        	jr	BDOS
  82+ 73F3
  83+ 73F3              ;IN: IX=FCB
  84+ 73F3              BDOSCloseFile:
  85+ 73F3 3E 03        	ld	a, 3
  86+ 73F5 18 10        	jr	BDOS
  87+ 73F7
  88+ 73F7
  89+ 73F7              ;0 OK,
  90+ 73F7              ;1 end of file,
  91+ 73F7              ;9 invalid FCB,
  92+ 73F7              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
  93+ 73F7              ;11 (MP/M) unlocked file verification error,
  94+ 73F7              ;0FFh hardware error.
  95+ 73F7
  96+ 73F7              ;IN: IX=FCB
  97+ 73F7              BDOSReadFileBlockSeq:
  98+ 73F7 3E 07        	ld	a, 7
  99+ 73F9 18 0C        	jr	BDOS
 100+ 73FB
 101+ 73FB
 102+ 73FB              ;0 OK,
 103+ 73FB              ;1 directory full,
 104+ 73FB              ;2 disc full,
 105+ 73FB              ;8 (MP/M) record locked by another process,
 106+ 73FB              ;9 invalid FCB,
 107+ 73FB              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 108+ 73FB              ;11 (MP/M) unlocked file verification error,
 109+ 73FB              ;0FFh hardware error.
 110+ 73FB
 111+ 73FB              ;IN: IX=FCB
 112+ 73FB              BDOSWriteFileBlockSeq:
 113+ 73FB 3E 08        	ld	a, 8
 114+ 73FD 18 08        	jr	BDOS
 115+ 73FF
 116+ 73FF
 117+ 73FF              ;0 OK
 118+ 73FF              ;1 Reading unwritten data
 119+ 73FF              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 120+ 73FF              ;6 Record number out of range
 121+ 73FF              ;9 Invalid FCB
 122+ 73FF              BDOSReadFileBlockRandom:
 123+ 73FF 3E 12        	ld	a, 18
 124+ 7401 18 04        	jr	BDOS
 125+ 7403
 126+ 7403              ;0 OK
 127+ 7403              ;2 Disc full
 128+ 7403              ;3 Cannot close extent
 129+ 7403              ;5 Directory full
 130+ 7403              ;6 Record number out of range
 131+ 7403              ;8 Record is locked by another process (MP/M)
 132+ 7403              ;9 Invalid FCB
 133+ 7403              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 134+ 7403              BDOSWriteFileBlockRandom:
 135+ 7403 3E 13        	ld	a, 19
 136+ 7405 18 00        	jr	BDOS
 137+ 7407
 138+ 7407
 139+ 7407              ;Generic BDOS call
 140+ 7407              ;IX=arg, A=function
 141+ 7407              BDOS:
 142+ 7407 DD 22 ED 5C  	ld (HD11), ix
 143+ 740B 32 EF 5C     	ld (COPIES), a
 144+ 740E CF           	rst 08
 145+ 740F 39           	DEFB 57
 146+ 7410 C9           	ret
 147+ 7411
 148+ 7411              ;Set DMA address for BDOS
 149+ 7411              ;IX=DMA
 150+ 7411              BDOSSetDMA:
 151+ 7411 3E 0D        	ld a, 13
 152+ 7413 18 F2        	jr BDOS
 153+ 7415
 154+ 7415              ;In: IX=FCB
 155+ 7415              BDOSSetRandFilePtr:
 156+ 7415 3E 15        	ld	a, 21
 157+ 7417 18 EE        	jr	BDOS
 158+ 7419
 159+ 7419              ;In: HL=filename
 160+ 7419              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 161+ 7419              GetFileSize:
 162+ 7419              	IFUSED
 163+ 7419
 164+ 7419 3A 97 73     	ld 		a, (RWTSDrive)
 165+ 741C 3C           	inc		a					;Convert to BASIC drive number: 1,2
 166+ 741D CD CB 73     	call	CreateChannel
 167+ 7420
 168+ 7420 3E 14        	ld		a, 20
 169+ 7422 CD 07 74     	call	BDOS
 170+ 7425              	;inc		a
 171+ 7425              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 172+ 7425
 173+ 7425 DD 6E 21     	ld		l, (ix + FCB_R0)
 174+ 7428 DD 66 22     	ld		h, (ix + FCB_R1)
 175+ 742B
 176+ 742B              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 177+ 742B 3E 01        	ld		a, 1
 178+ 742D BC           	cp		h
 179+ 742E 30 05        	jr		nc, GetFileSizeOK
 180+ 7430 21 00 00     	ld		hl, 0
 181+ 7433 18 08        	jr		GetFileSizeEnd
 182+ 7435
 183+ 7435              GetFileSizeOK:
 184+ 7435              	;*128 == 2^7
 185+ 7435 06 07        	ld		b, 7
 186+ 7437              GetFileSizeMul:
 187+ 7437 CB 15        	rl		l
 188+ 7439 CB 14        	rl		h
 189+ 743B 10 FA        	djnz	GetFileSizeMul
 190+ 743D
 191+ 743D              GetFileSizeEnd:
 192+ 743D E5           	push	hl
 193+ 743E CD E1 73     		call	DestroyChannel
 194+ 7441 E1           	pop		hl
 195+ 7442
 196+ 7442 C9           	ret
 197+ 7443              	ENDIF
 198+ 7443
 199+ 7443              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 200+ 7443              ;HL=file name, A=drive
 201+ 7443              DeleteFile:
 202+ 7443 CD CB 73     	call	CreateChannel
 203+ 7446
 204+ 7446 3E 06        	ld		a, 6
 205+ 7448 CD 07 74     	call	BDOS
 206+ 744B
 207+ 744B CD E1 73     	call	DestroyChannel
 208+ 744E C9           	ret
 209+ 744F
 210+ 744F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 211+ 744F              ;Returns A >= 0 if the file exists, returns $FF on error.
 212+ 744F              ;HL=file name, A=drive
 213+ 744F              DoesFileExist:
 214+ 744F              	IFUSED
 215+ 744F              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 216+ 744F F5           	push	af
 217+ 7450 E5           	push	hl
 218+ 7451 DD 21 FB F6  		ld		ix, FileIdx
 219+ 7455 CD 11 74     		call 	BDOSSetDMA
 220+ 7458 E1           	pop		hl
 221+ 7459 F1           	pop		af
 222+ 745A
 223+ 745A CD CB 73     	call	CreateChannel
 224+ 745D
 225+ 745D              	;Uses FindFirst system call.
 226+ 745D 3E 04        	ld		a, 4
 227+ 745F CD 07 74     	call	BDOS
 228+ 7462
 229+ 7462 F5           	push	af
 230+ 7463 CD E1 73     		call	DestroyChannel
 231+ 7466 F1           	pop		af
 232+ 7467 C9           	ret
 233+ 7468              	ENDIF
 234+ 7468
 235+ 7468              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 236+ 7468              ;IN: E0 = RO, E1 = SYS, HL=filename
 237+ 7468              ChangeFileAttrib:
 238+ 7468 3A 97 73     	ld 		a, (RWTSDrive)
 239+ 746B 3C           	inc		a					;Convert to BASIC drive number: 1,2
 240+ 746C D5           	push	de
 241+ 746D CD CB 73     	call	CreateChannel
 242+ 7470 D1           	pop		de
 243+ 7471
 244+ 7471 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 245+ 7474 CB 27        	sla		a								;reset existing attribute flag
 246+ 7476 CB 1B        	rr		e								;put wanted flag in Carry flag
 247+ 7478 CB 1F        	rr		a								;put Carry flag in register L
 248+ 747A DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 249+ 747D
 250+ 747D DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 251+ 7480 CB 27        	sla		a
 252+ 7482 CB 1B        	rr		e
 253+ 7484 CB 1F        	rr		a
 254+ 7486 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 255+ 7489
 256+ 7489              FileAttribSet:
 257+ 7489 3E 11        	ld		a, 17
 258+ 748B CD 07 74     	call	BDOS
 259+ 748E
 260+ 748E CD E1 73     	call	DestroyChannel
 261+ 7491 C9           	ret
 262+ 7492
 263+ 7492              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 264+ 7492
 265+ 7492              ;HL=original name, DE = new name
 266+ 7492              ;Works only on the same drive.
 267+ 7492              RenameFile:
 268+ 7492 3A 97 73     	ld 		a, (RWTSDrive)
 269+ 7495 3C           	inc		a					;Convert to BASIC drive number: 1,2
 270+ 7496 D5           	push	de
 271+ 7497 CD CB 73     	call	CreateChannel
 272+ 749A D1           	pop		de
 273+ 749B
 274+ 749B DD E5        	push	ix					;IX == FCB
 275+ 749D E1           	pop		hl
 276+ 749E 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 277+ 74A1 09           	add		hl, bc
 278+ 74A2 EB           	ex		de, hl
 279+ 74A3 3A 97 73     	ld		a, (RWTSDrive)
 280+ 74A6 12           	ld		(de), a
 281+ 74A7 01 0B 00     	ld		bc, NAMELEN
 282+ 74AA ED B0        	ldir
 283+ 74AC
 284+ 74AC 3E 0A        	ld		a, 10
 285+ 74AE CD 07 74     	call	BDOS
 286+ 74B1
 287+ 74B1 CD E1 73     	call	DestroyChannel
 288+ 74B4 C9           	ret
 289+ 74B5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 290+ 74B5              PromptDiskChangeDst:
 291+ 74B5 21 85 80     	ld		hl, MsgInsertDstDsk
 292+ 74B8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 293+ 74BB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 294+ 74BD CD 65 78     	call	PrintStrClr
 295+ 74C0 21 94 80     	ld		hl, MsgPressAnyKey
 296+ 74C3 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 297+ 74C6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 298+ 74C8 CD 65 78     	call	PrintStrClr
 299+ 74CB CD 01 78     	call	ReadChar
 300+ 74CE C9           	ret
 301+ 74CF
 302+ 74CF              PromptDiskChangeSrc:
 303+ 74CF 21 76 80     	ld		hl, MsgInsertSrcDsk
 304+ 74D2 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 305+ 74D5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 306+ 74D7 CD 65 78     	call	PrintStrClr
 307+ 74DA 21 94 80     	ld		hl, MsgPressAnyKey
 308+ 74DD 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 309+ 74E0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 310+ 74E2 CD 65 78     	call	PrintStrClr
 311+ 74E5 CD 01 78     	call	ReadChar
 312+ 74E8 C9           	ret
 313+ 74E9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 314+ 74E9
 315+ 74E9              ;HL = source file name, A = source drive
 316+ 74E9              ;Use cases:
 317+ 74E9              ;1. Copy from A: to B: or B: to A:.
 318+ 74E9              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 319+ 74E9              ;3. Copy from A:/B: to COM.
 320+ 74E9              ;4. Copy from COM to A:/B:.
 321+ 74E9              ;Single drive scenario:
 322+ 74E9              ;1. Read first file part,
 323+ 74E9              ;2. Ask for dest disk,
 324+ 74E9              ;3. check if file exists/ask for overwrite,
 325+ 74E9              ;4. create empty dest file,
 326+ 74E9              ;5. write first file part,
 327+ 74E9              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 328+ 74E9              CopyFile:
 329+ 74E9 3A 97 73     	ld 		a, (RWTSDrive)
 330+ 74EC 3C           	inc		a					;Convert to BASIC drive number: 1,2
 331+ 74ED 32 C5 80     	ld		(CopyFileSrcDrv), a
 332+ 74F0 32 D1 80     	ld		(CopyFileDstDrv), a
 333+ 74F3 11 C6 80     	ld		de, CopyFileSrcName
 334+ 74F6 01 0B 00     	ld		bc, NAMELEN
 335+ 74F9 E5           	push	hl
 336+ 74FA C5           	push	bc
 337+ 74FB ED B0        	ldir
 338+ 74FD C1           	pop		bc
 339+ 74FE E1           	pop		hl
 340+ 74FF 11 D2 80     	ld		de, CopyFileDstName
 341+ 7502 ED B0        	ldir
 342+ 7504
 343+ 7504              	;Reset R/O attribute for destination, to allow file write.
 344+ 7504 3A DA 80     	ld		a, (CopyFileDstName+RO_POS)
 345+ 7507 CB BF        	res		7, a
 346+ 7509 32 DA 80     	ld		(CopyFileDstName+RO_POS), a
 347+ 750C
 348+ 750C AF           	xor		a
 349+ 750D 32 BD 80     	ld		(CopyFileRes), a
 350+ 7510 11 00 00     	ld		de, 0
 351+ 7513 ED 53 C0 80  	ld		(FilePosRead), de
 352+ 7517 ED 53 C2 80  	ld		(FilePosWrite), de
 353+ 751B
 354+ 751B 3A C5 80     	ld		a, (CopyFileSrcDrv)
 355+ 751E C6 40        	add		'A'-1
 356+ 7520              	;Update menu messages with current drive.
 357+ 7520 32 FE 7F     	ld		(MsgMenuSingleDrv1), a
 358+ 7523 32 02 80     	ld		(MsgMenuSingleDrv2), a
 359+ 7526 32 0C 80     	ld		(MsgMenuDualDrv1), a
 360+ 7529 32 1A 80     	ld		(MsgMenuToComDrv), a
 361+ 752C 32 2E 80     	ld		(MsgMenuFromCOMDrv), a
 362+ 752F              	;Update menu messages with the alternate drive.
 363+ 752F 3A C5 80     	ld		a, (CopyFileSrcDrv)
 364+ 7532 EE 03        	xor		%11
 365+ 7534 C6 40        	add		'A'-1
 366+ 7536 32 10 80     	ld		(MsgMenuDualDrv2), a
 367+ 7539
 368+ 7539 21 DB 7F     	ld		hl, MsgMenuFileCopy
 369+ 753C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 370+ 753F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371+ 7541 CD 65 78     	call	PrintStrClr
 372+ 7544 21 EA 7F     	ld		hl, MsgMenuBack
 373+ 7547 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 374+ 754A CD 3D 78     	call	PrintStr
 375+ 754D 21 F6 7F     	ld		hl, MsgMenuSingle
 376+ 7550 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 377+ 7553 CD 3D 78     	call	PrintStr
 378+ 7556 21 04 80     	ld		hl, MsgMenuDual
 379+ 7559 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 380+ 755C CD 3D 78     	call	PrintStr
 381+ 755F 21 12 80     	ld		hl, MsgMenuToCOM
 382+ 7562 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 383+ 7565 CD 3D 78     	call	PrintStr
 384+ 7568 21 21 80     	ld		hl, MsgMenuFromCOM
 385+ 756B 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 386+ 756E CD 3D 78     	call	PrintStr
 387+ 7571
 388+ 7571 CD 01 78     	call	ReadChar
 389+ 7574 32 BA 80     	ld		(CopySelOption), a
 390+ 7577
 391+ 7577 F5           	push	af
 392+ 7578 06 06        		ld		b, 6
 393+ 757A CD E9 79     		call	ClearNMsgLines
 394+ 757D F1           	pop		af
 395+ 757E
 396+ 757E              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 397+ 757E FE 30        	cp		'0'
 398+ 7580 20 04        	jr		nz, CopyFileNotExit
 399+ 7582 E1           	pop		hl
 400+ 7583 C3 0C 69     	jp		ReadKeyLoop
 401+ 7586
 402+ 7586              CopyFileNotExit:
 403+ 7586 FE 31        	cp		'1'
 404+ 7588 28 4D        	jr		z, CopyFileSameDrive
 405+ 758A
 406+ 758A FE 32        	cp		'2'
 407+ 758C CA 52 76     	jp		z, CopyFileDualDrive
 408+ 758F
 409+ 758F FE 33        	cp		'3'
 410+ 7591 CA 9A 76     	jp		z, CopyFileToCOM
 411+ 7594
 412+ 7594 FE 34        	cp		'4'
 413+ 7596 CA CB 76     	jp		z, CopyFileFromCOM
 414+ 7599
 415+ 7599 E1           	pop		hl
 416+ 759A C3 0C 69     	jp		ReadKeyLoop
 417+ 759D
 418+ 759D
 419+ 759D              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 420+ 759D              CopyFileCheckOverwrite:
 421+ 759D              	;Check if destination file exists.
 422+ 759D 3A D1 80     	ld		a, (CopyFileDstDrv)
 423+ 75A0 21 D2 80     	ld		hl, CopyFileDstName
 424+ 75A3 CD 4F 74     	call	DoesFileExist
 425+ 75A6 3C           	inc		a
 426+ 75A7 C8           	ret		z						;return Z=1 when file doesn't exist
 427+ 75A8
 428+ 75A8              	;Ask overwrite confirmation.
 429+ 75A8 21 58 80     	ld		hl, MsgFileOverwrite
 430+ 75AB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 431+ 75AE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 432+ 75B0 CD 65 78     	call	PrintStrClr
 433+ 75B3 CD 01 78     	call	ReadChar
 434+ 75B6 FE 79        	cp		'y'
 435+ 75B8 C9           	ret								;return Z=1 when user confirmed file overwrite
 436+ 75B9
 437+ 75B9
 438+ 75B9              CopyFileCreateNewFile:
 439+ 75B9 3A D1 80     	ld		a, (CopyFileDstDrv)
 440+ 75BC 21 D2 80     	ld		hl, CopyFileDstName
 441+ 75BF F5           	push	af
 442+ 75C0 E5           	push	hl
 443+ 75C1 CD 43 74     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 444+ 75C4 E1           	pop		hl
 445+ 75C5 F1           	pop		af
 446+ 75C6 CD CB 73     	call	CreateChannel
 447+ 75C9 CD EB 73     	call 	BDOSCreateFile
 448+ 75CC 3C           	inc  	a						;Cancel if A==$FF
 449+ 75CD C8           	ret		z
 450+ 75CE
 451+ 75CE              	;Close dest file once created.
 452+ 75CE F5           	push	af
 453+ 75CF CD F3 73     		call	BDOSCloseFile
 454+ 75D2 CD E1 73     		call	DestroyChannel
 455+ 75D5 F1           	pop		af
 456+ 75D6 C9           	ret
 457+ 75D7
 458+ 75D7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 459+ 75D7              CopyFileSameDrive:
 460+ 75D7              	;Read first file section from SRC.
 461+ 75D7 3A C5 80     	ld		a, (CopyFileSrcDrv)
 462+ 75DA 21 C6 80     	ld		hl, CopyFileSrcName
 463+ 75DD CD 4E 77     	call	ReadFileSection
 464+ 75E0 3A C4 80     	ld		a, (CopyFileSectCnt)
 465+ 75E3 B7           	or		a
 466+ 75E4 C8           	ret		z
 467+ 75E5
 468+ 75E5              	;Prompt for DST disk change.
 469+ 75E5 CD B5 74     	call	PromptDiskChangeDst
 470+ 75E8 3A 97 73     	ld		a, (RWTSDrive)
 471+ 75EB CD BF 73     	call	BDOSInit
 472+ 75EE
 473+ 75EE 06 02        	ld		b, 2
 474+ 75F0 CD E9 79     	call	ClearNMsgLines
 475+ 75F3
 476+ 75F3 CD 9D 75     	call	CopyFileCheckOverwrite
 477+ 75F6 C0           	ret		nz
 478+ 75F7
 479+ 75F7 CD B9 75     	call	CopyFileCreateNewFile
 480+ 75FA C8           	ret		z
 481+ 75FB
 482+ 75FB              CopyFileSameDriveLoop:
 483+ 75FB 3A C4 80     	ld		a, (CopyFileSectCnt)
 484+ 75FE 6F           	ld		l, a
 485+ 75FF 26 00        	ld		h, 0
 486+ 7601 11 A1 80     	ld		de, MsgCopySectors
 487+ 7604 CD 62 6F     	call	Byte2Txt
 488+ 7607 21 A1 80     	ld		hl, MsgCopySectors
 489+ 760A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 490+ 760D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 491+ 760F CD 65 78     	call	PrintStrClr
 492+ 7612
 493+ 7612 3A BD 80     	ld		a, (CopyFileRes)			;Save read status code.
 494+ 7615 F5           	push	af
 495+ 7616 3A D1 80     		ld		a, (CopyFileDstDrv)
 496+ 7619 21 D2 80     		ld		hl, CopyFileDstName
 497+ 761C CD 70 77     		call	WriteFileSection
 498+ 761F 3A BD 80     		ld		a, (CopyFileRes)
 499+ 7622 6F           		ld		l, a
 500+ 7623 F1           	pop		af
 501+ 7624 B5           	or		l
 502+ 7625 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 503+ 7626
 504+ 7626
 505+ 7626              	;Prompt for SRC disk change.
 506+ 7626 CD CF 74     	call	PromptDiskChangeSrc
 507+ 7629 3A 97 73     	ld		a, (RWTSDrive)
 508+ 762C CD BF 73     	call	BDOSInit
 509+ 762F
 510+ 762F 06 02        	ld		b, 2
 511+ 7631 CD E9 79     	call	ClearNMsgLines
 512+ 7634
 513+ 7634 3A C5 80     	ld		a, (CopyFileSrcDrv)
 514+ 7637 21 C6 80     	ld		hl, CopyFileSrcName
 515+ 763A CD 4E 77     	call	ReadFileSection
 516+ 763D 3A C4 80     	ld		a, (CopyFileSectCnt)
 517+ 7640 B7           	or		a
 518+ 7641 C8           	ret		z
 519+ 7642
 520+ 7642              	;Prompt for DST disk change.
 521+ 7642 CD B5 74     	call	PromptDiskChangeDst
 522+ 7645 3A 97 73     	ld		a, (RWTSDrive)
 523+ 7648 CD BF 73     	call	BDOSInit
 524+ 764B
 525+ 764B 06 02        	ld		b, 2
 526+ 764D CD E9 79     	call	ClearNMsgLines
 527+ 7650
 528+ 7650 18 A9        	jr		CopyFileSameDriveLoop
 529+ 7652
 530+ 7652              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 531+ 7652
 532+ 7652              CopyFileDualDrive:
 533+ 7652 3A C5 80     	ld		a, (CopyFileSrcDrv)
 534+ 7655 EE 03        	xor		%11
 535+ 7657 32 D1 80     	ld		(CopyFileDstDrv), a
 536+ 765A
 537+ 765A CD 9D 75     	call	CopyFileCheckOverwrite
 538+ 765D C0           	ret		nz
 539+ 765E
 540+ 765E CD B9 75     	call	CopyFileCreateNewFile
 541+ 7661 C8           	ret		z
 542+ 7662
 543+ 7662              CopyFileDualDriveLoop:
 544+ 7662 3A C5 80     	ld		a, (CopyFileSrcDrv)
 545+ 7665 21 C6 80     	ld		hl, CopyFileSrcName
 546+ 7668 CD 4E 77     	call	ReadFileSection
 547+ 766B 3A C4 80     	ld		a, (CopyFileSectCnt)
 548+ 766E B7           	or		a
 549+ 766F C8           	ret		z
 550+ 7670
 551+ 7670 3A C4 80     	ld		a, (CopyFileSectCnt)
 552+ 7673 6F           	ld		l, a
 553+ 7674 26 00        	ld		h, 0
 554+ 7676 11 A1 80     	ld		de, MsgCopySectors
 555+ 7679 CD 62 6F     	call	Byte2Txt
 556+ 767C 21 A1 80     	ld		hl, MsgCopySectors
 557+ 767F 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 558+ 7682 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 559+ 7684
 560+ 7684 3A BD 80     	ld		a, (CopyFileRes)
 561+ 7687 F5           	push	af
 562+ 7688 3A D1 80     		ld		a, (CopyFileDstDrv)
 563+ 768B 21 D2 80     		ld		hl, CopyFileDstName
 564+ 768E CD 70 77     		call	WriteFileSection
 565+ 7691 3A BD 80     		ld		a, (CopyFileRes)
 566+ 7694 6F           		ld		l, a
 567+ 7695 F1           	pop		af
 568+ 7696 B5           	or		l
 569+ 7697 C0           	ret		nz
 570+ 7698
 571+ 7698 18 C8        	jr		CopyFileDualDriveLoop
 572+ 769A
 573+ 769A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 574+ 769A              CopyFileToCOM:
 575+ 769A AF           	xor		a
 576+ 769B 32 BD 80     	ld		(CopyFileRes), a
 577+ 769E 32 C4 80     	ld		(CopyFileSectCnt), a
 578+ 76A1 11 00 00     	ld		de, 0
 579+ 76A4 ED 53 C0 80  	ld		(FilePosRead), de
 580+ 76A8
 581+ 76A8              CopyFileToCOMLoop:
 582+ 76A8 3A C5 80     	ld		a, (CopyFileSrcDrv)
 583+ 76AB 21 C6 80     	ld		hl, CopyFileSrcName
 584+ 76AE CD 4E 77     	call	ReadFileSection
 585+ 76B1
 586+ 76B1 3A C4 80     	ld		a, (CopyFileSectCnt)
 587+ 76B4 B7           	or		a
 588+ 76B5 28 0F        	jr		z, CopyFileToCOMEnd
 589+ 76B7
 590+ 76B7              	;Send buffer to COM port.
 591+ 76B7 21 FB 8E     	ld		hl, FileData
 592+ 76BA 47           	ld		b, a					;Sector size is 256.
 593+ 76BB 0E 00        	ld		c, 0
 594+ 76BD CD C8 7D     	call	SERTB
 595+ 76C0
 596+ 76C0 3A BD 80     	ld		a, (CopyFileRes)
 597+ 76C3 B7           	or		a
 598+ 76C4 28 E2        	jr		z, CopyFileToCOMLoop
 599+ 76C6
 600+ 76C6              CopyFileToCOMEnd:
 601+ 76C6              	;Reset read error code, as 1 is returned when file is finished reading.
 602+ 76C6 AF           	xor		a
 603+ 76C7 32 BD 80     	ld		(CopyFileRes), a
 604+ 76CA
 605+ 76CA C9           	ret
 606+ 76CB
 607+ 76CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 608+ 76CB              CopyFileFromCOM:
 609+ 76CB AF           	xor		a
 610+ 76CC 32 BD 80     	ld		(CopyFileRes), a
 611+ 76CF 11 00 00     	ld		de, 0
 612+ 76D2 ED 53 C2 80  	ld		(FilePosWrite), de
 613+ 76D6
 614+ 76D6              	;Must ask for the new file name and check to not exist.
 615+ 76D6 21 C1 7F     	ld		hl, MsgNewFileName
 616+ 76D9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 617+ 76DC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 618+ 76DE CD 65 78     	call	PrintStrClr
 619+ 76E1
 620+ 76E1 21 8C 7F     	ld		hl, MsgClear
 621+ 76E4 11 FB 8E     	ld		de, FileData
 622+ 76E7 01 0B 00     	ld		bc, NAMELEN
 623+ 76EA ED B0        	ldir
 624+ 76EC 3E A0        	ld		a, $80 | ' '
 625+ 76EE 12           	ld		(de), a
 626+ 76EF 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 627+ 76F2 21 FB 8E     	ld		hl, FileData
 628+ 76F5 CD 3D 78     	call	PrintStr
 629+ 76F8
 630+ 76F8 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 631+ 76FB 01 0B 00     	ld		bc, NAMELEN
 632+ 76FE CD A7 79     	call	ReadString
 633+ 7701
 634+ 7701 11 FB 8E     	ld		de, FileData
 635+ 7704 1A           	ld		a, (de)
 636+ 7705 FE 20        	cp		' '					;If starting with space, input was canceled.
 637+ 7707 C8           	ret		z
 638+ 7708
 639+ 7708              	;Copy new file name
 640+ 7708 21 FB 8E     	ld		hl, FileData
 641+ 770B 11 D2 80     	ld		de, CopyFileDstName
 642+ 770E 01 0B 00     	ld		bc, NAMELEN
 643+ 7711 ED B0        	ldir
 644+ 7713
 645+ 7713              	;Check if new name doesn't exist already.
 646+ 7713 3A C5 80     	ld		a, (CopyFileSrcDrv)
 647+ 7716 21 D2 80     	ld		hl, CopyFileDstName
 648+ 7719 CD 9D 75     	call	CopyFileCheckOverwrite
 649+ 771C C0           	ret		nz
 650+ 771D
 651+ 771D              	;Delete and re-create empty destination file
 652+ 771D 3A C5 80     	ld		a, (CopyFileSrcDrv)
 653+ 7720 21 D2 80     	ld		hl, CopyFileDstName
 654+ 7723 CD B9 75     	call	CopyFileCreateNewFile
 655+ 7726 C8           	ret		z
 656+ 7727
 657+ 7727              CopyFileFromCOMLoop:
 658+ 7727 21 FB 8E     	ld		hl, FileData
 659+ 772A 01 00 68     	ld		bc, FileDataSize
 660+ 772D 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 661+ 772F CD 95 7D     	call	SERRB				;BC = Number of bytes read from COM
 662+ 7732 79           	ld		a, c
 663+ 7733 B0           	or		b
 664+ 7734 C8           	ret		z
 665+ 7735
 666+ 7735              	;If C is not 0, add one more sector.
 667+ 7735 79           	ld 		a, c
 668+ 7736 B7           	or		a
 669+ 7737 28 01        	jr		z, CopyFileFromCOMDontInc
 670+ 7739 04           	inc		b
 671+ 773A              CopyFileFromCOMDontInc:
 672+ 773A 78           	ld		a, b				;Sector size is 256
 673+ 773B 32 C4 80     	ld		(CopyFileSectCnt), a
 674+ 773E 3A D1 80     	ld		a, (CopyFileDstDrv)
 675+ 7741 21 D2 80     	ld		hl, CopyFileDstName
 676+ 7744 CD 70 77     	call	WriteFileSection
 677+ 7747
 678+ 7747 3A BD 80     	ld		a, (CopyFileRes)
 679+ 774A B7           	or		a
 680+ 774B 28 DA        	jr		z, CopyFileFromCOMLoop
 681+ 774D
 682+ 774D C9           	ret
 683+ 774E
 684+ 774E              ;Reads/Writes disk file portion to/from memory.
 685+ 774E              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 686+ 774E              ;This should work with single-drive file copy from one disk to another.
 687+ 774E              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records
 688+ 774E              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 689+ 774E              ;
 690+ 774E              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 691+ 774E              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 692+ 774E              ;Must use sequential read/write. But for the first operation must use random read/write.
 693+ 774E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 694+ 774E              ReadFileSection:
 695+ 774E 11 FF 73     	ld		de, BDOSReadFileBlockRandom
 696+ 7751 ED 53 B8 77  	ld		(CopyFileOperAddr1), de
 697+ 7755 11 F7 73     	ld		de, BDOSReadFileBlockSeq
 698+ 7758 ED 53 D7 77  	ld		(CopyFileOperAddr2), de
 699+ 775C 11 C0 80     	ld		de, FilePosRead
 700+ 775F ED 53 AF 77  	ld		(CopyFilePtr), de
 701+ 7763 ED 53 F3 77  	ld		(CopyFilePtr2), de
 702+ 7767
 703+ 7767              	;Limit max sectors to read to leave space for the index too.
 704+ 7767 F5           	push	af
 705+ 7768 3E 68        		ld		a, MAX_SECT_BUF
 706+ 776A 32 C4 80     		ld		(CopyFileSectCnt), a
 707+ 776D F1           	pop		af
 708+ 776E 18 19        	jr		ReadWriteFileSection
 709+ 7770
 710+ 7770              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 711+ 7770
 712+ 7770              WriteFileSection:
 713+ 7770 11 03 74     	ld		de, BDOSWriteFileBlockRandom
 714+ 7773 ED 53 B8 77  	ld		(CopyFileOperAddr1), de
 715+ 7777 11 FB 73     	ld		de, BDOSWriteFileBlockSeq
 716+ 777A ED 53 D7 77  	ld		(CopyFileOperAddr2), de
 717+ 777E 11 C2 80     	ld		de, FilePosWrite
 718+ 7781 ED 53 AF 77  	ld		(CopyFilePtr), de
 719+ 7785 ED 53 F3 77  	ld		(CopyFilePtr2), de
 720+ 7789
 721+ 7789
 722+ 7789              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 723+ 7789              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 724+ 7789              ReadWriteFileSection:
 725+ 7789 CD CB 73     	call	CreateChannel
 726+ 778C DD 22 BB 80  	ld		(CopyFileFCB), ix
 727+ 7790 CD EF 73     	call 	BDOSOpenFile
 728+ 7793 3C           	inc  	a						;Cancel if A==$FF
 729+ 7794 C8           	ret		z
 730+ 7795
 731+ 7795              	;Set DMA initial pointer = FileData
 732+ 7795 DD E5        	push	ix
 733+ 7797 21 FB 8E     		ld		hl, FileData
 734+ 779A DD 21 BE 80  		ld		ix, CopyFileDMAAddr
 735+ 779E DD 75 00     		ld		(ix), l
 736+ 77A1 DD 74 01     		ld		(ix+1), h
 737+ 77A4 DD 21 FB 8E  		ld		ix, FileData
 738+ 77A8 CD 11 74     		call 	BDOSSetDMA
 739+ 77AB DD E1        	pop		ix
 740+ 77AD
 741+ 77AD              CopyFilePtr EQU $+2
 742+ 77AD              	;Update file pointer using read/write random call.
 743+ 77AD ED 5B C0 80  	ld		de, (FilePosRead)
 744+ 77B1 DD 73 21     	ld		(ix + FCB_R0), e
 745+ 77B4 DD 72 22     	ld		(ix + FCB_R1), d
 746+ 77B7              CopyFileOperAddr1 EQU $ + 1
 747+ 77B7 CD FF 73     	call 	BDOSReadFileBlockRandom
 748+ 77BA
 749+ 77BA 32 BD 80     	ld		(CopyFileRes), a
 750+ 77BD B7           	or		a
 751+ 77BE 20 22        	jr		nz, ReadWriteFileSectionEnd
 752+ 77C0
 753+ 77C0 3A C4 80     	ld		a, (CopyFileSectCnt)
 754+ 77C3 47           	ld		b, a
 755+ 77C4
 756+ 77C4              ReadWriteFileSectionLoop:
 757+ 77C4 C5           	push	bc
 758+ 77C5 DD 2A BE 80  		ld		ix, (CopyFileDMAAddr)
 759+ 77C9 CD 11 74     		call 	BDOSSetDMA
 760+ 77CC DD 24        		inc		ixh
 761+ 77CE DD 22 BE 80  		ld		(CopyFileDMAAddr), ix
 762+ 77D2
 763+ 77D2 DD 2A BB 80  		ld		ix, (CopyFileFCB)
 764+ 77D6              CopyFileOperAddr2 EQU $ + 1
 765+ 77D6 CD F7 73     		call 	BDOSReadFileBlockSeq
 766+ 77D9 32 BD 80     		ld		(CopyFileRes), a
 767+ 77DC C1           	pop		bc
 768+ 77DD B7           	or		a
 769+ 77DE 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 770+ 77E0 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 771+ 77E2
 772+ 77E2              ReadWriteFileSectionEnd:
 773+ 77E2              	;Update sector count variable with how many sectors were transfered.
 774+ 77E2 3E 68        	ld 		a, MAX_SECT_BUF
 775+ 77E4 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 776+ 77E5 32 C4 80     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 777+ 77E8
 778+ 77E8              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 779+ 77E8 CD 15 74     	call	BDOSSetRandFilePtr
 780+ 77EB DD 5E 21     	ld		e, (ix + FCB_R0)
 781+ 77EE DD 56 22     	ld		d, (ix + FCB_R1)
 782+ 77F1              CopyFilePtr2 EQU $+2
 783+ 77F1 ED 53 C0 80  	ld		(FilePosRead), de
 784+ 77F5
 785+ 77F5 CD F3 73     	call 	BDOSCloseFile
 786+ 77F8 CD E1 73     	call 	DestroyChannel
 787+ 77FB
 788+ 77FB ED 5B BE 80  	ld		de, (CopyFileDMAAddr)
 789+ 77FF 15           	dec		d
 790+ 7800 C9           	ret
 791+ 7801
 792+ 7801              	ENDIF
 793+ 7801
# file closed: bdos.asm
1249  7801              	include "ui.asm"
# file opened: ui.asm
   1+ 7801              ;UI related functions
   2+ 7801
   3+ 7801              	ifndef	_UI_
   4+ 7801              	define	_UI_
   5+ 7801
   6+ 7801              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++7801              	ifndef	_HCCFG_
   2++7801 ~            	define	_HCCFG_
   3++7801 ~
   4++7801 ~            ;HC specific code, for configuration
   5++7801 ~
   6++7801 ~            HC_CFG_PORT			EQU	$7E
   7++7801 ~
   8++7801 ~            ;BASIC/CPM ROM selection
   9++7801 ~            HC_CFG_ROM_BAS		EQU	%0
  10++7801 ~            HC_CFG_ROM_CPM		EQU	%1
  11++7801 ~
  12++7801 ~            ;Address for ROM paging: 0 or $E000
  13++7801 ~            HC_CFG_ROM_0000		EQU %00
  14++7801 ~            HC_CFG_ROM_E000		EQU %10
  15++7801 ~
  16++7801 ~            ;Cfg. port Enable/Disable
  17++7801 ~            HC_CFG_PORT_DIS		EQU %000
  18++7801 ~            HC_CFG_PORT_EN		EQU	%100
  19++7801 ~
  20++7801 ~            ;Video memory bank: $4000 or $C000
  21++7801 ~            HC_CFG_VID_4000		EQU	%0000
  22++7801 ~            HC_CFG_VID_C000		EQU	%1000
  23++7801 ~
  24++7801 ~
  25++7801 ~            ;Standar BASIC config
  26++7801 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++7801 ~            ;Standar CP/M config
  28++7801 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++7801 ~
  30++7801 ~
  31++7801 ~            HC_VID_BANK0		EQU	$4000
  32++7801 ~            HC_VID_BANK1		EQU	$C000
  33++7801 ~
  34++7801              	endif
# file closed: hccfg.asm
   7+ 7801
   8+ 7801              COL             EQU 23728
   9+ 7801              LINE            EQU 23729               ;Coordinates
  10+ 7801              LineCol			EQU	COL
  11+ 7801              CODE			EQU 23681               ;Char to print
  12+ 7801
  13+ 7801              CPM_FNT         EQU $25AB
  14+ 7801
  15+ 7801              PORT_ZX			EQU	$FE
  16+ 7801
  17+ 7801              ;COLORS
  18+ 7801              CLR_BLACK		EQU 0
  19+ 7801              CLR_BLUE		EQU 1
  20+ 7801              CLR_RED			EQU 2
  21+ 7801              CLR_MAGENTA		EQU 3
  22+ 7801              CLR_GREEN		EQU 4
  23+ 7801              CLR_CYAN		EQU	5
  24+ 7801              CLR_YELLOW		EQU	6
  25+ 7801              CLR_WHITE		EQU	7
  26+ 7801              CLR_BRIGHT		EQU	%01000000
  27+ 7801              CLR_FLASH		EQU	%10000000
  28+ 7801
  29+ 7801              ;PAPER
  30+ 7801              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 7801              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 7801              PAPER_RED		EQU (CLR_RED << 3)
  33+ 7801              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 7801              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 7801              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 7801              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 7801              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 7801
  39+ 7801              ;INK
  40+ 7801              INK_BLACK		EQU CLR_BLACK
  41+ 7801              INK_BLUE		EQU CLR_BLUE
  42+ 7801              INK_RED			EQU CLR_RED
  43+ 7801              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 7801              INK_GREEN		EQU CLR_GREEN
  45+ 7801              INK_CYAN		EQU	CLR_CYAN
  46+ 7801              INK_YELLOW		EQU	CLR_YELLOW
  47+ 7801              INK_WHITE		EQU	CLR_WHITE
  48+ 7801
  49+ 7801
  50+ 7801              SCR_ATTR_ADDR	EQU 22528
  51+ 7801              SCR_ADDR		EQU 16384
  52+ 7801              SCR_PIX_LEN		EQU	6144
  53+ 7801              SCR_ATTR_LEN	EQU	768
  54+ 7801              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 7801              SCR_BYTES_PER_LINE	EQU	32
  56+ 7801
  57+ 7801              SCR_COLS		EQU	64
  58+ 7801              SCR_LINES		EQU 24
  59+ 7801
  60+ 7801              ;used for file names list positioning
  61+ 7801              LST_LINES_CNT	EQU	21
  62+ 7801              LST_FIRST_LINE	EQU	1
  63+ 7801              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 7801              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 7801              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 7801              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 7801              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 7801              LST_FIRST_COL	EQU	16
  69+ 7801              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 7801
  71+ 7801              ;key codes
  72+ 7801              KEY_ESC			EQU	7
  73+ 7801              KEY_LEFT		EQU	8
  74+ 7801              KEY_RIGHT		EQU	9
  75+ 7801              KEY_DOWN		EQU	10
  76+ 7801              KEY_UP			EQU	11
  77+ 7801              KEY_BACKSP		EQU 12
  78+ 7801              KEY_ENTER		EQU	13
  79+ 7801              KEY_CTRL		EQU	14
  80+ 7801
  81+ 7801              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 7801              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 7801              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 7801
  85+ 7801              ;Special formating chars
  86+ 7801              CHR_CR			EQU	13
  87+ 7801              CHR_LF			EQU	10
  88+ 7801              CHR_TAB			EQU	09
  89+ 7801
  90+ 7801
  91+ 7801              ;Semi-graphical chars
  92+ 7801              ;           UC
  93+ 7801              ;     UL +H-+--+UR
  94+ 7801              ;        |  |  |
  95+ 7801              ;     ML +--+--+MR
  96+ 7801              ;        V C|  |
  97+ 7801              ;     LL +--+--+LR
  98+ 7801              ;           DC
  99+ 7801              CHR_GRID        EQU 127
 100+ 7801              CHR_V           EQU	128
 101+ 7801              CHR_MR          EQU	129
 102+ 7801              CHR_UR          EQU 130
 103+ 7801              CHR_DL          EQU 131
 104+ 7801              CHR_DC          EQU 132
 105+ 7801              CHR_UC          EQU 133
 106+ 7801              CHR_ML          EQU 134
 107+ 7801              CHR_H           EQU 135
 108+ 7801              CHR_C           EQU 136
 109+ 7801              CHR_LR          EQU 137
 110+ 7801              CHR_UL          EQU 138
 111+ 7801              CHR_FULL        EQU 139
 112+ 7801              CHR_HALF        EQU 140
 113+ 7801
 114+ 7801              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 7801
 116+ 7801              ;Return read char in A
 117+ 7801              ReadChar:
 118+ 7801 CF           	rst 08
 119+ 7802 1B           	DEFB 27
 120+ 7803 C9           	ret
 121+ 7804
 122+ 7804              ;Checks if a key is pressed
 123+ 7804              ;Cy=1 if key is pressed
 124+ 7804              KbdHit:
 125+ 7804 CF           	rst 08
 126+ 7805 20           	DEFB 32
 127+ 7806 C9           	ret
 128+ 7807              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 7807
 130+ 7807              InitFonts:
 131+ 7807              	IFUSED
 132+ 7807                  ;page-in CPM ROM to get fonts
 133+ 7807 F3               di
 134+ 7808 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 780A D3 7E            out	(HC_CFG_PORT), a
 136+ 780C
 137+ 780C 21 AB 25     	ld		hl, CPM_FNT
 138+ 780F 11 93 8B     	ld		de, FontTable
 139+ 7812 01 68 03     	ld		bc, 872
 140+ 7815 ED B0        	ldir
 141+ 7817
 142+ 7817                  ;restore BASIC ROM
 143+ 7817 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 7819 D3 7E            out	(HC_CFG_PORT), a
 145+ 781B FB               ei
 146+ 781C
 147+ 781C C9           	ret
 148+ 781D              	ENDIF
 149+ 781D
 150+ 781D              ClrScr:
 151+ 781D 2A FC 79     	ld		hl, (CurrScrAddr)
 152+ 7820 54           	ld		d, h
 153+ 7821 5D           	ld		e, l
 154+ 7822 13           	inc		de
 155+ 7823 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 7826 36 00        	ld		(hl), 0
 157+ 7828 ED B0        	ldir
 158+ 782A
 159+ 782A 23           	inc 	hl
 160+ 782B 13           	inc		de
 161+ 782C
 162+ 782C 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 782F 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 7831 ED B0        	ldir
 165+ 7833
 166+ 7833              	;also set border color
 167+ 7833 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 7835 D3 FE        	out		(PORT_ZX), a
 169+ 7837
 170+ 7837 3E 45        	ld		a, SCR_DEF_CLR
 171+ 7839 32 48 5C     	ld		(23624), a
 172+ 783C C9           	ret
 173+ 783D
 174+ 783D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 783D              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 783D              PrintStr:
 177+ 783D 7E           	ld		a, (hl)
 178+ 783E FE 20        	cp		' '
 179+ 7840 30 02        	jr		nc, GoodChar
 180+ 7842 3E 3F        	ld		a, '?'
 181+ 7844              GoodChar:
 182+ 7844 CB 7F        	bit		7, a
 183+ 7846 CB BF        	res		7, a
 184+ 7848 32 81 5C     	ld		(CODE), a
 185+ 784B ED 53 B0 5C  	ld		(LineCol), de
 186+ 784F 08           	ex		af, af'
 187+ 7850 D9           	exx
 188+ 7851 E5           	push	hl
 189+ 7852 CD 69 79     	call 	PrintChar
 190+ 7855 E1           	pop		hl
 191+ 7856 D9           	exx
 192+ 7857 08           	ex		af, af'
 193+ 7858 C0           	ret		nz
 194+ 7859
 195+ 7859 1C           	inc		e
 196+ 785A 23           	inc		hl
 197+ 785B
 198+ 785B 7B           	ld		a, e
 199+ 785C FE 40        	cp		64
 200+ 785E 38 DD        	jr		c, PrintStr
 201+ 7860 1E 00        	ld		e, 0
 202+ 7862 14           	inc		d
 203+ 7863
 204+ 7863 18 D8        	jr		PrintStr
 205+ 7865
 206+ 7865              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 7865
 208+ 7865              ;IN: HL = string, DE = coords, A = color
 209+ 7865              PrintStrClr:
 210+ 7865 32 91 78     	ld		(StrClr), a
 211+ 7868 D5           	push	de
 212+ 7869 CD 3D 78     		call	PrintStr
 213+ 786C E1           	pop		hl
 214+ 786D              	;get string len.
 215+ 786D 7B           	ld		a, e
 216+ 786E 95           	sub		l
 217+ 786F 1F           	rra
 218+ 7870 08           	ex		af, af'
 219+ 7871              		;line * 32
 220+ 7871 7C           		ld		a, h
 221+ 7872 17           		rla
 222+ 7873 17           		rla
 223+ 7874 11 00 00     		ld	de, 0
 224+ 7877 17           		rla
 225+ 7878 CB 12        		rl	d
 226+ 787A 17           		rla
 227+ 787B CB 12        		rl	d
 228+ 787D 17           		rla
 229+ 787E CB 12        		rl	d
 230+ 7880 5F           		ld	e, a
 231+ 7881
 232+ 7881 26 00        		ld		h, 0
 233+ 7883 19           		add		hl, de
 234+ 7884 ED 5B FE 79  		ld		de, (CurrScrAttrAddr)
 235+ 7888 19           		add		hl, de
 236+ 7889 08           	ex		af, af'
 237+ 788A 4F           	ld		c, a
 238+ 788B 06 00        	ld		b, 0
 239+ 788D 54           	ld		d, h
 240+ 788E 5D           	ld		e, l
 241+ 788F 13           	inc 	de
 242+ 7890              StrClr	EQU	$ + 1
 243+ 7890 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 7892 ED B0        	ldir
 245+ 7894 C9           	ret
 246+ 7895              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 7895
 248+ 7895              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 7895              DrawLine:
 250+ 7895 32 81 5C     	ld		(CODE), a
 251+ 7898
 252+ 7898 38 04        	jr		c, VertDir
 253+ 789A 3E 1C        	ld		a, $1C
 254+ 789C 18 02        	jr		StoreDir
 255+ 789E              VertDir:
 256+ 789E 3E 14        	ld		a, $14
 257+ 78A0              StoreDir:
 258+ 78A0 32 B0 78     	ld		(LineDir), a
 259+ 78A3
 260+ 78A3              DrawLineLoop:
 261+ 78A3 ED 53 B0 5C  	ld		(LineCol), de
 262+ 78A7 D5           	push	de
 263+ 78A8 D9           		exx
 264+ 78A9 E5           		push	hl
 265+ 78AA CD 69 79     		call 	PrintChar
 266+ 78AD E1           		pop		hl
 267+ 78AE D9           		exx
 268+ 78AF D1           	pop		de
 269+ 78B0              LineDir:
 270+ 78B0 1C           	inc		e
 271+ 78B1 10 F0        	djnz	DrawLineLoop
 272+ 78B3
 273+ 78B3 C9           	ret
 274+ 78B4
 275+ 78B4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 78B4
 277+ 78B4              DrawHLines:
 278+ 78B4 11 00 00     	ld		de, 0
 279+ 78B7 06 40        	ld		b, 64
 280+ 78B9 3E 87        	ld		a, CHR_H
 281+ 78BB B7           	or		a
 282+ 78BC CD 95 78     	call	DrawLine
 283+ 78BF
 284+ 78BF 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 78C2 06 40        	ld		b, 64
 286+ 78C4 3E 87        	ld		a, CHR_H
 287+ 78C6 B7           	or		a
 288+ 78C7 CD 95 78     	call	DrawLine
 289+ 78CA
 290+ 78CA 06 04        	ld		b, 4
 291+ 78CC 11 10 00     	ld		de, LST_FIRST_COL
 292+ 78CF              DrawUpperIntersectLoop:
 293+ 78CF C5           	push	bc
 294+ 78D0 D5           	push	de
 295+ 78D1 3E 85        		ld		a, CHR_UC
 296+ 78D3 CD F5 78     		call	DrawIntersect
 297+ 78D6 D1           	pop		de
 298+ 78D7 C1           	pop		bc
 299+ 78D8 21 0C 00     	ld		hl, NAMELEN+1
 300+ 78DB 19           	add		hl, de
 301+ 78DC EB           	ex		de, hl
 302+ 78DD 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 78DF
 304+ 78DF 06 04        	ld		b, 4
 305+ 78E1 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 78E4              DrawLowerIntersectLoop:
 307+ 78E4 C5           	push	bc
 308+ 78E5 D5           	push	de
 309+ 78E6 3E 84        		ld		a, CHR_DC
 310+ 78E8 CD F5 78     		call	DrawIntersect
 311+ 78EB D1           	pop		de
 312+ 78EC C1           	pop		bc
 313+ 78ED 21 0C 00     	ld		hl, NAMELEN+1
 314+ 78F0 19           	add		hl, de
 315+ 78F1 EB           	ex		de, hl
 316+ 78F2 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 78F4
 318+ 78F4 C9           	ret
 319+ 78F5
 320+ 78F5
 321+ 78F5              DrawIntersect:
 322+ 78F5 21 B0 5C     	ld		hl, LineCol
 323+ 78F8 73 23 72 2B  	ld		(hl), de
 324+ 78FC 32 81 5C     	ld		(CODE), a
 325+ 78FF E5           	push	hl
 326+ 7900 CD 69 79     	call	PrintChar
 327+ 7903 E1           	pop		hl
 328+ 7904 34           	inc		(hl)
 329+ 7905 3E 87        	ld		a, CHR_H
 330+ 7907 32 81 5C     	ld		(CODE), a
 331+ 790A CD 69 79     	call	PrintChar
 332+ 790D C9           	ret
 333+ 790E
 334+ 790E
 335+ 790E              DrawVLines:
 336+ 790E 06 04        	ld		b, 4
 337+ 7910 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 338+ 7913              DrawVLinesLoop:
 339+ 7913 C5           	push 	bc
 340+ 7914 D5           	push	de
 341+ 7915 06 15        		ld		b, LST_LINES_CNT
 342+ 7917 3E 80        		ld		a, CHR_V
 343+ 7919 37           		scf
 344+ 791A CD 95 78     		call	DrawLine
 345+ 791D D1           	pop		de
 346+ 791E C1           	pop	bc
 347+ 791F 7B           	ld		a, e
 348+ 7920 C6 0C        	add		NAMELEN+1
 349+ 7922 5F           	ld		e, a
 350+ 7923 10 EE        	djnz	DrawVLinesLoop
 351+ 7925 C9           	ret
 352+ 7926
 353+ 7926              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 354+ 7926
 355+ 7926              ;IN: A = color mask
 356+ 7926              DrawCursor:
 357+ 7926 ED 5B B4 80  	ld	de, (CursorAddr)
 358+ 792A 06 06        	ld	b, 	(NAMELEN + 1)/2
 359+ 792C              DrawCursorLoop:
 360+ 792C 12           	ld	(de), a
 361+ 792D 13           	inc de
 362+ 792E 10 FC        	djnz DrawCursorLoop
 363+ 7930 C9           	ret
 364+ 7931
 365+ 7931              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 366+ 7931
 367+ 7931              ;IN:	A = file idx.
 368+ 7931              MoveCursor:
 369+ 7931              	;File idx / SCR_LINES => cursor line & column
 370+ 7931 6F           	ld		l, a
 371+ 7932 26 00        	ld		h, 0
 372+ 7934 0E 15        	ld		c, LST_LINES_CNT
 373+ 7936 CD 9E 6F     	call	Div					;HL = file column, A = line
 374+ 7939
 375+ 7939              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 376+ 7939 C6 01        	add		LST_FIRST_LINE
 377+ 793B
 378+ 793B
 379+ 793B 54           	ld d, h
 380+ 793C 5D           	ld e, l
 381+ 793D 21 00 00     	ld	hl, 0
 382+ 7940
 383+ 7940              	;line*32
 384+ 7940 17           	rla
 385+ 7941 17           	rla
 386+ 7942 17           	rla
 387+ 7943 17           	rla
 388+ 7944 CB 14        	rl h
 389+ 7946 17           	rla
 390+ 7947 CB 14        	rl h
 391+ 7949 6F           	ld l, a
 392+ 794A
 393+ 794A
 394+ 794A              	;col * 6
 395+ 794A E5           	push	hl					;save line * 32
 396+ 794B 3E 06        		ld		a, (NAMELEN + 1)/2
 397+ 794D CD BE 6F     		call	Mul				;HL = column * 12/2
 398+ 7950 D1           	pop		de
 399+ 7951 19           	add		hl, de
 400+ 7952
 401+ 7952 11 08 00     	ld		de, LST_FIRST_COL/2
 402+ 7955 ED 4B FE 79  	ld		bc, (CurrScrAttrAddr)
 403+ 7959 19           	add		hl, de
 404+ 795A 09           	add		hl, bc
 405+ 795B
 406+ 795B              	;clear old cursor
 407+ 795B 3E 45        	ld		a, SCR_DEF_CLR
 408+ 795D CD 26 79     	call	DrawCursor
 409+ 7960
 410+ 7960              	;draw new one
 411+ 7960 22 B4 80     	ld		(CursorAddr), hl
 412+ 7963 3E 60        	ld		a, SCR_SEL_CLR
 413+ 7965 CD 26 79     	call	DrawCursor
 414+ 7968
 415+ 7968 C9           	ret
 416+ 7969
 417+ 7969              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 418+ 7969
 419+ 7969              PrintChar:
 420+ 7969 ED 5B B0 5C      ld		de, (LineCol)
 421+ 796D
 422+ 796D                  ;calculate 64 column screen address
 423+ 796D              	;IN: D = line, E = col
 424+ 796D              	;OUT: HL = screen address
 425+ 796D
 426+ 796D CB 3B            SRL     E                                       ;col = col/2
 427+ 796F CB 19            RR      C                                       ;mark odd/even column
 428+ 7971 7A               LD      A, D                            ;A = line
 429+ 7972 E6 18            AND 24                                  ;keep only %00011000
 430+ 7974 2A FC 79         ld		hl, (CurrScrAddr)
 431+ 7977 B4               OR      h								;add screen start address
 432+ 7978 67               LD      H, A                            ;save H
 433+ 7979 7A               LD      A, D                            ;A = line
 434+ 797A E6 07            AND 7                                   ;keep only %00000111
 435+ 797C 0F               RRCA                                    ;%10000011
 436+ 797D 0F               RRCA                                    ;%11000001
 437+ 797E 0F               RRCA                                    ;%11100000
 438+ 797F B3               OR      E                                       ;add column
 439+ 7980 6F               LD      L, A                            ;HL = screen address
 440+ 7981
 441+ 7981              PrintChar3:
 442+ 7981                  ;get font address
 443+ 7981 E5               PUSH HL
 444+ 7982 AF                   XOR A
 445+ 7983 67                   LD  H, A
 446+ 7984 3A 81 5C             LD  A, (CODE)
 447+ 7987 D6 20                SUB ' '
 448+ 7989 6F                   LD  L, A
 449+ 798A 29                   ADD     HL, HL                  ;char code = char code * 8
 450+ 798B 29                   ADD     HL, HL                  ;i.e. offset into font table
 451+ 798C 29                   ADD     HL, HL
 452+ 798D 11 93 8B             LD      DE, FontTable             ;get font table
 453+ 7990 19                   ADD     HL, DE
 454+ 7991 EB                   EX      DE, HL                  ;DE = our char font address
 455+ 7992 E1               POP     HL
 456+ 7993
 457+ 7993
 458+ 7993                  ;print a char
 459+ 7993 06 08            LD      B, 8                            ;char height is 8 lines
 460+ 7995              PrintCharLine:
 461+ 7995 1A                   LD      A, (DE)                         ;load char line in A
 462+ 7996
 463+ 7996 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 464+ 7998 20 06                JR  	NZ, NoTurn
 465+ 799A
 466+ 799A 07                   RLCA
 467+ 799B 07                   RLCA
 468+ 799C 07                   RLCA
 469+ 799D 07                   RLCA
 470+ 799E 18 01                JR      Store
 471+ 79A0              NoTurn:
 472+ 79A0 B6                   OR (HL)
 473+ 79A1              Store:
 474+ 79A1 77                   LD (HL), A
 475+ 79A2
 476+ 79A2 13                   INC     DE                                      ;next char line in font table
 477+ 79A3 24                   INC     H                                       ;next char line on screen
 478+ 79A4 10 EF            DJNZ PrintCharLine                  ;last line of char?
 479+ 79A6
 480+ 79A6 C9               ret
 481+ 79A7
 482+ 79A7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 483+ 79A7
 484+ 79A7              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 485+ 79A7              ReadString:
 486+ 79A7 21 FB 8E     	ld		hl, FileData
 487+ 79AA D5           	push	de
 488+ 79AB DD E1        	pop		ix
 489+ 79AD
 490+ 79AD              ReadStringLoop:
 491+ 79AD D5           	push	de
 492+ 79AE E5           	push	hl
 493+ 79AF CD 01 78     		call ReadChar
 494+ 79B2 E1           	pop		hl
 495+ 79B3 D1           	pop		de
 496+ 79B4
 497+ 79B4 FE 0D        	cp	KEY_ENTER
 498+ 79B6 C8           	ret z
 499+ 79B7
 500+ 79B7 FE 0C        	cp  KEY_BACKSP
 501+ 79B9 20 0F        	jr	nz, ReadStrChar
 502+ 79BB
 503+ 79BB E5           	push hl
 504+ 79BC 01 FC 8E     	ld   bc, FileData+1
 505+ 79BF ED 42        	sbc	 hl, bc
 506+ 79C1 E1           	pop  hl
 507+ 79C2 38 16        	jr   c, ReadStrPrint
 508+ 79C4
 509+ 79C4 1B           	dec	de
 510+ 79C5 2B           	dec	hl
 511+ 79C6 36 20        	ld	(hl), ' '
 512+ 79C8 18 10        	jr	ReadStrPrint
 513+ 79CA
 514+ 79CA              ReadStrChar:
 515+ 79CA FE 20        	cp	' '
 516+ 79CC 38 DF        	jr	c, ReadStringLoop
 517+ 79CE FE 7F        	cp  127
 518+ 79D0 30 DB        	jr	nc, ReadStringLoop
 519+ 79D2
 520+ 79D2              	;Check end of string and go back if found.
 521+ 79D2 46           	ld	b, (hl)
 522+ 79D3 CB 78        	bit 7, b
 523+ 79D5 20 03        	jr	nz, ReadStrPrint
 524+ 79D7
 525+ 79D7 77           	ld	(hl), a
 526+ 79D8 23           	inc	hl
 527+ 79D9 13           	inc	de
 528+ 79DA
 529+ 79DA              ReadStrPrint:
 530+ 79DA E5           	push	hl
 531+ 79DB D5           	push	de
 532+ 79DC 21 FB 8E     	ld		hl, FileData
 533+ 79DF DD E5        	push	ix
 534+ 79E1 D1           	pop		de
 535+ 79E2 CD 3D 78     	call	PrintStr
 536+ 79E5 D1           	pop		de
 537+ 79E6 E1           	pop		hl
 538+ 79E7
 539+ 79E7 18 C4        	jr		ReadStringLoop
 540+ 79E9
 541+ 79E9              ClearNMsgLines:
 542+ 79E9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 543+ 79EC              ClearNMsgLinesLoop:
 544+ 79EC D5           	push	de
 545+ 79ED C5           	push	bc
 546+ 79EE 21 8C 7F     	ld		hl, MsgClear
 547+ 79F1 3E 45        	ld		a, SCR_DEF_CLR
 548+ 79F3 CD 65 78     	call	PrintStrClr
 549+ 79F6 C1           	pop		bc
 550+ 79F7 D1           	pop		de
 551+ 79F8 14           	inc		d
 552+ 79F9 10 F1        	djnz	ClearNMsgLinesLoop
 553+ 79FB
 554+ 79FB C9           	ret
 555+ 79FC
 556+ 79FC 00 40        CurrScrAddr		DEFW	SCR_ADDR
 557+ 79FE 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 558+ 7A00
 559+ 7A00                 	endif
# file closed: ui.asm
1250  7A00              	include "math.asm"
# file opened: math.asm
   1+ 7A00              	ifndef	_MATH_
   2+ 7A00 ~            	define	_MATH_
   3+ 7A00 ~
   4+ 7A00 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 7A00 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 7A00 ~
   7+ 7A00 ~
   8+ 7A00 ~            Word2Txt:
   9+ 7A00 ~            	IFUSED
  10+ 7A00 ~            	push	de
  11+ 7A00 ~            		call	Word2Txt_
  12+ 7A00 ~            	pop		de
  13+ 7A00 ~
  14+ 7A00 ~            	ld		b, 4
  15+ 7A00 ~            	call	StrippLeading0
  16+ 7A00 ~            	ret
  17+ 7A00 ~
  18+ 7A00 ~            Byte2Txt:
  19+ 7A00 ~            	push	de
  20+ 7A00 ~            		call	Byte2Txt_
  21+ 7A00 ~            	pop		de
  22+ 7A00 ~
  23+ 7A00 ~            	ld		b, 2
  24+ 7A00 ~            	call	StrippLeading0
  25+ 7A00 ~            	ret
  26+ 7A00 ~            	ENDIF
  27+ 7A00 ~
  28+ 7A00 ~
  29+ 7A00 ~            StrippLeading0:
  30+ 7A00 ~            	ld		a, (de)
  31+ 7A00 ~            	cp		'1'
  32+ 7A00 ~            	ret		nc
  33+ 7A00 ~
  34+ 7A00 ~            	ld		a, ' '
  35+ 7A00 ~            	ld		(de), a
  36+ 7A00 ~            	inc		de
  37+ 7A00 ~            	djnz	StrippLeading0
  38+ 7A00 ~            	ret
  39+ 7A00 ~
  40+ 7A00 ~
  41+ 7A00 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 7A00 ~            Word2Txt_:
  43+ 7A00 ~            	ld bc, -10000
  44+ 7A00 ~            	call DigitLoop
  45+ 7A00 ~            	ld bc, -1000
  46+ 7A00 ~            	call DigitLoop
  47+ 7A00 ~            Byte2Txt_:
  48+ 7A00 ~            	ld bc, -100
  49+ 7A00 ~            	call DigitLoop
  50+ 7A00 ~            	ld bc, -10
  51+ 7A00 ~            	call DigitLoop
  52+ 7A00 ~            	ld bc, -1
  53+ 7A00 ~
  54+ 7A00 ~            DigitLoop:
  55+ 7A00 ~            	ld	a, '0' - 1
  56+ 7A00 ~            DivNrLoop:
  57+ 7A00 ~            	inc	a			;increase reminder
  58+ 7A00 ~            	add	hl, bc		;substract divizor
  59+ 7A00 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 7A00 ~            	sbc	hl, bc		;nope, restore
  61+ 7A00 ~
  62+ 7A00 ~            	ld (de), a
  63+ 7A00 ~            	inc de
  64+ 7A00 ~            	ret
  65+ 7A00 ~
  66+ 7A00 ~
  67+ 7A00 ~            ;Input: HL = Dividend, C = Divisor
  68+ 7A00 ~            ;Output: HL = Quotient, A = Remainder
  69+ 7A00 ~            ;Warning: doesn't work with divisor >= $80
  70+ 7A00 ~            Div:
  71+ 7A00 ~            	IFUSED
  72+ 7A00 ~            	xor a
  73+ 7A00 ~            	ld b, 16
  74+ 7A00 ~
  75+ 7A00 ~            DivLoop:
  76+ 7A00 ~            	add	hl,hl
  77+ 7A00 ~            	rla
  78+ 7A00 ~            	cp	c
  79+ 7A00 ~            	jr	c, NoSub
  80+ 7A00 ~            	sub	c
  81+ 7A00 ~            	inc	l
  82+ 7A00 ~            NoSub:
  83+ 7A00 ~            	djnz DivLoop
  84+ 7A00 ~
  85+ 7A00 ~            	ret
  86+ 7A00 ~            	ENDIF
  87+ 7A00 ~
  88+ 7A00 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 7A00 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 7A00 ~            Div2:
  91+ 7A00 ~            	ld hl, 0
  92+ 7A00 ~            	ld b, 16
  93+ 7A00 ~            Div2Loop:
  94+ 7A00 ~            	sll c		; unroll 16 times
  95+ 7A00 ~            	rla			; ...
  96+ 7A00 ~            	adc	hl,hl		; ...
  97+ 7A00 ~            	sbc	hl,de		; ...
  98+ 7A00 ~            	jr	nc,$+4		; ...
  99+ 7A00 ~            	add	hl,de		; ...
 100+ 7A00 ~            	dec	c		; ...
 101+ 7A00 ~            	djnz Div2Loop
 102+ 7A00 ~            	ret
 103+ 7A00 ~
 104+ 7A00 ~
 105+ 7A00 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 7A00 ~            ;Output: A:HL = Product
 107+ 7A00 ~            Mul:
 108+ 7A00 ~            	IFUSED
 109+ 7A00 ~            	ld hl, 0
 110+ 7A00 ~            	ld bc, $0700
 111+ 7A00 ~
 112+ 7A00 ~            	add	a, a		; optimised 1st iteration
 113+ 7A00 ~            	jr	nc, MulLoop
 114+ 7A00 ~            	ld	h, d
 115+ 7A00 ~            	ld	l, e
 116+ 7A00 ~
 117+ 7A00 ~            MulLoop:
 118+ 7A00 ~            	add	hl,hl
 119+ 7A00 ~            	rla
 120+ 7A00 ~            	jr	nc, NoAdd
 121+ 7A00 ~            	add	hl,de
 122+ 7A00 ~            	adc	a,c
 123+ 7A00 ~            NoAdd:
 124+ 7A00 ~            	djnz MulLoop
 125+ 7A00 ~
 126+ 7A00 ~            	ret
 127+ 7A00 ~            	ENDIF
 128+ 7A00 ~
 129+ 7A00              	endif
# file closed: math.asm
1251  7A00              	include "txtview.asm"
# file opened: txtview.asm
   1+ 7A00              ; 	DEVICE ZXSPECTRUM48
   2+ 7A00
   3+ 7A00              LINE_CNT	EQU	23
   4+ 7A00              COL_CNT		EQU	64
   5+ 7A00
   6+ 7A00              CHAR_CR		EQU	$0D
   7+ 7A00              CHAR_LF		EQU	$0A
   8+ 7A00              CHAR_TAB	EQU	$09
   9+ 7A00              CHAR_EOF	EQU	$1A
  10+ 7A00
  11+ 7A00              COORDS		EQU	23728		;Coordinates
  12+ 7A00
  13+ 7A00
  14+ 7A00              InitViewer:
  15+ 7A00 22 4B 7D     	ld		 (FileBegin), hl
  16+ 7A03 09           	add		hl, bc
  17+ 7A04              	;must filter any EOF chars.
  18+ 7A04 3E 1A        	ld		a, CHAR_EOF
  19+ 7A06 25           	dec		h
  20+ 7A07 25           	dec		h
  21+ 7A08 01 00 04     	ld		bc, SECT_SZ	* 4
  22+ 7A0B ED B1        	cpir
  23+ 7A0D 2B           	dec		hl
  24+ 7A0E 22 4F 7D     	ld		(FileEnd), hl
  25+ 7A11 ED 5B 4B 7D  	ld		de, (FileBegin)
  26+ 7A15 B7           	or		a
  27+ 7A16 ED 52        	sbc		hl, de
  28+ 7A18 22 4D 7D     	ld		(FileLen), hl
  29+ 7A1B
  30+ 7A1B 3E 0D        	ld		a, CHAR_CR
  31+ 7A1D 77           	ld		(hl), a
  32+ 7A1E
  33+ 7A1E
  34+ 7A1E 21 04 02     	ld		hl, (2 << 8) | 4
  35+ 7A21 22 09 5C     	ld		(REPDEL), hl
  36+ 7A24
  37+ 7A24 21 00 00     	ld		hl, 0
  38+ 7A27 22 B0 5C     	ld		(COORDS), hl
  39+ 7A2A
  40+ 7A2A 21 00 58     	ld		hl, SCR_ADDR + SCR_PIX_LEN
  41+ 7A2D 54           	ld		d, h
  42+ 7A2E 5D           	ld		e, l
  43+ 7A2F 13           	inc		de
  44+ 7A30 01 FF 02     	ld		bc, 767
  45+ 7A33 36 45        	ld		(hl), SCR_DEF_CLR
  46+ 7A35 ED B0        	ldir
  47+ 7A37
  48+ 7A37 CD 52 7C     	call	ScrollInit
  49+ 7A3A
  50+ 7A3A 11 00 00     	ld		de, 0
  51+ 7A3D ED 53 48 7D  	ld		(CurLine), de
  52+ 7A41
  53+ 7A41              	;prepare file progress %
  54+ 7A41 2A 4D 7D     	ld		hl, (FileLen)
  55+ 7A44 7C           	ld		a, h
  56+ 7A45 4D           	ld		c, l
  57+ 7A46 11 64 00     	ld		de, 100
  58+ 7A49 CD AB 6F     	call	Div2
  59+ 7A4C 67           	ld		h, a
  60+ 7A4D 69           	ld		l, c
  61+ 7A4E 22 51 7D     	ld		(PROGR_PERC), hl
  62+ 7A51
  63+ 7A51 CD E1 7B     	call	PrintMsg
  64+ 7A54
  65+ 7A54 DD 21 F9 F6  	ld		ix, FileIdx	- 2
  66+ 7A58 06 17        	ld		b, LINE_CNT
  67+ 7A5A 2A 4B 7D     	ld		hl, (FileBegin)
  68+ 7A5D
  69+ 7A5D C9           	ret
  70+ 7A5E
  71+ 7A5E
  72+ 7A5E              PrintLoop:
  73+ 7A5E C5           	push	bc
  74+ 7A5F DD 23        		inc		ix
  75+ 7A61 DD 23        		inc		ix
  76+ 7A63 DD 75 00     		ld		(ix), l
  77+ 7A66 DD 74 01     		ld		(ix + 1), h
  78+ 7A69
  79+ 7A69 CD 7F 7B     		call	GetLine
  80+ 7A6C CD 51 7B     		call	PrintLine
  81+ 7A6F
  82+ 7A6F ED 5B 48 7D  		ld		de, (CurLine)
  83+ 7A73 13           		inc		de
  84+ 7A74 ED 53 48 7D  		ld		(CurLine), de
  85+ 7A78 C1           	pop		bc
  86+ 7A79 CD 46 7B     	call	CheckEnd
  87+ 7A7C 38 13        	jr		c, ViewFileEOF
  88+ 7A7E
  89+ 7A7E 10 DE        	djnz	PrintLoop
  90+ 7A80 18 17        	jr		PrintLoop2
  91+ 7A82
  92+ 7A82              GetKey:
  93+ 7A82 76           	halt
  94+ 7A83 FD CB 01 6E  	bit		5, (iy + 1);
  95+ 7A87 28 F9        	jr		z, GetKey
  96+ 7A89 FD CB 01 AE  	res		5, (iy + 1)
  97+ 7A8D FD 7E CE     	ld		a, (iy - $32)
  98+ 7A90 C9           	ret
  99+ 7A91
 100+ 7A91              ViewFileEOF:
 101+ 7A91 CD 82 7A     	call	GetKey
 102+ 7A94 FE 30        	cp		'0'
 103+ 7A96 20 F9        	jr		nz, ViewFileEOF
 104+ 7A98 C9           	ret
 105+ 7A99
 106+ 7A99              PrintLoop2:
 107+ 7A99 CD E1 7B     	call	PrintMsg
 108+ 7A9C
 109+ 7A9C CD 82 7A     	call	GetKey
 110+ 7A9F FE 30        	cp		'0'					;Exit on 0
 111+ 7AA1 C8           	ret		z
 112+ 7AA2
 113+ 7AA2 FE 0A        	cp		KEY_DOWN
 114+ 7AA4 28 5C        	jr		z, Down
 115+ 7AA6
 116+ 7AA6 FE 0B        	cp		KEY_UP
 117+ 7AA8 28 2D        	jr		z, Up
 118+ 7AAA
 119+ 7AAA FE 32        	cp		'2'
 120+ 7AAC 20 EB        	jr		nz, PrintLoop2
 121+ 7AAE
 122+ 7AAE 3A 4A 7D     	ld		a, (WrapFlag)
 123+ 7AB1 EE 01        	xor		1
 124+ 7AB3 32 4A 7D     	ld		(WrapFlag), a
 125+ 7AB6 B7           	or		a
 126+ 7AB7 28 0F        	jr		z, NoWrap
 127+ 7AB9
 128+ 7AB9 11 4F 6E     	ld		de, 'nO'
 129+ 7ABC ED 53 FD 7C  	ld		(MsgLineWrF), de
 130+ 7AC0 3E 20        	ld		a, ' '
 131+ 7AC2 32 FF 7C     	ld		(MsgLineWrF + 2), a
 132+ 7AC5 C3 99 7A     	jp		PrintLoop2
 133+ 7AC8
 134+ 7AC8              NoWrap:
 135+ 7AC8 11 4F 66     	ld		de, 'fO'
 136+ 7ACB ED 53 FD 7C  	ld		(MsgLineWrF), de
 137+ 7ACF 3E 66        	ld		a, 'f'
 138+ 7AD1 32 FF 7C     	ld		(MsgLineWrF + 2), a
 139+ 7AD4
 140+ 7AD4 C3 99 7A     	jp		PrintLoop2
 141+ 7AD7
 142+ 7AD7
 143+ 7AD7              Up:
 144+ 7AD7 CD 36 7B     	call	CheckBegin
 145+ 7ADA 28 BD        	jr		z, PrintLoop2
 146+ 7ADC
 147+ 7ADC CD 80 7C     	call	ScrollUp
 148+ 7ADF
 149+ 7ADF DD 2B        	dec		ix
 150+ 7AE1 DD 2B        	dec		ix
 151+ 7AE3 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 152+ 7AE6 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 153+ 7AE9 CD 7F 7B     	call	GetLine						;extract previous line to display
 154+ 7AEC
 155+ 7AEC 11 00 00     	ld		de, 0
 156+ 7AEF ED 53 B0 5C  	ld		(COORDS), de
 157+ 7AF3 CD 51 7B     	call	PrintLine
 158+ 7AF6
 159+ 7AF6 2A 48 7D     	ld		hl, (CurLine)
 160+ 7AF9 2B           	dec		hl
 161+ 7AFA 22 48 7D     	ld		(CurLine), hl
 162+ 7AFD CD E1 7B     	call	PrintMsg
 163+ 7B00 18 97        	jr		PrintLoop2
 164+ 7B02
 165+ 7B02
 166+ 7B02              Down:
 167+ 7B02 DD 6E 00     	ld		l, (ix)
 168+ 7B05 DD 66 01     	ld		h, (ix + 1)
 169+ 7B08 CD 7F 7B     	call	GetLine						;get next line pointer
 170+ 7B0B
 171+ 7B0B CD 46 7B     	call	CheckEnd					;check if HL == file end
 172+ 7B0E D8           	ret		c
 173+ 7B0F
 174+ 7B0F DD 23        	inc		ix								;save next line pointer
 175+ 7B11 DD 23        	inc		ix
 176+ 7B13 DD 75 00     	ld		(ix), l
 177+ 7B16 DD 74 01     	ld		(ix + 1), h
 178+ 7B19
 179+ 7B19 CD 7F 7B     	call	GetLine						;extract next line in buffer for display
 180+ 7B1C
 181+ 7B1C CD 85 7C     	call	ScrollDown
 182+ 7B1F
 183+ 7B1F 11 00 16     	ld		de, (LINE_CNT-1) << 8
 184+ 7B22 ED 53 B0 5C  	ld		(COORDS), de
 185+ 7B26 CD 51 7B     	call	PrintLine
 186+ 7B29
 187+ 7B29 2A 48 7D     	ld		hl, (CurLine)
 188+ 7B2C 23           	inc		hl
 189+ 7B2D 22 48 7D     	ld		(CurLine), hl
 190+ 7B30 CD E1 7B     	call	PrintMsg
 191+ 7B33
 192+ 7B33 C3 99 7A     	jp		PrintLoop2
 193+ 7B36
 194+ 7B36
 195+ 7B36              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 196+ 7B36              ;check begining of buffer
 197+ 7B36              CheckBegin:
 198+ 7B36 E5           	push	hl
 199+ 7B37 DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 200+ 7B3A DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 201+ 7B3D ED 5B 4B 7D  		ld		de, (FileBegin)
 202+ 7B41 B7           		or		a
 203+ 7B42 ED 52        		sbc		hl, de
 204+ 7B44 E1           	pop		hl
 205+ 7B45 C9           	ret
 206+ 7B46
 207+ 7B46              ;check end of buffer
 208+ 7B46              CheckEnd:
 209+ 7B46 E5           	push	hl
 210+ 7B47 ED 5B 4F 7D  		ld		de, (FileEnd)
 211+ 7B4B EB           		ex		de, hl
 212+ 7B4C B7           		or		a
 213+ 7B4D ED 52        		sbc		hl, de
 214+ 7B4F E1           	pop		hl
 215+ 7B50 C9           	ret
 216+ 7B51
 217+ 7B51              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 7B51              ;Print a line
 219+ 7B51              PrintLine:
 220+ 7B51 11 08 7D     	ld		de, LineBuf
 221+ 7B54 06 40        	ld		b, COL_CNT
 222+ 7B56
 223+ 7B56 CD 65 7B     	call	PrintStrTxt
 224+ 7B59
 225+ 7B59              	;go to the next screen line
 226+ 7B59 ED 5B B0 5C  	ld		de, (COORDS)
 227+ 7B5D 14           	inc		d
 228+ 7B5E 1E 00        	ld		e, 0
 229+ 7B60 ED 53 B0 5C  	ld		(COORDS), de
 230+ 7B64 C9           	ret
 231+ 7B65
 232+ 7B65              PrintStrTxt:
 233+ 7B65 1A           	ld		a, (de)
 234+ 7B66 13           	inc		de
 235+ 7B67 D5           	push	de
 236+ 7B68 32 81 5C     		ld		(CODE), a
 237+ 7B6B C5           		push	bc
 238+ 7B6C E5           			push	hl
 239+ 7B6D CD 69 79     				call	PrintChar
 240+ 7B70 E1           			pop		hl
 241+ 7B71 C1           		pop		bc
 242+ 7B72
 243+ 7B72 ED 5B B0 5C  		ld		de, (COORDS)
 244+ 7B76 1C           		inc		e
 245+ 7B77 ED 53 B0 5C  		ld		(COORDS), de
 246+ 7B7B D1           	pop		de
 247+ 7B7C 10 E7        	djnz	PrintStrTxt
 248+ 7B7E C9           	ret
 249+ 7B7F
 250+ 7B7F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 251+ 7B7F              ;Extract a line of text to fit exactly on a 64 screen line
 252+ 7B7F              ;IN:	HL = current file pointer
 253+ 7B7F              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 254+ 7B7F              GetLine:
 255+ 7B7F 11 08 7D     	ld		de, LineBuf
 256+ 7B82 06 40        	ld		b, COL_CNT
 257+ 7B84              GetLineLoop:
 258+ 7B84 7E           	ld		a, (hl)
 259+ 7B85 23           	inc		hl
 260+ 7B86
 261+ 7B86 FE 0D        	cp		CHAR_CR
 262+ 7B88 28 2F        	jr		z, GetLineSkip0A
 263+ 7B8A
 264+ 7B8A FE 0A        	cp		CHAR_LF
 265+ 7B8C 28 2B        	jr		z, GetLineSkip0A
 266+ 7B8E
 267+ 7B8E FE 09        	cp		CHAR_TAB
 268+ 7B90 28 06        	jr		z, GetLineTab
 269+ 7B92
 270+ 7B92 FE 1A        	cp		CHAR_EOF
 271+ 7B94 28 44        	jr		z, GetLineFillLoop
 272+ 7B96
 273+ 7B96 18 07        	jr		GetLineNext
 274+ 7B98
 275+ 7B98              GetLineTab:
 276+ 7B98              	;1 space tab
 277+ 7B98 3E 20        	ld		a, ' '
 278+ 7B9A 12           	ld		(de), a
 279+ 7B9B 13           	inc		de
 280+ 7B9C 05           	dec		b
 281+ 7B9D 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 282+ 7B9F
 283+ 7B9F              GetLineNext:
 284+ 7B9F FE 20        	cp		' '
 285+ 7BA1 38 06        	jr		c, NotValid
 286+ 7BA3
 287+ 7BA3 FE 80        	cp		128
 288+ 7BA5 30 02        	jr		nc, NotValid
 289+ 7BA7 18 03        	jr		Valid
 290+ 7BA9
 291+ 7BA9              NotValid:
 292+ 7BA9 CD 30 7C     	call	ReplaceChars
 293+ 7BAC
 294+ 7BAC              Valid:
 295+ 7BAC 12           	ld		(de), a
 296+ 7BAD 13           	inc		de
 297+ 7BAE 10 D4        	djnz	GetLineLoop
 298+ 7BB0
 299+ 7BB0              ;if line is exactly 64 char long, must skip the new line char(s)
 300+ 7BB0              GetLineSkip0D:
 301+ 7BB0 0E 00        	ld		c, 0
 302+ 7BB2 3E 0D        	ld		a, CHAR_CR						;skip 0D
 303+ 7BB4 BE           	cp		(hl)
 304+ 7BB5 20 02        	jr		nz, GetLineSkip0A
 305+ 7BB7 23           	inc		hl
 306+ 7BB8 0C           	inc		c
 307+ 7BB9
 308+ 7BB9              GetLineSkip0A:						;skip 0A
 309+ 7BB9 3E 0A        	ld		a, CHAR_LF
 310+ 7BBB BE           	cp		(hl)
 311+ 7BBC 20 02        	jr		nz, GetLineFill
 312+ 7BBE 23           	inc		hl
 313+ 7BBF 0C           	inc		c
 314+ 7BC0
 315+ 7BC0              GetLineFill:
 316+ 7BC0 78           	ld		a, b
 317+ 7BC1 B7           	or		a
 318+ 7BC2 20 16        	jr		nz, GetLineFillLoop
 319+ 7BC4
 320+ 7BC4 79           	ld		a, c
 321+ 7BC5 B7           	or		a
 322+ 7BC6 C0           	ret		nz
 323+ 7BC7
 324+ 7BC7              	;wrap or not
 325+ 7BC7 3A 4A 7D     	ld		a, (WrapFlag)
 326+ 7BCA B7           	or		a
 327+ 7BCB C0           	ret		nz
 328+ 7BCC
 329+ 7BCC ~            	/*
 330+ 7BCC ~            	ld		de, (FileEnd)
 331+ 7BCC ~            	push	hl
 332+ 7BCC ~            		ex		de, hl
 333+ 7BCC ~            		or		a
 334+ 7BCC ~            		sbc		hl, de
 335+ 7BCC ~            		ld		b, h
 336+ 7BCC ~            		ld		c, l
 337+ 7BCC ~            	pop		hl
 338+ 7BCC ~            	*/
 339+ 7BCC
 340+ 7BCC 3E 0D        	ld		a, CHAR_CR
 341+ 7BCE 01 40 00     	ld		bc, COL_CNT
 342+ 7BD1 ED B1        	cpir
 343+ 7BD3 C0           	ret		nz
 344+ 7BD4 3E 0A        	ld		a, CHAR_LF
 345+ 7BD6 BE           	cp		(hl)
 346+ 7BD7 C0           	ret		nz
 347+ 7BD8 23           	inc		hl
 348+ 7BD9
 349+ 7BD9 C9           	ret
 350+ 7BDA
 351+ 7BDA              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 352+ 7BDA 3E 20        	ld		a, ' '
 353+ 7BDC 12           	ld		(de), a
 354+ 7BDD 13           	inc		de
 355+ 7BDE 10 FA        	djnz	GetLineFillLoop
 356+ 7BE0 C9           	ret
 357+ 7BE1
 358+ 7BE1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 359+ 7BE1              PrintMsg:
 360+ 7BE1 ED 5B B0 5C  	ld		de, (COORDS)
 361+ 7BE5 D5           	push	de
 362+ 7BE6 11 00 17     	ld		de, LINE_CNT<<8
 363+ 7BE9 ED 53 B0 5C  	ld		(COORDS), de
 364+ 7BED
 365+ 7BED              	;Get current file pointer
 366+ 7BED DD 6E 00     	ld		l, (ix)
 367+ 7BF0 DD 66 01     	ld		h, (ix + 1)
 368+ 7BF3 ED 4B 4B 7D  	ld		bc, (FileBegin)
 369+ 7BF7 B7           	or		a
 370+ 7BF8 ED 42        	sbc		hl, bc
 371+ 7BFA
 372+ 7BFA              	;Divide by one percent length
 373+ 7BFA 7C           	ld		a, h
 374+ 7BFB 4D           	ld		c, l
 375+ 7BFC ED 5B 51 7D  	ld		de, (PROGR_PERC)
 376+ 7C00 CD AB 6F     	call	Div2
 377+ 7C03
 378+ 7C03              	;Display %
 379+ 7C03 11 E3 7C     	ld		de, MsgLinePr
 380+ 7C06 67           	ld		h, a
 381+ 7C07 69           	ld		l, c
 382+ 7C08 CD 62 6F     	call	Byte2Txt
 383+ 7C0B
 384+ 7C0B
 385+ 7C0B 2A 48 7D     	ld		hl, (CurLine)
 386+ 7C0E 11 EF 7C     	ld		de, MsgLineNo
 387+ 7C11 CD 57 6F     	call	Word2Txt
 388+ 7C14
 389+ 7C14 11 DA 7C     	ld		de, MsgLine
 390+ 7C17 06 2E        	ld		b, MsgLineLen
 391+ 7C19 CD 65 7B     	call	PrintStrTxt
 392+ 7C1C D1           	pop		de
 393+ 7C1D ED 53 B0 5C  	ld		(COORDS), DE
 394+ 7C21
 395+ 7C21 21 E0 5A     	ld		hl, SCR_ADDR + SCR_PIX_LEN + LINE_CNT*32
 396+ 7C24 54           	ld		d, h
 397+ 7C25 5D           	ld		e, l
 398+ 7C26 13           	inc		de
 399+ 7C27 3E 60        	ld		a, SCR_LBL_CLR
 400+ 7C29 77           	ld		(hl), a
 401+ 7C2A 01 1F 00     	ld		bc, SCR_BYTES_PER_LINE-1
 402+ 7C2D ED B0        	ldir
 403+ 7C2F C9           	ret
 404+ 7C30
 405+ 7C30
 406+ 7C30              ReplaceChars:
 407+ 7C30 E5           	push	hl
 408+ 7C31 C5           	push	bc
 409+ 7C32 21 C0 7C     		ld		hl, CharReplaceTbl
 410+ 7C35 06 0D        		ld		b, CharReplTblLen
 411+ 7C37              ReplaceSGCLoop:
 412+ 7C37 BE           		cp		(hl)
 413+ 7C38 28 09        		jr		z, ReplaceMatch
 414+ 7C3A 23           		inc		hl
 415+ 7C3B 23           		inc		hl
 416+ 7C3C 10 F9        		djnz	ReplaceSGCLoop
 417+ 7C3E
 418+ 7C3E 3E 3F        		ld		a, '?'
 419+ 7C40 C1           		pop		bc
 420+ 7C41 E1           		pop		hl
 421+ 7C42 C9           	ret
 422+ 7C43
 423+ 7C43              ReplaceMatch:
 424+ 7C43 23           		inc		hl
 425+ 7C44 7E           		ld		a, (hl)
 426+ 7C45 C1           	pop		bc
 427+ 7C46 E1           	pop		hl
 428+ 7C47 C9           	ret
 429+ 7C48              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 430+ 7C48
 431+ 7C48              	include	"scroll.asm"
# file opened: scroll.asm
   1++7C48              ;Scrolling routines for UP/DOWN
   2++7C48              ;They use 2 tables of pointers of screen cell rows.
   3++7C48              ;One table has addresses in increasing order, for scroll down,
   4++7C48              ;the other in decreasing order, for scroll up, so the same
   5++7C48              ;scroll routine is used in both cases.
   6++7C48              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++7C48
   8++7C48              ; Char Down
   9++7C48              ; Adjusts screen address HL to move eight pixels down on the display.
  10++7C48              ; enter: HL = valid screen address
  11++7C48              ; exit : HL = moves one character down
  12++7C48              ; used : AF, HL
  13++7C48              GetCellDown:
  14++7C48 7D           	ld a,l
  15++7C49 C6 20        	add a,$20
  16++7C4B 6F           	ld l,a
  17++7C4C D0           	ret nc
  18++7C4D 7C           	ld a,h
  19++7C4E C6 08        	add a,$08
  20++7C50 67           	ld h,a
  21++7C51 C9           	ret
  22++7C52
  23++7C52              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++7C52              ;Fills the two tables with pointers.
  25++7C52              ScrollInit:
  26++7C52 21 00 40     	ld		hl, SCR_ADDR
  27++7C55 06 17        	ld		b, LINE_CNT
  28++7C57              FillScrLinesLoop:
  29++7C57              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++7C57 22 00 5B     	ld		(SCRLinesDown), hl
  31++7C5A              	;inc. pointer in destination table (of pointers to lines)
  32++7C5A ED 5B 58 7C  	ld		de, (FillScrLinesPtr)
  33++7C5E 13           	inc		de
  34++7C5F 13           	inc		de
  35++7C60 ED 53 58 7C  	ld		(FillScrLinesPtr), de
  36++7C64 CD 48 7C     	call	GetCellDown
  37++7C67 10 EE        	djnz	FillScrLinesLoop
  38++7C69
  39++7C69              	;now fill the table in reverse
  40++7C69 ED 73 7D 7C  	ld		(FillScrLinesSPStore), sp
  41++7C6D 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++7C70 06 17        	ld		b, LINE_CNT
  43++7C72 21 00 5B     	ld		hl, SCRLinesDown
  44++7C75              FillScrLinesRev:
  45++7C75 5E           	ld		e, (hl)
  46++7C76 23           	inc		hl
  47++7C77 56           	ld		d, (hl)
  48++7C78 23           	inc		hl
  49++7C79 D5           	push	de
  50++7C7A 10 F9        	djnz	FillScrLinesRev
  51++7C7C              FillScrLinesSPStore	EQU	$ + 1
  52++7C7C 31 00 00     	ld		sp, 0
  53++7C7F C9           	ret
  54++7C80
  55++7C80              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++7C80              ScrollUp:
  57++7C80 21 2E 5B     	ld		hl, SCRLinesUp
  58++7C83 18 03        	jr		Scroll
  59++7C85
  60++7C85              ScrollDown:
  61++7C85 21 00 5B     	ld		hl, SCRLinesDown
  62++7C88
  63++7C88              Scroll:
  64++7C88 22 96 7C     	ld		(ScrollDownPtrDest), hl
  65++7C8B 23           	inc		hl
  66++7C8C 23           	inc		hl
  67++7C8D 22 99 7C     	ld		(ScrollDownPtrSrc), hl
  68++7C90 0E 16        	ld		c, LINE_CNT - 1
  69++7C92
  70++7C92              ScrollDownLoop2:
  71++7C92 06 04        	ld		b, 4
  72++7C94              ScrollDownPtrDest	EQU	$ + 2
  73++7C94 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++7C98              ScrollDownPtrSrc	EQU	$ + 1
  75++7C98 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++7C9B
  77++7C9B              ScrollDownLoop:					;copy a single char line
  78++7C9B C5           	push	bc
  79++7C9C 01 20 00     	ld		bc, 32
  80++7C9F ED B0        	ldir
  81++7CA1 2B           	dec		hl
  82++7CA2 1B           	dec		de
  83++7CA3 24           	inc		h
  84++7CA4 14           	inc		d
  85++7CA5 01 20 00     	ld		bc, 32
  86++7CA8 ED B8        	lddr
  87++7CAA 23           	inc		hl
  88++7CAB 13           	inc		de
  89++7CAC 24           	inc		h
  90++7CAD 14           	inc		d
  91++7CAE C1           	pop		bc
  92++7CAF 10 EA        	djnz	ScrollDownLoop
  93++7CB1
  94++7CB1 0D           	dec		c
  95++7CB2 C8           	ret		z
  96++7CB3
  97++7CB3 2A 99 7C     	ld		hl, (ScrollDownPtrSrc)
  98++7CB6 22 96 7C     	ld		(ScrollDownPtrDest), hl
  99++7CB9 23           	inc		hl
 100++7CBA 23           	inc		hl
 101++7CBB 22 99 7C     	ld		(ScrollDownPtrSrc), hl
 102++7CBE 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 432+ 7CC0
 433+ 7CC0              CharReplaceTbl:
 434+ 7CC0 B3 80        	defb	179, 128
 435+ 7CC2 B4 81        	defb	180, 129
 436+ 7CC4 BF 82        	defb	191, 130
 437+ 7CC6 C0 83        	defb	192, 131
 438+ 7CC8 C1 84        	defb	193, 132
 439+ 7CCA C2 85        	defb	194, 133
 440+ 7CCC C3 86        	defb	195, 134
 441+ 7CCE C4 87        	defb	196, 135
 442+ 7CD0 C5 88        	defb	197, 136
 443+ 7CD2 D9 89        	defb	217, 137
 444+ 7CD4 DA 8A        	defb	218, 138
 445+ 7CD6 DB 8B        	defb	219, 139
 446+ 7CD8 DC 8C        	defb	220, 140
 447+ 7CDA              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 448+ 7CDA
 449+ 7CDA 50 72 6F 67  MsgLine		defb	'Progress:'
 449+ 7CDE 72 65 73 73
 449+ 7CE2 3A
 450+ 7CE3 20 20 20 25  MsgLinePr	defb	'   %; '
 450+ 7CE7 3B 20
 451+ 7CE9 4C 69 6E 65  			defb	'Line: '
 451+ 7CED 3A 20
 452+ 7CEF 20 20 20 20  MsgLineNo	defb	'     ; '
 452+ 7CF3 20 3B 20
 453+ 7CF6 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 453+ 7CFA 61 70 20
 454+ 7CFD 20 4F 6E     MsgLineWrF	defb	' On'
 455+ 7D00 3B 20 30 2D  			defb	'; 0-Exit'
 455+ 7D04 45 78 69 74
 456+ 7D08              MsgLineLen	EQU		$ - MsgLine
 457+ 7D08
 458+ 7D08 20 20 20 20  LineBuf		defb	'                                                                '
 458+ 7D0C 20 20 20 20
 458+ 7D10 20 20 20 20
 458+ 7D14 20 20 20 20
 458+ 7D18 20 20 20 20
 458+ 7D1C 20 20 20 20
 458+ 7D20 20 20 20 20
 458+ 7D24 20 20 20 20
 458+ 7D28 20 20 20 20
 458+ 7D2C 20 20 20 20
 458+ 7D30 20 20 20 20
 458+ 7D34 20 20 20 20
 458+ 7D38 20 20 20 20
 458+ 7D3C 20 20 20 20
 458+ 7D40 20 20 20 20
 458+ 7D44 20 20 20 20
 459+ 7D48 00 00        CurLine		defw	0
 460+ 7D4A 01           WrapFlag	defb	1
 461+ 7D4B 00 00        FileBegin	defw	0
 462+ 7D4D 00 00        FileLen		defw	0
 463+ 7D4F 00 00        FileEnd		defw	0
 464+ 7D51 00 00        PROGR_PERC	defw	0
 465+ 7D53
 466+ 7D53              SCRLinesDown	EQU PRN_BUF
 467+ 7D53              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 468+ 7D53              End:
 469+ 7D53
# file closed: txtview.asm
1252  7D53              	include "serial.asm"
# file opened: serial.asm
   1+ 7D53              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7D53              ;They work with 19200 theoretical speed.
   3+ 7D53              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7D53
   5+ 7D53              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7D53              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7D53
   8+ 7D53
   9+ 7D53              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7D53              ; A=1 IF FRAMING ERROR
  11+ 7D53              ; USES BC,D _DOES NOT USE E!_
  12+ 7D53              SERRXI:
  12+ 7D53
  13+ 7D53 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7D56 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 7D58 D3 EF        	OUT	(0EFH),A
  16+ 7D5A
  17+ 7D5A              	; WAIT FOR START
  18+ 7D5A              SERWSL:
  19+ 7D5A 0B           	DEC	BC
  20+ 7D5B AF           	XOR	A
  21+ 7D5C B8           	CP	B
  22+ 7D5D 20 03        	JR	NZ,SERWS
  23+ 7D5F B9           	CP	C
  24+ 7D60 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7D62 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7D64 CB 7F        	BIT	7,A
  27+ 7D66 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 7D68
  29+ 7D68              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 7D68              ; OF BIT 0
  31+ 7D68 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 7D6A 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 7D6C
  34+ 7D6C              ; GET AND SHIFT BITS
  35+ 7D6C              SERRL:
  36+ 7D6C 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7D6E 00           	NOP			; 4 (TIMING)
  38+ 7D6F 00           	NOP			; 4 (TIMING)
  39+ 7D70 00           	NOP			; 4 (TIMING)
  40+ 7D71 DB F7        	IN	A,(0F7H)	; 11
  41+ 7D73 17           	RLA			; 4
  42+ 7D74 CB 1A        	RR	D		; 8
  43+ 7D76 06 0A        	LD	B,CBAUD		; 7
  44+ 7D78 0D           	DEC	C		; 4
  45+ 7D79 20 F1        	JR	NZ,SERRL	; 12
  46+ 7D7B
  47+ 7D7B              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 7D7B              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 7D7B              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 7D7B              ; IDLE UNTIL NEXT START BIT
  51+ 7D7B 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7D7D D3 EF        	OUT	(0EFH),A
  53+ 7D7F
  54+ 7D7F 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7D81              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7D81              SERWIL:
  57+ 7D81 05           	DEC	B
  58+ 7D82 28 0E        	JR	Z,SERRTF
  59+ 7D84 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7D86 CB 7F        	BIT	7,A
  61+ 7D88 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 7D8A
  63+ 7D8A              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 7D8A 7A           	LD	A,D
  65+ 7D8B 2F           	CPL			; INVERT BITS
  66+ 7D8C 57           	LD	D,A
  67+ 7D8D AF           	XOR	A		; 0 = SUCCESS
  68+ 7D8E C9           	RET
  69+ 7D8F
  70+ 7D8F              ; TIMEOUT
  71+ 7D8F              SERRTO:
  72+ 7D8F 3E FF        	LD	A,0FFH
  73+ 7D91 C9           	RET
  74+ 7D92
  75+ 7D92              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7D92              SERRTF:
  77+ 7D92 3E 01        	LD	A,01H
  78+ 7D94 C9           	RET
  79+ 7D95
  80+ 7D95
  81+ 7D95
  82+ 7D95              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7D95              SERRB:
  83+ 7D95
  84+ 7D95              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7D95              ; BITMAPPED OPTIONS IN E:
  86+ 7D95              ; XXXXXXIT
  87+ 7D95              ; I SET = leave Interrupts disabled at exit
  88+ 7D95              ; T SET = return after Timeout
  89+ 7D95              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7D95              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7D95              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7D95 F3           	DI
  93+ 7D96 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 7D97              				; OF RECEIVED BYTES
  95+ 7D97
  96+ 7D97              SERRBL:
  97+ 7D97 C5           	PUSH	BC
  98+ 7D98 CD 53 7D     	CALL	SERRXI
  99+ 7D9B C1           	POP	BC
 100+ 7D9C B7           	OR	A
 101+ 7D9D 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7D9F 72           	LD	(HL),D
 103+ 7DA0 23           	INC	HL
 104+ 7DA1 0B           	DEC	BC
 105+ 7DA2 AF           	XOR	A
 106+ 7DA3 B8           	CP	B
 107+ 7DA4 20 F1        	JR	NZ,SERRBL
 108+ 7DA6 B9           	CP	C
 109+ 7DA7 20 EE        	JR	NZ,SERRBL
 110+ 7DA9              ; FULL RECEIVE
 111+ 7DA9 C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 7DAA
 113+ 7DAA              SERRBX:				; EXIT
 114+ 7DAA CB 4B        	BIT	1,E
 115+ 7DAC C0           	RET	NZ
 116+ 7DAD FB           	EI
 117+ 7DAE C9           	RET
 118+ 7DAF
 119+ 7DAF              SERRBT:
 120+ 7DAF FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7DB1 28 04        	JR	Z,SERRBC
 122+ 7DB3 CB 43        	BIT	0,E
 123+ 7DB5 28 E0        	JR	Z,SERRBL
 124+ 7DB7
 125+ 7DB7              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7DB7 EB           	EX	DE,HL		; PRESERVE HL
 127+ 7DB8 E1           	POP	HL		; GET INITIAL COUNT
 128+ 7DB9 37           	SCF
 129+ 7DBA 3F           	CCF
 130+ 7DBB ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7DBD 44           	LD	B,H
 132+ 7DBE 4D           	LD	C,L		; BC = COUNT
 133+ 7DBF EB           	EX	DE,HL		; RESTORE HL
 134+ 7DC0
 135+ 7DC0 18 E8        	JR	SERRBX
 136+ 7DC2
 137+ 7DC2              SERRX:
 137+ 7DC2
 138+ 7DC2              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7DC2              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7DC2              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7DC2 F3           	DI
 142+ 7DC3 CD 53 7D     	CALL	SERRXI
 143+ 7DC6 FB           	EI
 144+ 7DC7 C9           	RET
 145+ 7DC8
 146+ 7DC8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7DC8              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7DC8              SERTB:
 148+ 7DC8
 149+ 7DC8 7E           	LD	A,(HL)
 150+ 7DC9 C5           	PUSH	BC
 151+ 7DCA CD D5 7D     		CALL	SERTX
 152+ 7DCD C1           	POP	BC
 153+ 7DCE 23           	INC	HL
 154+ 7DCF 0B           	DEC BC
 155+ 7DD0 78           	LD	A, B
 156+ 7DD1 B1           	OR	C
 157+ 7DD2 20 F4        	JR	NZ, SERTB
 158+ 7DD4 C9           	RET
 159+ 7DD5
 160+ 7DD5              ; SEND CHAR ROUTINE
 161+ 7DD5              SERTX:
 161+ 7DD5
 162+ 7DD5 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7DD6 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7DD7 F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7DD8 3E 01        	LD	A,01H
 166+ 7DDA D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7DDC 1E 20        	LD	E,20H	; PORT MASK
 168+ 7DDE 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 7DE0 3E 01        	LD	A,1
 170+ 7DE2 C3 E9 7D     	JP	SBIT
 171+ 7DE5
 172+ 7DE5 AF           SHLOOP:	XOR	A		; 4
 173+ 7DE6 CB 3A        	SRL	D		; 8
 174+ 7DE8 17           	RLA			; 4
 175+ 7DE9              SBIT:
 176+ 7DE9 B3           	OR	E		; 4
 177+ 7DEA D3 EF        	OUT	(0EFH),A	; 11
 178+ 7DEC 06 0A        	LD	B,CBAUD		; 7
 179+ 7DEE              SBITDL:
 180+ 7DEE 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 7DF0 00           	NOP			; 4 (TIMING)
 182+ 7DF1 0D           	DEC	C		; 4
 183+ 7DF2 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 7DF4              ; STOP BIT
 185+ 7DF4 3E 20        	LD	A,20H
 186+ 7DF6 D3 EF        	OUT	(0EFH),A
 187+ 7DF8 06 0A        	LD	B,CBAUD
 188+ 7DFA 10 FE        STOPL:	DJNZ	STOPL
 189+ 7DFC FB           	EI
 190+ 7DFD C9           	RET
# file closed: serial.asm
1253  7DFE
1254  7DFE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1255  7DFE 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-08-08"
1255  7E02 64 20 32 30
1255  7E06 32 33 2D 30
1255  7E0A 38 2D 30 38
1256  7E0E 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1256  7E12 67 65 20 43
1256  7E16 68 69 72 74
1256  7E1A 6F 61 63 E1
1257  7E1E 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1257  7E22 72 61 6D 20
1257  7E26 49 6E 66 6F
1257  7E2A 20 20 20 A0
1258  7E2E 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1258  7E32 20 49 6E 66
1258  7E36 6F 20 20 20
1258  7E3A 20 20 20 A0
1259  7E3E 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1259  7E42 20 49 6E 66
1259  7E46 6F 20 20 20
1259  7E4A 20 20 20 A0
1260  7E4E 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1260  7E52 61 67 65 73
1260  7E56 20 20 20 20
1260  7E5A 20 20 20 A0
1261  7E5E 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1261  7E62 20 32 2D 42
1261  7E66 3A 20 33 2D
1261  7E6A 56 69 65 77
1261  7E6E 20 34 2D 50
1261  7E72 72 6F 70 20
1261  7E76 35 2D 43 6F
1261  7E7A 70 79 20 36
1261  7E7E 2D 52 65 6E
1261  7E82 20 37 2D 41
1261  7E86 74 74 72 20
1261  7E8A 38 2D 44 65
1261  7E8E 6C 20 39 2D
1261  7E92 44 69 73 6B
1261  7E96 20 30 2D 45
1261  7E9A 78 69 F4
1262  7E9D 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1262  7EA1 46 72 65 65
1262  7EA5 3A 20 20
1263  7EA8 41 2F        MsgDriveLet		DEFM	'A', '/'
1264  7EAA 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1265  7EAD 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1265  7EB1 73 2F 4B 42
1265  7EB5 3A
1266  7EB6 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1266  7EBA 30 30 30
1267  7EBD 45 72 72 6F  MsgErr			DEFM	'Error code '
1267  7EC1 72 20 63 6F
1267  7EC5 64 65 20
1268  7EC8 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1269  7ECC 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1269  7ED0 69 6E 67 20
1269  7ED4 50 72 6F 67
1269  7ED8 72 61 ED
1270  7EDB 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1270  7EDF 69 6E 67 20
1270  7EE3 53 43 52 45
1270  7EE7 45 4E A4
1271  7EEA 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1271  7EEE 69 6E 67 20
1271  7EF2 43 4F 44 45
1271  7EF6 20 28 21 A9
1272  7EFA 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1272  7EFE 20 4C 65 6E
1272  7F02 3A
1273  7F03 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1273  7F07 30 20 CB
1274  7F0A 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1274  7F0E 69 62 20 20
1274  7F12 3A
1275  7F13 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1275  7F17 48 49 C4
1276  7F1A 54 79 70 65  MsgFileType		DEFM	'Type    :'
1276  7F1E 20 20 20 20
1276  7F22 3A
1277  7F23 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1277  7F27 20 20 20 20
1277  7F2B 20 A0
1278  7F2D 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1278  7F31 72 61 ED
1279  7F34 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1279  7F38 73 20 A0
1280  7F3B 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1280  7F3F 45 4E A4
1281  7F42 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1281  7F46 41 72 F2
1282  7F49 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1282  7F4D 41 72 F2
1283  7F50 4E 6F 6E 65  MsgFileTypeText	DEFM	'None  ', ' ' + $80
1283  7F54 20 20 A0
1284  7F57 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1284  7F5B 20 20 A0
1285  7F5E 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1285  7F62 74 68 20 20
1285  7F66 3A
1286  7F67 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1286  7F6B 35 20 C2
1287  7F6E 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1287  7F72 74 20 20 20
1287  7F76 3A
1288  7F77 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1288  7F7B 35 20 A0
1289  7F7E 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1289  7F82 69 6E 67 20
1289  7F86 68 65 61 64
1289  7F8A 65 F2
1290  7F8C 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1290  7F90 20 20 20 20
1290  7F94 20 20 20 20
1290  7F98 20 20 20 A0
1291  7F9C 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1291  7FA0 66 69 6C 65
1291  7FA4 3F 20 79 2F
1291  7FA8 EE
1292  7FA9 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1292  7FAD 52 2F 4F 3F
1292  7FB1 20 79 2F EE
1293  7FB5 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1293  7FB9 48 49 44 3F
1293  7FBD 20 79 2F EE
1294  7FC1 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1294  7FC5 3F 6E 6F 6E
1294  7FC9 65 3D 61 62
1294  7FCD 6F 72 74 BA
1295  7FD1 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1295  7FD5 20 6D 65 6E
1295  7FD9 75 BA
1296  7FDB 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1296  7FDF 20 63 6F 70
1296  7FE3 79 20 6D 65
1296  7FE7 6E 75 BA
1297  7FEA 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1297  7FEE 78 69 74 20
1297  7FF2 6D 65 6E F5
1298  7FF6
1299  7FF6 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1299  7FFA 6F 70 79 20
1300  7FFE 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1301  8002 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1302  8004
1303  8004 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1303  8008 6F 70 79 20
1304  800C 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1305  8010 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1306  8012
1307  8012 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1307  8016 6F 70 79 20
1308  801A 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1308  801E 43 4F CD
1309  8021
1310  8021 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1310  8025 6F 70 79 20
1310  8029 43 4F 4D 2D
1310  802D 3E
1311  802E 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1312  8030
1313  8030 35 2E 20 46  MsgMenuFmt		DEFM	'5. Format '
1313  8034 6F 72 6D 61
1313  8038 74 20
1314  803A 41 BA        MsgMenuFmtDrv	DEFM	'A', ':' | $80
1315  803C
1316  803C 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1316  8040 61 74 74 69
1316  8044 6E 67 20
1317  8047 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1318  8049
1319  8049 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1319  804D 62 6C 6F 63
1319  8051 6B 73 20 6C
1319  8055 65 66 F4
1320  8058 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1320  805C 77 72 69 74
1320  8060 65 3F 20 79
1320  8064 2F EE
1321  8066 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1321  806A 20 6E 61 6D
1321  806E 65 20 65 78
1321  8072 69 73 74 F3
1322  8076 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1322  807A 53 4F 55 52
1322  807E 43 45 20 64
1322  8082 69 73 EB
1323  8085 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1323  8089 44 45 53 54
1323  808D 2E 20 64 69
1323  8091 73 6B A0
1324  8094 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1324  8098 73 20 61 6E
1324  809C 79 20 6B 65
1324  80A0 F9
1325  80A1 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1325  80A5 73 65 63 74
1325  80A9 6F 72 73 20
1325  80AD 63 6F 70 F9
1326  80B1
1327  80B1              	IFNDEF	_REAL_HW_
1328  80B1 ~            FontTable:
1329  80B1 ~            	incbin "cpmfnt.bin"
1330  80B1              	ENDIF
1331  80B1              EndCode:
1332  80B1
1333  80B1              ;Unalocated variables
1334  80B1              UnallocStart	EQU		EndCode
1335  80B1              FileCnt			EQU		UnallocStart			;File counter, 1B
1336  80B1              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1337  80B1              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1338  80B1              CursorAddr		EQU		SelFile + 1				;2 B
1339  80B1              AUCnt			EQU		CursorAddr + 2			;2 B
1340  80B1              SelFileCache	EQU		AUCnt + 2				;2 B
1341  80B1              CopySelOption	EQU		SelFileCache+2			;1 B
1342  80B1
1343  80B1              CopyFileFCB		EQU	CopySelOption + 1
1344  80B1              CopyFileRes		EQU CopyFileFCB + 2
1345  80B1              CopyFileDMAAddr	EQU	CopyFileRes + 1
1346  80B1              FilePosRead		EQU	CopyFileDMAAddr + 2
1347  80B1              FilePosWrite	EQU	FilePosRead + 2
1348  80B1              CopyFileSectCnt EQU FilePosWrite + 2
1349  80B1              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1350  80B1              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1351  80B1              CopyFileDstDrv	EQU CopyFileSrcName + 11
1352  80B1              CopyFileDstName	EQU CopyFileDstDrv + 1
1353  80B1
1354  80B1              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1355  80B1              ;FS block list constants
1356  80B1              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1357  80B1              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1358  80B1              UsedBlockListSz		EQU 320 * 2 + 2							;640
1359  80B1
1360  80B1              	IFDEF	_REAL_HW_
1361  80B1              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1362  80B1              DataBuf			EQU		FontTable + 872
1363  80B1              	ELSE
1364  80B1 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1365  80B1              	ENDIF
1366  80B1
1367  80B1              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1368  80B1
1369  80B1
1370  80B1              ;File viewer constants
1371  80B1              FileData		EQU		DataBuf
1372  80B1              ;File buffer size, without index
1373  80B1              FileIdxSize		EQU		2 * 1024
1374  80B1              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1375  80B1              ;Set a few KB aside for file indexing
1376  80B1              FileIdx			EQU		FileData + FileDataSize
1377  80B1              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1378  80B1
1379  80B1
1380  80B1              ;Copy buffer size, follows
1381  80B1              CopyDiskBuf			EQU DataBuf
1382  80B1
1383  80B1              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1384  80B1              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1385  80B1              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1386  80B1
1387  80B1              	DISPLAY "DataBuf: ", /D,DataBuf
1388  80B1              	DISPLAY "BinSize: ", /D, EndCode - Start
1389  80B1              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1390  80B1              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6FA8   NoSub
0x6FA1   DivLoop
0x7005   MAX_RAM_FREE
0x0070   MAX_SECT_RAM
0x0800   FileIdxSize
0x0282   UsedBlockListSz
0x80B1   UnallocStart
0x80B1   EndCode
0x7EAA X MsgFreeSpaceNo
0x7DFA   STOPL
0x7DE5   SHLOOP
0x7DE9   SBIT
0x7DEE   SBITDL
0x7DD5   SERTX
0x7DC2 X SERRX
0x7DB7   SERRBC
0x7DAA   SERRBX
0x7DAF   SERRBT
0x7D97   SERRBL
0x7D84 X SERWI
0x7D92   SERRTF
0x7D81   SERWIL
0x7D6C   SERRL
0x7D8F   SERRTO
0x7D62   SERWS
0x7D5A   SERWSL
0x7D53   SERRXI
0x000A   CBAUD
0x7D53 X End
0x7CF6 X MsgLineWrap
0x7C9B   ScrollDownLoop
0x7C92   ScrollDownLoop2
0x7C99   ScrollDownPtrSrc
0x7C96   ScrollDownPtrDest
0x7C88   Scroll
0x7C75   FillScrLinesRev
0x5B2E   SCRLinesUp
0x7C7D   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x7C58   FillScrLinesPtr
0x7C57   FillScrLinesLoop
0x7C48   GetCellDown
0x7C43   ReplaceMatch
0x7C37   ReplaceSGCLoop
0x000D   CharReplTblLen
0x7CC0   CharReplaceTbl
0x002E   MsgLineLen
0x7CDA   MsgLine
0x7CEF   MsgLineNo
0x7CE3   MsgLinePr
0x7BC0   GetLineFill
0x7C30   ReplaceChars
0x7BAC   Valid
0x7BA9   NotValid
0x7BB0   GetLineSkip0D
0x7B9F   GetLineNext
0x7BDA   GetLineFillLoop
0x7B98   GetLineTab
0x7BB9   GetLineSkip0A
0x7B84   GetLineLoop
0x7B65   PrintStrTxt
0x7D08   LineBuf
0x7C85   ScrollDown
0x7C80   ScrollUp
0x7B36   CheckBegin
0x7CFD   MsgLineWrF
0x7AC8   NoWrap
0x7D4A   WrapFlag
0x7AD7   Up
0x7B02   Down
0x7A82   GetKey
0x7A91   ViewFileEOF
0x7B46   CheckEnd
0x7B51   PrintLine
0x7B7F   GetLine
0x7BE1   PrintMsg
0x7D51   PROGR_PERC
0x7D48   CurLine
0x7C52   ScrollInit
0x7D4D   FileLen
0x7D4F   FileEnd
0x7D4B   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x79EC   ClearNMsgLinesLoop
0x79DA   ReadStrPrint
0x79CA   ReadStrChar
0x79AD   ReadStringLoop
0x79A1   Store
0x79A0   NoTurn
0x7995   PrintCharLine
0x7981 X PrintChar3
0x792C   DrawCursorLoop
0x7913   DrawVLinesLoop
0x78E4   DrawLowerIntersectLoop
0x78F5   DrawIntersect
0x78CF   DrawUpperIntersectLoop
0x78A3   DrawLineLoop
0x78B0   LineDir
0x78A0   StoreDir
0x789E   VertDir
0x7895   DrawLine
0x7891   StrClr
0x7844   GoodChar
0x79FC   CurrScrAddr
0x8B93   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x77C4   ReadWriteFileSectionLoop
0x77E2   ReadWriteFileSectionEnd
0x80BE   CopyFileDMAAddr
0x80BB   CopyFileFCB
0x7789   ReadWriteFileSection
0x0068   MAX_SECT_BUF
0x77F3   CopyFilePtr2
0x77AF   CopyFilePtr
0x77D7   CopyFileOperAddr2
0x77B8   CopyFileOperAddr1
0x773A   CopyFileFromCOMDontInc
0x6800   FileDataSize
0x7727   CopyFileFromCOMLoop
0x76C6   CopyFileToCOMEnd
0x76A8   CopyFileToCOMLoop
0x7662   CopyFileDualDriveLoop
0x7770   WriteFileSection
0x80A1   MsgCopySectors
0x75FB   CopyFileSameDriveLoop
0x80C4   CopyFileSectCnt
0x75B9   CopyFileCreateNewFile
0x8058   MsgFileOverwrite
0x759D   CopyFileCheckOverwrite
0x76CB   CopyFileFromCOM
0x769A   CopyFileToCOM
0x7652   CopyFileDualDrive
0x75D7   CopyFileSameDrive
0x7586   CopyFileNotExit
0x7FDB   MsgMenuFileCopy
0x80C2   FilePosWrite
0x80D2   CopyFileDstName
0x80C6   CopyFileSrcName
0x8076   MsgInsertSrcDsk
0x8094   MsgPressAnyKey
0x8085   MsgInsertDstDsk
0x7489 X FileAttribSet
0xF6FB   FileIdx
0x7437   GetFileSizeMul
0x743D   GetFileSizeEnd
0x7435   GetFileSizeOK
0x7415   BDOSSetRandFilePtr
0x7411   BDOSSetDMA
0x7403   BDOSWriteFileBlockRandom
0x73FF   BDOSReadFileBlockRandom
0x73FB   BDOSWriteFileBlockSeq
0x73F7   BDOSReadFileBlockSeq
0x73F3   BDOSCloseFile
0x73EF   BDOSOpenFile
0x73EB   BDOSCreateFile
0x73E1   DestroyChannel
0x73CB   CreateChannel
0x73CB X BDOSGetCurrentDisk
0x73CB X BDOSGetDiskRO
0x73CB X BDOSMakeDiskRO
0x7407   BDOS
0x73AF   InterleaveTbl
0x73AD X PrmIntrlvTbl
0x73AC X PrmSpinUp
0x73AB X PrmHeadLoad
0x73A9 X PrmDevType
0x73A4 X RWTSResTmp
0x73A3 X RWTSResVolNo
0x73A9   BasPrmTbl
0x739F X RWTSPrmTbl
0x739D X RWTSExtBuf
0x739A X RWTSSector
0x7398 X RWTSVolNo
0x7396 X RWTSBlockType
0x738D   CopyMsg
0x7381   SearchMsgEnd
0x738A   SaveMsg
0x7378   IF1Paged
0x7346   IF1Call
0x7341   IsFileHeaderValidLoop
0x7419   GetFileSize
0x7325   ReadFileHeaderIsTextFile
0x733E   IsFileHeaderValid
0x733A   ReadHeaderEnd
0x72DF   CacheNotFinished
0x73C2   BDOSSelectDisk
0x727C   FileReadLoop
0x7270 X FileLoadHeader
0x7282   FileLoadNoHeader
0x7290   FileFree
0x724C   MisMatch
0x7244   Compare
0x7242   StrCmp
0x71F9   CopyDiskFromCOMLoop
0x7D95   SERRB
0x7195   CopyDiskToCOMLoop
0x7DC8   SERTB
0x74CF   PromptDiskChangeSrc
0x716D   CopyDiskDualDrive2
0x717A   CopyDiskEnd
0x7149 X CopyDiskWriteEnd
0x7132   CopyDiskLoopWriteLoop
0x712B   CopyDiskReadEnd
0x73BF   BDOSInit
0x74B5   PromptDiskChangeDst
0x7121   CopyDiskDualDrive1
0x70F8   CopyDiskLoopReadLoop
0x8EFB   CopyDiskBuf
0x70F1   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x8049   MsgBlocksLeft
0x70CE   CopyDiskLoop
0x8913   UsedBlockListBlk
0x72A8   WriteDiskSectors
0x70BA   WriteFSBlock
0x7295   ReadDiskSectors
0x70AD   ReadFSBlock
0x709F   ReadUsedBlocksSkip
0x7082   ReadUsedBlocksLoop2
0x70A2   ReadUsedBlocksSkip2
0x7072   ReadUsedBlocksLoop
0x8911   UsedBlockListCnt
0x7055   ReadUsedBlocksList
0x704E   CheckAUEnd
0x703A   CheckAU
0x7023   FirstAU
0x701D   Track0
0x7008   AU2TS
0x73A2   RWTSRes
0x6FEC   WriteOneDiskSector
0x7399   RWTSTrack
0x739B   RWTSDMA
0x6FE1   ReadOneDiskSector
0x7396   RWTSParams
0x73A1   RWTSCmd
0x6FD5   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x001A   CHAR_EOF
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6FCF   NoAdd
0x6FC9   MulLoop
0x6FB0   Div2Loop
0x6FAB   Div2
0x6F9E   Div
0x6F95   DivNrLoop
0x6F93   DigitLoop
0x6F84   Byte2Txt_
0x6F6D   StrippLeading0
0x6F78   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x6F54   DontInc
0x6F4E   ReadAllHeadersEnd
0x6F39   AKey
0x7804   KbdHit
0x6F1E   NextFile
0x7F5E   MsgFileLen
0x7F1A   MsgFileType
0x7F6E   MsgFileStart
0x6EDD   PrintStartStr
0x7F77   MsgFileStartN
0x7F57   MsgNA
0x6ECF   PrintStart
0x0007   HDR_LINE
0x6EAA   PrintByteStart
0x6EA2   PrintProgStart
0x7F67   MsgFileLenN
0x6E88 X PrepFileLenText
0x7F50   MsgFileTypeText
0x7F34   MsgFileTypeByte
0x7F3B   MsgFileTypeSCR
0x6E6E   NotScr
0x6E79   CheckText
0x7F42   MsgFileTypeChrA
0x6E51   CheckByte
0x0002   CHAR_TYPE
0x7F49   MsgFileTypeNoA
0x6E42   CheckChrArr
0x0001   NUMB_TYPE
0x6E82   PrepFileLen
0x73AA X PrmStepRate
0x6EFB   MoveMsg
0x7F23   MsgFileTypeN
0x7F2D   MsgFileTypePrg
0x6E33   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6EB2   HeadNotRead
0x7F0A   MsgFileAttr
0x6E04   AttrEnd
0x6DF8   NotSYS
0x6DE4   CheckSys
0x6DD2   NotRO
0x7F13   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x6EC4   PrintStartNotRead
0x7EFA   MsgFileSzDsk
0x7F03   MsgFileSzDskN
0x7A99   PrintLoop2
0x7A5E   PrintLoop
0x7A00   InitViewer
0x774E   ReadFileSection
0x6D69   ViewFileLoop
0x80C0   FilePosRead
0x734C   LoadProgram
0x80C5   CopyFileSrcDrv
0x7ECC   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7EDB   MsgLoadingSCR
0x0003   HDR_ADDR
0x7295   IF1FileLoadEnd
0x5B00   PRN_BUF
0x724F   IF1FileLoad
0x7EEA   MsgLoadingCODE
0x6D0B X HandleFileCODE
0x6D31   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6D5F   HandleFileText
0x0003   BYTE_TYPE
0x6D4F   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6CD5   FindExtEnd
0x72D4   FindCache
0x6CE4   GetFileNamesEnd
0x0009   HDR_SZ
0x6CB0   FindExt
0x000C   EXT_IDX
0x7026   CheckExtAlloc
0x6CD7   NextExt
0x0000   EXT_DEL_FLAG
0x6C5F   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6C3C   DisplayFilenamesLoop
0x6C22   LineOK
0x5CB1   LINE
0x5CB0   COL
0x7969   PrintChar
0x5C81   CODE
0x6BFC   DispLoop
0x6BFA   DisplayFilename
0x7931   MoveCursor
0x6FF7   FormatDisk
0x803C   MsgFormat
0x71DC   CopyDiskFromCOM
0x6BB8   CheckDiskMenuFormat
0x7180   CopyDiskToCOM
0x6BAE   CheckDiskMenuFromCOM
0x6BA5   CheckDiskMenuToCOM
0x70C7   CopyDisk
0x6B97   CheckDiskMenuDualDrive
0x6BE9   DiskMenuExit
0x6B85 X CheckKeyDiskMenuLoop
0x8030   MsgMenuFmt
0x8021   MsgMenuFromCOM
0x8012   MsgMenuToCOM
0x8004   MsgMenuDual
0x7FF6   MsgMenuSingle
0x7FEA   MsgMenuBack
0x7FD1   MsgMenuDiskCopy
0x8010   MsgMenuDualDrv2
0x8047   MsgFormatDrv
0x803A   MsgMenuFmtDrv
0x802E   MsgMenuFromCOMDrv
0x801A   MsgMenuToComDrv
0x800C   MsgMenuDualDrv1
0x8002   MsgMenuSingleDrv2
0x7FFE   MsgMenuSingleDrv1
0x6BEC   CheckKeyExit
0x7468   ChangeFileAttrib
0x6AFE   AttrChange
0x7FB5   MsgSetSYS
0x6AE6   CheckSYS
0x7FA9   MsgSetRO
0x6B0D   CheckKeyDiskMenu
0x7443   DeleteFile
0x6AB8   DoFileDelete
0x7F9C   MsgDelete
0x6AC5   CheckKeyAttrib
0x7492   RenameFile
0x8066   MsgFileExists
0x6A7F   RenameFileNotExist
0x744F   DoesFileExist
0x6A8B   RenameCanceled
0x79A7   ReadString
0x000B   NAMELEN
0x8EFB   FileData
0x7F8C   MsgClear
0x7FC1   MsgNewFileName
0x6A93   CheckKeyDel
0x6D60   ViewFile
0x6A23   CheckKeyRename
0x0001   DRIVE_B_CPM
0x6A12   CheckKeyView
0x6B07   SelectDrive
0x6A09   CheckKeyDriveB
0x6F01   ReadAllHeaders
0x6A00   CheckKeyDriveA
0x80D1   CopyFileDstDrv
0x80BA   CopySelOption
0x69D8   CopyFileOK
0x80BD   CopyFileRes
0x74E9   CopyFile
0x69EF   CheckKeyFileInfo
0x79E9   ClearNMsgLines
0x72E5   ReadFileHeader
0x7F7E   MsgReadingExt
0x69A6   CheckKeyCopy
0x6CE5   HandleFile
0x6981   CheckKeyInfo
0x697B   DoKeyEnter
0x000D   KEY_ENTER
0x6972   CheckEnter
0x6965   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x695D   CheckLeft
0x694B   DoKeyRight
0x0009   KEY_RIGHT
0x6943   CheckRight
0x6936   DoKeyUp
0x000B   KEY_UP
0x6BF4   MoveIt
0x692E   CheckUp
0x691D   DoKeyDown
0x000A   KEY_DOWN
0x6D8F   DisplayFileInfo
0x80B8   SelFileCache
0x6FBE   Mul
0x68FB   CalcFileCache
0x7EAD   MsgFilesCnt
0x80B1   FileCnt
0x7EB6   MsgFilesCntNo
0x7E9D   MsgDrive
0x6F57   Word2Txt
0x7EA8   MsgDriveLet
0x013E   MAX_FREE_AU_CNT
0x80B6   AUCnt
0x7365   SetFastKeys
0x7926   DrawCursor
0x0060   SCR_SEL_CLR
0x7E4E   MsgMessages
0x0007   LST_FILE_INFO
0x7E3E   MsgFileInf
0x0004   LST_DISK_INFO
0x7E2E   MsgDskInf
0x7E1E   MsgSysInf
0x7E5E   BtnBar
0x0060   SCR_LBL_CLR
0x7E0E   VerMsg2
0x783D   PrintStr
0x0001   LST_PROG_INFO
0x7DFE   VerMsg1
0x78B4   DrawHLines
0x790E   DrawVLines
0x80B4   CursorAddr
0x79FE   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x781D   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x80B2   NameCol
0x0010   LST_FIRST_COL
0x80B3   SelFile
0x8EFB   DataBuf
0x7370   GetErrMsg
0x5C3A   ERRNR
0x67E3 X HCRunEnd
0x690C   ReadKeyLoop
0x6899   DisplayDiskInfo
0x6C2C   DisplayFilenames
0x681B   InitUI
0x67D7   HCRunMain
0x6C4C   GetFileNames
0x7397   RWTSDrive
0x0000   DRIVE_A_CPM
0x7801   ReadChar
0x7865   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7EBD   MsgErr
0x6F62   Byte2Txt
0x7EC8   MsgErrCode
0x67D4   HCRunCacheFiles
0x72BB   ReadCatalogTrack
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x80DD   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8EFB   TrackBuf
0x6796   HCRunInitDisk
0x67E9   ErrorHandler
0x5C3D   ERRSP
0x6FD2   IF1Init
0x7807   InitFonts
0x6784   Start
