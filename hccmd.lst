# file opened: hccmd.asm
   1  0000
   2  0000
   3  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   4  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   5  0000              	;DEFINE  _REAL_HW_
   6  0000
   7  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
   8  0000              ;So we have to put our code after the program as loaded in RAM.
   9  0000              	ORG 26000
  10  6590
  11  6590              Start:
  12  6590              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  13  6590 CD AE 77     		call InitFonts
  14  6593              	ENDIF
  15  6593 CD 85 6F     	call IF1Init
  16  6596
  17  6596              	;install error handler
  18  6596 2A 3D 5C     	ld		hl, (ERRSP)
  19  6599 E5           	push	hl
  20  659A 21 1E 66     	ld		hl, ErrorHandler
  21  659D E5           	push	hl
  22  659E ED 73 3D 5C  	ld		(ERRSP), sp
  23  65A2
  24  65A2              HCRunInitDisk:
  25  65A2              	;Set track buffer to del marker
  26  65A2 21 DC 8E     	ld		hl, TrackBuf
  27  65A5 54           	ld		d, h
  28  65A6 5D           	ld		e, l
  29  65A7 13           	inc		de
  30  65A8 01 00 10     	ld		bc, SPT*SECT_SZ
  31  65AB 36 E5        	ld		(hl), DEL_MARKER
  32  65AD ED B0        	ldir
  33  65AF
  34  65AF              	;Invalidate file cache
  35  65AF 21 BE 80     	ld		hl, FileCache
  36  65B2 54           	ld		d, h
  37  65B3 5D           	ld		e, l
  38  65B4 13           	inc		de
  39  65B5 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  40  65B8 36 00        	ld		(hl), 0
  41  65BA ED B0        	ldir
  42  65BC
  43  65BC              	;main program
  44  65BC CD 62 73     	call	BDOSGetCurrentDrive
  45  65BF FE FF        	cp		$FF
  46  65C1 20 02        	jr		nz, DetectTrackCount
  47  65C3
  48  65C3 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  49  65C5
  50  65C5              DetectTrackCount:
  51  65C5 F5           	push	af
  52  65C6 CD 56 73     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  53  65C9 F1           	pop		af
  54  65CA 32 3E 73     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  55  65CD CD 59 73     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  56  65D0
  57  65D0              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  58  65D0 1E 28        	ld		e, TRACK_CNT/2
  59  65D2 21 DC 8E     	ld		hl, FileData
  60  65D5 CD 94 6F     	call	ReadOneDiskSector
  61  65D8 3A 49 73     	ld		a, (RWTSRes)
  62  65DB B7           	or		a
  63  65DC 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  64  65DF 28 03        	jr		z, DriveIs80Tracks
  65  65E1 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  66  65E4              DriveIs80Tracks:
  67  65E4 22 97 80     	ld		(AUCntMaxFree), hl
  68  65E7
  69  65E7 CD 6F 72     	call 	ReadCatalogTrack
  70  65EA B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  71  65EB 28 1A        	jr		z, HCRunCacheFiles
  72  65ED
  73  65ED 6F           	ld		l, a
  74  65EE 26 00        	ld		h, 0
  75  65F0 11 59 7E     	ld		de, MsgErrCode
  76  65F3 CD 79 6E     	call	Byte2Txt
  77  65F6 21 4E 7E     	ld		hl, MsgErr
  78  65F9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  79  65FC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  80  65FE CD 0C 78     	call	PrintStrClr
  81  6601 CD 56 73     	call	BDOSInit
  82  6604 C3 A2 65     	jp		HCRunInitDisk
  83  6607
  84  6607
  85  6607              HCRunCacheFiles:
  86  6607 CD EA 6A     	call 	GetFileNames
  87  660A
  88  660A              HCRunMain:
  89  660A CD 53 66     	call 	InitUI
  90  660D CD CA 6A     	call	DisplayFilenames
  91  6610 CD D1 66     	call	DisplayDiskInfo
  92  6613 C3 44 67     	jp		ReadKeyLoop
  93  6616
  94  6616              HCRunEnd:
  95  6616              	;restore error handler
  96  6616 E1           	pop		hl
  97  6617 E1           	pop		hl
  98  6618 22 3D 5C     	ld		(ERRSP), hl
  99  661B
 100  661B              	;ret
 101  661B C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 102  661E
 103  661E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 104  661E
 105  661E              ErrorHandler:
 106  661E E1           	pop		hl
 107  661F 22 3D 5C     	ld		(ERRSP), hl
 108  6622
 109  6622 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 110  6625 6F           	ld		l, a
 111  6626 26 00        	ld		h, 0
 112  6628 11 59 7E     	ld		de, MsgErrCode
 113  662B CD 79 6E     	call	Byte2Txt
 114  662E 21 4E 7E     	ld		hl, MsgErr
 115  6631 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 116  6634 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 117  6636 CD 0C 78     	call	PrintStrClr
 118  6639
 119  6639 3A 3A 5C     	ld		a, (ERRNR)
 120  663C CD 17 73     	call	GetErrMsg
 121  663F
 122  663F 21 DC 8E     	ld		hl, DataBuf
 123  6642 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 124  6645 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 125  6647 CD 0C 78     	call	PrintStrClr
 126  664A
 127  664A CD A8 77     	call	ReadChar
 128  664D CD 56 73     	call	BDOSInit
 129  6650 C3 90 65     	jp		Start
 130  6653
 131  6653              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 132  6653
 133  6653              InitUI:
 134  6653 AF           	xor		a
 135  6654 32 92 80     	ld		(SelFile), A
 136  6657 3E 11        	ld		a, LST_FIRST_COL + 1
 137  6659 32 91 80     	ld		(NameCol), A
 138  665C 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 139  665F ED 53 B0 5C  	ld		(LineCol), de
 140  6663
 141  6663 CD C4 77     	call	ClrScr
 142  6666
 143  6666 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 144  6669 ED 4B A5 79  	ld		bc, (CurrScrAttrAddr)
 145  666D 09           	add		hl, bc
 146  666E 22 93 80     	ld		(CursorAddr), hl
 147  6671
 148  6671 CD B5 78     	call	DrawVLines
 149  6674
 150  6674 CD 5B 78     	call	DrawHLines
 151  6677
 152  6677 21 8F 7D     	ld		hl, VerMsg1
 153  667A 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 154  667D 3A 9E 7D     	ld		a, (VerMsg1 + 15)
 155  6680 F6 80        	or		$80
 156  6682 32 9E 7D     	ld		(VerMsg1 + 15), a
 157  6685 CD E4 77     	call	PrintStr
 158  6688 21 9F 7D     	ld		hl, VerMsg2
 159  668B 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 160  668E CD E4 77     	call	PrintStr
 161  6691
 162  6691 3E 60        	ld		a, SCR_LBL_CLR
 163  6693 11 00 17     	ld		de, 23 << 8
 164  6696 21 EF 7D     	ld		hl, BtnBar
 165  6699 CD 0C 78     	call	PrintStrClr
 166  669C
 167  669C 3E 60        	ld		a, SCR_LBL_CLR
 168  669E 21 AF 7D     	ld		hl, MsgSysInf
 169  66A1 11 00 01     	ld		de, LST_PROG_INFO << 8
 170  66A4 CD 0C 78     	call	PrintStrClr
 171  66A7
 172  66A7 3E 60        	ld		a, SCR_LBL_CLR
 173  66A9 21 BF 7D     	ld		hl, MsgDskInf
 174  66AC 11 00 04     	ld		de, LST_DISK_INFO << 8
 175  66AF CD 0C 78     	call	PrintStrClr
 176  66B2
 177  66B2 3E 60        	ld		a, SCR_LBL_CLR
 178  66B4 21 CF 7D     	ld		hl, MsgFileInf
 179  66B7 11 00 07     	ld		de, LST_FILE_INFO << 8
 180  66BA CD 0C 78     	call	PrintStrClr
 181  66BD
 182  66BD 3E 60        	ld		a, SCR_LBL_CLR
 183  66BF 21 DF 7D     	ld		hl, MsgMessages
 184  66C2 11 00 0D     	ld		de, LST_LINE_MSG << 8
 185  66C5 CD 0C 78     	call	PrintStrClr
 186  66C8
 187  66C8 3E 60        	ld		a, SCR_SEL_CLR
 188  66CA CD CD 78     	call	DrawCursor
 189  66CD
 190  66CD CD 0C 73     	call	SetFastKeys
 191  66D0
 192  66D0 C9           	ret
 193  66D1
 194  66D1
 195  66D1              DisplayDiskInfo:
 196  66D1 2A 97 80     	ld		hl, (AUCntMaxFree)
 197  66D4 ED 5B 95 80  	ld		de, (AUCntUsed)
 198  66D8 B7           	or		a
 199  66D9 ED 52        	sbc		hl, de
 200  66DB CB 15        	rl		l								;*2, 2K/AU
 201  66DD CB 14        	rl		h
 202  66DF
 203  66DF 11 39 7E     	ld		de, MsgDriveLet
 204  66E2 CD 6E 6E     	call	Word2Txt
 205  66E5 3A 3D 7E     	ld		a, (MsgDriveLet+4)
 206  66E8 F6 80        	or		$80
 207  66EA 32 3D 7E     	ld		(MsgDriveLet+4), a
 208  66ED
 209  66ED 3A 3E 73     	ld		a, (RWTSDrive)
 210  66F0 C6 41        	add		'A'
 211  66F2 32 39 7E     	ld		(MsgDriveLet), a
 212  66F5 3E 2F        	ld		a, '/'
 213  66F7 32 3A 7E     	ld		(MsgDriveLet+1), a
 214  66FA
 215  66FA 21 2E 7E     	ld		hl, MsgDrive
 216  66FD 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 217  6700 CD E4 77     	call	PrintStr
 218  6703
 219  6703 2A 95 80     	ld		hl, (AUCntUsed)
 220  6706 CB 15        	rl		l								;*2, 2K/AU
 221  6708 CB 14        	rl		h
 222  670A 11 49 7E     	ld		de, MsgFilesCntNo+2
 223  670D CD 6E 6E     	call	Word2Txt
 224  6710 3A 4D 7E     	ld		a, (MsgFilesCntNo+6)
 225  6713 F6 80        	or		$80
 226  6715 32 4D 7E     	ld		(MsgFilesCntNo+6), a
 227  6718 3E 2F        	ld		a, '/'
 228  671A 32 4A 7E     	ld		(MsgFilesCntNo+3), a
 229  671D
 230  671D 3A 90 80     	ld		a, (FileCnt)
 231  6720 6F           	ld		l, a
 232  6721 26 00        	ld		h, 0
 233  6723 11 47 7E     	ld		de, MsgFilesCntNo
 234  6726 CD 79 6E     	call	Byte2Txt
 235  6729 21 3E 7E     	ld		hl, MsgFilesCnt
 236  672C 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 237  672F CD E4 77     	call	PrintStr
 238  6732
 239  6732 C9           	ret
 240  6733
 241  6733              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 242  6733
 243  6733              CalcFileCache:
 244  6733 3A 92 80     	ld		a, (SelFile)
 245  6736 11 19 00     	ld		de, CACHE_SZ
 246  6739 CD D5 6E     	call	Mul
 247  673C 01 BE 80     	ld		bc, FileCache
 248  673F 09           	add		hl, bc					;HL = file AU cnt
 249  6740 22 99 80     	ld		(SelFileCache), hl
 250  6743 C9           	ret
 251  6744
 252  6744              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 253  6744
 254  6744
 255  6744              ReadKeyLoop:
 256  6744 CD 33 67     	call	CalcFileCache
 257  6747 CD B2 6C     	call	DisplayFileInfo
 258  674A
 259  674A CD A8 77     	call	ReadChar
 260  674D
 261  674D FE 0A        	cp		KEY_DOWN
 262  674F 28 04        	jr		z,  DoKeyDown
 263  6751 FE 61        	cp 		'a'
 264  6753 20 11        	jr		nz, CheckUp
 265  6755
 266  6755              DoKeyDown:
 267  6755 3A 90 80     	ld		a, (FileCnt)
 268  6758 47           	ld		b, a
 269  6759 3A 92 80     	ld		a, (SelFile)
 270  675C 3C           	inc		a
 271  675D B8           	cp		b
 272  675E 30 E4        	jr		nc, ReadKeyLoop
 273  6760 32 92 80     	ld		(SelFile), a
 274  6763 C3 92 6A     	jp		MoveIt
 275  6766
 276  6766              CheckUp:
 277  6766 FE 0B        	cp		KEY_UP
 278  6768 28 04        	jr		z, DoKeyUp
 279  676A FE 71        	cp 		'q'
 280  676C 20 0D        	jr		nz, CheckRight
 281  676E
 282  676E              DoKeyUp:
 283  676E 3A 92 80     	ld		a, (SelFile)
 284  6771 B7           	or		a
 285  6772 28 D0        	jr		z, ReadKeyLoop
 286  6774
 287  6774 3D           	dec		a
 288  6775 32 92 80     	ld		(SelFile), a
 289  6778 C3 92 6A     	jp		MoveIt
 290  677B
 291  677B              CheckRight:
 292  677B FE 09        	cp		KEY_RIGHT
 293  677D 28 04        	jr		z, DoKeyRight
 294  677F FE 70        	cp 		'p'
 295  6781 20 12        	jr		nz, CheckLeft
 296  6783
 297  6783              DoKeyRight:
 298  6783 3A 90 80     	ld		a, (FileCnt)
 299  6786 47           	ld		b, a
 300  6787 3A 92 80     	ld		a, (SelFile)
 301  678A C6 15        	add		LST_LINES_CNT
 302  678C B8           	cp		b
 303  678D 30 B5        	jr		nc, ReadKeyLoop
 304  678F
 305  678F 32 92 80     	ld		(SelFile), a
 306  6792 C3 92 6A     	jp		MoveIt
 307  6795
 308  6795              CheckLeft:
 309  6795 FE 08        	cp		KEY_LEFT
 310  6797 28 04        	jr		z, DoKeyLeft
 311  6799 FE 6F        	cp		'o'
 312  679B 20 0D        	jr		nz, CheckEnter
 313  679D
 314  679D              DoKeyLeft:
 315  679D 3A 92 80     	ld		a, (SelFile)
 316  67A0 D6 15        	sub		LST_LINES_CNT
 317  67A2 38 A0        	jr		c, ReadKeyLoop
 318  67A4
 319  67A4 32 92 80     	ld		(SelFile), a
 320  67A7 C3 92 6A     	jp		MoveIt
 321  67AA
 322  67AA              CheckEnter:
 323  67AA FE 0D        	cp		KEY_ENTER
 324  67AC 28 05        	jr		z, DoKeyEnter
 325  67AE FE 6D        	cp		'm'
 326  67B0 C2 B9 67     	jp		nz, CheckKeyInfo
 327  67B3
 328  67B3              DoKeyEnter:
 329  67B3 CD 7F 6B     	call	HandleFile
 330  67B6 C3 0A 66     	jp		HCRunMain
 331  67B9
 332  67B9              CheckKeyInfo:
 333  67B9 FE 34        	cp		'4'
 334  67BB 20 21        	jr		nz, CheckKeyCopy
 335  67BD
 336  67BD 3A 90 80     	ld		a, (FileCnt)
 337  67C0 B7           	or		a
 338  67C1 CA 44 67     	jp		z, ReadKeyLoop
 339  67C4
 340  67C4 DD 2A 99 80  	ld		ix, (SelFileCache)
 341  67C8 21 0F 7F     	ld		hl, MsgReadingExt
 342  67CB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 343  67CE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 344  67D0 CD 0C 78     	call	PrintStrClr
 345  67D3 CD 8C 72     	call	ReadFileHeader
 346  67D6 06 01        	ld		b, 1
 347  67D8 CD 90 79     	call	ClearNMsgLines
 348  67DB C3 44 67     	jp		ReadKeyLoop
 349  67DE
 350  67DE              CheckKeyCopy:
 351  67DE FE 35        	cp		'5'
 352  67E0 C2 2A 68     	jp		nz, CheckKeyFileInfo
 353  67E3
 354  67E3 3A 90 80     	ld		a, (FileCnt)
 355  67E6 B7           	or		a
 356  67E7 CA 44 67     	jp		z, ReadKeyLoop
 357  67EA
 358  67EA 2A 99 80     	ld		hl, (SelFileCache)
 359  67ED CD 84 74     	call	CopyFile
 360  67F0 3A 9E 80     	ld		a, (CopyFileRes)
 361  67F3 B7           	or		a
 362  67F4 28 1A        	jr		z, CopyFileOK
 363  67F6
 364  67F6 6F           	ld		l, a
 365  67F7 26 00        	ld		h, 0
 366  67F9 11 59 7E     	ld		de, MsgErrCode
 367  67FC CD 79 6E     	call	Byte2Txt
 368  67FF 21 4E 7E     	ld		hl, MsgErr
 369  6802 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 370  6805 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371  6807 CD 0C 78     	call	PrintStrClr
 372  680A CD A8 77     	call	ReadChar
 373  680D C3 44 67     	jp		ReadKeyLoop
 374  6810
 375  6810              CopyFileOK:
 376  6810 06 02        	ld		b, 2
 377  6812 CD 90 79     	call	ClearNMsgLines
 378  6815              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 379  6815 3A 9B 80     	ld		a, (CopySelOption)
 380  6818 FE 33        	cp		'3'
 381  681A CA 44 67     	jp		z, ReadKeyLoop
 382  681D 3A B2 80     	ld		a, (CopyFileDstDrv)
 383  6820 3D           	dec		a
 384  6821 32 3E 73     	ld		(RWTSDrive), a
 385  6824 CD 59 73     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 386  6827 C3 A2 65     	jp		HCRunInitDisk
 387  682A
 388  682A              CheckKeyFileInfo:
 389  682A FE 20        	cp		' '
 390  682C 20 0D        	jr		nz, CheckKeyDriveA
 391  682E
 392  682E 3A 90 80     	ld		a, (FileCnt)
 393  6831 B7           	or		a
 394  6832 CA 44 67     	jp		z, ReadKeyLoop
 395  6835
 396  6835 CD 18 6E     	call	ReadAllHeaders
 397  6838 C3 44 67     	jp		ReadKeyLoop
 398  683B
 399  683B              CheckKeyDriveA:
 400  683B FE 31        	cp		'1'
 401  683D 20 05        	jr		nz, CheckKeyDriveB
 402  683F 3E 00        	ld		a, DRIVE_A_CPM
 403  6841 C3 6B 69     	jp		SelectDrive
 404  6844
 405  6844              CheckKeyDriveB:
 406  6844 FE 32        	cp		'2'
 407  6846 20 05        	jr		nz, CheckKeyView
 408  6848 3E 01        	ld		a, DRIVE_B_CPM
 409  684A C3 6B 69     	jp		SelectDrive
 410  684D
 411  684D              CheckKeyView:
 412  684D FE 33        	cp		'3'
 413  684F 20 36        	jr		nz, CheckKeyRename
 414  6851
 415  6851 3A 90 80     	ld		a, (FileCnt)
 416  6854 B7           	or		a
 417  6855 CA 44 67     	jp		z, ReadKeyLoop
 418  6858
 419  6858
 420  6858 21 60 80     	ld		hl, MsgViewFileMenu
 421  685B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 422  685E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 423  6860 CD 0C 78     	call		PrintStrClr
 424  6863 21 6F 80     	ld		hl, MsgViewFileText
 425  6866 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 426  6869 CD E4 77     	call		PrintStr
 427  686C 21 78 80     	ld		hl, MsgViewFileHex
 428  686F 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 429  6872 CD E4 77     	call		PrintStr
 430  6875 21 80 80     	ld		hl, MsgViewFileAuto
 431  6878 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 432  687B CD E4 77     	call		PrintStr
 433  687E CD A8 77     	call		ReadChar
 434  6881
 435  6881 CD FA 6B     	call		ViewFile
 436  6884 C3 0A 66     	jp		HCRunMain
 437  6887
 438  6887              CheckKeyRename:
 439  6887 FE 36        	cp		'6'
 440  6889 20 6C        	jr		nz, CheckKeyDel
 441  688B
 442  688B 3A 90 80     	ld		a, (FileCnt)
 443  688E B7           	or		a
 444  688F CA 44 67     	jp		z, ReadKeyLoop
 445  6892
 446  6892 21 52 7F     	ld		hl, MsgNewFileName
 447  6895 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 448  6898 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 449  689A CD 0C 78     	call	PrintStrClr
 450  689D
 451  689D 21 1D 7F     	ld		hl, MsgClear
 452  68A0 11 DC 8E     	ld		de, FileData
 453  68A3 01 0B 00     	ld		bc, NAMELEN
 454  68A6 ED B0        	ldir
 455  68A8 3E A0        	ld		a, $80 | ' '
 456  68AA 12           	ld		(de), a
 457  68AB 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 458  68AE 21 DC 8E     	ld		hl, FileData
 459  68B1 CD E4 77     	call	PrintStr
 460  68B4
 461  68B4 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 462  68B7 01 0B 00     	ld		bc, NAMELEN
 463  68BA CD 4E 79     	call	ReadString
 464  68BD
 465  68BD 11 DC 8E     	ld		de, FileData
 466  68C0 1A           	ld		a, (de)
 467  68C1 FE 20        	cp		' '					;If starting with space, input was canceled.
 468  68C3 CA EF 68     	jp		z, RenameCanceled
 469  68C6
 470  68C6              	;Check if new name doesn't exist already. Cancel if so.
 471  68C6 21 DC 8E     	ld		hl, FileData
 472  68C9 3A 3E 73     	ld 		a, (RWTSDrive)
 473  68CC 3C           	inc		a
 474  68CD CD EA 73     	call	DoesFileExist
 475  68D0 3C           	inc		a
 476  68D1 28 10        	jr		z, RenameFileNotExist
 477  68D3
 478  68D3 21 F6 7F     	ld		hl, MsgFileExists
 479  68D6 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 480  68D9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 481  68DB CD 0C 78     	call	PrintStrClr
 482  68DE CD A8 77     	call	ReadChar
 483  68E1 18 0C        	jr		RenameCanceled
 484  68E3
 485  68E3              RenameFileNotExist:
 486  68E3 11 DC 8E     	ld		de, FileData
 487  68E6 2A 99 80     	ld		hl, (SelFileCache)
 488  68E9 CD 2D 74     	call	RenameFile
 489  68EC C3 A2 65     	jp		HCRunInitDisk
 490  68EF
 491  68EF              RenameCanceled:
 492  68EF 06 02        	ld		b, 2
 493  68F1 CD 90 79     	call	ClearNMsgLines
 494  68F4 C3 44 67     	jp		ReadKeyLoop
 495  68F7
 496  68F7              CheckKeyDel:
 497  68F7 FE 38        	cp		'8'
 498  68F9 20 2E        	jr		nz, CheckKeyAttrib
 499  68FB
 500  68FB 3A 90 80     	ld		a, (FileCnt)
 501  68FE B7           	or		a
 502  68FF CA 44 67     	jp		z, ReadKeyLoop
 503  6902
 504  6902 21 2D 7F     	ld		hl, MsgDelete
 505  6905 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 506  6908 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 507  690A CD 0C 78     	call	PrintStrClr
 508  690D CD A8 77     	call	ReadChar
 509  6910 FE 79        	cp		'y'
 510  6912 28 08        	jr		z, DoFileDelete
 511  6914 06 01        	ld		b, 1
 512  6916 CD 90 79     	call	ClearNMsgLines
 513  6919 C3 44 67     	jp		ReadKeyLoop
 514  691C              DoFileDelete:
 515  691C 2A 99 80     	ld		hl, (SelFileCache)
 516  691F 3A 3E 73     	ld 		a, (RWTSDrive)
 517  6922 3C           	inc		a					;Convert to BASIC drive number: 1,2
 518  6923 CD DE 73     	call	DeleteFile
 519  6926 C3 A2 65     	jp		HCRunInitDisk
 520  6929
 521  6929              CheckKeyAttrib:
 522  6929 FE 37        	cp		'7'
 523  692B 20 47        	jr		nz, CheckKeyDiskMenu
 524  692D
 525  692D 3A 90 80     	ld		a, (FileCnt)
 526  6930 B7           	or		a
 527  6931 CA 44 67     	jp		z, ReadKeyLoop
 528  6934
 529  6934 21 3A 7F     	ld		hl, MsgSetRO
 530  6937 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 531  693A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 532  693C CD 0C 78     	call	PrintStrClr
 533  693F CD A8 77     	call	ReadChar
 534  6942 1E 00        	ld		e, 0
 535  6944 FE 79        	cp		'y'
 536  6946 20 02        	jr		nz, CheckSYS
 537  6948 1E 01        	ld		e, 1
 538  694A
 539  694A              CheckSYS:
 540  694A D5           	push	de
 541  694B 21 46 7F     		ld		hl, MsgSetSYS
 542  694E 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 543  6951 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 544  6953 CD 0C 78     		call	PrintStrClr
 545  6956 CD A8 77     		call	ReadChar
 546  6959 FE 79        		cp		'y'
 547  695B D1           	pop		de
 548  695C 20 04        	jr		nz, AttrChange
 549  695E 3E 02        	ld		a, %10
 550  6960 B3           	or		e
 551  6961 5F           	ld		e, a
 552  6962
 553  6962              AttrChange:
 554  6962 2A 99 80     	ld		hl, (SelFileCache)
 555  6965 CD 03 74     	call	ChangeFileAttrib
 556  6968 C3 A2 65     	jp		HCRunInitDisk
 557  696B
 558  696B              SelectDrive:
 559  696B 32 3E 73     	ld 		(RWTSDrive), a
 560  696E CD 59 73     	call	BDOSSelectDisk
 561  6971              	;call	BDOSInit
 562  6971 C3 A2 65     	jp		HCRunInitDisk
 563  6974
 564  6974              CheckKeyDiskMenu:
 565  6974 FE 39        	cp		'9'
 566  6976 C2 8A 6A     	jp		nz, CheckKeyExit
 567  6979
 568  6979 3A 3E 73     	ld		a, (RWTSDrive)
 569  697C C6 41        	add		'A'
 570  697E              	;Update menu messages with current drive.
 571  697E 32 8F 7F     	ld		(MsgMenuSingleDrv1), a
 572  6981 32 93 7F     	ld		(MsgMenuSingleDrv2), a
 573  6984 32 9D 7F     	ld		(MsgMenuDualDrv1), a
 574  6987 32 AB 7F     	ld		(MsgMenuToComDrv), a
 575  698A 32 BF 7F     	ld		(MsgMenuFromCOMDrv), a
 576  698D              	;Update menu messages with the alternate drive.
 577  698D 3A 3E 73     	ld		a, (RWTSDrive)
 578  6990 3C           	inc		a
 579  6991 EE 03        	xor		%11
 580  6993 C6 40        	add		'A'-1
 581  6995 32 A1 7F     	ld		(MsgMenuDualDrv2), a
 582  6998
 583  6998 21 62 7F     	ld		hl, MsgMenuDiskCopy
 584  699B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 585  699E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586  69A0 CD 0C 78     	call	PrintStrClr
 587  69A3 21 7B 7F     	ld		hl, MsgMenuBack
 588  69A6 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 589  69A9 CD E4 77     	call	PrintStr
 590  69AC 21 87 7F     	ld		hl, MsgMenuSingle
 591  69AF 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 592  69B2 CD E4 77     	call	PrintStr
 593  69B5 21 95 7F     	ld		hl, MsgMenuDual
 594  69B8 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 595  69BB CD E4 77     	call	PrintStr
 596  69BE 21 A3 7F     	ld		hl, MsgMenuToCOM
 597  69C1 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 598  69C4 CD E4 77     	call	PrintStr
 599  69C7 21 B2 7F     	ld		hl, MsgMenuFromCOM
 600  69CA 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 601  69CD CD E4 77     	call	PrintStr
 602  69D0 21 C1 7F     	ld		hl, MsgMenuFmt1
 603  69D3 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 604  69D6 CD E4 77     	call	PrintStr
 605  69D9 21 CD 7F     	ld		hl, MsgMenuFmt2
 606  69DC 11 00 15     	ld		de, LST_LINE_MSG + 8 << 8
 607  69DF CD E4 77     	call	PrintStr
 608  69E2
 609  69E2 CD A8 77     	call	ReadChar
 610  69E5 F5           	push	af
 611  69E6 06 08        		ld		b, 8
 612  69E8 CD 90 79     		call	ClearNMsgLines
 613  69EB F1           	pop		af
 614  69EC 32 9B 80     	ld		(CopySelOption), a
 615  69EF
 616  69EF              CheckKeyDiskMenuLoop:
 617  69EF FE 30        	cp		'0'
 618  69F1 CA 87 6A     	jp		z, DiskMenuExit
 619  69F4
 620  69F4              	;Single drive copy
 621  69F4 FE 31        	cp		'1'
 622  69F6 20 0B        	jr		nz, CheckDiskMenuDualDrive
 623  69F8 CD 7B 70     	call	CopyDisk
 624  69FB 06 02        	ld		b, 2
 625  69FD CD 90 79     	call	ClearNMsgLines
 626  6A00 C3 87 6A     	jp		DiskMenuExit
 627  6A03
 628  6A03              	;Dual drive copy
 629  6A03              CheckDiskMenuDualDrive:
 630  6A03 FE 32        	cp		'2'
 631  6A05 20 0A        	jr		nz, CheckDiskMenuToCOM
 632  6A07 CD 7B 70     	call	CopyDisk
 633  6A0A 06 02        	ld		b, 2
 634  6A0C CD 90 79     	call	ClearNMsgLines
 635  6A0F 18 76        	jr		DiskMenuExit
 636  6A11
 637  6A11              CheckDiskMenuToCOM:
 638  6A11 FE 33        	cp		'3'
 639  6A13 20 05        	jr		nz, CheckDiskMenuFromCOM
 640  6A15 CD 34 71     	call	CopyDiskToCOM
 641  6A18 18 6D        	jr		DiskMenuExit
 642  6A1A
 643  6A1A              CheckDiskMenuFromCOM:
 644  6A1A FE 34        	cp		'4'
 645  6A1C 20 06        	jr		nz, CheckDiskMenuFormat1
 646  6A1E CD 90 71     	call	CopyDiskFromCOM
 647  6A21 C3 A2 65     	jp		HCRunInitDisk
 648  6A24
 649  6A24              CheckDiskMenuFormat1:
 650  6A24 FE 35        	cp		'5'
 651  6A26 C2 33 6A     	jp		nz, CheckDiskMenuFormat2
 652  6A29
 653  6A29 3E 00        	ld		a, DRIVE_A_CPM
 654  6A2B 32 3E 73     	ld		(RWTSDrive), a
 655  6A2E 21 C4 7F     	ld		hl, MsgMenuFmt1+3
 656  6A31 18 0D        	jr		FormatDiskAction
 657  6A33
 658  6A33              CheckDiskMenuFormat2:
 659  6A33 FE 36        	cp		'6'
 660  6A35 C2 0A 66     	jp		nz, HCRunMain
 661  6A38
 662  6A38 3E 01        	ld		a, DRIVE_B_CPM
 663  6A3A 32 3E 73     	ld		(RWTSDrive), a
 664  6A3D 21 D0 7F     	ld		hl, MsgMenuFmt2+3
 665  6A40
 666  6A40              FormatDiskAction:
 667  6A40 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 668  6A43 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 669  6A45 CD 0C 78     	call	PrintStrClr
 670  6A48
 671  6A48 21 41 80     	ld		hl, MsgAreYouSure
 672  6A4B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 673  6A4E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 674  6A50 CD 0C 78     	call	PrintStrClr
 675  6A53 CD A8 77     	call	ReadChar
 676  6A56 FE 79        	cp		'y'
 677  6A58 C2 0A 66     	jp		nz, HCRunMain
 678  6A5B
 679  6A5B 21 1D 7F     	ld		hl, MsgClear
 680  6A5E 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 681  6A61 3E 45        	ld		a, SCR_DEF_CLR
 682  6A63 CD 0C 78     	call	PrintStrClr
 683  6A66
 684  6A66 CD AA 6F     	call	FormatDisk
 685  6A69 B7           	or		a
 686  6A6A CA A2 65     	jp		z, HCRunInitDisk
 687  6A6D
 688  6A6D              	;Display error for format
 689  6A6D 6F           	ld		l, a
 690  6A6E 26 00        	ld		h, 0
 691  6A70 11 59 7E     	ld		de, MsgErrCode
 692  6A73 CD 79 6E     	call	Byte2Txt
 693  6A76 21 4E 7E     	ld		hl, MsgErr
 694  6A79 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 695  6A7C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 696  6A7E CD 0C 78     	call	PrintStrClr
 697  6A81 CD A8 77     	call	ReadChar
 698  6A84 C3 A2 65     	jp		HCRunInitDisk
 699  6A87
 700  6A87              DiskMenuExit:
 701  6A87 C3 44 67     	jp		ReadKeyLoop
 702  6A8A
 703  6A8A              CheckKeyExit:
 704  6A8A FE 30        	cp		'0'
 705  6A8C C2 44 67     	jp		nz, ReadKeyLoop
 706  6A8F C3 16 66     	jp		HCRunEnd
 707  6A92              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 708  6A92
 709  6A92              MoveIt:
 710  6A92 CD D8 78     	call 	MoveCursor
 711  6A95 C3 44 67     	jp		ReadKeyLoop
 712  6A98
 713  6A98              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 714  6A98
 715  6A98
 716  6A98              DisplayFilename:
 717  6A98 06 0B        	LD		B, NAMELEN
 718  6A9A              DispLoop:
 719  6A9A 1A           	LD		A, (DE)
 720  6A9B
 721  6A9B              	;clear bit 7
 722  6A9B CB BF        	RES 	7, A
 723  6A9D 32 81 5C     	LD		(CODE), A
 724  6AA0
 725  6AA0 13           	INC		DE
 726  6AA1 D5           	PUSH	DE
 727  6AA2 C5           	PUSH	BC
 728  6AA3 CD 10 79     		CALL	PrintChar
 729  6AA6 C1           	POP		BC
 730  6AA7 D1           	POP 	DE
 731  6AA8
 732  6AA8 21 B0 5C     	LD		HL, COL
 733  6AAB 34           	INC		(HL)
 734  6AAC 10 EC        	DJNZ	DispLoop
 735  6AAE              	;now a name is displayed
 736  6AAE
 737  6AAE              	;check bounds
 738  6AAE 3A B1 5C     	LD		A, (LINE)
 739  6AB1 3C           	INC		A
 740  6AB2 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 741  6AB4 38 0A        	JR		C, LineOK
 742  6AB6
 743  6AB6              	;set names column to the next one
 744  6AB6 3A 91 80     	LD		A, (NameCol)
 745  6AB9 C6 0C        	ADD		NAMELEN + 1
 746  6ABB 32 91 80     	LD		(NameCol), A
 747  6ABE
 748  6ABE 3E 01        	LD		A, LST_FIRST_LINE
 749  6AC0              LineOK:
 750  6AC0 32 B1 5C     	LD		(LINE), A
 751  6AC3
 752  6AC3 3A 91 80     	LD		A, (NameCol)
 753  6AC6 32 B0 5C     	LD		(COL), A
 754  6AC9
 755  6AC9 C9           	RET
 756  6ACA
 757  6ACA
 758  6ACA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759  6ACA
 760  6ACA              DisplayFilenames:
 761  6ACA 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 762  6ACD ED 53 B0 5C  	ld		(LineCol), de
 763  6AD1
 764  6AD1 11 BE 80     	ld		de, FileCache
 765  6AD4 3A 90 80     	ld		a, (FileCnt)
 766  6AD7 B7           	or		a
 767  6AD8 C8           	ret		z
 768  6AD9
 769  6AD9 47           	ld		b,	a
 770  6ADA
 771  6ADA              DisplayFilenamesLoop:
 772  6ADA C5           	push	bc
 773  6ADB D5           		push	de
 774  6ADC CD 98 6A     			call	DisplayFilename
 775  6ADF D1           		pop		de
 776  6AE0 EB           		ex		de, hl
 777  6AE1 01 19 00     		ld		bc, CACHE_SZ
 778  6AE4 09           		add		hl, bc
 779  6AE5 EB           		ex		de, hl
 780  6AE6 C1           	pop		bc
 781  6AE7 10 F1        	djnz	DisplayFilenamesLoop
 782  6AE9
 783  6AE9 C9           	ret
 784  6AEA
 785  6AEA
 786  6AEA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 787  6AEA              ;Selects only valid filenames (not deleted and only from first extension)
 788  6AEA              GetFileNames:
 789  6AEA DD 21 DC 8E  	ld		ix, TrackBuf
 790  6AEE 11 BE 80     	ld		de, FileCache
 791  6AF1 06 80        	ld		b, MAX_EXT_CNT
 792  6AF3 AF           	xor		a
 793  6AF4 32 90 80     	ld		(FileCnt), a
 794  6AF7 21 95 80     	ld		hl, AUCntUsed
 795  6AFA 77           	ld		(hl), a
 796  6AFB 23           	inc		hl
 797  6AFC 77           	ld		(hl), a
 798  6AFD
 799  6AFD              StoreFilenamesLoop:
 800  6AFD AF           	xor a
 801  6AFE DD BE 00     	cp (ix + EXT_DEL_FLAG)
 802  6B01 C2 71 6B     	jp nz, NextExt
 803  6B04
 804  6B04              	;count AU
 805  6B04 D9           	exx
 806  6B05 E5           	push hl
 807  6B06 CD D9 6F     		call CheckExtAlloc
 808  6B09 EB           		ex de, hl			;save first AU no.
 809  6B0A
 810  6B0A              		;store disk alocated AU count
 811  6B0A 2A 95 80     		ld hl, (AUCntUsed)
 812  6B0D 48           		ld c, b
 813  6B0E 06 00        		ld b, 0
 814  6B10 09           		add hl, bc
 815  6B11 22 95 80     		ld (AUCntUsed), hl
 816  6B14 E1           	pop hl
 817  6B15 D9           	exx
 818  6B16
 819  6B16 AF           	xor	a
 820  6B17 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 821  6B1A 20 2E        	jr nz, FindExt
 822  6B1C
 823  6B1C DD E5        	push ix
 824  6B1E E1           	pop hl
 825  6B1F 23           	inc hl					;skip del flag
 826  6B20
 827  6B20 C5           	push bc
 828  6B21 ~            		/*
 829  6B21 ~            		push de
 830  6B21 ~            			push hl
 831  6B21 ~            				ex de, hl
 832  6B21 ~            				call DisplayFilename
 833  6B21 ~            			pop hl
 834  6B21 ~            		pop de
 835  6B21 ~            		*/
 836  6B21 01 0B 00     		ld bc, NAMELEN
 837  6B24 ED B0        		ldir				;save file name
 838  6B26
 839  6B26 D9           		exx
 840  6B27 D5           		push 	de			;de = first AU
 841  6B28 D9           		exx
 842  6B29 E1           		pop		hl
 843  6B2A EB           		ex		de, hl
 844  6B2B 73           		ld		(hl), e
 845  6B2C 23           		inc		hl
 846  6B2D 72           		ld		(hl), d		;save first AU
 847  6B2E
 848  6B2E 23           		inc		hl
 849  6B2F
 850  6B2F D9           		exx					;save AU cnt for file
 851  6B30 C5           		push	bc
 852  6B31 D9           		exx
 853  6B32 C1           		pop		bc
 854  6B33 71           		ld		(hl), c
 855  6B34 23           		inc		hl
 856  6B35 70           		ld		(hl), b
 857  6B36 23           		inc		hl
 858  6B37
 859  6B37              		;xor		a			;make flag 0 to signal that header is not read yet
 860  6B37              		;ld		(hl), a
 861  6B37
 862  6B37 01 0A 00     		ld		bc, HDR_SZ + 1
 863  6B3A 09           		add		hl, bc
 864  6B3B
 865  6B3B EB           		ex		de, hl
 866  6B3C C1           	pop bc
 867  6B3D
 868  6B3D
 869  6B3D 3A 90 80     	ld 		a, (FileCnt)			;inc file counter
 870  6B40 3C           	inc		a
 871  6B41 32 90 80     	ld 		(FileCnt), a
 872  6B44 FE 54        	cp		LST_MAX_FILES
 873  6B46 38 29        	jr		c, NextExt
 874  6B48 18 34        	jr		GetFileNamesEnd
 875  6B4A
 876  6B4A
 877  6B4A              FindExt:					;BC' = AU cnt for this ext
 878  6B4A C5           	push	bc
 879  6B4B D5           		push 	de
 880  6B4C DD E5        			push	ix
 881  6B4E D1           			pop		de
 882  6B4F 13           			inc		de				;DE = name to find
 883  6B50
 884  6B50 21 BE 80     			ld		hl, FileCache
 885  6B53 3A 90 80     			ld		a, (FileCnt)
 886  6B56 4F           			ld		c, a
 887  6B57 CD 7B 72     			call	FindCache
 888  6B5A 20 13        			jr		nz, FindExtEnd
 889  6B5C
 890  6B5C 01 0D 00     			ld		bc, CACHE_AU_CNT
 891  6B5F 09           			add		hl, bc
 892  6B60 D9           			exx
 893  6B61 C5           			push	bc
 894  6B62 D9           			exx
 895  6B63 C1           			pop		bc
 896  6B64
 897  6B64 5E           			ld		e, (hl)		;DE = Current AU CNT for file
 898  6B65 23           			inc		hl
 899  6B66 56           			ld		d, (hl)
 900  6B67 2B           			dec		hl
 901  6B68 EB           			ex		de, hl
 902  6B69 09           			add		hl, bc
 903  6B6A EB           			ex		de, hl
 904  6B6B 73           			ld		(hl), e
 905  6B6C 23           			inc		hl
 906  6B6D 72           			ld		(hl), d
 907  6B6E 2B           			dec		hl
 908  6B6F              FindExtEnd:
 909  6B6F D1           		pop		de
 910  6B70 C1           	pop		bc
 911  6B71
 912  6B71              NextExt:
 913  6B71 C5           	push bc
 914  6B72 01 20 00     		ld bc, EXT_SZ
 915  6B75 DD 09        		add ix, bc
 916  6B77 C1           	pop	bc
 917  6B78
 918  6B78 05           	dec	b
 919  6B79 78           	ld	a, b
 920  6B7A B7           	or	a
 921  6B7B C2 FD 6A     	jp	nz, StoreFilenamesLoop
 922  6B7E              GetFileNamesEnd:
 923  6B7E C9           	ret
 924  6B7F
 925  6B7F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926  6B7F
 927  6B7F              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 928  6B7F              ;IN: HL = file name
 929  6B7F              HandleFile:
 930  6B7F              	;Make HL point to the selected file
 931  6B7F DD 2A 99 80  	ld		ix, (SelFileCache)
 932  6B83 DD E5        	push	ix
 933  6B85 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 934  6B88 B7           		or		a
 935  6B89 CC 8C 72     		call	z, ReadFileHeader
 936  6B8C
 937  6B8C DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 938  6B8F FE 00        		cp		PROG_TYPE
 939  6B91 28 56        		jr		z, HandleFileProg
 940  6B93
 941  6B93 FE 03        		cp		BYTE_TYPE
 942  6B95 20 62        		jr		nz, HandleFileText
 943  6B97
 944  6B97 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)		;get length
 945  6B9A DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 946  6B9D 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 947  6BA0 19           		add		hl, de
 948  6BA1 7C           		ld		a, h
 949  6BA2 B5           		or		l
 950  6BA3 28 26        		jr		z, HandleFileSCR
 951  6BA5
 952  6BA5
 953  6BA5              HandleFileCODE:
 954  6BA5 21 7B 7E     		ld		hl, MsgLoadingCODE
 955  6BA8 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 956  6BAB 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 957  6BAD CD 0C 78     		call	PrintStrClr
 958  6BB0
 959  6BB0              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 960  6BB0 21 03 72     		ld		hl, IF1FileLoad
 961  6BB3 11 00 5B     		ld		de, PRN_BUF
 962  6BB6 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 963  6BB9 ED B0        		ldir
 964  6BBB              		;ld		a, $C9
 965  6BBB              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 966  6BBB
 967  6BBB E1           	pop		hl
 968  6BBC ED 5B DF 8E  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 969  6BC0 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 970  6BC1 C1           	pop		bc						;2nd, 3rd call for error handler
 971  6BC2 C1           	pop		bc
 972  6BC3 ED 43 3D 5C  	ld		(ERRSP), bc
 973  6BC7 D5           	push	de						;push CODE address to return to = start of CODE block
 974  6BC8 C3 00 5B     	jp		PRN_BUF
 975  6BCB
 976  6BCB
 977  6BCB
 978  6BCB
 979  6BCB              HandleFileSCR:
 980  6BCB 21 6C 7E     		ld		hl, MsgLoadingSCR
 981  6BCE 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 982  6BD1 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 983  6BD3 CD 0C 78     		call	PrintStrClr
 984  6BD6
 985  6BD6 E1           	pop		hl
 986  6BD7
 987  6BD7              	IFDEF _REAL_HW_
 988  6BD7              		;Load to alternate SCREEN$ memory
 989  6BD7 11 00 C0     		ld		de, HC_VID_BANK1
 990  6BDA CD 03 72     		call	IF1FileLoad
 991  6BDD
 992  6BDD              		;Set display to alternate SCREEN$ memory
 993  6BDD 3E 08        		ld		a, HC_CFG_VID_C000
 994  6BDF D3 7E        		out 	(HC_CFG_PORT), a
 995  6BE1 CD A8 77     		call	ReadChar
 996  6BE4
 997  6BE4              		;Set back to regular SCREEN$ memory
 998  6BE4 3E 00        		ld		a, HC_CFG_VID_4000
 999  6BE6 D3 7E        		out 	(HC_CFG_PORT), a
1000  6BE8              	ELSE
1001  6BE8 ~            		ld		de, HC_VID_BANK0
1002  6BE8 ~            		call	IF1FileLoad
1003  6BE8 ~            		call	ReadChar
1004  6BE8              	ENDIF
1005  6BE8
1006  6BE8 C9           	ret
1007  6BE9
1008  6BE9              HandleFileProg:
1009  6BE9 21 5D 7E     		ld		hl, MsgLoadingPrg
1010  6BEC 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
1011  6BEF 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
1012  6BF1 CD 0C 78     		call	PrintStrClr
1013  6BF4 E1           	pop		hl
1014  6BF5 CD F3 72     	call	LoadProgram
1015  6BF8 C9           	ret
1016  6BF9
1017  6BF9
1018  6BF9              HandleFileText:
1019  6BF9 E1           	pop		hl
1020  6BFA
1021  6BFA
1022  6BFA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1023  6BFA
1024  6BFA              ;Use constants for loading in RAM only as much as we can in order to fit both the binary and the text representation.
1025  6BFA              ViewFileConvertRatioText	EQU	1				;Text data is stored as is, 1:1, byte to byte.
1026  6BFA              ViewFileConvertRatioBASIC	EQU	4				;BASIC tokens are expanded to text as 1 byte to 3 chars on average? To test!
1027  6BFA              ViewFileConvertRatioHEX		EQU	5				;1 byte expands to 4 bytes when printed as hex. So RAM stores 1+4 bytes for each byte.
1028  6BFA              ViewFileConvertRatioASM		EQU	3				;Disassembly is expanded as 1:3? To test!
1029  6BFA
1030  6BFA              ;Auto viewing mode will show content bases on file type: no type - as text, programs as BASIC, rest - as hex
1031  6BFA              ;Skip header, if exists.
1032  6BFA
1033  6BFA              ViewFile:
1034  6BFA F5           	push		af				;Save file menu choice.
1035  6BFB
1036  6BFB 21 51 80     		ld		hl, MsgFileLoading
1037  6BFE 11 00 0E     		ld		de, LST_LINE_MSG + 1 << 8
1038  6C01 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
1039  6C03 CD 0C 78     		call		PrintStrClr
1040  6C06
1041  6C06              		;Read file header if not yet read.
1042  6C06 DD 2A 99 80  		ld		ix, (SelFileCache)
1043  6C0A DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1044  6C0D B7           		or		a
1045  6C0E CC 8C 72     		call		z, ReadFileHeader
1046  6C11
1047  6C11 F1           	pop		af
1048  6C12 FE 31        	cp		'1'
1049  6C14 28 13        	jr		z, ViewFileAsText
1050  6C16
1051  6C16 FE 32        	cp		'2'
1052  6C18 28 17        	jr		z, ViewFileAsHex
1053  6C1A
1054  6C1A              ViewFileAuto:
1055  6C1A              	;Decide how to display file, if auto mode.
1056  6C1A DD 2A 99 80  	ld		ix, (SelFileCache)
1057  6C1E DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1058  6C21 FE 00        	cp		PROG_TYPE
1059  6C23 28 22        	jr		z, ViewFileAsBASIC
1060  6C25
1061  6C25 FE 03        	cp		BYTE_TYPE
1062  6C27 28 08        	jr		z, ViewFileAsHex
1063  6C29
1064  6C29              ViewFileAsText:
1065  6C29              	;If text file, load as much as possible to RAM.
1066  6C29 06 60        	ld		b, MAX_SECT_BUF * ViewFileConvertRatioText
1067  6C2B CD 76 6C     	call		ReadFileForViewing
1068  6C2E C3 6B 6C     	jp		ViewFileText
1069  6C31
1070  6C31              ViewFileAsHex:
1071  6C31 06 13        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioHEX
1072  6C33 CD 76 6C     	call		ReadFileForViewing
1073  6C36 11 0F A2     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioHEX
1074  6C39 D5           	push		de
1075  6C3A CD 35 6F     		call	Bin2HexStr
1076  6C3D E1           	pop		hl
1077  6C3E              	;Determine lenght of hex print buffer.
1078  6C3E EB           	ex		de, hl
1079  6C3F B7           	or		a
1080  6C40 ED 52        	sbc		hl, de
1081  6C42 44           	ld		b, h
1082  6C43 4D           	ld		c, l
1083  6C44 EB           	ex		de, hl
1084  6C45 18 24        	jr		ViewFileText
1085  6C47
1086  6C47
1087  6C47              ViewFileAsBASIC:
1088  6C47 06 18        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioBASIC		;Load half of available RAM with program bytecode, leave half for decoded text.
1089  6C49 CD 76 6C     	call		ReadFileForViewing
1090  6C4C DD 2A 99 80  	ld		ix, (SelFileCache)
1091  6C50
1092  6C50              	;Read program length from header.
1093  6C50 DD 4E 15     	ld		c, (ix + CACHE_HDR + HDR_PLEN)
1094  6C53 DD 46 16     	ld		b, (ix + CACHE_HDR + HDR_PLEN + 1)
1095  6C56 11 DC A6     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioBASIC		;Store text of program after read block.
1096  6C59 D5           	push		de
1097  6C5A CD C6 7C     		call	BASIC2TXT
1098  6C5D D1           	pop		de
1099  6C5E              	;Get decoded text length
1100  6C5E 2A 8D 7D     	ld		hl, (DestinationAddr)
1101  6C61 3E 1A        	ld		a, CHAR_EOF
1102  6C63 77           	ld		(hl), a								;Force EOF char at end of decoded basic program.
1103  6C64 23           	inc		hl
1104  6C65 B7           	or		a
1105  6C66 ED 52        	sbc		hl, de
1106  6C68 44           	ld		b, h
1107  6C69 4D           	ld		c, l
1108  6C6A EB           	ex		de, hl
1109  6C6B
1110  6C6B              ViewFileText:
1111  6C6B E5           	push	hl
1112  6C6C C5           	push	bc
1113  6C6D CD C4 77     		call	ClrScr
1114  6C70 C1           	pop	bc
1115  6C71 E1           	pop	hl
1116  6C72 CD 2B 7A     	call	TextViewer
1117  6C75 C9           	ret
1118  6C76
1119  6C76
1120  6C76              ;Reads file section, as much as it fits in RAM for the type of output.
1121  6C76              ;Returns HL=start address and BC=length read (if it didn't fit in RAM) or logical length.
1122  6C76              ;IN: B = how many sectors to read.
1123  6C76              ReadFileForViewing:
1124  6C76 21 00 00     	ld		hl, 0
1125  6C79 22 A1 80     	ld		(FilePosRead), hl
1126  6C7C 2A 99 80     	ld		hl, (SelFileCache)
1127  6C7F 3A 3E 73     	ld 		a, (RWTSDrive)
1128  6C82 3C           	inc		a
1129  6C83 CD F1 76     	call		ReadFileSection		;DE = last address read
1130  6C86
1131  6C86              	;Calculate size of read buffer.
1132  6C86 21 DC 8E     	ld	hl, FileData
1133  6C89 EB           	ex	de, hl
1134  6C8A B7           	or	a
1135  6C8B ED 52        	sbc	hl, de
1136  6C8D 44           	ld	b, h
1137  6C8E 4D           	ld	c, l
1138  6C8F
1139  6C8F              	;Check file type from header, to see if header exists or not.
1140  6C8F DD 2A 99 80  	ld		ix, (SelFileCache)
1141  6C93 DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1142  6C96 FE 04        	cp		TEXT_TYPE
1143  6C98 21 DC 8E     	ld		hl, FileData
1144  6C9B 30 14        	jr		nc, ReadFileForViewingNoHeader
1145  6C9D
1146  6C9D              	;Determine if read buffer was bigger than logical length and set BC to logical length if so (size on disk might be bigger).
1147  6C9D              	;Else, file didn't fit in RAM, keep length that was read (smaller than real file size).
1148  6C9D DD 6E 11     	ld		l, (ix + CACHE_HDR + HDR_LEN)
1149  6CA0 DD 66 12     	ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1150  6CA3 B7           	or		a
1151  6CA4 ED 42        	sbc		hl, bc
1152  6CA6 30 06        	jr		nc, ReadFileForViewingUseReadLenght
1153  6CA8
1154  6CA8 DD 4E 11     	ld		c, (ix + CACHE_HDR + HDR_LEN)
1155  6CAB DD 46 12     	ld		b, (ix + CACHE_HDR + HDR_LEN + 1)
1156  6CAE
1157  6CAE              ReadFileForViewingUseReadLenght:
1158  6CAE 21 E5 8E     	ld		hl, FileData+HDR_SZ
1159  6CB1
1160  6CB1              ReadFileForViewingNoHeader:
1161  6CB1
1162  6CB1 C9           	ret
1163  6CB2
1164  6CB2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1165  6CB2
1166  6CB2
1167  6CB2              DisplayFileInfo:
1168  6CB2 2A 99 80     	ld		hl, (SelFileCache)
1169  6CB5 E5           	push	hl
1170  6CB6              		;disk size - at least 2KB ==1  AU
1171  6CB6 01 0D 00     		ld		bc, CACHE_AU_CNT
1172  6CB9 09           		add		hl, bc
1173  6CBA 5E           		ld		e, (hl)
1174  6CBB 23           		inc		hl
1175  6CBC 56           		ld		d, (hl)
1176  6CBD 2B           		dec		hl
1177  6CBE EB           		ex		de, hl
1178  6CBF              		;*2, since one block (AU) is 2KB.
1179  6CBF CB 15        		rl	l
1180  6CC1 CB 14        		rl	h
1181  6CC3
1182  6CC3 11 94 7E     		ld		de, MsgFileSzDskN
1183  6CC6 CD 6E 6E     		call	Word2Txt
1184  6CC9 21 8B 7E     		ld		hl, MsgFileSzDsk
1185  6CCC 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1186  6CCF CD E4 77     		call	PrintStr
1187  6CD2 E1           	pop		hl
1188  6CD3 E5           	push	hl
1189  6CD4              		;attributes
1190  6CD4 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1191  6CD7 09           		add		hl, bc
1192  6CD8 EB           		ex		de, hl
1193  6CD9 21 A4 7E     		ld		hl, MsgFileAttrN
1194  6CDC 1A           		ld		a, (de)
1195  6CDD E6 80        		and		%10000000
1196  6CDF 28 10        		jr		z, NotRO
1197  6CE1
1198  6CE1 01 52 2F     		ld		bc, '/R'
1199  6CE4 71           		ld		(hl), c
1200  6CE5 23           		inc		hl
1201  6CE6 70           		ld		(hl), b
1202  6CE7 23           		inc		hl
1203  6CE8 01 4F 2C     		ld		bc, ',O'
1204  6CEB 71           		ld		(hl), c
1205  6CEC 23           		inc		hl
1206  6CED 70           		ld		(hl), b
1207  6CEE 23           		inc		hl
1208  6CEF 18 0E        		jr		CheckSys
1209  6CF1              NotRO:
1210  6CF1 01 2D 2D     		ld		bc, '--'
1211  6CF4 71           		ld		(hl), c
1212  6CF5 23           		inc		hl
1213  6CF6 70           		ld		(hl), b
1214  6CF7 23           		inc		hl
1215  6CF8 01 2D 2C     		ld		bc, ',-'
1216  6CFB 71           		ld		(hl), c
1217  6CFC 23           		inc		hl
1218  6CFD 70           		ld		(hl), b
1219  6CFE 23           		inc		hl
1220  6CFF
1221  6CFF              CheckSys:
1222  6CFF 13           		inc		de
1223  6D00 1A           		ld		a, (de)
1224  6D01 E6 80        		and		%10000000
1225  6D03 28 0C        		jr		z, NotSYS
1226  6D05
1227  6D05 01 48 49     		ld		bc, 'IH'
1228  6D08 71           		ld		(hl), c
1229  6D09 23           		inc		hl
1230  6D0A 70           		ld		(hl), b
1231  6D0B 23           		inc		hl
1232  6D0C 3E C4        		ld		a, 'D' + $80
1233  6D0E 77           		ld		(hl), a
1234  6D0F 18 0A        		jr		AttrEnd
1235  6D11              NotSYS:
1236  6D11 01 2D 2D     		ld		bc, '--'
1237  6D14 71           		ld		(hl), c
1238  6D15 23           		inc		hl
1239  6D16 70           		ld		(hl), b
1240  6D17 23           		inc		hl
1241  6D18 3E AD        		ld		a, '-' + $80
1242  6D1A 77           		ld		(hl), a
1243  6D1B              AttrEnd:
1244  6D1B 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1245  6D1E 21 9B 7E     		ld		hl, MsgFileAttr
1246  6D21 CD E4 77     		call	PrintStr
1247  6D24 DD E1        	pop		ix
1248  6D26 DD E5        	push	ix
1249  6D28 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1250  6D2B B7           		or		a
1251  6D2C CA C9 6D             jp		z, HeadNotRead
1252  6D2F
1253  6D2F DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1254  6D32 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1255  6D35 CA C9 6D             jp		z, HeadNotRead
1256  6D38
1257  6D38 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1258  6D3B FE 00        		cp		PROG_TYPE
1259  6D3D 20 0B        		jr		nz, CheckNoArr
1260  6D3F
1261  6D3F 21 BE 7E     		ld		hl, MsgFileTypePrg
1262  6D42 11 B4 7E     		ld		de, MsgFileTypeN
1263  6D45 CD 12 6E     		call	MoveMsg
1264  6D48 18 4F        		jr		PrepFileLen
1265  6D4A
1266  6D4A              CheckNoArr:
1267  6D4A FE 01        		cp		NUMB_TYPE
1268  6D4C 20 0B        		jr		nz, CheckChrArr
1269  6D4E
1270  6D4E 21 DA 7E     		ld		hl, MsgFileTypeNoA
1271  6D51 11 B4 7E     		ld		de, MsgFileTypeN
1272  6D54 CD 12 6E     		call	MoveMsg
1273  6D57 18 40        		jr		PrepFileLen
1274  6D59
1275  6D59              CheckChrArr:
1276  6D59 FE 02        		cp		CHAR_TYPE
1277  6D5B 20 0B        		jr		nz, CheckByte
1278  6D5D
1279  6D5D 21 D3 7E     		ld		hl, MsgFileTypeChrA
1280  6D60 11 B4 7E     		ld		de, MsgFileTypeN
1281  6D63 CD 12 6E     		call	MoveMsg
1282  6D66 18 31        		jr		PrepFileLen
1283  6D68
1284  6D68              CheckByte:
1285  6D68 FE 03        		cp		BYTE_TYPE
1286  6D6A 20 24        		jr		nz, CheckText
1287  6D6C
1288  6D6C DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1289  6D6F DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1290  6D72 01 00 E5     		ld		bc, -SCR_LEN
1291  6D75 09           		add		hl, bc
1292  6D76 7C           		ld		a, h
1293  6D77 B5           		or		l
1294  6D78 20 0B        		jr		nz, NotScr
1295  6D7A
1296  6D7A 21 CC 7E     		ld		hl, MsgFileTypeSCR
1297  6D7D 11 B4 7E     		ld		de, MsgFileTypeN
1298  6D80 CD 12 6E     		call	MoveMsg
1299  6D83 18 14        		jr		PrepFileLen
1300  6D85              NotScr:
1301  6D85 21 C5 7E     		ld		hl, MsgFileTypeByte
1302  6D88 11 B4 7E     		ld		de, MsgFileTypeN
1303  6D8B CD 12 6E     		call	MoveMsg
1304  6D8E 18 09        		jr		PrepFileLen
1305  6D90
1306  6D90              CheckText:
1307  6D90 21 E1 7E     		ld		hl, MsgFileTypeText
1308  6D93 11 B4 7E     		ld		de, MsgFileTypeN
1309  6D96 CD 12 6E     		call	MoveMsg
1310  6D99
1311  6D99              PrepFileLen:
1312  6D99              		;File len
1313  6D99 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1314  6D9C DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1315  6D9F              PrepFileLenText:
1316  6D9F 11 F8 7E     		ld		de, MsgFileLenN
1317  6DA2 CD 6E 6E     		call	Word2Txt
1318  6DA5 26 C2        		ld		h, 'B' | $80
1319  6DA7 2E 20        		ld		l, ' '
1320  6DA9 22 FD 7E     		ld		(MsgFileLenN + 5), hl
1321  6DAC
1322  6DAC DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1323  6DAF FE 00        		cp		PROG_TYPE
1324  6DB1 28 06        		jr		z, PrintProgStart
1325  6DB3
1326  6DB3 FE 03        		cp		BYTE_TYPE
1327  6DB5 28 0A        		jr		z, PrintByteStart
1328  6DB7
1329  6DB7 18 22        		jr		PrintStartNotRead
1330  6DB9
1331  6DB9              PrintProgStart:
1332  6DB9 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1333  6DBC DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1334  6DBF 18 25        		jr		PrintStart
1335  6DC1
1336  6DC1              PrintByteStart:
1337  6DC1 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1338  6DC4 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1339  6DC7 18 1D        		jr		PrintStart
1340  6DC9
1341  6DC9              HeadNotRead:
1342  6DC9 21 E8 7E             ld        hl, MsgNA
1343  6DCC 11 B4 7E             ld        de, MsgFileTypeN
1344  6DCF CD 12 6E             call    MoveMsg
1345  6DD2
1346  6DD2 21 E8 7E     		ld		hl, MsgNA
1347  6DD5 11 F8 7E     		ld		de, MsgFileLenN
1348  6DD8 CD 12 6E     		call	MoveMsg
1349  6DDB
1350  6DDB              PrintStartNotRead:
1351  6DDB 21 E8 7E     		ld		hl, MsgNA
1352  6DDE 11 08 7F     		ld		de, MsgFileStartN
1353  6DE1 CD 12 6E     		call	MoveMsg
1354  6DE4 18 0E        		jr		PrintStartStr
1355  6DE6
1356  6DE6              PrintStart:
1357  6DE6 1E 20        	ld		e, ' '
1358  6DE8 16 A0        	ld		d, ' ' | $80
1359  6DEA ED 53 0D 7F  	ld		(MsgFileStartN + 5), de
1360  6DEE 11 08 7F     	ld		de, MsgFileStartN
1361  6DF1 CD 6E 6E     	call	Word2Txt
1362  6DF4              PrintStartStr:
1363  6DF4 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1364  6DF7 21 FF 7E     	ld		hl, MsgFileStart
1365  6DFA CD E4 77     	call	PrintStr
1366  6DFD
1367  6DFD DD E1        	pop		ix
1368  6DFF 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1369  6E02 21 AB 7E     	ld		hl, MsgFileType
1370  6E05 CD E4 77     	call	PrintStr
1371  6E08
1372  6E08 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1373  6E0B 21 EF 7E     	ld		hl, MsgFileLen
1374  6E0E CD E4 77     	call	PrintStr
1375  6E11
1376  6E11 C9           	ret
1377  6E12
1378  6E12              MoveMsg:
1379  6E12 01 07 00     	ld		bc, 7
1380  6E15 ED B0        	ldir
1381  6E17 C9           	ret
1382  6E18
1383  6E18              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1384  6E18
1385  6E18              ReadAllHeaders:
1386  6E18 21 0F 7F     	ld		hl, MsgReadingExt
1387  6E1B 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1388  6E1E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1389  6E20 CD 0C 78     	call	PrintStrClr
1390  6E23
1391  6E23 CD 33 67     	call	CalcFileCache
1392  6E26
1393  6E26 3A 92 80     	ld		a, (SelFile)
1394  6E29 47           	ld		b, a
1395  6E2A 3A 90 80     	ld		a, (FileCnt)
1396  6E2D 90           	sub		b
1397  6E2E B7           	or		a
1398  6E2F C8           	ret		z
1399  6E30
1400  6E30 47           	ld		b, a
1401  6E31
1402  6E31 DD 2A 99 80  	ld		ix, (SelFileCache)
1403  6E35              NextFile:
1404  6E35 C5           	push	bc
1405  6E36 CD 8C 72     		call	ReadFileHeader
1406  6E39 01 19 00     		ld		bc, CACHE_SZ
1407  6E3C DD 09        		add		ix, bc
1408  6E3E DD E5        		push	ix
1409  6E40 CD 33 67     			call	CalcFileCache
1410  6E43 CD B2 6C     			call	DisplayFileInfo
1411  6E46 DD E1        		pop		ix
1412  6E48
1413  6E48 CD AB 77     		call	KbdHit
1414  6E4B 38 03        		jr		c, AKey
1415  6E4D C1           	pop		bc
1416  6E4E 18 15        	jr		ReadAllHeadersEnd
1417  6E50
1418  6E50              AKey:
1419  6E50 3A 92 80     		ld		a, (SelFile)
1420  6E53 3C           		inc		a
1421  6E54 47           		ld		b, a
1422  6E55 3A 90 80     		ld		a, (FileCnt)
1423  6E58 B8           		cp		b
1424  6E59 28 10        		jr		z, DontInc
1425  6E5B 78           		ld		a, b
1426  6E5C 32 92 80     		ld		(SelFile), a
1427  6E5F CD D8 78     		call	MoveCursor
1428  6E62 C1           	pop		bc
1429  6E63 10 D0        	djnz	NextFile
1430  6E65
1431  6E65              ReadAllHeadersEnd:
1432  6E65 06 01        	ld		b, 1
1433  6E67 CD 90 79     	call	ClearNMsgLines
1434  6E6A C9           	ret
1435  6E6B
1436  6E6B              DontInc:
1437  6E6B C1           	pop		bc
1438  6E6C 18 F7        	jr		ReadAllHeadersEnd
1439  6E6E
1440  6E6E
1441  6E6E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1442  6E6E
1443  6E6E              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6E6E              	ifndef	_HCCFG_
   2+ 6E6E              	define	_HCCFG_
   3+ 6E6E
   4+ 6E6E              ;HC specific code, for configuration
   5+ 6E6E
   6+ 6E6E              HC_CFG_PORT			EQU	$7E
   7+ 6E6E              HC_FLOPPY_PORT		EQU 7
   8+ 6E6E
   9+ 6E6E              ;BASIC/CPM ROM selection
  10+ 6E6E              HC_CFG_ROM_BAS		EQU	%0
  11+ 6E6E              HC_CFG_ROM_CPM		EQU	%1
  12+ 6E6E
  13+ 6E6E              ;Address for ROM paging: 0 or $E000
  14+ 6E6E              HC_CFG_ROM_0000		EQU %00
  15+ 6E6E              HC_CFG_ROM_E000		EQU %10
  16+ 6E6E
  17+ 6E6E              ;Cfg. port Enable/Disable
  18+ 6E6E              HC_CFG_PORT_DIS		EQU %000
  19+ 6E6E              HC_CFG_PORT_EN		EQU	%100
  20+ 6E6E
  21+ 6E6E              ;Video memory bank: $4000 or $C000
  22+ 6E6E              HC_CFG_VID_4000		EQU	%0000
  23+ 6E6E              HC_CFG_VID_C000		EQU	%1000
  24+ 6E6E
  25+ 6E6E
  26+ 6E6E              ;Standar BASIC config
  27+ 6E6E              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 6E6E              ;Standar CP/M config
  29+ 6E6E              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 6E6E
  31+ 6E6E
  32+ 6E6E              HC_VID_BANK0		EQU	$4000
  33+ 6E6E              HC_VID_BANK1		EQU	$C000
  34+ 6E6E
  35+ 6E6E              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 6E6E              ;Info from Rares Atodiresei.
  37+ 6E6E              IsDrive2_80Tracks:
  38+ 6E6E              	IFUSED
  39+ 6E6E ~            	in	a, (HC_FLOPPY_PORT)
  40+ 6E6E ~            	and %10
  41+ 6E6E ~            	ret
  42+ 6E6E              	ENDIF
  43+ 6E6E
  44+ 6E6E              	endif
# file closed: hccfg.asm
1444  6E6E              	include "if1.asm"
# file opened: if1.asm
   1+ 6E6E              ;HC IF1 routines and constants
   2+ 6E6E
   3+ 6E6E              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6E6E              ;12 = Writing to a 'read' file
   5+ 6E6E              ;13 = Reading a 'write' file
   6+ 6E6E              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6E6E              ;15 = Disk full (disk or catalog full)
   8+ 6E6E              ;16 = Disk error (hardware error)
   9+ 6E6E              ;17 = File not found
  10+ 6E6E              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6E6E              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6E6E
  13+ 6E6E              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6E6E              ;00h = OK
  15+ 6E6E              ;08h = cannot format disk
  16+ 6E6E              ;10h = disk protected (read-only?)
  17+ 6E6E              ;20h = volume error
  18+ 6E6E              ;40h = drive error
  19+ 6E6E              ;80h = reading error
  20+ 6E6E              ;Codes I encountered:
  21+ 6E6E              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6E6E
  23+ 6E6E
  24+ 6E6E              	ifndef	_DISK_
  25+ 6E6E              	define	_DISK_
  26+ 6E6E
  27+ 6E6E              	include	"math.asm"
# file opened: math.asm
   1++6E6E              	ifndef	_MATH_
   2++6E6E              	define	_MATH_
   3++6E6E
   4++6E6E              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6E6E              ;http://map.tni.nl/sources/external/z80bits.html
   6++6E6E
   7++6E6E
   8++6E6E              Word2Txt:
   9++6E6E              	IFUSED
  10++6E6E D5           	push	de
  11++6E6F CD 8F 6E     		call	Word2Txt_
  12++6E72 D1           	pop		de
  13++6E73
  14++6E73 06 04        	ld		b, 4
  15++6E75 CD 84 6E     	call	StrippLeading0
  16++6E78 C9           	ret
  17++6E79
  18++6E79              Byte2Txt:
  19++6E79 D5           	push	de
  20++6E7A CD 9B 6E     		call	Byte2Txt_
  21++6E7D D1           	pop		de
  22++6E7E
  23++6E7E 06 02        	ld		b, 2
  24++6E80 CD 84 6E     	call	StrippLeading0
  25++6E83 C9           	ret
  26++6E84              	ENDIF
  27++6E84
  28++6E84
  29++6E84              StrippLeading0:
  30++6E84 1A           	ld		a, (de)
  31++6E85 FE 31        	cp		'1'
  32++6E87 D0           	ret		nc
  33++6E88
  34++6E88 3E 20        	ld		a, ' '
  35++6E8A 12           	ld		(de), a
  36++6E8B 13           	inc		de
  37++6E8C 10 F6        	djnz	StrippLeading0
  38++6E8E C9           	ret
  39++6E8F
  40++6E8F
  41++6E8F              ;Converts the number in HL to ASCII in decimal string at DE
  42++6E8F              Word2Txt_:
  43++6E8F 01 F0 D8     	ld bc, -10000
  44++6E92 CD AA 6E     	call DigitLoop
  45++6E95 01 18 FC     	ld bc, -1000
  46++6E98 CD AA 6E     	call DigitLoop
  47++6E9B              Byte2Txt_:
  48++6E9B 01 9C FF     	ld bc, -100
  49++6E9E CD AA 6E     	call DigitLoop
  50++6EA1 01 F6 FF     	ld bc, -10
  51++6EA4 CD AA 6E     	call DigitLoop
  52++6EA7 01 FF FF     	ld bc, -1
  53++6EAA
  54++6EAA              DigitLoop:
  55++6EAA 3E 2F        	ld	a, '0' - 1
  56++6EAC              DivNrLoop:
  57++6EAC 3C           	inc	a			;increase reminder
  58++6EAD 09           	add	hl, bc		;substract divizor
  59++6EAE 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6EB0 ED 42        	sbc	hl, bc		;nope, restore
  61++6EB2
  62++6EB2 12           	ld (de), a
  63++6EB3 13           	inc de
  64++6EB4 C9           	ret
  65++6EB5
  66++6EB5
  67++6EB5              ;Input: HL = Dividend, C = Divisor
  68++6EB5              ;Output: HL = Quotient, A = Remainder
  69++6EB5              ;Warning: doesn't work with divisor >= $80
  70++6EB5              Div:
  71++6EB5              	IFUSED
  72++6EB5 AF           	xor a
  73++6EB6 06 10        	ld b, 16
  74++6EB8
  75++6EB8              DivLoop:
  76++6EB8 29           	add	hl,hl
  77++6EB9 17           	rla
  78++6EBA B9           	cp	c
  79++6EBB 38 02        	jr	c, NoSub
  80++6EBD 91           	sub	c
  81++6EBE 2C           	inc	l
  82++6EBF              NoSub:
  83++6EBF 10 F7        	djnz DivLoop
  84++6EC1
  85++6EC1 C9           	ret
  86++6EC2              	ENDIF
  87++6EC2
  88++6EC2              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6EC2              ;Output: A:C = Quotient, HL = Remainder
  90++6EC2              Div2:
  91++6EC2 21 00 00     	ld hl, 0
  92++6EC5 06 10        	ld b, 16
  93++6EC7              Div2Loop:
  94++6EC7 CB 31        	sll c		; unroll 16 times
  95++6EC9 17           	rla			; ...
  96++6ECA ED 6A        	adc	hl,hl		; ...
  97++6ECC ED 52        	sbc	hl,de		; ...
  98++6ECE 30 02        	jr	nc,$+4		; ...
  99++6ED0 19           	add	hl,de		; ...
 100++6ED1 0D           	dec	c		; ...
 101++6ED2 10 F3        	djnz Div2Loop
 102++6ED4 C9           	ret
 103++6ED5
 104++6ED5
 105++6ED5              ;Input: A = Multiplier, DE = Multiplicand
 106++6ED5              ;Output: A:HL = Product
 107++6ED5              Mul:
 108++6ED5              	IFUSED
 109++6ED5 21 00 00     	ld hl, 0
 110++6ED8 01 00 07     	ld bc, $0700
 111++6EDB
 112++6EDB 87           	add	a, a		; optimised 1st iteration
 113++6EDC 30 02        	jr	nc, MulLoop
 114++6EDE 62           	ld	h, d
 115++6EDF 6B           	ld	l, e
 116++6EE0
 117++6EE0              MulLoop:
 118++6EE0 29           	add	hl,hl
 119++6EE1 17           	rla
 120++6EE2 30 02        	jr	nc, NoAdd
 121++6EE4 19           	add	hl,de
 122++6EE5 89           	adc	a,c
 123++6EE6              NoAdd:
 124++6EE6 10 F8        	djnz MulLoop
 125++6EE8
 126++6EE8 C9           	ret
 127++6EE9              	ENDIF
 128++6EE9
 129++6EE9
 130++6EE9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++6EE9              ;IN: HL=address to read, DE=output address	for 2 chars
 132++6EE9              Byte2Hex:
 133++6EE9 AF           	xor	a
 134++6EEA ED 6F        	rld
 135++6EEC CD EF 6E     	call	Byte2HexNibble
 136++6EEF
 137++6EEF              Byte2HexNibble:
 138++6EEF F5           	push	af
 139++6EF0 27           	daa
 140++6EF1 C6 F0        	add		a,$F0
 141++6EF3 CE 40        	adc		a,$40
 142++6EF5
 143++6EF5 12           	ld		(de), a
 144++6EF6 13           	inc		de
 145++6EF7
 146++6EF7 F1           	pop		af
 147++6EF8 ED 6F        	rld
 148++6EFA C9           	ret
 149++6EFB
 150++6EFB
 151++6EFB              Byte2HexHex:
 152++6EFB CD E9 6E     	call	Byte2Hex
 153++6EFE 23           	inc		hl
 154++6EFF 3E 20        	ld		a, ' '
 155++6F01 12           	ld		(de), a
 156++6F02 13           	inc		de
 157++6F03 C9           	ret
 158++6F04
 159++6F04              Byte2HexChar:
 160++6F04 3E 0D        	ld		a, CHAR_CR
 161++6F06 BE           	cp		(hl)
 162++6F07 28 05        	jr		z, Bin2HexLineLoopTextReplace
 163++6F09
 164++6F09 3E 1A        	ld		a, CHAR_EOF
 165++6F0B BE           	cp		(hl)
 166++6F0C 20 03        	jr		nz, Bin2HexLineLoopTextCopy
 167++6F0E
 168++6F0E              Bin2HexLineLoopTextReplace:
 169++6F0E 3E 2E        	ld		a, '.'
 170++6F10 77           	ld		(hl), a
 171++6F11
 172++6F11              Bin2HexLineLoopTextCopy:
 173++6F11 ED A0        	ldi
 174++6F13 C9           	ret
 175++6F14
 176++6F14
 177++6F14              HEX_COLUMNS	EQU	16
 178++6F14
 179++6F14              Bin2HexLine:
 180++6F14              	;Hex part
 181++6F14 06 10        	ld		b, HEX_COLUMNS
 182++6F16 E5           	push	hl
 183++6F17              Bin2HexLineLoopHex:
 184++6F17 CD FB 6E     		call	Byte2HexHex
 185++6F1A
 186++6F1A              		;Put separator in the middle of hex line.
 187++6F1A 3E 09        		ld		a, HEX_COLUMNS/2+1
 188++6F1C B8           		cp		b
 189++6F1D 20 05        		jr		nz, Bin2HexLineLoopHexNotHalf
 190++6F1F 1B           		dec		de
 191++6F20 3E 2D        		ld		a, '-'
 192++6F22 12           		ld		(de), a
 193++6F23 13           		inc		de
 194++6F24
 195++6F24              Bin2HexLineLoopHexNotHalf:
 196++6F24 10 F1        		djnz	Bin2HexLineLoopHex
 197++6F26 E1           	pop		hl
 198++6F27
 199++6F27 1B           	dec		de
 200++6F28 3E 7C        	ld		a, '|'
 201++6F2A 12           	ld		(de), a
 202++6F2B 13           	inc		de
 203++6F2C
 204++6F2C              	;String part
 205++6F2C              	;Ignore CR & EOF
 206++6F2C              Bin2HexLineText:
 207++6F2C              	;just to not alter B with LDI, set C to something > 16
 208++6F2C 01 20 10     	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209++6F2F              Bin2HexLineLoopText:
 210++6F2F CD 04 6F     	call	Byte2HexChar
 211++6F32 10 FB        	djnz	Bin2HexLineLoopText
 212++6F34 C9           	ret
 213++6F35
 214++6F35
 215++6F35              ;Converts binary buffer at HL to hex string at DE
 216++6F35              Bin2HexStr:
 217++6F35              	;Calculate the number of full lines by dividing BC to 16.
 218++6F35 AF           	xor		a
 219++6F36
 220++6F36 CB 18        	rr		b
 221++6F38 CB 19        	rr		c
 222++6F3A 1F           	rra
 223++6F3B
 224++6F3B CB 18        	rr		b
 225++6F3D CB 19        	rr		c
 226++6F3F 1F           	rra
 227++6F40
 228++6F40 CB 18        	rr		b
 229++6F42 CB 19        	rr		c
 230++6F44 1F           	rra
 231++6F45
 232++6F45 CB 18        	rr		b
 233++6F47 CB 19        	rr		c
 234++6F49 1F           	rra
 235++6F4A
 236++6F4A 1F           	rra
 237++6F4B 1F           	rra
 238++6F4C 1F           	rra
 239++6F4D 1F           	rra
 240++6F4E
 241++6F4E 08           	ex		af, af'			;Keep reminder
 242++6F4F
 243++6F4F              Bin2HexStrLoop:
 244++6F4F C5           	push	bc
 245++6F50 CD 14 6F     		call	Bin2HexLine
 246++6F53 C1           	pop		bc
 247++6F54
 248++6F54 0B           	dec		bc
 249++6F55 78           	ld		a, b
 250++6F56 B1           	or		c
 251++6F57 20 F6        	jr		nz, Bin2HexStrLoop
 252++6F59
 253++6F59              	;Set remaining imcomplete line.
 254++6F59 D5           	push	de
 255++6F5A E5           	push	hl
 256++6F5B 3E 20        		ld		a, ' '
 257++6F5D 06 40        		ld		b, COL_CNT
 258++6F5F              Bin2HexLineClear:
 259++6F5F 12           		ld		(de), a
 260++6F60 13           		inc		de
 261++6F61 10 FC        		djnz	Bin2HexLineClear
 262++6F63 E1           	pop		hl
 263++6F64 D1           	pop		de
 264++6F65
 265++6F65 D5           	push	de
 266++6F66 DD E1        	pop		ix
 267++6F68 01 30 00     	ld		bc, HEX_COLUMNS*3
 268++6F6B DD 09        	add		ix, bc
 269++6F6D
 270++6F6D              	;Write hex and char part
 271++6F6D 08           	ex		af, af'
 272++6F6E B7           	or		a
 273++6F6F C8           	ret		z
 274++6F70
 275++6F70 47           	ld		b, a
 276++6F71 0E 20        	ld		c, HEX_COLUMNS*2
 277++6F73
 278++6F73              Bin2HexLineLoopHex2:
 279++6F73 CD FB 6E     	call	Byte2HexHex
 280++6F76 2B           	dec		hl
 281++6F77
 282++6F77 D5           	push	de
 283++6F78 DD 5D        		ld		e, ixl
 284++6F7A DD 54        		ld		d, ixh
 285++6F7C CD 04 6F     		call	Byte2HexChar
 286++6F7F D1           	pop		de
 287++6F80 DD 23        	inc		ix
 288++6F82 10 EF        	djnz	Bin2HexLineLoopHex2
 289++6F84
 290++6F84 C9           	ret
 291++6F85
 292++6F85              	endif
# file closed: math.asm
  28+ 6F85
  29+ 6F85              DRIVE_CUR_BAS	EQU 0
  30+ 6F85              DRIVE_A_BAS		EQU	1
  31+ 6F85              DRIVE_B_BAS		EQU	2
  32+ 6F85              DRIVE_A_CPM		EQU	0
  33+ 6F85              DRIVE_B_CPM		EQU	1
  34+ 6F85              ;Disk geometry stuff
  35+ 6F85              SPT				EQU	16			;sectors per track
  36+ 6F85              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6F85              TRACK_CNT		EQU	80			;track count
  38+ 6F85              HEAD_CNT		EQU	2			;disk face count
  39+ 6F85              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6F85              EXT_SZ			EQU	32			;directory entry size
  41+ 6F85              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6F85              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6F85              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6F85              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6F85              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6F85              REC_SZ			EQU 128			;cp/m record size
  47+ 6F85              DEL_MARKER		EQU	$E5
  48+ 6F85
  49+ 6F85
  50+ 6F85              ;Extension structure (directory entry)
  51+ 6F85              EXT_DEL_FLAG	EQU	0
  52+ 6F85              EXT_NAME		EQU 1
  53+ 6F85              EXT_IDX			EQU 12
  54+ 6F85              EXT_S1			EQU 13
  55+ 6F85              EXT_S2			EQU 14
  56+ 6F85              EXT_RC			EQU	15
  57+ 6F85              EXT_AU0			EQU	16
  58+ 6F85              EXT_AU1			EQU	18
  59+ 6F85              EXT_AU2			EQU	20
  60+ 6F85              EXT_AU3			EQU	22
  61+ 6F85              EXT_AU4			EQU	24
  62+ 6F85              EXT_AU5			EQU	26
  63+ 6F85              EXT_AU6			EQU	28
  64+ 6F85              EXT_AU7			EQU	30
  65+ 6F85              EXT_SIZE		EQU 32
  66+ 6F85
  67+ 6F85              ;FCB structure
  68+ 6F85              FCB_DRIVE		EQU 0
  69+ 6F85              FCB_NAME		EQU EXT_NAME
  70+ 6F85              FCB_EX_IDX		EQU EXT_IDX
  71+ 6F85              FCB_S1			EQU EXT_S1
  72+ 6F85              FCB_S2			EQU EXT_S2
  73+ 6F85              FCB_RC			EQU	EXT_RC
  74+ 6F85              FCB_AU			EQU	EXT_AU0
  75+ 6F85              FCB_CR			EQU	32
  76+ 6F85              FCB_R0			EQU 33
  77+ 6F85              FCB_R1			EQU 34
  78+ 6F85              FCB_R2			EQU 35
  79+ 6F85              FCB_SIZE		EQU 36
  80+ 6F85
  81+ 6F85
  82+ 6F85
  83+ 6F85              ;System variables for disk
  84+ 6F85              DSTR1			EQU	$5CD6		;drive
  85+ 6F85              FSTR1			EQU	$5CDC		;file name
  86+ 6F85              NSTR1			EQU	$5CDA		;name length
  87+ 6F85              HD11			EQU	$5CED		;BDOS argument
  88+ 6F85              COPIES			EQU	$5CEF		;BDOS function
  89+ 6F85
  90+ 6F85              ERRSP			EQU $5C3D
  91+ 6F85              ERRNR			EQU $5C3A
  92+ 6F85              ERRMSG			EQU	$0260
  93+ 6F85
  94+ 6F85              PROG			EQU $5C53
  95+ 6F85              VARS			EQU	$5C4B
  96+ 6F85              STKEND			EQU	$5C65
  97+ 6F85
  98+ 6F85              PRN_BUF			EQU	23296
  99+ 6F85
 100+ 6F85              REPDEL			EQU	23561
 101+ 6F85              REPPER			EQU	23562
 102+ 6F85              PIP				EQU	23609
 103+ 6F85
 104+ 6F85
 105+ 6F85              ;RWTS routine commands
 106+ 6F85              RWTS_CMD_SEEK	EQU	0			;position head
 107+ 6F85              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6F85              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6F85              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6F85
 111+ 6F85
 112+ 6F85              ;File name stuff
 113+ 6F85              NAMELEN			EQU	11			;name length
 114+ 6F85              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6F85              SYS_POS			EQU	9			;system attribute position in name
 116+ 6F85
 117+ 6F85              ;File types (first byte in header)
 118+ 6F85              PROG_TYPE		EQU	0			;program
 119+ 6F85              NUMB_TYPE		EQU	1			;number array
 120+ 6F85              CHAR_TYPE		EQU	2			;char array
 121+ 6F85              BYTE_TYPE		EQU	3			;bytes
 122+ 6F85              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6F85
 124+ 6F85              ;File header offsets
 125+ 6F85              HDR_TYPE		EQU	0
 126+ 6F85              HDR_LEN			EQU 1
 127+ 6F85              HDR_ADDR		EQU 3
 128+ 6F85              HDR_PLEN		EQU	5
 129+ 6F85              HDR_LINE		EQU 7
 130+ 6F85              HDR_SZ			EQU	9
 131+ 6F85
 132+ 6F85              ;BASIC disk channel structure
 133+ 6F85              CH_RW_FLAG		EQU 11
 134+ 6F85              CH_FCB			EQU	12
 135+ 6F85              CH_DATA			EQU	50
 136+ 6F85              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6F85
 138+ 6F85              CACHE_NAME		EQU	0					;11B
 139+ 6F85              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6F85              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6F85              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6F85              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6F85              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6F85
 145+ 6F85              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6F85
 147+ 6F85              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6F85              IF1Init:
 149+ 6F85 CF           	rst		08
 150+ 6F86 31           	defb	49		;create system variables
 151+ 6F87 C9           	ret
 152+ 6F88
 153+ 6F88              ;ReadWriteTrackSector
 154+ 6F88              ;A=command: 0, 1, 2, 4
 155+ 6F88              RWTS:
 156+ 6F88 32 48 73     	ld (RWTSCmd), a
 157+ 6F8B 21 3D 73     	ld hl, RWTSParams
 158+ 6F8E 22 ED 5C     	ld (HD11), hl
 159+ 6F91 CF           	rst 08
 160+ 6F92 3A           	DEFB 58
 161+ 6F93 C9           	ret
 162+ 6F94
 163+ 6F94
 164+ 6F94              ;D = sector, E = track
 165+ 6F94              ;HL = dma
 166+ 6F94              ReadOneDiskSector:
 167+ 6F94 22 42 73     	ld (RWTSDMA), hl
 168+ 6F97 ED 53 40 73  	ld (RWTSTrack), de
 169+ 6F9B              	;ld (RWTSDrive), a
 170+ 6F9B 3E 01        	ld a, RWTS_CMD_READ
 171+ 6F9D 18 E9        	jr	RWTS
 172+ 6F9F
 173+ 6F9F              ;D = sector, E = track
 174+ 6F9F              ;HL = dma
 175+ 6F9F              WriteOneDiskSector:
 176+ 6F9F 22 42 73     	ld (RWTSDMA), hl
 177+ 6FA2 ED 53 40 73  	ld (RWTSTrack), de
 178+ 6FA6              	;ld (RWTSDrive), a
 179+ 6FA6 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6FA8 18 DE        	jr	RWTS
 181+ 6FAA
 182+ 6FAA              FormatDisk:
 183+ 6FAA 21 DC 8E     	ld		hl, DataBuf
 184+ 6FAD 36 E5        	ld		(hl), DEL_MARKER
 185+ 6FAF 22 42 73     	ld 		(RWTSDMA), hl
 186+ 6FB2 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 6FB4 CD 88 6F     	call	RWTS
 188+ 6FB7 3A 49 73     	ld		a, (RWTSRes)
 189+ 6FBA C9           	ret
 190+ 6FBB
 191+ 6FBB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 6FBB
 193+ 6FBB              ;Allocation unit no. to track/sector
 194+ 6FBB              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 6FBB              ;IN:  HL=alloc. unit no.
 196+ 6FBB              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 6FBB              AU2TS:
 198+ 6FBB 0E 02        	ld c, SPT/SPAL
 199+ 6FBD CD B5 6E     	call Div					;A = sector
 200+ 6FC0 F5           	push af
 201+ 6FC1 ~            		/*
 202+ 6FC1 ~            		ld c, HEAD_CNT
 203+ 6FC1 ~            		call Div				;L = track, A = head (0 or 1)
 204+ 6FC1 ~            		*/
 205+ 6FC1 AF           		xor a
 206+ 6FC2 CB 1C        		rr h
 207+ 6FC4 CB 1D        		rr l
 208+ 6FC6 CB 1F        		rr a
 209+ 6FC8
 210+ 6FC8 4D           		ld c, l
 211+ 6FC9 06 00        		ld b, 0
 212+ 6FCB B7           		or a
 213+ 6FCC 28 02        		jr z, Track0
 214+ 6FCE 06 10        		ld b, SPT
 215+ 6FD0              Track0:
 216+ 6FD0 F1           	pop af
 217+ 6FD1 B7           	or a
 218+ 6FD2 28 02        	jr z, FirstAU
 219+ 6FD4 3E 08        	ld a, SPAL
 220+ 6FD6              FirstAU:
 221+ 6FD6 80           	add a, b
 222+ 6FD7 47           	ld  b, a
 223+ 6FD8 C9           	ret
 224+ 6FD9
 225+ 6FD9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 6FD9
 227+ 6FD9              ;Checks the allocation units number used in extension
 228+ 6FD9              ;IN:	IX = extension addr
 229+ 6FD9              ;OUT:	B = no. of allocation units used
 230+ 6FD9              ;		C = no. of records used in ext.
 231+ 6FD9              ;		HL = first alloc. unit no.
 232+ 6FD9              ;		DE = last alloc. unit no.
 233+ 6FD9              CheckExtAlloc:
 234+ 6FD9 DD E5        	push ix
 235+ 6FDB 01 0F 00     		ld bc, EXT_RC
 236+ 6FDE DD 09        		add ix, bc
 237+ 6FE0 DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 6FE3 DD 23        		inc ix
 239+ 6FE5 DD 6E 00     		ld l, (ix)
 240+ 6FE8 DD 66 01     		ld h, (ix + 1)
 241+ 6FEB 06 08        		ld b, EXT_AU_CNT
 242+ 6FED              CheckAU:
 243+ 6FED DD 7E 00     		ld a, (ix)
 244+ 6FF0 DD B6 01     		or (ix + 1)
 245+ 6FF3 28 0C        		jr z, CheckAUEnd
 246+ 6FF5 DD 5E 00     		ld e, (ix)
 247+ 6FF8 DD 56 01     		ld d, (ix + 1)
 248+ 6FFB DD 23        		inc ix
 249+ 6FFD DD 23        		inc ix
 250+ 6FFF 10 EC        		djnz CheckAU
 251+ 7001              CheckAUEnd:
 252+ 7001 3E 08        		ld a, EXT_AU_CNT
 253+ 7003 90           		sub b
 254+ 7004 47           		ld b, a
 255+ 7005 DD E1        	pop ix
 256+ 7007 C9           	ret
 257+ 7008
 258+ 7008              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 7008
 260+ 7008              ;Input: TrackBuffer
 261+ 7008              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 7008              ReadUsedBlocksList:
 263+ 7008 DD 21 DC 8E  	ld		ix, TrackBuf			;source buffer
 264+ 700C 21 F2 88     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 700F ED 4B 97 80  	ld		bc, (AUCntMaxFree)		;loop counter
 266+ 7013 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 7016 73           	ld		(hl), e
 268+ 7017 23           	inc		hl
 269+ 7018 72           	ld		(hl), d
 270+ 7019 23           	inc		hl
 271+ 701A
 272+ 701A              	;Add blocks 0 and 1 for directory
 273+ 701A 11 00 00     	ld		de, 0
 274+ 701D 73           	ld		(hl), e
 275+ 701E 23           	inc		hl
 276+ 701F 72           	ld		(hl), d
 277+ 7020 23           	inc		hl
 278+ 7021
 279+ 7021 13           	inc		de
 280+ 7022 73           	ld		(hl), e
 281+ 7023 23           	inc		hl
 282+ 7024 72           	ld		(hl), d
 283+ 7025 23           	inc		hl
 284+ 7026
 285+ 7026              ReadUsedBlocksLoop:
 286+ 7026 AF           	xor		a
 287+ 7027 DD BE 00     	cp		(ix)
 288+ 702A 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 702C
 290+ 702C DD E5        	push	ix
 291+ 702E C5           	push	bc
 292+ 702F 06 08        		ld		b, EXT_AU_CNT
 293+ 7031 11 10 00     		ld		de, EXT_AU0
 294+ 7034 DD 19        		add		ix, de
 295+ 7036
 296+ 7036              ReadUsedBlocksLoop2:
 297+ 7036 DD 5E 00     		ld		e, (ix)
 298+ 7039 DD 56 01     		ld		d, (ix+1)
 299+ 703C 7B           		ld		a, e
 300+ 703D B2           		or		d
 301+ 703E 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 7040
 303+ 7040 73           		ld		(hl), e
 304+ 7041 23           		inc		hl
 305+ 7042 72           		ld		(hl), d
 306+ 7043 23           		inc		hl
 307+ 7044
 308+ 7044 DD 23        		inc		ix
 309+ 7046 DD 23        		inc		ix
 310+ 7048
 311+ 7048 ED 5B F2 88  		ld		de, (UsedBlockListCnt)
 312+ 704C 13           		inc		de
 313+ 704D ED 53 F2 88  		ld		(UsedBlockListCnt), de
 314+ 7051
 315+ 7051 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 7053
 317+ 7053
 318+ 7053              ReadUsedBlocksSkip:
 319+ 7053 C1           	pop		bc
 320+ 7054 DD E1        	pop		ix
 321+ 7056              ReadUsedBlocksSkip2:
 322+ 7056 11 20 00     	ld		de, EXT_SZ
 323+ 7059 DD 19        	add		ix, de
 324+ 705B
 325+ 705B 0B           	dec		bc
 326+ 705C 78           	ld		a, b
 327+ 705D B1           	or		c
 328+ 705E 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 7060
 330+ 7060 C9           	ret
 331+ 7061
 332+ 7061              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 7061              ;Reads 8 sectors for an AU
 334+ 7061              ;HL = block number, DE = destination buffer
 335+ 7061              ReadFSBlock:
 336+ 7061 D5           	push	de
 337+ 7062 CD BB 6F     		call	AU2TS		;B=sector, C=track
 338+ 7065 E1           	pop		hl				;HL=dest
 339+ 7066
 340+ 7066 50           	ld		d, b
 341+ 7067 59           	ld		e, c
 342+ 7068 06 08        	ld		b, SPAL
 343+ 706A
 344+ 706A CD 49 72     	call	ReadDiskSectors
 345+ 706D C9           	ret
 346+ 706E
 347+ 706E
 348+ 706E              ;Write 8 sectors for an AU
 349+ 706E              ;HL = block number, DE = source buffer
 350+ 706E              WriteFSBlock:
 351+ 706E D5           	push	de
 352+ 706F CD BB 6F     		call	AU2TS		;B=sector, C=track
 353+ 7072 E1           	pop		hl				;HL=dest
 354+ 7073
 355+ 7073 50           	ld		d, b
 356+ 7074 59           	ld		e, c
 357+ 7075 06 08        	ld		b, SPAL
 358+ 7077
 359+ 7077 CD 5C 72     	call	WriteDiskSectors
 360+ 707A C9           	ret
 361+ 707B
 362+ 707B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 707B              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 707B              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 707B              CopyDisk:
 366+ 707B              	;Get list of used blocks in current disk, max 632 bytes
 367+ 707B CD 08 70     	call	ReadUsedBlocksList
 368+ 707E DD 21 F4 88  	ld		ix, UsedBlockListBlk
 369+ 7082
 370+ 7082              CopyDiskLoop:
 371+ 7082 2A F2 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 7085 11 D9 7F     	ld		de, MsgBlocksLeft
 373+ 7088 CD 79 6E     	call	Byte2Txt
 374+ 708B 21 D9 7F     	ld		hl, MsgBlocksLeft
 375+ 708E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 7091 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 7093 CD 0C 78     	call	PrintStrClr
 378+ 7096
 379+ 7096              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 7096 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 7099 ED 4B F2 88  	ld		bc, (UsedBlockListCnt)
 382+ 709D B7           	or		a
 383+ 709E ED 42        	sbc		hl, bc
 384+ 70A0 30 03        	jr		nc, CopyDiskLoopRead
 385+ 70A2 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 70A5
 387+ 70A5              CopyDiskLoopRead:
 388+ 70A5 41           	ld		b, c
 389+ 70A6 11 DC 8E     	ld		de, CopyDiskBuf
 390+ 70A9              	;save initial counter and initial block number array position
 391+ 70A9 C5           	push	bc
 392+ 70AA DD E5        	push	ix
 393+ 70AC
 394+ 70AC              CopyDiskLoopReadLoop:
 395+ 70AC DD 6E 00     		ld		l, (ix)
 396+ 70AF DD 66 01     		ld		h, (ix+1)
 397+ 70B2 DD 23        		inc		ix
 398+ 70B4 DD 23        		inc		ix
 399+ 70B6
 400+ 70B6 D5           		push	de
 401+ 70B7 C5           		push	bc
 402+ 70B8 CD 61 70     			call	ReadFSBlock			;Stop on error or continue?
 403+ 70BB C1           		pop		bc
 404+ 70BC D1           		pop		de
 405+ 70BD
 406+ 70BD              		;+2048
 407+ 70BD 7A           		ld		a, d
 408+ 70BE C6 08        		add		8
 409+ 70C0 57           		ld		d, a
 410+ 70C1
 411+ 70C1 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 70C3
 413+ 70C3              		;Check if selection is 1=single drive or 2=dual drive
 414+ 70C3 3A 9B 80     		ld		a, (CopySelOption)
 415+ 70C6 FE 31        		cp		'1'
 416+ 70C8 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 70CA
 418+ 70CA              		;Prompt for disk change
 419+ 70CA CD 50 74     		call	PromptDiskChangeDst
 420+ 70CD 3A 3E 73     		ld		a, (RWTSDrive)
 421+ 70D0 CD 56 73     		call	BDOSInit
 422+ 70D3 18 0A        		jr		CopyDiskReadEnd
 423+ 70D5
 424+ 70D5              CopyDiskDualDrive1:
 425+ 70D5              		;alternate drive
 426+ 70D5 3A 3E 73     		ld		a, (RWTSDrive)
 427+ 70D8 3C           		inc 	a
 428+ 70D9 EE 03        		xor		%11
 429+ 70DB 3D           		dec		a
 430+ 70DC 32 3E 73     		ld		(RWTSDrive), a
 431+ 70DF
 432+ 70DF              CopyDiskReadEnd:
 433+ 70DF              	;restore initial counter and initial block number array position
 434+ 70DF DD E1        	pop		ix
 435+ 70E1 C1           	pop		bc
 436+ 70E2 11 DC 8E     	ld		de, CopyDiskBuf
 437+ 70E5 C5           	push	bc
 438+ 70E6
 439+ 70E6              CopyDiskLoopWriteLoop:
 440+ 70E6 DD 6E 00     		ld		l, (ix)
 441+ 70E9 DD 66 01     		ld		h, (ix+1)
 442+ 70EC DD 23        		inc		ix
 443+ 70EE DD 23        		inc		ix
 444+ 70F0
 445+ 70F0 D5           		push	de
 446+ 70F1 C5           		push	bc
 447+ 70F2 CD 6E 70     			call	WriteFSBlock		;Stop on error or continue?
 448+ 70F5 C1           		pop		bc
 449+ 70F6 D1           		pop		de
 450+ 70F7
 451+ 70F7              		;+2048
 452+ 70F7 7A           		ld		a, d
 453+ 70F8 C6 08        		add		8
 454+ 70FA 57           		ld		d, a
 455+ 70FB
 456+ 70FB 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 70FD
 458+ 70FD              CopyDiskWriteEnd:
 459+ 70FD C1           	pop		bc
 460+ 70FE 48           	ld		c, b
 461+ 70FF 06 00        	ld		b, 0
 462+ 7101
 463+ 7101              	;Decrease number of blocks read by now.
 464+ 7101 2A F2 88     	ld		hl, (UsedBlockListCnt)
 465+ 7104 B7           	or		a
 466+ 7105 ED 42        	sbc		hl, bc
 467+ 7107 22 F2 88     	ld		(UsedBlockListCnt), hl
 468+ 710A
 469+ 710A 7D           	ld		a, l
 470+ 710B B4           	or		h
 471+ 710C 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 710E
 473+ 710E              	;Check if selection is 1=single drive or 2=dual drive
 474+ 710E 3A 9B 80     	ld		a, (CopySelOption)
 475+ 7111 FE 31        	cp		'1'
 476+ 7113 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 7115
 478+ 7115              	;Prompt for disk change
 479+ 7115 CD 6A 74     	call	PromptDiskChangeSrc
 480+ 7118 3A 3E 73     	ld		a, (RWTSDrive)
 481+ 711B CD 56 73     	call	BDOSInit
 482+ 711E C3 82 70     	jp		CopyDiskLoop
 483+ 7121
 484+ 7121              CopyDiskDualDrive2:
 485+ 7121              	;alternate drive again
 486+ 7121 3A 3E 73     	ld		a, (RWTSDrive)
 487+ 7124 3C           	inc		a
 488+ 7125 EE 03        	xor		%11
 489+ 7127 3D           	dec		a
 490+ 7128 32 3E 73     	ld		(RWTSDrive), a
 491+ 712B C3 82 70     	jp		CopyDiskLoop
 492+ 712E
 493+ 712E              CopyDiskEnd:
 494+ 712E 06 01        	ld		b, 1
 495+ 7130 CD 90 79     	call	ClearNMsgLines
 496+ 7133 C9           	ret
 497+ 7134
 498+ 7134              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 7134              ;Copies the current disk blocks to COM port.
 500+ 7134              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 7134              CopyDiskToCOM:
 502+ 7134              	;Get list of used blocks in current disk, max 632 bytes
 503+ 7134 CD 08 70     	call	ReadUsedBlocksList
 504+ 7137
 505+ 7137              	;Send block count and block indexes
 506+ 7137 2A F2 88     	ld		hl, (UsedBlockListCnt)
 507+ 713A 29           	add		hl, hl
 508+ 713B 23           	inc		hl
 509+ 713C 23           	inc		hl
 510+ 713D 44           	ld		b, h
 511+ 713E 4D           	ld		c, l
 512+ 713F 21 F2 88     	ld		hl, UsedBlockListCnt
 513+ 7142 CD 90 7C     	call	SERTB
 514+ 7145
 515+ 7145 DD 21 F4 88  	ld		ix, UsedBlockListBlk
 516+ 7149
 517+ 7149              CopyDiskToCOMLoop:
 518+ 7149              	;Print block count left
 519+ 7149 2A F2 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 714C 11 D9 7F     	ld		de, MsgBlocksLeft
 521+ 714F CD 79 6E     	call	Byte2Txt
 522+ 7152 21 D9 7F     	ld		hl, MsgBlocksLeft
 523+ 7155 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 7158 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 715A CD 0C 78     	call	PrintStrClr
 526+ 715D
 527+ 715D              	;Read block into buffer
 528+ 715D DD 6E 00     	ld		l, (ix)
 529+ 7160 DD 66 01     	ld		h, (ix+1)
 530+ 7163 11 DC 8E     	ld		de, CopyDiskBuf
 531+ 7166 DD E5        	push	ix
 532+ 7168 CD 61 70     		call	ReadFSBlock
 533+ 716B DD E1        	pop		ix
 534+ 716D DD 23        	inc		ix
 535+ 716F DD 23        	inc		ix
 536+ 7171
 537+ 7171              	;Send block buffer
 538+ 7171 21 DC 8E     	ld		hl, CopyDiskBuf
 539+ 7174 01 00 08     	ld		bc, AU_SZ
 540+ 7177 CD 90 7C     	call	SERTB
 541+ 717A
 542+ 717A ED 4B F2 88  	ld		bc, (UsedBlockListCnt)
 543+ 717E 0B           	dec		bc
 544+ 717F ED 43 F2 88  	ld		(UsedBlockListCnt), bc
 545+ 7183
 546+ 7183 DD E5        	push	ix
 547+ 7185 CD AB 77     		call	KbdHit
 548+ 7188 DD E1        	pop		ix
 549+ 718A D8           	ret		c
 550+ 718B
 551+ 718B 78           	ld		a, b
 552+ 718C B1           	or		c
 553+ 718D 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 718F
 555+ 718F C9           	ret
 556+ 7190
 557+ 7190              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 7190              CopyDiskFromCOM:
 559+ 7190              	;Receive block count.
 560+ 7190 21 F2 88     	ld		hl, UsedBlockListCnt
 561+ 7193 01 02 00     	ld		bc, 2
 562+ 7196 1E 00        	ld		e, 0
 563+ 7198 CD 5D 7C     	call	SERRB
 564+ 719B
 565+ 719B              	;Receive block indexes.
 566+ 719B 2A F2 88     	ld		hl, (UsedBlockListCnt)
 567+ 719E 29           	add		hl, hl
 568+ 719F 44           	ld		b, h
 569+ 71A0 4D           	ld		c, l
 570+ 71A1 21 F4 88     	ld		hl, UsedBlockListBlk
 571+ 71A4 1E 00        	ld		e, 0
 572+ 71A6 CD 5D 7C     	call	SERRB
 573+ 71A9
 574+ 71A9              	;Read each block by index and write to disk
 575+ 71A9 DD 21 F4 88  	ld		ix, UsedBlockListBlk
 576+ 71AD
 577+ 71AD              CopyDiskFromCOMLoop:
 578+ 71AD              	;Print block count left
 579+ 71AD 2A F2 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 71B0 11 D9 7F     	ld		de, MsgBlocksLeft
 581+ 71B3 CD 79 6E     	call	Byte2Txt
 582+ 71B6 21 D9 7F     	ld		hl, MsgBlocksLeft
 583+ 71B9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 71BC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 71BE CD 0C 78     	call	PrintStrClr
 586+ 71C1
 587+ 71C1              	;Read block buffer
 588+ 71C1 21 DC 8E     	ld		hl, CopyDiskBuf
 589+ 71C4 01 00 08     	ld		bc, AU_SZ
 590+ 71C7 1E 00        	ld		e, 0
 591+ 71C9 CD 5D 7C     	call	SERRB
 592+ 71CC
 593+ 71CC              	;Write block to disk
 594+ 71CC DD 6E 00     	ld		l, (ix)
 595+ 71CF DD 66 01     	ld		h, (ix+1)
 596+ 71D2 11 DC 8E     	ld		de, CopyDiskBuf
 597+ 71D5 DD E5        	push	ix
 598+ 71D7 CD 6E 70     		call	WriteFSBlock			;Stop on error or continue?
 599+ 71DA DD E1        	pop		ix
 600+ 71DC DD 23        	inc		ix
 601+ 71DE DD 23        	inc		ix
 602+ 71E0
 603+ 71E0 ED 4B F2 88  	ld		bc, (UsedBlockListCnt)
 604+ 71E4 0B           	dec		bc
 605+ 71E5 ED 43 F2 88  	ld		(UsedBlockListCnt), bc
 606+ 71E9
 607+ 71E9 DD E5        	push	ix
 608+ 71EB CD AB 77     		call	KbdHit
 609+ 71EE DD E1        	pop		ix
 610+ 71F0 D8           	ret		c
 611+ 71F1
 612+ 71F1 78           	ld		a, b
 613+ 71F2 B1           	or		c
 614+ 71F3 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 71F5 C9           	ret
 616+ 71F6
 617+ 71F6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 71F6
 619+ 71F6              ;Compare string at HL with the one at DE, max length B
 620+ 71F6              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 71F6              ;OUT: z flag, set = match, reset = mismatch
 622+ 71F6              StrCmp:
 623+ 71F6 E5           	push hl
 624+ 71F7 D5           	push de
 625+ 71F8              Compare:
 626+ 71F8 1A           		ld a, (de)
 627+ 71F9 BE           		cp (hl)
 628+ 71FA 20 04        		jr nz, MisMatch
 629+ 71FC 23           		inc hl
 630+ 71FD 13           		inc de
 631+ 71FE 10 F8        		djnz Compare
 632+ 7200              MisMatch:
 633+ 7200 D1           	pop de
 634+ 7201 E1           	pop hl
 635+ 7202 C9           	ret
 636+ 7203
 637+ 7203              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 7203
 639+ 7203              ;Read a file into a buffer, sector by sector.
 640+ 7203              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 7203              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 7203              ;In: HL = Name address, DE = buffer
 643+ 7203              IF1FileLoad:
 644+ 7203 D5           	push	de
 645+ 7204 22 DC 5C     		ld (FSTR1), hl
 646+ 7207 26 00        		ld h, 0
 647+ 7209 3A 3E 73     		ld a, (RWTSDrive)
 648+ 720C 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 720D 6F           		ld	l, a
 650+ 720E 22 D6 5C     		ld (DSTR1), hl
 651+ 7211 2E 0B        		ld l,NAMELEN
 652+ 7213 22 DA 5C     		ld (NSTR1), hl
 653+ 7216 CF           		rst 08
 654+ 7217 33           		DEFB 51			;open disk channel
 655+ 7218
 656+ 7218 CF           		rst		8
 657+ 7219 35           		defb	53		;read sector
 658+ 721A D1           	pop		de
 659+ 721B 30 27        	jr		nc, FileFree
 660+ 721D
 661+ 721D DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 7220 FE 04        	cp		TEXT_TYPE
 663+ 7222 30 12        	jr		nc, FileLoadNoHeader
 664+ 7224
 665+ 7224              FileLoadHeader:
 666+ 7224 DD E5        	push	ix
 667+ 7226 E1           	pop		hl
 668+ 7227 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 722A 09           	add		hl, bc
 670+ 722B 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 722E ED B0        	ldir
 672+ 7230
 673+ 7230              FileReadLoop:
 674+ 7230 D5           	push	de
 675+ 7231 CF           		rst		8
 676+ 7232 35           		defb	53		;read sector
 677+ 7233 D1           	pop		de
 678+ 7234 30 0E        	jr		nc, FileFree
 679+ 7236
 680+ 7236              FileLoadNoHeader:
 681+ 7236 DD E5        	push	ix
 682+ 7238 E1           	pop		hl
 683+ 7239 01 32 00     	ld		bc, CH_DATA
 684+ 723C 09           	add		hl, bc
 685+ 723D 01 00 01     	ld		bc, SECT_SZ
 686+ 7240 ED B0        	ldir
 687+ 7242 18 EC        	jr		FileReadLoop
 688+ 7244
 689+ 7244              FileFree:
 690+ 7244 D5           	push	de
 691+ 7245 CF           	rst		8
 692+ 7246 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 7247 D1           	pop		de
 694+ 7248 C9           	ret
 695+ 7249              IF1FileLoadEnd:
 696+ 7249
 697+ 7249              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 7249              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 7249              ;Out: A = error code, 0=OK
 700+ 7249              ReadDiskSectors:
 701+ 7249 C5           	push bc
 702+ 724A E5           		push hl
 703+ 724B D5           			push de
 704+ 724C CD 94 6F     				call ReadOneDiskSector
 705+ 724F D1           			pop de
 706+ 7250 E1           		pop hl
 707+ 7251
 708+ 7251 14           		inc d
 709+ 7252 24           		inc h
 710+ 7253 C1           	pop bc
 711+ 7254
 712+ 7254 3A 49 73     	ld	a, (RWTSRes)
 713+ 7257 B7           	or	a
 714+ 7258 C0           	ret nz
 715+ 7259
 716+ 7259 10 EE        	djnz ReadDiskSectors
 717+ 725B C9           	ret
 718+ 725C
 719+ 725C              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 725C              ;Out: A = error code, 0=OK
 721+ 725C              WriteDiskSectors:
 722+ 725C C5           	push bc
 723+ 725D E5           		push hl
 724+ 725E D5           			push de
 725+ 725F CD 9F 6F     				call WriteOneDiskSector
 726+ 7262 D1           			pop de
 727+ 7263 E1           		pop hl
 728+ 7264
 729+ 7264 14           		inc d
 730+ 7265 24           		inc h
 731+ 7266 C1           	pop bc
 732+ 7267
 733+ 7267 3A 49 73     	ld	a, (RWTSRes)
 734+ 726A B7           	or	a
 735+ 726B C0           	ret nz
 736+ 726C
 737+ 726C 10 EE        	djnz WriteDiskSectors
 738+ 726E C9           	ret
 739+ 726F
 740+ 726F
 741+ 726F              ;Reads disk catalog
 742+ 726F              ReadCatalogTrack:
 743+ 726F 21 DC 8E     	ld hl, TrackBuf
 744+ 7272 11 00 00     	ld de, 0
 745+ 7275 06 10        	ld b, SPT
 746+ 7277
 747+ 7277 CD 49 72     	call ReadDiskSectors
 748+ 727A C9           	ret
 749+ 727B
 750+ 727B              ;A = track
 751+ 727B              SeekTrack:
 752+ 727B              	IFUSED
 753+ 727B ~            	ld	(RWTSTrack), a
 754+ 727B ~            	ld 	a, RWTS_CMD_SEEK
 755+ 727B ~            	jp	RWTS
 756+ 727B              	ENDIF
 757+ 727B
 758+ 727B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759+ 727B
 760+ 727B              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761+ 727B              FindCache:
 762+ 727B 06 0B        	ld		b, NAMELEN
 763+ 727D CD F6 71     	call	StrCmp			;find the file to wich this extension belongs
 764+ 7280 C8           	ret		z
 765+ 7281
 766+ 7281 0D           	dec		c
 767+ 7282 20 02        	jr		nz, CacheNotFinished
 768+ 7284 B1           	or		c
 769+ 7285 C9           	ret
 770+ 7286
 771+ 7286              CacheNotFinished:
 772+ 7286 01 19 00     	ld		bc, CACHE_SZ
 773+ 7289 09           	add		hl, bc			;to the next cache line
 774+ 728A 18 EF        	jr		FindCache
 775+ 728C
 776+ 728C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777+ 728C
 778+ 728C              	;ld		ix, (SelFileCache)
 779+ 728C              ReadFileHeader:
 780+ 728C DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 781+ 728F B7           	or		a
 782+ 7290 C0           	ret		nz				;return if already read
 783+ 7291
 784+ 7291 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 785+ 7294 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 786+ 7297 7C           	ld		a, h
 787+ 7298 B5           	or		l
 788+ 7299 28 46        	jr		z, ReadHeaderEnd
 789+ 729B
 790+ 729B CD BB 6F     	call	AU2TS
 791+ 729E 50           	ld		d, b
 792+ 729F 59           	ld		e, c
 793+ 72A0 21 DC 8E     	ld		hl, DataBuf
 794+ 72A3 DD E5        	push	ix
 795+ 72A5 DD E5        	push	ix
 796+ 72A7 CD 94 6F     		call	ReadOneDiskSector
 797+ 72AA E1           	pop		hl
 798+ 72AB DD E1        	pop		ix
 799+ 72AD
 800+ 72AD E5           	push	hl
 801+ 72AE 21 DC 8E     		ld		hl, DataBuf
 802+ 72B1 CD E5 72     		call	IsFileHeaderValid
 803+ 72B4 E1           	pop		hl
 804+ 72B5 B7           	or		a
 805+ 72B6 28 14        	jr		z, ReadFileHeaderIsTextFile
 806+ 72B8
 807+ 72B8 01 10 00     	ld		bc, CACHE_HDR
 808+ 72BB 09           	add		hl, bc
 809+ 72BC EB           	ex		hl, de
 810+ 72BD 21 DC 8E     	ld		hl, DataBuf
 811+ 72C0 01 09 00     	ld		bc, HDR_SZ
 812+ 72C3 ED B0        	ldir
 813+ 72C5
 814+ 72C5              	;For text files, read file size as reported by BDOS, since we don't have a header.
 815+ 72C5 3E 03        	ld		a, BYTE_TYPE
 816+ 72C7 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 817+ 72CA 30 15        	jr		nc, ReadHeaderEnd
 818+ 72CC
 819+ 72CC              ReadFileHeaderIsTextFile:
 820+ 72CC DD E5        	push	ix
 821+ 72CE DD E5        	push	ix
 822+ 72D0 E1           	pop		hl
 823+ 72D1 CD B4 73     		call	GetFileSize
 824+ 72D4 DD E1        	pop		ix
 825+ 72D6 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 826+ 72D9 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827+ 72DC 3E 04        	ld		a, TEXT_TYPE
 828+ 72DE DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829+ 72E1
 830+ 72E1              ReadHeaderEnd:
 831+ 72E1 DD 34 0F     	inc		(ix + CACHE_FLAG)
 832+ 72E4 C9           	ret
 833+ 72E5
 834+ 72E5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835+ 72E5              ;Checks if the file header is valid. For now it checks to not have all 0s.
 836+ 72E5              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837+ 72E5              ;In: HL = header
 838+ 72E5              ;Out: A > 0 if valid
 839+ 72E5              IsFileHeaderValid:
 840+ 72E5              	IFUSED
 841+ 72E5 AF           	xor		a
 842+ 72E6 06 09        	ld		b, HDR_SZ
 843+ 72E8              IsFileHeaderValidLoop:
 844+ 72E8 B6           	or		(hl)
 845+ 72E9 23           	inc		hl
 846+ 72EA 10 FC        	djnz	IsFileHeaderValidLoop
 847+ 72EC
 848+ 72EC C9           	ret
 849+ 72ED              	ENDIF
 850+ 72ED
 851+ 72ED              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852+ 72ED
 853+ 72ED              ;IN: HL = address from IF1 to call
 854+ 72ED              IF1Call:
 855+ 72ED 22 ED 5C     	LD   (HD11), HL
 856+ 72F0 CF           	RST  8
 857+ 72F1 32           	DEFB 50
 858+ 72F2 C9           	RET
 859+ 72F3
 860+ 72F3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861+ 72F3
 862+ 72F3              ;Load a program from disk
 863+ 72F3              ;IN: HL = file name addr
 864+ 72F3              LoadProgram:
 865+ 72F3 22 DC 5C     	LD   (FSTR1), HL
 866+ 72F6 26 00        	LD   H, 0
 867+ 72F8 2E 0B        	LD   L, NAMELEN
 868+ 72FA 22 DA 5C     	LD   (NSTR1), HL
 869+ 72FD 3A 3E 73     	LD	 A, (RWTSDrive)
 870+ 7300 3C           	INC  A					;Adapt for BASIC drive number
 871+ 7301 6F           	LD   L, A
 872+ 7302 22 D6 5C     	LD   (DSTR1), HL
 873+ 7305 21 41 0A     	LD   HL, LOAD_ADDR
 874+ 7308 CD ED 72     	CALL IF1Call
 875+ 730B C9           	RET
 876+ 730C
 877+ 730C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878+ 730C
 879+ 730C              SetFastKeys:
 880+ 730C 3E 0A        	ld		a, 10
 881+ 730E 32 09 5C     	ld		(REPDEL), a
 882+ 7311 3E 01        	ld		a, 1
 883+ 7313 32 0A 5C     	ld		(REPDEL+1),a
 884+ 7316
 885+ 7316 C9           	ret
 886+ 7317
 887+ 7317
 888+ 7317              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889+ 7317              ;Reads the error message string from IF1 ROM.
 890+ 7317              GetErrMsg:
 891+ 7317 3C           	inc		a
 892+ 7318 08           	ex		af, af'
 893+ 7319
 894+ 7319 21 1F 73     	ld		hl, IF1Paged			;page-in IF1
 895+ 731C C3 ED 72     	jp		IF1Call
 896+ 731F
 897+ 731F              IF1Paged:
 898+ 731F 21 60 02     	ld		hl, ERRMSG
 899+ 7322 08           	ex		af, af'
 900+ 7323 B7           	or		a
 901+ 7324 28 0B        	jr		z, SaveMsg
 902+ 7326
 903+ 7326 06 00        	ld		b, 0
 904+ 7328              SearchMsgEnd:
 905+ 7328 CB 7E        	bit		7, (hl)
 906+ 732A 23           	inc		hl
 907+ 732B 28 FB        	jr		z, SearchMsgEnd
 908+ 732D
 909+ 732D 04           	inc		b
 910+ 732E B8           	cp		b
 911+ 732F 20 F7        	jr		nz, SearchMsgEnd
 912+ 7331
 913+ 7331              SaveMsg:
 914+ 7331 11 DC 8E     	ld		de, DataBuf
 915+ 7334              CopyMsg:
 916+ 7334 7E           	ld		a, (hl)
 917+ 7335 CB 7F        	bit		7, a
 918+ 7337 12           	ld		(de), a
 919+ 7338 23           	inc		hl
 920+ 7339 13           	inc		de
 921+ 733A 28 F8        	jr		z, CopyMsg
 922+ 733C
 923+ 733C C9           	ret
 924+ 733D
 925+ 733D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926+ 733D
 927+ 733D              ;RWTS routine I/O block
 928+ 733D              RWTSParams:
 929+ 733D 01           RWTSBlockType	DEFB	1							;?
 930+ 733E 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931+ 733F 00           RWTSVolNo		DEFB	0							;?
 932+ 7340 00           RWTSTrack		DEFB	0
 933+ 7341 00           RWTSSector		DEFB	0
 934+ 7342 00 00        RWTSDMA			DEFW	0
 935+ 7344 32 29        RWTSExtBuf		DEFW	$2932
 936+ 7346              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937+ 7346              	IFDEF _REAL_HW_
 938+ 7346 50 73        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939+ 7348              	ELSE
 940+ 7348 ~            RWTSPrmTbl		DEFW	$1f2a
 941+ 7348              	ENDIF
 942+ 7348 01           RWTSCmd			DEFB	RWTS_CMD_READ
 943+ 7349              ;Results
 944+ 7349 00           RWTSRes			DEFB	0
 945+ 734A 00           RWTSResVolNo	DEFB	0
 946+ 734B 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 946+ 734F 00
 947+ 7350
 948+ 7350              ;Param. table, usualy found in ROM.
 949+ 7350              	IFDEF _REAL_HW_
 950+ 7350              BasPrmTbl:
 951+ 7350
 952+ 7350              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953+ 7350              	;DEFINE _STANDARD_DRIVE_PARAM_
 954+ 7350              	IFDEF _STANDARD_DRIVE_PARAM_
 955+ 7350 ~            PrmDevType		DEFB	$01
 956+ 7350 ~            PrmStepRate		DEFB	$0D		;(milisec)
 957+ 7350 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958+ 7350 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959+ 7350              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960+ 7350              PrmFastFactor	EQU		4
 961+ 7350 01           PrmDevType		DEFB	$01
 962+ 7351 03           PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963+ 7352 08           PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964+ 7353 19           PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965+ 7354              	ENDIF
 966+ 7354
 967+ 7354 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968+ 7356              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969+ 7356              	ENDIF
 970+ 7356
 971+ 7356              	endif
# file closed: if1.asm
1445  7356              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7356              ;BDOS functions - similar to CP/M
   2+ 7356
   3+ 7356              	IFNDEF	_BDOS_
   4+ 7356              	DEFINE	_BDOS_
   5+ 7356
   6+ 7356              	include "if1.asm"
# file opened: if1.asm
   1++7356              ;HC IF1 routines and constants
   2++7356
   3++7356              ;IF1 routines error codes, also returned by BASIC commands
   4++7356              ;12 = Writing to a 'read' file
   5++7356              ;13 = Reading a 'write' file
   6++7356              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7356              ;15 = Disk full (disk or catalog full)
   8++7356              ;16 = Disk error (hardware error)
   9++7356              ;17 = File not found
  10++7356              ;23 = Disk R/O (disk change detected, software R/O)
  11++7356              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7356
  13++7356              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7356              ;00h = OK
  15++7356              ;08h = cannot format disk
  16++7356              ;10h = disk protected (read-only?)
  17++7356              ;20h = volume error
  18++7356              ;40h = drive error
  19++7356              ;80h = reading error
  20++7356              ;Codes I encountered:
  21++7356              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7356
  23++7356
  24++7356              	ifndef	_DISK_
  25++7356 ~            	define	_DISK_
  26++7356 ~
  27++7356 ~            	include	"math.asm"
  28++7356 ~
  29++7356 ~            DRIVE_CUR_BAS	EQU 0
  30++7356 ~            DRIVE_A_BAS		EQU	1
  31++7356 ~            DRIVE_B_BAS		EQU	2
  32++7356 ~            DRIVE_A_CPM		EQU	0
  33++7356 ~            DRIVE_B_CPM		EQU	1
  34++7356 ~            ;Disk geometry stuff
  35++7356 ~            SPT				EQU	16			;sectors per track
  36++7356 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7356 ~            TRACK_CNT		EQU	80			;track count
  38++7356 ~            HEAD_CNT		EQU	2			;disk face count
  39++7356 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7356 ~            EXT_SZ			EQU	32			;directory entry size
  41++7356 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7356 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7356 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7356 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7356 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7356 ~            REC_SZ			EQU 128			;cp/m record size
  47++7356 ~            DEL_MARKER		EQU	$E5
  48++7356 ~
  49++7356 ~
  50++7356 ~            ;Extension structure (directory entry)
  51++7356 ~            EXT_DEL_FLAG	EQU	0
  52++7356 ~            EXT_NAME		EQU 1
  53++7356 ~            EXT_IDX			EQU 12
  54++7356 ~            EXT_S1			EQU 13
  55++7356 ~            EXT_S2			EQU 14
  56++7356 ~            EXT_RC			EQU	15
  57++7356 ~            EXT_AU0			EQU	16
  58++7356 ~            EXT_AU1			EQU	18
  59++7356 ~            EXT_AU2			EQU	20
  60++7356 ~            EXT_AU3			EQU	22
  61++7356 ~            EXT_AU4			EQU	24
  62++7356 ~            EXT_AU5			EQU	26
  63++7356 ~            EXT_AU6			EQU	28
  64++7356 ~            EXT_AU7			EQU	30
  65++7356 ~            EXT_SIZE		EQU 32
  66++7356 ~
  67++7356 ~            ;FCB structure
  68++7356 ~            FCB_DRIVE		EQU 0
  69++7356 ~            FCB_NAME		EQU EXT_NAME
  70++7356 ~            FCB_EX_IDX		EQU EXT_IDX
  71++7356 ~            FCB_S1			EQU EXT_S1
  72++7356 ~            FCB_S2			EQU EXT_S2
  73++7356 ~            FCB_RC			EQU	EXT_RC
  74++7356 ~            FCB_AU			EQU	EXT_AU0
  75++7356 ~            FCB_CR			EQU	32
  76++7356 ~            FCB_R0			EQU 33
  77++7356 ~            FCB_R1			EQU 34
  78++7356 ~            FCB_R2			EQU 35
  79++7356 ~            FCB_SIZE		EQU 36
  80++7356 ~
  81++7356 ~
  82++7356 ~
  83++7356 ~            ;System variables for disk
  84++7356 ~            DSTR1			EQU	$5CD6		;drive
  85++7356 ~            FSTR1			EQU	$5CDC		;file name
  86++7356 ~            NSTR1			EQU	$5CDA		;name length
  87++7356 ~            HD11			EQU	$5CED		;BDOS argument
  88++7356 ~            COPIES			EQU	$5CEF		;BDOS function
  89++7356 ~
  90++7356 ~            ERRSP			EQU $5C3D
  91++7356 ~            ERRNR			EQU $5C3A
  92++7356 ~            ERRMSG			EQU	$0260
  93++7356 ~
  94++7356 ~            PROG			EQU $5C53
  95++7356 ~            VARS			EQU	$5C4B
  96++7356 ~            STKEND			EQU	$5C65
  97++7356 ~
  98++7356 ~            PRN_BUF			EQU	23296
  99++7356 ~
 100++7356 ~            REPDEL			EQU	23561
 101++7356 ~            REPPER			EQU	23562
 102++7356 ~            PIP				EQU	23609
 103++7356 ~
 104++7356 ~
 105++7356 ~            ;RWTS routine commands
 106++7356 ~            RWTS_CMD_SEEK	EQU	0			;position head
 107++7356 ~            RWTS_CMD_READ	EQU	1			;read sector
 108++7356 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++7356 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++7356 ~
 111++7356 ~
 112++7356 ~            ;File name stuff
 113++7356 ~            NAMELEN			EQU	11			;name length
 114++7356 ~            RO_POS			EQU	8			;read-only attribute position in name
 115++7356 ~            SYS_POS			EQU	9			;system attribute position in name
 116++7356 ~
 117++7356 ~            ;File types (first byte in header)
 118++7356 ~            PROG_TYPE		EQU	0			;program
 119++7356 ~            NUMB_TYPE		EQU	1			;number array
 120++7356 ~            CHAR_TYPE		EQU	2			;char array
 121++7356 ~            BYTE_TYPE		EQU	3			;bytes
 122++7356 ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++7356 ~
 124++7356 ~            ;File header offsets
 125++7356 ~            HDR_TYPE		EQU	0
 126++7356 ~            HDR_LEN			EQU 1
 127++7356 ~            HDR_ADDR		EQU 3
 128++7356 ~            HDR_PLEN		EQU	5
 129++7356 ~            HDR_LINE		EQU 7
 130++7356 ~            HDR_SZ			EQU	9
 131++7356 ~
 132++7356 ~            ;BASIC disk channel structure
 133++7356 ~            CH_RW_FLAG		EQU 11
 134++7356 ~            CH_FCB			EQU	12
 135++7356 ~            CH_DATA			EQU	50
 136++7356 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++7356 ~
 138++7356 ~            CACHE_NAME		EQU	0					;11B
 139++7356 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++7356 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++7356 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++7356 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++7356 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++7356 ~
 145++7356 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++7356 ~
 147++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++7356 ~            IF1Init:
 149++7356 ~            	rst		08
 150++7356 ~            	defb	49		;create system variables
 151++7356 ~            	ret
 152++7356 ~
 153++7356 ~            ;ReadWriteTrackSector
 154++7356 ~            ;A=command: 0, 1, 2, 4
 155++7356 ~            RWTS:
 156++7356 ~            	ld (RWTSCmd), a
 157++7356 ~            	ld hl, RWTSParams
 158++7356 ~            	ld (HD11), hl
 159++7356 ~            	rst 08
 160++7356 ~            	DEFB 58
 161++7356 ~            	ret
 162++7356 ~
 163++7356 ~
 164++7356 ~            ;D = sector, E = track
 165++7356 ~            ;HL = dma
 166++7356 ~            ReadOneDiskSector:
 167++7356 ~            	ld (RWTSDMA), hl
 168++7356 ~            	ld (RWTSTrack), de
 169++7356 ~            	;ld (RWTSDrive), a
 170++7356 ~            	ld a, RWTS_CMD_READ
 171++7356 ~            	jr	RWTS
 172++7356 ~
 173++7356 ~            ;D = sector, E = track
 174++7356 ~            ;HL = dma
 175++7356 ~            WriteOneDiskSector:
 176++7356 ~            	ld (RWTSDMA), hl
 177++7356 ~            	ld (RWTSTrack), de
 178++7356 ~            	;ld (RWTSDrive), a
 179++7356 ~            	ld a, RWTS_CMD_WRITE
 180++7356 ~            	jr	RWTS
 181++7356 ~
 182++7356 ~            FormatDisk:
 183++7356 ~            	ld		hl, DataBuf
 184++7356 ~            	ld		(hl), DEL_MARKER
 185++7356 ~            	ld 		(RWTSDMA), hl
 186++7356 ~            	ld 		a, RWTS_CMD_FMT
 187++7356 ~            	call	RWTS
 188++7356 ~            	ld		a, (RWTSRes)
 189++7356 ~            	ret
 190++7356 ~
 191++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++7356 ~
 193++7356 ~            ;Allocation unit no. to track/sector
 194++7356 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++7356 ~            ;IN:  HL=alloc. unit no.
 196++7356 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++7356 ~            AU2TS:
 198++7356 ~            	ld c, SPT/SPAL
 199++7356 ~            	call Div					;A = sector
 200++7356 ~            	push af
 201++7356 ~            		/*
 202++7356 ~            		ld c, HEAD_CNT
 203++7356 ~            		call Div				;L = track, A = head (0 or 1)
 204++7356 ~            		*/
 205++7356 ~            		xor a
 206++7356 ~            		rr h
 207++7356 ~            		rr l
 208++7356 ~            		rr a
 209++7356 ~
 210++7356 ~            		ld c, l
 211++7356 ~            		ld b, 0
 212++7356 ~            		or a
 213++7356 ~            		jr z, Track0
 214++7356 ~            		ld b, SPT
 215++7356 ~            Track0:
 216++7356 ~            	pop af
 217++7356 ~            	or a
 218++7356 ~            	jr z, FirstAU
 219++7356 ~            	ld a, SPAL
 220++7356 ~            FirstAU:
 221++7356 ~            	add a, b
 222++7356 ~            	ld  b, a
 223++7356 ~            	ret
 224++7356 ~
 225++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++7356 ~
 227++7356 ~            ;Checks the allocation units number used in extension
 228++7356 ~            ;IN:	IX = extension addr
 229++7356 ~            ;OUT:	B = no. of allocation units used
 230++7356 ~            ;		C = no. of records used in ext.
 231++7356 ~            ;		HL = first alloc. unit no.
 232++7356 ~            ;		DE = last alloc. unit no.
 233++7356 ~            CheckExtAlloc:
 234++7356 ~            	push ix
 235++7356 ~            		ld bc, EXT_RC
 236++7356 ~            		add ix, bc
 237++7356 ~            		ld c, (ix)			;save rec. no.
 238++7356 ~            		inc ix
 239++7356 ~            		ld l, (ix)
 240++7356 ~            		ld h, (ix + 1)
 241++7356 ~            		ld b, EXT_AU_CNT
 242++7356 ~            CheckAU:
 243++7356 ~            		ld a, (ix)
 244++7356 ~            		or (ix + 1)
 245++7356 ~            		jr z, CheckAUEnd
 246++7356 ~            		ld e, (ix)
 247++7356 ~            		ld d, (ix + 1)
 248++7356 ~            		inc ix
 249++7356 ~            		inc ix
 250++7356 ~            		djnz CheckAU
 251++7356 ~            CheckAUEnd:
 252++7356 ~            		ld a, EXT_AU_CNT
 253++7356 ~            		sub b
 254++7356 ~            		ld b, a
 255++7356 ~            	pop ix
 256++7356 ~            	ret
 257++7356 ~
 258++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++7356 ~
 260++7356 ~            ;Input: TrackBuffer
 261++7356 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++7356 ~            ReadUsedBlocksList:
 263++7356 ~            	ld		ix, TrackBuf			;source buffer
 264++7356 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++7356 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 266++7356 ~            	ld		de, 2					;counter of used blocks, start with 2
 267++7356 ~            	ld		(hl), e
 268++7356 ~            	inc		hl
 269++7356 ~            	ld		(hl), d
 270++7356 ~            	inc		hl
 271++7356 ~
 272++7356 ~            	;Add blocks 0 and 1 for directory
 273++7356 ~            	ld		de, 0
 274++7356 ~            	ld		(hl), e
 275++7356 ~            	inc		hl
 276++7356 ~            	ld		(hl), d
 277++7356 ~            	inc		hl
 278++7356 ~
 279++7356 ~            	inc		de
 280++7356 ~            	ld		(hl), e
 281++7356 ~            	inc		hl
 282++7356 ~            	ld		(hl), d
 283++7356 ~            	inc		hl
 284++7356 ~
 285++7356 ~            ReadUsedBlocksLoop:
 286++7356 ~            	xor		a
 287++7356 ~            	cp		(ix)
 288++7356 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++7356 ~
 290++7356 ~            	push	ix
 291++7356 ~            	push	bc
 292++7356 ~            		ld		b, EXT_AU_CNT
 293++7356 ~            		ld		de, EXT_AU0
 294++7356 ~            		add		ix, de
 295++7356 ~
 296++7356 ~            ReadUsedBlocksLoop2:
 297++7356 ~            		ld		e, (ix)
 298++7356 ~            		ld		d, (ix+1)
 299++7356 ~            		ld		a, e
 300++7356 ~            		or		d
 301++7356 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++7356 ~
 303++7356 ~            		ld		(hl), e
 304++7356 ~            		inc		hl
 305++7356 ~            		ld		(hl), d
 306++7356 ~            		inc		hl
 307++7356 ~
 308++7356 ~            		inc		ix
 309++7356 ~            		inc		ix
 310++7356 ~
 311++7356 ~            		ld		de, (UsedBlockListCnt)
 312++7356 ~            		inc		de
 313++7356 ~            		ld		(UsedBlockListCnt), de
 314++7356 ~
 315++7356 ~            		djnz	ReadUsedBlocksLoop2
 316++7356 ~
 317++7356 ~
 318++7356 ~            ReadUsedBlocksSkip:
 319++7356 ~            	pop		bc
 320++7356 ~            	pop		ix
 321++7356 ~            ReadUsedBlocksSkip2:
 322++7356 ~            	ld		de, EXT_SZ
 323++7356 ~            	add		ix, de
 324++7356 ~
 325++7356 ~            	dec		bc
 326++7356 ~            	ld		a, b
 327++7356 ~            	or		c
 328++7356 ~            	jr		nz, ReadUsedBlocksLoop
 329++7356 ~
 330++7356 ~            	ret
 331++7356 ~
 332++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++7356 ~            ;Reads 8 sectors for an AU
 334++7356 ~            ;HL = block number, DE = destination buffer
 335++7356 ~            ReadFSBlock:
 336++7356 ~            	push	de
 337++7356 ~            		call	AU2TS		;B=sector, C=track
 338++7356 ~            	pop		hl				;HL=dest
 339++7356 ~
 340++7356 ~            	ld		d, b
 341++7356 ~            	ld		e, c
 342++7356 ~            	ld		b, SPAL
 343++7356 ~
 344++7356 ~            	call	ReadDiskSectors
 345++7356 ~            	ret
 346++7356 ~
 347++7356 ~
 348++7356 ~            ;Write 8 sectors for an AU
 349++7356 ~            ;HL = block number, DE = source buffer
 350++7356 ~            WriteFSBlock:
 351++7356 ~            	push	de
 352++7356 ~            		call	AU2TS		;B=sector, C=track
 353++7356 ~            	pop		hl				;HL=dest
 354++7356 ~
 355++7356 ~            	ld		d, b
 356++7356 ~            	ld		e, c
 357++7356 ~            	ld		b, SPAL
 358++7356 ~
 359++7356 ~            	call	WriteDiskSectors
 360++7356 ~            	ret
 361++7356 ~
 362++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++7356 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++7356 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++7356 ~            CopyDisk:
 366++7356 ~            	;Get list of used blocks in current disk, max 632 bytes
 367++7356 ~            	call	ReadUsedBlocksList
 368++7356 ~            	ld		ix, UsedBlockListBlk
 369++7356 ~
 370++7356 ~            CopyDiskLoop:
 371++7356 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++7356 ~            	ld		de, MsgBlocksLeft
 373++7356 ~            	call	Byte2Txt
 374++7356 ~            	ld		hl, MsgBlocksLeft
 375++7356 ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++7356 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++7356 ~            	call	PrintStrClr
 378++7356 ~
 379++7356 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++7356 ~            	ld		hl, MAX_AU_RAM
 381++7356 ~            	ld		bc, (UsedBlockListCnt)
 382++7356 ~            	or		a
 383++7356 ~            	sbc		hl, bc
 384++7356 ~            	jr		nc, CopyDiskLoopRead
 385++7356 ~            	ld		bc, MAX_AU_RAM
 386++7356 ~
 387++7356 ~            CopyDiskLoopRead:
 388++7356 ~            	ld		b, c
 389++7356 ~            	ld		de, CopyDiskBuf
 390++7356 ~            	;save initial counter and initial block number array position
 391++7356 ~            	push	bc
 392++7356 ~            	push	ix
 393++7356 ~
 394++7356 ~            CopyDiskLoopReadLoop:
 395++7356 ~            		ld		l, (ix)
 396++7356 ~            		ld		h, (ix+1)
 397++7356 ~            		inc		ix
 398++7356 ~            		inc		ix
 399++7356 ~
 400++7356 ~            		push	de
 401++7356 ~            		push	bc
 402++7356 ~            			call	ReadFSBlock			;Stop on error or continue?
 403++7356 ~            		pop		bc
 404++7356 ~            		pop		de
 405++7356 ~
 406++7356 ~            		;+2048
 407++7356 ~            		ld		a, d
 408++7356 ~            		add		8
 409++7356 ~            		ld		d, a
 410++7356 ~
 411++7356 ~            		djnz	CopyDiskLoopReadLoop
 412++7356 ~
 413++7356 ~            		;Check if selection is 1=single drive or 2=dual drive
 414++7356 ~            		ld		a, (CopySelOption)
 415++7356 ~            		cp		'1'
 416++7356 ~            		jr		nz, CopyDiskDualDrive1
 417++7356 ~
 418++7356 ~            		;Prompt for disk change
 419++7356 ~            		call	PromptDiskChangeDst
 420++7356 ~            		ld		a, (RWTSDrive)
 421++7356 ~            		call	BDOSInit
 422++7356 ~            		jr		CopyDiskReadEnd
 423++7356 ~
 424++7356 ~            CopyDiskDualDrive1:
 425++7356 ~            		;alternate drive
 426++7356 ~            		ld		a, (RWTSDrive)
 427++7356 ~            		inc 	a
 428++7356 ~            		xor		%11
 429++7356 ~            		dec		a
 430++7356 ~            		ld		(RWTSDrive), a
 431++7356 ~
 432++7356 ~            CopyDiskReadEnd:
 433++7356 ~            	;restore initial counter and initial block number array position
 434++7356 ~            	pop		ix
 435++7356 ~            	pop		bc
 436++7356 ~            	ld		de, CopyDiskBuf
 437++7356 ~            	push	bc
 438++7356 ~
 439++7356 ~            CopyDiskLoopWriteLoop:
 440++7356 ~            		ld		l, (ix)
 441++7356 ~            		ld		h, (ix+1)
 442++7356 ~            		inc		ix
 443++7356 ~            		inc		ix
 444++7356 ~
 445++7356 ~            		push	de
 446++7356 ~            		push	bc
 447++7356 ~            			call	WriteFSBlock		;Stop on error or continue?
 448++7356 ~            		pop		bc
 449++7356 ~            		pop		de
 450++7356 ~
 451++7356 ~            		;+2048
 452++7356 ~            		ld		a, d
 453++7356 ~            		add		8
 454++7356 ~            		ld		d, a
 455++7356 ~
 456++7356 ~            		djnz	CopyDiskLoopWriteLoop
 457++7356 ~
 458++7356 ~            CopyDiskWriteEnd:
 459++7356 ~            	pop		bc
 460++7356 ~            	ld		c, b
 461++7356 ~            	ld		b, 0
 462++7356 ~
 463++7356 ~            	;Decrease number of blocks read by now.
 464++7356 ~            	ld		hl, (UsedBlockListCnt)
 465++7356 ~            	or		a
 466++7356 ~            	sbc		hl, bc
 467++7356 ~            	ld		(UsedBlockListCnt), hl
 468++7356 ~
 469++7356 ~            	ld		a, l
 470++7356 ~            	or		h
 471++7356 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++7356 ~
 473++7356 ~            	;Check if selection is 1=single drive or 2=dual drive
 474++7356 ~            	ld		a, (CopySelOption)
 475++7356 ~            	cp		'1'
 476++7356 ~            	jr		nz, CopyDiskDualDrive2
 477++7356 ~
 478++7356 ~            	;Prompt for disk change
 479++7356 ~            	call	PromptDiskChangeSrc
 480++7356 ~            	ld		a, (RWTSDrive)
 481++7356 ~            	call	BDOSInit
 482++7356 ~            	jp		CopyDiskLoop
 483++7356 ~
 484++7356 ~            CopyDiskDualDrive2:
 485++7356 ~            	;alternate drive again
 486++7356 ~            	ld		a, (RWTSDrive)
 487++7356 ~            	inc		a
 488++7356 ~            	xor		%11
 489++7356 ~            	dec		a
 490++7356 ~            	ld		(RWTSDrive), a
 491++7356 ~            	jp		CopyDiskLoop
 492++7356 ~
 493++7356 ~            CopyDiskEnd:
 494++7356 ~            	ld		b, 1
 495++7356 ~            	call	ClearNMsgLines
 496++7356 ~            	ret
 497++7356 ~
 498++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++7356 ~            ;Copies the current disk blocks to COM port.
 500++7356 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++7356 ~            CopyDiskToCOM:
 502++7356 ~            	;Get list of used blocks in current disk, max 632 bytes
 503++7356 ~            	call	ReadUsedBlocksList
 504++7356 ~
 505++7356 ~            	;Send block count and block indexes
 506++7356 ~            	ld		hl, (UsedBlockListCnt)
 507++7356 ~            	add		hl, hl
 508++7356 ~            	inc		hl
 509++7356 ~            	inc		hl
 510++7356 ~            	ld		b, h
 511++7356 ~            	ld		c, l
 512++7356 ~            	ld		hl, UsedBlockListCnt
 513++7356 ~            	call	SERTB
 514++7356 ~
 515++7356 ~            	ld		ix, UsedBlockListBlk
 516++7356 ~
 517++7356 ~            CopyDiskToCOMLoop:
 518++7356 ~            	;Print block count left
 519++7356 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++7356 ~            	ld		de, MsgBlocksLeft
 521++7356 ~            	call	Byte2Txt
 522++7356 ~            	ld		hl, MsgBlocksLeft
 523++7356 ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++7356 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++7356 ~            	call	PrintStrClr
 526++7356 ~
 527++7356 ~            	;Read block into buffer
 528++7356 ~            	ld		l, (ix)
 529++7356 ~            	ld		h, (ix+1)
 530++7356 ~            	ld		de, CopyDiskBuf
 531++7356 ~            	push	ix
 532++7356 ~            		call	ReadFSBlock
 533++7356 ~            	pop		ix
 534++7356 ~            	inc		ix
 535++7356 ~            	inc		ix
 536++7356 ~
 537++7356 ~            	;Send block buffer
 538++7356 ~            	ld		hl, CopyDiskBuf
 539++7356 ~            	ld		bc, AU_SZ
 540++7356 ~            	call	SERTB
 541++7356 ~
 542++7356 ~            	ld		bc, (UsedBlockListCnt)
 543++7356 ~            	dec		bc
 544++7356 ~            	ld		(UsedBlockListCnt), bc
 545++7356 ~
 546++7356 ~            	push	ix
 547++7356 ~            		call	KbdHit
 548++7356 ~            	pop		ix
 549++7356 ~            	ret		c
 550++7356 ~
 551++7356 ~            	ld		a, b
 552++7356 ~            	or		c
 553++7356 ~            	jr		nz, CopyDiskToCOMLoop
 554++7356 ~
 555++7356 ~            	ret
 556++7356 ~
 557++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++7356 ~            CopyDiskFromCOM:
 559++7356 ~            	;Receive block count.
 560++7356 ~            	ld		hl, UsedBlockListCnt
 561++7356 ~            	ld		bc, 2
 562++7356 ~            	ld		e, 0
 563++7356 ~            	call	SERRB
 564++7356 ~
 565++7356 ~            	;Receive block indexes.
 566++7356 ~            	ld		hl, (UsedBlockListCnt)
 567++7356 ~            	add		hl, hl
 568++7356 ~            	ld		b, h
 569++7356 ~            	ld		c, l
 570++7356 ~            	ld		hl, UsedBlockListBlk
 571++7356 ~            	ld		e, 0
 572++7356 ~            	call	SERRB
 573++7356 ~
 574++7356 ~            	;Read each block by index and write to disk
 575++7356 ~            	ld		ix, UsedBlockListBlk
 576++7356 ~
 577++7356 ~            CopyDiskFromCOMLoop:
 578++7356 ~            	;Print block count left
 579++7356 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++7356 ~            	ld		de, MsgBlocksLeft
 581++7356 ~            	call	Byte2Txt
 582++7356 ~            	ld		hl, MsgBlocksLeft
 583++7356 ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++7356 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++7356 ~            	call	PrintStrClr
 586++7356 ~
 587++7356 ~            	;Read block buffer
 588++7356 ~            	ld		hl, CopyDiskBuf
 589++7356 ~            	ld		bc, AU_SZ
 590++7356 ~            	ld		e, 0
 591++7356 ~            	call	SERRB
 592++7356 ~
 593++7356 ~            	;Write block to disk
 594++7356 ~            	ld		l, (ix)
 595++7356 ~            	ld		h, (ix+1)
 596++7356 ~            	ld		de, CopyDiskBuf
 597++7356 ~            	push	ix
 598++7356 ~            		call	WriteFSBlock			;Stop on error or continue?
 599++7356 ~            	pop		ix
 600++7356 ~            	inc		ix
 601++7356 ~            	inc		ix
 602++7356 ~
 603++7356 ~            	ld		bc, (UsedBlockListCnt)
 604++7356 ~            	dec		bc
 605++7356 ~            	ld		(UsedBlockListCnt), bc
 606++7356 ~
 607++7356 ~            	push	ix
 608++7356 ~            		call	KbdHit
 609++7356 ~            	pop		ix
 610++7356 ~            	ret		c
 611++7356 ~
 612++7356 ~            	ld		a, b
 613++7356 ~            	or		c
 614++7356 ~            	jr		nz, CopyDiskFromCOMLoop
 615++7356 ~            	ret
 616++7356 ~
 617++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++7356 ~
 619++7356 ~            ;Compare string at HL with the one at DE, max length B
 620++7356 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++7356 ~            ;OUT: z flag, set = match, reset = mismatch
 622++7356 ~            StrCmp:
 623++7356 ~            	push hl
 624++7356 ~            	push de
 625++7356 ~            Compare:
 626++7356 ~            		ld a, (de)
 627++7356 ~            		cp (hl)
 628++7356 ~            		jr nz, MisMatch
 629++7356 ~            		inc hl
 630++7356 ~            		inc de
 631++7356 ~            		djnz Compare
 632++7356 ~            MisMatch:
 633++7356 ~            	pop de
 634++7356 ~            	pop hl
 635++7356 ~            	ret
 636++7356 ~
 637++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++7356 ~
 639++7356 ~            ;Read a file into a buffer, sector by sector.
 640++7356 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++7356 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++7356 ~            ;In: HL = Name address, DE = buffer
 643++7356 ~            IF1FileLoad:
 644++7356 ~            	push	de
 645++7356 ~            		ld (FSTR1), hl
 646++7356 ~            		ld h, 0
 647++7356 ~            		ld a, (RWTSDrive)
 648++7356 ~            		inc  a			;CP/M drive number to BASIC drive number
 649++7356 ~            		ld	l, a
 650++7356 ~            		ld (DSTR1), hl
 651++7356 ~            		ld l,NAMELEN
 652++7356 ~            		ld (NSTR1), hl
 653++7356 ~            		rst 08
 654++7356 ~            		DEFB 51			;open disk channel
 655++7356 ~
 656++7356 ~            		rst		8
 657++7356 ~            		defb	53		;read sector
 658++7356 ~            	pop		de
 659++7356 ~            	jr		nc, FileFree
 660++7356 ~
 661++7356 ~            	ld		a, (ix + CH_DATA)
 662++7356 ~            	cp		TEXT_TYPE
 663++7356 ~            	jr		nc, FileLoadNoHeader
 664++7356 ~
 665++7356 ~            FileLoadHeader:
 666++7356 ~            	push	ix
 667++7356 ~            	pop		hl
 668++7356 ~            	ld		bc, CH_DATA + HDR_SZ
 669++7356 ~            	add		hl, bc
 670++7356 ~            	ld		bc, SECT_SZ - HDR_SZ
 671++7356 ~            	ldir
 672++7356 ~
 673++7356 ~            FileReadLoop:
 674++7356 ~            	push	de
 675++7356 ~            		rst		8
 676++7356 ~            		defb	53		;read sector
 677++7356 ~            	pop		de
 678++7356 ~            	jr		nc, FileFree
 679++7356 ~
 680++7356 ~            FileLoadNoHeader:
 681++7356 ~            	push	ix
 682++7356 ~            	pop		hl
 683++7356 ~            	ld		bc, CH_DATA
 684++7356 ~            	add		hl, bc
 685++7356 ~            	ld		bc, SECT_SZ
 686++7356 ~            	ldir
 687++7356 ~            	jr		FileReadLoop
 688++7356 ~
 689++7356 ~            FileFree:
 690++7356 ~            	push	de
 691++7356 ~            	rst		8
 692++7356 ~            	defb	56			;close channel (52) or detroy channel (56)
 693++7356 ~            	pop		de
 694++7356 ~            	ret
 695++7356 ~            IF1FileLoadEnd:
 696++7356 ~
 697++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++7356 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++7356 ~            ;Out: A = error code, 0=OK
 700++7356 ~            ReadDiskSectors:
 701++7356 ~            	push bc
 702++7356 ~            		push hl
 703++7356 ~            			push de
 704++7356 ~            				call ReadOneDiskSector
 705++7356 ~            			pop de
 706++7356 ~            		pop hl
 707++7356 ~
 708++7356 ~            		inc d
 709++7356 ~            		inc h
 710++7356 ~            	pop bc
 711++7356 ~
 712++7356 ~            	ld	a, (RWTSRes)
 713++7356 ~            	or	a
 714++7356 ~            	ret nz
 715++7356 ~
 716++7356 ~            	djnz ReadDiskSectors
 717++7356 ~            	ret
 718++7356 ~
 719++7356 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++7356 ~            ;Out: A = error code, 0=OK
 721++7356 ~            WriteDiskSectors:
 722++7356 ~            	push bc
 723++7356 ~            		push hl
 724++7356 ~            			push de
 725++7356 ~            				call WriteOneDiskSector
 726++7356 ~            			pop de
 727++7356 ~            		pop hl
 728++7356 ~
 729++7356 ~            		inc d
 730++7356 ~            		inc h
 731++7356 ~            	pop bc
 732++7356 ~
 733++7356 ~            	ld	a, (RWTSRes)
 734++7356 ~            	or	a
 735++7356 ~            	ret nz
 736++7356 ~
 737++7356 ~            	djnz WriteDiskSectors
 738++7356 ~            	ret
 739++7356 ~
 740++7356 ~
 741++7356 ~            ;Reads disk catalog
 742++7356 ~            ReadCatalogTrack:
 743++7356 ~            	ld hl, TrackBuf
 744++7356 ~            	ld de, 0
 745++7356 ~            	ld b, SPT
 746++7356 ~
 747++7356 ~            	call ReadDiskSectors
 748++7356 ~            	ret
 749++7356 ~
 750++7356 ~            ;A = track
 751++7356 ~            SeekTrack:
 752++7356 ~            	IFUSED
 753++7356 ~            	ld	(RWTSTrack), a
 754++7356 ~            	ld 	a, RWTS_CMD_SEEK
 755++7356 ~            	jp	RWTS
 756++7356 ~            	ENDIF
 757++7356 ~
 758++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759++7356 ~
 760++7356 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761++7356 ~            FindCache:
 762++7356 ~            	ld		b, NAMELEN
 763++7356 ~            	call	StrCmp			;find the file to wich this extension belongs
 764++7356 ~            	ret		z
 765++7356 ~
 766++7356 ~            	dec		c
 767++7356 ~            	jr		nz, CacheNotFinished
 768++7356 ~            	or		c
 769++7356 ~            	ret
 770++7356 ~
 771++7356 ~            CacheNotFinished:
 772++7356 ~            	ld		bc, CACHE_SZ
 773++7356 ~            	add		hl, bc			;to the next cache line
 774++7356 ~            	jr		FindCache
 775++7356 ~
 776++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777++7356 ~
 778++7356 ~            	;ld		ix, (SelFileCache)
 779++7356 ~            ReadFileHeader:
 780++7356 ~            	ld		a, (ix + CACHE_FLAG)
 781++7356 ~            	or		a
 782++7356 ~            	ret		nz				;return if already read
 783++7356 ~
 784++7356 ~            	ld		l, (ix + CACHE_FIRST_AU)
 785++7356 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 786++7356 ~            	ld		a, h
 787++7356 ~            	or		l
 788++7356 ~            	jr		z, ReadHeaderEnd
 789++7356 ~
 790++7356 ~            	call	AU2TS
 791++7356 ~            	ld		d, b
 792++7356 ~            	ld		e, c
 793++7356 ~            	ld		hl, DataBuf
 794++7356 ~            	push	ix
 795++7356 ~            	push	ix
 796++7356 ~            		call	ReadOneDiskSector
 797++7356 ~            	pop		hl
 798++7356 ~            	pop		ix
 799++7356 ~
 800++7356 ~            	push	hl
 801++7356 ~            		ld		hl, DataBuf
 802++7356 ~            		call	IsFileHeaderValid
 803++7356 ~            	pop		hl
 804++7356 ~            	or		a
 805++7356 ~            	jr		z, ReadFileHeaderIsTextFile
 806++7356 ~
 807++7356 ~            	ld		bc, CACHE_HDR
 808++7356 ~            	add		hl, bc
 809++7356 ~            	ex		hl, de
 810++7356 ~            	ld		hl, DataBuf
 811++7356 ~            	ld		bc, HDR_SZ
 812++7356 ~            	ldir
 813++7356 ~
 814++7356 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 815++7356 ~            	ld		a, BYTE_TYPE
 816++7356 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 817++7356 ~            	jr		nc, ReadHeaderEnd
 818++7356 ~
 819++7356 ~            ReadFileHeaderIsTextFile:
 820++7356 ~            	push	ix
 821++7356 ~            	push	ix
 822++7356 ~            	pop		hl
 823++7356 ~            		call	GetFileSize
 824++7356 ~            	pop		ix
 825++7356 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 826++7356 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827++7356 ~            	ld		a, TEXT_TYPE
 828++7356 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829++7356 ~
 830++7356 ~            ReadHeaderEnd:
 831++7356 ~            	inc		(ix + CACHE_FLAG)
 832++7356 ~            	ret
 833++7356 ~
 834++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835++7356 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 836++7356 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837++7356 ~            ;In: HL = header
 838++7356 ~            ;Out: A > 0 if valid
 839++7356 ~            IsFileHeaderValid:
 840++7356 ~            	IFUSED
 841++7356 ~            	xor		a
 842++7356 ~            	ld		b, HDR_SZ
 843++7356 ~            IsFileHeaderValidLoop:
 844++7356 ~            	or		(hl)
 845++7356 ~            	inc		hl
 846++7356 ~            	djnz	IsFileHeaderValidLoop
 847++7356 ~
 848++7356 ~            	ret
 849++7356 ~            	ENDIF
 850++7356 ~
 851++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852++7356 ~
 853++7356 ~            ;IN: HL = address from IF1 to call
 854++7356 ~            IF1Call:
 855++7356 ~            	LD   (HD11), HL
 856++7356 ~            	RST  8
 857++7356 ~            	DEFB 50
 858++7356 ~            	RET
 859++7356 ~
 860++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861++7356 ~
 862++7356 ~            ;Load a program from disk
 863++7356 ~            ;IN: HL = file name addr
 864++7356 ~            LoadProgram:
 865++7356 ~            	LD   (FSTR1), HL
 866++7356 ~            	LD   H, 0
 867++7356 ~            	LD   L, NAMELEN
 868++7356 ~            	LD   (NSTR1), HL
 869++7356 ~            	LD	 A, (RWTSDrive)
 870++7356 ~            	INC  A					;Adapt for BASIC drive number
 871++7356 ~            	LD   L, A
 872++7356 ~            	LD   (DSTR1), HL
 873++7356 ~            	LD   HL, LOAD_ADDR
 874++7356 ~            	CALL IF1Call
 875++7356 ~            	RET
 876++7356 ~
 877++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878++7356 ~
 879++7356 ~            SetFastKeys:
 880++7356 ~            	ld		a, 10
 881++7356 ~            	ld		(REPDEL), a
 882++7356 ~            	ld		a, 1
 883++7356 ~            	ld		(REPDEL+1),a
 884++7356 ~
 885++7356 ~            	ret
 886++7356 ~
 887++7356 ~
 888++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889++7356 ~            ;Reads the error message string from IF1 ROM.
 890++7356 ~            GetErrMsg:
 891++7356 ~            	inc		a
 892++7356 ~            	ex		af, af'
 893++7356 ~
 894++7356 ~            	ld		hl, IF1Paged			;page-in IF1
 895++7356 ~            	jp		IF1Call
 896++7356 ~
 897++7356 ~            IF1Paged:
 898++7356 ~            	ld		hl, ERRMSG
 899++7356 ~            	ex		af, af'
 900++7356 ~            	or		a
 901++7356 ~            	jr		z, SaveMsg
 902++7356 ~
 903++7356 ~            	ld		b, 0
 904++7356 ~            SearchMsgEnd:
 905++7356 ~            	bit		7, (hl)
 906++7356 ~            	inc		hl
 907++7356 ~            	jr		z, SearchMsgEnd
 908++7356 ~
 909++7356 ~            	inc		b
 910++7356 ~            	cp		b
 911++7356 ~            	jr		nz, SearchMsgEnd
 912++7356 ~
 913++7356 ~            SaveMsg:
 914++7356 ~            	ld		de, DataBuf
 915++7356 ~            CopyMsg:
 916++7356 ~            	ld		a, (hl)
 917++7356 ~            	bit		7, a
 918++7356 ~            	ld		(de), a
 919++7356 ~            	inc		hl
 920++7356 ~            	inc		de
 921++7356 ~            	jr		z, CopyMsg
 922++7356 ~
 923++7356 ~            	ret
 924++7356 ~
 925++7356 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926++7356 ~
 927++7356 ~            ;RWTS routine I/O block
 928++7356 ~            RWTSParams:
 929++7356 ~            RWTSBlockType	DEFB	1							;?
 930++7356 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931++7356 ~            RWTSVolNo		DEFB	0							;?
 932++7356 ~            RWTSTrack		DEFB	0
 933++7356 ~            RWTSSector		DEFB	0
 934++7356 ~            RWTSDMA			DEFW	0
 935++7356 ~            RWTSExtBuf		DEFW	$2932
 936++7356 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937++7356 ~            	IFDEF _REAL_HW_
 938++7356 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939++7356 ~            	ELSE
 940++7356 ~            RWTSPrmTbl		DEFW	$1f2a
 941++7356 ~            	ENDIF
 942++7356 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 943++7356 ~            ;Results
 944++7356 ~            RWTSRes			DEFB	0
 945++7356 ~            RWTSResVolNo	DEFB	0
 946++7356 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 947++7356 ~
 948++7356 ~            ;Param. table, usualy found in ROM.
 949++7356 ~            	IFDEF _REAL_HW_
 950++7356 ~            BasPrmTbl:
 951++7356 ~
 952++7356 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953++7356 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 954++7356 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 955++7356 ~            PrmDevType		DEFB	$01
 956++7356 ~            PrmStepRate		DEFB	$0D		;(milisec)
 957++7356 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958++7356 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959++7356 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960++7356 ~            PrmFastFactor	EQU		4
 961++7356 ~            PrmDevType		DEFB	$01
 962++7356 ~            PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963++7356 ~            PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964++7356 ~            PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965++7356 ~            	ENDIF
 966++7356 ~
 967++7356 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968++7356 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969++7356 ~            	ENDIF
 970++7356 ~
 971++7356              	endif
# file closed: if1.asm
   7+ 7356
   8+ 7356              BDOSInit:
   9+ 7356 AF           	xor		a
  10+ 7357 18 49        	jr		BDOS
  11+ 7359
  12+ 7359
  13+ 7359              ;IN: A = Drive to select
  14+ 7359              BDOSSelectDisk:
  15+ 7359              	IFUSED
  16+ 7359 DD 6F        	ld		ixl, a
  17+ 735B DD 26 00     	ld		ixh, 0
  18+ 735E 3E 01        	ld		a, 1
  19+ 7360 18 40        	jr		BDOS
  20+ 7362              	ENDIF
  21+ 7362
  22+ 7362
  23+ 7362              BDOSMakeDiskRO:
  24+ 7362              	IFUSED
  25+ 7362 ~            	ld		a, 15
  26+ 7362 ~            	jr		BDOS
  27+ 7362              	ENDIF
  28+ 7362
  29+ 7362              ;Get Read Only flag
  30+ 7362              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 7362              BDOSGetDiskRO:
  32+ 7362              	IFUSED
  33+ 7362 ~            	ld	a, 16
  34+ 7362 ~            	jr	BDOS
  35+ 7362              	ENDIF
  36+ 7362
  37+ 7362              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 7362              BDOSGetCurrentDrive:
  39+ 7362              	IFUSED
  40+ 7362 3E 0C        	ld		a, 12
  41+ 7364 18 3C        	jr		BDOS
  42+ 7366              	ENDIF
  43+ 7366
  44+ 7366              ;Does log-off for all drives?
  45+ 7366              BDOSCloseDrives:
  46+ 7366              	IFUSED
  47+ 7366 ~            	ld		ixl, a
  48+ 7366 ~            	ld		ixh, 0
  49+ 7366 ~            	ld		a, 22
  50+ 7366 ~            	jr		BDOS
  51+ 7366              	ENDIF
  52+ 7366
  53+ 7366              ;Create a disk channel for BDOS access (does not open the file)
  54+ 7366              ;IN: HL=name addr, A=drive
  55+ 7366              ;OUT: IX=FCB
  56+ 7366              CreateChannel:
  57+ 7366 22 DC 5C     	ld (FSTR1), hl
  58+ 7369 26 00        	ld h,0
  59+ 736B 6F           	ld l,a
  60+ 736C 22 D6 5C     	ld (DSTR1), hl
  61+ 736F 2E 0B        	ld l,NAMELEN
  62+ 7371 22 DA 5C     	ld (NSTR1), hl
  63+ 7374 CF           	rst 08
  64+ 7375 37           	DEFB 55
  65+ 7376 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 7379 DD 09        	add ix, bc
  67+ 737B C9           	ret
  68+ 737C
  69+ 737C
  70+ 737C              ;Destroy a BDOS channel
  71+ 737C              ;IN: IX=FCB
  72+ 737C              DestroyChannel:
  73+ 737C C5           	push bc
  74+ 737D 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 7380 DD 09        	add ix, bc
  76+ 7382 CF           	rst 08
  77+ 7383 38           	DEFB 56
  78+ 7384 C1           	pop bc
  79+ 7385 C9           	ret
  80+ 7386
  81+ 7386
  82+ 7386              ;Input: IX=FCB
  83+ 7386              BDOSCreateFile:
  84+ 7386 3E 09        	ld	a, 9
  85+ 7388 18 18        	jr	BDOS
  86+ 738A
  87+ 738A              ;Input: IX=FCB
  88+ 738A              BDOSOpenFile:
  89+ 738A 3E 02        	ld	a, 2
  90+ 738C 18 14        	jr	BDOS
  91+ 738E
  92+ 738E              ;IN: IX=FCB
  93+ 738E              BDOSCloseFile:
  94+ 738E 3E 03        	ld	a, 3
  95+ 7390 18 10        	jr	BDOS
  96+ 7392
  97+ 7392
  98+ 7392              ;0 OK,
  99+ 7392              ;1 end of file,
 100+ 7392              ;9 invalid FCB,
 101+ 7392              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 7392              ;11 (MP/M) unlocked file verification error,
 103+ 7392              ;0FFh hardware error.
 104+ 7392
 105+ 7392              ;IN: IX=FCB
 106+ 7392              BDOSReadFileBlockSeq:
 107+ 7392 3E 07        	ld	a, 7
 108+ 7394 18 0C        	jr	BDOS
 109+ 7396
 110+ 7396
 111+ 7396              ;0 OK,
 112+ 7396              ;1 directory full,
 113+ 7396              ;2 disc full,
 114+ 7396              ;8 (MP/M) record locked by another process,
 115+ 7396              ;9 invalid FCB,
 116+ 7396              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 7396              ;11 (MP/M) unlocked file verification error,
 118+ 7396              ;0FFh hardware error.
 119+ 7396
 120+ 7396              ;IN: IX=FCB
 121+ 7396              BDOSWriteFileBlockSeq:
 122+ 7396 3E 08        	ld	a, 8
 123+ 7398 18 08        	jr	BDOS
 124+ 739A
 125+ 739A
 126+ 739A              ;0 OK
 127+ 739A              ;1 Reading unwritten data
 128+ 739A              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 739A              ;6 Record number out of range
 130+ 739A              ;9 Invalid FCB
 131+ 739A              BDOSReadFileBlockRandom:
 132+ 739A 3E 12        	ld	a, 18
 133+ 739C 18 04        	jr	BDOS
 134+ 739E
 135+ 739E              ;0 OK
 136+ 739E              ;2 Disc full
 137+ 739E              ;3 Cannot close extent
 138+ 739E              ;5 Directory full
 139+ 739E              ;6 Record number out of range
 140+ 739E              ;8 Record is locked by another process (MP/M)
 141+ 739E              ;9 Invalid FCB
 142+ 739E              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 739E              BDOSWriteFileBlockRandom:
 144+ 739E 3E 13        	ld	a, 19
 145+ 73A0 18 00        	jr	BDOS
 146+ 73A2
 147+ 73A2
 148+ 73A2              ;Generic BDOS call
 149+ 73A2              ;IX=arg, A=function
 150+ 73A2              BDOS:
 151+ 73A2 DD 22 ED 5C  	ld (HD11), ix
 152+ 73A6 32 EF 5C     	ld (COPIES), a
 153+ 73A9 CF           	rst 08
 154+ 73AA 39           	DEFB 57
 155+ 73AB C9           	ret
 156+ 73AC
 157+ 73AC              ;Set DMA address for BDOS
 158+ 73AC              ;IX=DMA
 159+ 73AC              BDOSSetDMA:
 160+ 73AC 3E 0D        	ld a, 13
 161+ 73AE 18 F2        	jr BDOS
 162+ 73B0
 163+ 73B0              ;In: IX=FCB
 164+ 73B0              BDOSSetRandFilePtr:
 165+ 73B0 3E 15        	ld	a, 21
 166+ 73B2 18 EE        	jr	BDOS
 167+ 73B4
 168+ 73B4              ;In: HL=filename
 169+ 73B4              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 73B4              GetFileSize:
 171+ 73B4              	IFUSED
 172+ 73B4
 173+ 73B4 3A 3E 73     	ld 		a, (RWTSDrive)
 174+ 73B7 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 73B8 CD 66 73     	call	CreateChannel
 176+ 73BB
 177+ 73BB 3E 14        	ld		a, 20
 178+ 73BD CD A2 73     	call	BDOS
 179+ 73C0              	;inc		a
 180+ 73C0              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 73C0
 182+ 73C0 DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 73C3 DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 73C6
 185+ 73C6              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 73C6 3E 01        	ld		a, 1
 187+ 73C8 BC           	cp		h
 188+ 73C9 30 05        	jr		nc, GetFileSizeOK
 189+ 73CB 21 00 00     	ld		hl, 0
 190+ 73CE 18 08        	jr		GetFileSizeEnd
 191+ 73D0
 192+ 73D0              GetFileSizeOK:
 193+ 73D0              	;*128 == 2^7
 194+ 73D0 06 07        	ld		b, 7
 195+ 73D2              GetFileSizeMul:
 196+ 73D2 CB 15        	rl		l
 197+ 73D4 CB 14        	rl		h
 198+ 73D6 10 FA        	djnz	GetFileSizeMul
 199+ 73D8
 200+ 73D8              GetFileSizeEnd:
 201+ 73D8 E5           	push	hl
 202+ 73D9 CD 7C 73     		call	DestroyChannel
 203+ 73DC E1           	pop		hl
 204+ 73DD
 205+ 73DD C9           	ret
 206+ 73DE              	ENDIF
 207+ 73DE
 208+ 73DE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 73DE              ;HL=file name, A=drive
 210+ 73DE              DeleteFile:
 211+ 73DE CD 66 73     	call	CreateChannel
 212+ 73E1
 213+ 73E1 3E 06        	ld		a, 6
 214+ 73E3 CD A2 73     	call	BDOS
 215+ 73E6
 216+ 73E6 CD 7C 73     	call	DestroyChannel
 217+ 73E9 C9           	ret
 218+ 73EA
 219+ 73EA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 73EA              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 73EA              ;HL=file name, A=drive
 222+ 73EA              DoesFileExist:
 223+ 73EA              	IFUSED
 224+ 73EA              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 73EA F5           	push	af
 226+ 73EB E5           	push	hl
 227+ 73EC DD 21 DC EE  		ld		ix, FileIdx
 228+ 73F0 CD AC 73     		call 	BDOSSetDMA
 229+ 73F3 E1           	pop		hl
 230+ 73F4 F1           	pop		af
 231+ 73F5
 232+ 73F5 CD 66 73     	call	CreateChannel
 233+ 73F8
 234+ 73F8              	;Uses FindFirst system call.
 235+ 73F8 3E 04        	ld		a, 4
 236+ 73FA CD A2 73     	call	BDOS
 237+ 73FD
 238+ 73FD F5           	push	af
 239+ 73FE CD 7C 73     		call	DestroyChannel
 240+ 7401 F1           	pop		af
 241+ 7402 C9           	ret
 242+ 7403              	ENDIF
 243+ 7403
 244+ 7403              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7403              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 7403              ChangeFileAttrib:
 247+ 7403 3A 3E 73     	ld 		a, (RWTSDrive)
 248+ 7406 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 7407 D5           	push	de
 250+ 7408 CD 66 73     	call	CreateChannel
 251+ 740B D1           	pop		de
 252+ 740C
 253+ 740C DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 740F CB 27        	sla		a								;reset existing attribute flag
 255+ 7411 CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 7413 CB 1F        	rr		a								;put Carry flag in register L
 257+ 7415 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 7418
 259+ 7418 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 741B CB 27        	sla		a
 261+ 741D CB 1B        	rr		e
 262+ 741F CB 1F        	rr		a
 263+ 7421 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 7424
 265+ 7424              FileAttribSet:
 266+ 7424 3E 11        	ld		a, 17
 267+ 7426 CD A2 73     	call	BDOS
 268+ 7429
 269+ 7429 CD 7C 73     	call	DestroyChannel
 270+ 742C C9           	ret
 271+ 742D
 272+ 742D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 742D
 274+ 742D              ;HL=original name, DE = new name
 275+ 742D              ;Works only on the same drive.
 276+ 742D              RenameFile:
 277+ 742D 3A 3E 73     	ld 		a, (RWTSDrive)
 278+ 7430 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 7431 D5           	push	de
 280+ 7432 CD 66 73     	call	CreateChannel
 281+ 7435 D1           	pop		de
 282+ 7436
 283+ 7436 DD E5        	push	ix					;IX == FCB
 284+ 7438 E1           	pop		hl
 285+ 7439 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 743C 09           	add		hl, bc
 287+ 743D EB           	ex		de, hl
 288+ 743E 3A 3E 73     	ld		a, (RWTSDrive)
 289+ 7441 12           	ld		(de), a
 290+ 7442 01 0B 00     	ld		bc, NAMELEN
 291+ 7445 ED B0        	ldir
 292+ 7447
 293+ 7447 3E 0A        	ld		a, 10
 294+ 7449 CD A2 73     	call	BDOS
 295+ 744C
 296+ 744C CD 7C 73     	call	DestroyChannel
 297+ 744F C9           	ret
 298+ 7450              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 7450              PromptDiskChangeDst:
 300+ 7450 21 15 80     	ld		hl, MsgInsertDstDsk
 301+ 7453 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 7456 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 7458 CD 0C 78     	call	PrintStrClr
 304+ 745B 21 24 80     	ld		hl, MsgPressAnyKey
 305+ 745E 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 7461 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 7463 CD 0C 78     	call	PrintStrClr
 308+ 7466 CD A8 77     	call	ReadChar
 309+ 7469 C9           	ret
 310+ 746A
 311+ 746A              PromptDiskChangeSrc:
 312+ 746A 21 06 80     	ld		hl, MsgInsertSrcDsk
 313+ 746D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 7470 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 7472 CD 0C 78     	call	PrintStrClr
 316+ 7475 21 24 80     	ld		hl, MsgPressAnyKey
 317+ 7478 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 747B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 747D CD 0C 78     	call	PrintStrClr
 320+ 7480 CD A8 77     	call	ReadChar
 321+ 7483 C9           	ret
 322+ 7484              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 7484
 324+ 7484              ;HL = source file name, A = source drive
 325+ 7484              ;Use cases:
 326+ 7484              ;1. Copy from A: to B: or B: to A:.
 327+ 7484              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 7484              ;3. Copy from A:/B: to COM.
 329+ 7484              ;4. Copy from COM to A:/B:.
 330+ 7484              ;Single drive scenario:
 331+ 7484              ;1. Read first file part,
 332+ 7484              ;2. Ask for dest disk,
 333+ 7484              ;3. check if file exists/ask for overwrite,
 334+ 7484              ;4. create empty dest file,
 335+ 7484              ;5. write first file part,
 336+ 7484              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 7484              CopyFile:
 338+ 7484 3A 3E 73     	ld 		a, (RWTSDrive)
 339+ 7487 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 7488 32 A6 80     	ld		(CopyFileSrcDrv), a
 341+ 748B 32 B2 80     	ld		(CopyFileDstDrv), a
 342+ 748E 11 A7 80     	ld		de, CopyFileSrcName
 343+ 7491 01 0B 00     	ld		bc, NAMELEN
 344+ 7494 E5           	push	hl
 345+ 7495 C5           	push	bc
 346+ 7496 ED B0        	ldir
 347+ 7498 C1           	pop		bc
 348+ 7499 E1           	pop		hl
 349+ 749A 11 B3 80     	ld		de, CopyFileDstName
 350+ 749D ED B0        	ldir
 351+ 749F
 352+ 749F              	;Reset R/O attribute for destination, to allow file write.
 353+ 749F 3A BB 80     	ld		a, (CopyFileDstName+RO_POS)
 354+ 74A2 CB BF        	res		7, a
 355+ 74A4 32 BB 80     	ld		(CopyFileDstName+RO_POS), a
 356+ 74A7
 357+ 74A7 AF           	xor		a
 358+ 74A8 32 9E 80     	ld		(CopyFileRes), a
 359+ 74AB 11 00 00     	ld		de, 0
 360+ 74AE ED 53 A1 80  	ld		(FilePosRead), de
 361+ 74B2 ED 53 A3 80  	ld		(FilePosWrite), de
 362+ 74B6
 363+ 74B6 3A A6 80     	ld		a, (CopyFileSrcDrv)
 364+ 74B9 C6 40        	add		'A'-1
 365+ 74BB              	;Update menu messages with current drive.
 366+ 74BB 32 8F 7F     	ld		(MsgMenuSingleDrv1), a
 367+ 74BE 32 93 7F     	ld		(MsgMenuSingleDrv2), a
 368+ 74C1 32 9D 7F     	ld		(MsgMenuDualDrv1), a
 369+ 74C4 32 AB 7F     	ld		(MsgMenuToComDrv), a
 370+ 74C7 32 BF 7F     	ld		(MsgMenuFromCOMDrv), a
 371+ 74CA              	;Update menu messages with the alternate drive.
 372+ 74CA 3A A6 80     	ld		a, (CopyFileSrcDrv)
 373+ 74CD EE 03        	xor		%11
 374+ 74CF C6 40        	add		'A'-1
 375+ 74D1 32 A1 7F     	ld		(MsgMenuDualDrv2), a
 376+ 74D4
 377+ 74D4 21 6C 7F     	ld		hl, MsgMenuFileCopy
 378+ 74D7 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 74DA 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 74DC CD 0C 78     	call	PrintStrClr
 381+ 74DF 21 7B 7F     	ld		hl, MsgMenuBack
 382+ 74E2 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 74E5 CD E4 77     	call	PrintStr
 384+ 74E8 21 87 7F     	ld		hl, MsgMenuSingle
 385+ 74EB 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 74EE CD E4 77     	call	PrintStr
 387+ 74F1 21 95 7F     	ld		hl, MsgMenuDual
 388+ 74F4 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 74F7 CD E4 77     	call	PrintStr
 390+ 74FA 21 A3 7F     	ld		hl, MsgMenuToCOM
 391+ 74FD 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 7500 CD E4 77     	call	PrintStr
 393+ 7503 21 B2 7F     	ld		hl, MsgMenuFromCOM
 394+ 7506 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 7509 CD E4 77     	call	PrintStr
 396+ 750C
 397+ 750C CD A8 77     	call	ReadChar
 398+ 750F 32 9B 80     	ld		(CopySelOption), a
 399+ 7512
 400+ 7512 F5           	push	af
 401+ 7513 06 06        		ld		b, 6
 402+ 7515 CD 90 79     		call	ClearNMsgLines
 403+ 7518 F1           	pop		af
 404+ 7519
 405+ 7519              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 7519 FE 30        	cp		'0'
 407+ 751B 20 04        	jr		nz, CopyFileNotExit
 408+ 751D E1           	pop		hl
 409+ 751E C3 44 67     	jp		ReadKeyLoop
 410+ 7521
 411+ 7521              CopyFileNotExit:
 412+ 7521 FE 31        	cp		'1'
 413+ 7523 28 4D        	jr		z, CopyFileSameDrive
 414+ 7525
 415+ 7525 FE 32        	cp		'2'
 416+ 7527 CA F1 75     	jp		z, CopyFileDualDrive
 417+ 752A
 418+ 752A FE 33        	cp		'3'
 419+ 752C CA 3B 76     	jp		z, CopyFileToCOM
 420+ 752F
 421+ 752F FE 34        	cp		'4'
 422+ 7531 CA 6E 76     	jp		z, CopyFileFromCOM
 423+ 7534
 424+ 7534 E1           	pop		hl
 425+ 7535 C3 44 67     	jp		ReadKeyLoop
 426+ 7538
 427+ 7538
 428+ 7538              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 7538              CopyFileCheckOverwrite:
 430+ 7538              	;Check if destination file exists.
 431+ 7538 3A B2 80     	ld		a, (CopyFileDstDrv)
 432+ 753B 21 B3 80     	ld		hl, CopyFileDstName
 433+ 753E CD EA 73     	call	DoesFileExist
 434+ 7541 3C           	inc		a
 435+ 7542 C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 7543
 437+ 7543              	;Ask overwrite confirmation.
 438+ 7543 21 E8 7F     	ld		hl, MsgFileOverwrite
 439+ 7546 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 7549 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 754B CD 0C 78     	call	PrintStrClr
 442+ 754E CD A8 77     	call	ReadChar
 443+ 7551 FE 79        	cp		'y'
 444+ 7553 C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 7554
 446+ 7554
 447+ 7554              CopyFileCreateNewFile:
 448+ 7554 3A B2 80     	ld		a, (CopyFileDstDrv)
 449+ 7557 21 B3 80     	ld		hl, CopyFileDstName
 450+ 755A F5           	push	af
 451+ 755B E5           	push	hl
 452+ 755C CD DE 73     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 755F E1           	pop		hl
 454+ 7560 F1           	pop		af
 455+ 7561 CD 66 73     	call	CreateChannel
 456+ 7564 CD 86 73     	call 	BDOSCreateFile
 457+ 7567 3C           	inc  	a						;Cancel if A==$FF
 458+ 7568 C8           	ret		z
 459+ 7569
 460+ 7569              	;Close dest file once created.
 461+ 7569 F5           	push	af
 462+ 756A CD 8E 73     		call	BDOSCloseFile
 463+ 756D CD 7C 73     		call	DestroyChannel
 464+ 7570 F1           	pop		af
 465+ 7571 C9           	ret
 466+ 7572
 467+ 7572              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 7572              CopyFileSameDrive:
 469+ 7572              	;Read first file section from SRC.
 470+ 7572 3A A6 80     	ld		a, (CopyFileSrcDrv)
 471+ 7575 21 A7 80     	ld		hl, CopyFileSrcName
 472+ 7578 06 60        	ld		b, MAX_SECT_BUF
 473+ 757A CD F1 76     	call	ReadFileSection
 474+ 757D 3A A5 80     	ld		a, (CopyFileSectCnt)
 475+ 7580 B7           	or		a
 476+ 7581 C8           	ret		z
 477+ 7582
 478+ 7582              	;Prompt for DST disk change.
 479+ 7582 CD 50 74     	call	PromptDiskChangeDst
 480+ 7585 3A 3E 73     	ld		a, (RWTSDrive)
 481+ 7588 CD 56 73     	call	BDOSInit
 482+ 758B
 483+ 758B 06 02        	ld		b, 2
 484+ 758D CD 90 79     	call	ClearNMsgLines
 485+ 7590
 486+ 7590 CD 38 75     	call	CopyFileCheckOverwrite
 487+ 7593 C0           	ret		nz
 488+ 7594
 489+ 7594 CD 54 75     	call	CopyFileCreateNewFile
 490+ 7597 C8           	ret		z
 491+ 7598
 492+ 7598              CopyFileSameDriveLoop:
 493+ 7598 3A A5 80     	ld		a, (CopyFileSectCnt)
 494+ 759B 6F           	ld		l, a
 495+ 759C 26 00        	ld		h, 0
 496+ 759E 11 31 80     	ld		de, MsgCopySectors
 497+ 75A1 CD 79 6E     	call	Byte2Txt
 498+ 75A4 21 31 80     	ld		hl, MsgCopySectors
 499+ 75A7 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500+ 75AA 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501+ 75AC CD 0C 78     	call	PrintStrClr
 502+ 75AF
 503+ 75AF 3A 9E 80     	ld		a, (CopyFileRes)			;Save read status code.
 504+ 75B2 F5           	push	af
 505+ 75B3 3A B2 80     		ld		a, (CopyFileDstDrv)
 506+ 75B6 21 B3 80     		ld		hl, CopyFileDstName
 507+ 75B9 CD 16 77     		call	WriteFileSection
 508+ 75BC 3A 9E 80     		ld		a, (CopyFileRes)
 509+ 75BF 6F           		ld		l, a
 510+ 75C0 F1           	pop		af
 511+ 75C1 B5           	or		l
 512+ 75C2 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 513+ 75C3
 514+ 75C3
 515+ 75C3              	;Prompt for SRC disk change.
 516+ 75C3 CD 6A 74     	call	PromptDiskChangeSrc
 517+ 75C6 3A 3E 73     	ld		a, (RWTSDrive)
 518+ 75C9 CD 56 73     	call	BDOSInit
 519+ 75CC
 520+ 75CC 06 02        	ld		b, 2
 521+ 75CE CD 90 79     	call	ClearNMsgLines
 522+ 75D1
 523+ 75D1 3A A6 80     	ld		a, (CopyFileSrcDrv)
 524+ 75D4 21 A7 80     	ld		hl, CopyFileSrcName
 525+ 75D7 06 60        	ld		b, MAX_SECT_BUF
 526+ 75D9 CD F1 76     	call	ReadFileSection
 527+ 75DC 3A A5 80     	ld		a, (CopyFileSectCnt)
 528+ 75DF B7           	or		a
 529+ 75E0 C8           	ret		z
 530+ 75E1
 531+ 75E1              	;Prompt for DST disk change.
 532+ 75E1 CD 50 74     	call	PromptDiskChangeDst
 533+ 75E4 3A 3E 73     	ld		a, (RWTSDrive)
 534+ 75E7 CD 56 73     	call	BDOSInit
 535+ 75EA
 536+ 75EA 06 02        	ld		b, 2
 537+ 75EC CD 90 79     	call	ClearNMsgLines
 538+ 75EF
 539+ 75EF 18 A7        	jr		CopyFileSameDriveLoop
 540+ 75F1
 541+ 75F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 542+ 75F1
 543+ 75F1              CopyFileDualDrive:
 544+ 75F1 3A A6 80     	ld		a, (CopyFileSrcDrv)
 545+ 75F4 EE 03        	xor		%11
 546+ 75F6 32 B2 80     	ld		(CopyFileDstDrv), a
 547+ 75F9
 548+ 75F9 CD 38 75     	call	CopyFileCheckOverwrite
 549+ 75FC C0           	ret		nz
 550+ 75FD
 551+ 75FD CD 54 75     	call	CopyFileCreateNewFile
 552+ 7600 C8           	ret		z
 553+ 7601
 554+ 7601              CopyFileDualDriveLoop:
 555+ 7601 3A A6 80     	ld		a, (CopyFileSrcDrv)
 556+ 7604 21 A7 80     	ld		hl, CopyFileSrcName
 557+ 7607 06 60        	ld		b, MAX_SECT_BUF
 558+ 7609 CD F1 76     	call	ReadFileSection
 559+ 760C 3A A5 80     	ld		a, (CopyFileSectCnt)
 560+ 760F B7           	or		a
 561+ 7610 C8           	ret		z
 562+ 7611
 563+ 7611 3A A5 80     	ld		a, (CopyFileSectCnt)
 564+ 7614 6F           	ld		l, a
 565+ 7615 26 00        	ld		h, 0
 566+ 7617 11 31 80     	ld		de, MsgCopySectors
 567+ 761A CD 79 6E     	call	Byte2Txt
 568+ 761D 21 31 80     	ld		hl, MsgCopySectors
 569+ 7620 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 570+ 7623 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 571+ 7625
 572+ 7625 3A 9E 80     	ld		a, (CopyFileRes)
 573+ 7628 F5           	push	af
 574+ 7629 3A B2 80     		ld		a, (CopyFileDstDrv)
 575+ 762C 21 B3 80     		ld		hl, CopyFileDstName
 576+ 762F CD 16 77     		call	WriteFileSection
 577+ 7632 3A 9E 80     		ld		a, (CopyFileRes)
 578+ 7635 6F           		ld		l, a
 579+ 7636 F1           	pop		af
 580+ 7637 B5           	or		l
 581+ 7638 C0           	ret		nz
 582+ 7639
 583+ 7639 18 C6        	jr		CopyFileDualDriveLoop
 584+ 763B
 585+ 763B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 586+ 763B              CopyFileToCOM:
 587+ 763B AF           	xor		a
 588+ 763C 32 9E 80     	ld		(CopyFileRes), a
 589+ 763F 32 A5 80     	ld		(CopyFileSectCnt), a
 590+ 7642 11 00 00     	ld		de, 0
 591+ 7645 ED 53 A1 80  	ld		(FilePosRead), de
 592+ 7649
 593+ 7649              CopyFileToCOMLoop:
 594+ 7649 3A A6 80     	ld		a, (CopyFileSrcDrv)
 595+ 764C 21 A7 80     	ld		hl, CopyFileSrcName
 596+ 764F 06 60        	ld		b, MAX_SECT_BUF
 597+ 7651 CD F1 76     	call	ReadFileSection
 598+ 7654
 599+ 7654 3A A5 80     	ld		a, (CopyFileSectCnt)
 600+ 7657 B7           	or		a
 601+ 7658 28 0F        	jr		z, CopyFileToCOMEnd
 602+ 765A
 603+ 765A              	;Send buffer to COM port.
 604+ 765A 21 DC 8E     	ld		hl, FileData
 605+ 765D 47           	ld		b, a					;Sector size is 256.
 606+ 765E 0E 00        	ld		c, 0
 607+ 7660 CD 90 7C     	call	SERTB
 608+ 7663
 609+ 7663 3A 9E 80     	ld		a, (CopyFileRes)
 610+ 7666 B7           	or		a
 611+ 7667 28 E0        	jr		z, CopyFileToCOMLoop
 612+ 7669
 613+ 7669              CopyFileToCOMEnd:
 614+ 7669              	;Reset read error code, as 1 is returned when file is finished reading.
 615+ 7669 AF           	xor		a
 616+ 766A 32 9E 80     	ld		(CopyFileRes), a
 617+ 766D
 618+ 766D C9           	ret
 619+ 766E
 620+ 766E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 621+ 766E              CopyFileFromCOM:
 622+ 766E AF           	xor		a
 623+ 766F 32 9E 80     	ld		(CopyFileRes), a
 624+ 7672 11 00 00     	ld		de, 0
 625+ 7675 ED 53 A3 80  	ld		(FilePosWrite), de
 626+ 7679
 627+ 7679              	;Must ask for the new file name and check to not exist.
 628+ 7679 21 52 7F     	ld		hl, MsgNewFileName
 629+ 767C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 630+ 767F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 631+ 7681 CD 0C 78     	call	PrintStrClr
 632+ 7684
 633+ 7684 21 1D 7F     	ld		hl, MsgClear
 634+ 7687 11 DC 8E     	ld		de, FileData
 635+ 768A 01 0B 00     	ld		bc, NAMELEN
 636+ 768D ED B0        	ldir
 637+ 768F 3E A0        	ld		a, $80 | ' '
 638+ 7691 12           	ld		(de), a
 639+ 7692 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 7695 21 DC 8E     	ld		hl, FileData
 641+ 7698 CD E4 77     	call	PrintStr
 642+ 769B
 643+ 769B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 644+ 769E 01 0B 00     	ld		bc, NAMELEN
 645+ 76A1 CD 4E 79     	call	ReadString
 646+ 76A4
 647+ 76A4 11 DC 8E     	ld		de, FileData
 648+ 76A7 1A           	ld		a, (de)
 649+ 76A8 FE 20        	cp		' '					;If starting with space, input was canceled.
 650+ 76AA C8           	ret		z
 651+ 76AB
 652+ 76AB              	;Copy new file name
 653+ 76AB 21 DC 8E     	ld		hl, FileData
 654+ 76AE 11 B3 80     	ld		de, CopyFileDstName
 655+ 76B1 01 0B 00     	ld		bc, NAMELEN
 656+ 76B4 ED B0        	ldir
 657+ 76B6
 658+ 76B6              	;Check if new name doesn't exist already.
 659+ 76B6 3A A6 80     	ld		a, (CopyFileSrcDrv)
 660+ 76B9 21 B3 80     	ld		hl, CopyFileDstName
 661+ 76BC CD 38 75     	call	CopyFileCheckOverwrite
 662+ 76BF C0           	ret		nz
 663+ 76C0
 664+ 76C0              	;Delete and re-create empty destination file
 665+ 76C0 3A A6 80     	ld		a, (CopyFileSrcDrv)
 666+ 76C3 21 B3 80     	ld		hl, CopyFileDstName
 667+ 76C6 CD 54 75     	call	CopyFileCreateNewFile
 668+ 76C9 C8           	ret		z
 669+ 76CA
 670+ 76CA              CopyFileFromCOMLoop:
 671+ 76CA 21 DC 8E     	ld		hl, FileData
 672+ 76CD 01 00 60     	ld		bc, FileDataSize
 673+ 76D0 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 674+ 76D2 CD 5D 7C     	call	SERRB				;BC = Number of bytes read from COM
 675+ 76D5 79           	ld		a, c
 676+ 76D6 B0           	or		b
 677+ 76D7 C8           	ret		z
 678+ 76D8
 679+ 76D8              	;If C is not 0, add one more sector.
 680+ 76D8 79           	ld 		a, c
 681+ 76D9 B7           	or		a
 682+ 76DA 28 01        	jr		z, CopyFileFromCOMDontInc
 683+ 76DC 04           	inc		b
 684+ 76DD              CopyFileFromCOMDontInc:
 685+ 76DD 78           	ld		a, b				;Sector size is 256
 686+ 76DE 32 A5 80     	ld		(CopyFileSectCnt), a
 687+ 76E1 3A B2 80     	ld		a, (CopyFileDstDrv)
 688+ 76E4 21 B3 80     	ld		hl, CopyFileDstName
 689+ 76E7 CD 16 77     	call	WriteFileSection
 690+ 76EA
 691+ 76EA 3A 9E 80     	ld		a, (CopyFileRes)
 692+ 76ED B7           	or		a
 693+ 76EE 28 DA        	jr		z, CopyFileFromCOMLoop
 694+ 76F0
 695+ 76F0 C9           	ret
 696+ 76F1
 697+ 76F1              ;Reads/Writes disk file portion to/from memory.
 698+ 76F1              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 699+ 76F1              ;This should work with single-drive file copy from one disk to another.
 700+ 76F1              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records, B = max sectors to read
 701+ 76F1              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 702+ 76F1              ;
 703+ 76F1              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 704+ 76F1              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 705+ 76F1              ;Must use sequential read/write. But for the first operation must use random read/write.
 706+ 76F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 76F1              ReadFileSection:
 708+ 76F1 11 9A 73     	ld		de, BDOSReadFileBlockRandom
 709+ 76F4 ED 53 5E 77  	ld		(CopyFileOperAddr1), de
 710+ 76F8 11 92 73     	ld		de, BDOSReadFileBlockSeq
 711+ 76FB ED 53 7D 77  	ld		(CopyFileOperAddr2), de
 712+ 76FF 11 A1 80     	ld		de, FilePosRead
 713+ 7702 ED 53 55 77  	ld		(CopyFilePtr), de
 714+ 7706 ED 53 9A 77  	ld		(CopyFilePtr2), de
 715+ 770A
 716+ 770A              	;Limit max sectors to read to leave space for the index too.
 717+ 770A F5           	push	af
 718+ 770B 78           		ld		a, b
 719+ 770C 32 A5 80     		ld		(CopyFileSectCnt), a
 720+ 770F C5           		push	bc
 721+ 7710 D9           		exx
 722+ 7711 C1           		pop		bc
 723+ 7712 D9           		exx
 724+ 7713 F1           	pop		af
 725+ 7714 18 19        	jr		ReadWriteFileSection
 726+ 7716
 727+ 7716              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 728+ 7716
 729+ 7716              WriteFileSection:
 730+ 7716 11 9E 73     	ld		de, BDOSWriteFileBlockRandom
 731+ 7719 ED 53 5E 77  	ld		(CopyFileOperAddr1), de
 732+ 771D 11 96 73     	ld		de, BDOSWriteFileBlockSeq
 733+ 7720 ED 53 7D 77  	ld		(CopyFileOperAddr2), de
 734+ 7724 11 A3 80     	ld		de, FilePosWrite
 735+ 7727 ED 53 55 77  	ld		(CopyFilePtr), de
 736+ 772B ED 53 9A 77  	ld		(CopyFilePtr2), de
 737+ 772F
 738+ 772F
 739+ 772F              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 740+ 772F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 741+ 772F              ReadWriteFileSection:
 742+ 772F CD 66 73     	call	CreateChannel
 743+ 7732 DD 22 9C 80  	ld		(CopyFileFCB), ix
 744+ 7736 CD 8A 73     	call 	BDOSOpenFile
 745+ 7739 3C           	inc  	a						;Cancel if A==$FF
 746+ 773A C8           	ret		z
 747+ 773B
 748+ 773B              	;Set DMA initial pointer = FileData
 749+ 773B DD E5        	push	ix
 750+ 773D 21 DC 8E     		ld		hl, FileData
 751+ 7740 DD 21 9F 80  		ld		ix, CopyFileDMAAddr
 752+ 7744 DD 75 00     		ld		(ix), l
 753+ 7747 DD 74 01     		ld		(ix+1), h
 754+ 774A DD 21 DC 8E  		ld		ix, FileData
 755+ 774E CD AC 73     		call 	BDOSSetDMA
 756+ 7751 DD E1        	pop		ix
 757+ 7753
 758+ 7753              CopyFilePtr EQU $+2
 759+ 7753              	;Update file pointer using read/write random call.
 760+ 7753 ED 5B A1 80  	ld		de, (FilePosRead)
 761+ 7757 DD 73 21     	ld		(ix + FCB_R0), e
 762+ 775A DD 72 22     	ld		(ix + FCB_R1), d
 763+ 775D              CopyFileOperAddr1 EQU $ + 1
 764+ 775D CD 9A 73     	call 	BDOSReadFileBlockRandom
 765+ 7760
 766+ 7760 32 9E 80     	ld		(CopyFileRes), a
 767+ 7763 B7           	or		a
 768+ 7764 20 22        	jr		nz, ReadWriteFileSectionEnd
 769+ 7766
 770+ 7766 3A A5 80     	ld		a, (CopyFileSectCnt)
 771+ 7769 47           	ld		b, a
 772+ 776A
 773+ 776A              ReadWriteFileSectionLoop:
 774+ 776A C5           	push	bc
 775+ 776B DD 2A 9F 80  		ld		ix, (CopyFileDMAAddr)
 776+ 776F CD AC 73     		call 	BDOSSetDMA
 777+ 7772 DD 24        		inc		ixh
 778+ 7774 DD 22 9F 80  		ld		(CopyFileDMAAddr), ix
 779+ 7778
 780+ 7778 DD 2A 9C 80  		ld		ix, (CopyFileFCB)
 781+ 777C              CopyFileOperAddr2 EQU $ + 1
 782+ 777C CD 92 73     		call 	BDOSReadFileBlockSeq
 783+ 777F 32 9E 80     		ld		(CopyFileRes), a
 784+ 7782 C1           	pop		bc
 785+ 7783 B7           	or		a
 786+ 7784 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 787+ 7786 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 788+ 7788
 789+ 7788              ReadWriteFileSectionEnd:
 790+ 7788              	;Update sector count variable with how many sectors were transfered.
 791+ 7788 D9           	exx
 792+ 7789 78           	ld		a, b
 793+ 778A D9           	exx
 794+ 778B 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 795+ 778C 32 A5 80     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 796+ 778F
 797+ 778F              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 798+ 778F CD B0 73     	call	BDOSSetRandFilePtr
 799+ 7792 DD 5E 21     	ld		e, (ix + FCB_R0)
 800+ 7795 DD 56 22     	ld		d, (ix + FCB_R1)
 801+ 7798              CopyFilePtr2 EQU $+2
 802+ 7798 ED 53 A1 80  	ld		(FilePosRead), de
 803+ 779C
 804+ 779C CD 8E 73     	call 	BDOSCloseFile
 805+ 779F CD 7C 73     	call 	DestroyChannel
 806+ 77A2
 807+ 77A2 ED 5B 9F 80  	ld		de, (CopyFileDMAAddr)
 808+ 77A6 15           	dec		d
 809+ 77A7 C9           	ret
 810+ 77A8
 811+ 77A8              	ENDIF
 812+ 77A8
# file closed: bdos.asm
1446  77A8              	include "ui.asm"
# file opened: ui.asm
   1+ 77A8              ;UI related functions
   2+ 77A8
   3+ 77A8              	ifndef	_UI_
   4+ 77A8              	define	_UI_
   5+ 77A8
   6+ 77A8              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++77A8              	ifndef	_HCCFG_
   2++77A8 ~            	define	_HCCFG_
   3++77A8 ~
   4++77A8 ~            ;HC specific code, for configuration
   5++77A8 ~
   6++77A8 ~            HC_CFG_PORT			EQU	$7E
   7++77A8 ~            HC_FLOPPY_PORT		EQU 7
   8++77A8 ~
   9++77A8 ~            ;BASIC/CPM ROM selection
  10++77A8 ~            HC_CFG_ROM_BAS		EQU	%0
  11++77A8 ~            HC_CFG_ROM_CPM		EQU	%1
  12++77A8 ~
  13++77A8 ~            ;Address for ROM paging: 0 or $E000
  14++77A8 ~            HC_CFG_ROM_0000		EQU %00
  15++77A8 ~            HC_CFG_ROM_E000		EQU %10
  16++77A8 ~
  17++77A8 ~            ;Cfg. port Enable/Disable
  18++77A8 ~            HC_CFG_PORT_DIS		EQU %000
  19++77A8 ~            HC_CFG_PORT_EN		EQU	%100
  20++77A8 ~
  21++77A8 ~            ;Video memory bank: $4000 or $C000
  22++77A8 ~            HC_CFG_VID_4000		EQU	%0000
  23++77A8 ~            HC_CFG_VID_C000		EQU	%1000
  24++77A8 ~
  25++77A8 ~
  26++77A8 ~            ;Standar BASIC config
  27++77A8 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++77A8 ~            ;Standar CP/M config
  29++77A8 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++77A8 ~
  31++77A8 ~
  32++77A8 ~            HC_VID_BANK0		EQU	$4000
  33++77A8 ~            HC_VID_BANK1		EQU	$C000
  34++77A8 ~
  35++77A8 ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++77A8 ~            ;Info from Rares Atodiresei.
  37++77A8 ~            IsDrive2_80Tracks:
  38++77A8 ~            	IFUSED
  39++77A8 ~            	in	a, (HC_FLOPPY_PORT)
  40++77A8 ~            	and %10
  41++77A8 ~            	ret
  42++77A8 ~            	ENDIF
  43++77A8 ~
  44++77A8              	endif
# file closed: hccfg.asm
   7+ 77A8
   8+ 77A8              COL             EQU 23728
   9+ 77A8              LINE            EQU 23729               ;Coordinates
  10+ 77A8              LineCol			EQU	COL
  11+ 77A8              CODE			EQU 23681               ;Char to print
  12+ 77A8
  13+ 77A8              CPM_FNT         EQU $25AB
  14+ 77A8
  15+ 77A8              PORT_ZX			EQU	$FE
  16+ 77A8
  17+ 77A8              ;COLORS
  18+ 77A8              CLR_BLACK		EQU 0
  19+ 77A8              CLR_BLUE		EQU 1
  20+ 77A8              CLR_RED			EQU 2
  21+ 77A8              CLR_MAGENTA		EQU 3
  22+ 77A8              CLR_GREEN		EQU 4
  23+ 77A8              CLR_CYAN		EQU	5
  24+ 77A8              CLR_YELLOW		EQU	6
  25+ 77A8              CLR_WHITE		EQU	7
  26+ 77A8              CLR_BRIGHT		EQU	%01000000
  27+ 77A8              CLR_FLASH		EQU	%10000000
  28+ 77A8
  29+ 77A8              ;PAPER
  30+ 77A8              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 77A8              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 77A8              PAPER_RED		EQU (CLR_RED << 3)
  33+ 77A8              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 77A8              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 77A8              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 77A8              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 77A8              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 77A8
  39+ 77A8              ;INK
  40+ 77A8              INK_BLACK		EQU CLR_BLACK
  41+ 77A8              INK_BLUE		EQU CLR_BLUE
  42+ 77A8              INK_RED			EQU CLR_RED
  43+ 77A8              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 77A8              INK_GREEN		EQU CLR_GREEN
  45+ 77A8              INK_CYAN		EQU	CLR_CYAN
  46+ 77A8              INK_YELLOW		EQU	CLR_YELLOW
  47+ 77A8              INK_WHITE		EQU	CLR_WHITE
  48+ 77A8
  49+ 77A8
  50+ 77A8              SCR_ATTR_ADDR	EQU 22528
  51+ 77A8              SCR_ADDR		EQU 16384
  52+ 77A8              SCR_PIX_LEN		EQU	6144
  53+ 77A8              SCR_ATTR_LEN	EQU	768
  54+ 77A8              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 77A8              SCR_BYTES_PER_LINE	EQU	32
  56+ 77A8
  57+ 77A8              SCR_COLS		EQU	64
  58+ 77A8              SCR_LINES		EQU 24
  59+ 77A8
  60+ 77A8              ;used for file names list positioning
  61+ 77A8              LST_LINES_CNT	EQU	21
  62+ 77A8              LST_FIRST_LINE	EQU	1
  63+ 77A8              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 77A8              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 77A8              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 77A8              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 77A8              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 77A8              LST_FIRST_COL	EQU	16
  69+ 77A8              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 77A8
  71+ 77A8              ;key codes
  72+ 77A8              KEY_ESC			EQU	7
  73+ 77A8              KEY_LEFT		EQU	8
  74+ 77A8              KEY_RIGHT		EQU	9
  75+ 77A8              KEY_DOWN		EQU	10
  76+ 77A8              KEY_UP			EQU	11
  77+ 77A8              KEY_BACKSP		EQU 12
  78+ 77A8              KEY_ENTER		EQU	13
  79+ 77A8              KEY_CTRL		EQU	14
  80+ 77A8
  81+ 77A8              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 77A8              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 77A8              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 77A8
  85+ 77A8              ;Special formating chars
  86+ 77A8              CHR_CR			EQU	13
  87+ 77A8              CHR_LF			EQU	10
  88+ 77A8              CHR_TAB			EQU	09
  89+ 77A8
  90+ 77A8
  91+ 77A8              ;Semi-graphical chars
  92+ 77A8              ;           UC
  93+ 77A8              ;     UL +H-+--+UR
  94+ 77A8              ;        |  |  |
  95+ 77A8              ;     ML +--+--+MR
  96+ 77A8              ;        V C|  |
  97+ 77A8              ;     LL +--+--+LR
  98+ 77A8              ;           DC
  99+ 77A8              CHR_GRID        EQU 127
 100+ 77A8              CHR_V           EQU	128
 101+ 77A8              CHR_MR          EQU	129
 102+ 77A8              CHR_UR          EQU 130
 103+ 77A8              CHR_DL          EQU 131
 104+ 77A8              CHR_DC          EQU 132
 105+ 77A8              CHR_UC          EQU 133
 106+ 77A8              CHR_ML          EQU 134
 107+ 77A8              CHR_H           EQU 135
 108+ 77A8              CHR_C           EQU 136
 109+ 77A8              CHR_LR          EQU 137
 110+ 77A8              CHR_UL          EQU 138
 111+ 77A8              CHR_FULL        EQU 139
 112+ 77A8              CHR_HALF        EQU 140
 113+ 77A8
 114+ 77A8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 77A8
 116+ 77A8              ;Return read char in A
 117+ 77A8              ReadChar:
 118+ 77A8 CF           	rst 08
 119+ 77A9 1B           	DEFB 27
 120+ 77AA C9           	ret
 121+ 77AB
 122+ 77AB              ;Checks if a key is pressed
 123+ 77AB              ;Cy=1 if key is pressed
 124+ 77AB              KbdHit:
 125+ 77AB CF           	rst 08
 126+ 77AC 20           	DEFB 32
 127+ 77AD C9           	ret
 128+ 77AE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 77AE
 130+ 77AE              InitFonts:
 131+ 77AE              	IFUSED
 132+ 77AE                  ;page-in CPM ROM to get fonts
 133+ 77AE F3               di
 134+ 77AF 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 77B1 D3 7E            out	(HC_CFG_PORT), a
 136+ 77B3
 137+ 77B3 21 AB 25     	ld		hl, CPM_FNT
 138+ 77B6 11 74 8B     	ld		de, FontTable
 139+ 77B9 01 68 03     	ld		bc, 872
 140+ 77BC ED B0        	ldir
 141+ 77BE
 142+ 77BE                  ;restore BASIC ROM
 143+ 77BE 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 77C0 D3 7E            out	(HC_CFG_PORT), a
 145+ 77C2 FB               ei
 146+ 77C3
 147+ 77C3 C9           	ret
 148+ 77C4              	ENDIF
 149+ 77C4
 150+ 77C4              ClrScr:
 151+ 77C4 2A A3 79     	ld		hl, (CurrScrAddr)
 152+ 77C7 54           	ld		d, h
 153+ 77C8 5D           	ld		e, l
 154+ 77C9 13           	inc		de
 155+ 77CA 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 77CD 36 00        	ld		(hl), 0
 157+ 77CF ED B0        	ldir
 158+ 77D1
 159+ 77D1 23           	inc 	hl
 160+ 77D2 13           	inc		de
 161+ 77D3
 162+ 77D3 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 77D6 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 77D8 ED B0        	ldir
 165+ 77DA
 166+ 77DA              	;also set border color
 167+ 77DA 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 77DC D3 FE        	out		(PORT_ZX), a
 169+ 77DE
 170+ 77DE 3E 45        	ld		a, SCR_DEF_CLR
 171+ 77E0 32 48 5C     	ld		(23624), a
 172+ 77E3 C9           	ret
 173+ 77E4
 174+ 77E4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 77E4              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 77E4              PrintStr:
 177+ 77E4 7E           	ld		a, (hl)
 178+ 77E5 FE 20        	cp		' '
 179+ 77E7 30 02        	jr		nc, GoodChar
 180+ 77E9 3E 3F        	ld		a, '?'
 181+ 77EB              GoodChar:
 182+ 77EB CB 7F        	bit		7, a
 183+ 77ED CB BF        	res		7, a
 184+ 77EF 32 81 5C     	ld		(CODE), a
 185+ 77F2 ED 53 B0 5C  	ld		(LineCol), de
 186+ 77F6 08           	ex		af, af'
 187+ 77F7 D9           	exx
 188+ 77F8 E5           	push	hl
 189+ 77F9 CD 10 79     	call 	PrintChar
 190+ 77FC E1           	pop		hl
 191+ 77FD D9           	exx
 192+ 77FE 08           	ex		af, af'
 193+ 77FF C0           	ret		nz
 194+ 7800
 195+ 7800 1C           	inc		e
 196+ 7801 23           	inc		hl
 197+ 7802
 198+ 7802 7B           	ld		a, e
 199+ 7803 FE 40        	cp		64
 200+ 7805 38 DD        	jr		c, PrintStr
 201+ 7807 1E 00        	ld		e, 0
 202+ 7809 14           	inc		d
 203+ 780A
 204+ 780A 18 D8        	jr		PrintStr
 205+ 780C
 206+ 780C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 780C
 208+ 780C              ;IN: HL = string, DE = coords, A = color
 209+ 780C              PrintStrClr:
 210+ 780C 32 38 78     	ld		(StrClr), a
 211+ 780F D5           	push	de
 212+ 7810 CD E4 77     		call	PrintStr
 213+ 7813 E1           	pop		hl
 214+ 7814              	;get string len.
 215+ 7814 7B           	ld		a, e
 216+ 7815 95           	sub		l
 217+ 7816 1F           	rra
 218+ 7817 08           	ex		af, af'
 219+ 7818              		;line * 32
 220+ 7818 7C           		ld		a, h
 221+ 7819 17           		rla
 222+ 781A 17           		rla
 223+ 781B 11 00 00     		ld	de, 0
 224+ 781E 17           		rla
 225+ 781F CB 12        		rl	d
 226+ 7821 17           		rla
 227+ 7822 CB 12        		rl	d
 228+ 7824 17           		rla
 229+ 7825 CB 12        		rl	d
 230+ 7827 5F           		ld	e, a
 231+ 7828
 232+ 7828 26 00        		ld		h, 0
 233+ 782A 19           		add		hl, de
 234+ 782B ED 5B A5 79  		ld		de, (CurrScrAttrAddr)
 235+ 782F 19           		add		hl, de
 236+ 7830 08           	ex		af, af'
 237+ 7831 4F           	ld		c, a
 238+ 7832 06 00        	ld		b, 0
 239+ 7834 54           	ld		d, h
 240+ 7835 5D           	ld		e, l
 241+ 7836 13           	inc 	de
 242+ 7837              StrClr	EQU	$ + 1
 243+ 7837 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 7839 ED B0        	ldir
 245+ 783B C9           	ret
 246+ 783C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 783C
 248+ 783C              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 783C              DrawLine:
 250+ 783C 32 81 5C     	ld		(CODE), a
 251+ 783F
 252+ 783F 38 04        	jr		c, VertDir
 253+ 7841 3E 1C        	ld		a, $1C
 254+ 7843 18 02        	jr		StoreDir
 255+ 7845              VertDir:
 256+ 7845 3E 14        	ld		a, $14
 257+ 7847              StoreDir:
 258+ 7847 32 57 78     	ld		(LineDir), a
 259+ 784A
 260+ 784A              DrawLineLoop:
 261+ 784A ED 53 B0 5C  	ld		(LineCol), de
 262+ 784E D5           	push	de
 263+ 784F D9           		exx
 264+ 7850 E5           		push	hl
 265+ 7851 CD 10 79     		call 	PrintChar
 266+ 7854 E1           		pop		hl
 267+ 7855 D9           		exx
 268+ 7856 D1           	pop		de
 269+ 7857              LineDir:
 270+ 7857 1C           	inc		e
 271+ 7858 10 F0        	djnz	DrawLineLoop
 272+ 785A
 273+ 785A C9           	ret
 274+ 785B
 275+ 785B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 785B
 277+ 785B              DrawHLines:
 278+ 785B 11 00 00     	ld		de, 0
 279+ 785E 06 40        	ld		b, 64
 280+ 7860 3E 87        	ld		a, CHR_H
 281+ 7862 B7           	or		a
 282+ 7863 CD 3C 78     	call	DrawLine
 283+ 7866
 284+ 7866 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 7869 06 40        	ld		b, 64
 286+ 786B 3E 87        	ld		a, CHR_H
 287+ 786D B7           	or		a
 288+ 786E CD 3C 78     	call	DrawLine
 289+ 7871
 290+ 7871 06 04        	ld		b, 4
 291+ 7873 11 10 00     	ld		de, LST_FIRST_COL
 292+ 7876              DrawUpperIntersectLoop:
 293+ 7876 C5           	push	bc
 294+ 7877 D5           	push	de
 295+ 7878 3E 85        		ld		a, CHR_UC
 296+ 787A CD 9C 78     		call	DrawIntersect
 297+ 787D D1           	pop		de
 298+ 787E C1           	pop		bc
 299+ 787F 21 0C 00     	ld		hl, NAMELEN+1
 300+ 7882 19           	add		hl, de
 301+ 7883 EB           	ex		de, hl
 302+ 7884 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 7886
 304+ 7886 06 04        	ld		b, 4
 305+ 7888 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 788B              DrawLowerIntersectLoop:
 307+ 788B C5           	push	bc
 308+ 788C D5           	push	de
 309+ 788D 3E 84        		ld		a, CHR_DC
 310+ 788F CD 9C 78     		call	DrawIntersect
 311+ 7892 D1           	pop		de
 312+ 7893 C1           	pop		bc
 313+ 7894 21 0C 00     	ld		hl, NAMELEN+1
 314+ 7897 19           	add		hl, de
 315+ 7898 EB           	ex		de, hl
 316+ 7899 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 789B
 318+ 789B C9           	ret
 319+ 789C
 320+ 789C
 321+ 789C              DrawIntersect:
 322+ 789C 21 B0 5C     	ld		hl, LineCol
 323+ 789F 73           	ld		(hl), e
 324+ 78A0 23           	inc		hl
 325+ 78A1 72           	ld		(hl), d
 326+ 78A2 2B           	dec		hl
 327+ 78A3 32 81 5C     	ld		(CODE), a
 328+ 78A6 E5           	push	hl
 329+ 78A7 CD 10 79     	call	PrintChar
 330+ 78AA E1           	pop		hl
 331+ 78AB 34           	inc		(hl)
 332+ 78AC 3E 87        	ld		a, CHR_H
 333+ 78AE 32 81 5C     	ld		(CODE), a
 334+ 78B1 CD 10 79     	call	PrintChar
 335+ 78B4 C9           	ret
 336+ 78B5
 337+ 78B5
 338+ 78B5              DrawVLines:
 339+ 78B5 06 04        	ld		b, 4
 340+ 78B7 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 341+ 78BA              DrawVLinesLoop:
 342+ 78BA C5           	push 	bc
 343+ 78BB D5           	push	de
 344+ 78BC 06 15        		ld		b, LST_LINES_CNT
 345+ 78BE 3E 80        		ld		a, CHR_V
 346+ 78C0 37           		scf
 347+ 78C1 CD 3C 78     		call	DrawLine
 348+ 78C4 D1           	pop		de
 349+ 78C5 C1           	pop	bc
 350+ 78C6 7B           	ld		a, e
 351+ 78C7 C6 0C        	add		NAMELEN+1
 352+ 78C9 5F           	ld		e, a
 353+ 78CA 10 EE        	djnz	DrawVLinesLoop
 354+ 78CC C9           	ret
 355+ 78CD
 356+ 78CD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 357+ 78CD
 358+ 78CD              ;IN: A = color mask
 359+ 78CD              DrawCursor:
 360+ 78CD ED 5B 93 80  	ld	de, (CursorAddr)
 361+ 78D1 06 06        	ld	b, 	(NAMELEN + 1)/2
 362+ 78D3              DrawCursorLoop:
 363+ 78D3 12           	ld	(de), a
 364+ 78D4 13           	inc de
 365+ 78D5 10 FC        	djnz DrawCursorLoop
 366+ 78D7 C9           	ret
 367+ 78D8
 368+ 78D8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 369+ 78D8
 370+ 78D8              ;IN:	A = file idx.
 371+ 78D8              MoveCursor:
 372+ 78D8              	;File idx / SCR_LINES => cursor line & column
 373+ 78D8 6F           	ld		l, a
 374+ 78D9 26 00        	ld		h, 0
 375+ 78DB 0E 15        	ld		c, LST_LINES_CNT
 376+ 78DD CD B5 6E     	call	Div					;HL = file column, A = line
 377+ 78E0
 378+ 78E0              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 379+ 78E0 C6 01        	add		LST_FIRST_LINE
 380+ 78E2
 381+ 78E2
 382+ 78E2 54           	ld d, h
 383+ 78E3 5D           	ld e, l
 384+ 78E4 21 00 00     	ld	hl, 0
 385+ 78E7
 386+ 78E7              	;line*32
 387+ 78E7 17           	rla
 388+ 78E8 17           	rla
 389+ 78E9 17           	rla
 390+ 78EA 17           	rla
 391+ 78EB CB 14        	rl h
 392+ 78ED 17           	rla
 393+ 78EE CB 14        	rl h
 394+ 78F0 6F           	ld l, a
 395+ 78F1
 396+ 78F1
 397+ 78F1              	;col * 6
 398+ 78F1 E5           	push	hl					;save line * 32
 399+ 78F2 3E 06        		ld		a, (NAMELEN + 1)/2
 400+ 78F4 CD D5 6E     		call	Mul				;HL = column * 12/2
 401+ 78F7 D1           	pop		de
 402+ 78F8 19           	add		hl, de
 403+ 78F9
 404+ 78F9 11 08 00     	ld		de, LST_FIRST_COL/2
 405+ 78FC ED 4B A5 79  	ld		bc, (CurrScrAttrAddr)
 406+ 7900 19           	add		hl, de
 407+ 7901 09           	add		hl, bc
 408+ 7902
 409+ 7902              	;clear old cursor
 410+ 7902 3E 45        	ld		a, SCR_DEF_CLR
 411+ 7904 CD CD 78     	call	DrawCursor
 412+ 7907
 413+ 7907              	;draw new one
 414+ 7907 22 93 80     	ld		(CursorAddr), hl
 415+ 790A 3E 60        	ld		a, SCR_SEL_CLR
 416+ 790C CD CD 78     	call	DrawCursor
 417+ 790F
 418+ 790F C9           	ret
 419+ 7910
 420+ 7910              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 421+ 7910
 422+ 7910              PrintChar:
 423+ 7910 ED 5B B0 5C      ld		de, (LineCol)
 424+ 7914
 425+ 7914                  ;calculate 64 column screen address
 426+ 7914              	;IN: D = line, E = col
 427+ 7914              	;OUT: HL = screen address
 428+ 7914
 429+ 7914 CB 3B            SRL     E                                       ;col = col/2
 430+ 7916 CB 19            RR      C                                       ;mark odd/even column
 431+ 7918 7A               LD      A, D                            ;A = line
 432+ 7919 E6 18            AND 24                                  ;keep only %00011000
 433+ 791B 2A A3 79         ld		hl, (CurrScrAddr)
 434+ 791E B4               OR      h								;add screen start address
 435+ 791F 67               LD      H, A                            ;save H
 436+ 7920 7A               LD      A, D                            ;A = line
 437+ 7921 E6 07            AND 7                                   ;keep only %00000111
 438+ 7923 0F               RRCA                                    ;%10000011
 439+ 7924 0F               RRCA                                    ;%11000001
 440+ 7925 0F               RRCA                                    ;%11100000
 441+ 7926 B3               OR      E                                       ;add column
 442+ 7927 6F               LD      L, A                            ;HL = screen address
 443+ 7928
 444+ 7928              PrintChar3:
 445+ 7928                  ;get font address
 446+ 7928 E5               PUSH HL
 447+ 7929 AF                   XOR A
 448+ 792A 67                   LD  H, A
 449+ 792B 3A 81 5C             LD  A, (CODE)
 450+ 792E D6 20                SUB ' '
 451+ 7930 6F                   LD  L, A
 452+ 7931 29                   ADD     HL, HL                  ;char code = char code * 8
 453+ 7932 29                   ADD     HL, HL                  ;i.e. offset into font table
 454+ 7933 29                   ADD     HL, HL
 455+ 7934 11 74 8B             LD      DE, FontTable             ;get font table
 456+ 7937 19                   ADD     HL, DE
 457+ 7938 EB                   EX      DE, HL                  ;DE = our char font address
 458+ 7939 E1               POP     HL
 459+ 793A
 460+ 793A
 461+ 793A                  ;print a char
 462+ 793A 06 08            LD      B, 8                            ;char height is 8 lines
 463+ 793C              PrintCharLine:
 464+ 793C 1A                   LD      A, (DE)                         ;load char line in A
 465+ 793D
 466+ 793D CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 467+ 793F 20 06                JR  	NZ, NoTurn
 468+ 7941
 469+ 7941 07                   RLCA
 470+ 7942 07                   RLCA
 471+ 7943 07                   RLCA
 472+ 7944 07                   RLCA
 473+ 7945 18 01                JR      Store
 474+ 7947              NoTurn:
 475+ 7947 B6                   OR (HL)
 476+ 7948              Store:
 477+ 7948 77                   LD (HL), A
 478+ 7949
 479+ 7949 13                   INC     DE                                      ;next char line in font table
 480+ 794A 24                   INC     H                                       ;next char line on screen
 481+ 794B 10 EF            DJNZ PrintCharLine                  ;last line of char?
 482+ 794D
 483+ 794D C9               ret
 484+ 794E
 485+ 794E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 486+ 794E
 487+ 794E              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 488+ 794E              ReadString:
 489+ 794E 21 DC 8E     	ld		hl, FileData
 490+ 7951 D5           	push	de
 491+ 7952 DD E1        	pop		ix
 492+ 7954
 493+ 7954              ReadStringLoop:
 494+ 7954 D5           	push	de
 495+ 7955 E5           	push	hl
 496+ 7956 CD A8 77     		call ReadChar
 497+ 7959 E1           	pop		hl
 498+ 795A D1           	pop		de
 499+ 795B
 500+ 795B FE 0D        	cp	KEY_ENTER
 501+ 795D C8           	ret z
 502+ 795E
 503+ 795E FE 0C        	cp  KEY_BACKSP
 504+ 7960 20 0F        	jr	nz, ReadStrChar
 505+ 7962
 506+ 7962 E5           	push hl
 507+ 7963 01 DD 8E     	ld   bc, FileData+1
 508+ 7966 ED 42        	sbc	 hl, bc
 509+ 7968 E1           	pop  hl
 510+ 7969 38 16        	jr   c, ReadStrPrint
 511+ 796B
 512+ 796B 1B           	dec	de
 513+ 796C 2B           	dec	hl
 514+ 796D 36 20        	ld	(hl), ' '
 515+ 796F 18 10        	jr	ReadStrPrint
 516+ 7971
 517+ 7971              ReadStrChar:
 518+ 7971 FE 20        	cp	' '
 519+ 7973 38 DF        	jr	c, ReadStringLoop
 520+ 7975 FE 7F        	cp  127
 521+ 7977 30 DB        	jr	nc, ReadStringLoop
 522+ 7979
 523+ 7979              	;Check end of string and go back if found.
 524+ 7979 46           	ld	b, (hl)
 525+ 797A CB 78        	bit 7, b
 526+ 797C 20 03        	jr	nz, ReadStrPrint
 527+ 797E
 528+ 797E 77           	ld	(hl), a
 529+ 797F 23           	inc	hl
 530+ 7980 13           	inc	de
 531+ 7981
 532+ 7981              ReadStrPrint:
 533+ 7981 E5           	push	hl
 534+ 7982 D5           	push	de
 535+ 7983 21 DC 8E     	ld		hl, FileData
 536+ 7986 DD E5        	push	ix
 537+ 7988 D1           	pop		de
 538+ 7989 CD E4 77     	call	PrintStr
 539+ 798C D1           	pop		de
 540+ 798D E1           	pop		hl
 541+ 798E
 542+ 798E 18 C4        	jr		ReadStringLoop
 543+ 7990
 544+ 7990              ClearNMsgLines:
 545+ 7990 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 546+ 7993              ClearNMsgLinesLoop:
 547+ 7993 D5           	push	de
 548+ 7994 C5           	push	bc
 549+ 7995 21 1D 7F     	ld		hl, MsgClear
 550+ 7998 3E 45        	ld		a, SCR_DEF_CLR
 551+ 799A CD 0C 78     	call	PrintStrClr
 552+ 799D C1           	pop		bc
 553+ 799E D1           	pop		de
 554+ 799F 14           	inc		d
 555+ 79A0 10 F1        	djnz	ClearNMsgLinesLoop
 556+ 79A2
 557+ 79A2 C9           	ret
 558+ 79A3
 559+ 79A3 00 40        CurrScrAddr		DEFW	SCR_ADDR
 560+ 79A5 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 561+ 79A7
 562+ 79A7                 	endif
# file closed: ui.asm
1447  79A7              	include "math.asm"
# file opened: math.asm
   1+ 79A7              	ifndef	_MATH_
   2+ 79A7 ~            	define	_MATH_
   3+ 79A7 ~
   4+ 79A7 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 79A7 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 79A7 ~
   7+ 79A7 ~
   8+ 79A7 ~            Word2Txt:
   9+ 79A7 ~            	IFUSED
  10+ 79A7 ~            	push	de
  11+ 79A7 ~            		call	Word2Txt_
  12+ 79A7 ~            	pop		de
  13+ 79A7 ~
  14+ 79A7 ~            	ld		b, 4
  15+ 79A7 ~            	call	StrippLeading0
  16+ 79A7 ~            	ret
  17+ 79A7 ~
  18+ 79A7 ~            Byte2Txt:
  19+ 79A7 ~            	push	de
  20+ 79A7 ~            		call	Byte2Txt_
  21+ 79A7 ~            	pop		de
  22+ 79A7 ~
  23+ 79A7 ~            	ld		b, 2
  24+ 79A7 ~            	call	StrippLeading0
  25+ 79A7 ~            	ret
  26+ 79A7 ~            	ENDIF
  27+ 79A7 ~
  28+ 79A7 ~
  29+ 79A7 ~            StrippLeading0:
  30+ 79A7 ~            	ld		a, (de)
  31+ 79A7 ~            	cp		'1'
  32+ 79A7 ~            	ret		nc
  33+ 79A7 ~
  34+ 79A7 ~            	ld		a, ' '
  35+ 79A7 ~            	ld		(de), a
  36+ 79A7 ~            	inc		de
  37+ 79A7 ~            	djnz	StrippLeading0
  38+ 79A7 ~            	ret
  39+ 79A7 ~
  40+ 79A7 ~
  41+ 79A7 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 79A7 ~            Word2Txt_:
  43+ 79A7 ~            	ld bc, -10000
  44+ 79A7 ~            	call DigitLoop
  45+ 79A7 ~            	ld bc, -1000
  46+ 79A7 ~            	call DigitLoop
  47+ 79A7 ~            Byte2Txt_:
  48+ 79A7 ~            	ld bc, -100
  49+ 79A7 ~            	call DigitLoop
  50+ 79A7 ~            	ld bc, -10
  51+ 79A7 ~            	call DigitLoop
  52+ 79A7 ~            	ld bc, -1
  53+ 79A7 ~
  54+ 79A7 ~            DigitLoop:
  55+ 79A7 ~            	ld	a, '0' - 1
  56+ 79A7 ~            DivNrLoop:
  57+ 79A7 ~            	inc	a			;increase reminder
  58+ 79A7 ~            	add	hl, bc		;substract divizor
  59+ 79A7 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 79A7 ~            	sbc	hl, bc		;nope, restore
  61+ 79A7 ~
  62+ 79A7 ~            	ld (de), a
  63+ 79A7 ~            	inc de
  64+ 79A7 ~            	ret
  65+ 79A7 ~
  66+ 79A7 ~
  67+ 79A7 ~            ;Input: HL = Dividend, C = Divisor
  68+ 79A7 ~            ;Output: HL = Quotient, A = Remainder
  69+ 79A7 ~            ;Warning: doesn't work with divisor >= $80
  70+ 79A7 ~            Div:
  71+ 79A7 ~            	IFUSED
  72+ 79A7 ~            	xor a
  73+ 79A7 ~            	ld b, 16
  74+ 79A7 ~
  75+ 79A7 ~            DivLoop:
  76+ 79A7 ~            	add	hl,hl
  77+ 79A7 ~            	rla
  78+ 79A7 ~            	cp	c
  79+ 79A7 ~            	jr	c, NoSub
  80+ 79A7 ~            	sub	c
  81+ 79A7 ~            	inc	l
  82+ 79A7 ~            NoSub:
  83+ 79A7 ~            	djnz DivLoop
  84+ 79A7 ~
  85+ 79A7 ~            	ret
  86+ 79A7 ~            	ENDIF
  87+ 79A7 ~
  88+ 79A7 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 79A7 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 79A7 ~            Div2:
  91+ 79A7 ~            	ld hl, 0
  92+ 79A7 ~            	ld b, 16
  93+ 79A7 ~            Div2Loop:
  94+ 79A7 ~            	sll c		; unroll 16 times
  95+ 79A7 ~            	rla			; ...
  96+ 79A7 ~            	adc	hl,hl		; ...
  97+ 79A7 ~            	sbc	hl,de		; ...
  98+ 79A7 ~            	jr	nc,$+4		; ...
  99+ 79A7 ~            	add	hl,de		; ...
 100+ 79A7 ~            	dec	c		; ...
 101+ 79A7 ~            	djnz Div2Loop
 102+ 79A7 ~            	ret
 103+ 79A7 ~
 104+ 79A7 ~
 105+ 79A7 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 79A7 ~            ;Output: A:HL = Product
 107+ 79A7 ~            Mul:
 108+ 79A7 ~            	IFUSED
 109+ 79A7 ~            	ld hl, 0
 110+ 79A7 ~            	ld bc, $0700
 111+ 79A7 ~
 112+ 79A7 ~            	add	a, a		; optimised 1st iteration
 113+ 79A7 ~            	jr	nc, MulLoop
 114+ 79A7 ~            	ld	h, d
 115+ 79A7 ~            	ld	l, e
 116+ 79A7 ~
 117+ 79A7 ~            MulLoop:
 118+ 79A7 ~            	add	hl,hl
 119+ 79A7 ~            	rla
 120+ 79A7 ~            	jr	nc, NoAdd
 121+ 79A7 ~            	add	hl,de
 122+ 79A7 ~            	adc	a,c
 123+ 79A7 ~            NoAdd:
 124+ 79A7 ~            	djnz MulLoop
 125+ 79A7 ~
 126+ 79A7 ~            	ret
 127+ 79A7 ~            	ENDIF
 128+ 79A7 ~
 129+ 79A7 ~
 130+ 79A7 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131+ 79A7 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132+ 79A7 ~            Byte2Hex:
 133+ 79A7 ~            	xor	a
 134+ 79A7 ~            	rld
 135+ 79A7 ~            	call	Byte2HexNibble
 136+ 79A7 ~
 137+ 79A7 ~            Byte2HexNibble:
 138+ 79A7 ~            	push	af
 139+ 79A7 ~            	daa
 140+ 79A7 ~            	add		a,$F0
 141+ 79A7 ~            	adc		a,$40
 142+ 79A7 ~
 143+ 79A7 ~            	ld		(de), a
 144+ 79A7 ~            	inc		de
 145+ 79A7 ~
 146+ 79A7 ~            	pop		af
 147+ 79A7 ~            	rld
 148+ 79A7 ~            	ret
 149+ 79A7 ~
 150+ 79A7 ~
 151+ 79A7 ~            Byte2HexHex:
 152+ 79A7 ~            	call	Byte2Hex
 153+ 79A7 ~            	inc		hl
 154+ 79A7 ~            	ld		a, ' '
 155+ 79A7 ~            	ld		(de), a
 156+ 79A7 ~            	inc		de
 157+ 79A7 ~            	ret
 158+ 79A7 ~
 159+ 79A7 ~            Byte2HexChar:
 160+ 79A7 ~            	ld		a, CHAR_CR
 161+ 79A7 ~            	cp		(hl)
 162+ 79A7 ~            	jr		z, Bin2HexLineLoopTextReplace
 163+ 79A7 ~
 164+ 79A7 ~            	ld		a, CHAR_EOF
 165+ 79A7 ~            	cp		(hl)
 166+ 79A7 ~            	jr		nz, Bin2HexLineLoopTextCopy
 167+ 79A7 ~
 168+ 79A7 ~            Bin2HexLineLoopTextReplace:
 169+ 79A7 ~            	ld		a, '.'
 170+ 79A7 ~            	ld		(hl), a
 171+ 79A7 ~
 172+ 79A7 ~            Bin2HexLineLoopTextCopy:
 173+ 79A7 ~            	ldi
 174+ 79A7 ~            	ret
 175+ 79A7 ~
 176+ 79A7 ~
 177+ 79A7 ~            HEX_COLUMNS	EQU	16
 178+ 79A7 ~
 179+ 79A7 ~            Bin2HexLine:
 180+ 79A7 ~            	;Hex part
 181+ 79A7 ~            	ld		b, HEX_COLUMNS
 182+ 79A7 ~            	push	hl
 183+ 79A7 ~            Bin2HexLineLoopHex:
 184+ 79A7 ~            		call	Byte2HexHex
 185+ 79A7 ~
 186+ 79A7 ~            		;Put separator in the middle of hex line.
 187+ 79A7 ~            		ld		a, HEX_COLUMNS/2+1
 188+ 79A7 ~            		cp		b
 189+ 79A7 ~            		jr		nz, Bin2HexLineLoopHexNotHalf
 190+ 79A7 ~            		dec		de
 191+ 79A7 ~            		ld		a, '-'
 192+ 79A7 ~            		ld		(de), a
 193+ 79A7 ~            		inc		de
 194+ 79A7 ~
 195+ 79A7 ~            Bin2HexLineLoopHexNotHalf:
 196+ 79A7 ~            		djnz	Bin2HexLineLoopHex
 197+ 79A7 ~            	pop		hl
 198+ 79A7 ~
 199+ 79A7 ~            	dec		de
 200+ 79A7 ~            	ld		a, '|'
 201+ 79A7 ~            	ld		(de), a
 202+ 79A7 ~            	inc		de
 203+ 79A7 ~
 204+ 79A7 ~            	;String part
 205+ 79A7 ~            	;Ignore CR & EOF
 206+ 79A7 ~            Bin2HexLineText:
 207+ 79A7 ~            	;just to not alter B with LDI, set C to something > 16
 208+ 79A7 ~            	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209+ 79A7 ~            Bin2HexLineLoopText:
 210+ 79A7 ~            	call	Byte2HexChar
 211+ 79A7 ~            	djnz	Bin2HexLineLoopText
 212+ 79A7 ~            	ret
 213+ 79A7 ~
 214+ 79A7 ~
 215+ 79A7 ~            ;Converts binary buffer at HL to hex string at DE
 216+ 79A7 ~            Bin2HexStr:
 217+ 79A7 ~            	;Calculate the number of full lines by dividing BC to 16.
 218+ 79A7 ~            	xor		a
 219+ 79A7 ~
 220+ 79A7 ~            	rr		b
 221+ 79A7 ~            	rr		c
 222+ 79A7 ~            	rra
 223+ 79A7 ~
 224+ 79A7 ~            	rr		b
 225+ 79A7 ~            	rr		c
 226+ 79A7 ~            	rra
 227+ 79A7 ~
 228+ 79A7 ~            	rr		b
 229+ 79A7 ~            	rr		c
 230+ 79A7 ~            	rra
 231+ 79A7 ~
 232+ 79A7 ~            	rr		b
 233+ 79A7 ~            	rr		c
 234+ 79A7 ~            	rra
 235+ 79A7 ~
 236+ 79A7 ~            	rra
 237+ 79A7 ~            	rra
 238+ 79A7 ~            	rra
 239+ 79A7 ~            	rra
 240+ 79A7 ~
 241+ 79A7 ~            	ex		af, af'			;Keep reminder
 242+ 79A7 ~
 243+ 79A7 ~            Bin2HexStrLoop:
 244+ 79A7 ~            	push	bc
 245+ 79A7 ~            		call	Bin2HexLine
 246+ 79A7 ~            	pop		bc
 247+ 79A7 ~
 248+ 79A7 ~            	dec		bc
 249+ 79A7 ~            	ld		a, b
 250+ 79A7 ~            	or		c
 251+ 79A7 ~            	jr		nz, Bin2HexStrLoop
 252+ 79A7 ~
 253+ 79A7 ~            	;Set remaining imcomplete line.
 254+ 79A7 ~            	push	de
 255+ 79A7 ~            	push	hl
 256+ 79A7 ~            		ld		a, ' '
 257+ 79A7 ~            		ld		b, COL_CNT
 258+ 79A7 ~            Bin2HexLineClear:
 259+ 79A7 ~            		ld		(de), a
 260+ 79A7 ~            		inc		de
 261+ 79A7 ~            		djnz	Bin2HexLineClear
 262+ 79A7 ~            	pop		hl
 263+ 79A7 ~            	pop		de
 264+ 79A7 ~
 265+ 79A7 ~            	push	de
 266+ 79A7 ~            	pop		ix
 267+ 79A7 ~            	ld		bc, HEX_COLUMNS*3
 268+ 79A7 ~            	add		ix, bc
 269+ 79A7 ~
 270+ 79A7 ~            	;Write hex and char part
 271+ 79A7 ~            	ex		af, af'
 272+ 79A7 ~            	or		a
 273+ 79A7 ~            	ret		z
 274+ 79A7 ~
 275+ 79A7 ~            	ld		b, a
 276+ 79A7 ~            	ld		c, HEX_COLUMNS*2
 277+ 79A7 ~
 278+ 79A7 ~            Bin2HexLineLoopHex2:
 279+ 79A7 ~            	call	Byte2HexHex
 280+ 79A7 ~            	dec		hl
 281+ 79A7 ~
 282+ 79A7 ~            	push	de
 283+ 79A7 ~            		ld		e, ixl
 284+ 79A7 ~            		ld		d, ixh
 285+ 79A7 ~            		call	Byte2HexChar
 286+ 79A7 ~            	pop		de
 287+ 79A7 ~            	inc		ix
 288+ 79A7 ~            	djnz	Bin2HexLineLoopHex2
 289+ 79A7 ~
 290+ 79A7 ~            	ret
 291+ 79A7 ~
 292+ 79A7              	endif
# file closed: math.asm
1448  79A7              	include "txtview.asm"
# file opened: txtview.asm
   1+ 79A7              	IFNDEF _TXTVIEW_
   2+ 79A7              	DEFINE _TXTVIEW_
   3+ 79A7
   4+ 79A7              LINE_CNT	EQU	23
   5+ 79A7              COL_CNT		EQU	64
   6+ 79A7
   7+ 79A7              CHAR_CR		EQU	$0D
   8+ 79A7              CHAR_LF		EQU	$0A
   9+ 79A7              CHAR_TAB	EQU	$09
  10+ 79A7              CHAR_EOF	EQU	$1A
  11+ 79A7
  12+ 79A7              COORDS		EQU	23728		;Coordinates
  13+ 79A7              SCRLinesDown	EQU PRN_BUF
  14+ 79A7              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
  15+ 79A7
  16+ 79A7
  17+ 79A7              	include "scroll.asm"
# file opened: scroll.asm
   1++79A7              ;Scrolling routines for UP/DOWN
   2++79A7              ;They use 2 tables of pointers of screen cell rows.
   3++79A7              ;One table has addresses in increasing order, for scroll down,
   4++79A7              ;the other in decreasing order, for scroll up, so the same
   5++79A7              ;scroll routine is used in both cases.
   6++79A7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++79A7
   8++79A7              ; Char Down
   9++79A7              ; Adjusts screen address HL to move eight pixels down on the display.
  10++79A7              ; enter: HL = valid screen address
  11++79A7              ; exit : HL = moves one character down
  12++79A7              ; used : AF, HL
  13++79A7              GetCellDown:
  14++79A7 7D           	ld a,l
  15++79A8 C6 20        	add a,$20
  16++79AA 6F           	ld l,a
  17++79AB D0           	ret nc
  18++79AC 7C           	ld a,h
  19++79AD C6 08        	add a,$08
  20++79AF 67           	ld h,a
  21++79B0 C9           	ret
  22++79B1
  23++79B1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++79B1              ;Fills the two tables with pointers.
  25++79B1              ScrollInit:
  26++79B1 21 00 40     	ld		hl, SCR_ADDR
  27++79B4 06 17        	ld		b, LINE_CNT
  28++79B6 DD 21 00 5B  	ld		ix, SCRLinesDown
  29++79BA
  30++79BA              	;Don't init again if already did it.
  31++79BA DD 7E 00     	ld		a, (ix)
  32++79BD BD           	cp		l
  33++79BE 20 05        	jr		nz, FillScrLinesLoop
  34++79C0 DD 7E 01     	ld		a, (ix+1)
  35++79C3 BC           	cp		h
  36++79C4 C8           	ret		z
  37++79C5
  38++79C5              FillScrLinesLoop:
  39++79C5 DD 75 00     	ld		(ix), l
  40++79C8 DD 74 01     	ld		(ix+1), h
  41++79CB DD 23        	inc		ix
  42++79CD DD 23        	inc		ix
  43++79CF              	;inc. pointer in destination table (of pointers to lines)
  44++79CF CD A7 79     	call	GetCellDown
  45++79D2 10 F1        	djnz	FillScrLinesLoop
  46++79D4
  47++79D4              	;now fill the table in reverse, every 2 bytes
  48++79D4 DD E5        	push	ix
  49++79D6 E1           	pop		hl
  50++79D7 2B           	dec		hl
  51++79D8 06 17        	ld		b, LINE_CNT
  52++79DA              FillScrLinesRev:
  53++79DA 56           	ld		d, (hl)
  54++79DB 2B           	dec		hl
  55++79DC 5E           	ld		e, (hl)
  56++79DD 2B           	dec		hl
  57++79DE
  58++79DE DD 73 00     	ld		(ix), e
  59++79E1 DD 72 01     	ld		(ix+1), d
  60++79E4 DD 23        	inc		ix
  61++79E6 DD 23        	inc		ix
  62++79E8 10 F0        	djnz	FillScrLinesRev
  63++79EA C9           	ret
  64++79EB
  65++79EB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  66++79EB              ScrollUp:
  67++79EB 21 2E 5B     	ld		hl, SCRLinesUp
  68++79EE 18 03        	jr		Scroll
  69++79F0
  70++79F0              ScrollDown:
  71++79F0 21 00 5B     	ld		hl, SCRLinesDown
  72++79F3
  73++79F3              Scroll:
  74++79F3 22 01 7A     	ld		(ScrollDownPtrDest), hl
  75++79F6 23           	inc		hl
  76++79F7 23           	inc		hl
  77++79F8 22 04 7A     	ld		(ScrollDownPtrSrc), hl
  78++79FB 0E 16        	ld		c, LINE_CNT - 1
  79++79FD
  80++79FD              ScrollDownLoop2:
  81++79FD 06 04        	ld		b, 4
  82++79FF              ScrollDownPtrDest	EQU	$ + 2
  83++79FF ED 5B 00 5B  	ld		de, (SCRLinesDown)
  84++7A03              ScrollDownPtrSrc	EQU	$ + 1
  85++7A03 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  86++7A06
  87++7A06              ScrollDownLoop:					;copy a single char line
  88++7A06 C5           	push	bc
  89++7A07 01 20 00     	ld		bc, 32
  90++7A0A ED B0        	ldir
  91++7A0C 2B           	dec		hl
  92++7A0D 1B           	dec		de
  93++7A0E 24           	inc		h
  94++7A0F 14           	inc		d
  95++7A10 01 20 00     	ld		bc, 32
  96++7A13 ED B8        	lddr
  97++7A15 23           	inc		hl
  98++7A16 13           	inc		de
  99++7A17 24           	inc		h
 100++7A18 14           	inc		d
 101++7A19 C1           	pop		bc
 102++7A1A 10 EA        	djnz	ScrollDownLoop
 103++7A1C
 104++7A1C 0D           	dec		c
 105++7A1D C8           	ret		z
 106++7A1E
 107++7A1E 2A 04 7A     	ld		hl, (ScrollDownPtrSrc)
 108++7A21 22 01 7A     	ld		(ScrollDownPtrDest), hl
 109++7A24 23           	inc		hl
 110++7A25 23           	inc		hl
 111++7A26 22 04 7A     	ld		(ScrollDownPtrSrc), hl
 112++7A29 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
  18+ 7A2B              	include "math.asm"
# file opened: math.asm
   1++7A2B              	ifndef	_MATH_
   2++7A2B ~            	define	_MATH_
   3++7A2B ~
   4++7A2B ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++7A2B ~            ;http://map.tni.nl/sources/external/z80bits.html
   6++7A2B ~
   7++7A2B ~
   8++7A2B ~            Word2Txt:
   9++7A2B ~            	IFUSED
  10++7A2B ~            	push	de
  11++7A2B ~            		call	Word2Txt_
  12++7A2B ~            	pop		de
  13++7A2B ~
  14++7A2B ~            	ld		b, 4
  15++7A2B ~            	call	StrippLeading0
  16++7A2B ~            	ret
  17++7A2B ~
  18++7A2B ~            Byte2Txt:
  19++7A2B ~            	push	de
  20++7A2B ~            		call	Byte2Txt_
  21++7A2B ~            	pop		de
  22++7A2B ~
  23++7A2B ~            	ld		b, 2
  24++7A2B ~            	call	StrippLeading0
  25++7A2B ~            	ret
  26++7A2B ~            	ENDIF
  27++7A2B ~
  28++7A2B ~
  29++7A2B ~            StrippLeading0:
  30++7A2B ~            	ld		a, (de)
  31++7A2B ~            	cp		'1'
  32++7A2B ~            	ret		nc
  33++7A2B ~
  34++7A2B ~            	ld		a, ' '
  35++7A2B ~            	ld		(de), a
  36++7A2B ~            	inc		de
  37++7A2B ~            	djnz	StrippLeading0
  38++7A2B ~            	ret
  39++7A2B ~
  40++7A2B ~
  41++7A2B ~            ;Converts the number in HL to ASCII in decimal string at DE
  42++7A2B ~            Word2Txt_:
  43++7A2B ~            	ld bc, -10000
  44++7A2B ~            	call DigitLoop
  45++7A2B ~            	ld bc, -1000
  46++7A2B ~            	call DigitLoop
  47++7A2B ~            Byte2Txt_:
  48++7A2B ~            	ld bc, -100
  49++7A2B ~            	call DigitLoop
  50++7A2B ~            	ld bc, -10
  51++7A2B ~            	call DigitLoop
  52++7A2B ~            	ld bc, -1
  53++7A2B ~
  54++7A2B ~            DigitLoop:
  55++7A2B ~            	ld	a, '0' - 1
  56++7A2B ~            DivNrLoop:
  57++7A2B ~            	inc	a			;increase reminder
  58++7A2B ~            	add	hl, bc		;substract divizor
  59++7A2B ~            	jr	c, DivNrLoop	;still dividing?
  60++7A2B ~            	sbc	hl, bc		;nope, restore
  61++7A2B ~
  62++7A2B ~            	ld (de), a
  63++7A2B ~            	inc de
  64++7A2B ~            	ret
  65++7A2B ~
  66++7A2B ~
  67++7A2B ~            ;Input: HL = Dividend, C = Divisor
  68++7A2B ~            ;Output: HL = Quotient, A = Remainder
  69++7A2B ~            ;Warning: doesn't work with divisor >= $80
  70++7A2B ~            Div:
  71++7A2B ~            	IFUSED
  72++7A2B ~            	xor a
  73++7A2B ~            	ld b, 16
  74++7A2B ~
  75++7A2B ~            DivLoop:
  76++7A2B ~            	add	hl,hl
  77++7A2B ~            	rla
  78++7A2B ~            	cp	c
  79++7A2B ~            	jr	c, NoSub
  80++7A2B ~            	sub	c
  81++7A2B ~            	inc	l
  82++7A2B ~            NoSub:
  83++7A2B ~            	djnz DivLoop
  84++7A2B ~
  85++7A2B ~            	ret
  86++7A2B ~            	ENDIF
  87++7A2B ~
  88++7A2B ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++7A2B ~            ;Output: A:C = Quotient, HL = Remainder
  90++7A2B ~            Div2:
  91++7A2B ~            	ld hl, 0
  92++7A2B ~            	ld b, 16
  93++7A2B ~            Div2Loop:
  94++7A2B ~            	sll c		; unroll 16 times
  95++7A2B ~            	rla			; ...
  96++7A2B ~            	adc	hl,hl		; ...
  97++7A2B ~            	sbc	hl,de		; ...
  98++7A2B ~            	jr	nc,$+4		; ...
  99++7A2B ~            	add	hl,de		; ...
 100++7A2B ~            	dec	c		; ...
 101++7A2B ~            	djnz Div2Loop
 102++7A2B ~            	ret
 103++7A2B ~
 104++7A2B ~
 105++7A2B ~            ;Input: A = Multiplier, DE = Multiplicand
 106++7A2B ~            ;Output: A:HL = Product
 107++7A2B ~            Mul:
 108++7A2B ~            	IFUSED
 109++7A2B ~            	ld hl, 0
 110++7A2B ~            	ld bc, $0700
 111++7A2B ~
 112++7A2B ~            	add	a, a		; optimised 1st iteration
 113++7A2B ~            	jr	nc, MulLoop
 114++7A2B ~            	ld	h, d
 115++7A2B ~            	ld	l, e
 116++7A2B ~
 117++7A2B ~            MulLoop:
 118++7A2B ~            	add	hl,hl
 119++7A2B ~            	rla
 120++7A2B ~            	jr	nc, NoAdd
 121++7A2B ~            	add	hl,de
 122++7A2B ~            	adc	a,c
 123++7A2B ~            NoAdd:
 124++7A2B ~            	djnz MulLoop
 125++7A2B ~
 126++7A2B ~            	ret
 127++7A2B ~            	ENDIF
 128++7A2B ~
 129++7A2B ~
 130++7A2B ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++7A2B ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132++7A2B ~            Byte2Hex:
 133++7A2B ~            	xor	a
 134++7A2B ~            	rld
 135++7A2B ~            	call	Byte2HexNibble
 136++7A2B ~
 137++7A2B ~            Byte2HexNibble:
 138++7A2B ~            	push	af
 139++7A2B ~            	daa
 140++7A2B ~            	add		a,$F0
 141++7A2B ~            	adc		a,$40
 142++7A2B ~
 143++7A2B ~            	ld		(de), a
 144++7A2B ~            	inc		de
 145++7A2B ~
 146++7A2B ~            	pop		af
 147++7A2B ~            	rld
 148++7A2B ~            	ret
 149++7A2B ~
 150++7A2B ~
 151++7A2B ~            Byte2HexHex:
 152++7A2B ~            	call	Byte2Hex
 153++7A2B ~            	inc		hl
 154++7A2B ~            	ld		a, ' '
 155++7A2B ~            	ld		(de), a
 156++7A2B ~            	inc		de
 157++7A2B ~            	ret
 158++7A2B ~
 159++7A2B ~            Byte2HexChar:
 160++7A2B ~            	ld		a, CHAR_CR
 161++7A2B ~            	cp		(hl)
 162++7A2B ~            	jr		z, Bin2HexLineLoopTextReplace
 163++7A2B ~
 164++7A2B ~            	ld		a, CHAR_EOF
 165++7A2B ~            	cp		(hl)
 166++7A2B ~            	jr		nz, Bin2HexLineLoopTextCopy
 167++7A2B ~
 168++7A2B ~            Bin2HexLineLoopTextReplace:
 169++7A2B ~            	ld		a, '.'
 170++7A2B ~            	ld		(hl), a
 171++7A2B ~
 172++7A2B ~            Bin2HexLineLoopTextCopy:
 173++7A2B ~            	ldi
 174++7A2B ~            	ret
 175++7A2B ~
 176++7A2B ~
 177++7A2B ~            HEX_COLUMNS	EQU	16
 178++7A2B ~
 179++7A2B ~            Bin2HexLine:
 180++7A2B ~            	;Hex part
 181++7A2B ~            	ld		b, HEX_COLUMNS
 182++7A2B ~            	push	hl
 183++7A2B ~            Bin2HexLineLoopHex:
 184++7A2B ~            		call	Byte2HexHex
 185++7A2B ~
 186++7A2B ~            		;Put separator in the middle of hex line.
 187++7A2B ~            		ld		a, HEX_COLUMNS/2+1
 188++7A2B ~            		cp		b
 189++7A2B ~            		jr		nz, Bin2HexLineLoopHexNotHalf
 190++7A2B ~            		dec		de
 191++7A2B ~            		ld		a, '-'
 192++7A2B ~            		ld		(de), a
 193++7A2B ~            		inc		de
 194++7A2B ~
 195++7A2B ~            Bin2HexLineLoopHexNotHalf:
 196++7A2B ~            		djnz	Bin2HexLineLoopHex
 197++7A2B ~            	pop		hl
 198++7A2B ~
 199++7A2B ~            	dec		de
 200++7A2B ~            	ld		a, '|'
 201++7A2B ~            	ld		(de), a
 202++7A2B ~            	inc		de
 203++7A2B ~
 204++7A2B ~            	;String part
 205++7A2B ~            	;Ignore CR & EOF
 206++7A2B ~            Bin2HexLineText:
 207++7A2B ~            	;just to not alter B with LDI, set C to something > 16
 208++7A2B ~            	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209++7A2B ~            Bin2HexLineLoopText:
 210++7A2B ~            	call	Byte2HexChar
 211++7A2B ~            	djnz	Bin2HexLineLoopText
 212++7A2B ~            	ret
 213++7A2B ~
 214++7A2B ~
 215++7A2B ~            ;Converts binary buffer at HL to hex string at DE
 216++7A2B ~            Bin2HexStr:
 217++7A2B ~            	;Calculate the number of full lines by dividing BC to 16.
 218++7A2B ~            	xor		a
 219++7A2B ~
 220++7A2B ~            	rr		b
 221++7A2B ~            	rr		c
 222++7A2B ~            	rra
 223++7A2B ~
 224++7A2B ~            	rr		b
 225++7A2B ~            	rr		c
 226++7A2B ~            	rra
 227++7A2B ~
 228++7A2B ~            	rr		b
 229++7A2B ~            	rr		c
 230++7A2B ~            	rra
 231++7A2B ~
 232++7A2B ~            	rr		b
 233++7A2B ~            	rr		c
 234++7A2B ~            	rra
 235++7A2B ~
 236++7A2B ~            	rra
 237++7A2B ~            	rra
 238++7A2B ~            	rra
 239++7A2B ~            	rra
 240++7A2B ~
 241++7A2B ~            	ex		af, af'			;Keep reminder
 242++7A2B ~
 243++7A2B ~            Bin2HexStrLoop:
 244++7A2B ~            	push	bc
 245++7A2B ~            		call	Bin2HexLine
 246++7A2B ~            	pop		bc
 247++7A2B ~
 248++7A2B ~            	dec		bc
 249++7A2B ~            	ld		a, b
 250++7A2B ~            	or		c
 251++7A2B ~            	jr		nz, Bin2HexStrLoop
 252++7A2B ~
 253++7A2B ~            	;Set remaining imcomplete line.
 254++7A2B ~            	push	de
 255++7A2B ~            	push	hl
 256++7A2B ~            		ld		a, ' '
 257++7A2B ~            		ld		b, COL_CNT
 258++7A2B ~            Bin2HexLineClear:
 259++7A2B ~            		ld		(de), a
 260++7A2B ~            		inc		de
 261++7A2B ~            		djnz	Bin2HexLineClear
 262++7A2B ~            	pop		hl
 263++7A2B ~            	pop		de
 264++7A2B ~
 265++7A2B ~            	push	de
 266++7A2B ~            	pop		ix
 267++7A2B ~            	ld		bc, HEX_COLUMNS*3
 268++7A2B ~            	add		ix, bc
 269++7A2B ~
 270++7A2B ~            	;Write hex and char part
 271++7A2B ~            	ex		af, af'
 272++7A2B ~            	or		a
 273++7A2B ~            	ret		z
 274++7A2B ~
 275++7A2B ~            	ld		b, a
 276++7A2B ~            	ld		c, HEX_COLUMNS*2
 277++7A2B ~
 278++7A2B ~            Bin2HexLineLoopHex2:
 279++7A2B ~            	call	Byte2HexHex
 280++7A2B ~            	dec		hl
 281++7A2B ~
 282++7A2B ~            	push	de
 283++7A2B ~            		ld		e, ixl
 284++7A2B ~            		ld		d, ixh
 285++7A2B ~            		call	Byte2HexChar
 286++7A2B ~            	pop		de
 287++7A2B ~            	inc		ix
 288++7A2B ~            	djnz	Bin2HexLineLoopHex2
 289++7A2B ~
 290++7A2B ~            	ret
 291++7A2B ~
 292++7A2B              	endif
# file closed: math.asm
  19+ 7A2B
  20+ 7A2B              TextViewer:
  21+ 7A2B CD 20 7B     	call	TextViewIndex
  22+ 7A2E
  23+ 7A2E 21 00 00     	ld		hl, 0
  24+ 7A31 22 B0 5C     	ld		(COORDS), hl
  25+ 7A34 CD B1 79     	call	ScrollInit
  26+ 7A37
  27+ 7A37              TextViewerLoop2:
  28+ 7A37              	;Display 23 lines or less.
  29+ 7A37 2A D7 7B     	ld		hl, (LineCount)
  30+ 7A3A 01 17 00     	ld		bc, LINE_CNT
  31+ 7A3D B7           	or		a
  32+ 7A3E ED 42        	sbc		hl, bc
  33+ 7A40 06 17        	ld		b, LINE_CNT
  34+ 7A42 30 04        	jr		nc, MoreThan23LinesInFile
  35+ 7A44 2A D7 7B     	ld		hl, (LineCount)
  36+ 7A47 45           	ld		b, l
  37+ 7A48              MoreThan23LinesInFile:
  38+ 7A48 DD 21 DC EE  	ld		ix, FileIdx
  39+ 7A4C
  40+ 7A4C              ;Display first screen of text.
  41+ 7A4C              TextViewerLoop:
  42+ 7A4C C5           	push	bc
  43+ 7A4D CD 7D 7B     		call	PrintOneLine
  44+ 7A50 DD 23        		inc		ix
  45+ 7A52 DD 23        		inc		ix
  46+ 7A54 DD 23        		inc		ix
  47+ 7A56
  48+ 7A56 ED 5B B0 5C  		ld		de, (COORDS)
  49+ 7A5A 14           		inc		d
  50+ 7A5B 1E 00        		ld		e, 0
  51+ 7A5D ED 53 B0 5C  		ld		(COORDS), de
  52+ 7A61 C1           	pop		bc
  53+ 7A62 10 E8        	djnz	TextViewerLoop
  54+ 7A64
  55+ 7A64 11 00 00     	ld		de, 0
  56+ 7A67 ED 53 D9 7B  	ld		(FirstLineShown), de
  57+ 7A6B
  58+ 7A6B DD 2B        	dec		ix
  59+ 7A6D DD 2B        	dec		ix
  60+ 7A6F DD 2B        	dec		ix
  61+ 7A71
  62+ 7A71 2A D7 7B     	ld		hl, (LineCount)
  63+ 7A74 11 F9 7B     	ld		de, MsgLineTotal
  64+ 7A77 CD 6E 6E     	call	Word2Txt
  65+ 7A7A
  66+ 7A7A              TextViewerLoop3:
  67+ 7A7A 2A D9 7B     	ld		hl, (FirstLineShown)
  68+ 7A7D 23           	inc		hl
  69+ 7A7E 11 F3 7B     	ld		de, MsgLineNo
  70+ 7A81 CD 6E 6E     	call	Word2Txt
  71+ 7A84
  72+ 7A84 2A 99 80     	ld		hl, (SelFileCache)
  73+ 7A87 11 E1 7B     	ld		de, MsgLineFileName
  74+ 7A8A 06 0B        	ld		b, NAMELEN
  75+ 7A8C              TextViewerShowFilename:
  76+ 7A8C 7E           	ld		a, (hl)
  77+ 7A8D E6 7F        	and		$7F
  78+ 7A8F 12           	ld		(de), a
  79+ 7A90 23           	inc		hl
  80+ 7A91 13           	inc		de
  81+ 7A92 10 F8        	djnz	TextViewerShowFilename
  82+ 7A94
  83+ 7A94 21 DB 7B     	ld		hl, MsgLine
  84+ 7A97 11 00 17     	ld		de, LINE_CNT << 8
  85+ 7A9A 3E 60        	ld		a, SCR_SEL_CLR
  86+ 7A9C CD 0C 78     	call	PrintStrClr
  87+ 7A9F
  88+ 7A9F CD A8 77     	call	ReadChar
  89+ 7AA2
  90+ 7AA2 FE 0A        	cp		KEY_DOWN
  91+ 7AA4 28 3A        	jr		z, TextViewerScrollDown
  92+ 7AA6
  93+ 7AA6 FE 0B        	cp		KEY_UP
  94+ 7AA8 28 05        	jr		z, TextViewerScrollUp
  95+ 7AAA
  96+ 7AAA FE 30        	cp		'0'
  97+ 7AAC C8           	ret		z
  98+ 7AAD
  99+ 7AAD 18 CB        	jr		TextViewerLoop3
 100+ 7AAF
 101+ 7AAF              TextViewerScrollUp:
 102+ 7AAF              	;Do nothing if showing begining of file.
 103+ 7AAF ED 5B D9 7B  	ld		de, (FirstLineShown)
 104+ 7AB3 7A           	ld		a, d
 105+ 7AB4 B3           	or		e
 106+ 7AB5 28 C3        	jr		z, TextViewerLoop3
 107+ 7AB7
 108+ 7AB7 1B           	dec		de
 109+ 7AB8 ED 53 D9 7B  	ld		(FirstLineShown), de
 110+ 7ABC
 111+ 7ABC 7A           	ld		a, d
 112+ 7ABD B3           	or		e
 113+ 7ABE DD 21 DC EE  	ld		ix, FileIdx
 114+ 7AC2 28 09        	jr		z, TextViewerScrollUp1
 115+ 7AC4
 116+ 7AC4              	;3*FirstLineShown
 117+ 7AC4 3E 03        	ld		a, 3
 118+ 7AC6 CD D5 6E     	call	Mul
 119+ 7AC9 EB           	ex		de, hl
 120+ 7ACA B7           	or		a
 121+ 7ACB DD 19        	add		ix, de
 122+ 7ACD
 123+ 7ACD
 124+ 7ACD              TextViewerScrollUp1:
 125+ 7ACD CD EB 79     	call	ScrollUp
 126+ 7AD0 ED 5B B0 5C  	ld		de, (COORDS)
 127+ 7AD4 11 00 00     	ld		de, 0
 128+ 7AD7 ED 53 B0 5C  	ld		(COORDS), de
 129+ 7ADB CD 7D 7B     	call	PrintOneLine
 130+ 7ADE
 131+ 7ADE 18 9A        	jr		TextViewerLoop3
 132+ 7AE0
 133+ 7AE0              TextViewerScrollDown:
 134+ 7AE0              	;Exit if reached last line from file.
 135+ 7AE0 2A D9 7B     	ld		hl, (FirstLineShown)
 136+ 7AE3 01 18 00     	ld		bc, LINE_CNT+1
 137+ 7AE6 B7           	or		a
 138+ 7AE7 ED 4A        	adc		hl, bc
 139+ 7AE9 EB           	ex		de, hl
 140+ 7AEA 2A D7 7B     	ld		hl, (LineCount)
 141+ 7AED B7           	or		a
 142+ 7AEE ED 52        	sbc		hl, de
 143+ 7AF0 38 88        	jr		c, TextViewerLoop3
 144+ 7AF2
 145+ 7AF2 2A D9 7B     	ld		hl, (FirstLineShown)
 146+ 7AF5 23           	inc		hl
 147+ 7AF6 22 D9 7B     	ld		(FirstLineShown), hl
 148+ 7AF9 01 16 00     	ld		bc, LINE_CNT-1
 149+ 7AFC B7           	or		a
 150+ 7AFD ED 4A        	adc		hl, bc
 151+ 7AFF EB           	ex		de, hl
 152+ 7B00
 153+ 7B00              	;(FirstLineShown + 23	) * 3
 154+ 7B00 3E 03        	ld		a, 3
 155+ 7B02 CD D5 6E     	call	Mul
 156+ 7B05 EB           	ex		de, hl
 157+ 7B06 DD 21 DC EE  	ld		ix, FileIdx
 158+ 7B0A DD 19        	add		ix, de
 159+ 7B0C
 160+ 7B0C CD F0 79     	call	ScrollDown
 161+ 7B0F ED 5B B0 5C  	ld		de, (COORDS)
 162+ 7B13 11 00 16     	ld		de, (LINE_CNT - 1) << 8
 163+ 7B16 ED 53 B0 5C  	ld		(COORDS), de
 164+ 7B1A
 165+ 7B1A CD 7D 7B     	call	PrintOneLine
 166+ 7B1D
 167+ 7B1D C3 7A 7A     	jp		TextViewerLoop3
 168+ 7B20
 169+ 7B20              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 170+ 7B20
 171+ 7B20              ;Creates line start indexes, with 2 byte address and 1 byte length for each line. Stores total line count.
 172+ 7B20              ;IN: HL=start address, BC: length
 173+ 7B20              TextViewIndex:
 174+ 7B20 DD 21 DC EE  	ld		ix, FileIdx
 175+ 7B24
 176+ 7B24              	;Search for CHAR_EOF, to mark end of buffer there, if found.
 177+ 7B24              	;Save initial length in DE.
 178+ 7B24 E5           	push	hl
 179+ 7B25 C5           		push	bc
 180+ 7B26 3E 1A        			ld		a, CHAR_EOF
 181+ 7B28 ED B1        			cpir
 182+ 7B2A
 183+ 7B2A E5           			push	hl
 184+ 7B2B D1           			pop		de				;DE will contain the address of EOF char or end of file.
 185+ 7B2C C1           		pop		bc
 186+ 7B2D E1           	pop		hl
 187+ 7B2E
 188+ 7B2E 1B           	dec		de
 189+ 7B2F ED 53 D5 7B  	ld		(FileEnd), de
 190+ 7B33
 191+ 7B33 11 00 00     	ld		de, 0					;Assume at least one line is shown, even if empty.
 192+ 7B36 ED 53 D7 7B  	ld		(LineCount), de
 193+ 7B3A
 194+ 7B3A              TextViewIndexLoop:
 195+ 7B3A DD 75 00     	ld		(ix), l
 196+ 7B3D DD 74 01     	ld		(ix+1), h
 197+ 7B40
 198+ 7B40 01 40 00     	ld		bc, COL_CNT			;Search CR char, might be on position 65.
 199+ 7B43 3E 0D        	ld		a, CHAR_CR
 200+ 7B45 ED B1        	cpir
 201+ 7B47
 202+ 7B47 3E 0D        	ld		a, CHAR_CR			;Don't show an empty line if the CR char is exactly after 64 chars.
 203+ 7B49 BE           	cp		(hl)
 204+ 7B4A 20 01        	jr		nz, TextViewCheckLF
 205+ 7B4C 23           	inc		hl
 206+ 7B4D
 207+ 7B4D              TextViewCheckLF:
 208+ 7B4D 3E 0A        	ld		a, CHR_LF
 209+ 7B4F BE           	cp		(hl)
 210+ 7B50 20 01        	jr		nz, TextViewIndexNoLF
 211+ 7B52 23           	inc		hl						;Skip LF char.
 212+ 7B53
 213+ 7B53              TextViewIndexNoLF:
 214+ 7B53
 215+ 7B53              	;If line shorter than 64 chars, calculate actual length.
 216+ 7B53 79           	ld		a, c
 217+ 7B54 B7           	or		a						;if c==0, line was 64 chars
 218+ 7B55 3E 40        	ld		a, COL_CNT
 219+ 7B57 28 02        	jr		z, TextViewIndexStoreLineLen
 220+ 7B59 0C           	inc		c						;account for the CR char found.
 221+ 7B5A 91           	sub		c
 222+ 7B5B
 223+ 7B5B              TextViewIndexStoreLineLen:
 224+ 7B5B DD 77 02     	ld		(ix+2), a
 225+ 7B5E ED 5B D7 7B  	ld		de, (LineCount)
 226+ 7B62 13           	inc		de
 227+ 7B63 ED 53 D7 7B  	ld		(LineCount), de
 228+ 7B67
 229+ 7B67              	;Check end of file.
 230+ 7B67 3E 1A        	ld		a, CHAR_EOF
 231+ 7B69 BE           	cp		(hl)
 232+ 7B6A C8           	ret		z
 233+ 7B6B
 234+ 7B6B              TextViewerIncrementIndex:
 235+ 7B6B              	;Point to the next index position.
 236+ 7B6B DD 23        	inc		ix
 237+ 7B6D DD 23        	inc		ix
 238+ 7B6F DD 23        	inc		ix
 239+ 7B71
 240+ 7B71              TextViewerCheckEnd:
 241+ 7B71 E5           	push	hl
 242+ 7B72 EB           		ex		de, hl
 243+ 7B73 2A D5 7B     		ld		hl, (FileEnd)
 244+ 7B76 B7           		or		a
 245+ 7B77 ED 52        		sbc		hl, de
 246+ 7B79 E1           	pop		hl
 247+ 7B7A 30 BE        	jr		nc, TextViewIndexLoop
 248+ 7B7C
 249+ 7B7C              TextViewerEnd:
 250+ 7B7C C9           	ret
 251+ 7B7D
 252+ 7B7D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 253+ 7B7D              PrintOneLine:
 254+ 7B7D DD 6E 00     	ld		l, (ix)
 255+ 7B80 DD 66 01     	ld		h, (ix+1)
 256+ 7B83 DD 7E 02     	ld		a, (ix+2)
 257+ 7B86
 258+ 7B86 B7           	or		a
 259+ 7B87 06 40        	ld		b, COL_CNT
 260+ 7B89 28 34        	jr		z, PrintOneLineCleanLine
 261+ 7B8B
 262+ 7B8B 47           	ld		b, a
 263+ 7B8C              PrintOneLineLoop:
 264+ 7B8C 7E           	ld		a, (hl)
 265+ 7B8D
 266+ 7B8D              	;Put space instead of tab
 267+ 7B8D FE 09        	cp		CHAR_TAB
 268+ 7B8F 20 02        	jr		nz, PrintOneLineNotTab
 269+ 7B91 3E 20        	ld		a, ' '
 270+ 7B93
 271+ 7B93              PrintOneLineNotTab:
 272+ 7B93 E5           	push	hl
 273+ 7B94 FE 20        		cp	' '
 274+ 7B96 38 06        		jr	c, PrintCharNotValid
 275+ 7B98 FE 7F        		cp  127
 276+ 7B9A 30 02        		jr	nc, PrintCharNotValid
 277+ 7B9C
 278+ 7B9C 18 02        		jr	PrintCharValid
 279+ 7B9E              PrintCharNotValid:
 280+ 7B9E 3E 2E        		ld	a, '.'
 281+ 7BA0              PrintCharValid:
 282+ 7BA0 32 81 5C     		ld		(CODE), a
 283+ 7BA3 C5           		push	bc
 284+ 7BA4 CD 10 79     			call	PrintChar
 285+ 7BA7 C1           		pop		bc
 286+ 7BA8
 287+ 7BA8 ED 5B B0 5C  		ld		de, (COORDS)
 288+ 7BAC 1C           		inc		e
 289+ 7BAD ED 53 B0 5C  		ld		(COORDS), de
 290+ 7BB1 E1           	pop		hl
 291+ 7BB2 23           	inc		hl
 292+ 7BB3 10 D7        	djnz	PrintOneLineLoop
 293+ 7BB5
 294+ 7BB5              	;Fill rest of line with spaces.
 295+ 7BB5 DD 46 02     	ld		b, (ix+2)
 296+ 7BB8 3E 40        	ld		a, COL_CNT
 297+ 7BBA B8           	cp		b
 298+ 7BBB C8           	ret		z
 299+ 7BBC
 300+ 7BBC B7           	or		a
 301+ 7BBD 98           	sbc		b
 302+ 7BBE 47           	ld		b, a
 303+ 7BBF
 304+ 7BBF              PrintOneLineCleanLine:
 305+ 7BBF 3E 20        	ld		a, ' '
 306+ 7BC1 32 81 5C     	ld		(CODE), a
 307+ 7BC4 C5           	push	bc
 308+ 7BC5 CD 10 79     		call	PrintChar
 309+ 7BC8 ED 5B B0 5C  		ld		de, (COORDS)
 310+ 7BCC 1C           		inc		e
 311+ 7BCD ED 53 B0 5C  		ld		(COORDS), de
 312+ 7BD1 C1           	pop		bc
 313+ 7BD2 10 EB        	djnz	PrintOneLineCleanLine
 314+ 7BD4
 315+ 7BD4 C9           	ret
 316+ 7BD5
 317+ 7BD5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 318+ 7BD5
 319+ 7BD5 00 00        FileEnd			DEFW	0
 320+ 7BD7 00 00        LineCount		DEFW	0
 321+ 7BD9 00 00        FirstLineShown	DEFW	0
 322+ 7BDB
 323+ 7BDB 46 69 6C 65  MsgLine			defb	'File: '
 323+ 7BDF 3A 20
 324+ 7BE1 20 20 20 20  MsgLineFileName defb 	'           |'
 324+ 7BE5 20 20 20 20
 324+ 7BE9 20 20 20 7C
 325+ 7BED 4C 69 6E 65  				defb	'Line: '
 325+ 7BF1 3A 20
 326+ 7BF3 20 20 20 20  MsgLineNo		defb	'     /'
 326+ 7BF7 20 2F
 327+ 7BF9 20 20 20 20  MsgLineTotal	defb	'     |'
 327+ 7BFD 20 7C
 328+ 7BFF 20 20 20...  				defs	21, ' '
 329+ 7C14 7C 30 3A 45  				defb	'|0:Exi', 't' | $80
 329+ 7C18 78 69 F4
 330+ 7C1B
 331+ 7C1B              	ENDIF
# file closed: txtview.asm
1449  7C1B              	include "serial.asm"
# file opened: serial.asm
   1+ 7C1B              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7C1B              ;They work with 19200 theoretical speed.
   3+ 7C1B              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7C1B
   5+ 7C1B              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7C1B              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7C1B
   8+ 7C1B
   9+ 7C1B              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7C1B              ; A=1 IF FRAMING ERROR
  11+ 7C1B              ; USES BC,D _DOES NOT USE E!_
  12+ 7C1B              SERRXI:
  12+ 7C1B
  13+ 7C1B 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7C1E 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 7C20 D3 EF        	OUT	(0EFH),A
  16+ 7C22
  17+ 7C22              	; WAIT FOR START
  18+ 7C22              SERWSL:
  19+ 7C22 0B           	DEC	BC
  20+ 7C23 AF           	XOR	A
  21+ 7C24 B8           	CP	B
  22+ 7C25 20 03        	JR	NZ,SERWS
  23+ 7C27 B9           	CP	C
  24+ 7C28 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7C2A DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7C2C CB 7F        	BIT	7,A
  27+ 7C2E 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 7C30
  29+ 7C30              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 7C30              ; OF BIT 0
  31+ 7C30 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 7C32 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 7C34
  34+ 7C34              ; GET AND SHIFT BITS
  35+ 7C34              SERRL:
  36+ 7C34 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7C36 00           	NOP			; 4 (TIMING)
  38+ 7C37 00           	NOP			; 4 (TIMING)
  39+ 7C38 00           	NOP			; 4 (TIMING)
  40+ 7C39 DB F7        	IN	A,(0F7H)	; 11
  41+ 7C3B 17           	RLA			; 4
  42+ 7C3C CB 1A        	RR	D		; 8
  43+ 7C3E 06 0A        	LD	B,CBAUD		; 7
  44+ 7C40 0D           	DEC	C		; 4
  45+ 7C41 20 F1        	JR	NZ,SERRL	; 12
  46+ 7C43
  47+ 7C43              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 7C43              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 7C43              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 7C43              ; IDLE UNTIL NEXT START BIT
  51+ 7C43 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7C45 D3 EF        	OUT	(0EFH),A
  53+ 7C47
  54+ 7C47 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7C49              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7C49              SERWIL:
  57+ 7C49 05           	DEC	B
  58+ 7C4A 28 0E        	JR	Z,SERRTF
  59+ 7C4C DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7C4E CB 7F        	BIT	7,A
  61+ 7C50 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 7C52
  63+ 7C52              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 7C52 7A           	LD	A,D
  65+ 7C53 2F           	CPL			; INVERT BITS
  66+ 7C54 57           	LD	D,A
  67+ 7C55 AF           	XOR	A		; 0 = SUCCESS
  68+ 7C56 C9           	RET
  69+ 7C57
  70+ 7C57              ; TIMEOUT
  71+ 7C57              SERRTO:
  72+ 7C57 3E FF        	LD	A,0FFH
  73+ 7C59 C9           	RET
  74+ 7C5A
  75+ 7C5A              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7C5A              SERRTF:
  77+ 7C5A 3E 01        	LD	A,01H
  78+ 7C5C C9           	RET
  79+ 7C5D
  80+ 7C5D
  81+ 7C5D
  82+ 7C5D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7C5D              SERRB:
  83+ 7C5D
  84+ 7C5D              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7C5D              ; BITMAPPED OPTIONS IN E:
  86+ 7C5D              ; XXXXXXIT
  87+ 7C5D              ; I SET = leave Interrupts disabled at exit
  88+ 7C5D              ; T SET = return after Timeout
  89+ 7C5D              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7C5D              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7C5D              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7C5D F3           	DI
  93+ 7C5E C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 7C5F              				; OF RECEIVED BYTES
  95+ 7C5F
  96+ 7C5F              SERRBL:
  97+ 7C5F C5           	PUSH	BC
  98+ 7C60 CD 1B 7C     	CALL	SERRXI
  99+ 7C63 C1           	POP	BC
 100+ 7C64 B7           	OR	A
 101+ 7C65 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7C67 72           	LD	(HL),D
 103+ 7C68 23           	INC	HL
 104+ 7C69 0B           	DEC	BC
 105+ 7C6A AF           	XOR	A
 106+ 7C6B B8           	CP	B
 107+ 7C6C 20 F1        	JR	NZ,SERRBL
 108+ 7C6E B9           	CP	C
 109+ 7C6F 20 EE        	JR	NZ,SERRBL
 110+ 7C71              ; FULL RECEIVE
 111+ 7C71 C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 7C72
 113+ 7C72              SERRBX:				; EXIT
 114+ 7C72 CB 4B        	BIT	1,E
 115+ 7C74 C0           	RET	NZ
 116+ 7C75 FB           	EI
 117+ 7C76 C9           	RET
 118+ 7C77
 119+ 7C77              SERRBT:
 120+ 7C77 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7C79 28 04        	JR	Z,SERRBC
 122+ 7C7B CB 43        	BIT	0,E
 123+ 7C7D 28 E0        	JR	Z,SERRBL
 124+ 7C7F
 125+ 7C7F              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7C7F EB           	EX	DE,HL		; PRESERVE HL
 127+ 7C80 E1           	POP	HL		; GET INITIAL COUNT
 128+ 7C81 37           	SCF
 129+ 7C82 3F           	CCF
 130+ 7C83 ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7C85 44           	LD	B,H
 132+ 7C86 4D           	LD	C,L		; BC = COUNT
 133+ 7C87 EB           	EX	DE,HL		; RESTORE HL
 134+ 7C88
 135+ 7C88 18 E8        	JR	SERRBX
 136+ 7C8A
 137+ 7C8A              SERRX:
 137+ 7C8A
 138+ 7C8A              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7C8A              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7C8A              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7C8A F3           	DI
 142+ 7C8B CD 1B 7C     	CALL	SERRXI
 143+ 7C8E FB           	EI
 144+ 7C8F C9           	RET
 145+ 7C90
 146+ 7C90              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7C90              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7C90              SERTB:
 148+ 7C90
 149+ 7C90 7E           	LD	A,(HL)
 150+ 7C91 C5           	PUSH	BC
 151+ 7C92 CD 9D 7C     		CALL	SERTX
 152+ 7C95 C1           	POP	BC
 153+ 7C96 23           	INC	HL
 154+ 7C97 0B           	DEC BC
 155+ 7C98 78           	LD	A, B
 156+ 7C99 B1           	OR	C
 157+ 7C9A 20 F4        	JR	NZ, SERTB
 158+ 7C9C C9           	RET
 159+ 7C9D
 160+ 7C9D              ; SEND CHAR ROUTINE
 161+ 7C9D              SERTX:
 161+ 7C9D
 162+ 7C9D 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7C9E 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7C9F F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7CA0 3E 01        	LD	A,01H
 166+ 7CA2 D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7CA4 1E 20        	LD	E,20H	; PORT MASK
 168+ 7CA6 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 7CA8 3E 01        	LD	A,1
 170+ 7CAA C3 B1 7C     	JP	SBIT
 171+ 7CAD
 172+ 7CAD AF           SHLOOP:	XOR	A		; 4
 173+ 7CAE CB 3A        	SRL	D		; 8
 174+ 7CB0 17           	RLA			; 4
 175+ 7CB1              SBIT:
 176+ 7CB1 B3           	OR	E		; 4
 177+ 7CB2 D3 EF        	OUT	(0EFH),A	; 11
 178+ 7CB4 06 0A        	LD	B,CBAUD		; 7
 179+ 7CB6              SBITDL:
 180+ 7CB6 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 7CB8 00           	NOP			; 4 (TIMING)
 182+ 7CB9 0D           	DEC	C		; 4
 183+ 7CBA 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 7CBC              ; STOP BIT
 185+ 7CBC 3E 20        	LD	A,20H
 186+ 7CBE D3 EF        	OUT	(0EFH),A
 187+ 7CC0 06 0A        	LD	B,CBAUD
 188+ 7CC2 10 FE        STOPL:	DJNZ	STOPL
 189+ 7CC4 FB           	EI
 190+ 7CC5 C9           	RET
# file closed: serial.asm
1450  7CC6              	include "bas2txt.asm"
# file opened: bas2txt.asm
   1+ 7CC6              	IFNDEF _BAS2TXT_
   2+ 7CC6              	DEFINE _BAS2TXT_
   3+ 7CC6
   4+ 7CC6              CHANS		EQU		23631
   5+ 7CC6              CH_LEN		EQU		5
   6+ 7CC6              CHANNEL		EQU		3
   7+ 7CC6              CHAN_OPEN	EQU		$1601
   8+ 7CC6
   9+ 7CC6              NumMarker	EQU		$0E
  10+ 7CC6
  11+ 7CC6              PO_SEARCH	EQU		$0C41
  12+ 7CC6              TKN_TABLE	EQU		$0095
  13+ 7CC6
  14+ 7CC6
  15+ 7CC6              ;Input: HL=source of program, BC=length of program, DE=text output address
  16+ 7CC6              ;Output: DE=end of text
  17+ 7CC6              BASIC2TXT:
  18+ 7CC6 22 89 7D     	ld		(ProgramStartAddr), hl
  19+ 7CC9 09           	add		hl, bc
  20+ 7CCA 22 8B 7D     	ld		(ProgramEndAddr), hl
  21+ 7CCD ED 53 8D 7D  	ld		(DestinationAddr), de
  22+ 7CD1
  23+ 7CD1              	;Open channel.
  24+ 7CD1 3E 03        	LD   A, CHANNEL
  25+ 7CD3 CD 01 16     	CALL CHAN_OPEN		;
  26+ 7CD6
  27+ 7CD6              	;modify output routine
  28+ 7CD6 2A 4F 5C     	ld   hl, (CHANS)
  29+ 7CD9 01 0F 00     	ld	 bc, CH_LEN * CHANNEL
  30+ 7CDC 09           	add	 hl, bc
  31+ 7CDD 11 5C 7D     	ld   de, OutputFnct
  32+ 7CE0 73           	ld   (hl), e
  33+ 7CE1 23           	inc	hl
  34+ 7CE2 72           	ld	(hl), d
  35+ 7CE3
  36+ 7CE3 2A 89 7D     	ld	hl, (ProgramStartAddr)
  37+ 7CE6
  38+ 7CE6              NextLine:
  39+ 7CE6 E5           	PUSH HL
  40+ 7CE7 B7           		or	 a
  41+ 7CE8 ED 5B 8B 7D  		ld   de, (ProgramEndAddr)
  42+ 7CEC EB           		ex	de, hl
  43+ 7CED ED 52        		SBC  HL,DE
  44+ 7CEF 7C           		LD   A,H
  45+ 7CF0 B5           		OR   L
  46+ 7CF1 E1           	POP  HL
  47+ 7CF2 C8           	RET  Z				;Return if length == 0.
  48+ 7CF3
  49+ 7CF3              	;Print line number
  50+ 7CF3 3E 20        	ld		a, ' '
  51+ 7CF5 CD 7A 7D     	call	PrintIt
  52+ 7CF8 46           	LD   B,(HL)
  53+ 7CF9 23           	INC  HL
  54+ 7CFA 4E           	LD   C,(HL)
  55+ 7CFB 23           	INC  HL
  56+ 7CFC E5           	PUSH HL
  57+ 7CFD CD 2B 2D     		CALL $2D2B		;STACK_BC
  58+ 7D00 CD E3 2D     		CALL $2DE3		;PRINT_FP
  59+ 7D03 3E 20        		ld		a, ' '
  60+ 7D05 CD 7A 7D     		call	PrintIt
  61+ 7D08 E1           	POP  HL
  62+ 7D09
  63+ 7D09              	;Get line length in BC.
  64+ 7D09 4E           	LD   C,(HL)
  65+ 7D0A 23           	INC  HL
  66+ 7D0B 46           	LD   B,(HL)
  67+ 7D0C 23           	INC  HL
  68+ 7D0D
  69+ 7D0D              	;Save line end address.
  70+ 7D0D E5           	PUSH HL
  71+ 7D0E 09           		ADD  HL,BC
  72+ 7D0F 22 87 7D     		LD   (LineEndAddr),HL
  73+ 7D12 E1           	POP  HL
  74+ 7D13
  75+ 7D13              GetCharLoop:
  76+ 7D13              	;Load a char
  77+ 7D13 7E           	LD   A, (HL)
  78+ 7D14 FE 0D        	CP   CHR_CR
  79+ 7D16 20 04        	JR   NZ, IsNotCR		; A == CR
  80+ 7D18
  81+ 7D18              	;Print CR and process next line.
  82+ 7D18 23           	INC  HL
  83+ 7D19 D7           	RST  $10			;PRINT_A_1
  84+ 7D1A 18 CA        	JR   NextLine
  85+ 7D1C
  86+ 7D1C              IsNotCR:
  87+ 7D1C FE 2E        	CP   '.'
  88+ 7D1E 28 08        	JR   Z, SearchNum	; A == '.'
  89+ 7D20
  90+ 7D20 FE 3A        	CP   ':'
  91+ 7D22 30 13        	JR   NC, TestSPC1	; A >= ':'
  92+ 7D24
  93+ 7D24 FE 30        	CP   '0'
  94+ 7D26 38 0F        	JR   C, TestSPC1	; A < '0'
  95+ 7D28
  96+ 7D28              SearchNum:
  97+ 7D28 44           	LD   B, H
  98+ 7D29 3E 0E        	LD   A, NumMarker
  99+ 7D2B ED B1        	CPIR
 100+ 7D2D CD B4 33     	CALL $33B4			;STACK_NUM
 101+ 7D30 E5           	PUSH HL
 102+ 7D31 CD E3 2D     		CALL $2DE3		;PRINT_FP
 103+ 7D34 E1           	POP  HL
 104+ 7D35 18 DC        	JR   GetCharLoop
 105+ 7D37
 106+ 7D37              TestSPC1:
 107+ 7D37 FE 20        	CP   ' '
 108+ 7D39 38 02        	JR   C, TestREM		; A < ' '
 109+ 7D3B
 110+ 7D3B              	;Print char >= ' '
 111+ 7D3B D7           	RST  $10			;PRINT_A_1
 112+ 7D3C 7E           	LD   A,(HL)
 113+ 7D3D
 114+ 7D3D              TestREM:
 115+ 7D3D FE EA        	CP   $EA			;RND token
 116+ 7D3F 20 08        	JR   NZ, TestQuote1	; A != RND
 117+ 7D41
 118+ 7D41              	;Print CR.
 119+ 7D41 3E 0D        	LD   A, CHR_CR
 120+ 7D43 D7           	RST  $10			;PRINT_A_1
 121+ 7D44 2A 87 7D     	LD   HL,(LineEndAddr)	;Ingore chars after REM.
 122+ 7D47 18 9D        	JR   NextLine
 123+ 7D49
 124+ 7D49              TestQuote1:
 125+ 7D49 FE 22        	CP   '"'
 126+ 7D4B 20 0C        	JR   NZ, SkipChar	; A != '"'
 127+ 7D4D
 128+ 7D4D              TestSPC2:
 129+ 7D4D 23           	INC  HL
 130+ 7D4E 7E           	LD   A,(HL)
 131+ 7D4F FE 20        	CP   ' '
 132+ 7D51 38 02        	JR   C, TestQuote2	; A < ' '
 133+ 7D53
 134+ 7D53              	;Print >= ' '.
 135+ 7D53 D7           	RST  $10			;PRINT_A_1
 136+ 7D54 7E           	LD   A,(HL)
 137+ 7D55
 138+ 7D55              TestQuote2:
 139+ 7D55 FE 22        	CP   '"'
 140+ 7D57 20 F4        	JR   NZ, TestSPC2	; A != '"'
 141+ 7D59
 142+ 7D59              SkipChar:
 143+ 7D59 23           	INC  HL
 144+ 7D5A 18 B7        	JR   GetCharLoop
 145+ 7D5C
 146+ 7D5C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7D5C
 148+ 7D5C              OutputFnct:
 149+ 7D5C FE A4        	cp	164
 150+ 7D5E 38 1A        	jr	c, PrintIt	; A <= 164 ?
 151+ 7D60
 152+ 7D60 D6 A5        	sub		165
 153+ 7D62 11 95 00     	ld		de, TKN_TABLE
 154+ 7D65 CD 41 0C     	call	PO_SEARCH
 155+ 7D68
 156+ 7D68              NextTokenChar:
 157+ 7D68 1A           	ld		a, (de)
 158+ 7D69 13           	inc		de
 159+ 7D6A CB 7F        	bit		7, a
 160+ 7D6C 20 05        	jr		nz, LastChar
 161+ 7D6E CD 7A 7D     	call	PrintIt
 162+ 7D71 18 F5        	jr		NextTokenChar
 163+ 7D73
 164+ 7D73              LastChar:
 165+ 7D73 E6 7F        	and		%01111111
 166+ 7D75 CD 7A 7D     	call	PrintIt
 167+ 7D78 3E 20        	ld		a, ' '
 168+ 7D7A
 169+ 7D7A              PrintIt:
 170+ 7D7A D5           	push	de
 171+ 7D7B ED 5B 8D 7D  		ld	de, (DestinationAddr)
 172+ 7D7F 12           		ld	(de), a
 173+ 7D80 13           		inc	de
 174+ 7D81 ED 53 8D 7D  		ld	(DestinationAddr), de
 175+ 7D85 D1           	pop		de
 176+ 7D86 C9           	ret
 177+ 7D87
 178+ 7D87 00 00        LineEndAddr			DEFW 0
 179+ 7D89 00 00        ProgramStartAddr	DEFW 0
 180+ 7D8B 00 00        ProgramEndAddr		DEFW 0
 181+ 7D8D 00 00        DestinationAddr		DEFW 0
 182+ 7D8F
 183+ 7D8F              	ENDIF
# file closed: bas2txt.asm
1451  7D8F
1452  7D8F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1453  7D8F 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-23"
1453  7D93 64 20 32 30
1453  7D97 32 33 2D 31
1453  7D9B 32 2D 32 33
1454  7D9F 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1454  7DA3 67 65 20 43
1454  7DA7 68 69 72 74
1454  7DAB 6F 61 63 E1
1455  7DAF 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1455  7DB3 72 61 6D 20
1455  7DB7 49 6E 66 6F
1455  7DBB 20 20 20 A0
1456  7DBF 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1456  7DC3 20 49 6E 66
1456  7DC7 6F 20 20 20
1456  7DCB 20 20 20 A0
1457  7DCF 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1457  7DD3 20 49 6E 66
1457  7DD7 6F 20 20 20
1457  7DDB 20 20 20 A0
1458  7DDF 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1458  7DE3 61 67 65 73
1458  7DE7 20 20 20 20
1458  7DEB 20 20 20 A0
1459  7DEF 31 2D 41 3A  BtnBar			DEFM	'1-A:|2-B:|3-View|4-Prop|5-Copy|6-Ren|7-Attr|8-Del|9-Disk|0-Exi', 't' + $80
1459  7DF3 7C 32 2D 42
1459  7DF7 3A 7C 33 2D
1459  7DFB 56 69 65 77
1459  7DFF 7C 34 2D 50
1459  7E03 72 6F 70 7C
1459  7E07 35 2D 43 6F
1459  7E0B 70 79 7C 36
1459  7E0F 2D 52 65 6E
1459  7E13 7C 37 2D 41
1459  7E17 74 74 72 7C
1459  7E1B 38 2D 44 65
1459  7E1F 6C 7C 39 2D
1459  7E23 44 69 73 6B
1459  7E27 7C 30 2D 45
1459  7E2B 78 69 F4
1460  7E2E 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1460  7E32 46 72 65 65
1460  7E36 3A 20 20
1461  7E39 41 2F        MsgDriveLet		DEFM	'A', '/'
1462  7E3B 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1463  7E3E 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1463  7E42 73 2F 4B 42
1463  7E46 3A
1464  7E47 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1464  7E4B 30 30 30
1465  7E4E 45 72 72 6F  MsgErr			DEFM	'Error code '
1465  7E52 72 20 63 6F
1465  7E56 64 65 20
1466  7E59 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1467  7E5D 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1467  7E61 69 6E 67 20
1467  7E65 50 72 6F 67
1467  7E69 72 61 ED
1468  7E6C 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1468  7E70 69 6E 67 20
1468  7E74 53 43 52 45
1468  7E78 45 4E A4
1469  7E7B 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1469  7E7F 69 6E 67 20
1469  7E83 43 4F 44 45
1469  7E87 20 28 21 A9
1470  7E8B 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1470  7E8F 20 4C 65 6E
1470  7E93 3A
1471  7E94 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1471  7E98 30 20 CB
1472  7E9B 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1472  7E9F 69 62 20 20
1472  7EA3 3A
1473  7EA4 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1473  7EA8 48 49 C4
1474  7EAB 54 79 70 65  MsgFileType		DEFM	'Type    :'
1474  7EAF 20 20 20 20
1474  7EB3 3A
1475  7EB4 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1475  7EB8 20 20 20 20
1475  7EBC 20 A0
1476  7EBE 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1476  7EC2 72 61 ED
1477  7EC5 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1477  7EC9 73 20 A0
1478  7ECC 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1478  7ED0 45 4E A4
1479  7ED3 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1479  7ED7 41 72 F2
1480  7EDA 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1480  7EDE 41 72 F2
1481  7EE1 55 6E 74 79  MsgFileTypeText	DEFM	'Untype', 'd' + $80
1481  7EE5 70 65 E4
1482  7EE8 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1482  7EEC 20 20 A0
1483  7EEF 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1483  7EF3 74 68 20 20
1483  7EF7 3A
1484  7EF8 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1484  7EFC 35 20 C2
1485  7EFF 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1485  7F03 74 20 20 20
1485  7F07 3A
1486  7F08 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1486  7F0C 35 20 A0
1487  7F0F 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1487  7F13 69 6E 67 20
1487  7F17 68 65 61 64
1487  7F1B 65 F2
1488  7F1D 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1488  7F21 20 20 20 20
1488  7F25 20 20 20 20
1488  7F29 20 20 20 A0
1489  7F2D 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1489  7F31 66 69 6C 65
1489  7F35 3F 20 79 2F
1489  7F39 EE
1490  7F3A 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1490  7F3E 52 2F 4F 3F
1490  7F42 20 79 2F EE
1491  7F46 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1491  7F4A 48 49 44 3F
1491  7F4E 20 79 2F EE
1492  7F52 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1492  7F56 3F 6E 6F 6E
1492  7F5A 65 3D 61 62
1492  7F5E 6F 72 74 BA
1493  7F62 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1493  7F66 20 6D 65 6E
1493  7F6A 75 BA
1494  7F6C 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1494  7F70 20 63 6F 70
1494  7F74 79 20 6D 65
1494  7F78 6E 75 BA
1495  7F7B 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1495  7F7F 78 69 74 20
1495  7F83 6D 65 6E F5
1496  7F87
1497  7F87 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1497  7F8B 6F 70 79 20
1498  7F8F 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1499  7F93 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1500  7F95
1501  7F95 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1501  7F99 6F 70 79 20
1502  7F9D 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1503  7FA1 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1504  7FA3
1505  7FA3 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1505  7FA7 6F 70 79 20
1506  7FAB 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1506  7FAF 43 4F CD
1507  7FB2
1508  7FB2 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1508  7FB6 6F 70 79 20
1508  7FBA 43 4F 4D 2D
1508  7FBE 3E
1509  7FBF 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1510  7FC1
1511  7FC1 35 2E 20 46  MsgMenuFmt1		DEFM	'5. Format A', ':' | $80
1511  7FC5 6F 72 6D 61
1511  7FC9 74 20 41 BA
1512  7FCD 36 2E 20 46  MsgMenuFmt2		DEFM	'6. Format B', ':' | $80
1512  7FD1 6F 72 6D 61
1512  7FD5 74 20 42 BA
1513  7FD9
1514  7FD9 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1514  7FDD 62 6C 6F 63
1514  7FE1 6B 73 20 6C
1514  7FE5 65 66 F4
1515  7FE8 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1515  7FEC 77 72 69 74
1515  7FF0 65 3F 20 79
1515  7FF4 2F EE
1516  7FF6 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1516  7FFA 20 6E 61 6D
1516  7FFE 65 20 65 78
1516  8002 69 73 74 F3
1517  8006 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1517  800A 53 4F 55 52
1517  800E 43 45 20 64
1517  8012 69 73 EB
1518  8015 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1518  8019 44 45 53 54
1518  801D 2E 20 64 69
1518  8021 73 6B A0
1519  8024 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1519  8028 73 20 61 6E
1519  802C 79 20 6B 65
1519  8030 F9
1520  8031 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1520  8035 73 65 63 74
1520  8039 6F 72 73 20
1520  803D 63 6F 70 F9
1521  8041 41 72 65 20  MsgAreYouSure	DEFM	'Are you sure?y/', 'n' | $80
1521  8045 79 6F 75 20
1521  8049 73 75 72 65
1521  804D 3F 79 2F EE
1522  8051 52 65 61 64  MsgFileLoading	DEFM	'Reading file..', '.' | $80
1522  8055 69 6E 67 20
1522  8059 66 69 6C 65
1522  805D 2E 2E AE
1523  8060 56 69 65 77  MsgViewFileMenu	DEFM	'View file menu', ':' | $80
1523  8064 20 66 69 6C
1523  8068 65 20 6D 65
1523  806C 6E 75 BA
1524  806F 31 2E 41 73  MsgViewFileText	DEFM	'1.As tex', 't' | $80
1524  8073 20 74 65 78
1524  8077 F4
1525  8078 32 2E 41 73  MsgViewFileHex	DEFM	'2.As he', 'x' | $80
1525  807C 20 68 65 F8
1526  8080 33 2E 41 75  MsgViewFileAuto	DEFM	'3.Auto-1/2/BASI', 'C' | $80
1526  8084 74 6F 2D 31
1526  8088 2F 32 2F 42
1526  808C 41 53 49 C3
1527  8090
1528  8090              	IFNDEF	_REAL_HW_
1529  8090 ~            FontTable:
1530  8090 ~            	incbin "cpmfnt.bin"
1531  8090              	ENDIF
1532  8090              EndCode:
1533  8090
1534  8090              ;Unalocated variables
1535  8090              UnallocStart	EQU		EndCode
1536  8090              FileCnt			EQU		UnallocStart			;File counter, 1B
1537  8090              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1538  8090              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1539  8090              CursorAddr		EQU		SelFile + 1				;2 B
1540  8090              AUCntUsed		EQU		CursorAddr + 2			;2 B
1541  8090              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1542  8090              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1543  8090              CopySelOption	EQU		SelFileCache+2			;1 B
1544  8090
1545  8090              CopyFileFCB		EQU	CopySelOption + 1
1546  8090              CopyFileRes		EQU CopyFileFCB + 2
1547  8090              CopyFileDMAAddr	EQU	CopyFileRes + 1
1548  8090              FilePosRead		EQU	CopyFileDMAAddr + 2
1549  8090              FilePosWrite	EQU	FilePosRead + 2
1550  8090              CopyFileSectCnt EQU FilePosWrite + 2
1551  8090              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1552  8090              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1553  8090              CopyFileDstDrv	EQU CopyFileSrcName + 11
1554  8090              CopyFileDstName	EQU CopyFileDstDrv + 1
1555  8090
1556  8090              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1557  8090              ;FS block list constants
1558  8090              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1559  8090              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1560  8090              UsedBlockListSz		EQU 320 * 2 + 2							;640
1561  8090
1562  8090              	IFDEF	_REAL_HW_
1563  8090              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1564  8090              DataBuf			EQU		FontTable + 872
1565  8090              	ELSE
1566  8090 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1567  8090              	ENDIF
1568  8090
1569  8090              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1570  8090
1571  8090
1572  8090              ;File viewer constants
1573  8090              FileData		EQU		DataBuf
1574  8090              ;4K index allows for 2000 lines of text.
1575  8090              FileIdxSize		EQU		4	 * 1024
1576  8090              ;File buffer size, without index
1577  8090              FileDataSize	EQU		(MAX_SECT_RAM * SECT_SZ) - FileIdxSize
1578  8090              ;Set a few KB aside for file indexing
1579  8090              FileIdx			EQU		FileData + FileDataSize
1580  8090              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1581  8090
1582  8090
1583  8090              ;Copy buffer size, follows
1584  8090              CopyDiskBuf			EQU DataBuf
1585  8090
1586  8090              ;256 bytes for the stack should be enough.
1587  8090              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1588  8090              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1589  8090              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1590  8090
1591  8090              	DISPLAY "DataBuf: ", /D,DataBuf
1592  8090              	DISPLAY "BinSize: ", /D, EndCode - Start
1593  8090              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1594  8090              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6EBF   NoSub
0x6EB8   DivLoop
0x7024   MAX_RAM_FREE
0x0070   MAX_SECT_RAM
0x1000   FileIdxSize
0x0282   UsedBlockListSz
0x8090   UnallocStart
0x8090   EndCode
0x7E3B X MsgFreeSpaceNo
0x7D73   LastChar
0x7D68   NextTokenChar
0x7D55   TestQuote2
0x7D4D   TestSPC2
0x7D59   SkipChar
0x7D49   TestQuote1
0x7D3D   TestREM
0x7D37   TestSPC1
0x7D28   SearchNum
0x7D1C   IsNotCR
0x7D13   GetCharLoop
0x7D87   LineEndAddr
0x7D7A   PrintIt
0x7CE6   NextLine
0x7D5C   OutputFnct
0x7D8B   ProgramEndAddr
0x7D89   ProgramStartAddr
0x0095   TKN_TABLE
0x0C41   PO_SEARCH
0x000E   NumMarker
0x1601   CHAN_OPEN
0x0003   CHANNEL
0x0005   CH_LEN
0x5C4F   CHANS
0x7CC2   STOPL
0x7CAD   SHLOOP
0x7CB1   SBIT
0x7CB6   SBITDL
0x7C9D   SERTX
0x7C8A X SERRX
0x7C7F   SERRBC
0x7C72   SERRBX
0x7C77   SERRBT
0x7C5F   SERRBL
0x7C4C X SERWI
0x7C5A   SERRTF
0x7C49   SERWIL
0x7C34   SERRL
0x7C57   SERRTO
0x7C2A   SERWS
0x7C22   SERWSL
0x7C1B   SERRXI
0x000A   CBAUD
0x7BA0   PrintCharValid
0x7B9E   PrintCharNotValid
0x7B93   PrintOneLineNotTab
0x7B8C   PrintOneLineLoop
0x7B7C X TextViewerEnd
0x7B71 X TextViewerCheckEnd
0x7B6B X TextViewerIncrementIndex
0x7B5B   TextViewIndexStoreLineLen
0x7B53   TextViewIndexNoLF
0x7B4D   TextViewCheckLF
0x7B3A   TextViewIndexLoop
0x7BD5   FileEnd
0x7ACD   TextViewerScrollUp1
0x7AAF   TextViewerScrollUp
0x7AE0   TextViewerScrollDown
0x7BDB   MsgLine
0x7A8C   TextViewerShowFilename
0x7BE1   MsgLineFileName
0x7BF3   MsgLineNo
0x7A7A   TextViewerLoop3
0x7BF9   MsgLineTotal
0x7BD9   FirstLineShown
0x7B7D   PrintOneLine
0x7A4C   TextViewerLoop
0x7A48   MoreThan23LinesInFile
0x7BD7   LineCount
0x7A37 X TextViewerLoop2
0x7B20   TextViewIndex
0x7A06   ScrollDownLoop
0x79FD   ScrollDownLoop2
0x7A04   ScrollDownPtrSrc
0x7A01   ScrollDownPtrDest
0x79F0   ScrollDown
0x79F3   Scroll
0x79EB   ScrollUp
0x79DA   FillScrLinesRev
0x79C5   FillScrLinesLoop
0x79B1   ScrollInit
0x79A7   GetCellDown
0x5B2E   SCRLinesUp
0x5B00   SCRLinesDown
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A X CHAR_LF
0x0017   LINE_CNT
0x7993   ClearNMsgLinesLoop
0x7981   ReadStrPrint
0x7971   ReadStrChar
0x7954   ReadStringLoop
0x7948   Store
0x7947   NoTurn
0x793C   PrintCharLine
0x7928 X PrintChar3
0x78D3   DrawCursorLoop
0x78BA   DrawVLinesLoop
0x788B   DrawLowerIntersectLoop
0x789C   DrawIntersect
0x7876   DrawUpperIntersectLoop
0x784A   DrawLineLoop
0x7857   LineDir
0x7847   StoreDir
0x7845   VertDir
0x783C   DrawLine
0x7838   StrClr
0x77EB   GoodChar
0x79A3   CurrScrAddr
0x8B74   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A   CHR_LF
0x000D   CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x776A   ReadWriteFileSectionLoop
0x7788   ReadWriteFileSectionEnd
0x809F   CopyFileDMAAddr
0x809C   CopyFileFCB
0x772F   ReadWriteFileSection
0x779A   CopyFilePtr2
0x7755   CopyFilePtr
0x777D   CopyFileOperAddr2
0x775E   CopyFileOperAddr1
0x76DD   CopyFileFromCOMDontInc
0x6000   FileDataSize
0x76CA   CopyFileFromCOMLoop
0x7669   CopyFileToCOMEnd
0x7649   CopyFileToCOMLoop
0x7601   CopyFileDualDriveLoop
0x7716   WriteFileSection
0x8031   MsgCopySectors
0x7598   CopyFileSameDriveLoop
0x80A5   CopyFileSectCnt
0x7554   CopyFileCreateNewFile
0x7FE8   MsgFileOverwrite
0x7538   CopyFileCheckOverwrite
0x766E   CopyFileFromCOM
0x763B   CopyFileToCOM
0x75F1   CopyFileDualDrive
0x7572   CopyFileSameDrive
0x7521   CopyFileNotExit
0x7F6C   MsgMenuFileCopy
0x80A3   FilePosWrite
0x80B3   CopyFileDstName
0x80A7   CopyFileSrcName
0x8006   MsgInsertSrcDsk
0x8024   MsgPressAnyKey
0x8015   MsgInsertDstDsk
0x7424 X FileAttribSet
0xEEDC   FileIdx
0x73D2   GetFileSizeMul
0x73D8   GetFileSizeEnd
0x73D0   GetFileSizeOK
0x73B0   BDOSSetRandFilePtr
0x73AC   BDOSSetDMA
0x739E   BDOSWriteFileBlockRandom
0x739A   BDOSReadFileBlockRandom
0x7396   BDOSWriteFileBlockSeq
0x7392   BDOSReadFileBlockSeq
0x738E   BDOSCloseFile
0x738A   BDOSOpenFile
0x7386   BDOSCreateFile
0x737C   DestroyChannel
0x7366   CreateChannel
0x7366 X BDOSCloseDrives
0x7362 X BDOSGetDiskRO
0x7362 X BDOSMakeDiskRO
0x73A2   BDOS
0x7354 X PrmIntrlvTbl
0x7353 X PrmSpinUp
0x7352 X PrmHeadLoad
0x7350 X PrmDevType
0x0004   PrmFastFactor
0x734B X RWTSResTmp
0x734A X RWTSResVolNo
0x7350   BasPrmTbl
0x7346 X RWTSPrmTbl
0x7344 X RWTSExtBuf
0x7341 X RWTSSector
0x733F X RWTSVolNo
0x733D X RWTSBlockType
0x7334   CopyMsg
0x7328   SearchMsgEnd
0x7331   SaveMsg
0x731F   IF1Paged
0x72ED   IF1Call
0x72E8   IsFileHeaderValidLoop
0x73B4   GetFileSize
0x72CC   ReadFileHeaderIsTextFile
0x72E5   IsFileHeaderValid
0x72E1   ReadHeaderEnd
0x7286   CacheNotFinished
0x727B X SeekTrack
0x7230   FileReadLoop
0x7224 X FileLoadHeader
0x7236   FileLoadNoHeader
0x7244   FileFree
0x7200   MisMatch
0x71F8   Compare
0x71F6   StrCmp
0x71AD   CopyDiskFromCOMLoop
0x7C5D   SERRB
0x7149   CopyDiskToCOMLoop
0x7C90   SERTB
0x746A   PromptDiskChangeSrc
0x7121   CopyDiskDualDrive2
0x712E   CopyDiskEnd
0x70FD X CopyDiskWriteEnd
0x70E6   CopyDiskLoopWriteLoop
0x70DF   CopyDiskReadEnd
0x7450   PromptDiskChangeDst
0x70D5   CopyDiskDualDrive1
0x70AC   CopyDiskLoopReadLoop
0x8EDC   CopyDiskBuf
0x70A5   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7FD9   MsgBlocksLeft
0x7082   CopyDiskLoop
0x88F4   UsedBlockListBlk
0x725C   WriteDiskSectors
0x706E   WriteFSBlock
0x7249   ReadDiskSectors
0x7061   ReadFSBlock
0x7053   ReadUsedBlocksSkip
0x7036   ReadUsedBlocksLoop2
0x7056   ReadUsedBlocksSkip2
0x7026   ReadUsedBlocksLoop
0x88F2   UsedBlockListCnt
0x7008   ReadUsedBlocksList
0x7001   CheckAUEnd
0x6FED   CheckAU
0x6FD6   FirstAU
0x6FD0   Track0
0x6FBB   AU2TS
0x6F9F   WriteOneDiskSector
0x7340   RWTSTrack
0x7342   RWTSDMA
0x733D   RWTSParams
0x7348   RWTSCmd
0x6F88   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6F73   Bin2HexLineLoopHex2
0x6F5F   Bin2HexLineClear
0x0040   COL_CNT
0x6F4F   Bin2HexStrLoop
0x6F2F   Bin2HexLineLoopText
0x6F2C X Bin2HexLineText
0x6F24   Bin2HexLineLoopHexNotHalf
0x6F17   Bin2HexLineLoopHex
0x6F14   Bin2HexLine
0x0010   HEX_COLUMNS
0x6F11   Bin2HexLineLoopTextCopy
0x6F0E   Bin2HexLineLoopTextReplace
0x000D   CHAR_CR
0x6F04   Byte2HexChar
0x6EFB   Byte2HexHex
0x6EEF   Byte2HexNibble
0x6EE9   Byte2Hex
0x6EE6   NoAdd
0x6EE0   MulLoop
0x6EC7   Div2Loop
0x6EC2 X Div2
0x6EB5   Div
0x6EAC   DivNrLoop
0x6EAA   DigitLoop
0x6E9B   Byte2Txt_
0x6E84   StrippLeading0
0x6E8F   Word2Txt_
0x6E6E X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x6E6B   DontInc
0x6E65   ReadAllHeadersEnd
0x6E50   AKey
0x77AB   KbdHit
0x6E35   NextFile
0x7EEF   MsgFileLen
0x7EAB   MsgFileType
0x7EFF   MsgFileStart
0x6DF4   PrintStartStr
0x7F08   MsgFileStartN
0x7EE8   MsgNA
0x6DE6   PrintStart
0x0007   HDR_LINE
0x6DC1   PrintByteStart
0x6DB9   PrintProgStart
0x7EF8   MsgFileLenN
0x6D9F X PrepFileLenText
0x7EE1   MsgFileTypeText
0x7EC5   MsgFileTypeByte
0x7ECC   MsgFileTypeSCR
0x6D85   NotScr
0x6D90   CheckText
0x7ED3   MsgFileTypeChrA
0x6D68   CheckByte
0x0002   CHAR_TYPE
0x7EDA   MsgFileTypeNoA
0x6D59   CheckChrArr
0x0001   NUMB_TYPE
0x6D99   PrepFileLen
0x7351 X PrmStepRate
0x6E12   MoveMsg
0x7EB4   MsgFileTypeN
0x7EBE   MsgFileTypePrg
0x6D4A   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6DC9   HeadNotRead
0x7E9B   MsgFileAttr
0x6D1B   AttrEnd
0x6D11   NotSYS
0x6CFF   CheckSys
0x6CF1   NotRO
0x0008   RO_POS
0x0000   CACHE_NAME
0x6DDB   PrintStartNotRead
0x7E8B   MsgFileSzDsk
0x7E94   MsgFileSzDskN
0x6CAE   ReadFileForViewingUseReadLenght
0x6CB1   ReadFileForViewingNoHeader
0x0004   TEXT_TYPE
0x76F1   ReadFileSection
0x80A1   FilePosRead
0x7A2B   TextViewer
0x5CED   HD11
0x001A   CHAR_EOF
0x7D8D   DestinationAddr
0x7CC6   BASIC2TXT
0x0005   HDR_PLEN
0x6F35   Bin2HexStr
0x6C6B   ViewFileText
0x6C76   ReadFileForViewing
0x0060   MAX_SECT_BUF
0x6C47   ViewFileAsBASIC
0x6C1A X ViewFileAuto
0x6C31   ViewFileAsHex
0x6C29   ViewFileAsText
0x8051   MsgFileLoading
0x7EA4   MsgFileAttrN
0x0003 X ViewFileConvertRatioASM
0x0005   ViewFileConvertRatioHEX
0x0004   ViewFileConvertRatioBASIC
0x0001   ViewFileConvertRatioText
0x72F3   LoadProgram
0x80A6   CopyFileSrcDrv
0x7E5D   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7E6C   MsgLoadingSCR
0x0003   HDR_ADDR
0x7249   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7203   IF1FileLoad
0x7E7B   MsgLoadingCODE
0x6BA5 X HandleFileCODE
0x6BCB   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6BF9   HandleFileText
0x0003   BYTE_TYPE
0x6BE9   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6B6F   FindExtEnd
0x727B   FindCache
0x6B7E   GetFileNamesEnd
0x0009   HDR_SZ
0x6B4A   FindExt
0x000C   EXT_IDX
0x6FD9   CheckExtAlloc
0x6B71   NextExt
0x0000   EXT_DEL_FLAG
0x6AFD   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6ADA   DisplayFilenamesLoop
0x6AC0   LineOK
0x5CB1   LINE
0x5CB0   COL
0x7910   PrintChar
0x5C81   CODE
0x6A9A   DispLoop
0x6A98   DisplayFilename
0x78D8   MoveCursor
0x6FAA   FormatDisk
0x8041   MsgAreYouSure
0x6A40   FormatDiskAction
0x6A33   CheckDiskMenuFormat2
0x7190   CopyDiskFromCOM
0x6A24   CheckDiskMenuFormat1
0x7134   CopyDiskToCOM
0x6A1A   CheckDiskMenuFromCOM
0x6A11   CheckDiskMenuToCOM
0x707B   CopyDisk
0x6A03   CheckDiskMenuDualDrive
0x6A87   DiskMenuExit
0x69EF X CheckKeyDiskMenuLoop
0x7FCD   MsgMenuFmt2
0x7FC1   MsgMenuFmt1
0x7FB2   MsgMenuFromCOM
0x7FA3   MsgMenuToCOM
0x7F95   MsgMenuDual
0x7F87   MsgMenuSingle
0x7F7B   MsgMenuBack
0x7F62   MsgMenuDiskCopy
0x7FA1   MsgMenuDualDrv2
0x7FBF   MsgMenuFromCOMDrv
0x7FAB   MsgMenuToComDrv
0x7F9D   MsgMenuDualDrv1
0x7F93   MsgMenuSingleDrv2
0x7F8F   MsgMenuSingleDrv1
0x6A8A   CheckKeyExit
0x7403   ChangeFileAttrib
0x6962   AttrChange
0x7F46   MsgSetSYS
0x694A   CheckSYS
0x7F3A   MsgSetRO
0x6974   CheckKeyDiskMenu
0x73DE   DeleteFile
0x691C   DoFileDelete
0x7F2D   MsgDelete
0x6929   CheckKeyAttrib
0x742D   RenameFile
0x7FF6   MsgFileExists
0x68E3   RenameFileNotExist
0x73EA   DoesFileExist
0x68EF   RenameCanceled
0x794E   ReadString
0x000B   NAMELEN
0x7F1D   MsgClear
0x7F52   MsgNewFileName
0x68F7   CheckKeyDel
0x6BFA   ViewFile
0x8080   MsgViewFileAuto
0x8078   MsgViewFileHex
0x806F   MsgViewFileText
0x8060   MsgViewFileMenu
0x6887   CheckKeyRename
0x0001   DRIVE_B_CPM
0x684D   CheckKeyView
0x696B   SelectDrive
0x6844   CheckKeyDriveB
0x6E18   ReadAllHeaders
0x683B   CheckKeyDriveA
0x80B2   CopyFileDstDrv
0x809B   CopySelOption
0x6810   CopyFileOK
0x809E   CopyFileRes
0x7484   CopyFile
0x682A   CheckKeyFileInfo
0x7990   ClearNMsgLines
0x728C   ReadFileHeader
0x7F0F   MsgReadingExt
0x67DE   CheckKeyCopy
0x6B7F   HandleFile
0x67B9   CheckKeyInfo
0x67B3   DoKeyEnter
0x000D   KEY_ENTER
0x67AA   CheckEnter
0x679D   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6795   CheckLeft
0x6783   DoKeyRight
0x0009   KEY_RIGHT
0x677B   CheckRight
0x676E   DoKeyUp
0x000B   KEY_UP
0x6A92   MoveIt
0x6766   CheckUp
0x6755   DoKeyDown
0x000A   KEY_DOWN
0x6CB2   DisplayFileInfo
0x8099   SelFileCache
0x6ED5   Mul
0x6733   CalcFileCache
0x7E3E   MsgFilesCnt
0x8090   FileCnt
0x7E47   MsgFilesCntNo
0x7E2E   MsgDrive
0x6E6E   Word2Txt
0x7E39   MsgDriveLet
0x8095   AUCntUsed
0x730C   SetFastKeys
0x78CD   DrawCursor
0x0060   SCR_SEL_CLR
0x7DDF   MsgMessages
0x0007   LST_FILE_INFO
0x7DCF   MsgFileInf
0x0004   LST_DISK_INFO
0x7DBF   MsgDskInf
0x7DAF   MsgSysInf
0x7DEF   BtnBar
0x0060   SCR_LBL_CLR
0x7D9F   VerMsg2
0x77E4   PrintStr
0x0001   LST_PROG_INFO
0x7D8F   VerMsg1
0x785B   DrawHLines
0x78B5   DrawVLines
0x8093   CursorAddr
0x79A5   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x77C4   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x8091   NameCol
0x0010   LST_FIRST_COL
0x8092   SelFile
0x77A8   ReadChar
0x8EDC   DataBuf
0x7317   GetErrMsg
0x5C3A   ERRNR
0x6616   HCRunEnd
0x6744   ReadKeyLoop
0x66D1   DisplayDiskInfo
0x6ACA   DisplayFilenames
0x6653   InitUI
0x660A   HCRunMain
0x6AEA   GetFileNames
0x780C   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7E4E   MsgErr
0x6E79   Byte2Txt
0x7E59   MsgErrCode
0x6607   HCRunCacheFiles
0x726F   ReadCatalogTrack
0x8097   AUCntMaxFree
0x65E4   DriveIs80Tracks
0x7BBF   PrintOneLineCleanLine
0x013E   MAX_FREE_AU_CNT
0x7349   RWTSRes
0x6F94   ReadOneDiskSector
0x8EDC   FileData
0x0050   TRACK_CNT
0x7359   BDOSSelectDisk
0x733E   RWTSDrive
0x7356   BDOSInit
0x0000   DRIVE_A_CPM
0x65C5   DetectTrackCount
0x7362   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x80BE   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8EDC   TrackBuf
0x65A2   HCRunInitDisk
0x661E   ErrorHandler
0x5C3D   ERRSP
0x6F85   IF1Init
0x77AE   InitFonts
0x6590   Start
