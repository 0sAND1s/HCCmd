# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 37000
  12  9088
  13  9088              Start:
  14  9088              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  9088 CD 7B 9F     		call InitFonts
  16  908B              	ENDIF
  17  908B CD DD 98     	call IF1Init
  18  908E
  19  908E              	;install error handler
  20  908E 2A 3D 5C     	ld		hl, (ERRSP)
  21  9091 E5           	push	hl
  22  9092 21 F0 90     	ld		hl, ErrorHandler
  23  9095 E5           	push	hl
  24  9096 ED 73 3D 5C  	ld		(ERRSP), sp
  25  909A
  26  909A              HCRunInitDisk:
  27  909A              	;Set track buffer to del marker
  28  909A 21 E3 B6     	ld		hl, TrackBuf
  29  909D 54           	ld		d, h
  30  909E 5D           	ld		e, l
  31  909F 13           	inc		de
  32  90A0 01 00 10     	ld		bc, SPT*SECT_SZ
  33  90A3 36 E5        	ld		(hl), DEL_MARKER
  34  90A5 ED B0        	ldir
  35  90A7
  36  90A7              	;Invalidate file cache
  37  90A7 21 FD A7     	ld		hl, FileCache
  38  90AA 54           	ld		d, h
  39  90AB 5D           	ld		e, l
  40  90AC 13           	inc		de
  41  90AD 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  90B0 36 00        	ld		(hl), 0
  43  90B2 ED B0        	ldir
  44  90B4
  45  90B4              	;main program
  46  90B4 CD 96 9B     	call 	ReadCatalogTrack
  47  90B7 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  90B8 28 1E        	jr		z, HCRunCacheFiles
  49  90BA
  50  90BA 6F           	ld		l, a
  51  90BB 26 00        	ld		h, 0
  52  90BD 11 1B A6     	ld		de, MsgErrCode
  53  90C0 CD 6D 98     	call	Byte2Txt
  54  90C3 21 10 A6     	ld		hl, MsgErr
  55  90C6 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  56  90C9 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  90CB CD D9 9F     	call	PrintStrClr
  58  90CE CD 75 9F     	call	ReadChar
  59  90D1 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  90D3 32 72 9C     	ld		(RWTSDrive), a
  61  90D6 18 C2        	jr		HCRunInitDisk
  62  90D8
  63  90D8              HCRunCacheFiles:
  64  90D8 CD 32 95     	call 	GetFileNames
  65  90DB
  66  90DB              HCRunMain:
  67  90DB CD 22 91     	call 	InitUI
  68  90DE CD 47 98     	call	PrintIntro
  69  90E1 CD 12 95     	call	DisplayFilenames
  70  90E4 CD 85 91     	call	DisplayDiskInfo
  71  90E7 C3 DF 91     	jp		ReadKeyLoop
  72  90EA
  73  90EA              HCRunEnd:
  74  90EA              	;restore error handler
  75  90EA E1           	pop		hl
  76  90EB E1           	pop		hl
  77  90EC 22 3D 5C     	ld		(ERRSP), hl
  78  90EF
  79  90EF C9           	ret
  80  90F0
  81  90F0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  82  90F0
  83  90F0              ErrorHandler:
  84  90F0 E1           	pop		hl
  85  90F1 22 3D 5C     	ld		(ERRSP), hl
  86  90F4
  87  90F4 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  88  90F7 6F           	ld		l, a
  89  90F8 26 00        	ld		h, 0
  90  90FA 11 1B A6     	ld		de, MsgErrCode
  91  90FD CD 6D 98     	call	Byte2Txt
  92  9100 21 10 A6     	ld		hl, MsgErr
  93  9103 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  94  9106 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  95  9108 CD D9 9F     	call	PrintStrClr
  96  910B
  97  910B 3A 3A 5C     	ld		a, (ERRNR)
  98  910E CD 4B 9C     	call	GetErrMsg
  99  9111
 100  9111 21 E3 B6     	ld		hl, DataBuf
 101  9114 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 102  9117 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 103  9119 CD D9 9F     	call	PrintStrClr
 104  911C
 105  911C CD 75 9F     	call	ReadChar
 106  911F C3 88 90     	jp	Start
 107  9122
 108  9122
 109  9122
 110  9122
 111  9122              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 112  9122
 113  9122              InitUI:
 114  9122 AF           	xor		a
 115  9123 32 F6 A7     	ld		(SelFile), A
 116  9126 3E 11        	ld		a, LST_FIRST_COL + 1
 117  9128 32 F5 A7     	ld		(NameCol), A
 118  912B 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 119  912E ED 53 B0 5C  	ld		(LineCol), de
 120  9132
 121  9132 CD 91 9F     	call	ClrScr
 122  9135
 123  9135 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 124  9138 ED 4B 36 A1  	ld		bc, (CurrScrAttrAddr)
 125  913C 09           	add		hl, bc
 126  913D 22 F7 A7     	ld		(CursorAddr), hl
 127  9140
 128  9140 3E 84        	ld		a, CHR_DC
 129  9142 CD 52 A0     	call	DrawVLines
 130  9145
 131  9145 3E 28        	ld		a, SCR_LBL_CLR
 132  9147 11 00 17     	ld		de, 23 << 8
 133  914A 21 A1 A5     	ld		hl, BtnBar
 134  914D CD D9 9F     	call	PrintStrClr
 135  9150
 136  9150 3E 28        	ld		a, SCR_LBL_CLR
 137  9152 21 61 A5     	ld		hl, MsgSysInf
 138  9155 11 00 00     	ld		de, LST_PROG_INFO << 8
 139  9158 CD D9 9F     	call	PrintStrClr
 140  915B
 141  915B 3E 28        	ld		a, SCR_LBL_CLR
 142  915D 21 71 A5     	ld		hl, MsgDskInf
 143  9160 11 00 04     	ld		de, LST_DISK_INFO << 8
 144  9163 CD D9 9F     	call	PrintStrClr
 145  9166
 146  9166 3E 28        	ld		a, SCR_LBL_CLR
 147  9168 21 81 A5     	ld		hl, MsgFileInf
 148  916B 11 00 08     	ld		de, LST_FILE_INFO << 8
 149  916E CD D9 9F     	call	PrintStrClr
 150  9171
 151  9171 3E 28        	ld		a, SCR_LBL_CLR
 152  9173 21 91 A5     	ld		hl, MsgMessages
 153  9176 11 00 0E     	ld		de, LST_LINE_MSG << 8
 154  9179 CD D9 9F     	call	PrintStrClr
 155  917C
 156  917C 3E 28        	ld		a, SCR_SEL_CLR
 157  917E CD 71 A0     	call	DrawCursor
 158  9181
 159  9181 CD 40 9C     	call	SetFastKeys
 160  9184
 161  9184 C9           	ret
 162  9185
 163  9185
 164  9185              DisplayDiskInfo:
 165  9185 3A 72 9C     	ld		a, (RWTSDrive)
 166  9188 C6 C1        	add		'A' + $80
 167  918A 32 EF A5     	ld		(MsgDriveLet), a
 168  918D 21 E0 A5     	ld		hl, MsgDrive
 169  9190 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 170  9193 CD B1 9F     	call	PrintStr
 171  9196
 172  9196 3A F4 A7     	ld		a, (FileCnt)
 173  9199 6F           	ld		l, a
 174  919A 26 00        	ld		h, 0
 175  919C 11 F9 A5     	ld		de, MsgFilesCntNo
 176  919F CD 6D 98     	call	Byte2Txt
 177  91A2 21 F0 A5     	ld		hl, MsgFilesCnt
 178  91A5 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 179  91A8 CD B1 9F     	call	PrintStr
 180  91AB
 181  91AB ED 5B F9 A7  	ld		de, (AUCnt)
 182  91AF 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 183  91B2 B7           	or		a
 184  91B3 ED 52        	sbc		hl, de
 185  91B5 CB 15        	rl		l								;*2, 2K/AU
 186  91B7 CB 14        	rl		h
 187  91B9 11 07 A6     	ld		de, MsgFreeSpaceNo - 2
 188  91BC CD 62 98     	call	Word2Txt
 189  91BF 3E 3A        	ld		a, ':'
 190  91C1 32 08 A6     	ld		(MsgFreeSpaceNo -1), a
 191  91C4 21 00 A6     	ld		hl, MsgFreeSpace
 192  91C7 11 00 07     	ld		de, LST_DISK_INFO + 3 << 8
 193  91CA CD B1 9F     	call	PrintStr
 194  91CD
 195  91CD C9           	ret
 196  91CE
 197  91CE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198  91CE
 199  91CE              CalcFileCache:
 200  91CE 3A F6 A7     	ld		a, (SelFile)
 201  91D1 11 19 00     	ld		de, CACHE_SZ
 202  91D4 CD C9 98     	call	Mul
 203  91D7 01 FD A7     	ld		bc, FileCache
 204  91DA 09           	add		hl, bc					;HL = file AU cnt
 205  91DB 22 FB A7     	ld		(SelFileCache), hl
 206  91DE C9           	ret
 207  91DF
 208  91DF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209  91DF
 210  91DF
 211  91DF              ReadKeyLoop:
 212  91DF CD CE 91     	call	CalcFileCache
 213  91E2 CD 79 96     	call	DisplayFileInfo
 214  91E5
 215  91E5 CD 75 9F     	call	ReadChar
 216  91E8
 217  91E8 FE 0A        	cp		KEY_DOWN
 218  91EA 20 11        	jr		nz, CheckUp
 219  91EC
 220  91EC 3A F4 A7     	ld		a, (FileCnt)
 221  91EF 47           	ld		b, a
 222  91F0 3A F6 A7     	ld		a, (SelFile)
 223  91F3 3C           	inc		a
 224  91F4 B8           	cp		b
 225  91F5 30 E8        	jr		nc, ReadKeyLoop
 226  91F7 32 F6 A7     	ld		(SelFile), a
 227  91FA C3 DA 94     	jp		MoveIt
 228  91FD
 229  91FD              CheckUp:
 230  91FD FE 0B        	cp		KEY_UP
 231  91FF 20 0D        	jr		nz, CheckRight
 232  9201
 233  9201 3A F6 A7     	ld		a, (SelFile)
 234  9204 B7           	or		a
 235  9205 28 D8        	jr		z, ReadKeyLoop
 236  9207
 237  9207 3D           	dec		a
 238  9208 32 F6 A7     	ld		(SelFile), a
 239  920B C3 DA 94     	jp		MoveIt
 240  920E
 241  920E              CheckRight:
 242  920E FE 09        	cp		KEY_RIGHT
 243  9210 20 12        	jr		nz, CheckLeft
 244  9212
 245  9212 3A F4 A7     	ld		a, (FileCnt)
 246  9215 47           	ld		b, a
 247  9216 3A F6 A7     	ld		a, (SelFile)
 248  9219 C6 17        	add		LST_LINES_CNT
 249  921B B8           	cp		b
 250  921C 30 C1        	jr		nc, ReadKeyLoop
 251  921E
 252  921E 32 F6 A7     	ld		(SelFile), a
 253  9221 C3 DA 94     	jp		MoveIt
 254  9224
 255  9224              CheckLeft:
 256  9224 FE 08        	cp		KEY_LEFT
 257  9226 20 0D        	jr		nz, CheckEnter
 258  9228
 259  9228 3A F6 A7     	ld		a, (SelFile)
 260  922B D6 17        	sub		LST_LINES_CNT
 261  922D 38 B0        	jr		c, ReadKeyLoop
 262  922F
 263  922F 32 F6 A7     	ld		(SelFile), a
 264  9232 C3 DA 94     	jp		MoveIt
 265  9235
 266  9235              CheckEnter:
 267  9235 FE 0D        	cp		KEY_ENTER
 268  9237 C2 40 92     	jp		nz, CheckKeyInfo
 269  923A CD CB 95     	call	HandleFile
 270  923D C3 DB 90     	jp		HCRunMain
 271  9240
 272  9240              CheckKeyInfo:
 273  9240 FE 34        	cp		'4'
 274  9242 20 27        	jr		nz, CheckKeyCopy
 275  9244
 276  9244 3A F4 A7     	ld		a, (FileCnt)
 277  9247 B7           	or		a
 278  9248 CA DF 91     	jp		z, ReadKeyLoop
 279  924B
 280  924B DD 2A FB A7  	ld		ix, (SelFileCache)
 281  924F 21 D2 A6     	ld		hl, MsgReadingExt
 282  9252 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 283  9255 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 284  9257 CD D9 9F     	call	PrintStrClr
 285  925A CD C0 9B     	call	ReadFileHeader
 286  925D 21 E0 A6     	ld		hl, MsgClear
 287  9260 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
 288  9263 3E 0F        	ld		a, SCR_DEF_CLR
 289  9265 CD D9 9F     	call	PrintStrClr
 290  9268 C3 DF 91     	jp		ReadKeyLoop
 291  926B
 292  926B              CheckKeyCopy:
 293  926B FE 35        	cp		'5'
 294  926D C2 BA 92     	jp		nz, CheckKeyFileInfo
 295  9270
 296  9270 3A F4 A7     	ld		a, (FileCnt)
 297  9273 B7           	or		a
 298  9274 CA DF 91     	jp		z, ReadKeyLoop
 299  9277
 300  9277 2A FB A7     	ld		hl, (SelFileCache)
 301  927A CD 85 9D     	call	CopyFile
 302  927D 3A E5 B6     	ld		a, (CopyFileRes)
 303  9280 B7           	or		a
 304  9281 28 17        	jr		z, CopyFileOK
 305  9283
 306  9283 6F           	ld		l, a
 307  9284 26 00        	ld		h, 0
 308  9286 11 1B A6     	ld		de, MsgErrCode
 309  9289 CD 6D 98     	call	Byte2Txt
 310  928C 21 10 A6     	ld		hl, MsgErr
 311  928F 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 312  9292 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 313  9294 CD D9 9F     	call	PrintStrClr
 314  9297 CD 75 9F     	call	ReadChar
 315  929A
 316  929A              CopyFileOK:
 317  929A              CopyFileDontOverwrite:
 318  929A 21 E0 A6     	ld		hl, MsgClear
 319  929D 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
 320  92A0 3E 0F        	ld		a, SCR_DEF_CLR
 321  92A2 CD D9 9F     	call	PrintStrClr
 322  92A5 21 E0 A6     	ld		hl, MsgClear
 323  92A8 11 00 10     	ld		de, LST_LINE_MSG+2 << 8
 324  92AB 3E 0F        	ld		a, SCR_DEF_CLR
 325  92AD CD D9 9F     	call	PrintStrClr
 326  92B0              	;Display destination disk after file copy.
 327  92B0 3A FE B6     	ld		a, (CopyFileDst)
 328  92B3 3D           	dec		a
 329  92B4 32 72 9C     	ld		(RWTSDrive), a
 330  92B7 C3 9A 90     	jp		HCRunInitDisk
 331  92BA
 332  92BA              CheckKeyFileInfo:
 333  92BA FE 20        	cp		' '
 334  92BC 20 0D        	jr		nz, CheckKeyDriveA
 335  92BE
 336  92BE 3A F4 A7     	ld		a, (FileCnt)
 337  92C1 B7           	or		a
 338  92C2 CA DF 91     	jp		z, ReadKeyLoop
 339  92C5
 340  92C5 CD EB 97     	call	ReadAllHeaders
 341  92C8 C3 DF 91     	jp		ReadKeyLoop
 342  92CB
 343  92CB              CheckKeyDriveA:
 344  92CB FE 31        	cp		'1'
 345  92CD 20 05        	jr		nz, CheckKeyDriveB
 346  92CF 3E 00        	ld		a, DRIVE_A_CPM
 347  92D1 C3 E9 93     	jp		SelectDrive
 348  92D4
 349  92D4              CheckKeyDriveB:
 350  92D4 FE 32        	cp		'2'
 351  92D6 20 05        	jr		nz, CheckKeyView
 352  92D8 3E 01        	ld		a, DRIVE_B_CPM
 353  92DA C3 E9 93     	jp		SelectDrive
 354  92DD
 355  92DD              CheckKeyView:
 356  92DD FE 33        	cp		'3'
 357  92DF 20 0D        	jr		nz, CheckKeyRename
 358  92E1
 359  92E1 3A F4 A7     	ld		a, (FileCnt)
 360  92E4 B7           	or		a
 361  92E5 CA DF 91     	jp		z, ReadKeyLoop
 362  92E8
 363  92E8 CD 49 96     	call	ViewFile
 364  92EB C3 DB 90     	jp		HCRunMain
 365  92EE
 366  92EE              CheckKeyRename:
 367  92EE FE 36        	cp		'6'
 368  92F0 20 7D        	jr		nz, CheckKeyDel
 369  92F2
 370  92F2 3A F4 A7     	ld		a, (FileCnt)
 371  92F5 B7           	or		a
 372  92F6 CA DF 91     	jp		z, ReadKeyLoop
 373  92F9
 374  92F9 21 15 A7     	ld		hl, MsgNewFileName
 375  92FC 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 376  92FF 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377  9301 CD D9 9F     	call	PrintStrClr
 378  9304
 379  9304 21 E0 A6     	ld		hl, MsgClear
 380  9307 11 E3 B6     	ld		de, DataBuf
 381  930A 01 0B 00     	ld		bc, NAMELEN
 382  930D ED B0        	ldir
 383  930F 3E A0        	ld		a, $80 | ' '
 384  9311 12           	ld		(de), a
 385  9312 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 386  9315 21 E3 B6     	ld		hl, DataBuf
 387  9318 CD B1 9F     	call	PrintStr
 388  931B
 389  931B 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 390  931E 01 0B 00     	ld		bc, NAMELEN
 391  9321 CD F2 A0     	call	ReadString
 392  9324
 393  9324 11 E3 B6     	ld		de, DataBuf
 394  9327 1A           	ld		a, (de)
 395  9328 FE 20        	cp		' '					;If starting with space, input was canceled.
 396  932A CA 56 93     	jp		z, RenameCanceled
 397  932D
 398  932D              	;Check if new name doesn't exist already. Cancel if so.
 399  932D 21 E3 B6     	ld		hl, DataBuf
 400  9330 3A 72 9C     	ld 		a, (RWTSDrive)
 401  9333 3C           	inc		a
 402  9334 CD 2A 9D     	call	DoesFileExist
 403  9337 3C           	inc		a
 404  9338 28 10        	jr		z, RenameFileNotExist
 405  933A
 406  933A 21 B9 A7     	ld		hl, MsgFileExists
 407  933D 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 408  9340 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 409  9342 CD D9 9F     	call	PrintStrClr
 410  9345 CD 75 9F     	call	ReadChar
 411  9348 18 0C        	jr		RenameCanceled
 412  934A
 413  934A              RenameFileNotExist:
 414  934A 11 E3 B6     	ld		de, DataBuf
 415  934D 2A FB A7     	ld		hl, (SelFileCache)
 416  9350 CD 62 9D     	call	RenameFile
 417  9353 C3 9A 90     	jp		HCRunInitDisk
 418  9356
 419  9356              RenameCanceled:
 420  9356 21 E0 A6     	ld		hl, MsgClear
 421  9359 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 422  935C 3E 0F        	ld		a, SCR_DEF_CLR
 423  935E CD D9 9F     	call	PrintStrClr
 424  9361 21 E0 A6     	ld		hl, MsgClear
 425  9364 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 426  9367 3E 0F        	ld		a, SCR_DEF_CLR
 427  9369 CD D9 9F     	call	PrintStrClr
 428  936C C3 DF 91     	jp		ReadKeyLoop
 429  936F
 430  936F              CheckKeyDel:
 431  936F FE 38        	cp		'8'
 432  9371 20 34        	jr		nz, CheckKeyAttrib
 433  9373
 434  9373 3A F4 A7     	ld		a, (FileCnt)
 435  9376 B7           	or		a
 436  9377 CA DF 91     	jp		z, ReadKeyLoop
 437  937A
 438  937A 21 F0 A6     	ld		hl, MsgDelete
 439  937D 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 440  9380 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441  9382 CD D9 9F     	call	PrintStrClr
 442  9385 CD 75 9F     	call	ReadChar
 443  9388 FE 79        	cp		'y'
 444  938A 28 0E        	jr		z, DoFileDelete
 445  938C 21 E0 A6     	ld		hl, MsgClear
 446  938F 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 447  9392 3E 0F        	ld		a, SCR_DEF_CLR
 448  9394 CD D9 9F     	call	PrintStrClr
 449  9397 C3 DF 91     	jp		ReadKeyLoop
 450  939A              DoFileDelete:
 451  939A 2A FB A7     	ld		hl, (SelFileCache)
 452  939D 3A 72 9C     	ld 		a, (RWTSDrive)
 453  93A0 3C           	inc		a					;Convert to BASIC drive number: 1,2
 454  93A1 CD 1E 9D     	call	DeleteFile
 455  93A4 C3 9A 90     	jp		HCRunInitDisk
 456  93A7
 457  93A7              CheckKeyAttrib:
 458  93A7 FE 37        	cp		'7'
 459  93A9 20 44        	jr		nz, CheckKeyExtra
 460  93AB
 461  93AB 3A F4 A7     	ld		a, (FileCnt)
 462  93AE B7           	or		a
 463  93AF CA DF 91     	jp		z, ReadKeyLoop
 464  93B2
 465  93B2 21 FD A6     	ld		hl, MsgSetRO
 466  93B5 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 467  93B8 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 468  93BA CD D9 9F     	call	PrintStrClr
 469  93BD CD 75 9F     	call	ReadChar
 470  93C0 1E 00        	ld		e, 0
 471  93C2 FE 79        	cp		'y'
 472  93C4 20 02        	jr		nz, CheckSYS
 473  93C6 1E 01        	ld		e, 1
 474  93C8
 475  93C8              CheckSYS:
 476  93C8 D5           	push	de
 477  93C9 21 09 A7     		ld		hl, MsgSetSYS
 478  93CC 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 479  93CF 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 480  93D1 CD D9 9F     		call	PrintStrClr
 481  93D4 CD 75 9F     		call	ReadChar
 482  93D7 FE 79        		cp		'y'
 483  93D9 D1           	pop		de
 484  93DA 20 04        	jr		nz, AttrChange
 485  93DC 3E 02        	ld		a, %10
 486  93DE B3           	or		e
 487  93DF 5F           	ld		e, a
 488  93E0
 489  93E0              AttrChange:
 490  93E0 2A FB A7     	ld		hl, (SelFileCache)
 491  93E3 CD 38 9D     	call	ChangeFileAttrib
 492  93E6 C3 9A 90     	jp		HCRunInitDisk
 493  93E9
 494  93E9              SelectDrive:
 495  93E9 32 72 9C     	ld 		(RWTSDrive), a
 496  93EC C3 9A 90     	jp		HCRunInitDisk
 497  93EF
 498  93EF              CheckKeyExtra:
 499  93EF FE 39        	cp		'9'
 500  93F1 C2 D2 94     	jp		nz, CheckKeyExit
 501  93F4
 502  93F4 21 43 A7     	ld		hl, MsgMenu0
 503  93F7 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 504  93FA 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 505  93FC CD D9 9F     	call	PrintStrClr
 506  93FF 3A 72 9C     	ld		a, (RWTSDrive)
 507  9402 C6 41        	add		'A'
 508  9404 32 61 A7     	ld		(MsgMenu2Drv), a
 509  9407 32 9A A7     	ld		(MsgFormatDrv), a
 510  940A 32 6B A7     	ld		(MsgMenu3Drv1), a
 511  940D 32 79 A7     	ld		(MsgMenu4Drv1), a
 512  9410 32 8D A7     	ld		(MsgMenu5Drv1), a
 513  9413 3A 72 9C     	ld		a, (RWTSDrive)
 514  9416 3C           	inc		a
 515  9417 EE 03        	xor		%11
 516  9419 C6 40        	add		'A'-1
 517  941B 32 6F A7     	ld		(MsgMenu3Drv2), a
 518  941E
 519  941E              CheckKeyDiskMenu:
 520  941E 21 50 A7     	ld		hl, MsgMenu1
 521  9421 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 522  9424 CD B1 9F     	call	PrintStr
 523  9427 21 57 A7     	ld		hl, MsgMenu2
 524  942A 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 525  942D CD B1 9F     	call	PrintStr
 526  9430 21 63 A7     	ld		hl, MsgMenu3
 527  9433 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 528  9436 CD B1 9F     	call	PrintStr
 529  9439 21 71 A7     	ld		hl, MsgMenu4
 530  943C 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 531  943F CD B1 9F     	call	PrintStr
 532  9442 21 80 A7     	ld		hl, MsgMenu5
 533  9445 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 534  9448 CD B1 9F     	call	PrintStr
 535  944B CD 75 9F     	call	ReadChar
 536  944E F5           	push	af
 537  944F
 538  944F 21 E0 A6     		ld		hl, MsgClear
 539  9452 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 540  9455 CD B1 9F     		call	PrintStr
 541  9458 21 E0 A6     		ld		hl, MsgClear
 542  945B 11 00 11     		ld		de, LST_LINE_MSG + 3 << 8
 543  945E CD B1 9F     		call	PrintStr
 544  9461 21 E0 A6     		ld		hl, MsgClear
 545  9464 11 00 12     		ld		de, LST_LINE_MSG + 4 << 8
 546  9467 CD B1 9F     		call	PrintStr
 547  946A 21 E0 A6     		ld		hl, MsgClear
 548  946D 11 00 13     		ld		de, LST_LINE_MSG + 5 << 8
 549  9470 CD B1 9F     		call	PrintStr
 550  9473 21 E0 A6     		ld		hl, MsgClear
 551  9476 11 00 14     		ld		de, LST_LINE_MSG + 6 << 8
 552  9479 CD B1 9F     		call	PrintStr
 553  947C
 554  947C F1           	pop		af
 555  947D
 556  947D              CheckKeyDiskMenuLoop:
 557  947D FE 30        	cp		'0'
 558  947F 28 4E        	jr		z, ExtraMenuExit
 559  9481
 560  9481 FE 31        	cp		'1'
 561  9483 20 2C        	jr		nz, CheckExtra2
 562  9485
 563  9485 21 8F A7     	ld		hl, MsgFormat
 564  9488 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 565  948B 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 566  948D CD D9 9F     	call	PrintStrClr
 567  9490
 568  9490 CD 02 99     	call	FormatDisk
 569  9493 B7           	or		a
 570  9494 CA 9A 90     	jp		z, HCRunInitDisk
 571  9497
 572  9497              	;Display error for format
 573  9497 6F           	ld		l, a
 574  9498 26 00        	ld		h, 0
 575  949A 11 1B A6     	ld		de, MsgErrCode
 576  949D CD 6D 98     	call	Byte2Txt
 577  94A0 21 10 A6     	ld		hl, MsgErr
 578  94A3 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 579  94A6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 580  94A8 CD D9 9F     	call	PrintStrClr
 581  94AB CD 75 9F     	call	ReadChar
 582  94AE C3 9A 90     	jp		HCRunInitDisk
 583  94B1
 584  94B1              CheckExtra2:
 585  94B1 FE 32        	cp		'2'
 586  94B3 20 05        	jr		nz, CheckExtra3
 587  94B5
 588  94B5 CD D2 99     	call	CopyDisk
 589  94B8 18 15        	jr		ExtraMenuExit
 590  94BA
 591  94BA              CheckExtra3:
 592  94BA FE 33        	cp		'3'
 593  94BC C2 C4 94     	jp		nz, CheckExtra4
 594  94BF CD 5B 9A     	call	CopyDiskToCOM
 595  94C2 18 0B        	jr		ExtraMenuExit
 596  94C4
 597  94C4              CheckExtra4:
 598  94C4 FE 34        	cp		'4'
 599  94C6 C2 CF 94     	jp		nz, ExtraMenuExit
 600  94C9 CD B7 9A     	call	CopyDiskFromCOM
 601  94CC C3 9A 90     	jp		HCRunInitDisk
 602  94CF
 603  94CF              ExtraMenuExit:
 604  94CF C3 DB 90     	jp		HCRunMain
 605  94D2
 606  94D2              CheckKeyExit:
 607  94D2 FE 30        	cp		'0'
 608  94D4 C2 DF 91     	jp		nz, ReadKeyLoop
 609  94D7 C3 EA 90     	jp		HCRunEnd
 610  94DA
 611  94DA              MoveIt:
 612  94DA CD 7C A0     	call 	MoveCursor
 613  94DD C3 DF 91     	jp		ReadKeyLoop
 614  94E0
 615  94E0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 616  94E0
 617  94E0
 618  94E0              DisplayFilename:
 619  94E0 06 0B        	LD		B, NAMELEN
 620  94E2              DispLoop:
 621  94E2 1A           	LD		A, (DE)
 622  94E3
 623  94E3              	;clear bit 7
 624  94E3 CB BF        	RES 	7, A
 625  94E5 32 81 5C     	LD		(CODE), A
 626  94E8
 627  94E8 13           	INC		DE
 628  94E9 D5           	PUSH	DE
 629  94EA C5           	PUSH	BC
 630  94EB CD B4 A0     		CALL	PrintChar
 631  94EE C1           	POP		BC
 632  94EF D1           	POP 	DE
 633  94F0
 634  94F0 21 B0 5C     	LD		HL, COL
 635  94F3 34           	INC		(HL)
 636  94F4 10 EC        	DJNZ	DispLoop
 637  94F6              	;now a name is displayed
 638  94F6
 639  94F6              	;check bounds
 640  94F6 3A B1 5C     	LD		A, (LINE)
 641  94F9 3C           	INC		A
 642  94FA FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 643  94FC 38 0A        	JR		C, LineOK
 644  94FE
 645  94FE              	;set names column to the next one
 646  94FE 3A F5 A7     	LD		A, (NameCol)
 647  9501 C6 0C        	ADD		NAMELEN + 1
 648  9503 32 F5 A7     	LD		(NameCol), A
 649  9506
 650  9506 3E 00        	LD		A, LST_FIRST_LINE
 651  9508              LineOK:
 652  9508 32 B1 5C     	LD		(LINE), A
 653  950B
 654  950B 3A F5 A7     	LD		A, (NameCol)
 655  950E 32 B0 5C     	LD		(COL), A
 656  9511
 657  9511 C9           	RET
 658  9512
 659  9512
 660  9512              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 661  9512
 662  9512              DisplayFilenames:
 663  9512 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 664  9515 ED 53 B0 5C  	ld		(LineCol), de
 665  9519
 666  9519 11 FD A7     	ld		de, FileCache
 667  951C 3A F4 A7     	ld		a, (FileCnt)
 668  951F B7           	or		a
 669  9520 C8           	ret		z
 670  9521
 671  9521 47           	ld		b,	a
 672  9522
 673  9522              DisplayFilenamesLoop:
 674  9522 C5           	push	bc
 675  9523 D5           		push	de
 676  9524 CD E0 94     			call	DisplayFilename
 677  9527 D1           		pop		de
 678  9528 EB           		ex		de, hl
 679  9529 01 19 00     		ld		bc, CACHE_SZ
 680  952C 09           		add		hl, bc
 681  952D EB           		ex		de, hl
 682  952E C1           	pop		bc
 683  952F 10 F1        	djnz	DisplayFilenamesLoop
 684  9531
 685  9531 C9           	ret
 686  9532
 687  9532
 688  9532              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 689  9532              ;Selects only valid filenames (not deleted and only from first extension)
 690  9532              GetFileNames:
 691  9532 DD 21 E3 B6  	ld		ix, TrackBuf
 692  9536 11 FD A7     	ld		de, FileCache
 693  9539 06 80        	ld		b, MAX_EXT_CNT
 694  953B AF           	xor		a
 695  953C 32 F4 A7     	ld		(FileCnt), a
 696  953F 21 F9 A7     	ld		hl, AUCnt
 697  9542 77           	ld		(hl), a
 698  9543 23           	inc		hl
 699  9544 77           	ld		(hl), a
 700  9545
 701  9545              StoreFilenamesLoop:
 702  9545 AF           	xor a
 703  9546 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 704  9549 C2 BD 95     	jp nz, NextExt
 705  954C
 706  954C              	;count AU
 707  954C D9           	exx
 708  954D E5           	push hl
 709  954E CD 31 99     		call CheckExtAlloc
 710  9551 EB           		ex de, hl			;save first AU no.
 711  9552
 712  9552              		;store disk alocated AU count
 713  9552 2A F9 A7     		ld hl, (AUCnt)
 714  9555 48           		ld c, b
 715  9556 06 00        		ld b, 0
 716  9558 09           		add hl, bc
 717  9559 22 F9 A7     		ld (AUCnt), hl
 718  955C E1           	pop hl
 719  955D D9           	exx
 720  955E
 721  955E AF           	xor	a
 722  955F DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 723  9562 20 32        	jr nz, FindExt
 724  9564
 725  9564 DD E5        	push ix
 726  9566 E1           	pop hl
 727  9567 23           	inc hl					;skip del flag
 728  9568
 729  9568 C5           	push bc
 730  9569 ~            		/*
 731  9569 ~            		push de
 732  9569 ~            			push hl
 733  9569 ~            				ex de, hl
 734  9569 ~            				call DisplayFilename
 735  9569 ~            			pop hl
 736  9569 ~            		pop de
 737  9569 ~            		*/
 738  9569 01 0B 00     		ld bc, NAMELEN
 739  956C ED B0        		ldir				;save file name
 740  956E
 741  956E D9           		exx
 742  956F D5           		push 	de			;de = first AU
 743  9570 D9           		exx
 744  9571 E1           		pop		hl
 745  9572 EB           		ex		de, hl
 746  9573 73 23 72 2B  		ld		(hl), de	;save first AU
 747  9577
 748  9577 23           		inc		hl
 749  9578 23           		inc		hl
 750  9579
 751  9579 D9           		exx					;save AU cnt for file
 752  957A C5           		push	bc
 753  957B D9           		exx
 754  957C C1           		pop		bc
 755  957D 71 23 70 2B  		ld		(hl), bc
 756  9581
 757  9581 23           		inc		hl
 758  9582 23           		inc		hl
 759  9583
 760  9583              		;xor		a			;make flag 0 to signal that header is not read yet
 761  9583              		;ld		(hl), a
 762  9583
 763  9583 01 0A 00     		ld		bc, HDR_SZ + 1
 764  9586 09           		add		hl, bc
 765  9587
 766  9587 EB           		ex		de, hl
 767  9588 C1           	pop bc
 768  9589
 769  9589
 770  9589 3A F4 A7     	ld 		a, (FileCnt)			;inc file counter
 771  958C 3C           	inc		a
 772  958D 32 F4 A7     	ld 		(FileCnt), a
 773  9590 FE 5C        	cp		LST_MAX_FILES
 774  9592 38 29        	jr		c, NextExt
 775  9594 18 34        	jr		GetFileNamesEnd
 776  9596
 777  9596
 778  9596              FindExt:					;BC' = AU cnt for this ext
 779  9596 C5           	push	bc
 780  9597 D5           		push 	de
 781  9598 DD E5        			push	ix
 782  959A D1           			pop		de
 783  959B 13           			inc		de				;DE = name to find
 784  959C
 785  959C 21 FD A7     			ld		hl, FileCache
 786  959F 3A F4 A7     			ld		a, (FileCnt)
 787  95A2 4F           			ld		c, a
 788  95A3 CD AF 9B     			call	FindCache
 789  95A6 20 13        			jr		nz, FindExtEnd
 790  95A8
 791  95A8 01 0D 00     			ld		bc, CACHE_AU_CNT
 792  95AB 09           			add		hl, bc
 793  95AC D9           			exx
 794  95AD C5           			push	bc
 795  95AE D9           			exx
 796  95AF C1           			pop		bc
 797  95B0
 798  95B0 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 799  95B4 EB           			ex		de, hl
 800  95B5 09           			add		hl, bc
 801  95B6 EB           			ex		de, hl
 802  95B7 73 23 72 2B  			ld		(hl), de
 803  95BB              FindExtEnd:
 804  95BB D1           		pop		de
 805  95BC C1           	pop		bc
 806  95BD
 807  95BD              NextExt:
 808  95BD C5           	push bc
 809  95BE 01 20 00     		ld bc, EXT_SZ
 810  95C1 DD 09        		add ix, bc
 811  95C3 C1           	pop	bc
 812  95C4
 813  95C4 05           	dec	b
 814  95C5 78           	ld	a, b
 815  95C6 B7           	or	a
 816  95C7 C2 45 95     	jp	nz, StoreFilenamesLoop
 817  95CA              GetFileNamesEnd:
 818  95CA C9           	ret
 819  95CB
 820  95CB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 821  95CB
 822  95CB              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 823  95CB              ;IN: HL = file name
 824  95CB              HandleFile:
 825  95CB              	;Make HL point to the selected file
 826  95CB DD 2A FB A7  	ld		ix, (SelFileCache)
 827  95CF DD E5        	push	ix
 828  95D1 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 829  95D4 B7           		or		a
 830  95D5 CC C0 9B     		call	z, ReadFileHeader
 831  95D8
 832  95D8 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 833  95DB FE 00        		cp		PROG_TYPE
 834  95DD 28 59        		jr		z, HandleFileProg
 835  95DF
 836  95DF FE 03        		cp		BYTE_TYPE
 837  95E1 20 65        		jr		nz, HandleFileText
 838  95E3
 839  95E3 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 839  95E7 66 12
 840  95E9 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 841  95EC 19           		add		hl, de
 842  95ED 7C           		ld		a, h
 843  95EE B5           		or		l
 844  95EF 28 29        		jr		z, HandleFileSCR
 845  95F1
 846  95F1
 847  95F1              HandleFileCODE:
 848  95F1 21 3E A6     		ld		hl, MsgLoadingCODE
 849  95F4 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 850  95F7 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 851  95F9 CD D9 9F     		call	PrintStrClr
 852  95FC
 853  95FC              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 854  95FC 21 2A 9B     		ld		hl, IF1FileLoad
 855  95FF 11 00 5B     		ld		de, PRN_BUF
 856  9602 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 857  9605 ED B0        		ldir
 858  9607 3E C9        		ld		a, $C9
 859  9609 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 860  960A
 861  960A E1           	pop		hl
 862  960B ED 5B E6 B6  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 863  960F C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 864  9610 C1           	pop		bc						;2nd, 3rd call for error handler
 865  9611 C1           	pop		bc
 866  9612 ED 43 3D 5C  	ld		(ERRSP), bc
 867  9616 D5           	push	de						;push CODE address to return to = start of CODE block
 868  9617 C3 00 5B     	jp		PRN_BUF
 869  961A
 870  961A
 871  961A
 872  961A
 873  961A              HandleFileSCR:
 874  961A 21 2F A6     		ld		hl, MsgLoadingSCR
 875  961D 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 876  9620 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 877  9622 CD D9 9F     		call	PrintStrClr
 878  9625
 879  9625 E1           	pop		hl
 880  9626
 881  9626              	IFDEF _REAL_HW_
 882  9626              		;Load to alternate SCREEN$ memory
 883  9626 11 00 C0     		ld		de, HC_VID_BANK1
 884  9629 CD 2A 9B     		call	IF1FileLoad
 885  962C
 886  962C              		;Set display to alternate SCREEN$ memory
 887  962C 3E 08        		ld		a, HC_CFG_VID_C000
 888  962E D3 7E        		out 	(HC_CFG_PORT), a
 889  9630 CD 75 9F     		call	ReadChar
 890  9633
 891  9633              		;Set back to regular SCREEN$ memory
 892  9633 3E 00        		ld		a, HC_CFG_VID_4000
 893  9635 D3 7E        		out 	(HC_CFG_PORT), a
 894  9637              	ELSE
 895  9637 ~            		ld		de, HC_VID_BANK0
 896  9637 ~            		call	IF1FileLoad
 897  9637 ~            		call	ReadChar
 898  9637              	ENDIF
 899  9637
 900  9637 C9           	ret
 901  9638
 902  9638              HandleFileProg:
 903  9638 21 20 A6     		ld		hl, MsgLoadingPrg
 904  963B 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 905  963E 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 906  9640 CD D9 9F     		call	PrintStrClr
 907  9643 E1           	pop		hl
 908  9644 CD 27 9C     	call	LoadProgram
 909  9647 C9           	ret
 910  9648
 911  9648
 912  9648              HandleFileText:
 913  9648 E1           	pop		hl
 914  9649
 915  9649
 916  9649              ViewFile:
 917  9649 CD 91 9F     	call	ClrScr
 918  964C 21 00 00     	ld		hl, 0
 919  964F 22 EC B6     	ld		(FilePosRead), hl
 920  9652              ViewFileLoop:
 921  9652 2A FB A7     	ld		hl, (SelFileCache)
 922  9655 3A 72 9C     	ld 		a, (RWTSDrive)
 923  9658 3C           	inc		a
 924  9659 CD BC 9E     	call	ReadFileSection					;DE = last address read
 925  965C 21 E3 B7     	ld		hl, FileData
 926  965F              	;Calculate size of read buffer
 927  965F E5           	push	hl
 928  9660 EB           		ex	de, hl
 929  9661 B7           		or	a
 930  9662 ED 52        		sbc	hl, de
 931  9664 44           		ld	b, h
 932  9665 4B           		ld	c, e
 933  9666 E1           	pop		hl
 934  9667 CD 38 A1     	call	InitViewer
 935  966A CD 96 A1     	call	PrintLoop
 936  966D              	;Check if exited viewer because user wanted to.
 937  966D 28 09        	jr		z, ViewFileEnd
 938  966F              	;Check if file ended -> we need to load the next file segment.
 939  966F 3A E5 B6     	ld		a, (CopyFileRes)
 940  9672 B7           	or		a
 941  9673 28 DD        	jr		z, ViewFileLoop
 942  9675 C3 D1 A1     	jp		PrintLoop2
 943  9678              ViewFileEnd:
 944  9678 C9           	ret
 945  9679
 946  9679              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 947  9679
 948  9679
 949  9679              DisplayFileInfo:
 950  9679 2A FB A7     	ld		hl, (SelFileCache)
 951  967C E5           	push	hl
 952  967D              		;disk size - at least 2KB ==1  AU
 953  967D 01 0D 00     		ld		bc, CACHE_AU_CNT
 954  9680 09           		add		hl, bc
 955  9681 5E 23 56 2B  		ld		de, (hl)
 956  9685 EB           		ex		de, hl
 957  9686              		;*2, since one block (AU) is 2KB.
 958  9686 CB 15        		rl	l
 959  9688 CB 14        		rl	h
 960  968A
 961  968A 11 57 A6     		ld		de, MsgFileSzDskN
 962  968D CD 62 98     		call	Word2Txt
 963  9690 21 4E A6     		ld		hl, MsgFileSzDsk
 964  9693 11 00 09     		ld		de, LST_FILE_INFO + 1 << 8
 965  9696 CD B1 9F     		call	PrintStr
 966  9699 E1           	pop		hl
 967  969A E5           	push	hl
 968  969B              		;attributes
 969  969B 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 970  969E 09           		add		hl, bc
 971  969F EB           		ex		de, hl
 972  96A0 21 67 A6     		ld		hl, MsgFileAttrN
 973  96A3 1A           		ld		a, (de)
 974  96A4 E6 80        		and		%10000000
 975  96A6 28 14        		jr		z, NotRO
 976  96A8
 977  96A8 01 52 2F     		ld		bc, '/R'
 978  96AB 71 23 70 2B  		ld		(hl), bc
 979  96AF 23           		inc		hl
 980  96B0 23           		inc		hl
 981  96B1 01 4F 2C     		ld		bc, ',O'
 982  96B4 71 23 70 2B  		ld		(hl), bc
 983  96B8 23           		inc		hl
 984  96B9 23           		inc		hl
 985  96BA 18 12        		jr		CheckSys
 986  96BC              NotRO:
 987  96BC 01 2D 2D     		ld		bc, '--'
 988  96BF 71 23 70 2B  		ld		(hl), bc
 989  96C3 23           		inc		hl
 990  96C4 23           		inc		hl
 991  96C5 01 2D 2C     		ld		bc, ',-'
 992  96C8 71 23 70 2B  		ld		(hl), bc
 993  96CC 23           		inc		hl
 994  96CD 23           		inc		hl
 995  96CE
 996  96CE              CheckSys:
 997  96CE 13           		inc		de
 998  96CF 1A           		ld		a, (de)
 999  96D0 E6 80        		and		%10000000
1000  96D2 28 0E        		jr		z, NotSYS
1001  96D4
1002  96D4 01 48 49     		ld		bc, 'IH'
1003  96D7 71 23 70 2B  		ld		(hl), bc
1004  96DB 23           		inc		hl
1005  96DC 23           		inc		hl
1006  96DD 3E C4        		ld		a, 'D' + $80
1007  96DF 77           		ld		(hl), a
1008  96E0 18 0C        		jr		AttrEnd
1009  96E2              NotSYS:
1010  96E2 01 2D 2D     		ld		bc, '--'
1011  96E5 71 23 70 2B  		ld		(hl), bc
1012  96E9 23           		inc		hl
1013  96EA 23           		inc		hl
1014  96EB 3E AD        		ld		a, '-' + $80
1015  96ED 77           		ld		(hl), a
1016  96EE              AttrEnd:
1017  96EE 11 00 0A     		ld		de, LST_FILE_INFO + 2 << 8
1018  96F1 21 5E A6     		ld		hl, MsgFileAttr
1019  96F4 CD B1 9F     		call	PrintStr
1020  96F7 DD E1        	pop		ix
1021  96F9 DD E5        	push	ix
1022  96FB DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1023  96FE B7           		or		a
1024  96FF CA 9C 97             jp		z, HeadNotRead
1025  9702
1026  9702 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1027  9705 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1028  9708 CA 9C 97             jp		z, HeadNotRead
1029  970B
1030  970B DD 7E 10     		ld		a, (ix + CACHE_HDR)
1031  970E FE 00        		cp		PROG_TYPE
1032  9710 20 0B        		jr		nz, CheckNoArr
1033  9712
1034  9712 21 81 A6     		ld		hl, MsgFileTypePrg
1035  9715 11 77 A6     		ld		de, MsgFileTypeN
1036  9718 CD E5 97     		call	MoveMsg
1037  971B 18 4F        		jr		PrepFileLen
1038  971D
1039  971D              CheckNoArr:
1040  971D FE 01        		cp		NUMB_TYPE
1041  971F 20 0B        		jr		nz, CheckChrArr
1042  9721
1043  9721 21 9D A6     		ld		hl, MsgFileTypeNoA
1044  9724 11 77 A6     		ld		de, MsgFileTypeN
1045  9727 CD E5 97     		call	MoveMsg
1046  972A 18 40        		jr		PrepFileLen
1047  972C
1048  972C              CheckChrArr:
1049  972C FE 02        		cp		CHAR_TYPE
1050  972E 20 0B        		jr		nz, CheckByte
1051  9730
1052  9730 21 96 A6     		ld		hl, MsgFileTypeChrA
1053  9733 11 77 A6     		ld		de, MsgFileTypeN
1054  9736 CD E5 97     		call	MoveMsg
1055  9739 18 31        		jr		PrepFileLen
1056  973B
1057  973B              CheckByte:
1058  973B FE 03        		cp		BYTE_TYPE
1059  973D 20 24        		jr		nz, CheckText
1060  973F
1061  973F DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1061  9743 66 12
1062  9745 01 00 E5     		ld		bc, -SCR_LEN
1063  9748 09           		add		hl, bc
1064  9749 7C           		ld		a, h
1065  974A B5           		or		l
1066  974B 20 0B        		jr		nz, NotScr
1067  974D
1068  974D 21 8F A6     		ld		hl, MsgFileTypeSCR
1069  9750 11 77 A6     		ld		de, MsgFileTypeN
1070  9753 CD E5 97     		call	MoveMsg
1071  9756 18 14        		jr		PrepFileLen
1072  9758              NotScr:
1073  9758 21 88 A6     		ld		hl, MsgFileTypeByte
1074  975B 11 77 A6     		ld		de, MsgFileTypeN
1075  975E CD E5 97     		call	MoveMsg
1076  9761 18 09        		jr		PrepFileLen
1077  9763
1078  9763              CheckText:
1079  9763 21 A4 A6     		ld		hl, MsgFileTypeText
1080  9766 11 77 A6     		ld		de, MsgFileTypeN
1081  9769 CD E5 97     		call	MoveMsg
1082  976C
1083  976C              PrepFileLen:
1084  976C              		;File len
1085  976C DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1086  976F DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1087  9772              PrepFileLenText:
1088  9772 11 BB A6     		ld		de, MsgFileLenN
1089  9775 CD 62 98     		call	Word2Txt
1090  9778 26 C2        		ld		h, 'B' | $80
1091  977A 2E 20        		ld		l, ' '
1092  977C 22 C0 A6     		ld		(MsgFileLenN + 5), hl
1093  977F
1094  977F DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1095  9782 FE 00        		cp		PROG_TYPE
1096  9784 28 06        		jr		z, PrintProgStart
1097  9786
1098  9786 FE 03        		cp		BYTE_TYPE
1099  9788 28 0A        		jr		z, PrintByteStart
1100  978A
1101  978A 18 22        		jr		PrintStartNotRead
1102  978C
1103  978C              PrintProgStart:
1104  978C DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1105  978F DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1106  9792 18 25        		jr		PrintStart
1107  9794
1108  9794              PrintByteStart:
1109  9794 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1110  9797 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1111  979A 18 1D        		jr		PrintStart
1112  979C
1113  979C              HeadNotRead:
1114  979C 21 AB A6             ld        hl, MsgNA
1115  979F 11 77 A6             ld        de, MsgFileTypeN
1116  97A2 CD E5 97             call    MoveMsg
1117  97A5
1118  97A5 21 AB A6     		ld		hl, MsgNA
1119  97A8 11 BB A6     		ld		de, MsgFileLenN
1120  97AB CD E5 97     		call	MoveMsg
1121  97AE
1122  97AE              PrintStartNotRead:
1123  97AE 21 AB A6     		ld		hl, MsgNA
1124  97B1 11 CB A6     		ld		de, MsgFileStartN
1125  97B4 CD E5 97     		call	MoveMsg
1126  97B7 18 0E        		jr		PrintStartStr
1127  97B9
1128  97B9              PrintStart:
1129  97B9 1E 20        	ld		e, ' '
1130  97BB 16 A0        	ld		d, ' ' | $80
1131  97BD ED 53 D0 A6  	ld		(MsgFileStartN + 5), de
1132  97C1 11 CB A6     	ld		de, MsgFileStartN
1133  97C4 CD 62 98     	call	Word2Txt
1134  97C7              PrintStartStr:
1135  97C7 11 00 0C     	ld		de, LST_FILE_INFO + 4 << 8
1136  97CA 21 C2 A6     	ld		hl, MsgFileStart
1137  97CD CD B1 9F     	call	PrintStr
1138  97D0
1139  97D0 DD E1        	pop		ix
1140  97D2 11 00 0B     	ld		de, LST_FILE_INFO + 3 << 8
1141  97D5 21 6E A6     	ld		hl, MsgFileType
1142  97D8 CD B1 9F     	call	PrintStr
1143  97DB
1144  97DB 11 00 0D     	ld		de, LST_FILE_INFO + 5 << 8
1145  97DE 21 B2 A6     	ld		hl, MsgFileLen
1146  97E1 CD B1 9F     	call	PrintStr
1147  97E4
1148  97E4 C9           	ret
1149  97E5
1150  97E5              MoveMsg:
1151  97E5 01 07 00     	ld		bc, 7
1152  97E8 ED B0        	ldir
1153  97EA C9           	ret
1154  97EB
1155  97EB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1156  97EB
1157  97EB              ReadAllHeaders:
1158  97EB 21 D2 A6     	ld		hl, MsgReadingExt
1159  97EE 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1160  97F1 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1161  97F3 CD D9 9F     	call	PrintStrClr
1162  97F6
1163  97F6 CD CE 91     	call	CalcFileCache
1164  97F9
1165  97F9 3A F6 A7     	ld		a, (SelFile)
1166  97FC 47           	ld		b, a
1167  97FD 3A F4 A7     	ld		a, (FileCnt)
1168  9800 90           	sub		b
1169  9801 B7           	or		a
1170  9802 C8           	ret		z
1171  9803
1172  9803 47           	ld		b, a
1173  9804
1174  9804 DD 2A FB A7  	ld		ix, (SelFileCache)
1175  9808              NextFile:
1176  9808 C5           	push	bc
1177  9809 CD C0 9B     		call	ReadFileHeader
1178  980C 01 19 00     		ld		bc, CACHE_SZ
1179  980F DD 09        		add		ix, bc
1180  9811 DD E5        		push	ix
1181  9813 CD CE 91     			call	CalcFileCache
1182  9816 CD 79 96     			call	DisplayFileInfo
1183  9819 DD E1        		pop		ix
1184  981B
1185  981B CD 78 9F     		call	KbdHit
1186  981E 38 03        		jr		c, AKey
1187  9820 C1           	pop		bc
1188  9821 18 15        	jr		ReadAllHeadersEnd
1189  9823
1190  9823              AKey:
1191  9823 3A F6 A7     		ld		a, (SelFile)
1192  9826 3C           		inc		a
1193  9827 47           		ld		b, a
1194  9828 3A F4 A7     		ld		a, (FileCnt)
1195  982B B8           		cp		b
1196  982C 28 16        		jr		z, DontInc
1197  982E 78           		ld		a, b
1198  982F 32 F6 A7     		ld		(SelFile), a
1199  9832 CD 7C A0     		call	MoveCursor
1200  9835 C1           	pop		bc
1201  9836 10 D0        	djnz	NextFile
1202  9838
1203  9838              ReadAllHeadersEnd:
1204  9838 21 E0 A6     	ld		hl, MsgClear
1205  983B 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1206  983E 3E 0F        	ld		a, SCR_DEF_CLR
1207  9840 CD D9 9F     	call	PrintStrClr
1208  9843 C9           	ret
1209  9844
1210  9844              DontInc:
1211  9844 C1           	pop		bc
1212  9845 18 F1        	jr		ReadAllHeadersEnd
1213  9847
1214  9847              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1215  9847              ;Will report HC version based on copyright string. For HC2000 will report v1/v2. For IF1 will report v1/v2.
1216  9847              ;Versions:
1217  9847              ;"HC - 85", 6, 32, 32, 32, 32, "I.C.E FELIX"
1218  9847              ;"HC - 90", 6, 32, 32, 32, 32, "I.C.E FELIX"
1219  9847              ;"HC - 91", 6, 32, 32, 32, 32, "I.C.E FELIX"
1220  9847              ;"HC2000 ICE FELIX COMPUTER SA" - v1
1221  9847              ;"HC2000", 6, 32, 32, 32, 32, "I.C.E FELIX" - v2
1222  9847              PrintIntro:
1223  9847 21 31 A5     	ld		hl, VerMsg1
1224  984A 11 00 01     	ld		de, LST_PROG_INFO + 1 << 8
1225  984D CD B1 9F     	call	PrintStr
1226  9850 21 41 A5     	ld		hl, VerMsg2
1227  9853 11 00 02     	ld		de, LST_PROG_INFO + 2 << 8
1228  9856 CD B1 9F     	call	PrintStr
1229  9859 21 51 A5     	ld		hl, VerMsg3
1230  985C 11 00 03     	ld		de, LST_PROG_INFO + 3 << 8
1231  985F CD B1 9F     	call	PrintStr
1232  9862
1233  9862 ~            	/*
1234  9862 ~            	ld		hl, STR_MSG_BASIC
1235  9862 ~            	ld		de, MsgCompModelName
1236  9862 ~            	ld		b, 7
1237  9862 ~            PrintComputerInfoLoop:
1238  9862 ~            	ld		a, (hl)
1239  9862 ~            	cp		' '
1240  9862 ~            	jr		z, PrintComputerInfoSkip
1241  9862 ~            	ld		(de), a
1242  9862 ~            	inc		de
1243  9862 ~            PrintComputerInfoSkip:
1244  9862 ~            	inc		hl
1245  9862 ~            	djnz	PrintComputerInfoLoop
1246  9862 ~
1247  9862 ~            	ld		a, (STR_MSG_BASIC + 2)
1248  9862 ~            	cp		'2'
1249  9862 ~            	jr		nz, PrintComputerInfoIF1
1250  9862 ~
1251  9862 ~            	;HC2000
1252  9862 ~            	ld		a, ' '
1253  9862 ~            	ld		(de), a
1254  9862 ~            	inc		de
1255  9862 ~            	ld		a, 'v'
1256  9862 ~            	ld		(de), a
1257  9862 ~            	inc		de
1258  9862 ~
1259  9862 ~            	ld		a, (hl)
1260  9862 ~            	cp		'I'
1261  9862 ~            	jr		z, HC2000v1
1262  9862 ~            	ld		a, '2' | $80
1263  9862 ~            	jr		HC2000Store
1264  9862 ~            HC2000v1:
1265  9862 ~            	ld		a, '1' | $80
1266  9862 ~            HC2000Store:
1267  9862 ~            	ld		(de), a
1268  9862 ~            	inc		de
1269  9862 ~            	;Patch code to look for HC2000 IF1 string at a different address.
1270  9862 ~            	ld		hl, GetIF1String+1
1271  9862 ~            	ld		de, STR_MSG_IF1_2000
1272  9862 ~            	ld		(hl), e
1273  9862 ~            	inc		hl
1274  9862 ~            	ld		(hl), d
1275  9862 ~
1276  9862 ~            PrintComputerInfoIF1:
1277  9862 ~            	ld		hl, GetIF1String
1278  9862 ~            	ld		de, PrintCompInfo
1279  9862 ~            	push	de
1280  9862 ~            	jp		IF1Call
1281  9862 ~
1282  9862 ~            GetIF1String:
1283  9862 ~            	ld		hl, STR_MSG_IF1_91
1284  9862 ~            	ld		de, MsgIF1Date
1285  9862 ~            	ld		a, '.'
1286  9862 ~            GetIF1StringLoop:
1287  9862 ~            	ldi
1288  9862 ~            	ldi
1289  9862 ~            	ld		(de), a
1290  9862 ~            	inc		de
1291  9862 ~            	ldi
1292  9862 ~            	ldi
1293  9862 ~            	ld		(de), a
1294  9862 ~            	inc		de
1295  9862 ~            	ldi
1296  9862 ~            	ld		a, (hl)
1297  9862 ~            	or		$80
1298  9862 ~            	ld		(de), a
1299  9862 ~            	ret
1300  9862 ~
1301  9862 ~            PrintCompInfo:
1302  9862 ~            	ld		hl, MsgCompModel
1303  9862 ~            	ld		de, LST_PROG_INFO + 4 << 8
1304  9862 ~            	call	PrintStr
1305  9862 ~
1306  9862 ~            	ld		hl, MsgIF1Version
1307  9862 ~            	ld		de, LST_PROG_INFO + 5 << 8
1308  9862 ~            	call	PrintStr
1309  9862 ~
1310  9862 ~            	ret
1311  9862 ~            	*/
1312  9862              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1313  9862
1314  9862              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 9862              	ifndef	_HCCFG_
   2+ 9862              	define	_HCCFG_
   3+ 9862
   4+ 9862              ;HC specific code, for configuration
   5+ 9862
   6+ 9862              HC_CFG_PORT			EQU	$7E
   7+ 9862
   8+ 9862              ;BASIC/CPM ROM selection
   9+ 9862              HC_CFG_ROM_BAS		EQU	%0
  10+ 9862              HC_CFG_ROM_CPM		EQU	%1
  11+ 9862
  12+ 9862              ;Address for ROM paging: 0 or $E000
  13+ 9862              HC_CFG_ROM_0000		EQU %00
  14+ 9862              HC_CFG_ROM_E000		EQU %10
  15+ 9862
  16+ 9862              ;Cfg. port Enable/Disable
  17+ 9862              HC_CFG_PORT_DIS		EQU %000
  18+ 9862              HC_CFG_PORT_EN		EQU	%100
  19+ 9862
  20+ 9862              ;Video memory bank: $4000 or $C000
  21+ 9862              HC_CFG_VID_4000		EQU	%0000
  22+ 9862              HC_CFG_VID_C000		EQU	%1000
  23+ 9862
  24+ 9862
  25+ 9862              ;Standar BASIC config
  26+ 9862              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 9862              ;Standar CP/M config
  28+ 9862              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 9862
  30+ 9862
  31+ 9862              HC_VID_BANK0		EQU	$4000
  32+ 9862              HC_VID_BANK1		EQU	$C000
  33+ 9862
  34+ 9862              	endif
# file closed: hccfg.asm
1315  9862              	include "if1.asm"
# file opened: if1.asm
   1+ 9862              ;HC IF1 routines and constants
   2+ 9862
   3+ 9862              ;IF1 routines error codes, also returned by BASIC commands
   4+ 9862              ;12 = Writing to a 'read' file
   5+ 9862              ;13 = Reading a 'write' file
   6+ 9862              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 9862              ;15 = Disk full (disk or catalog full)
   8+ 9862              ;16 = Disk error (hardware error)
   9+ 9862              ;17 = File not found
  10+ 9862              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 9862              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 9862
  13+ 9862              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 9862              ;00h = OK
  15+ 9862              ;08h = cannot format disk
  16+ 9862              ;10h = disk protected (read-only?)
  17+ 9862              ;20h = volume error
  18+ 9862              ;40h = drive error
  19+ 9862              ;80h = reading error
  20+ 9862              ;Codes I encountered:
  21+ 9862              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 9862
  23+ 9862
  24+ 9862              	ifndef	_DISK_
  25+ 9862              	define	_DISK_
  26+ 9862
  27+ 9862              	include	"math.asm"
# file opened: math.asm
   1++9862              	ifndef	_MATH_
   2++9862              	define	_MATH_
   3++9862
   4++9862              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++9862              ;http://map.tni.nl/sources/external/z80bits.html
   6++9862
   7++9862
   8++9862              Word2Txt:
   9++9862              	IFUSED
  10++9862 D5           	push	de
  11++9863 CD 83 98     		call	Word2Txt_
  12++9866 D1           	pop		de
  13++9867
  14++9867 06 04        	ld		b, 4
  15++9869 CD 78 98     	call	StrippLeading0
  16++986C C9           	ret
  17++986D
  18++986D              Byte2Txt:
  19++986D D5           	push	de
  20++986E CD 8F 98     		call	Byte2Txt_
  21++9871 D1           	pop		de
  22++9872
  23++9872 06 02        	ld		b, 2
  24++9874 CD 78 98     	call	StrippLeading0
  25++9877 C9           	ret
  26++9878              	ENDIF
  27++9878
  28++9878
  29++9878              StrippLeading0:
  30++9878 1A           	ld		a, (de)
  31++9879 FE 31        	cp		'1'
  32++987B D0           	ret		nc
  33++987C
  34++987C 3E 20        	ld		a, ' '
  35++987E 12           	ld		(de), a
  36++987F 13           	inc		de
  37++9880 10 F6        	djnz	StrippLeading0
  38++9882 C9           	ret
  39++9883
  40++9883
  41++9883              ;Converts the number in HL to ASCII in decimal string at DE
  42++9883              Word2Txt_:
  43++9883 01 F0 D8     	ld bc, -10000
  44++9886 CD 9E 98     	call DigitLoop
  45++9889 01 18 FC     	ld bc, -1000
  46++988C CD 9E 98     	call DigitLoop
  47++988F              Byte2Txt_:
  48++988F 01 9C FF     	ld bc, -100
  49++9892 CD 9E 98     	call DigitLoop
  50++9895 01 F6 FF     	ld bc, -10
  51++9898 CD 9E 98     	call DigitLoop
  52++989B 01 FF FF     	ld bc, -1
  53++989E
  54++989E              DigitLoop:
  55++989E 3E 2F        	ld	a, '0' - 1
  56++98A0              DivNrLoop:
  57++98A0 3C           	inc	a			;increase reminder
  58++98A1 09           	add	hl, bc		;substract divizor
  59++98A2 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++98A4 ED 42        	sbc	hl, bc		;nope, restore
  61++98A6
  62++98A6 12           	ld (de), a
  63++98A7 13           	inc de
  64++98A8 C9           	ret
  65++98A9
  66++98A9
  67++98A9              ;Input: HL = Dividend, C = Divisor
  68++98A9              ;Output: HL = Quotient, A = Remainder
  69++98A9              ;Warning: doesn't work with divisor >= $80
  70++98A9              Div:
  71++98A9              	IFUSED
  72++98A9 AF           	xor a
  73++98AA 06 10        	ld b, 16
  74++98AC
  75++98AC              DivLoop:
  76++98AC 29           	add	hl,hl
  77++98AD 17           	rla
  78++98AE B9           	cp	c
  79++98AF 38 02        	jr	c, NoSub
  80++98B1 91           	sub	c
  81++98B2 2C           	inc	l
  82++98B3              NoSub:
  83++98B3 10 F7        	djnz DivLoop
  84++98B5
  85++98B5 C9           	ret
  86++98B6              	ENDIF
  87++98B6
  88++98B6              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++98B6              ;Output: A:C = Quotient, HL = Remainder
  90++98B6              Div2:
  91++98B6 21 00 00     	ld hl, 0
  92++98B9 06 10        	ld b, 16
  93++98BB              Div2Loop:
  94++98BB CB 31        	sll c		; unroll 16 times
  95++98BD 17           	rla			; ...
  96++98BE ED 6A        	adc	hl,hl		; ...
  97++98C0 ED 52        	sbc	hl,de		; ...
  98++98C2 30 02        	jr	nc,$+4		; ...
  99++98C4 19           	add	hl,de		; ...
 100++98C5 0D           	dec	c		; ...
 101++98C6 10 F3        	djnz Div2Loop
 102++98C8 C9           	ret
 103++98C9
 104++98C9
 105++98C9              ;Input: A = Multiplier, DE = Multiplicand
 106++98C9              ;Output: A:HL = Product
 107++98C9              Mul:
 108++98C9              	IFUSED
 109++98C9 21 00 00     	ld hl, 0
 110++98CC 01 00 07     	ld bc, $0700
 111++98CF
 112++98CF 87           	add	a, a		; optimised 1st iteration
 113++98D0 30 02        	jr	nc, MulLoop
 114++98D2 62           	ld	h, d
 115++98D3 6B           	ld	l, e
 116++98D4
 117++98D4              MulLoop:
 118++98D4 29           	add	hl,hl
 119++98D5 17           	rla
 120++98D6 30 02        	jr	nc, NoAdd
 121++98D8 19           	add	hl,de
 122++98D9 89           	adc	a,c
 123++98DA              NoAdd:
 124++98DA 10 F8        	djnz MulLoop
 125++98DC
 126++98DC C9           	ret
 127++98DD              	ENDIF
 128++98DD
 129++98DD              	endif
# file closed: math.asm
  28+ 98DD
  29+ 98DD              DRIVE_CUR_BAS	EQU 0
  30+ 98DD              DRIVE_A_BAS		EQU	1
  31+ 98DD              DRIVE_B_BAS		EQU	2
  32+ 98DD              DRIVE_A_CPM		EQU	0
  33+ 98DD              DRIVE_B_CPM		EQU	1
  34+ 98DD              ;Disk geometry stuff
  35+ 98DD              SPT				EQU	16			;sectors per track
  36+ 98DD              SECT_SZ			EQU	256			;sector size in bytes
  37+ 98DD              TRACK_CNT		EQU	80			;track count
  38+ 98DD              HEAD_CNT		EQU	2			;disk face count
  39+ 98DD              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 98DD              EXT_SZ			EQU	32			;directory entry size
  41+ 98DD              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 98DD              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 98DD              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 98DD              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 98DD              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 98DD              REC_SZ			EQU 128			;cp/m record size
  47+ 98DD              DEL_MARKER		EQU	$E5
  48+ 98DD
  49+ 98DD
  50+ 98DD              ;Extension structure (directory entry)
  51+ 98DD              EXT_DEL_FLAG	EQU	0
  52+ 98DD              EXT_NAME		EQU 1
  53+ 98DD              EXT_IDX			EQU 12
  54+ 98DD              EXT_S1			EQU 13
  55+ 98DD              EXT_S2			EQU 14
  56+ 98DD              EXT_RC			EQU	15
  57+ 98DD              EXT_AU0			EQU	16
  58+ 98DD              EXT_AU1			EQU	18
  59+ 98DD              EXT_AU2			EQU	20
  60+ 98DD              EXT_AU3			EQU	22
  61+ 98DD              EXT_AU4			EQU	24
  62+ 98DD              EXT_AU5			EQU	26
  63+ 98DD              EXT_AU6			EQU	28
  64+ 98DD              EXT_AU7			EQU	30
  65+ 98DD              EXT_SIZE		EQU 32
  66+ 98DD
  67+ 98DD              ;FCB structure
  68+ 98DD              FCB_DRIVE		EQU 0
  69+ 98DD              FCB_NAME		EQU EXT_NAME
  70+ 98DD              FCB_EX_IDX		EQU EXT_IDX
  71+ 98DD              FCB_S1			EQU EXT_S1
  72+ 98DD              FCB_S2			EQU EXT_S2
  73+ 98DD              FCB_RC			EQU	EXT_RC
  74+ 98DD              FCB_AU			EQU	EXT_AU0
  75+ 98DD              FCB_CR			EQU	32
  76+ 98DD              FCB_R0			EQU 33
  77+ 98DD              FCB_R1			EQU 34
  78+ 98DD              FCB_R2			EQU 35
  79+ 98DD              FCB_SIZE		EQU 36
  80+ 98DD
  81+ 98DD
  82+ 98DD
  83+ 98DD              ;System variables for disk
  84+ 98DD              DSTR1			EQU	$5CD6		;drive
  85+ 98DD              FSTR1			EQU	$5CDC		;file name
  86+ 98DD              NSTR1			EQU	$5CDA		;name length
  87+ 98DD              HD11			EQU	$5CED		;BDOS argument
  88+ 98DD              COPIES			EQU	$5CEF		;BDOS function
  89+ 98DD
  90+ 98DD              ERRSP			EQU $5C3D
  91+ 98DD              ERRNR			EQU $5C3A
  92+ 98DD              ERRMSG			EQU	$0260
  93+ 98DD
  94+ 98DD              PROG			EQU $5C53
  95+ 98DD              VARS			EQU	$5C4B
  96+ 98DD              STKEND			EQU	$5C65
  97+ 98DD
  98+ 98DD              PRN_BUF			EQU	23296
  99+ 98DD
 100+ 98DD              STR_MSG_BASIC	EQU	$1539
 101+ 98DD              STR_MSG_BASIC_LEN EQU 32
 102+ 98DD              STR_MSG_IF1_2000	EQU $27F0
 103+ 98DD              STR_MSG_IF1_91		EQU $23F0
 104+ 98DD              STR_MSG_IF1_LEN EQU 31
 105+ 98DD
 106+ 98DD              REPDEL			EQU	23561
 107+ 98DD              REPPER			EQU	23562
 108+ 98DD              PIP				EQU	23609
 109+ 98DD
 110+ 98DD
 111+ 98DD              ;RWTS routine commands
 112+ 98DD              RWTS_CMD_POS	EQU	0			;position head
 113+ 98DD              RWTS_CMD_READ	EQU	1			;read sector
 114+ 98DD              RWTS_CMD_WRITE	EQU	2			;write sector
 115+ 98DD              RWTS_CMD_FMT	EQU	4			;format all tracks
 116+ 98DD
 117+ 98DD
 118+ 98DD              ;File name stuff
 119+ 98DD              NAMELEN			EQU	11			;name length
 120+ 98DD              RO_POS			EQU	8			;read-only attribute position in name
 121+ 98DD              SYS_POS			EQU	9			;system attribute position in name
 122+ 98DD
 123+ 98DD              ;File types (first byte in header)
 124+ 98DD              PROG_TYPE		EQU	0			;program
 125+ 98DD              NUMB_TYPE		EQU	1			;number array
 126+ 98DD              CHAR_TYPE		EQU	2			;char array
 127+ 98DD              BYTE_TYPE		EQU	3			;bytes
 128+ 98DD              TEXT_TYPE		EQU	4			;text, >= 4
 129+ 98DD
 130+ 98DD              ;File header offsets
 131+ 98DD              HDR_TYPE		EQU	0
 132+ 98DD              HDR_LEN			EQU 1
 133+ 98DD              HDR_ADDR		EQU 3
 134+ 98DD              HDR_PLEN		EQU	5
 135+ 98DD              HDR_LINE		EQU 7
 136+ 98DD              HDR_SZ			EQU	9
 137+ 98DD
 138+ 98DD              ;BASIC disk channel structure
 139+ 98DD              CH_RW_FLAG		EQU 11
 140+ 98DD              CH_FCB			EQU	12
 141+ 98DD              CH_DATA			EQU	50
 142+ 98DD              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143+ 98DD
 144+ 98DD              CACHE_NAME		EQU	0					;11B
 145+ 98DD              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146+ 98DD              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147+ 98DD              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148+ 98DD              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149+ 98DD              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150+ 98DD
 151+ 98DD              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152+ 98DD
 153+ 98DD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154+ 98DD              IF1Init:
 155+ 98DD CF           	rst		08
 156+ 98DE 31           	defb	49		;create system variables
 157+ 98DF C9           	ret
 158+ 98E0
 159+ 98E0              ;ReadWriteTrackSector
 160+ 98E0              ;A=command: 0, 1, 2, 4
 161+ 98E0              RWTS:
 162+ 98E0 32 7C 9C     	ld (RWTSCmd), a
 163+ 98E3 21 71 9C     	ld hl, RWTSParams
 164+ 98E6 22 ED 5C     	ld (HD11), hl
 165+ 98E9 CF           	rst 08
 166+ 98EA 3A           	DEFB 58
 167+ 98EB C9           	ret
 168+ 98EC
 169+ 98EC
 170+ 98EC              ;D = sector, E = track
 171+ 98EC              ;HL = dma
 172+ 98EC              ReadOneDiskSector:
 173+ 98EC 22 76 9C     	ld (RWTSDMA), hl
 174+ 98EF ED 53 74 9C  	ld (RWTSTrack), de
 175+ 98F3              	;ld (RWTSDrive), a
 176+ 98F3 3E 01        	ld a, RWTS_CMD_READ
 177+ 98F5 18 E9        	jr	RWTS
 178+ 98F7
 179+ 98F7              ;D = sector, E = track
 180+ 98F7              ;HL = dma
 181+ 98F7              WriteOneDiskSector:
 182+ 98F7 22 76 9C     	ld (RWTSDMA), hl
 183+ 98FA ED 53 74 9C  	ld (RWTSTrack), de
 184+ 98FE              	;ld (RWTSDrive), a
 185+ 98FE 3E 02        	ld a, RWTS_CMD_WRITE
 186+ 9900 18 DE        	jr	RWTS
 187+ 9902
 188+ 9902              FormatDisk:
 189+ 9902 21 E3 B6     	ld		hl, DataBuf
 190+ 9905 36 E5        	ld		(hl), DEL_MARKER
 191+ 9907 22 76 9C     	ld 		(RWTSDMA), hl
 192+ 990A 3E 04        	ld 		a, RWTS_CMD_FMT
 193+ 990C CD E0 98     	call	RWTS
 194+ 990F 3A 7D 9C     	ld		a, (RWTSRes)
 195+ 9912 C9           	ret
 196+ 9913
 197+ 9913              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198+ 9913
 199+ 9913              ;Allocation unit no. to track/sector
 200+ 9913              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201+ 9913              ;IN:  HL=alloc. unit no.
 202+ 9913              ;OUT: B=sector; C=track (head is determined by the sector number)
 203+ 9913              AU2TS:
 204+ 9913 0E 02        	ld c, SPT/SPAL
 205+ 9915 CD A9 98     	call Div					;A = sector
 206+ 9918 F5           	push af
 207+ 9919 ~            		/*
 208+ 9919 ~            		ld c, HEAD_CNT
 209+ 9919 ~            		call Div				;L = track, A = head (0 or 1)
 210+ 9919 ~            		*/
 211+ 9919 AF           		xor a
 212+ 991A CB 1C        		rr h
 213+ 991C CB 1D        		rr l
 214+ 991E CB 1F        		rr a
 215+ 9920
 216+ 9920 4D           		ld c, l
 217+ 9921 06 00        		ld b, 0
 218+ 9923 B7           		or a
 219+ 9924 28 02        		jr z, Track0
 220+ 9926 06 10        		ld b, SPT
 221+ 9928              Track0:
 222+ 9928 F1           	pop af
 223+ 9929 B7           	or a
 224+ 992A 28 02        	jr z, FirstAU
 225+ 992C 3E 08        	ld a, SPAL
 226+ 992E              FirstAU:
 227+ 992E 80           	add a, b
 228+ 992F 47           	ld  b, a
 229+ 9930 C9           	ret
 230+ 9931
 231+ 9931              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232+ 9931
 233+ 9931              ;Checks the allocation units number used in extension
 234+ 9931              ;IN:	IX = extension addr
 235+ 9931              ;OUT:	B = no. of allocation units used
 236+ 9931              ;		C = no. of records used in ext.
 237+ 9931              ;		HL = first alloc. unit no.
 238+ 9931              ;		DE = last alloc. unit no.
 239+ 9931              CheckExtAlloc:
 240+ 9931 DD E5        	push ix
 241+ 9933 01 0F 00     		ld bc, EXT_RC
 242+ 9936 DD 09        		add ix, bc
 243+ 9938 DD 4E 00     		ld c, (ix)			;save rec. no.
 244+ 993B DD 23        		inc ix
 245+ 993D DD 6E 00     		ld l, (ix)
 246+ 9940 DD 66 01     		ld h, (ix + 1)
 247+ 9943 06 08        		ld b, EXT_AU_CNT
 248+ 9945              CheckAU:
 249+ 9945 DD 7E 00     		ld a, (ix)
 250+ 9948 DD B6 01     		or (ix + 1)
 251+ 994B 28 0C        		jr z, CheckAUEnd
 252+ 994D DD 5E 00     		ld e, (ix)
 253+ 9950 DD 56 01     		ld d, (ix + 1)
 254+ 9953 DD 23        		inc ix
 255+ 9955 DD 23        		inc ix
 256+ 9957 10 EC        		djnz CheckAU
 257+ 9959              CheckAUEnd:
 258+ 9959 3E 08        		ld a, EXT_AU_CNT
 259+ 995B 90           		sub b
 260+ 995C 47           		ld b, a
 261+ 995D DD E1        	pop ix
 262+ 995F C9           	ret
 263+ 9960
 264+ 9960              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265+ 9960
 266+ 9960              ;Input: TrackBuffer
 267+ 9960              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268+ 9960              ReadUsedBlocksList:
 269+ 9960 DD 21 E3 B6  	ld		ix, TrackBuf			;source buffer
 270+ 9964 21 F9 B0     	ld		hl, UsedBlockListCnt 	;destination buffer
 271+ 9967 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272+ 996A 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 273+ 996D 73           	ld		(hl), e
 274+ 996E 23           	inc		hl
 275+ 996F 72           	ld		(hl), d
 276+ 9970 23           	inc		hl
 277+ 9971
 278+ 9971              	;Add blocks 0 and 1 for directory
 279+ 9971 11 00 00     	ld		de, 0
 280+ 9974 73           	ld		(hl), e
 281+ 9975 23           	inc		hl
 282+ 9976 72           	ld		(hl), d
 283+ 9977 23           	inc		hl
 284+ 9978
 285+ 9978 13           	inc		de
 286+ 9979 73           	ld		(hl), e
 287+ 997A 23           	inc		hl
 288+ 997B 72           	ld		(hl), d
 289+ 997C 23           	inc		hl
 290+ 997D
 291+ 997D              ReadUsedBlocksLoop:
 292+ 997D AF           	xor		a
 293+ 997E DD BE 00     	cp		(ix)
 294+ 9981 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295+ 9983
 296+ 9983 DD E5        	push	ix
 297+ 9985 C5           	push	bc
 298+ 9986 06 08        		ld		b, EXT_AU_CNT
 299+ 9988 11 10 00     		ld		de, EXT_AU0
 300+ 998B DD 19        		add		ix, de
 301+ 998D
 302+ 998D              ReadUsedBlocksLoop2:
 303+ 998D DD 5E 00     		ld		e, (ix)
 304+ 9990 DD 56 01     		ld		d, (ix+1)
 305+ 9993 7B           		ld		a, e
 306+ 9994 B2           		or		d
 307+ 9995 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308+ 9997
 309+ 9997 73           		ld		(hl), e
 310+ 9998 23           		inc		hl
 311+ 9999 72           		ld		(hl), d
 312+ 999A 23           		inc		hl
 313+ 999B
 314+ 999B DD 23        		inc		ix
 315+ 999D DD 23        		inc		ix
 316+ 999F
 317+ 999F ED 5B F9 B0  		ld		de, (UsedBlockListCnt)
 318+ 99A3 13           		inc		de
 319+ 99A4 ED 53 F9 B0  		ld		(UsedBlockListCnt), de
 320+ 99A8
 321+ 99A8 10 E3        		djnz	ReadUsedBlocksLoop2
 322+ 99AA
 323+ 99AA
 324+ 99AA              ReadUsedBlocksSkip:
 325+ 99AA C1           	pop		bc
 326+ 99AB DD E1        	pop		ix
 327+ 99AD              ReadUsedBlocksSkip2:
 328+ 99AD 11 20 00     	ld		de, EXT_SZ
 329+ 99B0 DD 19        	add		ix, de
 330+ 99B2
 331+ 99B2 0B           	dec		bc
 332+ 99B3 78           	ld		a, b
 333+ 99B4 B1           	or		c
 334+ 99B5 20 C6        	jr		nz, ReadUsedBlocksLoop
 335+ 99B7
 336+ 99B7 C9           	ret
 337+ 99B8
 338+ 99B8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339+ 99B8              ;Reads 8 sectors for an AU
 340+ 99B8              ;HL = block number, DE = destination buffer
 341+ 99B8              ReadFSBlock:
 342+ 99B8 D5           	push	de
 343+ 99B9 CD 13 99     		call	AU2TS		;B=sector, C=track
 344+ 99BC E1           	pop		hl				;HL=dest
 345+ 99BD
 346+ 99BD 50           	ld		d, b
 347+ 99BE 59           	ld		e, c
 348+ 99BF 06 08        	ld		b, SPAL
 349+ 99C1
 350+ 99C1              ReadFSBlockLoop:
 351+ 99C1 CD 70 9B     	call	ReadDiskSectors
 352+ 99C4 C9           	ret
 353+ 99C5
 354+ 99C5
 355+ 99C5              ;Write 8 sectors for an AU
 356+ 99C5              ;HL = block number, DE = source buffer
 357+ 99C5              WriteFSBlock:
 358+ 99C5 D5           	push	de
 359+ 99C6 CD 13 99     		call	AU2TS		;B=sector, C=track
 360+ 99C9 E1           	pop		hl				;HL=dest
 361+ 99CA
 362+ 99CA 50           	ld		d, b
 363+ 99CB 59           	ld		e, c
 364+ 99CC 06 08        	ld		b, SPAL
 365+ 99CE
 366+ 99CE              WriteFSBlockLoop:
 367+ 99CE CD 83 9B     	call	WriteDiskSectors
 368+ 99D1 C9           	ret
 369+ 99D2
 370+ 99D2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371+ 99D2              ;Copies the allocated blocks from one disk to another, dual drive.
 372+ 99D2              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373+ 99D2              CopyDisk:
 374+ 99D2              	;Get list of used blocks in current disk, max 632 bytes
 375+ 99D2 CD 60 99     	call	ReadUsedBlocksList
 376+ 99D5 DD 21 FB B0  	ld		ix, UsedBlockListBlk
 377+ 99D9
 378+ 99D9              CopyDiskLoop:
 379+ 99D9 2A F9 B0     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380+ 99DC 11 9C A7     	ld		de, MsgBlocksLeft
 381+ 99DF CD 6D 98     	call	Byte2Txt
 382+ 99E2 21 9C A7     	ld		hl, MsgBlocksLeft
 383+ 99E5 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 384+ 99E8 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 385+ 99EA CD D9 9F     	call	PrintStrClr
 386+ 99ED
 387+ 99ED              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388+ 99ED 21 09 00     	ld		hl, MAX_AU_RAM
 389+ 99F0 ED 4B F9 B0  	ld		bc, (UsedBlockListCnt)
 390+ 99F4 B7           	or		a
 391+ 99F5 ED 42        	sbc		hl, bc
 392+ 99F7 30 03        	jr		nc, CopyDiskLoopRead
 393+ 99F9 01 09 00     	ld		bc, MAX_AU_RAM
 394+ 99FC
 395+ 99FC              CopyDiskLoopRead:
 396+ 99FC 41           	ld		b, c
 397+ 99FD 11 E3 B6     	ld		de, CopyDiskBuf
 398+ 9A00              	;save initial counter and initial block number array position
 399+ 9A00 C5           	push	bc
 400+ 9A01 DD E5        	push	ix
 401+ 9A03
 402+ 9A03              CopyDiskLoopReadLoop:
 403+ 9A03 DD 6E 00     		ld		l, (ix)
 404+ 9A06 DD 66 01     		ld		h, (ix+1)
 405+ 9A09 DD 23        		inc		ix
 406+ 9A0B DD 23        		inc		ix
 407+ 9A0D
 408+ 9A0D D5           		push	de
 409+ 9A0E C5           		push	bc
 410+ 9A0F CD B8 99     			call	ReadFSBlock			;Stop on error or continue?
 411+ 9A12 C1           		pop		bc
 412+ 9A13 D1           		pop		de
 413+ 9A14
 414+ 9A14              		;+2048
 415+ 9A14 7A           		ld		a, d
 416+ 9A15 C6 08        		add		8
 417+ 9A17 57           		ld		d, a
 418+ 9A18
 419+ 9A18 10 E9        		djnz	CopyDiskLoopReadLoop
 420+ 9A1A
 421+ 9A1A              		;alternate drive
 422+ 9A1A 3A 72 9C     		ld		a, (RWTSDrive)
 423+ 9A1D EE 03        		xor		%11
 424+ 9A1F 32 72 9C     		ld		(RWTSDrive), a
 425+ 9A22
 426+ 9A22              	;restore initial counter and initial block number array position
 427+ 9A22 DD E1        	pop		ix
 428+ 9A24 C1           	pop		bc
 429+ 9A25 11 E3 B6     	ld		de, CopyDiskBuf
 430+ 9A28 C5           	push	bc
 431+ 9A29
 432+ 9A29              CopyDiskLoopWriteLoop:
 433+ 9A29 DD 6E 00     		ld		l, (ix)
 434+ 9A2C DD 66 01     		ld		h, (ix+1)
 435+ 9A2F DD 23        		inc		ix
 436+ 9A31 DD 23        		inc		ix
 437+ 9A33
 438+ 9A33 D5           		push	de
 439+ 9A34 C5           		push	bc
 440+ 9A35 CD C5 99     			call	WriteFSBlock		;Stop on error or continue?
 441+ 9A38 C1           		pop		bc
 442+ 9A39 D1           		pop		de
 443+ 9A3A
 444+ 9A3A              		;+2048
 445+ 9A3A 7A           		ld		a, d
 446+ 9A3B C6 08        		add		8
 447+ 9A3D 57           		ld		d, a
 448+ 9A3E
 449+ 9A3E 10 E9        		djnz	CopyDiskLoopWriteLoop
 450+ 9A40
 451+ 9A40              		;alternate drive again
 452+ 9A40 3A 72 9C     		ld		a, (RWTSDrive)
 453+ 9A43 EE 03        		xor		%11
 454+ 9A45 32 72 9C     		ld		(RWTSDrive), a
 455+ 9A48
 456+ 9A48 C1           	pop		bc
 457+ 9A49 48           	ld		c, b
 458+ 9A4A 06 00        	ld		b, 0
 459+ 9A4C
 460+ 9A4C              	;Decrease number of blocks read by now.
 461+ 9A4C 2A F9 B0     	ld		hl, (UsedBlockListCnt)
 462+ 9A4F B7           	or		a
 463+ 9A50 ED 42        	sbc		hl, bc
 464+ 9A52 22 F9 B0     	ld		(UsedBlockListCnt), hl
 465+ 9A55
 466+ 9A55 7D           	ld		a, l
 467+ 9A56 B4           	or		h
 468+ 9A57 C2 D9 99     	jp		nz, CopyDiskLoop
 469+ 9A5A
 470+ 9A5A C9           	ret
 471+ 9A5B
 472+ 9A5B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473+ 9A5B              ;Copies the current disk blocks to COM port.
 474+ 9A5B              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475+ 9A5B              CopyDiskToCOM:
 476+ 9A5B              	;Get list of used blocks in current disk, max 632 bytes
 477+ 9A5B CD 60 99     	call	ReadUsedBlocksList
 478+ 9A5E
 479+ 9A5E              	;Send block count and block indexes
 480+ 9A5E 2A F9 B0     	ld		hl, (UsedBlockListCnt)
 481+ 9A61 29           	add		hl, hl
 482+ 9A62 23           	inc		hl
 483+ 9A63 23           	inc		hl
 484+ 9A64 44           	ld		b, h
 485+ 9A65 4D           	ld		c, l
 486+ 9A66 21 F9 B0     	ld		hl, UsedBlockListCnt
 487+ 9A69 CD FB A4     	call	SERTB
 488+ 9A6C
 489+ 9A6C DD 21 FB B0  	ld		ix, UsedBlockListBlk
 490+ 9A70
 491+ 9A70              CopyDiskToCOMLoop:
 492+ 9A70              	;Print block count left
 493+ 9A70 2A F9 B0     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494+ 9A73 11 9C A7     	ld		de, MsgBlocksLeft
 495+ 9A76 CD 6D 98     	call	Byte2Txt
 496+ 9A79 21 9C A7     	ld		hl, MsgBlocksLeft
 497+ 9A7C 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 498+ 9A7F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 499+ 9A81 CD D9 9F     	call	PrintStrClr
 500+ 9A84
 501+ 9A84              	;Read block into buffer
 502+ 9A84 DD 6E 00     	ld		l, (ix)
 503+ 9A87 DD 66 01     	ld		h, (ix+1)
 504+ 9A8A 11 E3 B6     	ld		de, CopyDiskBuf
 505+ 9A8D DD E5        	push	ix
 506+ 9A8F CD B8 99     		call	ReadFSBlock
 507+ 9A92 DD E1        	pop		ix
 508+ 9A94 DD 23        	inc		ix
 509+ 9A96 DD 23        	inc		ix
 510+ 9A98
 511+ 9A98              	;Send block buffer
 512+ 9A98 21 E3 B6     	ld		hl, CopyDiskBuf
 513+ 9A9B 01 00 08     	ld		bc, AU_SZ
 514+ 9A9E CD FB A4     	call	SERTB
 515+ 9AA1
 516+ 9AA1 ED 4B F9 B0  	ld		bc, (UsedBlockListCnt)
 517+ 9AA5 0B           	dec		bc
 518+ 9AA6 ED 43 F9 B0  	ld		(UsedBlockListCnt), bc
 519+ 9AAA
 520+ 9AAA DD E5        	push	ix
 521+ 9AAC CD 78 9F     		call	KbdHit
 522+ 9AAF DD E1        	pop		ix
 523+ 9AB1 D8           	ret		c
 524+ 9AB2
 525+ 9AB2 78           	ld		a, b
 526+ 9AB3 B1           	or		c
 527+ 9AB4 20 BA        	jr		nz, CopyDiskToCOMLoop
 528+ 9AB6
 529+ 9AB6 C9           	ret
 530+ 9AB7
 531+ 9AB7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532+ 9AB7              CopyDiskFromCOM:
 533+ 9AB7              	;Receive block count.
 534+ 9AB7 21 F9 B0     	ld		hl, UsedBlockListCnt
 535+ 9ABA 01 02 00     	ld		bc, 2
 536+ 9ABD 1E 00        	ld		e, 0
 537+ 9ABF CD C8 A4     	call	SERRB
 538+ 9AC2
 539+ 9AC2              	;Receive block indexes.
 540+ 9AC2 2A F9 B0     	ld		hl, (UsedBlockListCnt)
 541+ 9AC5 29           	add		hl, hl
 542+ 9AC6 44           	ld		b, h
 543+ 9AC7 4D           	ld		c, l
 544+ 9AC8 21 FB B0     	ld		hl, UsedBlockListBlk
 545+ 9ACB 1E 00        	ld		e, 0
 546+ 9ACD CD C8 A4     	call	SERRB
 547+ 9AD0
 548+ 9AD0              	;Read each block by index and write to disk
 549+ 9AD0 DD 21 FB B0  	ld		ix, UsedBlockListBlk
 550+ 9AD4
 551+ 9AD4              CopyDiskFromCOMLoop:
 552+ 9AD4              	;Print block count left
 553+ 9AD4 2A F9 B0     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554+ 9AD7 11 9C A7     	ld		de, MsgBlocksLeft
 555+ 9ADA CD 6D 98     	call	Byte2Txt
 556+ 9ADD 21 9C A7     	ld		hl, MsgBlocksLeft
 557+ 9AE0 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 558+ 9AE3 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 559+ 9AE5 CD D9 9F     	call	PrintStrClr
 560+ 9AE8
 561+ 9AE8              	;Read block buffer
 562+ 9AE8 21 E3 B6     	ld		hl, CopyDiskBuf
 563+ 9AEB 01 00 08     	ld		bc, AU_SZ
 564+ 9AEE 1E 00        	ld		e, 0
 565+ 9AF0 CD C8 A4     	call	SERRB
 566+ 9AF3
 567+ 9AF3              	;Write block to disk
 568+ 9AF3 DD 6E 00     	ld		l, (ix)
 569+ 9AF6 DD 66 01     	ld		h, (ix+1)
 570+ 9AF9 11 E3 B6     	ld		de, CopyDiskBuf
 571+ 9AFC DD E5        	push	ix
 572+ 9AFE CD C5 99     		call	WriteFSBlock			;Stop on error or continue?
 573+ 9B01 DD E1        	pop		ix
 574+ 9B03 DD 23        	inc		ix
 575+ 9B05 DD 23        	inc		ix
 576+ 9B07
 577+ 9B07 ED 4B F9 B0  	ld		bc, (UsedBlockListCnt)
 578+ 9B0B 0B           	dec		bc
 579+ 9B0C ED 43 F9 B0  	ld		(UsedBlockListCnt), bc
 580+ 9B10
 581+ 9B10 DD E5        	push	ix
 582+ 9B12 CD 78 9F     		call	KbdHit
 583+ 9B15 DD E1        	pop		ix
 584+ 9B17 D8           	ret		c
 585+ 9B18
 586+ 9B18 78           	ld		a, b
 587+ 9B19 B1           	or		c
 588+ 9B1A 20 B8        	jr		nz, CopyDiskFromCOMLoop
 589+ 9B1C C9           	ret
 590+ 9B1D
 591+ 9B1D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592+ 9B1D
 593+ 9B1D              ;Compare string at HL with the one at DE, max length B
 594+ 9B1D              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595+ 9B1D              ;OUT: z flag, set = match, reset = mismatch
 596+ 9B1D              StrCmp:
 597+ 9B1D E5           	push hl
 598+ 9B1E D5           	push de
 599+ 9B1F              Compare:
 600+ 9B1F 1A           		ld a, (de)
 601+ 9B20 BE           		cp (hl)
 602+ 9B21 20 04        		jr nz, MisMatch
 603+ 9B23 23           		inc hl
 604+ 9B24 13           		inc de
 605+ 9B25 10 F8        		djnz Compare
 606+ 9B27              MisMatch:
 607+ 9B27 D1           	pop de
 608+ 9B28 E1           	pop hl
 609+ 9B29 C9           	ret
 610+ 9B2A
 611+ 9B2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612+ 9B2A
 613+ 9B2A              ;Read a file into a buffer, sector by sector.
 614+ 9B2A              ;It's relocatable, to moved and be used when loading a CODE block.
 615+ 9B2A              ;It's not using BDOS, but using similar calls provided by IF1.
 616+ 9B2A              ;In: HL = Name address, DE = buffer
 617+ 9B2A              IF1FileLoad:
 618+ 9B2A D5           	push	de
 619+ 9B2B 22 DC 5C     		ld (FSTR1), hl
 620+ 9B2E 26 00        		ld h, 0
 621+ 9B30 3A 72 9C     		ld a, (RWTSDrive)
 622+ 9B33 3C           		inc  a			;CP/M drive number to BASIC drive number
 623+ 9B34 6F           		ld	l, a
 624+ 9B35 22 D6 5C     		ld (DSTR1), hl
 625+ 9B38 2E 0B        		ld l,NAMELEN
 626+ 9B3A 22 DA 5C     		ld (NSTR1), hl
 627+ 9B3D CF           		rst 08
 628+ 9B3E 33           		DEFB 51			;open disk channel
 629+ 9B3F
 630+ 9B3F CF           		rst		8
 631+ 9B40 35           		defb	53		;read sector
 632+ 9B41 D1           	pop		de
 633+ 9B42 30 27        	jr		nc, FileFree
 634+ 9B44
 635+ 9B44 DD 7E 32     	ld		a, (ix + CH_DATA)
 636+ 9B47 FE 04        	cp		TEXT_TYPE
 637+ 9B49 30 12        	jr		nc, FileLoadNoHeader
 638+ 9B4B
 639+ 9B4B              FileLoadHeader:
 640+ 9B4B DD E5        	push	ix
 641+ 9B4D E1           	pop		hl
 642+ 9B4E 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 643+ 9B51 09           	add		hl, bc
 644+ 9B52 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 645+ 9B55 ED B0        	ldir
 646+ 9B57
 647+ 9B57              FileReadLoop:
 648+ 9B57 D5           	push	de
 649+ 9B58 CF           		rst		8
 650+ 9B59 35           		defb	53		;read sector
 651+ 9B5A D1           	pop		de
 652+ 9B5B 30 0E        	jr		nc, FileFree
 653+ 9B5D
 654+ 9B5D              FileLoadNoHeader:
 655+ 9B5D DD E5        	push	ix
 656+ 9B5F E1           	pop		hl
 657+ 9B60 01 32 00     	ld		bc, CH_DATA
 658+ 9B63 09           	add		hl, bc
 659+ 9B64 01 00 01     	ld		bc, SECT_SZ
 660+ 9B67 ED B0        	ldir
 661+ 9B69 18 EC        	jr		FileReadLoop
 662+ 9B6B              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663+ 9B6B              IF1FileLoadEnd:
 664+ 9B6B
 665+ 9B6B              FileFree:
 666+ 9B6B D5           	push	de
 667+ 9B6C CF           	rst		8
 668+ 9B6D 38           	defb	56			;close channel (52) or detroy channel (56)
 669+ 9B6E D1           	pop		de
 670+ 9B6F C9           	ret
 671+ 9B70
 672+ 9B70
 673+ 9B70              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674+ 9B70              ;HL = destination buffer, B = count of sectors, DE = track/sector
 675+ 9B70              ;Out: A = error code, 0=OK
 676+ 9B70              ReadDiskSectors:
 677+ 9B70 C5           	push bc
 678+ 9B71 E5           		push hl
 679+ 9B72 D5           			push de
 680+ 9B73 CD EC 98     				call ReadOneDiskSector
 681+ 9B76 D1           			pop de
 682+ 9B77 E1           		pop hl
 683+ 9B78
 684+ 9B78 14           		inc d
 685+ 9B79 24           		inc h
 686+ 9B7A C1           	pop bc
 687+ 9B7B
 688+ 9B7B 3A 7D 9C     	ld	a, (RWTSRes)
 689+ 9B7E B7           	or	a
 690+ 9B7F C0           	ret nz
 691+ 9B80
 692+ 9B80 10 EE        	djnz ReadDiskSectors
 693+ 9B82 C9           	ret
 694+ 9B83
 695+ 9B83              ;HL = source buffer, B = count of sectors, DE = track/sector
 696+ 9B83              ;Out: A = error code, 0=OK
 697+ 9B83              WriteDiskSectors:
 698+ 9B83 C5           	push bc
 699+ 9B84 E5           		push hl
 700+ 9B85 D5           			push de
 701+ 9B86 CD F7 98     				call WriteOneDiskSector
 702+ 9B89 D1           			pop de
 703+ 9B8A E1           		pop hl
 704+ 9B8B
 705+ 9B8B 14           		inc d
 706+ 9B8C 24           		inc h
 707+ 9B8D C1           	pop bc
 708+ 9B8E
 709+ 9B8E 3A 7D 9C     	ld	a, (RWTSRes)
 710+ 9B91 B7           	or	a
 711+ 9B92 C0           	ret nz
 712+ 9B93
 713+ 9B93 10 EE        	djnz WriteDiskSectors
 714+ 9B95 C9           	ret
 715+ 9B96
 716+ 9B96
 717+ 9B96              ;Reads disk catalog
 718+ 9B96              ReadCatalogTrack:
 719+ 9B96 21 E3 B6     	ld hl, TrackBuf
 720+ 9B99 11 00 00     	ld de, 0
 721+ 9B9C 06 10        	ld b, SPT
 722+ 9B9E
 723+ 9B9E CD 70 9B     	call ReadDiskSectors
 724+ 9BA1 B7           	or   a
 725+ 9BA2 C0           	ret  nz
 726+ 9BA3
 727+ 9BA3              	;Sync with BDOS, to avoid disk R/O error on disk change
 728+ 9BA3 F5           	push  af
 729+ 9BA4 3A 72 9C     		ld  a, (RWTSDrive)
 730+ 9BA7 CD 9D 9C     		call BDOSSelectDisk
 731+ 9BAA CD 9A 9C     		call BDOSInit
 732+ 9BAD F1           	pop   af
 733+ 9BAE C9           	ret
 734+ 9BAF
 735+ 9BAF
 736+ 9BAF
 737+ 9BAF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738+ 9BAF
 739+ 9BAF              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740+ 9BAF              FindCache:
 741+ 9BAF 06 0B        	ld		b, NAMELEN
 742+ 9BB1 CD 1D 9B     	call	StrCmp			;find the file to wich this extension belongs
 743+ 9BB4 C8           	ret		z
 744+ 9BB5
 745+ 9BB5 0D           	dec		c
 746+ 9BB6 20 02        	jr		nz, CacheNotFinished
 747+ 9BB8 B1           	or		c
 748+ 9BB9 C9           	ret
 749+ 9BBA
 750+ 9BBA              CacheNotFinished:
 751+ 9BBA 01 19 00     	ld		bc, CACHE_SZ
 752+ 9BBD 09           	add		hl, bc			;to the next cache line
 753+ 9BBE 18 EF        	jr		FindCache
 754+ 9BC0
 755+ 9BC0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756+ 9BC0
 757+ 9BC0              	;ld		ix, (SelFileCache)
 758+ 9BC0              ReadFileHeader:
 759+ 9BC0 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 760+ 9BC3 B7           	or		a
 761+ 9BC4 C0           	ret		nz				;return if already read
 762+ 9BC5
 763+ 9BC5 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 764+ 9BC8 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 765+ 9BCB 7C           	ld		a, h
 766+ 9BCC B5           	or		l
 767+ 9BCD 28 46        	jr		z, ReadHeaderEnd
 768+ 9BCF
 769+ 9BCF CD 13 99     	call	AU2TS
 770+ 9BD2 50           	ld		d, b
 771+ 9BD3 59           	ld		e, c
 772+ 9BD4 21 E3 B6     	ld		hl, DataBuf
 773+ 9BD7 DD E5        	push	ix
 774+ 9BD9 DD E5        	push	ix
 775+ 9BDB CD EC 98     		call	ReadOneDiskSector
 776+ 9BDE E1           	pop		hl
 777+ 9BDF DD E1        	pop		ix
 778+ 9BE1
 779+ 9BE1 E5           	push	hl
 780+ 9BE2 21 E3 B6     		ld		hl, DataBuf
 781+ 9BE5 CD 19 9C     		call	IsFileHeaderValid
 782+ 9BE8 E1           	pop		hl
 783+ 9BE9 B7           	or		a
 784+ 9BEA 28 14        	jr		z, ReadFileHeaderIsTextFile
 785+ 9BEC
 786+ 9BEC 01 10 00     	ld		bc, CACHE_HDR
 787+ 9BEF 09           	add		hl, bc
 788+ 9BF0 EB           	ex		hl, de
 789+ 9BF1 21 E3 B6     	ld		hl, DataBuf
 790+ 9BF4 01 09 00     	ld		bc, HDR_SZ
 791+ 9BF7 ED B0        	ldir
 792+ 9BF9
 793+ 9BF9              	;For text files, read file size as reported by BDOS, since we don't have a header.
 794+ 9BF9 3E 03        	ld		a, BYTE_TYPE
 795+ 9BFB DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 796+ 9BFE 30 15        	jr		nc, ReadHeaderEnd
 797+ 9C00
 798+ 9C00              ReadFileHeaderIsTextFile:
 799+ 9C00 DD E5        	push	ix
 800+ 9C02 DD E5        	push	ix
 801+ 9C04 E1           	pop		hl
 802+ 9C05 CD F4 9C     		call	GetFileSize
 803+ 9C08 DD E1        	pop		ix
 804+ 9C0A DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 805+ 9C0D DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806+ 9C10 3E 04        	ld		a, TEXT_TYPE
 807+ 9C12 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808+ 9C15
 809+ 9C15              ReadHeaderEnd:
 810+ 9C15 DD 34 0F     	inc		(ix + CACHE_FLAG)
 811+ 9C18 C9           	ret
 812+ 9C19
 813+ 9C19              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814+ 9C19              ;Checks if the file header is valid. For now it checks to not have all 0s.
 815+ 9C19              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816+ 9C19              ;In: HL = header
 817+ 9C19              ;Out: A > 0 if valid
 818+ 9C19              IsFileHeaderValid:
 819+ 9C19              	IFUSED
 820+ 9C19 AF           	xor		a
 821+ 9C1A 06 09        	ld		b, HDR_SZ
 822+ 9C1C              IsFileHeaderValidLoop:
 823+ 9C1C B6           	or		(hl)
 824+ 9C1D 23           	inc		hl
 825+ 9C1E 10 FC        	djnz	IsFileHeaderValidLoop
 826+ 9C20
 827+ 9C20 C9           	ret
 828+ 9C21              	ENDIF
 829+ 9C21
 830+ 9C21              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831+ 9C21
 832+ 9C21              ;IN: HL = address from IF1 to call
 833+ 9C21              IF1Call:
 834+ 9C21 22 ED 5C     	LD   (HD11), HL
 835+ 9C24 CF           	RST  8
 836+ 9C25 32           	DEFB 50
 837+ 9C26 C9           	RET
 838+ 9C27
 839+ 9C27              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840+ 9C27
 841+ 9C27              ;Load a program from disk
 842+ 9C27              ;IN: HL = file name addr
 843+ 9C27              LoadProgram:
 844+ 9C27 22 DC 5C     	LD   (FSTR1), HL
 845+ 9C2A 26 00        	LD   H, 0
 846+ 9C2C 2E 0B        	LD   L, NAMELEN
 847+ 9C2E 22 DA 5C     	LD   (NSTR1), HL
 848+ 9C31 3A 72 9C     	LD	 A, (RWTSDrive)
 849+ 9C34 3C           	INC  A					;Adapt for BASIC drive number
 850+ 9C35 6F           	LD   L, A
 851+ 9C36 22 D6 5C     	LD   (DSTR1), HL
 852+ 9C39 21 41 0A     	LD   HL, LOAD_ADDR
 853+ 9C3C CD 21 9C     	CALL IF1Call
 854+ 9C3F C9           	RET
 855+ 9C40
 856+ 9C40              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857+ 9C40
 858+ 9C40              SetFastKeys:
 859+ 9C40 21 09 5C     	ld		hl, REPDEL
 860+ 9C43 11 0F 01     	ld		de, (1 << 8) | 15
 861+ 9C46 73 23 72 2B  	ld		(hl), de
 862+ 9C4A
 863+ 9C4A C9           	ret
 864+ 9C4B
 865+ 9C4B
 866+ 9C4B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867+ 9C4B              ;Reads the error message string from IF1 ROM.
 868+ 9C4B              GetErrMsg:
 869+ 9C4B 3C           	inc		a
 870+ 9C4C 08           	ex		af, af'
 871+ 9C4D
 872+ 9C4D 21 53 9C     	ld		hl, IF1Paged			;page-in IF1
 873+ 9C50 C3 21 9C     	jp		IF1Call
 874+ 9C53
 875+ 9C53              IF1Paged:
 876+ 9C53 21 60 02     	ld		hl, ERRMSG
 877+ 9C56 08           	ex		af, af'
 878+ 9C57 B7           	or		a
 879+ 9C58 28 0B        	jr		z, SaveMsg
 880+ 9C5A
 881+ 9C5A 06 00        	ld		b, 0
 882+ 9C5C              SearchMsgEnd:
 883+ 9C5C CB 7E        	bit		7, (hl)
 884+ 9C5E 23           	inc		hl
 885+ 9C5F 28 FB        	jr		z, SearchMsgEnd
 886+ 9C61
 887+ 9C61 04           	inc		b
 888+ 9C62 B8           	cp		b
 889+ 9C63 20 F7        	jr		nz, SearchMsgEnd
 890+ 9C65
 891+ 9C65              SaveMsg:
 892+ 9C65 11 E3 B6     	ld		de, DataBuf
 893+ 9C68              CopyMsg:
 894+ 9C68 7E           	ld		a, (hl)
 895+ 9C69 CB 7F        	bit		7, a
 896+ 9C6B 12           	ld		(de), a
 897+ 9C6C 23           	inc		hl
 898+ 9C6D 13           	inc		de
 899+ 9C6E 28 F8        	jr		z, CopyMsg
 900+ 9C70
 901+ 9C70 C9           	ret
 902+ 9C71
 903+ 9C71              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904+ 9C71
 905+ 9C71              ;RWTS routine I/O block
 906+ 9C71              RWTSParams:
 907+ 9C71 01           RWTSBlockType	DEFB	1							;?
 908+ 9C72 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 909+ 9C73 00           RWTSVolNo		DEFB	0							;?
 910+ 9C74 00           RWTSTrack		DEFB	0
 911+ 9C75 00           RWTSSector		DEFB	0
 912+ 9C76 00 00        RWTSDMA			DEFW	0
 913+ 9C78 32 29        RWTSExtBuf		DEFW	$2932
 914+ 9C7A              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 915+ 9C7A              	IFDEF _REAL_HW_
 916+ 9C7A 84 9C        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 917+ 9C7C              	ELSE
 918+ 9C7C ~            RWTSPrmTbl		DEFW	$1f2a
 919+ 9C7C              	ENDIF
 920+ 9C7C 01           RWTSCmd			DEFB	RWTS_CMD_READ
 921+ 9C7D              ;Results
 922+ 9C7D 00           RWTSRes			DEFB	0
 923+ 9C7E 00           RWTSResVolNo	DEFB	0
 924+ 9C7F 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 924+ 9C83 00
 925+ 9C84
 926+ 9C84              ;Param. table, usualy found in ROM.
 927+ 9C84              	IFDEF _REAL_HW_
 928+ 9C84              BasPrmTbl:
 929+ 9C84 01           PrmDevType		DEFB	$01		;$01
 930+ 9C85 01           PrmStepRate		DEFB	$01		;$0D	(milisec)
 931+ 9C86 01           PrmHeadLoad		DEFB	$01		;$23	(milisec)
 932+ 9C87 01           PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 933+ 9C88 8A 9C        PrmIntrlvTbl	DEFW	InterleaveTbl
 934+ 9C8A 01 03 05 07  InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 934+ 9C8E 09 0B 0D 0F
 934+ 9C92 02 04 06 08
 934+ 9C96 0A 0C 0E 10
 935+ 9C9A              	ENDIF
 936+ 9C9A
 937+ 9C9A              	endif
# file closed: if1.asm
1316  9C9A              	include "bdos.asm"
# file opened: bdos.asm
   1+ 9C9A              ;BDOS functions - similar to CP/M
   2+ 9C9A
   3+ 9C9A              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 9C9A              ;0 OK,
   5+ 9C9A              ;1 directory full,
   6+ 9C9A              ;2 disc full,
   7+ 9C9A              ;9 invalid FCB,
   8+ 9C9A              ;10(CP/M) media changed;
   9+ 9C9A              ;0FFh hardware error.
  10+ 9C9A
  11+ 9C9A              	IFNDEF	_BDOS_
  12+ 9C9A              	DEFINE	_BDOS_
  13+ 9C9A
  14+ 9C9A              	include "if1.asm"
# file opened: if1.asm
   1++9C9A              ;HC IF1 routines and constants
   2++9C9A
   3++9C9A              ;IF1 routines error codes, also returned by BASIC commands
   4++9C9A              ;12 = Writing to a 'read' file
   5++9C9A              ;13 = Reading a 'write' file
   6++9C9A              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++9C9A              ;15 = Disk full (disk or catalog full)
   8++9C9A              ;16 = Disk error (hardware error)
   9++9C9A              ;17 = File not found
  10++9C9A              ;23 = Disk R/O (disk change detected, software R/O)
  11++9C9A              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++9C9A
  13++9C9A              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++9C9A              ;00h = OK
  15++9C9A              ;08h = cannot format disk
  16++9C9A              ;10h = disk protected (read-only?)
  17++9C9A              ;20h = volume error
  18++9C9A              ;40h = drive error
  19++9C9A              ;80h = reading error
  20++9C9A              ;Codes I encountered:
  21++9C9A              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++9C9A
  23++9C9A
  24++9C9A              	ifndef	_DISK_
  25++9C9A ~            	define	_DISK_
  26++9C9A ~
  27++9C9A ~            	include	"math.asm"
  28++9C9A ~
  29++9C9A ~            DRIVE_CUR_BAS	EQU 0
  30++9C9A ~            DRIVE_A_BAS		EQU	1
  31++9C9A ~            DRIVE_B_BAS		EQU	2
  32++9C9A ~            DRIVE_A_CPM		EQU	0
  33++9C9A ~            DRIVE_B_CPM		EQU	1
  34++9C9A ~            ;Disk geometry stuff
  35++9C9A ~            SPT				EQU	16			;sectors per track
  36++9C9A ~            SECT_SZ			EQU	256			;sector size in bytes
  37++9C9A ~            TRACK_CNT		EQU	80			;track count
  38++9C9A ~            HEAD_CNT		EQU	2			;disk face count
  39++9C9A ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++9C9A ~            EXT_SZ			EQU	32			;directory entry size
  41++9C9A ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++9C9A ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++9C9A ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++9C9A ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++9C9A ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++9C9A ~            REC_SZ			EQU 128			;cp/m record size
  47++9C9A ~            DEL_MARKER		EQU	$E5
  48++9C9A ~
  49++9C9A ~
  50++9C9A ~            ;Extension structure (directory entry)
  51++9C9A ~            EXT_DEL_FLAG	EQU	0
  52++9C9A ~            EXT_NAME		EQU 1
  53++9C9A ~            EXT_IDX			EQU 12
  54++9C9A ~            EXT_S1			EQU 13
  55++9C9A ~            EXT_S2			EQU 14
  56++9C9A ~            EXT_RC			EQU	15
  57++9C9A ~            EXT_AU0			EQU	16
  58++9C9A ~            EXT_AU1			EQU	18
  59++9C9A ~            EXT_AU2			EQU	20
  60++9C9A ~            EXT_AU3			EQU	22
  61++9C9A ~            EXT_AU4			EQU	24
  62++9C9A ~            EXT_AU5			EQU	26
  63++9C9A ~            EXT_AU6			EQU	28
  64++9C9A ~            EXT_AU7			EQU	30
  65++9C9A ~            EXT_SIZE		EQU 32
  66++9C9A ~
  67++9C9A ~            ;FCB structure
  68++9C9A ~            FCB_DRIVE		EQU 0
  69++9C9A ~            FCB_NAME		EQU EXT_NAME
  70++9C9A ~            FCB_EX_IDX		EQU EXT_IDX
  71++9C9A ~            FCB_S1			EQU EXT_S1
  72++9C9A ~            FCB_S2			EQU EXT_S2
  73++9C9A ~            FCB_RC			EQU	EXT_RC
  74++9C9A ~            FCB_AU			EQU	EXT_AU0
  75++9C9A ~            FCB_CR			EQU	32
  76++9C9A ~            FCB_R0			EQU 33
  77++9C9A ~            FCB_R1			EQU 34
  78++9C9A ~            FCB_R2			EQU 35
  79++9C9A ~            FCB_SIZE		EQU 36
  80++9C9A ~
  81++9C9A ~
  82++9C9A ~
  83++9C9A ~            ;System variables for disk
  84++9C9A ~            DSTR1			EQU	$5CD6		;drive
  85++9C9A ~            FSTR1			EQU	$5CDC		;file name
  86++9C9A ~            NSTR1			EQU	$5CDA		;name length
  87++9C9A ~            HD11			EQU	$5CED		;BDOS argument
  88++9C9A ~            COPIES			EQU	$5CEF		;BDOS function
  89++9C9A ~
  90++9C9A ~            ERRSP			EQU $5C3D
  91++9C9A ~            ERRNR			EQU $5C3A
  92++9C9A ~            ERRMSG			EQU	$0260
  93++9C9A ~
  94++9C9A ~            PROG			EQU $5C53
  95++9C9A ~            VARS			EQU	$5C4B
  96++9C9A ~            STKEND			EQU	$5C65
  97++9C9A ~
  98++9C9A ~            PRN_BUF			EQU	23296
  99++9C9A ~
 100++9C9A ~            STR_MSG_BASIC	EQU	$1539
 101++9C9A ~            STR_MSG_BASIC_LEN EQU 32
 102++9C9A ~            STR_MSG_IF1_2000	EQU $27F0
 103++9C9A ~            STR_MSG_IF1_91		EQU $23F0
 104++9C9A ~            STR_MSG_IF1_LEN EQU 31
 105++9C9A ~
 106++9C9A ~            REPDEL			EQU	23561
 107++9C9A ~            REPPER			EQU	23562
 108++9C9A ~            PIP				EQU	23609
 109++9C9A ~
 110++9C9A ~
 111++9C9A ~            ;RWTS routine commands
 112++9C9A ~            RWTS_CMD_POS	EQU	0			;position head
 113++9C9A ~            RWTS_CMD_READ	EQU	1			;read sector
 114++9C9A ~            RWTS_CMD_WRITE	EQU	2			;write sector
 115++9C9A ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 116++9C9A ~
 117++9C9A ~
 118++9C9A ~            ;File name stuff
 119++9C9A ~            NAMELEN			EQU	11			;name length
 120++9C9A ~            RO_POS			EQU	8			;read-only attribute position in name
 121++9C9A ~            SYS_POS			EQU	9			;system attribute position in name
 122++9C9A ~
 123++9C9A ~            ;File types (first byte in header)
 124++9C9A ~            PROG_TYPE		EQU	0			;program
 125++9C9A ~            NUMB_TYPE		EQU	1			;number array
 126++9C9A ~            CHAR_TYPE		EQU	2			;char array
 127++9C9A ~            BYTE_TYPE		EQU	3			;bytes
 128++9C9A ~            TEXT_TYPE		EQU	4			;text, >= 4
 129++9C9A ~
 130++9C9A ~            ;File header offsets
 131++9C9A ~            HDR_TYPE		EQU	0
 132++9C9A ~            HDR_LEN			EQU 1
 133++9C9A ~            HDR_ADDR		EQU 3
 134++9C9A ~            HDR_PLEN		EQU	5
 135++9C9A ~            HDR_LINE		EQU 7
 136++9C9A ~            HDR_SZ			EQU	9
 137++9C9A ~
 138++9C9A ~            ;BASIC disk channel structure
 139++9C9A ~            CH_RW_FLAG		EQU 11
 140++9C9A ~            CH_FCB			EQU	12
 141++9C9A ~            CH_DATA			EQU	50
 142++9C9A ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 143++9C9A ~
 144++9C9A ~            CACHE_NAME		EQU	0					;11B
 145++9C9A ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 146++9C9A ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 147++9C9A ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 148++9C9A ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 149++9C9A ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 150++9C9A ~
 151++9C9A ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 152++9C9A ~
 153++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 154++9C9A ~            IF1Init:
 155++9C9A ~            	rst		08
 156++9C9A ~            	defb	49		;create system variables
 157++9C9A ~            	ret
 158++9C9A ~
 159++9C9A ~            ;ReadWriteTrackSector
 160++9C9A ~            ;A=command: 0, 1, 2, 4
 161++9C9A ~            RWTS:
 162++9C9A ~            	ld (RWTSCmd), a
 163++9C9A ~            	ld hl, RWTSParams
 164++9C9A ~            	ld (HD11), hl
 165++9C9A ~            	rst 08
 166++9C9A ~            	DEFB 58
 167++9C9A ~            	ret
 168++9C9A ~
 169++9C9A ~
 170++9C9A ~            ;D = sector, E = track
 171++9C9A ~            ;HL = dma
 172++9C9A ~            ReadOneDiskSector:
 173++9C9A ~            	ld (RWTSDMA), hl
 174++9C9A ~            	ld (RWTSTrack), de
 175++9C9A ~            	;ld (RWTSDrive), a
 176++9C9A ~            	ld a, RWTS_CMD_READ
 177++9C9A ~            	jr	RWTS
 178++9C9A ~
 179++9C9A ~            ;D = sector, E = track
 180++9C9A ~            ;HL = dma
 181++9C9A ~            WriteOneDiskSector:
 182++9C9A ~            	ld (RWTSDMA), hl
 183++9C9A ~            	ld (RWTSTrack), de
 184++9C9A ~            	;ld (RWTSDrive), a
 185++9C9A ~            	ld a, RWTS_CMD_WRITE
 186++9C9A ~            	jr	RWTS
 187++9C9A ~
 188++9C9A ~            FormatDisk:
 189++9C9A ~            	ld		hl, DataBuf
 190++9C9A ~            	ld		(hl), DEL_MARKER
 191++9C9A ~            	ld 		(RWTSDMA), hl
 192++9C9A ~            	ld 		a, RWTS_CMD_FMT
 193++9C9A ~            	call	RWTS
 194++9C9A ~            	ld		a, (RWTSRes)
 195++9C9A ~            	ret
 196++9C9A ~
 197++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 198++9C9A ~
 199++9C9A ~            ;Allocation unit no. to track/sector
 200++9C9A ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 201++9C9A ~            ;IN:  HL=alloc. unit no.
 202++9C9A ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 203++9C9A ~            AU2TS:
 204++9C9A ~            	ld c, SPT/SPAL
 205++9C9A ~            	call Div					;A = sector
 206++9C9A ~            	push af
 207++9C9A ~            		/*
 208++9C9A ~            		ld c, HEAD_CNT
 209++9C9A ~            		call Div				;L = track, A = head (0 or 1)
 210++9C9A ~            		*/
 211++9C9A ~            		xor a
 212++9C9A ~            		rr h
 213++9C9A ~            		rr l
 214++9C9A ~            		rr a
 215++9C9A ~
 216++9C9A ~            		ld c, l
 217++9C9A ~            		ld b, 0
 218++9C9A ~            		or a
 219++9C9A ~            		jr z, Track0
 220++9C9A ~            		ld b, SPT
 221++9C9A ~            Track0:
 222++9C9A ~            	pop af
 223++9C9A ~            	or a
 224++9C9A ~            	jr z, FirstAU
 225++9C9A ~            	ld a, SPAL
 226++9C9A ~            FirstAU:
 227++9C9A ~            	add a, b
 228++9C9A ~            	ld  b, a
 229++9C9A ~            	ret
 230++9C9A ~
 231++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 232++9C9A ~
 233++9C9A ~            ;Checks the allocation units number used in extension
 234++9C9A ~            ;IN:	IX = extension addr
 235++9C9A ~            ;OUT:	B = no. of allocation units used
 236++9C9A ~            ;		C = no. of records used in ext.
 237++9C9A ~            ;		HL = first alloc. unit no.
 238++9C9A ~            ;		DE = last alloc. unit no.
 239++9C9A ~            CheckExtAlloc:
 240++9C9A ~            	push ix
 241++9C9A ~            		ld bc, EXT_RC
 242++9C9A ~            		add ix, bc
 243++9C9A ~            		ld c, (ix)			;save rec. no.
 244++9C9A ~            		inc ix
 245++9C9A ~            		ld l, (ix)
 246++9C9A ~            		ld h, (ix + 1)
 247++9C9A ~            		ld b, EXT_AU_CNT
 248++9C9A ~            CheckAU:
 249++9C9A ~            		ld a, (ix)
 250++9C9A ~            		or (ix + 1)
 251++9C9A ~            		jr z, CheckAUEnd
 252++9C9A ~            		ld e, (ix)
 253++9C9A ~            		ld d, (ix + 1)
 254++9C9A ~            		inc ix
 255++9C9A ~            		inc ix
 256++9C9A ~            		djnz CheckAU
 257++9C9A ~            CheckAUEnd:
 258++9C9A ~            		ld a, EXT_AU_CNT
 259++9C9A ~            		sub b
 260++9C9A ~            		ld b, a
 261++9C9A ~            	pop ix
 262++9C9A ~            	ret
 263++9C9A ~
 264++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 265++9C9A ~
 266++9C9A ~            ;Input: TrackBuffer
 267++9C9A ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 268++9C9A ~            ReadUsedBlocksList:
 269++9C9A ~            	ld		ix, TrackBuf			;source buffer
 270++9C9A ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 271++9C9A ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 272++9C9A ~            	ld		de, 2					;counter of used blocks, start with 2
 273++9C9A ~            	ld		(hl), e
 274++9C9A ~            	inc		hl
 275++9C9A ~            	ld		(hl), d
 276++9C9A ~            	inc		hl
 277++9C9A ~
 278++9C9A ~            	;Add blocks 0 and 1 for directory
 279++9C9A ~            	ld		de, 0
 280++9C9A ~            	ld		(hl), e
 281++9C9A ~            	inc		hl
 282++9C9A ~            	ld		(hl), d
 283++9C9A ~            	inc		hl
 284++9C9A ~
 285++9C9A ~            	inc		de
 286++9C9A ~            	ld		(hl), e
 287++9C9A ~            	inc		hl
 288++9C9A ~            	ld		(hl), d
 289++9C9A ~            	inc		hl
 290++9C9A ~
 291++9C9A ~            ReadUsedBlocksLoop:
 292++9C9A ~            	xor		a
 293++9C9A ~            	cp		(ix)
 294++9C9A ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 295++9C9A ~
 296++9C9A ~            	push	ix
 297++9C9A ~            	push	bc
 298++9C9A ~            		ld		b, EXT_AU_CNT
 299++9C9A ~            		ld		de, EXT_AU0
 300++9C9A ~            		add		ix, de
 301++9C9A ~
 302++9C9A ~            ReadUsedBlocksLoop2:
 303++9C9A ~            		ld		e, (ix)
 304++9C9A ~            		ld		d, (ix+1)
 305++9C9A ~            		ld		a, e
 306++9C9A ~            		or		d
 307++9C9A ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 308++9C9A ~
 309++9C9A ~            		ld		(hl), e
 310++9C9A ~            		inc		hl
 311++9C9A ~            		ld		(hl), d
 312++9C9A ~            		inc		hl
 313++9C9A ~
 314++9C9A ~            		inc		ix
 315++9C9A ~            		inc		ix
 316++9C9A ~
 317++9C9A ~            		ld		de, (UsedBlockListCnt)
 318++9C9A ~            		inc		de
 319++9C9A ~            		ld		(UsedBlockListCnt), de
 320++9C9A ~
 321++9C9A ~            		djnz	ReadUsedBlocksLoop2
 322++9C9A ~
 323++9C9A ~
 324++9C9A ~            ReadUsedBlocksSkip:
 325++9C9A ~            	pop		bc
 326++9C9A ~            	pop		ix
 327++9C9A ~            ReadUsedBlocksSkip2:
 328++9C9A ~            	ld		de, EXT_SZ
 329++9C9A ~            	add		ix, de
 330++9C9A ~
 331++9C9A ~            	dec		bc
 332++9C9A ~            	ld		a, b
 333++9C9A ~            	or		c
 334++9C9A ~            	jr		nz, ReadUsedBlocksLoop
 335++9C9A ~
 336++9C9A ~            	ret
 337++9C9A ~
 338++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 339++9C9A ~            ;Reads 8 sectors for an AU
 340++9C9A ~            ;HL = block number, DE = destination buffer
 341++9C9A ~            ReadFSBlock:
 342++9C9A ~            	push	de
 343++9C9A ~            		call	AU2TS		;B=sector, C=track
 344++9C9A ~            	pop		hl				;HL=dest
 345++9C9A ~
 346++9C9A ~            	ld		d, b
 347++9C9A ~            	ld		e, c
 348++9C9A ~            	ld		b, SPAL
 349++9C9A ~
 350++9C9A ~            ReadFSBlockLoop:
 351++9C9A ~            	call	ReadDiskSectors
 352++9C9A ~            	ret
 353++9C9A ~
 354++9C9A ~
 355++9C9A ~            ;Write 8 sectors for an AU
 356++9C9A ~            ;HL = block number, DE = source buffer
 357++9C9A ~            WriteFSBlock:
 358++9C9A ~            	push	de
 359++9C9A ~            		call	AU2TS		;B=sector, C=track
 360++9C9A ~            	pop		hl				;HL=dest
 361++9C9A ~
 362++9C9A ~            	ld		d, b
 363++9C9A ~            	ld		e, c
 364++9C9A ~            	ld		b, SPAL
 365++9C9A ~
 366++9C9A ~            WriteFSBlockLoop:
 367++9C9A ~            	call	WriteDiskSectors
 368++9C9A ~            	ret
 369++9C9A ~
 370++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 371++9C9A ~            ;Copies the allocated blocks from one disk to another, dual drive.
 372++9C9A ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 373++9C9A ~            CopyDisk:
 374++9C9A ~            	;Get list of used blocks in current disk, max 632 bytes
 375++9C9A ~            	call	ReadUsedBlocksList
 376++9C9A ~            	ld		ix, UsedBlockListBlk
 377++9C9A ~
 378++9C9A ~            CopyDiskLoop:
 379++9C9A ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 380++9C9A ~            	ld		de, MsgBlocksLeft
 381++9C9A ~            	call	Byte2Txt
 382++9C9A ~            	ld		hl, MsgBlocksLeft
 383++9C9A ~            	ld		de, LST_LINE_MSG + 1 << 8
 384++9C9A ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 385++9C9A ~            	call	PrintStrClr
 386++9C9A ~
 387++9C9A ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 388++9C9A ~            	ld		hl, MAX_AU_RAM
 389++9C9A ~            	ld		bc, (UsedBlockListCnt)
 390++9C9A ~            	or		a
 391++9C9A ~            	sbc		hl, bc
 392++9C9A ~            	jr		nc, CopyDiskLoopRead
 393++9C9A ~            	ld		bc, MAX_AU_RAM
 394++9C9A ~
 395++9C9A ~            CopyDiskLoopRead:
 396++9C9A ~            	ld		b, c
 397++9C9A ~            	ld		de, CopyDiskBuf
 398++9C9A ~            	;save initial counter and initial block number array position
 399++9C9A ~            	push	bc
 400++9C9A ~            	push	ix
 401++9C9A ~
 402++9C9A ~            CopyDiskLoopReadLoop:
 403++9C9A ~            		ld		l, (ix)
 404++9C9A ~            		ld		h, (ix+1)
 405++9C9A ~            		inc		ix
 406++9C9A ~            		inc		ix
 407++9C9A ~
 408++9C9A ~            		push	de
 409++9C9A ~            		push	bc
 410++9C9A ~            			call	ReadFSBlock			;Stop on error or continue?
 411++9C9A ~            		pop		bc
 412++9C9A ~            		pop		de
 413++9C9A ~
 414++9C9A ~            		;+2048
 415++9C9A ~            		ld		a, d
 416++9C9A ~            		add		8
 417++9C9A ~            		ld		d, a
 418++9C9A ~
 419++9C9A ~            		djnz	CopyDiskLoopReadLoop
 420++9C9A ~
 421++9C9A ~            		;alternate drive
 422++9C9A ~            		ld		a, (RWTSDrive)
 423++9C9A ~            		xor		%11
 424++9C9A ~            		ld		(RWTSDrive), a
 425++9C9A ~
 426++9C9A ~            	;restore initial counter and initial block number array position
 427++9C9A ~            	pop		ix
 428++9C9A ~            	pop		bc
 429++9C9A ~            	ld		de, CopyDiskBuf
 430++9C9A ~            	push	bc
 431++9C9A ~
 432++9C9A ~            CopyDiskLoopWriteLoop:
 433++9C9A ~            		ld		l, (ix)
 434++9C9A ~            		ld		h, (ix+1)
 435++9C9A ~            		inc		ix
 436++9C9A ~            		inc		ix
 437++9C9A ~
 438++9C9A ~            		push	de
 439++9C9A ~            		push	bc
 440++9C9A ~            			call	WriteFSBlock		;Stop on error or continue?
 441++9C9A ~            		pop		bc
 442++9C9A ~            		pop		de
 443++9C9A ~
 444++9C9A ~            		;+2048
 445++9C9A ~            		ld		a, d
 446++9C9A ~            		add		8
 447++9C9A ~            		ld		d, a
 448++9C9A ~
 449++9C9A ~            		djnz	CopyDiskLoopWriteLoop
 450++9C9A ~
 451++9C9A ~            		;alternate drive again
 452++9C9A ~            		ld		a, (RWTSDrive)
 453++9C9A ~            		xor		%11
 454++9C9A ~            		ld		(RWTSDrive), a
 455++9C9A ~
 456++9C9A ~            	pop		bc
 457++9C9A ~            	ld		c, b
 458++9C9A ~            	ld		b, 0
 459++9C9A ~
 460++9C9A ~            	;Decrease number of blocks read by now.
 461++9C9A ~            	ld		hl, (UsedBlockListCnt)
 462++9C9A ~            	or		a
 463++9C9A ~            	sbc		hl, bc
 464++9C9A ~            	ld		(UsedBlockListCnt), hl
 465++9C9A ~
 466++9C9A ~            	ld		a, l
 467++9C9A ~            	or		h
 468++9C9A ~            	jp		nz, CopyDiskLoop
 469++9C9A ~
 470++9C9A ~            	ret
 471++9C9A ~
 472++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 473++9C9A ~            ;Copies the current disk blocks to COM port.
 474++9C9A ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 475++9C9A ~            CopyDiskToCOM:
 476++9C9A ~            	;Get list of used blocks in current disk, max 632 bytes
 477++9C9A ~            	call	ReadUsedBlocksList
 478++9C9A ~
 479++9C9A ~            	;Send block count and block indexes
 480++9C9A ~            	ld		hl, (UsedBlockListCnt)
 481++9C9A ~            	add		hl, hl
 482++9C9A ~            	inc		hl
 483++9C9A ~            	inc		hl
 484++9C9A ~            	ld		b, h
 485++9C9A ~            	ld		c, l
 486++9C9A ~            	ld		hl, UsedBlockListCnt
 487++9C9A ~            	call	SERTB
 488++9C9A ~
 489++9C9A ~            	ld		ix, UsedBlockListBlk
 490++9C9A ~
 491++9C9A ~            CopyDiskToCOMLoop:
 492++9C9A ~            	;Print block count left
 493++9C9A ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 494++9C9A ~            	ld		de, MsgBlocksLeft
 495++9C9A ~            	call	Byte2Txt
 496++9C9A ~            	ld		hl, MsgBlocksLeft
 497++9C9A ~            	ld		de, LST_LINE_MSG + 1 << 8
 498++9C9A ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 499++9C9A ~            	call	PrintStrClr
 500++9C9A ~
 501++9C9A ~            	;Read block into buffer
 502++9C9A ~            	ld		l, (ix)
 503++9C9A ~            	ld		h, (ix+1)
 504++9C9A ~            	ld		de, CopyDiskBuf
 505++9C9A ~            	push	ix
 506++9C9A ~            		call	ReadFSBlock
 507++9C9A ~            	pop		ix
 508++9C9A ~            	inc		ix
 509++9C9A ~            	inc		ix
 510++9C9A ~
 511++9C9A ~            	;Send block buffer
 512++9C9A ~            	ld		hl, CopyDiskBuf
 513++9C9A ~            	ld		bc, AU_SZ
 514++9C9A ~            	call	SERTB
 515++9C9A ~
 516++9C9A ~            	ld		bc, (UsedBlockListCnt)
 517++9C9A ~            	dec		bc
 518++9C9A ~            	ld		(UsedBlockListCnt), bc
 519++9C9A ~
 520++9C9A ~            	push	ix
 521++9C9A ~            		call	KbdHit
 522++9C9A ~            	pop		ix
 523++9C9A ~            	ret		c
 524++9C9A ~
 525++9C9A ~            	ld		a, b
 526++9C9A ~            	or		c
 527++9C9A ~            	jr		nz, CopyDiskToCOMLoop
 528++9C9A ~
 529++9C9A ~            	ret
 530++9C9A ~
 531++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 532++9C9A ~            CopyDiskFromCOM:
 533++9C9A ~            	;Receive block count.
 534++9C9A ~            	ld		hl, UsedBlockListCnt
 535++9C9A ~            	ld		bc, 2
 536++9C9A ~            	ld		e, 0
 537++9C9A ~            	call	SERRB
 538++9C9A ~
 539++9C9A ~            	;Receive block indexes.
 540++9C9A ~            	ld		hl, (UsedBlockListCnt)
 541++9C9A ~            	add		hl, hl
 542++9C9A ~            	ld		b, h
 543++9C9A ~            	ld		c, l
 544++9C9A ~            	ld		hl, UsedBlockListBlk
 545++9C9A ~            	ld		e, 0
 546++9C9A ~            	call	SERRB
 547++9C9A ~
 548++9C9A ~            	;Read each block by index and write to disk
 549++9C9A ~            	ld		ix, UsedBlockListBlk
 550++9C9A ~
 551++9C9A ~            CopyDiskFromCOMLoop:
 552++9C9A ~            	;Print block count left
 553++9C9A ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 554++9C9A ~            	ld		de, MsgBlocksLeft
 555++9C9A ~            	call	Byte2Txt
 556++9C9A ~            	ld		hl, MsgBlocksLeft
 557++9C9A ~            	ld		de, LST_LINE_MSG + 1 << 8
 558++9C9A ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 559++9C9A ~            	call	PrintStrClr
 560++9C9A ~
 561++9C9A ~            	;Read block buffer
 562++9C9A ~            	ld		hl, CopyDiskBuf
 563++9C9A ~            	ld		bc, AU_SZ
 564++9C9A ~            	ld		e, 0
 565++9C9A ~            	call	SERRB
 566++9C9A ~
 567++9C9A ~            	;Write block to disk
 568++9C9A ~            	ld		l, (ix)
 569++9C9A ~            	ld		h, (ix+1)
 570++9C9A ~            	ld		de, CopyDiskBuf
 571++9C9A ~            	push	ix
 572++9C9A ~            		call	WriteFSBlock			;Stop on error or continue?
 573++9C9A ~            	pop		ix
 574++9C9A ~            	inc		ix
 575++9C9A ~            	inc		ix
 576++9C9A ~
 577++9C9A ~            	ld		bc, (UsedBlockListCnt)
 578++9C9A ~            	dec		bc
 579++9C9A ~            	ld		(UsedBlockListCnt), bc
 580++9C9A ~
 581++9C9A ~            	push	ix
 582++9C9A ~            		call	KbdHit
 583++9C9A ~            	pop		ix
 584++9C9A ~            	ret		c
 585++9C9A ~
 586++9C9A ~            	ld		a, b
 587++9C9A ~            	or		c
 588++9C9A ~            	jr		nz, CopyDiskFromCOMLoop
 589++9C9A ~            	ret
 590++9C9A ~
 591++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 592++9C9A ~
 593++9C9A ~            ;Compare string at HL with the one at DE, max length B
 594++9C9A ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 595++9C9A ~            ;OUT: z flag, set = match, reset = mismatch
 596++9C9A ~            StrCmp:
 597++9C9A ~            	push hl
 598++9C9A ~            	push de
 599++9C9A ~            Compare:
 600++9C9A ~            		ld a, (de)
 601++9C9A ~            		cp (hl)
 602++9C9A ~            		jr nz, MisMatch
 603++9C9A ~            		inc hl
 604++9C9A ~            		inc de
 605++9C9A ~            		djnz Compare
 606++9C9A ~            MisMatch:
 607++9C9A ~            	pop de
 608++9C9A ~            	pop hl
 609++9C9A ~            	ret
 610++9C9A ~
 611++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 612++9C9A ~
 613++9C9A ~            ;Read a file into a buffer, sector by sector.
 614++9C9A ~            ;It's relocatable, to moved and be used when loading a CODE block.
 615++9C9A ~            ;It's not using BDOS, but using similar calls provided by IF1.
 616++9C9A ~            ;In: HL = Name address, DE = buffer
 617++9C9A ~            IF1FileLoad:
 618++9C9A ~            	push	de
 619++9C9A ~            		ld (FSTR1), hl
 620++9C9A ~            		ld h, 0
 621++9C9A ~            		ld a, (RWTSDrive)
 622++9C9A ~            		inc  a			;CP/M drive number to BASIC drive number
 623++9C9A ~            		ld	l, a
 624++9C9A ~            		ld (DSTR1), hl
 625++9C9A ~            		ld l,NAMELEN
 626++9C9A ~            		ld (NSTR1), hl
 627++9C9A ~            		rst 08
 628++9C9A ~            		DEFB 51			;open disk channel
 629++9C9A ~
 630++9C9A ~            		rst		8
 631++9C9A ~            		defb	53		;read sector
 632++9C9A ~            	pop		de
 633++9C9A ~            	jr		nc, FileFree
 634++9C9A ~
 635++9C9A ~            	ld		a, (ix + CH_DATA)
 636++9C9A ~            	cp		TEXT_TYPE
 637++9C9A ~            	jr		nc, FileLoadNoHeader
 638++9C9A ~
 639++9C9A ~            FileLoadHeader:
 640++9C9A ~            	push	ix
 641++9C9A ~            	pop		hl
 642++9C9A ~            	ld		bc, CH_DATA + HDR_SZ
 643++9C9A ~            	add		hl, bc
 644++9C9A ~            	ld		bc, SECT_SZ - HDR_SZ
 645++9C9A ~            	ldir
 646++9C9A ~
 647++9C9A ~            FileReadLoop:
 648++9C9A ~            	push	de
 649++9C9A ~            		rst		8
 650++9C9A ~            		defb	53		;read sector
 651++9C9A ~            	pop		de
 652++9C9A ~            	jr		nc, FileFree
 653++9C9A ~
 654++9C9A ~            FileLoadNoHeader:
 655++9C9A ~            	push	ix
 656++9C9A ~            	pop		hl
 657++9C9A ~            	ld		bc, CH_DATA
 658++9C9A ~            	add		hl, bc
 659++9C9A ~            	ld		bc, SECT_SZ
 660++9C9A ~            	ldir
 661++9C9A ~            	jr		FileReadLoop
 662++9C9A ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 663++9C9A ~            IF1FileLoadEnd:
 664++9C9A ~
 665++9C9A ~            FileFree:
 666++9C9A ~            	push	de
 667++9C9A ~            	rst		8
 668++9C9A ~            	defb	56			;close channel (52) or detroy channel (56)
 669++9C9A ~            	pop		de
 670++9C9A ~            	ret
 671++9C9A ~
 672++9C9A ~
 673++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 674++9C9A ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 675++9C9A ~            ;Out: A = error code, 0=OK
 676++9C9A ~            ReadDiskSectors:
 677++9C9A ~            	push bc
 678++9C9A ~            		push hl
 679++9C9A ~            			push de
 680++9C9A ~            				call ReadOneDiskSector
 681++9C9A ~            			pop de
 682++9C9A ~            		pop hl
 683++9C9A ~
 684++9C9A ~            		inc d
 685++9C9A ~            		inc h
 686++9C9A ~            	pop bc
 687++9C9A ~
 688++9C9A ~            	ld	a, (RWTSRes)
 689++9C9A ~            	or	a
 690++9C9A ~            	ret nz
 691++9C9A ~
 692++9C9A ~            	djnz ReadDiskSectors
 693++9C9A ~            	ret
 694++9C9A ~
 695++9C9A ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 696++9C9A ~            ;Out: A = error code, 0=OK
 697++9C9A ~            WriteDiskSectors:
 698++9C9A ~            	push bc
 699++9C9A ~            		push hl
 700++9C9A ~            			push de
 701++9C9A ~            				call WriteOneDiskSector
 702++9C9A ~            			pop de
 703++9C9A ~            		pop hl
 704++9C9A ~
 705++9C9A ~            		inc d
 706++9C9A ~            		inc h
 707++9C9A ~            	pop bc
 708++9C9A ~
 709++9C9A ~            	ld	a, (RWTSRes)
 710++9C9A ~            	or	a
 711++9C9A ~            	ret nz
 712++9C9A ~
 713++9C9A ~            	djnz WriteDiskSectors
 714++9C9A ~            	ret
 715++9C9A ~
 716++9C9A ~
 717++9C9A ~            ;Reads disk catalog
 718++9C9A ~            ReadCatalogTrack:
 719++9C9A ~            	ld hl, TrackBuf
 720++9C9A ~            	ld de, 0
 721++9C9A ~            	ld b, SPT
 722++9C9A ~
 723++9C9A ~            	call ReadDiskSectors
 724++9C9A ~            	or   a
 725++9C9A ~            	ret  nz
 726++9C9A ~
 727++9C9A ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 728++9C9A ~            	push  af
 729++9C9A ~            		ld  a, (RWTSDrive)
 730++9C9A ~            		call BDOSSelectDisk
 731++9C9A ~            		call BDOSInit
 732++9C9A ~            	pop   af
 733++9C9A ~            	ret
 734++9C9A ~
 735++9C9A ~
 736++9C9A ~
 737++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 738++9C9A ~
 739++9C9A ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 740++9C9A ~            FindCache:
 741++9C9A ~            	ld		b, NAMELEN
 742++9C9A ~            	call	StrCmp			;find the file to wich this extension belongs
 743++9C9A ~            	ret		z
 744++9C9A ~
 745++9C9A ~            	dec		c
 746++9C9A ~            	jr		nz, CacheNotFinished
 747++9C9A ~            	or		c
 748++9C9A ~            	ret
 749++9C9A ~
 750++9C9A ~            CacheNotFinished:
 751++9C9A ~            	ld		bc, CACHE_SZ
 752++9C9A ~            	add		hl, bc			;to the next cache line
 753++9C9A ~            	jr		FindCache
 754++9C9A ~
 755++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 756++9C9A ~
 757++9C9A ~            	;ld		ix, (SelFileCache)
 758++9C9A ~            ReadFileHeader:
 759++9C9A ~            	ld		a, (ix + CACHE_FLAG)
 760++9C9A ~            	or		a
 761++9C9A ~            	ret		nz				;return if already read
 762++9C9A ~
 763++9C9A ~            	ld		l, (ix + CACHE_FIRST_AU)
 764++9C9A ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 765++9C9A ~            	ld		a, h
 766++9C9A ~            	or		l
 767++9C9A ~            	jr		z, ReadHeaderEnd
 768++9C9A ~
 769++9C9A ~            	call	AU2TS
 770++9C9A ~            	ld		d, b
 771++9C9A ~            	ld		e, c
 772++9C9A ~            	ld		hl, DataBuf
 773++9C9A ~            	push	ix
 774++9C9A ~            	push	ix
 775++9C9A ~            		call	ReadOneDiskSector
 776++9C9A ~            	pop		hl
 777++9C9A ~            	pop		ix
 778++9C9A ~
 779++9C9A ~            	push	hl
 780++9C9A ~            		ld		hl, DataBuf
 781++9C9A ~            		call	IsFileHeaderValid
 782++9C9A ~            	pop		hl
 783++9C9A ~            	or		a
 784++9C9A ~            	jr		z, ReadFileHeaderIsTextFile
 785++9C9A ~
 786++9C9A ~            	ld		bc, CACHE_HDR
 787++9C9A ~            	add		hl, bc
 788++9C9A ~            	ex		hl, de
 789++9C9A ~            	ld		hl, DataBuf
 790++9C9A ~            	ld		bc, HDR_SZ
 791++9C9A ~            	ldir
 792++9C9A ~
 793++9C9A ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 794++9C9A ~            	ld		a, BYTE_TYPE
 795++9C9A ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 796++9C9A ~            	jr		nc, ReadHeaderEnd
 797++9C9A ~
 798++9C9A ~            ReadFileHeaderIsTextFile:
 799++9C9A ~            	push	ix
 800++9C9A ~            	push	ix
 801++9C9A ~            	pop		hl
 802++9C9A ~            		call	GetFileSize
 803++9C9A ~            	pop		ix
 804++9C9A ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 805++9C9A ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 806++9C9A ~            	ld		a, TEXT_TYPE
 807++9C9A ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 808++9C9A ~
 809++9C9A ~            ReadHeaderEnd:
 810++9C9A ~            	inc		(ix + CACHE_FLAG)
 811++9C9A ~            	ret
 812++9C9A ~
 813++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 814++9C9A ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 815++9C9A ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 816++9C9A ~            ;In: HL = header
 817++9C9A ~            ;Out: A > 0 if valid
 818++9C9A ~            IsFileHeaderValid:
 819++9C9A ~            	IFUSED
 820++9C9A ~            	xor		a
 821++9C9A ~            	ld		b, HDR_SZ
 822++9C9A ~            IsFileHeaderValidLoop:
 823++9C9A ~            	or		(hl)
 824++9C9A ~            	inc		hl
 825++9C9A ~            	djnz	IsFileHeaderValidLoop
 826++9C9A ~
 827++9C9A ~            	ret
 828++9C9A ~            	ENDIF
 829++9C9A ~
 830++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 831++9C9A ~
 832++9C9A ~            ;IN: HL = address from IF1 to call
 833++9C9A ~            IF1Call:
 834++9C9A ~            	LD   (HD11), HL
 835++9C9A ~            	RST  8
 836++9C9A ~            	DEFB 50
 837++9C9A ~            	RET
 838++9C9A ~
 839++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 840++9C9A ~
 841++9C9A ~            ;Load a program from disk
 842++9C9A ~            ;IN: HL = file name addr
 843++9C9A ~            LoadProgram:
 844++9C9A ~            	LD   (FSTR1), HL
 845++9C9A ~            	LD   H, 0
 846++9C9A ~            	LD   L, NAMELEN
 847++9C9A ~            	LD   (NSTR1), HL
 848++9C9A ~            	LD	 A, (RWTSDrive)
 849++9C9A ~            	INC  A					;Adapt for BASIC drive number
 850++9C9A ~            	LD   L, A
 851++9C9A ~            	LD   (DSTR1), HL
 852++9C9A ~            	LD   HL, LOAD_ADDR
 853++9C9A ~            	CALL IF1Call
 854++9C9A ~            	RET
 855++9C9A ~
 856++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 857++9C9A ~
 858++9C9A ~            SetFastKeys:
 859++9C9A ~            	ld		hl, REPDEL
 860++9C9A ~            	ld		de, (1 << 8) | 15
 861++9C9A ~            	ld		(hl), de
 862++9C9A ~
 863++9C9A ~            	ret
 864++9C9A ~
 865++9C9A ~
 866++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 867++9C9A ~            ;Reads the error message string from IF1 ROM.
 868++9C9A ~            GetErrMsg:
 869++9C9A ~            	inc		a
 870++9C9A ~            	ex		af, af'
 871++9C9A ~
 872++9C9A ~            	ld		hl, IF1Paged			;page-in IF1
 873++9C9A ~            	jp		IF1Call
 874++9C9A ~
 875++9C9A ~            IF1Paged:
 876++9C9A ~            	ld		hl, ERRMSG
 877++9C9A ~            	ex		af, af'
 878++9C9A ~            	or		a
 879++9C9A ~            	jr		z, SaveMsg
 880++9C9A ~
 881++9C9A ~            	ld		b, 0
 882++9C9A ~            SearchMsgEnd:
 883++9C9A ~            	bit		7, (hl)
 884++9C9A ~            	inc		hl
 885++9C9A ~            	jr		z, SearchMsgEnd
 886++9C9A ~
 887++9C9A ~            	inc		b
 888++9C9A ~            	cp		b
 889++9C9A ~            	jr		nz, SearchMsgEnd
 890++9C9A ~
 891++9C9A ~            SaveMsg:
 892++9C9A ~            	ld		de, DataBuf
 893++9C9A ~            CopyMsg:
 894++9C9A ~            	ld		a, (hl)
 895++9C9A ~            	bit		7, a
 896++9C9A ~            	ld		(de), a
 897++9C9A ~            	inc		hl
 898++9C9A ~            	inc		de
 899++9C9A ~            	jr		z, CopyMsg
 900++9C9A ~
 901++9C9A ~            	ret
 902++9C9A ~
 903++9C9A ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 904++9C9A ~
 905++9C9A ~            ;RWTS routine I/O block
 906++9C9A ~            RWTSParams:
 907++9C9A ~            RWTSBlockType	DEFB	1							;?
 908++9C9A ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 909++9C9A ~            RWTSVolNo		DEFB	0							;?
 910++9C9A ~            RWTSTrack		DEFB	0
 911++9C9A ~            RWTSSector		DEFB	0
 912++9C9A ~            RWTSDMA			DEFW	0
 913++9C9A ~            RWTSExtBuf		DEFW	$2932
 914++9C9A ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 915++9C9A ~            	IFDEF _REAL_HW_
 916++9C9A ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 917++9C9A ~            	ELSE
 918++9C9A ~            RWTSPrmTbl		DEFW	$1f2a
 919++9C9A ~            	ENDIF
 920++9C9A ~            RWTSCmd			DEFB	RWTS_CMD_READ
 921++9C9A ~            ;Results
 922++9C9A ~            RWTSRes			DEFB	0
 923++9C9A ~            RWTSResVolNo	DEFB	0
 924++9C9A ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 925++9C9A ~
 926++9C9A ~            ;Param. table, usualy found in ROM.
 927++9C9A ~            	IFDEF _REAL_HW_
 928++9C9A ~            BasPrmTbl:
 929++9C9A ~            PrmDevType		DEFB	$01		;$01
 930++9C9A ~            PrmStepRate		DEFB	$01		;$0D	(milisec)
 931++9C9A ~            PrmHeadLoad		DEFB	$01		;$23	(milisec)
 932++9C9A ~            PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 933++9C9A ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 934++9C9A ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 935++9C9A ~            	ENDIF
 936++9C9A ~
 937++9C9A              	endif
# file closed: if1.asm
  15+ 9C9A
  16+ 9C9A              BDOSInit:
  17+ 9C9A AF           	xor		a
  18+ 9C9B 18 45        	jr		BDOS
  19+ 9C9D
  20+ 9C9D
  21+ 9C9D              ;IN: A = Drive to select
  22+ 9C9D              BDOSSelectDisk:
  23+ 9C9D              	IFUSED
  24+ 9C9D DD 6F        	ld		ixl, a
  25+ 9C9F DD 26 00     	ld		ixh, 0
  26+ 9CA2 3E 01        	ld		a, 1
  27+ 9CA4 18 3C        	jr		BDOS
  28+ 9CA6              	ENDIF
  29+ 9CA6
  30+ 9CA6
  31+ 9CA6              BDOSMakeDiskRO:
  32+ 9CA6              	IFUSED
  33+ 9CA6 ~            	ld		a, 15
  34+ 9CA6 ~            	jr		BDOS
  35+ 9CA6              	ENDIF
  36+ 9CA6
  37+ 9CA6              ;Get Read Only flag
  38+ 9CA6              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 9CA6              BDOSGetDiskRO:
  40+ 9CA6              	IFUSED
  41+ 9CA6 ~            	ld	a, 16
  42+ 9CA6 ~            	jr	BDOS
  43+ 9CA6              	ENDIF
  44+ 9CA6
  45+ 9CA6              BDOSGetCurrentDisk:
  46+ 9CA6              	IFUSED
  47+ 9CA6 ~            	ld		a, 12
  48+ 9CA6 ~            	jr		BDOS
  49+ 9CA6              	ENDIF
  50+ 9CA6
  51+ 9CA6
  52+ 9CA6              ;Create a disk channel for BDOS access (does not open the file)
  53+ 9CA6              ;IN: HL=name addr, A=drive
  54+ 9CA6              ;OUT: IX=FCB
  55+ 9CA6              CreateChannel:
  56+ 9CA6 22 DC 5C     	ld (FSTR1), hl
  57+ 9CA9 26 00        	ld h,0
  58+ 9CAB 6F           	ld l,a
  59+ 9CAC 22 D6 5C     	ld (DSTR1), hl
  60+ 9CAF 2E 0B        	ld l,NAMELEN
  61+ 9CB1 22 DA 5C     	ld (NSTR1), hl
  62+ 9CB4 CF           	rst 08
  63+ 9CB5 37           	DEFB 55
  64+ 9CB6 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 9CB9 DD 09        	add ix, bc
  66+ 9CBB C9           	ret
  67+ 9CBC
  68+ 9CBC
  69+ 9CBC              ;Destroy a BDOS channel
  70+ 9CBC              ;IN: IX=FCB
  71+ 9CBC              DestroyChannel:
  72+ 9CBC C5           	push bc
  73+ 9CBD 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 9CC0 DD 09        	add ix, bc
  75+ 9CC2 CF           	rst 08
  76+ 9CC3 38           	DEFB 56
  77+ 9CC4 C1           	pop bc
  78+ 9CC5 C9           	ret
  79+ 9CC6
  80+ 9CC6
  81+ 9CC6              ;Input: IX=FCB
  82+ 9CC6              BDOSCreateFile:
  83+ 9CC6 3E 09        	ld	a, 9
  84+ 9CC8 18 18        	jr	BDOS
  85+ 9CCA
  86+ 9CCA              ;Input: IX=FCB
  87+ 9CCA              BDOSOpenFile:
  88+ 9CCA 3E 02        	ld	a, 2
  89+ 9CCC 18 14        	jr	BDOS
  90+ 9CCE
  91+ 9CCE              ;IN: IX=FCB
  92+ 9CCE              BDOSCloseFile:
  93+ 9CCE 3E 03        	ld	a, 3
  94+ 9CD0 18 10        	jr	BDOS
  95+ 9CD2
  96+ 9CD2
  97+ 9CD2              ;0 OK,
  98+ 9CD2              ;1 end of file,
  99+ 9CD2              ;9 invalid FCB,
 100+ 9CD2              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 101+ 9CD2              ;11 (MP/M) unlocked file verification error,
 102+ 9CD2              ;0FFh hardware error.
 103+ 9CD2
 104+ 9CD2              ;IN: IX=FCB
 105+ 9CD2              BDOSReadFileBlockSeq:
 106+ 9CD2 3E 07        	ld	a, 7
 107+ 9CD4 18 0C        	jr	BDOS
 108+ 9CD6
 109+ 9CD6
 110+ 9CD6              ;0 OK,
 111+ 9CD6              ;1 directory full,
 112+ 9CD6              ;2 disc full,
 113+ 9CD6              ;8 (MP/M) record locked by another process,
 114+ 9CD6              ;9 invalid FCB,
 115+ 9CD6              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 116+ 9CD6              ;11 (MP/M) unlocked file verification error,
 117+ 9CD6              ;0FFh hardware error.
 118+ 9CD6
 119+ 9CD6              ;IN: IX=FCB
 120+ 9CD6              BDOSWriteFileBlockSeq:
 121+ 9CD6 3E 08        	ld	a, 8
 122+ 9CD8 18 08        	jr	BDOS
 123+ 9CDA
 124+ 9CDA
 125+ 9CDA              ;0 OK
 126+ 9CDA              ;1 Reading unwritten data
 127+ 9CDA              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 128+ 9CDA              ;6 Record number out of range
 129+ 9CDA              ;9 Invalid FCB
 130+ 9CDA              BDOSReadFileBlockRandom:
 131+ 9CDA 3E 12        	ld	a, 18
 132+ 9CDC 18 04        	jr	BDOS
 133+ 9CDE
 134+ 9CDE              ;0 OK
 135+ 9CDE              ;2 Disc full
 136+ 9CDE              ;3 Cannot close extent
 137+ 9CDE              ;5 Directory full
 138+ 9CDE              ;6 Record number out of range
 139+ 9CDE              ;8 Record is locked by another process (MP/M)
 140+ 9CDE              ;9 Invalid FCB
 141+ 9CDE              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 142+ 9CDE              BDOSWriteFileBlockRandom:
 143+ 9CDE 3E 13        	ld	a, 19
 144+ 9CE0 18 00        	jr	BDOS
 145+ 9CE2
 146+ 9CE2
 147+ 9CE2              ;Generic BDOS call
 148+ 9CE2              ;IX=arg, A=function
 149+ 9CE2              BDOS:
 150+ 9CE2 DD 22 ED 5C  	ld (HD11), ix
 151+ 9CE6 32 EF 5C     	ld (COPIES), a
 152+ 9CE9 CF           	rst 08
 153+ 9CEA 39           	DEFB 57
 154+ 9CEB C9           	ret
 155+ 9CEC
 156+ 9CEC              ;Set DMA address for BDOS
 157+ 9CEC              ;IX=DMA
 158+ 9CEC              BDOSSetDMA:
 159+ 9CEC 3E 0D        	ld a, 13
 160+ 9CEE 18 F2        	jr BDOS
 161+ 9CF0
 162+ 9CF0              ;In: IX=FCB
 163+ 9CF0              BDOSSetRandFilePtr:
 164+ 9CF0 3E 15        	ld	a, 21
 165+ 9CF2 18 EE        	jr	BDOS
 166+ 9CF4
 167+ 9CF4              ;In: HL=filename
 168+ 9CF4              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 169+ 9CF4              GetFileSize:
 170+ 9CF4              	IFUSED
 171+ 9CF4
 172+ 9CF4 3A 72 9C     	ld 		a, (RWTSDrive)
 173+ 9CF7 3C           	inc		a					;Convert to BASIC drive number: 1,2
 174+ 9CF8 CD A6 9C     	call	CreateChannel
 175+ 9CFB
 176+ 9CFB 3E 14        	ld		a, 20
 177+ 9CFD CD E2 9C     	call	BDOS
 178+ 9D00              	;inc		a
 179+ 9D00              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 180+ 9D00
 181+ 9D00 DD 6E 21     	ld		l, (ix + FCB_R0)
 182+ 9D03 DD 66 22     	ld		h, (ix + FCB_R1)
 183+ 9D06
 184+ 9D06              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 185+ 9D06 3E 01        	ld		a, 1
 186+ 9D08 BC           	cp		h
 187+ 9D09 30 05        	jr		nc, GetFileSizeOK
 188+ 9D0B 21 00 00     	ld		hl, 0
 189+ 9D0E 18 08        	jr		GetFileSizeEnd
 190+ 9D10
 191+ 9D10              GetFileSizeOK:
 192+ 9D10              	;*128 == 2^7
 193+ 9D10 06 07        	ld		b, 7
 194+ 9D12              GetFileSizeMul:
 195+ 9D12 CB 15        	rl		l
 196+ 9D14 CB 14        	rl		h
 197+ 9D16 10 FA        	djnz	GetFileSizeMul
 198+ 9D18
 199+ 9D18              GetFileSizeEnd:
 200+ 9D18 E5           	push	hl
 201+ 9D19 CD BC 9C     		call	DestroyChannel
 202+ 9D1C E1           	pop		hl
 203+ 9D1D
 204+ 9D1D C9           	ret
 205+ 9D1E              	ENDIF
 206+ 9D1E
 207+ 9D1E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 208+ 9D1E              ;HL=file name, A=drive
 209+ 9D1E              DeleteFile:
 210+ 9D1E CD A6 9C     	call	CreateChannel
 211+ 9D21
 212+ 9D21 3E 06        	ld		a, 6
 213+ 9D23 CD E2 9C     	call	BDOS
 214+ 9D26
 215+ 9D26 CD BC 9C     	call	DestroyChannel
 216+ 9D29 C9           	ret
 217+ 9D2A
 218+ 9D2A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 219+ 9D2A              ;Returns A > 0 if the file exists
 220+ 9D2A              ;HL=file name, A=drive
 221+ 9D2A              DoesFileExist:
 222+ 9D2A              	IFUSED
 223+ 9D2A CD A6 9C     	call	CreateChannel
 224+ 9D2D
 225+ 9D2D 3E 04        	ld		a, 4
 226+ 9D2F CD E2 9C     	call	BDOS
 227+ 9D32
 228+ 9D32 F5           	push	af
 229+ 9D33 CD BC 9C     		call	DestroyChannel
 230+ 9D36 F1           	pop		af
 231+ 9D37 C9           	ret
 232+ 9D38              	ENDIF
 233+ 9D38
 234+ 9D38              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 235+ 9D38              ;IN: E0 = RO, E1 = SYS, HL=filename
 236+ 9D38              ChangeFileAttrib:
 237+ 9D38 3A 72 9C     	ld 		a, (RWTSDrive)
 238+ 9D3B 3C           	inc		a					;Convert to BASIC drive number: 1,2
 239+ 9D3C D5           	push	de
 240+ 9D3D CD A6 9C     	call	CreateChannel
 241+ 9D40 D1           	pop		de
 242+ 9D41
 243+ 9D41 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 244+ 9D44 CB 27        	sla		a								;reset existing attribute flag
 245+ 9D46 CB 1B        	rr		e								;put wanted flag in Carry flag
 246+ 9D48 CB 1F        	rr		a								;put Carry flag in register L
 247+ 9D4A DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 248+ 9D4D
 249+ 9D4D DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 250+ 9D50 CB 27        	sla		a
 251+ 9D52 CB 1B        	rr		e
 252+ 9D54 CB 1F        	rr		a
 253+ 9D56 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 254+ 9D59
 255+ 9D59              FileAttribSet:
 256+ 9D59 3E 11        	ld		a, 17
 257+ 9D5B CD E2 9C     	call	BDOS
 258+ 9D5E
 259+ 9D5E CD BC 9C     	call	DestroyChannel
 260+ 9D61 C9           	ret
 261+ 9D62
 262+ 9D62              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 263+ 9D62
 264+ 9D62              ;HL=original name, DE = new name
 265+ 9D62              ;Works only on the same drive.
 266+ 9D62              RenameFile:
 267+ 9D62 3A 72 9C     	ld 		a, (RWTSDrive)
 268+ 9D65 3C           	inc		a					;Convert to BASIC drive number: 1,2
 269+ 9D66 D5           	push	de
 270+ 9D67 CD A6 9C     	call	CreateChannel
 271+ 9D6A D1           	pop		de
 272+ 9D6B
 273+ 9D6B DD E5        	push	ix					;IX == FCB
 274+ 9D6D E1           	pop		hl
 275+ 9D6E 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 276+ 9D71 09           	add		hl, bc
 277+ 9D72 EB           	ex		de, hl
 278+ 9D73 3A 72 9C     	ld		a, (RWTSDrive)
 279+ 9D76 12           	ld		(de), a
 280+ 9D77 01 0B 00     	ld		bc, NAMELEN
 281+ 9D7A ED B0        	ldir
 282+ 9D7C
 283+ 9D7C 3E 0A        	ld		a, 10
 284+ 9D7E CD E2 9C     	call	BDOS
 285+ 9D81
 286+ 9D81 CD BC 9C     	call	DestroyChannel
 287+ 9D84 C9           	ret
 288+ 9D85              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 289+ 9D85
 290+ 9D85              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 291+ 9D85
 292+ 9D85              ;Will copy a file from A: to B: or vice versa.
 293+ 9D85              ;HL = source file name, A = source drive
 294+ 9D85              ;TODO:
 295+ 9D85              ;Use cases:
 296+ 9D85              ;1. Copy from A: to B: or B: to A:.
 297+ 9D85              ;2. Copy from A: to A:, with alternating disks (single drive) - ask for disk change.
 298+ 9D85              ;3. Copy from A:/B: to COM.
 299+ 9D85              ;4. Copy from COM to A:/B:.
 300+ 9D85              ;Validations:
 301+ 9D85              ;1. Ask for destination: to A:/to B:/to COM/from COM.
 302+ 9D85              ;2. Ask for new name (except to COM), default to current name, allow changing.
 303+ 9D85              ;3. Check if destination file name exists for A:/B:/from COM. Allow overwrite for different drives, don't allow for same drive.
 304+ 9D85              CopyFile:
 305+ 9D85              	;Check for 0 size files and ignore them.
 306+ 9D85 E5           	push	hl
 307+ 9D86 CD F4 9C     		call 	GetFileSize
 308+ 9D89 7C           		ld		a, h
 309+ 9D8A B5           		or		l
 310+ 9D8B E1           	pop		hl
 311+ 9D8C C8           	ret		z
 312+ 9D8D
 313+ 9D8D 3A 72 9C     	ld 		a, (RWTSDrive)
 314+ 9D90 3C           	inc		a					;Convert to BASIC drive number: 1,2
 315+ 9D91 32 F2 B6     	ld		(CopyFileSrc), a
 316+ 9D94 11 F3 B6     	ld		de, CopyFileSrc+1
 317+ 9D97 01 0B 00     	ld		bc, NAMELEN
 318+ 9D9A E5           	push	hl
 319+ 9D9B C5           	push	bc
 320+ 9D9C ED B0        	ldir
 321+ 9D9E C1           	pop		bc
 322+ 9D9F E1           	pop		hl
 323+ 9DA0 11 FF B6     	ld		de, CopyFileDst+1
 324+ 9DA3 ED B0        	ldir
 325+ 9DA5
 326+ 9DA5 AF           	xor		a
 327+ 9DA6 32 E5 B6     	ld		(CopyFileRes), a
 328+ 9DA9
 329+ 9DA9 21 25 A7     	ld		hl, MsgAskCopyDest
 330+ 9DAC 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 331+ 9DAF 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 332+ 9DB1 CD D9 9F     	call	PrintStrClr
 333+ 9DB4 CD 75 9F     	call	ReadChar
 334+ 9DB7              	;make upper case
 335+ 9DB7 E6 DF        	and		%11011111
 336+ 9DB9 FE 41        	cp		'A'
 337+ 9DBB              	;exit on invalid option
 338+ 9DBB D8           	ret		c
 339+ 9DBC FE 44        	cp		'C'+1
 340+ 9DBE D0           	ret		nc
 341+ 9DBF
 342+ 9DBF 32 40 A7     	ld		(MsgCopyFileDrv), a
 343+ 9DC2 D6 40        	sub		'A'-1
 344+ 9DC4 32 FE B6     	ld		(CopyFileDst), a
 345+ 9DC7
 346+ 9DC7 21 35 A7     	ld		hl, MsgCopyFile
 347+ 9DCA 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 348+ 9DCD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 349+ 9DCF CD D9 9F     	call	PrintStrClr
 350+ 9DD2
 351+ 9DD2
 352+ 9DD2 3A F2 B6     	ld		a, (CopyFileSrc)
 353+ 9DD5 47           	ld		b, a
 354+ 9DD6 3A FE B6     	ld		a, (CopyFileDst)
 355+ 9DD9 B8           	cp		b
 356+ 9DDA 28 02        	jr		z, CopyFileSameDrive
 357+ 9DDC 18 1F        	jr		CopyFileCheckOverwrite
 358+ 9DDE
 359+ 9DDE              	;Skip COM copy for now.
 360+ 9DDE              	;cp		3			;'C'
 361+ 9DDE              	;ret		z
 362+ 9DDE
 363+ 9DDE              CopyFileSameDrive:
 364+ 9DDE 21 D8 A7     	ld		hl, MsgInsertDstDsk
 365+ 9DE1 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 366+ 9DE4 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 367+ 9DE6 CD D9 9F     	call	PrintStrClr
 368+ 9DE9 21 E7 A7     	ld		hl, MsgPressAnyKey
 369+ 9DEC 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 370+ 9DEF 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371+ 9DF1 CD D9 9F     	call	PrintStrClr
 372+ 9DF4 CD 75 9F     	call	ReadChar
 373+ 9DF7
 374+ 9DF7 3A 72 9C     	ld		a, (RWTSDrive)
 375+ 9DFA              	;call 	BDOSSelectDisk
 376+ 9DFA CD 9A 9C     	call	BDOSInit
 377+ 9DFD
 378+ 9DFD              CopyFileCheckOverwrite:
 379+ 9DFD              	;Check if destination file exists.
 380+ 9DFD 3A FE B6     	ld		a, (CopyFileDst)
 381+ 9E00 21 FF B6     	ld		hl, CopyFileDst+1
 382+ 9E03 CD 2A 9D     	call	DoesFileExist
 383+ 9E06 3C           	inc		a
 384+ 9E07 28 11        	jr		z, CopyFileDestNotExist
 385+ 9E09
 386+ 9E09              	;Ask overwrite confirmation.
 387+ 9E09 21 AB A7     	ld		hl, MsgFileOverwrite
 388+ 9E0C 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 9E0F 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 390+ 9E11 CD D9 9F     	call	PrintStrClr
 391+ 9E14 CD 75 9F     	call	ReadChar
 392+ 9E17 FE 79        	cp		'y'
 393+ 9E19 C0           	ret		nz
 394+ 9E1A
 395+ 9E1A              CopyFileDestNotExist:
 396+ 9E1A              	;Delete and re-create empty destination file
 397+ 9E1A 3A FE B6     	ld		a, (CopyFileDst)
 398+ 9E1D 21 FF B6     	ld		hl, CopyFileDst+1
 399+ 9E20 F5           	push	af
 400+ 9E21 E5           	push	hl
 401+ 9E22 CD 1E 9D     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 402+ 9E25 E1           	pop		hl
 403+ 9E26 F1           	pop		af
 404+ 9E27 CD A6 9C     	call	CreateChannel
 405+ 9E2A CD C6 9C     	call 	BDOSCreateFile
 406+ 9E2D 3C           	inc  	a						;Cancel if A==$FF
 407+ 9E2E CA BB 9E     	jp   	z, CopyFileEnd
 408+ 9E31
 409+ 9E31              	;Close dest file once created.
 410+ 9E31 CD CE 9C     	call	BDOSCloseFile
 411+ 9E34 CD BC 9C     	call	DestroyChannel
 412+ 9E37
 413+ 9E37 11 00 00     	ld		de, 0
 414+ 9E3A ED 53 EC B6  	ld		(FilePosRead), de
 415+ 9E3E ED 53 EE B6  	ld		(FilePosWrite), de
 416+ 9E42
 417+ 9E42              CopyFileLoop:
 418+ 9E42              	;If copying on different drives, don't prompt for disk change.
 419+ 9E42 3A F2 B6     	ld		a, (CopyFileSrc)
 420+ 9E45 47           	ld		b, a
 421+ 9E46 3A FE B6     	ld		a, (CopyFileDst)
 422+ 9E49 B8           	cp		b
 423+ 9E4A 20 1F        	jr		nz, CopyFileNotSameDrive1
 424+ 9E4C
 425+ 9E4C 21 C9 A7     	ld		hl, MsgInsertSrcDsk
 426+ 9E4F 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 427+ 9E52 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 428+ 9E54 CD D9 9F     	call	PrintStrClr
 429+ 9E57 21 E7 A7     	ld		hl, MsgPressAnyKey
 430+ 9E5A 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 431+ 9E5D 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 432+ 9E5F CD D9 9F     	call	PrintStrClr
 433+ 9E62 CD 75 9F     	call	ReadChar
 434+ 9E65
 435+ 9E65 3A 72 9C     	ld		a, (RWTSDrive)
 436+ 9E68              	;call 	BDOSSelectDisk
 437+ 9E68 CD 9A 9C     	call	BDOSInit
 438+ 9E6B
 439+ 9E6B              CopyFileNotSameDrive1:
 440+ 9E6B 3A F2 B6     	ld		a, (CopyFileSrc)
 441+ 9E6E 21 F3 B6     	ld		hl, CopyFileSrc+1
 442+ 9E71 CD BC 9E     	call	ReadFileSection
 443+ 9E74 3A E5 B6     	ld		a, (CopyFileRes)
 444+ 9E77 F5           	push	af
 445+ 9E78
 446+ 9E78              		;If copying on different drives, don't prompt for disk change.
 447+ 9E78 3A F2 B6     		ld		a, (CopyFileSrc)
 448+ 9E7B 47           		ld		b, a
 449+ 9E7C 3A FE B6     		ld		a, (CopyFileDst)
 450+ 9E7F B8           		cp		b
 451+ 9E80 20 1F        		jr		nz, CopyFileNotSameDrive2
 452+ 9E82
 453+ 9E82 21 D8 A7     		ld		hl, MsgInsertDstDsk
 454+ 9E85 11 00 11     		ld		de, LST_LINE_MSG + 3 << 8
 455+ 9E88 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 456+ 9E8A CD D9 9F     		call	PrintStrClr
 457+ 9E8D 21 E7 A7     		ld		hl, MsgPressAnyKey
 458+ 9E90 11 00 12     		ld		de, LST_LINE_MSG + 4 << 8
 459+ 9E93 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 460+ 9E95 CD D9 9F     		call	PrintStrClr
 461+ 9E98 CD 75 9F     		call	ReadChar
 462+ 9E9B
 463+ 9E9B 3A 72 9C     		ld		a, (RWTSDrive)
 464+ 9E9E              		;call 	BDOSSelectDisk
 465+ 9E9E CD 9A 9C     		call	BDOSInit
 466+ 9EA1
 467+ 9EA1              CopyFileNotSameDrive2:
 468+ 9EA1 3A FE B6     		ld		a, (CopyFileDst)
 469+ 9EA4 21 FF B6     		ld		hl, CopyFileDst+1
 470+ 9EA7 CD DE 9E     		call	WriteFileSection
 471+ 9EAA 3A E5 B6     		ld		a, (CopyFileRes)
 472+ 9EAD 47           		ld		b, a
 473+ 9EAE F1           	pop		af
 474+ 9EAF B0           	or		b
 475+ 9EB0 C0           	ret		nz
 476+ 9EB1
 477+ 9EB1              	;Check if file ended, if not, continue copying.
 478+ 9EB1
 479+ 9EB1 3A F0 B6     	ld		a, (CopyFileSectCnt)
 480+ 9EB4 3D           	dec		a
 481+ 9EB5 32 F0 B6     	ld		(CopyFileSectCnt), a
 482+ 9EB8 B7           	or		a
 483+ 9EB9 20 87        	jr		nz, CopyFileLoop
 484+ 9EBB
 485+ 9EBB              CopyFileEnd:
 486+ 9EBB C9           	ret
 487+ 9EBC
 488+ 9EBC              ;Reads/Writes disk file portion to/from memory.
 489+ 9EBC              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 490+ 9EBC              ;This should work with single-drive file copy from one disk to another.
 491+ 9EBC              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records
 492+ 9EBC              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 493+ 9EBC              ;
 494+ 9EBC              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 495+ 9EBC              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 496+ 9EBC              ;Must use sequential read/write. But for the first operation must use random read/write.
 497+ 9EBC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 498+ 9EBC              ReadFileSection:
 499+ 9EBC 11 DA 9C     	ld		de, BDOSReadFileBlockRandom
 500+ 9EBF ED 53 26 9F  	ld		(CopyFileOperAddr1), de
 501+ 9EC3 11 D2 9C     	ld		de, BDOSReadFileBlockSeq
 502+ 9EC6 ED 53 4B 9F  	ld		(CopyFileOperAddr2), de
 503+ 9ECA 11 EC B6     	ld		de, FilePosRead
 504+ 9ECD ED 53 1D 9F  	ld		(CopyFilePtr), de
 505+ 9ED1 ED 53 67 9F  	ld		(CopyFilePtr2), de
 506+ 9ED5
 507+ 9ED5              	;Limit max sectors to read to leave space for the index too.
 508+ 9ED5 F5           	push	af
 509+ 9ED6 3E 3C        		ld		a, FileDataSize/SECT_SZ
 510+ 9ED8 32 F0 B6     		ld		(CopyFileSectCnt), a
 511+ 9EDB F1           	pop		af
 512+ 9EDC 18 19        	jr		ReadWriteFileSection
 513+ 9EDE
 514+ 9EDE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 515+ 9EDE
 516+ 9EDE              WriteFileSection:
 517+ 9EDE 11 DE 9C     	ld		de, BDOSWriteFileBlockRandom
 518+ 9EE1 ED 53 26 9F  	ld		(CopyFileOperAddr1), de
 519+ 9EE5 11 D6 9C     	ld		de, BDOSWriteFileBlockSeq
 520+ 9EE8 ED 53 4B 9F  	ld		(CopyFileOperAddr2), de
 521+ 9EEC 11 EE B6     	ld		de, FilePosWrite
 522+ 9EEF ED 53 1D 9F  	ld		(CopyFilePtr), de
 523+ 9EF3 ED 53 67 9F  	ld		(CopyFilePtr2), de
 524+ 9EF7
 525+ 9EF7
 526+ 9EF7              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 527+ 9EF7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 528+ 9EF7              ReadWriteFileSection:
 529+ 9EF7 CD A6 9C     	call	CreateChannel
 530+ 9EFA DD 22 E3 B6  	ld		(CopyFileFCB), ix
 531+ 9EFE CD CA 9C     	call 	BDOSOpenFile
 532+ 9F01 3C           	inc  	a						;Cancel if A==$FF
 533+ 9F02 C8           	ret		z
 534+ 9F03
 535+ 9F03              	;Set DMA initial pointer = FileData
 536+ 9F03 DD E5        	push	ix
 537+ 9F05 21 E3 B7     		ld		hl, FileData
 538+ 9F08 DD 21 E6 B6  		ld		ix, CopyFileDMAAddr
 539+ 9F0C DD 75 00     		ld		(ix), l
 540+ 9F0F DD 74 01     		ld		(ix+1), h
 541+ 9F12 DD 21 E3 B7  		ld		ix, FileData
 542+ 9F16 CD EC 9C     		call 	BDOSSetDMA
 543+ 9F19 DD E1        	pop		ix
 544+ 9F1B
 545+ 9F1B              CopyFilePtr EQU $+2
 546+ 9F1B              	;Update file pointer using read/write random call.
 547+ 9F1B ED 5B EC B6  	ld		de, (FilePosRead)
 548+ 9F1F DD 73 21     	ld		(ix + FCB_R0), e
 549+ 9F22 DD 72 22     	ld		(ix + FCB_R1), d
 550+ 9F25              CopyFileOperAddr1 EQU $ + 1
 551+ 9F25 CD DA 9C     	call 	BDOSReadFileBlockRandom
 552+ 9F28
 553+ 9F28 32 E5 B6     	ld		(CopyFileRes), a
 554+ 9F2B B7           	or		a
 555+ 9F2C 20 28        	jr		nz, ReadWriteFileSectionEnd
 556+ 9F2E
 557+ 9F2E 3A F0 B6     	ld		a, (CopyFileSectCnt)
 558+ 9F31 3D           	dec		a
 559+ 9F32 32 F0 B6     	ld		(CopyFileSectCnt), a
 560+ 9F35 28 1F        	jr		z, ReadWriteFileSectionEnd
 561+ 9F37 47           	ld		b, a
 562+ 9F38
 563+ 9F38              ReadWriteFileSectionLoop:
 564+ 9F38 C5           	push	bc
 565+ 9F39 DD 2A E6 B6  		ld		ix, (CopyFileDMAAddr)
 566+ 9F3D DD 24        		inc		ixh
 567+ 9F3F DD 22 E6 B6  		ld		(CopyFileDMAAddr), ix
 568+ 9F43 CD EC 9C     		call 	BDOSSetDMA
 569+ 9F46
 570+ 9F46 DD 2A E3 B6  		ld		ix, (CopyFileFCB)
 571+ 9F4A              CopyFileOperAddr2 EQU $ + 1
 572+ 9F4A CD D2 9C     		call 	BDOSReadFileBlockSeq
 573+ 9F4D
 574+ 9F4D 32 E5 B6     		ld		(CopyFileRes), a
 575+ 9F50 B7           		or		a
 576+ 9F51 C1           	pop		bc
 577+ 9F52 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 578+ 9F54 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 579+ 9F56
 580+ 9F56              ReadWriteFileSectionEnd:
 581+ 9F56              	;Update sector count variable with how many sectors were transfered.
 582+ 9F56 3E 3C        	ld 		a, FileDataSize/SECT_SZ
 583+ 9F58 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 584+ 9F59 32 F0 B6     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 585+ 9F5C
 586+ 9F5C              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 587+ 9F5C CD F0 9C     	call	BDOSSetRandFilePtr
 588+ 9F5F DD 5E 21     	ld		e, (ix + FCB_R0)
 589+ 9F62 DD 56 22     	ld		d, (ix + FCB_R1)
 590+ 9F65              CopyFilePtr2 EQU $+2
 591+ 9F65 ED 53 EC B6  	ld		(FilePosRead), de
 592+ 9F69
 593+ 9F69 CD CE 9C     	call 	BDOSCloseFile
 594+ 9F6C CD BC 9C     	call 	DestroyChannel
 595+ 9F6F
 596+ 9F6F ED 5B E6 B6  	ld		de, (CopyFileDMAAddr)
 597+ 9F73 15           	dec		d
 598+ 9F74 C9           	ret
 599+ 9F75
 600+ 9F75              	ENDIF
 601+ 9F75
# file closed: bdos.asm
1317  9F75              	include "ui.asm"
# file opened: ui.asm
   1+ 9F75              ;UI related functions
   2+ 9F75
   3+ 9F75              	ifndef	_UI_
   4+ 9F75              	define	_UI_
   5+ 9F75
   6+ 9F75              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++9F75              	ifndef	_HCCFG_
   2++9F75 ~            	define	_HCCFG_
   3++9F75 ~
   4++9F75 ~            ;HC specific code, for configuration
   5++9F75 ~
   6++9F75 ~            HC_CFG_PORT			EQU	$7E
   7++9F75 ~
   8++9F75 ~            ;BASIC/CPM ROM selection
   9++9F75 ~            HC_CFG_ROM_BAS		EQU	%0
  10++9F75 ~            HC_CFG_ROM_CPM		EQU	%1
  11++9F75 ~
  12++9F75 ~            ;Address for ROM paging: 0 or $E000
  13++9F75 ~            HC_CFG_ROM_0000		EQU %00
  14++9F75 ~            HC_CFG_ROM_E000		EQU %10
  15++9F75 ~
  16++9F75 ~            ;Cfg. port Enable/Disable
  17++9F75 ~            HC_CFG_PORT_DIS		EQU %000
  18++9F75 ~            HC_CFG_PORT_EN		EQU	%100
  19++9F75 ~
  20++9F75 ~            ;Video memory bank: $4000 or $C000
  21++9F75 ~            HC_CFG_VID_4000		EQU	%0000
  22++9F75 ~            HC_CFG_VID_C000		EQU	%1000
  23++9F75 ~
  24++9F75 ~
  25++9F75 ~            ;Standar BASIC config
  26++9F75 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++9F75 ~            ;Standar CP/M config
  28++9F75 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++9F75 ~
  30++9F75 ~
  31++9F75 ~            HC_VID_BANK0		EQU	$4000
  32++9F75 ~            HC_VID_BANK1		EQU	$C000
  33++9F75 ~
  34++9F75              	endif
# file closed: hccfg.asm
   7+ 9F75
   8+ 9F75              COL             EQU 23728
   9+ 9F75              LINE            EQU 23729               ;Coordinates
  10+ 9F75              LineCol			EQU	COL
  11+ 9F75              CODE			EQU 23681               ;Char to print
  12+ 9F75
  13+ 9F75              CPM_FNT         EQU $25AB
  14+ 9F75
  15+ 9F75              PORT_ZX			EQU	$FE
  16+ 9F75
  17+ 9F75              ;COLORS
  18+ 9F75              CLR_BLACK		EQU 0
  19+ 9F75              CLR_BLUE		EQU 1
  20+ 9F75              CLR_RED			EQU 2
  21+ 9F75              CLR_MAGENTA		EQU 3
  22+ 9F75              CLR_GREEN		EQU 4
  23+ 9F75              CLR_CYAN		EQU	5
  24+ 9F75              CLR_YELLOW		EQU	6
  25+ 9F75              CLR_WHITE		EQU	7
  26+ 9F75              CLR_BRIGHT		EQU	%01000000
  27+ 9F75              CLR_FLASH		EQU	%10000000
  28+ 9F75
  29+ 9F75              ;PAPER
  30+ 9F75              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 9F75              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 9F75              PAPER_RED		EQU (CLR_RED << 3)
  33+ 9F75              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 9F75              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 9F75              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 9F75              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 9F75              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 9F75
  39+ 9F75              ;INK
  40+ 9F75              INK_BLACK		EQU CLR_BLACK
  41+ 9F75              INK_BLUE		EQU CLR_BLUE
  42+ 9F75              INK_RED			EQU CLR_RED
  43+ 9F75              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 9F75              INK_GREEN		EQU CLR_GREEN
  45+ 9F75              INK_CYAN		EQU	CLR_CYAN
  46+ 9F75              INK_YELLOW		EQU	CLR_YELLOW
  47+ 9F75              INK_WHITE		EQU	CLR_WHITE
  48+ 9F75
  49+ 9F75
  50+ 9F75              ;SCR_ATTR_ADDR	EQU 22528
  51+ 9F75              SCR_PIX_LEN		EQU	6144
  52+ 9F75              SCR_ATTR_LEN	EQU	768
  53+ 9F75              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 9F75              SCR_BYTES_PER_LINE	EQU	32
  55+ 9F75
  56+ 9F75              SCR_COLS		EQU	64
  57+ 9F75              SCR_LINES		EQU 24
  58+ 9F75
  59+ 9F75              ;used for file names list positioning
  60+ 9F75              LST_LINES_CNT	EQU	23
  61+ 9F75              LST_FIRST_LINE	EQU	0
  62+ 9F75              LST_PROG_INFO	EQU LST_FIRST_LINE
  63+ 9F75              LST_DISK_INFO	EQU LST_PROG_INFO + 4
  64+ 9F75              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  65+ 9F75              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  66+ 9F75              LST_FIRST_COL	EQU	16
  67+ 9F75              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  68+ 9F75
  69+ 9F75              ;key codes
  70+ 9F75              KEY_ESC			EQU	7
  71+ 9F75              KEY_LEFT		EQU	8
  72+ 9F75              KEY_RIGHT		EQU	9
  73+ 9F75              KEY_DOWN		EQU	10
  74+ 9F75              KEY_UP			EQU	11
  75+ 9F75              KEY_BACKSP		EQU 12
  76+ 9F75              KEY_ENTER		EQU	13
  77+ 9F75              KEY_CTRL		EQU	14
  78+ 9F75
  79+ 9F75              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  80+ 9F75              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  81+ 9F75              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  82+ 9F75
  83+ 9F75              ;Special formating chars
  84+ 9F75              CHR_CR			EQU	13
  85+ 9F75              CHR_LF			EQU	10
  86+ 9F75              CHR_TAB			EQU	09
  87+ 9F75              CHR_EOF			EQU $1A
  88+ 9F75
  89+ 9F75
  90+ 9F75              ;Semi-graphical chars
  91+ 9F75              ;           UC
  92+ 9F75              ;     UL +H-+--+UR
  93+ 9F75              ;        |  |  |
  94+ 9F75              ;     ML +--+--+MR
  95+ 9F75              ;        V C|  |
  96+ 9F75              ;     LL +--+--+LR
  97+ 9F75              ;           DC
  98+ 9F75              CHR_GRID        EQU 127
  99+ 9F75              CHR_V           EQU	128
 100+ 9F75              CHR_MR          EQU	129
 101+ 9F75              CHR_UR          EQU 130
 102+ 9F75              CHR_DL          EQU 131
 103+ 9F75              CHR_DC          EQU 132
 104+ 9F75              CHR_UC          EQU 133
 105+ 9F75              CHR_ML          EQU 134
 106+ 9F75              CHR_H           EQU 135
 107+ 9F75              CHR_C           EQU 136
 108+ 9F75              CHR_LR          EQU 137
 109+ 9F75              CHR_UL          EQU 138
 110+ 9F75              CHR_FULL        EQU 139
 111+ 9F75              CHR_HALF        EQU 140
 112+ 9F75
 113+ 9F75              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 114+ 9F75
 115+ 9F75              ;Return read char in A
 116+ 9F75              ReadChar:
 117+ 9F75 CF           	rst 08
 118+ 9F76 1B           	DEFB 27
 119+ 9F77 C9           	ret
 120+ 9F78
 121+ 9F78              ;Checks if a key is pressed
 122+ 9F78              ;Cy=1 if key is pressed
 123+ 9F78              KbdHit:
 124+ 9F78 CF           	rst 08
 125+ 9F79 20           	DEFB 32
 126+ 9F7A C9           	ret
 127+ 9F7B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 128+ 9F7B
 129+ 9F7B              InitFonts:
 130+ 9F7B              	IFUSED
 131+ 9F7B                  ;page-in CPM ROM to get fonts
 132+ 9F7B F3               di
 133+ 9F7C 3E 01            ld a, HC_CFG_ROM_CPM
 134+ 9F7E D3 7E            out	(HC_CFG_PORT), a
 135+ 9F80
 136+ 9F80 21 AB 25     	ld		hl, CPM_FNT
 137+ 9F83 11 7B B3     	ld		de, FontTable
 138+ 9F86 01 68 03     	ld		bc, 872
 139+ 9F89 ED B0        	ldir
 140+ 9F8B
 141+ 9F8B                  ;restore BASIC ROM
 142+ 9F8B 3E 00            ld a, HC_CFG_ROM_BAS
 143+ 9F8D D3 7E            out	(HC_CFG_PORT), a
 144+ 9F8F FB               ei
 145+ 9F90
 146+ 9F90 C9           	ret
 147+ 9F91              	ENDIF
 148+ 9F91
 149+ 9F91              ClrScr:
 150+ 9F91 2A 34 A1     	ld		hl, (CurrScrAddr)
 151+ 9F94 54           	ld		d, h
 152+ 9F95 5D           	ld		e, l
 153+ 9F96 13           	inc		de
 154+ 9F97 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 155+ 9F9A 36 00        	ld		(hl), 0
 156+ 9F9C ED B0        	ldir
 157+ 9F9E
 158+ 9F9E 23           	inc 	hl
 159+ 9F9F 13           	inc		de
 160+ 9FA0
 161+ 9FA0 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 162+ 9FA3 36 0F        	ld		(hl), SCR_DEF_CLR
 163+ 9FA5 ED B0        	ldir
 164+ 9FA7
 165+ 9FA7              	;also set border color
 166+ 9FA7 3E 01        	ld		a, SCR_DEF_CLR >> 3
 167+ 9FA9 D3 FE        	out		(PORT_ZX), a
 168+ 9FAB
 169+ 9FAB 3E 0F        	ld		a, SCR_DEF_CLR
 170+ 9FAD 32 48 5C     	ld		(23624), a
 171+ 9FB0 C9           	ret
 172+ 9FB1
 173+ 9FB1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 174+ 9FB1              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 175+ 9FB1              PrintStr:
 176+ 9FB1 7E           	ld		a, (hl)
 177+ 9FB2 FE 20        	cp		' '
 178+ 9FB4 30 02        	jr		nc, GoodChar
 179+ 9FB6 3E 3F        	ld		a, '?'
 180+ 9FB8              GoodChar:
 181+ 9FB8 CB 7F        	bit		7, a
 182+ 9FBA CB BF        	res		7, a
 183+ 9FBC 32 81 5C     	ld		(CODE), a
 184+ 9FBF ED 53 B0 5C  	ld		(LineCol), de
 185+ 9FC3 08           	ex		af, af'
 186+ 9FC4 D9           	exx
 187+ 9FC5 E5           	push	hl
 188+ 9FC6 CD B4 A0     	call 	PrintChar
 189+ 9FC9 E1           	pop		hl
 190+ 9FCA D9           	exx
 191+ 9FCB 08           	ex		af, af'
 192+ 9FCC C0           	ret		nz
 193+ 9FCD
 194+ 9FCD 1C           	inc		e
 195+ 9FCE 23           	inc		hl
 196+ 9FCF
 197+ 9FCF 7B           	ld		a, e
 198+ 9FD0 FE 40        	cp		64
 199+ 9FD2 38 DD        	jr		c, PrintStr
 200+ 9FD4 1E 00        	ld		e, 0
 201+ 9FD6 14           	inc		d
 202+ 9FD7
 203+ 9FD7 18 D8        	jr		PrintStr
 204+ 9FD9
 205+ 9FD9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 206+ 9FD9
 207+ 9FD9              ;IN: HL = string, DE = coords, A = color
 208+ 9FD9              PrintStrClr:
 209+ 9FD9 32 05 A0     	ld		(StrClr), a
 210+ 9FDC D5           	push	de
 211+ 9FDD CD B1 9F     		call	PrintStr
 212+ 9FE0 E1           	pop		hl
 213+ 9FE1              	;get string len.
 214+ 9FE1 7B           	ld		a, e
 215+ 9FE2 95           	sub		l
 216+ 9FE3 1F           	rra
 217+ 9FE4 08           	ex		af, af'
 218+ 9FE5              		;line * 32
 219+ 9FE5 7C           		ld		a, h
 220+ 9FE6 17           		rla
 221+ 9FE7 17           		rla
 222+ 9FE8 11 00 00     		ld	de, 0
 223+ 9FEB 17           		rla
 224+ 9FEC CB 12        		rl	d
 225+ 9FEE 17           		rla
 226+ 9FEF CB 12        		rl	d
 227+ 9FF1 17           		rla
 228+ 9FF2 CB 12        		rl	d
 229+ 9FF4 5F           		ld	e, a
 230+ 9FF5
 231+ 9FF5 26 00        		ld		h, 0
 232+ 9FF7 19           		add		hl, de
 233+ 9FF8 ED 5B 36 A1  		ld		de, (CurrScrAttrAddr)
 234+ 9FFC 19           		add		hl, de
 235+ 9FFD 08           	ex		af, af'
 236+ 9FFE 4F           	ld		c, a
 237+ 9FFF 06 00        	ld		b, 0
 238+ A001 54           	ld		d, h
 239+ A002 5D           	ld		e, l
 240+ A003 13           	inc 	de
 241+ A004              StrClr	EQU	$ + 1
 242+ A004 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 243+ A006 ED B0        	ldir
 244+ A008 C9           	ret
 245+ A009              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 246+ A009
 247+ A009              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 248+ A009              DrawLine:
 249+ A009 32 81 5C     	ld		(CODE), a
 250+ A00C
 251+ A00C 38 04        	jr		c, VertDir
 252+ A00E 3E 1C        	ld		a, $1C
 253+ A010 18 02        	jr		StoreDir
 254+ A012              VertDir:
 255+ A012 3E 14        	ld		a, $14
 256+ A014              StoreDir:
 257+ A014 32 24 A0     	ld		(LineDir), a
 258+ A017
 259+ A017              DrawLineLoop:
 260+ A017 ED 53 B0 5C  	ld		(LineCol), de
 261+ A01B D5           	push	de
 262+ A01C D9           		exx
 263+ A01D E5           		push	hl
 264+ A01E CD B4 A0     		call 	PrintChar
 265+ A021 E1           		pop		hl
 266+ A022 D9           		exx
 267+ A023 D1           	pop		de
 268+ A024              LineDir:
 269+ A024 1C           	inc		e
 270+ A025 10 F0        	djnz	DrawLineLoop
 271+ A027
 272+ A027 C9           	ret
 273+ A028
 274+ A028              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 275+ A028
 276+ A028              DrawHLine:
 277+ A028 32 37 A0     	ld		(ChrParam), a
 278+ A02B
 279+ A02B 06 10        	ld		b, 16
 280+ A02D 3E 87        	ld		a, CHR_H
 281+ A02F B7           	or		a
 282+ A030 CD 09 A0     	call	DrawLine
 283+ A033
 284+ A033 06 04        	ld		b, 4
 285+ A035              DrawUpLine:
 286+ A035 C5           	push	bc
 287+ A036              ChrParam	EQU		$ + 1
 288+ A036 3E 85        		ld		a, CHR_UC
 289+ A038 D5           		push	de
 290+ A039 CD 6A A0     			call	PrintChar2
 291+ A03C D1           		pop		de
 292+ A03D 13           		inc		de
 293+ A03E
 294+ A03E 06 0B        		ld		b, NAMELEN
 295+ A040 3E 87        		ld		a, CHR_H
 296+ A042 B7           		or		a
 297+ A043 CD 09 A0     		call	DrawLine
 298+ A046 C1           	pop		bc
 299+ A047 10 EC        	djnz	DrawUpLine
 300+ A049
 301+ A049 06 04        	ld		b, 4
 302+ A04B 3E 87        	ld		a, CHR_H
 303+ A04D B7           	or		a
 304+ A04E CD 09 A0     	call	DrawLine
 305+ A051 C9           	ret
 306+ A052
 307+ A052
 308+ A052              DrawVLines:
 309+ A052 06 04        	ld		b, 4
 310+ A054 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 311+ A057              DrawVLinesLoop:
 312+ A057 C5           	push 	bc
 313+ A058 D5           	push	de
 314+ A059 06 17        		ld		b, LST_LINES_CNT
 315+ A05B 3E 80        		ld		a, CHR_V
 316+ A05D 37           		scf
 317+ A05E CD 09 A0     		call	DrawLine
 318+ A061 D1           	pop		de
 319+ A062 C1           	pop	bc
 320+ A063 7B           	ld		a, e
 321+ A064 C6 0C        	add		NAMELEN+1
 322+ A066 5F           	ld		e, a
 323+ A067 10 EE        	djnz	DrawVLinesLoop
 324+ A069 C9           	ret
 325+ A06A
 326+ A06A              PrintChar2:
 327+ A06A 32 81 5C     	ld		(CODE), a
 328+ A06D ED 53 B0 5C  	ld		(LineCol), de
 329+ A071
 330+ A071              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 331+ A071
 332+ A071              ;IN: A = color mask
 333+ A071              DrawCursor:
 334+ A071 ED 5B F7 A7  	ld	de, (CursorAddr)
 335+ A075 06 06        	ld	b, 	(NAMELEN + 1)/2
 336+ A077              DrawCursorLoop:
 337+ A077 12           	ld	(de), a
 338+ A078 13           	inc de
 339+ A079 10 FC        	djnz DrawCursorLoop
 340+ A07B C9           	ret
 341+ A07C
 342+ A07C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 343+ A07C
 344+ A07C              ;IN:	A = file idx.
 345+ A07C              MoveCursor:
 346+ A07C              	;File idx / SCR_LINES => cursor line & column
 347+ A07C 6F           	ld		l, a
 348+ A07D 26 00        	ld		h, 0
 349+ A07F 0E 17        	ld		c, LST_LINES_CNT
 350+ A081 CD A9 98     	call	Div					;HL = file column, A = line
 351+ A084
 352+ A084              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 353+ A084 C6 00        	add		LST_FIRST_LINE
 354+ A086
 355+ A086
 356+ A086 54           	ld d, h
 357+ A087 5D           	ld e, l
 358+ A088 21 00 00     	ld	hl, 0
 359+ A08B
 360+ A08B              	;line*32
 361+ A08B 17           	rla
 362+ A08C 17           	rla
 363+ A08D 17           	rla
 364+ A08E 17           	rla
 365+ A08F CB 14        	rl h
 366+ A091 17           	rla
 367+ A092 CB 14        	rl h
 368+ A094 6F           	ld l, a
 369+ A095
 370+ A095
 371+ A095              	;col * 6
 372+ A095 E5           	push	hl					;save line * 32
 373+ A096 3E 06        		ld		a, (NAMELEN + 1)/2
 374+ A098 CD C9 98     		call	Mul				;HL = column * 12/2
 375+ A09B D1           	pop		de
 376+ A09C 19           	add		hl, de
 377+ A09D
 378+ A09D 11 08 00     	ld		de, LST_FIRST_COL/2
 379+ A0A0 ED 4B 36 A1  	ld		bc, (CurrScrAttrAddr)
 380+ A0A4 19           	add		hl, de
 381+ A0A5 09           	add		hl, bc
 382+ A0A6
 383+ A0A6              	;clear old cursor
 384+ A0A6 3E 0F        	ld		a, SCR_DEF_CLR
 385+ A0A8 CD 71 A0     	call	DrawCursor
 386+ A0AB
 387+ A0AB              	;draw new one
 388+ A0AB 22 F7 A7     	ld		(CursorAddr), hl
 389+ A0AE 3E 28        	ld		a, SCR_SEL_CLR
 390+ A0B0 CD 71 A0     	call	DrawCursor
 391+ A0B3
 392+ A0B3 C9           	ret
 393+ A0B4
 394+ A0B4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 395+ A0B4
 396+ A0B4              PrintChar:
 397+ A0B4 ED 5B B0 5C      ld		de, (LineCol)
 398+ A0B8
 399+ A0B8                  ;calculate 64 column screen address
 400+ A0B8              	;IN: D = line, E = col
 401+ A0B8              	;OUT: HL = screen address
 402+ A0B8
 403+ A0B8 CB 3B            SRL     E                                       ;col = col/2
 404+ A0BA CB 19            RR      C                                       ;mark odd/even column
 405+ A0BC 7A               LD      A, D                            ;A = line
 406+ A0BD E6 18            AND 24                                  ;keep only %00011000
 407+ A0BF 2A 34 A1         ld		hl, (CurrScrAddr)
 408+ A0C2 B4               OR      h								;add screen start address
 409+ A0C3 67               LD      H, A                            ;save H
 410+ A0C4 7A               LD      A, D                            ;A = line
 411+ A0C5 E6 07            AND 7                                   ;keep only %00000111
 412+ A0C7 0F               RRCA                                    ;%10000011
 413+ A0C8 0F               RRCA                                    ;%11000001
 414+ A0C9 0F               RRCA                                    ;%11100000
 415+ A0CA B3               OR      E                                       ;add column
 416+ A0CB 6F               LD      L, A                            ;HL = screen address
 417+ A0CC
 418+ A0CC              PrintChar3:
 419+ A0CC                  ;get font address
 420+ A0CC E5               PUSH HL
 421+ A0CD AF                   XOR A
 422+ A0CE 67                   LD  H, A
 423+ A0CF 3A 81 5C             LD  A, (CODE)
 424+ A0D2 D6 20                SUB ' '
 425+ A0D4 6F                   LD  L, A
 426+ A0D5 29                   ADD     HL, HL                  ;char code = char code * 8
 427+ A0D6 29                   ADD     HL, HL                  ;i.e. offset into font table
 428+ A0D7 29                   ADD     HL, HL
 429+ A0D8 11 7B B3             LD      DE, FontTable             ;get font table
 430+ A0DB 19                   ADD     HL, DE
 431+ A0DC EB                   EX      DE, HL                  ;DE = our char font address
 432+ A0DD E1               POP     HL
 433+ A0DE
 434+ A0DE
 435+ A0DE                  ;print a char
 436+ A0DE 06 08            LD      B, 8                            ;char height is 8 lines
 437+ A0E0              PrintCharLine:
 438+ A0E0 1A                   LD      A, (DE)                         ;load char line in A
 439+ A0E1
 440+ A0E1 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 441+ A0E3 20 06                JR  	NZ, NoTurn
 442+ A0E5
 443+ A0E5 07                   RLCA
 444+ A0E6 07                   RLCA
 445+ A0E7 07                   RLCA
 446+ A0E8 07                   RLCA
 447+ A0E9 18 01                JR      Store
 448+ A0EB              NoTurn:
 449+ A0EB B6                   OR (HL)
 450+ A0EC              Store:
 451+ A0EC 77                   LD (HL), A
 452+ A0ED
 453+ A0ED 13                   INC     DE                                      ;next char line in font table
 454+ A0EE 24                   INC     H                                       ;next char line on screen
 455+ A0EF 10 EF            DJNZ PrintCharLine                  ;last line of char?
 456+ A0F1
 457+ A0F1 C9               ret
 458+ A0F2
 459+ A0F2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 460+ A0F2
 461+ A0F2              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 462+ A0F2              ReadString:
 463+ A0F2 21 E3 B6     	ld		hl, DataBuf
 464+ A0F5 D5           	push	de
 465+ A0F6 DD E1        	pop		ix
 466+ A0F8
 467+ A0F8              ReadStringLoop:
 468+ A0F8 D5           	push	de
 469+ A0F9 E5           	push	hl
 470+ A0FA CD 75 9F     		call ReadChar
 471+ A0FD E1           	pop		hl
 472+ A0FE D1           	pop		de
 473+ A0FF
 474+ A0FF FE 0D        	cp	KEY_ENTER
 475+ A101 C8           	ret z
 476+ A102
 477+ A102 FE 0C        	cp  KEY_BACKSP
 478+ A104 20 0F        	jr	nz, ReadStrChar
 479+ A106
 480+ A106 E5           	push hl
 481+ A107 01 E4 B6     	ld   bc, DataBuf+1
 482+ A10A ED 42        	sbc	 hl, bc
 483+ A10C E1           	pop  hl
 484+ A10D 38 16        	jr   c, ReadStrPrint
 485+ A10F
 486+ A10F 1B           	dec	de
 487+ A110 2B           	dec	hl
 488+ A111 36 20        	ld	(hl), ' '
 489+ A113 18 10        	jr	ReadStrPrint
 490+ A115
 491+ A115              ReadStrChar:
 492+ A115 FE 20        	cp	' '
 493+ A117 38 DF        	jr	c, ReadStringLoop
 494+ A119 FE 7F        	cp  127
 495+ A11B 30 DB        	jr	nc, ReadStringLoop
 496+ A11D
 497+ A11D              	;Check end of string and go back if found.
 498+ A11D 46           	ld	b, (hl)
 499+ A11E CB 78        	bit 7, b
 500+ A120 20 03        	jr	nz, ReadStrPrint
 501+ A122
 502+ A122 77           	ld	(hl), a
 503+ A123 23           	inc	hl
 504+ A124 13           	inc	de
 505+ A125
 506+ A125              ReadStrPrint:
 507+ A125 E5           	push	hl
 508+ A126 D5           	push	de
 509+ A127 21 E3 B6     	ld		hl, DataBuf
 510+ A12A DD E5        	push	ix
 511+ A12C D1           	pop		de
 512+ A12D CD B1 9F     	call	PrintStr
 513+ A130 D1           	pop		de
 514+ A131 E1           	pop		hl
 515+ A132
 516+ A132 18 C4        	jr		ReadStringLoop
 517+ A134
 518+ A134 00 40        CurrScrAddr		DEFW	16384
 519+ A136 00 58        CurrScrAttrAddr	DEFW	22528
 520+ A138
 521+ A138                 	endif
# file closed: ui.asm
1318  A138              	include "math.asm"
# file opened: math.asm
   1+ A138              	ifndef	_MATH_
   2+ A138 ~            	define	_MATH_
   3+ A138 ~
   4+ A138 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ A138 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ A138 ~
   7+ A138 ~
   8+ A138 ~            Word2Txt:
   9+ A138 ~            	IFUSED
  10+ A138 ~            	push	de
  11+ A138 ~            		call	Word2Txt_
  12+ A138 ~            	pop		de
  13+ A138 ~
  14+ A138 ~            	ld		b, 4
  15+ A138 ~            	call	StrippLeading0
  16+ A138 ~            	ret
  17+ A138 ~
  18+ A138 ~            Byte2Txt:
  19+ A138 ~            	push	de
  20+ A138 ~            		call	Byte2Txt_
  21+ A138 ~            	pop		de
  22+ A138 ~
  23+ A138 ~            	ld		b, 2
  24+ A138 ~            	call	StrippLeading0
  25+ A138 ~            	ret
  26+ A138 ~            	ENDIF
  27+ A138 ~
  28+ A138 ~
  29+ A138 ~            StrippLeading0:
  30+ A138 ~            	ld		a, (de)
  31+ A138 ~            	cp		'1'
  32+ A138 ~            	ret		nc
  33+ A138 ~
  34+ A138 ~            	ld		a, ' '
  35+ A138 ~            	ld		(de), a
  36+ A138 ~            	inc		de
  37+ A138 ~            	djnz	StrippLeading0
  38+ A138 ~            	ret
  39+ A138 ~
  40+ A138 ~
  41+ A138 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ A138 ~            Word2Txt_:
  43+ A138 ~            	ld bc, -10000
  44+ A138 ~            	call DigitLoop
  45+ A138 ~            	ld bc, -1000
  46+ A138 ~            	call DigitLoop
  47+ A138 ~            Byte2Txt_:
  48+ A138 ~            	ld bc, -100
  49+ A138 ~            	call DigitLoop
  50+ A138 ~            	ld bc, -10
  51+ A138 ~            	call DigitLoop
  52+ A138 ~            	ld bc, -1
  53+ A138 ~
  54+ A138 ~            DigitLoop:
  55+ A138 ~            	ld	a, '0' - 1
  56+ A138 ~            DivNrLoop:
  57+ A138 ~            	inc	a			;increase reminder
  58+ A138 ~            	add	hl, bc		;substract divizor
  59+ A138 ~            	jr	c, DivNrLoop	;still dividing?
  60+ A138 ~            	sbc	hl, bc		;nope, restore
  61+ A138 ~
  62+ A138 ~            	ld (de), a
  63+ A138 ~            	inc de
  64+ A138 ~            	ret
  65+ A138 ~
  66+ A138 ~
  67+ A138 ~            ;Input: HL = Dividend, C = Divisor
  68+ A138 ~            ;Output: HL = Quotient, A = Remainder
  69+ A138 ~            ;Warning: doesn't work with divisor >= $80
  70+ A138 ~            Div:
  71+ A138 ~            	IFUSED
  72+ A138 ~            	xor a
  73+ A138 ~            	ld b, 16
  74+ A138 ~
  75+ A138 ~            DivLoop:
  76+ A138 ~            	add	hl,hl
  77+ A138 ~            	rla
  78+ A138 ~            	cp	c
  79+ A138 ~            	jr	c, NoSub
  80+ A138 ~            	sub	c
  81+ A138 ~            	inc	l
  82+ A138 ~            NoSub:
  83+ A138 ~            	djnz DivLoop
  84+ A138 ~
  85+ A138 ~            	ret
  86+ A138 ~            	ENDIF
  87+ A138 ~
  88+ A138 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ A138 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ A138 ~            Div2:
  91+ A138 ~            	ld hl, 0
  92+ A138 ~            	ld b, 16
  93+ A138 ~            Div2Loop:
  94+ A138 ~            	sll c		; unroll 16 times
  95+ A138 ~            	rla			; ...
  96+ A138 ~            	adc	hl,hl		; ...
  97+ A138 ~            	sbc	hl,de		; ...
  98+ A138 ~            	jr	nc,$+4		; ...
  99+ A138 ~            	add	hl,de		; ...
 100+ A138 ~            	dec	c		; ...
 101+ A138 ~            	djnz Div2Loop
 102+ A138 ~            	ret
 103+ A138 ~
 104+ A138 ~
 105+ A138 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ A138 ~            ;Output: A:HL = Product
 107+ A138 ~            Mul:
 108+ A138 ~            	IFUSED
 109+ A138 ~            	ld hl, 0
 110+ A138 ~            	ld bc, $0700
 111+ A138 ~
 112+ A138 ~            	add	a, a		; optimised 1st iteration
 113+ A138 ~            	jr	nc, MulLoop
 114+ A138 ~            	ld	h, d
 115+ A138 ~            	ld	l, e
 116+ A138 ~
 117+ A138 ~            MulLoop:
 118+ A138 ~            	add	hl,hl
 119+ A138 ~            	rla
 120+ A138 ~            	jr	nc, NoAdd
 121+ A138 ~            	add	hl,de
 122+ A138 ~            	adc	a,c
 123+ A138 ~            NoAdd:
 124+ A138 ~            	djnz MulLoop
 125+ A138 ~
 126+ A138 ~            	ret
 127+ A138 ~            	ENDIF
 128+ A138 ~
 129+ A138              	endif
# file closed: math.asm
1319  A138              	include "txtview.asm"
# file opened: txtview.asm
   1+ A138              ; 	DEVICE ZXSPECTRUM48
   2+ A138
   3+ A138              LINE_CNT	EQU	23
   4+ A138              COL_CNT		EQU	64
   5+ A138
   6+ A138              CHAR_CR		EQU	$0D
   7+ A138              CHAR_LF		EQU	$0A
   8+ A138              CHAR_TAB	EQU	$09
   9+ A138              EOF_MARKER		EQU	$1A
  10+ A138
  11+ A138              COORDS		EQU	23728		;Coordinates
  12+ A138
  13+ A138
  14+ A138              InitViewer:
  15+ A138 22 7E A4     	ld		 (FileBegin), hl
  16+ A13B 09           	add		hl, bc
  17+ A13C              	;must filter any EOF chars.
  18+ A13C 3E 1A        	ld		a, EOF_MARKER
  19+ A13E 25           	dec		h
  20+ A13F 01 FF 00     	ld		bc, $FF
  21+ A142 ED B1        	cpir
  22+ A144 2B           	dec		hl
  23+ A145 2B           	dec		hl
  24+ A146 22 82 A4     	ld		(FileEnd), hl
  25+ A149 ED 5B 7E A4  	ld		de, (FileBegin)
  26+ A14D B7           	or		a
  27+ A14E ED 52        	sbc		hl, de
  28+ A150 22 80 A4     	ld		(FileLen), hl
  29+ A153
  30+ A153 3E 0D        	ld		a, CHAR_CR
  31+ A155 77           	ld		(hl), a
  32+ A156
  33+ A156
  34+ A156 21 04 02     	ld		hl, (2 << 8) | 4
  35+ A159 22 09 5C     	ld		(23561), hl
  36+ A15C
  37+ A15C 21 00 00     	ld		hl, 0
  38+ A15F 22 B0 5C     	ld		(COORDS), hl
  39+ A162
  40+ A162 21 00 58     	ld		hl, 16384 + 6144
  41+ A165 54           	ld		d, h
  42+ A166 5D           	ld		e, l
  43+ A167 13           	inc		de
  44+ A168 01 FF 02     	ld		bc, 767
  45+ A16B 36 0F        	ld		(hl), (1 << 3) | 7
  46+ A16D ED B0        	ldir
  47+ A16F
  48+ A16F CD 84 A3     	call	ScrollInit
  49+ A172
  50+ A172 11 00 00     	ld		de, 0
  51+ A175 ED 53 79 A4  	ld		(CurLine), de
  52+ A179
  53+ A179              	;prepare file progress %
  54+ A179 2A 80 A4     	ld		hl, (FileLen)
  55+ A17C 7C           	ld		a, h
  56+ A17D 4D           	ld		c, l
  57+ A17E 11 64 00     	ld		de, 100
  58+ A181 CD B6 98     	call	Div2
  59+ A184 67           	ld		h, a
  60+ A185 69           	ld		l, c
  61+ A186 22 84 A4     	ld		(PROGR_PERC), hl
  62+ A189
  63+ A189 CD 13 A3     	call	PrintMsg
  64+ A18C
  65+ A18C DD 21 E1 F3  	ld		ix, FileIdx	- 2
  66+ A190 06 17        	ld		b, LINE_CNT
  67+ A192 2A 7E A4     	ld		hl, (FileBegin)
  68+ A195
  69+ A195 C9           	ret
  70+ A196
  71+ A196
  72+ A196              PrintLoop:
  73+ A196 C5           	push	bc
  74+ A197 DD 23        		inc		ix
  75+ A199 DD 23        		inc		ix
  76+ A19B DD 75 00     		ld		(ix), l
  77+ A19E DD 74 01     		ld		(ix + 1), h
  78+ A1A1
  79+ A1A1 CD B7 A2     		call	GetLine
  80+ A1A4 CD 89 A2     		call	PrintLine
  81+ A1A7
  82+ A1A7 ED 5B 79 A4  		ld		de, (CurLine)
  83+ A1AB 13           		inc		de
  84+ A1AC ED 53 79 A4  		ld		(CurLine), de
  85+ A1B0 C1           	pop		bc
  86+ A1B1 CD 7E A2     	call	CheckEnd
  87+ A1B4 38 13        	jr		c, ViewFileEOF
  88+ A1B6
  89+ A1B6 10 DE        	djnz	PrintLoop
  90+ A1B8 18 17        	jr		PrintLoop2
  91+ A1BA
  92+ A1BA              GetKey:
  93+ A1BA 76           	halt
  94+ A1BB FD CB 01 6E  	bit		5, (iy + 1);
  95+ A1BF 28 F9        	jr		z, GetKey
  96+ A1C1 FD CB 01 AE  	res		5, (iy + 1)
  97+ A1C5 FD 7E CE     	ld		a, (iy - $32)
  98+ A1C8 C9           	ret
  99+ A1C9
 100+ A1C9              ViewFileEOF:
 101+ A1C9 CD BA A1     	call	GetKey
 102+ A1CC FE 30        	cp		'0'
 103+ A1CE 20 F9        	jr		nz, ViewFileEOF
 104+ A1D0 C9           	ret
 105+ A1D1
 106+ A1D1              PrintLoop2:
 107+ A1D1 CD 13 A3     	call	PrintMsg
 108+ A1D4
 109+ A1D4 CD BA A1     	call	GetKey
 110+ A1D7 FE 30        	cp		'0'					;Exit on 0
 111+ A1D9 C8           	ret		z
 112+ A1DA
 113+ A1DA FE 0A        	cp		KEY_DOWN
 114+ A1DC 28 5C        	jr		z, Down
 115+ A1DE
 116+ A1DE FE 0B        	cp		KEY_UP
 117+ A1E0 28 2D        	jr		z, Up
 118+ A1E2
 119+ A1E2 FE 32        	cp		'2'
 120+ A1E4 20 EB        	jr		nz, PrintLoop2
 121+ A1E6
 122+ A1E6 3A 7D A4     	ld		a, (WrapFlag)
 123+ A1E9 EE 01        	xor		1
 124+ A1EB 32 7D A4     	ld		(WrapFlag), a
 125+ A1EE B7           	or		a
 126+ A1EF 28 0F        	jr		z, NoWrap
 127+ A1F1
 128+ A1F1 11 4F 6E     	ld		de, 'nO'
 129+ A1F4 ED 53 2F A4  	ld		(MsgLineWrF), de
 130+ A1F8 3E 20        	ld		a, ' '
 131+ A1FA 32 31 A4     	ld		(MsgLineWrF + 2), a
 132+ A1FD C3 D1 A1     	jp		PrintLoop2
 133+ A200
 134+ A200              NoWrap:
 135+ A200 11 4F 66     	ld		de, 'fO'
 136+ A203 ED 53 2F A4  	ld		(MsgLineWrF), de
 137+ A207 3E 66        	ld		a, 'f'
 138+ A209 32 31 A4     	ld		(MsgLineWrF + 2), a
 139+ A20C
 140+ A20C C3 D1 A1     	jp		PrintLoop2
 141+ A20F
 142+ A20F
 143+ A20F              Up:
 144+ A20F CD 6E A2     	call	CheckBegin
 145+ A212 28 BD        	jr		z, PrintLoop2
 146+ A214
 147+ A214 CD B2 A3     	call	ScrollUp
 148+ A217
 149+ A217 DD 2B        	dec		ix
 150+ A219 DD 2B        	dec		ix
 151+ A21B DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 152+ A21E DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 153+ A221 CD B7 A2     	call	GetLine						;extract previous line to display
 154+ A224
 155+ A224 11 00 00     	ld		de, 0
 156+ A227 ED 53 B0 5C  	ld		(COORDS), de
 157+ A22B CD 89 A2     	call	PrintLine
 158+ A22E
 159+ A22E 2A 79 A4     	ld		hl, (CurLine)
 160+ A231 2B           	dec		hl
 161+ A232 22 79 A4     	ld		(CurLine), hl
 162+ A235 CD 13 A3     	call	PrintMsg
 163+ A238 18 97        	jr		PrintLoop2
 164+ A23A
 165+ A23A
 166+ A23A              Down:
 167+ A23A DD 6E 00     	ld		l, (ix)
 168+ A23D DD 66 01     	ld		h, (ix + 1)
 169+ A240 CD B7 A2     	call	GetLine						;get next line pointer
 170+ A243
 171+ A243 CD 7E A2     	call	CheckEnd					;check if HL == file end
 172+ A246 D8           	ret		c
 173+ A247
 174+ A247 DD 23        	inc		ix								;save next line pointer
 175+ A249 DD 23        	inc		ix
 176+ A24B DD 75 00     	ld		(ix), l
 177+ A24E DD 74 01     	ld		(ix + 1), h
 178+ A251
 179+ A251 CD B7 A2     	call	GetLine						;extract next line in buffer for display
 180+ A254
 181+ A254 CD B7 A3     	call	ScrollDown
 182+ A257
 183+ A257 11 00 16     	ld		de, (LINE_CNT-1) << 8
 184+ A25A ED 53 B0 5C  	ld		(COORDS), de
 185+ A25E CD 89 A2     	call	PrintLine
 186+ A261
 187+ A261 2A 79 A4     	ld		hl, (CurLine)
 188+ A264 23           	inc		hl
 189+ A265 22 79 A4     	ld		(CurLine), hl
 190+ A268 CD 13 A3     	call	PrintMsg
 191+ A26B
 192+ A26B C3 D1 A1     	jp		PrintLoop2
 193+ A26E
 194+ A26E
 195+ A26E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 196+ A26E              ;check begining of buffer
 197+ A26E              CheckBegin:
 198+ A26E E5           	push	hl
 199+ A26F DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 200+ A272 DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 201+ A275 ED 5B 7E A4  		ld		de, (FileBegin)
 202+ A279 B7           		or		a
 203+ A27A ED 52        		sbc		hl, de
 204+ A27C E1           	pop		hl
 205+ A27D C9           	ret
 206+ A27E
 207+ A27E              ;check end of buffer
 208+ A27E              CheckEnd:
 209+ A27E E5           	push	hl
 210+ A27F ED 5B 82 A4  		ld		de, (FileEnd)
 211+ A283 EB           		ex		de, hl
 212+ A284 B7           		or		a
 213+ A285 ED 52        		sbc		hl, de
 214+ A287 E1           	pop		hl
 215+ A288 C9           	ret
 216+ A289
 217+ A289              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ A289              ;Print a line
 219+ A289              PrintLine:
 220+ A289 11 39 A4     	ld		de, LineBuf
 221+ A28C 06 40        	ld		b, COL_CNT
 222+ A28E
 223+ A28E CD 9D A2     	call	PrintStrTxt
 224+ A291
 225+ A291              	;go to the next screen line
 226+ A291 ED 5B B0 5C  	ld		de, (COORDS)
 227+ A295 14           	inc		d
 228+ A296 1E 00        	ld		e, 0
 229+ A298 ED 53 B0 5C  	ld		(COORDS), de
 230+ A29C C9           	ret
 231+ A29D
 232+ A29D              PrintStrTxt:
 233+ A29D 1A           	ld		a, (de)
 234+ A29E 13           	inc		de
 235+ A29F D5           	push	de
 236+ A2A0 32 81 5C     		ld		(CODE), a
 237+ A2A3 C5           		push	bc
 238+ A2A4 E5           			push	hl
 239+ A2A5 CD B4 A0     				call	PrintChar
 240+ A2A8 E1           			pop		hl
 241+ A2A9 C1           		pop		bc
 242+ A2AA
 243+ A2AA ED 5B B0 5C  		ld		de, (COORDS)
 244+ A2AE 1C           		inc		e
 245+ A2AF ED 53 B0 5C  		ld		(COORDS), de
 246+ A2B3 D1           	pop		de
 247+ A2B4 10 E7        	djnz	PrintStrTxt
 248+ A2B6 C9           	ret
 249+ A2B7
 250+ A2B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 251+ A2B7              ;Extract a line of text to fit exactly on a 64 screen line
 252+ A2B7              ;IN:	HL = current file pointer
 253+ A2B7              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 254+ A2B7              GetLine:
 255+ A2B7 11 39 A4     	ld		de, LineBuf
 256+ A2BA 06 40        	ld		b, COL_CNT
 257+ A2BC              GetLineLoop:
 258+ A2BC 7E           	ld		a, (hl)
 259+ A2BD 23           	inc		hl
 260+ A2BE
 261+ A2BE FE 0D        	cp		CHAR_CR
 262+ A2C0 28 29        	jr		z, GetLineSkip0A
 263+ A2C2
 264+ A2C2 FE 0A        	cp		CHAR_LF
 265+ A2C4 28 25        	jr		z, GetLineSkip0A
 266+ A2C6
 267+ A2C6 FE 09        	cp		CHAR_TAB
 268+ A2C8 20 07        	jr		nz, GetLineNext
 269+ A2CA
 270+ A2CA 3E 20        	ld		a, ' '
 271+ A2CC 12           	ld		(de), a
 272+ A2CD 13           	inc		de
 273+ A2CE 05           	dec		b
 274+ A2CF 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 275+ A2D1
 276+ A2D1              GetLineNext:
 277+ A2D1 FE 20        	cp		' '
 278+ A2D3 38 06        	jr		c, NotValid
 279+ A2D5
 280+ A2D5 FE 80        	cp		128
 281+ A2D7 30 02        	jr		nc, NotValid
 282+ A2D9 18 03        	jr		Valid
 283+ A2DB
 284+ A2DB              NotValid:
 285+ A2DB CD 62 A3     	call	ReplaceChars
 286+ A2DE
 287+ A2DE              Valid:
 288+ A2DE 12           	ld		(de), a
 289+ A2DF 13           	inc		de
 290+ A2E0 10 DA        	djnz	GetLineLoop
 291+ A2E2
 292+ A2E2              ;if line is exactly 64 char long, must skip the new line char(s)
 293+ A2E2              GetLineSkip0D:
 294+ A2E2 0E 00        	ld		c, 0
 295+ A2E4 3E 0D        	ld		a, CHAR_CR						;skip 0D
 296+ A2E6 BE           	cp		(hl)
 297+ A2E7 20 02        	jr		nz, GetLineSkip0A
 298+ A2E9 23           	inc		hl
 299+ A2EA 0C           	inc		c
 300+ A2EB
 301+ A2EB              GetLineSkip0A:						;skip 0A
 302+ A2EB 3E 0A        	ld		a, CHAR_LF
 303+ A2ED BE           	cp		(hl)
 304+ A2EE 20 02        	jr		nz, GetLineFill
 305+ A2F0 23           	inc		hl
 306+ A2F1 0C           	inc		c
 307+ A2F2
 308+ A2F2              GetLineFill:
 309+ A2F2 78           	ld		a, b
 310+ A2F3 B7           	or		a
 311+ A2F4 20 16        	jr		nz, GetLineFillLoop
 312+ A2F6
 313+ A2F6 79           	ld		a, c
 314+ A2F7 B7           	or		a
 315+ A2F8 C0           	ret		nz
 316+ A2F9
 317+ A2F9              	;wrap or not
 318+ A2F9 3A 7D A4     	ld		a, (WrapFlag)
 319+ A2FC B7           	or		a
 320+ A2FD C0           	ret		nz
 321+ A2FE
 322+ A2FE ~            	/*
 323+ A2FE ~            	ld		de, (FileEnd)
 324+ A2FE ~            	push	hl
 325+ A2FE ~            		ex		de, hl
 326+ A2FE ~            		or		a
 327+ A2FE ~            		sbc		hl, de
 328+ A2FE ~            		ld		b, h
 329+ A2FE ~            		ld		c, l
 330+ A2FE ~            	pop		hl
 331+ A2FE ~            	*/
 332+ A2FE 3E 0D        	ld		a, CHAR_CR
 333+ A300 01 40 00     	ld		bc, COL_CNT
 334+ A303 ED B1        	cpir
 335+ A305 C0           	ret		nz
 336+ A306 3E 0A        	ld		a, CHAR_LF
 337+ A308 BE           	cp		(hl)
 338+ A309 C0           	ret		nz
 339+ A30A 23           	inc		hl
 340+ A30B
 341+ A30B C9           	ret
 342+ A30C
 343+ A30C              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 344+ A30C 3E 20        	ld		a, ' '
 345+ A30E 12           	ld		(de), a
 346+ A30F 13           	inc		de
 347+ A310 10 FA        	djnz	GetLineFillLoop
 348+ A312 C9           	ret
 349+ A313
 350+ A313              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 351+ A313              PrintMsg:
 352+ A313 ED 5B B0 5C  	ld		de, (COORDS)
 353+ A317 D5           	push	de
 354+ A318 11 00 17     	ld		de, LINE_CNT<<8
 355+ A31B ED 53 B0 5C  	ld		(COORDS), de
 356+ A31F
 357+ A31F              	;Get current file pointer
 358+ A31F DD 6E 00     	ld		l, (ix)
 359+ A322 DD 66 01     	ld		h, (ix + 1)
 360+ A325 ED 4B 7E A4  	ld		bc, (FileBegin)
 361+ A329 B7           	or		a
 362+ A32A ED 42        	sbc		hl, bc
 363+ A32C
 364+ A32C              	;Divide by one percent length
 365+ A32C 7C           	ld		a, h
 366+ A32D 4D           	ld		c, l
 367+ A32E ED 5B 84 A4  	ld		de, (PROGR_PERC)
 368+ A332 CD B6 98     	call	Div2
 369+ A335
 370+ A335              	;Display %
 371+ A335 11 15 A4     	ld		de, MsgLinePr
 372+ A338 67           	ld		h, a
 373+ A339 69           	ld		l, c
 374+ A33A CD 6D 98     	call	Byte2Txt
 375+ A33D
 376+ A33D
 377+ A33D 2A 79 A4     	ld		hl, (CurLine)
 378+ A340 11 21 A4     	ld		de, MsgLineNo
 379+ A343 CD 62 98     	call	Word2Txt
 380+ A346
 381+ A346 11 0C A4     	ld		de, MsgLine
 382+ A349 06 2D        	ld		b, MsgLineLen
 383+ A34B CD 9D A2     	call	PrintStrTxt
 384+ A34E D1           	pop		de
 385+ A34F ED 53 B0 5C  	ld		(COORDS), DE
 386+ A353
 387+ A353 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 388+ A356 54           	ld		d, h
 389+ A357 5D           	ld		e, l
 390+ A358 13           	inc		de
 391+ A359 3E 28        	ld		a, (5 << 3) | 0
 392+ A35B 77           	ld		(hl), a
 393+ A35C 01 1F 00     	ld		bc, 31
 394+ A35F ED B0        	ldir
 395+ A361 C9           	ret
 396+ A362
 397+ A362
 398+ A362              ReplaceChars:
 399+ A362 E5           	push	hl
 400+ A363 C5           	push	bc
 401+ A364 21 F2 A3     		ld		hl, CharReplaceTbl
 402+ A367 06 0D        		ld		b, CharReplTblLen
 403+ A369              ReplaceSGCLoop:
 404+ A369 BE           		cp		(hl)
 405+ A36A 28 09        		jr		z, ReplaceMatch
 406+ A36C 23           		inc		hl
 407+ A36D 23           		inc		hl
 408+ A36E 10 F9        		djnz	ReplaceSGCLoop
 409+ A370
 410+ A370 3E 3F        		ld		a, '?'
 411+ A372 C1           		pop		bc
 412+ A373 E1           		pop		hl
 413+ A374 C9           	ret
 414+ A375
 415+ A375              ReplaceMatch:
 416+ A375 23           		inc		hl
 417+ A376 7E           		ld		a, (hl)
 418+ A377 C1           	pop		bc
 419+ A378 E1           	pop		hl
 420+ A379 C9           	ret
 421+ A37A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 422+ A37A
 423+ A37A              	include	"scroll.asm"
# file opened: scroll.asm
   1++A37A              ;Scrolling routines for UP/DOWN
   2++A37A              ;They use 2 tables of pointers of screen cell rows.
   3++A37A              ;One table has addresses in increasing order, for scroll down,
   4++A37A              ;the other in decreasing order, for scroll up, so the same
   5++A37A              ;scroll routine is used in both cases.
   6++A37A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++A37A
   8++A37A              ; Char Down
   9++A37A              ; Adjusts screen address HL to move eight pixels down on the display.
  10++A37A              ; enter: HL = valid screen address
  11++A37A              ; exit : HL = moves one character down
  12++A37A              ; used : AF, HL
  13++A37A              GetCellDown:
  14++A37A 7D           	ld a,l
  15++A37B C6 20        	add a,$20
  16++A37D 6F           	ld l,a
  17++A37E D0           	ret nc
  18++A37F 7C           	ld a,h
  19++A380 C6 08        	add a,$08
  20++A382 67           	ld h,a
  21++A383 C9           	ret
  22++A384
  23++A384              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++A384              ;Fills the two tables with pointers.
  25++A384              ScrollInit:
  26++A384 21 00 40     	ld		hl, 16384
  27++A387 06 17        	ld		b, LINE_CNT
  28++A389              FillScrLinesLoop:
  29++A389              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++A389 22 00 5B     	ld		(SCRLinesDown), hl
  31++A38C              	;inc. pointer in destination table (of pointers to lines)
  32++A38C ED 5B 8A A3  	ld		de, (FillScrLinesPtr)
  33++A390 13           	inc		de
  34++A391 13           	inc		de
  35++A392 ED 53 8A A3  	ld		(FillScrLinesPtr), de
  36++A396 CD 7A A3     	call	GetCellDown
  37++A399 10 EE        	djnz	FillScrLinesLoop
  38++A39B
  39++A39B              	;now fill the table in reverse
  40++A39B ED 73 AF A3  	ld		(FillScrLinesSPStore), sp
  41++A39F 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++A3A2 06 17        	ld		b, LINE_CNT
  43++A3A4 21 00 5B     	ld		hl, SCRLinesDown
  44++A3A7              FillScrLinesRev:
  45++A3A7 5E           	ld		e, (hl)
  46++A3A8 23           	inc		hl
  47++A3A9 56           	ld		d, (hl)
  48++A3AA 23           	inc		hl
  49++A3AB D5           	push	de
  50++A3AC 10 F9        	djnz	FillScrLinesRev
  51++A3AE              FillScrLinesSPStore	EQU	$ + 1
  52++A3AE 31 00 00     	ld		sp, 0
  53++A3B1 C9           	ret
  54++A3B2
  55++A3B2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++A3B2              ScrollUp:
  57++A3B2 21 2E 5B     	ld		hl, SCRLinesUp
  58++A3B5 18 03        	jr		Scroll
  59++A3B7
  60++A3B7              ScrollDown:
  61++A3B7 21 00 5B     	ld		hl, SCRLinesDown
  62++A3BA
  63++A3BA              Scroll:
  64++A3BA 22 C8 A3     	ld		(ScrollDownPtrDest), hl
  65++A3BD 23           	inc		hl
  66++A3BE 23           	inc		hl
  67++A3BF 22 CB A3     	ld		(ScrollDownPtrSrc), hl
  68++A3C2 0E 16        	ld		c, LINE_CNT - 1
  69++A3C4
  70++A3C4              ScrollDownLoop2:
  71++A3C4 06 04        	ld		b, 4
  72++A3C6              ScrollDownPtrDest	EQU	$ + 2
  73++A3C6 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++A3CA              ScrollDownPtrSrc	EQU	$ + 1
  75++A3CA 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++A3CD
  77++A3CD              ScrollDownLoop:					;copy a single char line
  78++A3CD C5           	push	bc
  79++A3CE 01 20 00     	ld		bc, 32
  80++A3D1 ED B0        	ldir
  81++A3D3 2B           	dec		hl
  82++A3D4 1B           	dec		de
  83++A3D5 24           	inc		h
  84++A3D6 14           	inc		d
  85++A3D7 01 20 00     	ld		bc, 32
  86++A3DA ED B8        	lddr
  87++A3DC 23           	inc		hl
  88++A3DD 13           	inc		de
  89++A3DE 24           	inc		h
  90++A3DF 14           	inc		d
  91++A3E0 C1           	pop		bc
  92++A3E1 10 EA        	djnz	ScrollDownLoop
  93++A3E3
  94++A3E3 0D           	dec		c
  95++A3E4 C8           	ret		z
  96++A3E5
  97++A3E5 2A CB A3     	ld		hl, (ScrollDownPtrSrc)
  98++A3E8 22 C8 A3     	ld		(ScrollDownPtrDest), hl
  99++A3EB 23           	inc		hl
 100++A3EC 23           	inc		hl
 101++A3ED 22 CB A3     	ld		(ScrollDownPtrSrc), hl
 102++A3F0 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 424+ A3F2
 425+ A3F2              CharReplaceTbl:
 426+ A3F2 B3 80        	defb	179, 128
 427+ A3F4 B4 81        	defb	180, 129
 428+ A3F6 BF 82        	defb	191, 130
 429+ A3F8 C0 83        	defb	192, 131
 430+ A3FA C1 84        	defb	193, 132
 431+ A3FC C2 85        	defb	194, 133
 432+ A3FE C3 86        	defb	195, 134
 433+ A400 C4 87        	defb	196, 135
 434+ A402 C5 88        	defb	197, 136
 435+ A404 D9 89        	defb	217, 137
 436+ A406 DA 8A        	defb	218, 138
 437+ A408 DB 8B        	defb	219, 139
 438+ A40A DC 8C        	defb	220, 140
 439+ A40C              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 440+ A40C
 441+ A40C 50 72 6F 67  MsgLine		defb	'Progress:'
 441+ A410 72 65 73 73
 441+ A414 3A
 442+ A415 20 20 20 25  MsgLinePr	defb	'   %; '
 442+ A419 3B 20
 443+ A41B 4C 69 6E 65  			defb	'Line: '
 443+ A41F 3A 20
 444+ A421 20 20 20 20  MsgLineNo	defb	'     ; '
 444+ A425 20 3B 20
 445+ A428 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 445+ A42C 61 70 20
 446+ A42F 20 4F 6E     MsgLineWrF	defb	' On'
 447+ A432 20 30 2D 45  			defb	' 0-Exit'
 447+ A436 78 69 74
 448+ A439              MsgLineLen	EQU		$ - MsgLine
 449+ A439
 450+ A439 20 20 20 20  LineBuf		defb	'                                                                '
 450+ A43D 20 20 20 20
 450+ A441 20 20 20 20
 450+ A445 20 20 20 20
 450+ A449 20 20 20 20
 450+ A44D 20 20 20 20
 450+ A451 20 20 20 20
 450+ A455 20 20 20 20
 450+ A459 20 20 20 20
 450+ A45D 20 20 20 20
 450+ A461 20 20 20 20
 450+ A465 20 20 20 20
 450+ A469 20 20 20 20
 450+ A46D 20 20 20 20
 450+ A471 20 20 20 20
 450+ A475 20 20 20 20
 451+ A479 00 00        CurLine		defw	0
 452+ A47B 00 00        MaxLine		defw	0
 453+ A47D 01           WrapFlag	defb	1
 454+ A47E 00 00        FileBegin	defw	0
 455+ A480 00 00        FileLen		defw	0
 456+ A482 00 00        FileEnd		defw	0
 457+ A484 00 00        PROGR_PERC	defw	0
 458+ A486
 459+ A486              SCRLinesDown	EQU $5b00
 460+ A486              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 461+ A486              End:
 462+ A486
# file closed: txtview.asm
1320  A486              	include "serial.asm"
# file opened: serial.asm
   1+ A486              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ A486              ;They work with 19200 theoretical speed.
   3+ A486              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ A486
   5+ A486              CBAUD	EQU	10	; CBAUD for 19200
   6+ A486              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ A486
   8+ A486
   9+ A486              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ A486              ; A=1 IF FRAMING ERROR
  11+ A486              ; USES BC,D _DOES NOT USE E!_
  12+ A486              SERRXI:
  12+ A486
  13+ A486 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ A489 3E 30        	LD	A,30H		; ASSERT RTS
  15+ A48B D3 EF        	OUT	(0EFH),A
  16+ A48D
  17+ A48D              	; WAIT FOR START
  18+ A48D              SERWSL:
  19+ A48D 0B           	DEC	BC
  20+ A48E AF           	XOR	A
  21+ A48F B8           	CP	B
  22+ A490 20 03        	JR	NZ,SERWS
  23+ A492 B9           	CP	C
  24+ A493 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ A495 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ A497 CB 7F        	BIT	7,A
  27+ A499 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ A49B
  29+ A49B              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ A49B              ; OF BIT 0
  31+ A49B 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ A49D 0E 08        	LD	C,8		; 8 DATA BITS
  33+ A49F
  34+ A49F              ; GET AND SHIFT BITS
  35+ A49F              SERRL:
  36+ A49F 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ A4A1 00           	NOP			; 4 (TIMING)
  38+ A4A2 00           	NOP			; 4 (TIMING)
  39+ A4A3 00           	NOP			; 4 (TIMING)
  40+ A4A4 DB F7        	IN	A,(0F7H)	; 11
  41+ A4A6 17           	RLA			; 4
  42+ A4A7 CB 1A        	RR	D		; 8
  43+ A4A9 06 0A        	LD	B,CBAUD		; 7
  44+ A4AB 0D           	DEC	C		; 4
  45+ A4AC 20 F1        	JR	NZ,SERRL	; 12
  46+ A4AE
  47+ A4AE              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ A4AE              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ A4AE              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ A4AE              ; IDLE UNTIL NEXT START BIT
  51+ A4AE 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ A4B0 D3 EF        	OUT	(0EFH),A
  53+ A4B2
  54+ A4B2 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ A4B4              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ A4B4              SERWIL:
  57+ A4B4 05           	DEC	B
  58+ A4B5 28 0E        	JR	Z,SERRTF
  59+ A4B7 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ A4B9 CB 7F        	BIT	7,A
  61+ A4BB 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ A4BD
  63+ A4BD              ; RECEIVE ENDED AND LINE IS IDLE
  64+ A4BD 7A           	LD	A,D
  65+ A4BE 2F           	CPL			; INVERT BITS
  66+ A4BF 57           	LD	D,A
  67+ A4C0 AF           	XOR	A		; 0 = SUCCESS
  68+ A4C1 C9           	RET
  69+ A4C2
  70+ A4C2              ; TIMEOUT
  71+ A4C2              SERRTO:
  72+ A4C2 3E FF        	LD	A,0FFH
  73+ A4C4 C9           	RET
  74+ A4C5
  75+ A4C5              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ A4C5              SERRTF:
  77+ A4C5 3E 01        	LD	A,01H
  78+ A4C7 C9           	RET
  79+ A4C8
  80+ A4C8
  81+ A4C8
  82+ A4C8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ A4C8              SERRB:
  83+ A4C8
  84+ A4C8              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ A4C8              ; BITMAPPED OPTIONS IN E:
  86+ A4C8              ; XXXXXXIT
  87+ A4C8              ; I SET = leave Interrupts disabled at exit
  88+ A4C8              ; T SET = return after Timeout
  89+ A4C8              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ A4C8              ; BC=NUMBER OF BYTES RECEIVED
  91+ A4C8              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ A4C8 F3           	DI
  93+ A4C9 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ A4CA              				; OF RECEIVED BYTES
  95+ A4CA
  96+ A4CA              SERRBL:
  97+ A4CA C5           	PUSH	BC
  98+ A4CB CD 86 A4     	CALL	SERRXI
  99+ A4CE C1           	POP	BC
 100+ A4CF B7           	OR	A
 101+ A4D0 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ A4D2 72           	LD	(HL),D
 103+ A4D3 23           	INC	HL
 104+ A4D4 0B           	DEC	BC
 105+ A4D5 AF           	XOR	A
 106+ A4D6 B8           	CP	B
 107+ A4D7 20 F1        	JR	NZ,SERRBL
 108+ A4D9 B9           	CP	C
 109+ A4DA 20 EE        	JR	NZ,SERRBL
 110+ A4DC              ; FULL RECEIVE
 111+ A4DC C1           	POP	BC		; RESTORE BYTE COUNT
 112+ A4DD
 113+ A4DD              SERRBX:				; EXIT
 114+ A4DD CB 4B        	BIT	1,E
 115+ A4DF C0           	RET	NZ
 116+ A4E0 FB           	EI
 117+ A4E1 C9           	RET
 118+ A4E2
 119+ A4E2              SERRBT:
 120+ A4E2 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ A4E4 28 04        	JR	Z,SERRBC
 122+ A4E6 CB 43        	BIT	0,E
 123+ A4E8 28 E0        	JR	Z,SERRBL
 124+ A4EA
 125+ A4EA              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ A4EA EB           	EX	DE,HL		; PRESERVE HL
 127+ A4EB E1           	POP	HL		; GET INITIAL COUNT
 128+ A4EC 37           	SCF
 129+ A4ED 3F           	CCF
 130+ A4EE ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ A4F0 44           	LD	B,H
 132+ A4F1 4D           	LD	C,L		; BC = COUNT
 133+ A4F2 EB           	EX	DE,HL		; RESTORE HL
 134+ A4F3
 135+ A4F3 18 E8        	JR	SERRBX
 136+ A4F5
 137+ A4F5              SERRX:
 137+ A4F5
 138+ A4F5              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ A4F5              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ A4F5              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ A4F5 F3           	DI
 142+ A4F6 CD 86 A4     	CALL	SERRXI
 143+ A4F9 FB           	EI
 144+ A4FA C9           	RET
 145+ A4FB
 146+ A4FB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ A4FB              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ A4FB              SERTB:
 148+ A4FB
 149+ A4FB 7E           	LD	A,(HL)
 150+ A4FC C5           	PUSH	BC
 151+ A4FD CD 08 A5     		CALL	SERTX
 152+ A500 C1           	POP	BC
 153+ A501 23           	INC	HL
 154+ A502 0B           	DEC BC
 155+ A503 78           	LD	A, B
 156+ A504 B1           	OR	C
 157+ A505 20 F4        	JR	NZ, SERTB
 158+ A507 C9           	RET
 159+ A508
 160+ A508              ; SEND CHAR ROUTINE
 161+ A508              SERTX:
 161+ A508
 162+ A508 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ A509 57           	LD	D,A	; WILL SHIFT FROM D
 164+ A50A F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ A50B 3E 01        	LD	A,01H
 166+ A50D D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ A50F 1E 20        	LD	E,20H	; PORT MASK
 168+ A511 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ A513 3E 01        	LD	A,1
 170+ A515 C3 1C A5     	JP	SBIT
 171+ A518
 172+ A518 AF           SHLOOP:	XOR	A		; 4
 173+ A519 CB 3A        	SRL	D		; 8
 174+ A51B 17           	RLA			; 4
 175+ A51C              SBIT:
 176+ A51C B3           	OR	E		; 4
 177+ A51D D3 EF        	OUT	(0EFH),A	; 11
 178+ A51F 06 0A        	LD	B,CBAUD		; 7
 179+ A521              SBITDL:
 180+ A521 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ A523 00           	NOP			; 4 (TIMING)
 182+ A524 0D           	DEC	C		; 4
 183+ A525 20 F1        	JR	NZ,SHLOOP	; 12
 184+ A527              ; STOP BIT
 185+ A527 3E 20        	LD	A,20H
 186+ A529 D3 EF        	OUT	(0EFH),A
 187+ A52B 06 0A        	LD	B,CBAUD
 188+ A52D 10 FE        STOPL:	DJNZ	STOPL
 189+ A52F FB           	EI
 190+ A530 C9           	RET
# file closed: serial.asm
1321  A531
1322  A531              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1323  A531 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1323  A535 6F 6D 6D 61
1323  A539 6E 64 65 72
1323  A53D 20 31 2E B0
1324  A541 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1324  A545 67 65 2E 63
1324  A549 68 69 72 74
1324  A54D 6F 61 63 E1
1325  A551 40 67 6D 61  VerMsg3			DEFM	'@gmail.com MAY2', '3' + $80
1325  A555 69 6C 2E 63
1325  A559 6F 6D 20 4D
1325  A55D 41 59 32 B3
1326  A561 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1326  A565 72 61 6D 20
1326  A569 49 6E 66 6F
1326  A56D 20 20 20 A0
1327  A571              ;MsgCompModel	DEFB	'Model: '
1328  A571              ;MsgCompModelName DEFB	'        ', ' ' | $80
1329  A571              ;MsgIF1Version	DEFB	'IF1  : '
1330  A571              ;MsgIF1Date		DEFB	'       ', ' ' | $80
1331  A571 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1331  A575 20 49 6E 66
1331  A579 6F 20 20 20
1331  A57D 20 20 20 A0
1332  A581 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1332  A585 20 49 6E 66
1332  A589 6F 20 20 20
1332  A58D 20 20 20 A0
1333  A591 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1333  A595 61 67 65 73
1333  A599 20 20 20 20
1333  A59D 20 20 20 A0
1334  A5A1 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1334  A5A5 20 32 2D 42
1334  A5A9 3A 20 33 2D
1334  A5AD 56 69 65 77
1334  A5B1 20 34 2D 50
1334  A5B5 72 6F 70 20
1334  A5B9 35 2D 43 6F
1334  A5BD 70 79 20 36
1334  A5C1 2D 52 65 6E
1334  A5C5 20 37 2D 41
1334  A5C9 74 74 72 20
1334  A5CD 38 2D 44 65
1334  A5D1 6C 20 39 2D
1334  A5D5 44 69 73 6B
1334  A5D9 20 30 2D 45
1334  A5DD 78 69 F4
1335  A5E0 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1335  A5E4 65 20 20 20
1335  A5E8 3A 20 20 20
1335  A5EC 20 20 20
1336  A5EF C1           MsgDriveLet		DEFM	'A' + $80
1337  A5F0 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1337  A5F4 73 20 20 20
1337  A5F8 3A
1338  A5F9 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1338  A5FD 31 32 B8
1339  A600 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1339  A604 20 4B 42 20
1339  A608 3A
1340  A609 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1340  A60D 36 33 B6
1341  A610 45 72 72 6F  MsgErr			DEFM	'Error code '
1341  A614 72 20 63 6F
1341  A618 64 65 20
1342  A61B 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1342  A61F A0
1343  A620 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1343  A624 69 6E 67 20
1343  A628 50 72 6F 67
1343  A62C 72 61 ED
1344  A62F 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1344  A633 69 6E 67 20
1344  A637 53 43 52 45
1344  A63B 45 4E A4
1345  A63E 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1345  A642 69 6E 67 20
1345  A646 43 4F 44 45
1345  A64A 20 28 21 A9
1346  A64E 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1346  A652 20 4C 65 6E
1346  A656 3A
1347  A657 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1347  A65B 30 20 CB
1348  A65E 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1348  A662 69 62 20 20
1348  A666 3A
1349  A667 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1349  A66B 48 49 C4
1350  A66E 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1350  A672 54 79 70 65
1350  A676 3A
1351  A677 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1351  A67B 20 20 20 20
1351  A67F 20 A0
1352  A681 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1352  A685 72 61 ED
1353  A688 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1353  A68C 73 20 A0
1354  A68F 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1354  A693 45 4E A4
1355  A696 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1355  A69A 41 72 F2
1356  A69D 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1356  A6A1 41 72 F2
1357  A6A4 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1357  A6A8 20 20 A0
1358  A6AB 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1358  A6AF 20 20 A0
1359  A6B2 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1359  A6B6 74 68 20 20
1359  A6BA 3A
1360  A6BB 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1360  A6BF 35 20 C2
1361  A6C2 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1361  A6C6 74 20 20 20
1361  A6CA 3A
1362  A6CB 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1362  A6CF 35 20 A0
1363  A6D2 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1363  A6D6 69 6E 67 20
1363  A6DA 68 65 61 64
1363  A6DE 65 F2
1364  A6E0 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1364  A6E4 20 20 20 20
1364  A6E8 20 20 20 20
1364  A6EC 20 20 20 A0
1365  A6F0 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1365  A6F4 66 69 6C 65
1365  A6F8 3F 20 79 2F
1365  A6FC EE
1366  A6FD 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1366  A701 52 2F 4F 3F
1366  A705 20 79 2F EE
1367  A709 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1367  A70D 48 49 44 3F
1367  A711 20 79 2F EE
1368  A715 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1368  A719 3F 6E 6F 6E
1368  A71D 65 3D 61 62
1368  A721 6F 72 74 BA
1369  A725 43 6F 70 79  MsgAskCopyDest	DEFM	'Copy to A/B/COM','?' | $80
1369  A729 20 74 6F 20
1369  A72D 41 2F 42 2F
1369  A731 43 4F 4D BF
1370  A735 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1370  A739 69 6E 67 20
1370  A73D 74 6F 20
1371  A740 41 3A A0     MsgCopyFileDrv	DEFM	'A:', ' ' | $80
1372  A743 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1372  A747 20 6F 70 74
1372  A74B 69 6F 6E 73
1372  A74F BA
1373  A750 30 2E 20 42  MsgMenu1		DEFM	'0. Bac', 'k' | $80
1373  A754 61 63 EB
1374  A757 31 2E 20 46  MsgMenu2		DEFM	'1. Format '
1374  A75B 6F 72 6D 61
1374  A75F 74 20
1375  A761 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1376  A763 32 2E 20 43  MsgMenu3		DEFM	'2. Copy '
1376  A767 6F 70 79 20
1377  A76B 41 3A 2D 3E  MsgMenu3Drv1	DEFM	'A:->'
1378  A76F 42 BA        MsgMenu3Drv2	DEFM	'B', ':' | $80
1379  A771 33 2E 20 43  MsgMenu4		DEFM	'3. Copy '
1379  A775 6F 70 79 20
1380  A779 41 3A 2D 3E  MsgMenu4Drv1	DEFM	'A:->CO', 'M' | $80
1380  A77D 43 4F CD
1381  A780 34 2E 20 43  MsgMenu5		DEFM	'4. Copy COM->'
1381  A784 6F 70 79 20
1381  A788 43 4F 4D 2D
1381  A78C 3E
1382  A78D 41 BA        MsgMenu5Drv1	DEFM	'A', ':' | $80
1383  A78F 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1383  A793 61 74 74 69
1383  A797 6E 67 20
1384  A79A 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1385  A79C 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1385  A7A0 62 6C 6F 63
1385  A7A4 6B 73 20 6C
1385  A7A8 65 66 F4
1386  A7AB 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1386  A7AF 77 72 69 74
1386  A7B3 65 3F 20 79
1386  A7B7 2F EE
1387  A7B9 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1387  A7BD 20 6E 61 6D
1387  A7C1 65 20 65 78
1387  A7C5 69 73 74 F3
1388  A7C9 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1388  A7CD 53 4F 55 52
1388  A7D1 43 45 20 64
1388  A7D5 69 73 EB
1389  A7D8 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1389  A7DC 44 45 53 54
1389  A7E0 2E 20 64 69
1389  A7E4 73 6B A0
1390  A7E7 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1390  A7EB 73 20 61 6E
1390  A7EF 79 20 6B 65
1390  A7F3 F9
1391  A7F4
1392  A7F4              	IFNDEF	_REAL_HW_
1393  A7F4 ~            FontTable:
1394  A7F4 ~            	incbin "cpmfnt.bin"
1395  A7F4              	ENDIF
1396  A7F4              EndCode:
1397  A7F4
1398  A7F4              ;Unalocated variables
1399  A7F4              UnallocStart	EQU		EndCode
1400  A7F4              FileCnt			EQU		UnallocStart			;File counter, 1B
1401  A7F4              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1402  A7F4              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1403  A7F4              CursorAddr		EQU		SelFile + 1				;2 B
1404  A7F4              AUCnt			EQU		CursorAddr + 2			;2 B
1405  A7F4              SelFileCache	EQU		AUCnt + 2				;2 B
1406  A7F4
1407  A7F4              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1408  A7F4              ;FS block list constants
1409  A7F4              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1410  A7F4              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1411  A7F4              UsedBlockListSz		EQU 320 * 2 + 2							;640
1412  A7F4
1413  A7F4              	IFDEF	_REAL_HW_
1414  A7F4              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1415  A7F4              DataBuf			EQU		FontTable + 872
1416  A7F4              	ELSE
1417  A7F4 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1418  A7F4              	ENDIF
1419  A7F4
1420  A7F4              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1421  A7F4
1422  A7F4              CopyFileFCB		EQU	DataBuf
1423  A7F4              CopyFileRes		EQU DataBuf + 2
1424  A7F4              CopyFileDMAAddr	EQU	DataBuf + 3
1425  A7F4              CopyFileRCExtRead	EQU	DataBuf + 5
1426  A7F4              CopyFileRCExtWrite	EQU	DataBuf + 7
1427  A7F4              FilePosRead		EQU	DataBuf + 9
1428  A7F4              FilePosWrite	EQU	DataBuf + 11
1429  A7F4              CopyFileSectCnt EQU DataBuf + 13
1430  A7F4              CopyFileSrc		EQU DataBuf + 15				;drive 1B + name 11B
1431  A7F4              CopyFileDst		EQU DataBuf + 27
1432  A7F4
1433  A7F4              ;File viewer constants
1434  A7F4              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1435  A7F4              ;File buffer size, without index
1436  A7F4              FileIdxSize		EQU		3 * 1024
1437  A7F4              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1438  A7F4              ;Set a few KB aside for file indexing
1439  A7F4              FileIdx			EQU		FileData + FileDataSize
1440  A7F4
1441  A7F4
1442  A7F4              ;Copy buffer size, follows
1443  A7F4              CopyDiskBuf			EQU DataBuf
1444  A7F4
1445  A7F4              ;We can use up to about 30KB free space if we load at address 24000.
1446  A7F4              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1447  A7F4              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1448  A7F4              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1449  A7F4              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1450  A7F4              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1451  A7F4
1452  A7F4              	DISPLAY "DataBuf: ", /D,DataBuf
1453  A7F4              	DISPLAY "BinSize: ", /D, EndCode - Start
1454  A7F4              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1455  A7F4              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x98B3   NoSub
0x98AC   DivLoop
0x481D   MAX_RAM_FREE
0x0048   MAX_SECT_RAM
0x0C00   FileIdxSize
0xB6EA X CopyFileRCExtWrite
0xB6E8 X CopyFileRCExtRead
0x0282   UsedBlockListSz
0xA7F4   UnallocStart
0xA7F4   EndCode
0xA52D   STOPL
0xA518   SHLOOP
0xA51C   SBIT
0xA521   SBITDL
0xA508   SERTX
0xA4F5 X SERRX
0xA4EA   SERRBC
0xA4DD   SERRBX
0xA4E2   SERRBT
0xA4CA   SERRBL
0xA4B7 X SERWI
0xA4C5   SERRTF
0xA4B4   SERWIL
0xA49F   SERRL
0xA4C2   SERRTO
0xA495   SERWS
0xA48D   SERWSL
0xA486   SERRXI
0x000A   CBAUD
0xA486 X End
0xA47B X MaxLine
0xA428 X MsgLineWrap
0xA3CD   ScrollDownLoop
0xA3C4   ScrollDownLoop2
0xA3CB   ScrollDownPtrSrc
0xA3C8   ScrollDownPtrDest
0xA3BA   Scroll
0xA3A7   FillScrLinesRev
0x5B2E   SCRLinesUp
0xA3AF   FillScrLinesSPStore
0x5B00   SCRLinesDown
0xA38A   FillScrLinesPtr
0xA389   FillScrLinesLoop
0xA37A   GetCellDown
0xA375   ReplaceMatch
0xA369   ReplaceSGCLoop
0x000D   CharReplTblLen
0xA3F2   CharReplaceTbl
0x002D   MsgLineLen
0xA40C   MsgLine
0xA421   MsgLineNo
0xA415   MsgLinePr
0xA30C   GetLineFillLoop
0xA2F2   GetLineFill
0xA362   ReplaceChars
0xA2DE   Valid
0xA2DB   NotValid
0xA2E2   GetLineSkip0D
0xA2D1   GetLineNext
0xA2EB   GetLineSkip0A
0xA2BC   GetLineLoop
0xA29D   PrintStrTxt
0xA439   LineBuf
0xA3B7   ScrollDown
0xA3B2   ScrollUp
0xA26E   CheckBegin
0xA42F   MsgLineWrF
0xA200   NoWrap
0xA47D   WrapFlag
0xA20F   Up
0xA23A   Down
0xA1BA   GetKey
0xA1C9   ViewFileEOF
0xA27E   CheckEnd
0xA289   PrintLine
0xA2B7   GetLine
0xF3E3   FileIdx
0xA313   PrintMsg
0xA484   PROGR_PERC
0xA479   CurLine
0xA384   ScrollInit
0xA480   FileLen
0xA482   FileEnd
0xA47E   FileBegin
0x5CB0   COORDS
0x001A   EOF_MARKER
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0xA125   ReadStrPrint
0xA115   ReadStrChar
0xA0F8   ReadStringLoop
0xA0EC   Store
0xA0EB   NoTurn
0xA0E0   PrintCharLine
0xA0CC X PrintChar3
0xA077   DrawCursorLoop
0xA057   DrawVLinesLoop
0xA06A   PrintChar2
0xA035   DrawUpLine
0xA037   ChrParam
0xA028 X DrawHLine
0xA017   DrawLineLoop
0xA024   LineDir
0xA014   StoreDir
0xA012   VertDir
0xA009   DrawLine
0xA005   StrClr
0x9FB8   GoodChar
0xA134   CurrScrAddr
0xB37B   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x9F38   ReadWriteFileSectionLoop
0x9F56   ReadWriteFileSectionEnd
0xB6E6   CopyFileDMAAddr
0xB6E3   CopyFileFCB
0x9EF7   ReadWriteFileSection
0x3C00   FileDataSize
0x9F67   CopyFilePtr2
0x9F1D   CopyFilePtr
0x9F4B   CopyFileOperAddr2
0x9F26   CopyFileOperAddr1
0xB6F0   CopyFileSectCnt
0x9EDE   WriteFileSection
0x9EA1   CopyFileNotSameDrive2
0xA7C9   MsgInsertSrcDsk
0x9E6B   CopyFileNotSameDrive1
0x9E42   CopyFileLoop
0xB6EE   FilePosWrite
0x9EBB   CopyFileEnd
0xA7AB   MsgFileOverwrite
0x9E1A   CopyFileDestNotExist
0xA7E7   MsgPressAnyKey
0xA7D8   MsgInsertDstDsk
0x9DFD   CopyFileCheckOverwrite
0x9DDE   CopyFileSameDrive
0xA735   MsgCopyFile
0xA740   MsgCopyFileDrv
0xA725   MsgAskCopyDest
0xB6F2   CopyFileSrc
0x9D59 X FileAttribSet
0x9D12   GetFileSizeMul
0x9D18   GetFileSizeEnd
0x9D10   GetFileSizeOK
0x9CF0   BDOSSetRandFilePtr
0x9CEC   BDOSSetDMA
0x9CDE   BDOSWriteFileBlockRandom
0x9CDA   BDOSReadFileBlockRandom
0x9CD6   BDOSWriteFileBlockSeq
0x9CD2   BDOSReadFileBlockSeq
0x9CCE   BDOSCloseFile
0x9CCA   BDOSOpenFile
0x9CC6   BDOSCreateFile
0x9CBC   DestroyChannel
0x9CA6   CreateChannel
0x9CA6 X BDOSGetCurrentDisk
0x9CA6 X BDOSGetDiskRO
0x9CA6 X BDOSMakeDiskRO
0x9CE2   BDOS
0x9C8A   InterleaveTbl
0x9C88 X PrmIntrlvTbl
0x9C87 X PrmSpinUp
0x9C86 X PrmHeadLoad
0x9C84 X PrmDevType
0x9C7F X RWTSResTmp
0x9C7E X RWTSResVolNo
0x9C84   BasPrmTbl
0x9C7A X RWTSPrmTbl
0x9C78 X RWTSExtBuf
0x9C75 X RWTSSector
0x9C73 X RWTSVolNo
0x9C71 X RWTSBlockType
0x9C68   CopyMsg
0x9C5C   SearchMsgEnd
0x9C65   SaveMsg
0x9C53   IF1Paged
0x9C21   IF1Call
0x9C1C   IsFileHeaderValidLoop
0x9CF4   GetFileSize
0x9C00   ReadFileHeaderIsTextFile
0x9C19   IsFileHeaderValid
0x9C15   ReadHeaderEnd
0x9BBA   CacheNotFinished
0x9C9A   BDOSInit
0x9C9D   BDOSSelectDisk
0x9B57   FileReadLoop
0x9B4B X FileLoadHeader
0x9B5D   FileLoadNoHeader
0x9B6B   FileFree
0x9B27   MisMatch
0x9B1F   Compare
0x9B1D   StrCmp
0x9AD4   CopyDiskFromCOMLoop
0xA4C8   SERRB
0x9A70   CopyDiskToCOMLoop
0xA4FB   SERTB
0x9A29   CopyDiskLoopWriteLoop
0x9A03   CopyDiskLoopReadLoop
0xB6E3   CopyDiskBuf
0x99FC   CopyDiskLoopRead
0x0009   MAX_AU_RAM
0xA79C   MsgBlocksLeft
0x99D9   CopyDiskLoop
0xB0FB   UsedBlockListBlk
0x9B83   WriteDiskSectors
0x99CE X WriteFSBlockLoop
0x99C5   WriteFSBlock
0x9B70   ReadDiskSectors
0x99C1 X ReadFSBlockLoop
0x99B8   ReadFSBlock
0x99AA   ReadUsedBlocksSkip
0x998D   ReadUsedBlocksLoop2
0x99AD   ReadUsedBlocksSkip2
0x997D   ReadUsedBlocksLoop
0xB0F9   UsedBlockListCnt
0x9960   ReadUsedBlocksList
0x9959   CheckAUEnd
0x9945   CheckAU
0x992E   FirstAU
0x9928   Track0
0x9913   AU2TS
0x9C7D   RWTSRes
0x98F7   WriteOneDiskSector
0x9C74   RWTSTrack
0x9C76   RWTSDMA
0x98EC   ReadOneDiskSector
0x9C71   RWTSParams
0x9C7C   RWTSCmd
0x98E0   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x001F X STR_MSG_IF1_LEN
0x23F0 X STR_MSG_IF1_91
0x27F0 X STR_MSG_IF1_2000
0x0020 X STR_MSG_BASIC_LEN
0x1539 X STR_MSG_BASIC
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x98DA   NoAdd
0x98D4   MulLoop
0x98BB   Div2Loop
0x98B6   Div2
0x98A9   Div
0x98A0   DivNrLoop
0x989E   DigitLoop
0x988F   Byte2Txt_
0x9878   StrippLeading0
0x9883   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0xA551   VerMsg3
0xA541   VerMsg2
0xA531   VerMsg1
0x9844   DontInc
0x9838   ReadAllHeadersEnd
0x9823   AKey
0x9F78   KbdHit
0x9808   NextFile
0xA6B2   MsgFileLen
0xA66E   MsgFileType
0xA6C2   MsgFileStart
0x97C7   PrintStartStr
0xA6CB   MsgFileStartN
0xA6AB   MsgNA
0x97B9   PrintStart
0x0007   HDR_LINE
0x9794   PrintByteStart
0x978C   PrintProgStart
0xA6BB   MsgFileLenN
0x9772 X PrepFileLenText
0xA6A4   MsgFileTypeText
0xA688   MsgFileTypeByte
0xA68F   MsgFileTypeSCR
0x9758   NotScr
0x9763   CheckText
0xA696   MsgFileTypeChrA
0x973B   CheckByte
0x0002   CHAR_TYPE
0xA69D   MsgFileTypeNoA
0x972C   CheckChrArr
0x0001   NUMB_TYPE
0x976C   PrepFileLen
0x9C85 X PrmStepRate
0x97E5   MoveMsg
0xA677   MsgFileTypeN
0xA681   MsgFileTypePrg
0x971D   CheckNoArr
0x000B   CACHE_FIRST_AU
0x979C   HeadNotRead
0xA65E   MsgFileAttr
0x96EE   AttrEnd
0x96E2   NotSYS
0x96CE   CheckSys
0x96BC   NotRO
0xA667   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x97AE   PrintStartNotRead
0xA64E   MsgFileSzDsk
0xA657   MsgFileSzDskN
0xA1D1   PrintLoop2
0x9678   ViewFileEnd
0xA196   PrintLoop
0xA138   InitViewer
0xB7E3   FileData
0x9EBC   ReadFileSection
0x9652   ViewFileLoop
0xB6EC   FilePosRead
0x9C27   LoadProgram
0xA620   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0xA62F   MsgLoadingSCR
0x0003   HDR_ADDR
0x9B6B   IF1FileLoadEnd
0x5B00   PRN_BUF
0x9B2A   IF1FileLoad
0xA63E   MsgLoadingCODE
0x95F1 X HandleFileCODE
0x961A   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x9648   HandleFileText
0x0003   BYTE_TYPE
0x9638   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x95BB   FindExtEnd
0x9BAF   FindCache
0x95CA   GetFileNamesEnd
0x0009   HDR_SZ
0x9596   FindExt
0x000C   EXT_IDX
0x9931   CheckExtAlloc
0x95BD   NextExt
0x0000   EXT_DEL_FLAG
0x9545   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x9522   DisplayFilenamesLoop
0x9508   LineOK
0x5CB1   LINE
0x5CB0   COL
0xA0B4   PrintChar
0x5C81   CODE
0x94E2   DispLoop
0x94E0   DisplayFilename
0xA07C   MoveCursor
0x9AB7   CopyDiskFromCOM
0x9A5B   CopyDiskToCOM
0x94C4   CheckExtra4
0x99D2   CopyDisk
0x94BA   CheckExtra3
0x9902   FormatDisk
0xA78F   MsgFormat
0x94B1   CheckExtra2
0x94CF   ExtraMenuExit
0x947D X CheckKeyDiskMenuLoop
0xA780   MsgMenu5
0xA771   MsgMenu4
0xA763   MsgMenu3
0xA757   MsgMenu2
0xA750   MsgMenu1
0x941E X CheckKeyDiskMenu
0xA76F   MsgMenu3Drv2
0xA78D   MsgMenu5Drv1
0xA779   MsgMenu4Drv1
0xA76B   MsgMenu3Drv1
0xA79A   MsgFormatDrv
0xA761   MsgMenu2Drv
0xA743   MsgMenu0
0x94D2   CheckKeyExit
0x9D38   ChangeFileAttrib
0x93E0   AttrChange
0xA709   MsgSetSYS
0x93C8   CheckSYS
0xA6FD   MsgSetRO
0x93EF   CheckKeyExtra
0x9D1E   DeleteFile
0x939A   DoFileDelete
0xA6F0   MsgDelete
0x93A7   CheckKeyAttrib
0x9D62   RenameFile
0xA7B9   MsgFileExists
0x934A   RenameFileNotExist
0x9D2A   DoesFileExist
0x9356   RenameCanceled
0xA0F2   ReadString
0x000B   NAMELEN
0xA715   MsgNewFileName
0x936F   CheckKeyDel
0x9649   ViewFile
0x92EE   CheckKeyRename
0x0001   DRIVE_B_CPM
0x92DD   CheckKeyView
0x93E9   SelectDrive
0x92D4   CheckKeyDriveB
0x97EB   ReadAllHeaders
0x92CB   CheckKeyDriveA
0xB6FE   CopyFileDst
0x929A X CopyFileDontOverwrite
0x929A   CopyFileOK
0xB6E5   CopyFileRes
0x9D85   CopyFile
0x92BA   CheckKeyFileInfo
0xA6E0   MsgClear
0x9BC0   ReadFileHeader
0xA6D2   MsgReadingExt
0x926B   CheckKeyCopy
0x95CB   HandleFile
0x9240   CheckKeyInfo
0x000D   KEY_ENTER
0x9235   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x9224   CheckLeft
0x0009   KEY_RIGHT
0x920E   CheckRight
0x000B   KEY_UP
0x94DA   MoveIt
0x91FD   CheckUp
0x000A   KEY_DOWN
0x9679   DisplayFileInfo
0xA7FB   SelFileCache
0x98C9   Mul
0x91CE   CalcFileCache
0xA600   MsgFreeSpace
0x9862   Word2Txt
0xA609   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0xA7F9   AUCnt
0xA5F0   MsgFilesCnt
0xA5F9   MsgFilesCntNo
0xA7F4   FileCnt
0x9FB1   PrintStr
0xA5E0   MsgDrive
0xA5EF   MsgDriveLet
0x9C40   SetFastKeys
0xA071   DrawCursor
0x0028   SCR_SEL_CLR
0xA591   MsgMessages
0x0008   LST_FILE_INFO
0xA581   MsgFileInf
0x0004   LST_DISK_INFO
0xA571   MsgDskInf
0x0000   LST_PROG_INFO
0xA561   MsgSysInf
0xA5A1   BtnBar
0x0028   SCR_LBL_CLR
0xA052   DrawVLines
0x0084   CHR_DC
0xA7F7   CursorAddr
0xA136   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x9F91   ClrScr
0x5CB0   LineCol
0x0000   LST_FIRST_LINE
0xA7F5   NameCol
0x0010   LST_FIRST_COL
0xA7F6   SelFile
0xB6E3   DataBuf
0x9C4B   GetErrMsg
0x5C3A   ERRNR
0x90EA   HCRunEnd
0x91DF   ReadKeyLoop
0x9185   DisplayDiskInfo
0x9512   DisplayFilenames
0x9847   PrintIntro
0x9122   InitUI
0x90DB   HCRunMain
0x9532   GetFileNames
0x9C72   RWTSDrive
0x0000   DRIVE_A_CPM
0x9F75   ReadChar
0x9FD9   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x000E   LST_LINE_MSG
0xA610   MsgErr
0x986D   Byte2Txt
0xA61B   MsgErrCode
0x90D8   HCRunCacheFiles
0x9B96   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0xA7FD   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0xB6E3   TrackBuf
0x909A   HCRunInitDisk
0x90F0   ErrorHandler
0x5C3D   ERRSP
0x98DD   IF1Init
0x9F7B   InitFonts
0x9088   Start
