# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _ROM_FNT_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM, hence 32768.
  11  0000              	ORG 30000
  12  7530
  13  7530              Start:
  14  7530              	IFDEF _ROM_FNT_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  7530 CD 59 81     		call InitFonts
  16  7533              	ENDIF
  17  7533 CD AE 7C     	call IF1Init
  18  7536
  19  7536              	;install error handler
  20  7536 2A 3D 5C     	ld		hl, (ERRSP)
  21  7539 E5           	push	hl
  22  753A 21 90 75     	ld		hl, ErrorHandler
  23  753D E5           	push	hl
  24  753E ED 73 3D 5C  	ld		(ERRSP), sp
  25  7542
  26  7542              HCRunInitDisk:
  27  7542              	;Set track buffer to del marker
  28  7542 21 20 95     	ld		hl, TrackBuf
  29  7545 54           	ld		d, h
  30  7546 5D           	ld		e, l
  31  7547 13           	inc		de
  32  7548 01 00 10     	ld		bc, SPT*SECT_SZ
  33  754B 36 E5        	ld		(hl), DEL_MARKER
  34  754D ED B0        	ldir
  35  754F
  36  754F              	;Invalidate file cache
  37  754F 21 BC 88     	ld		hl, FileCache
  38  7552 54           	ld		d, h
  39  7553 5D           	ld		e, l
  40  7554 13           	inc		de
  41  7555 01 FB 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  7558 36 00        	ld		(hl), 0
  43  755A ED B0        	ldir
  44  755C
  45  755C              	;main program
  46  755C CD A5 7E     	call 	ReadCatalogTrack
  47  755F B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  7560 28 1C        	jr		z, HCRunMain
  49  7562
  50  7562 6F           	ld		l, a
  51  7563 26 00        	ld		h, 0
  52  7565 11 44 87     	ld		de, MsgErrCode
  53  7568 CD 3E 7C     	call	Byte2Txt
  54  756B 21 39 87     	ld		hl, MsgErr
  55  756E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  56  7571 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  7573 CD B7 81     	call	PrintStrClr
  58  7576 CD 53 81     	call	ReadChar
  59  7579 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  757B 32 84 7F     	ld		(RWTSDrive), a
  61  757E
  62  757E              HCRunMain:
  63  757E CD C2 75     	call 	InitUI
  64  7581 CD 35 79     	call 	GetFileNames
  65  7584 CD 42 76     	call	DisplayDiskInfo
  66  7587 C3 9C 76     	jp		ReadKeyLoop
  67  758A
  68  758A              HCRunEnd:
  69  758A              	;restore error handler
  70  758A E1           	pop		hl
  71  758B E1           	pop		hl
  72  758C 22 3D 5C     	ld		(ERRSP), hl
  73  758F
  74  758F C9           	ret
  75  7590
  76  7590              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  77  7590
  78  7590              ErrorHandler:
  79  7590 E1           	pop		hl
  80  7591 22 3D 5C     	ld		(ERRSP), hl
  81  7594
  82  7594 3A 3A 5C     	ld		a, (ERRNR)		;make something with the error code, display the error message maybe.
  83  7597 6F           	ld		l, a
  84  7598 26 00        	ld		h, 0
  85  759A 11 44 87     	ld		de, MsgErrCode
  86  759D CD 3E 7C     	call	Byte2Txt
  87  75A0 21 39 87     	ld		hl, MsgErr
  88  75A3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  89  75A6 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  90  75A8 CD B7 81     	call	PrintStrClr
  91  75AB
  92  75AB 3A 3A 5C     	ld		a, (ERRNR)
  93  75AE CD 5A 7F     	call	GetErrMsg
  94  75B1
  95  75B1 21 20 A5     	ld		hl, DataBuf
  96  75B4 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
  97  75B7 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
  98  75B9 CD B7 81     	call	PrintStrClr
  99  75BC
 100  75BC CD 53 81     	call	ReadChar
 101  75BF C3 30 75     	jp	Start
 102  75C2
 103  75C2
 104  75C2
 105  75C2
 106  75C2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 107  75C2
 108  75C2              InitUI:
 109  75C2 AF           	xor		a
 110  75C3 32 B5 88     	ld		(SelFile), A
 111  75C6 32 B3 88     	ld		(FileCnt), A
 112  75C9 3E 11        	ld		a, LST_FIRST_COL + 1
 113  75CB 32 B4 88     	ld		(NameCol), A
 114  75CE
 115  75CE 21 08 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 116  75D1 ED 4B 14 83  	ld		bc, (CurrScrAttrAddr)
 117  75D5 09           	add		hl, bc
 118  75D6 22 B6 88     	ld		(CursorAddr), hl
 119  75D9
 120  75D9 CD 6F 81     	call	ClrScr
 121  75DC
 122  75DC 3E 84        	ld		a, CHR_DC
 123  75DE CD 30 82     	call	DrawVLines
 124  75E1
 125  75E1 3E 28        	ld		a, SCR_LBL_CLR
 126  75E3 11 00 17     	ld		de, 23 << 8
 127  75E6 21 CA 86     	ld		hl, BtnBar
 128  75E9 CD B7 81     	call	PrintStrClr
 129  75EC
 130  75EC
 131  75EC 21 6A 86     	ld		hl, VerMsg1
 132  75EF 11 00 00     	ld		de, LST_FIRST_LINE << 8
 133  75F2 CD 8F 81     	call	PrintStr
 134  75F5 21 7A 86     	ld		hl, VerMsg2
 135  75F8 11 00 01     	ld		de, LST_FIRST_LINE + 1 << 8
 136  75FB CD 8F 81     	call	PrintStr
 137  75FE 21 8A 86     	ld		hl, VerMsg3
 138  7601 11 00 02     	ld		de, LST_FIRST_LINE + 2 << 8
 139  7604 CD 8F 81     	call	PrintStr
 140  7607
 141  7607
 142  7607 3E 28        	ld		a, SCR_LBL_CLR
 143  7609 21 9A 86     	ld		hl, MsgDskInf
 144  760C 11 00 03     	ld		de, LST_DISK_INFO << 8
 145  760F CD B7 81     	call	PrintStrClr
 146  7612
 147  7612 3E 28        	ld		a, SCR_LBL_CLR
 148  7614 21 AA 86     	ld		hl, MsgFileInf
 149  7617 11 00 07     	ld		de, LST_FILE_INFO << 8
 150  761A CD B7 81     	call	PrintStrClr
 151  761D
 152  761D 3E 28        	ld		a, SCR_LBL_CLR
 153  761F 21 BA 86     	ld		hl, MsgMessages
 154  7622 11 00 0D     	ld		de, LST_LINE_MSG << 8
 155  7625 CD B7 81     	call	PrintStrClr
 156  7628
 157  7628 11 11 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 158  762B ED 53 B0 5C  	ld		(LineCol), de
 159  762F 21 B8 88     	ld		hl, AUCnt
 160  7632 11 00 00     	ld		de, 0
 161  7635 73 23 72 2B  	ld		(hl), de
 162  7639
 163  7639 3E 28        	ld		a, SCR_SEL_CLR
 164  763B CD 4F 82     	call	DrawCursor
 165  763E
 166  763E CD 4F 7F     	call	SetFastKeys
 167  7641
 168  7641 C9           	ret
 169  7642
 170  7642
 171  7642              DisplayDiskInfo:
 172  7642 3A 84 7F     	ld		a, (RWTSDrive)
 173  7645 C6 C1        	add		'A' + $80
 174  7647 32 18 87     	ld		(MsgDriveLet), a
 175  764A 21 09 87     	ld		hl, MsgDrive
 176  764D 11 00 04     	ld		de, LST_DISK_INFO + 1 << 8
 177  7650 CD 8F 81     	call	PrintStr
 178  7653
 179  7653 3A B3 88     	ld		a, (FileCnt)
 180  7656 6F           	ld		l, a
 181  7657 26 00        	ld		h, 0
 182  7659 11 22 87     	ld		de, MsgFilesCntNo
 183  765C CD 3E 7C     	call	Byte2Txt
 184  765F 21 19 87     	ld		hl, MsgFilesCnt
 185  7662 11 00 05     	ld		de, LST_DISK_INFO + 2 << 8
 186  7665 CD 8F 81     	call	PrintStr
 187  7668
 188  7668 ED 5B B8 88  	ld		de, (AUCnt)
 189  766C 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 190  766F B7           	or		a
 191  7670 ED 52        	sbc		hl, de
 192  7672 CB 15        	rl		l								;*2, 2K/AU
 193  7674 CB 14        	rl		h
 194  7676 11 30 87     	ld		de, MsgFreeSpaceNo - 2
 195  7679 CD 33 7C     	call	Word2Txt
 196  767C 3E 3A        	ld		a, ':'
 197  767E 32 31 87     	ld		(MsgFreeSpaceNo -1), a
 198  7681 21 29 87     	ld		hl, MsgFreeSpace
 199  7684 11 00 06     	ld		de, LST_DISK_INFO + 3 << 8
 200  7687 CD 8F 81     	call	PrintStr
 201  768A
 202  768A C9           	ret
 203  768B
 204  768B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205  768B
 206  768B              CalcFileCache:
 207  768B 3A B5 88     	ld		a, (SelFile)
 208  768E 11 19 00     	ld		de, CACHE_SZ
 209  7691 CD 9A 7C     	call	Mul
 210  7694 01 BC 88     	ld		bc, FileCache
 211  7697 09           	add		hl, bc					;HL = file AU cnt
 212  7698 22 BA 88     	ld		(SelFileCache), hl
 213  769B C9           	ret
 214  769C
 215  769C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 216  769C
 217  769C
 218  769C              ReadKeyLoop:
 219  769C CD 8B 76     	call	CalcFileCache
 220  769F CD 65 7A     	call	DisplayFileInfo
 221  76A2
 222  76A2 CD 53 81     	call	ReadChar
 223  76A5
 224  76A5 FE 0A        	cp		KEY_DOWN
 225  76A7 20 11        	jr		nz, CheckUp
 226  76A9
 227  76A9 3A B3 88     	ld		a, (FileCnt)
 228  76AC 47           	ld		b, a
 229  76AD 3A B5 88     	ld		a, (SelFile)
 230  76B0 3C           	inc		a
 231  76B1 B8           	cp		b
 232  76B2 30 E8        	jr		nc, ReadKeyLoop
 233  76B4 32 B5 88     	ld		(SelFile), a
 234  76B7 C3 E6 78     	jp		MoveIt
 235  76BA
 236  76BA              CheckUp:
 237  76BA FE 0B        	cp		KEY_UP
 238  76BC 20 0D        	jr		nz, CheckRight
 239  76BE
 240  76BE 3A B5 88     	ld		a, (SelFile)
 241  76C1 B7           	or		a
 242  76C2 28 D8        	jr		z, ReadKeyLoop
 243  76C4
 244  76C4 3D           	dec		a
 245  76C5 32 B5 88     	ld		(SelFile), a
 246  76C8 C3 E6 78     	jp		MoveIt
 247  76CB
 248  76CB              CheckRight:
 249  76CB FE 09        	cp		KEY_RIGHT
 250  76CD 20 12        	jr		nz, CheckLeft
 251  76CF
 252  76CF 3A B3 88     	ld		a, (FileCnt)
 253  76D2 47           	ld		b, a
 254  76D3 3A B5 88     	ld		a, (SelFile)
 255  76D6 C6 17        	add		LST_LINES_CNT
 256  76D8 B8           	cp		b
 257  76D9 30 C1        	jr		nc, ReadKeyLoop
 258  76DB
 259  76DB 32 B5 88     	ld		(SelFile), a
 260  76DE C3 E6 78     	jp		MoveIt
 261  76E1
 262  76E1              CheckLeft:
 263  76E1 FE 08        	cp		KEY_LEFT
 264  76E3 20 0D        	jr		nz, CheckEnter
 265  76E5
 266  76E5 3A B5 88     	ld		a, (SelFile)
 267  76E8 D6 17        	sub		LST_LINES_CNT
 268  76EA 38 B0        	jr		c, ReadKeyLoop
 269  76EC
 270  76EC 32 B5 88     	ld		(SelFile), a
 271  76EF C3 E6 78     	jp		MoveIt
 272  76F2
 273  76F2              CheckEnter:
 274  76F2 FE 0D        	cp		KEY_ENTER
 275  76F4 C2 FD 76     	jp		nz, CheckKeyInfo
 276  76F7 CD CC 79     	call	HandleFile
 277  76FA C3 7E 75     	jp		HCRunMain
 278  76FD
 279  76FD              CheckKeyInfo:
 280  76FD FE 34        	cp		'4'
 281  76FF 20 20        	jr		nz, CheckKeyCopy
 282  7701 DD 2A BA 88  	ld		ix, (SelFileCache)
 283  7705 21 FB 87     	ld		hl, MsgReadingExt
 284  7708 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 285  770B 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 286  770D CD B7 81     	call	PrintStrClr
 287  7710 CD CF 7E     	call	ReadFileHeader
 288  7713 21 09 88     	ld		hl, MsgClear
 289  7716 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
 290  7719 3E 0F        	ld		a, SCR_DEF_CLR
 291  771B CD B7 81     	call	PrintStrClr
 292  771E C3 9C 76     	jp		ReadKeyLoop
 293  7721
 294  7721              CheckKeyCopy:
 295  7721 FE 35        	cp		'5'
 296  7723 20 39        	jr		nz, CheckKeyFileInfo
 297  7725
 298  7725 3A 84 7F     	ld 		a, (RWTSDrive)
 299  7728 3C           	inc		a
 300  7729 EE 03        	xor		%11
 301  772B C6 40        	add		'A' - 1
 302  772D 32 5F 88     	ld		(MsgCopyFileDrv), a
 303  7730 21 54 88     	ld		hl, MsgCopyFile
 304  7733 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 305  7736 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 306  7738 CD B7 81     	call	PrintStrClr
 307  773B 2A BA 88     	ld	hl, (SelFileCache)
 308  773E CD 67 80     	call	CopyFile
 309  7741 B7           	or		a
 310  7742 28 17        	jr		z, CopyFileOK
 311  7744
 312  7744 6F           	ld		l, a
 313  7745 26 00        	ld		h, 0
 314  7747 11 44 87     	ld		de, MsgErrCode
 315  774A CD 3E 7C     	call	Byte2Txt
 316  774D 21 39 87     	ld		hl, MsgErr
 317  7750 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 318  7753 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319  7755 CD B7 81     	call	PrintStrClr
 320  7758 CD 53 81     	call	ReadChar
 321  775B
 322  775B              CopyFileOK:
 323  775B C3 42 75     	jp		HCRunInitDisk
 324  775E
 325  775E              CheckKeyFileInfo:
 326  775E FE 20        	cp		' '
 327  7760 20 06        	jr		nz, CheckKeyDriveA
 328  7762 CD D7 7B     	call	ReadAllHeaders
 329  7765 C3 9C 76     	jp		ReadKeyLoop
 330  7768
 331  7768              CheckKeyDriveA:
 332  7768 FE 31        	cp		'1'
 333  776A 20 05        	jr		nz, CheckKeyDriveB
 334  776C 3E 00        	ld		a, DRIVE_A_CPM
 335  776E C3 3F 78     	jp		SelectDrive
 336  7771
 337  7771              CheckKeyDriveB:
 338  7771 FE 32        	cp		'2'
 339  7773 20 05        	jr		nz, CheckKeyView
 340  7775 3E 01        	ld		a, DRIVE_B_CPM
 341  7777 C3 3F 78     	jp		SelectDrive
 342  777A
 343  777A              CheckKeyView:
 344  777A FE 33        	cp		'3'
 345  777C 20 06        	jr		nz, CheckKeyRename
 346  777E CD 4A 7A     	call	ViewFile
 347  7781 C3 7E 75     	jp		HCRunMain
 348  7784
 349  7784              CheckKeyRename:
 350  7784 FE 36        	cp		'6'
 351  7786 20 4B        	jr		nz, CheckKeyDel
 352  7788
 353  7788 21 44 88     	ld		hl, MsgNewFileName
 354  778B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 355  778E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 356  7790 CD B7 81     	call	PrintStrClr
 357  7793
 358  7793 21 09 88     	ld		hl, MsgClear
 359  7796 11 20 A5     	ld		de, DataBuf
 360  7799 01 0B 00     	ld		bc, NAMELEN
 361  779C ED B0        	ldir
 362  779E 3E A0        	ld		a, $80 | ' '
 363  77A0 12           	ld		(de), a
 364  77A1 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 365  77A4 21 20 A5     	ld		hl, DataBuf
 366  77A7 CD 8F 81     	call	PrintStr
 367  77AA
 368  77AA 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 369  77AD 01 0B 00     	ld		bc, NAMELEN
 370  77B0 CD D0 82     	call	ReadString
 371  77B3
 372  77B3 11 20 A5     	ld		de, DataBuf
 373  77B6 1A           	ld		a, (de)
 374  77B7 FE 20        	cp		' '					;If starting with space, input was canceled.
 375  77B9 CA C5 77     	jp		z, RenameCanceled
 376  77BC 2A BA 88     	ld		hl, (SelFileCache)
 377  77BF CD 44 80     	call	RenameFile
 378  77C2 C3 42 75     	jp		HCRunInitDisk
 379  77C5
 380  77C5              RenameCanceled:
 381  77C5 21 09 88     	ld		hl, MsgClear
 382  77C8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 383  77CB 3E 0F        	ld		a, SCR_DEF_CLR
 384  77CD CD B7 81     	call	PrintStrClr
 385  77D0 C3 9C 76     	jp		ReadKeyLoop
 386  77D3
 387  77D3              CheckKeyDel:
 388  77D3 FE 38        	cp		'8'
 389  77D5 20 2D        	jr		nz, CheckKeyAttrib
 390  77D7
 391  77D7 21 19 88     	ld		hl, MsgDelete
 392  77DA 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 393  77DD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 394  77DF CD B7 81     	call	PrintStrClr
 395  77E2 CD 53 81     	call	ReadChar
 396  77E5 FE 79        	cp		'y'
 397  77E7 28 0E        	jr		z, DoFileDelete
 398  77E9 21 09 88     	ld		hl, MsgClear
 399  77EC 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 400  77EF 3E 0F        	ld		a, SCR_DEF_CLR
 401  77F1 CD B7 81     	call	PrintStrClr
 402  77F4 C3 9C 76     	jp		ReadKeyLoop
 403  77F7              DoFileDelete:
 404  77F7 2A BA 88     	ld		hl, (SelFileCache)
 405  77FA 3A 84 7F     	ld 		a, (RWTSDrive)
 406  77FD 3C           	inc		a					;Convert to BASIC drive number: 1,2
 407  77FE CD 0E 80     	call	DeleteFile
 408  7801 C3 42 75     	jp		HCRunInitDisk
 409  7804
 410  7804              CheckKeyAttrib:
 411  7804 FE 37        	cp		'7'
 412  7806 20 3D        	jr		nz, CheckKeyExtra
 413  7808
 414  7808 21 28 88     	ld		hl, MsgSetRO
 415  780B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 416  780E 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 417  7810 CD B7 81     	call	PrintStrClr
 418  7813 CD 53 81     	call	ReadChar
 419  7816 1E 00        	ld		e, 0
 420  7818 FE 79        	cp		'y'
 421  781A 20 02        	jr		nz, CheckSYS
 422  781C 1E 01        	ld		e, 1
 423  781E
 424  781E              CheckSYS:
 425  781E D5           	push	de
 426  781F 21 36 88     		ld		hl, MsgSetSYS
 427  7822 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 428  7825 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 429  7827 CD B7 81     		call	PrintStrClr
 430  782A CD 53 81     		call	ReadChar
 431  782D FE 79        		cp		'y'
 432  782F D1           	pop		de
 433  7830 20 04        	jr		nz, AttrChange
 434  7832 3E 02        	ld		a, %10
 435  7834 B3           	or		e
 436  7835 5F           	ld		e, a
 437  7836
 438  7836              AttrChange:
 439  7836 2A BA 88     	ld		hl, (SelFileCache)
 440  7839 CD 1A 80     	call	ChangeFileAttrib
 441  783C C3 42 75     	jp		HCRunInitDisk
 442  783F
 443  783F              SelectDrive:
 444  783F 32 84 7F     	ld 		(RWTSDrive), a
 445  7842 C3 42 75     	jp		HCRunInitDisk
 446  7845
 447  7845              CheckKeyExtra:
 448  7845 FE 39        	cp		'9'
 449  7847 C2 DE 78     	jp		nz, CheckKeyExit
 450  784A 21 61 88     	ld		hl, MsgMenu0
 451  784D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 452  7850 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 453  7852 CD B7 81     	call	PrintStrClr
 454  7855 3A 84 7F     	ld		a, (RWTSDrive)
 455  7858 C6 41        	add		'A'
 456  785A 32 7C 88     	ld		(MsgMenu1Drv), a
 457  785D 32 A2 88     	ld		(MsgFormatDrv), a
 458  7860 32 8A 88     	ld		(MsgMenu2Drv), a
 459  7863
 460  7863              CheckKeyExtraMenu:
 461  7863 21 6E 88     	ld		hl, MsgMenu1
 462  7866 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 463  7869 CD 8F 81     	call	PrintStr
 464  786C 21 7E 88     	ld		hl, MsgMenu2
 465  786F 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 466  7872 CD 8F 81     	call	PrintStr
 467  7875 21 8C 88     	ld		hl, MsgMenu3
 468  7878 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 469  787B CD 8F 81     	call	PrintStr
 470  787E CD 53 81     	call	ReadChar
 471  7881 F5           	push	af
 472  7882
 473  7882 21 09 88     		ld		hl, MsgClear
 474  7885 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 475  7888 CD 8F 81     		call	PrintStr
 476  788B 21 09 88     		ld		hl, MsgClear
 477  788E 11 00 10     		ld		de, LST_LINE_MSG + 3 << 8
 478  7891 CD 8F 81     		call	PrintStr
 479  7894 21 09 88     		ld		hl, MsgClear
 480  7897 11 00 11     		ld		de, LST_LINE_MSG + 4 << 8
 481  789A CD 8F 81     		call	PrintStr
 482  789D
 483  789D F1           	pop		af
 484  789E FE 33        	cp		'3'
 485  78A0 28 39        	jr		z, ExtraMenuExit
 486  78A2
 487  78A2 FE 31        	cp		'1'
 488  78A4 20 2C        	jr		nz, CheckExtra2
 489  78A6
 490  78A6 21 97 88     	ld		hl, MsgFormat
 491  78A9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 492  78AC 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 493  78AE CD B7 81     	call	PrintStrClr
 494  78B1
 495  78B1 CD D3 7C     	call	FormatDisk
 496  78B4 B7           	or		a
 497  78B5 CA 42 75     	jp		z, HCRunInitDisk
 498  78B8
 499  78B8              	;Display error for format
 500  78B8 6F           	ld		l, a
 501  78B9 26 00        	ld		h, 0
 502  78BB 11 44 87     	ld		de, MsgErrCode
 503  78BE CD 3E 7C     	call	Byte2Txt
 504  78C1 21 39 87     	ld		hl, MsgErr
 505  78C4 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 506  78C7 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 507  78C9 CD B7 81     	call	PrintStrClr
 508  78CC CD 53 81     	call	ReadChar
 509  78CF C3 42 75     	jp		HCRunInitDisk
 510  78D2
 511  78D2              CheckExtra2:
 512  78D2 FE 32        	cp		'2'
 513  78D4 20 8D        	jr		nz, CheckKeyExtraMenu
 514  78D6
 515  78D6 CD A3 7D     	call	CopyDisk
 516  78D9 18 00        	jr		ExtraMenuExit
 517  78DB
 518  78DB              ExtraMenuExit:
 519  78DB C3 7E 75     	jp		HCRunMain
 520  78DE
 521  78DE              CheckKeyExit:
 522  78DE FE 30        	cp		'0'
 523  78E0 C2 9C 76     	jp		nz, ReadKeyLoop
 524  78E3 C3 8A 75     	jp		HCRunEnd
 525  78E6
 526  78E6              MoveIt:
 527  78E6 CD 5A 82     	call 	MoveCursor
 528  78E9 C3 9C 76     	jp		ReadKeyLoop
 529  78EC
 530  78EC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 531  78EC
 532  78EC
 533  78EC              DisplayFilename:
 534  78EC 06 0B        	LD		B, NAMELEN
 535  78EE              DispLoop:
 536  78EE 1A           	LD		A, (DE)
 537  78EF
 538  78EF              	;clear bit 7
 539  78EF CB BF        	RES 	7, A
 540  78F1 32 81 5C     	LD		(CODE), A
 541  78F4
 542  78F4 13           	INC		DE
 543  78F5 D5           	PUSH	DE
 544  78F6 C5           	PUSH	BC
 545  78F7 CD 92 82     		CALL	PrintChar
 546  78FA C1           	POP		BC
 547  78FB D1           	POP 	DE
 548  78FC
 549  78FC 21 B0 5C     	LD		HL, COL
 550  78FF 34           	INC		(HL)
 551  7900 10 EC        	DJNZ	DispLoop
 552  7902              	;now a name is displayed
 553  7902
 554  7902              	;check bounds
 555  7902 3A B1 5C     	LD		A, (LINE)
 556  7905 3C           	INC		A
 557  7906 FE 17        	CP		LST_LINES_CNT + LST_FIRST_LINE
 558  7908 38 0A        	JR		C, LineOK
 559  790A
 560  790A              	;set names column to the next one
 561  790A 3A B4 88     	LD		A, (NameCol)
 562  790D C6 0C        	ADD		NAMELEN + 1
 563  790F 32 B4 88     	LD		(NameCol), A
 564  7912
 565  7912 3E 00        	LD		A, LST_FIRST_LINE
 566  7914              LineOK:
 567  7914 32 B1 5C     	LD		(LINE), A
 568  7917
 569  7917 3A B4 88     	LD		A, (NameCol)
 570  791A 32 B0 5C     	LD		(COL), A
 571  791D
 572  791D C9           	RET
 573  791E
 574  791E
 575  791E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 576  791E
 577  791E              DisplayFilenames:
 578  791E 11 BC 88     	ld		de, FileCache
 579  7921 3A B3 88     	ld		a, (FileCnt)
 580  7924 47           	ld		b,	a
 581  7925
 582  7925              DisplayFilenamesLoop:
 583  7925 C5           	push	bc
 584  7926 D5           		push	de
 585  7927 CD EC 78     			call	DisplayFilename
 586  792A D1           		pop		de
 587  792B EB           		ex		de, hl
 588  792C 01 19 00     		ld		bc, CACHE_SZ
 589  792F 09           		add		hl, bc
 590  7930 EB           		ex		de, hl
 591  7931 C1           	pop		bc
 592  7932 10 F1        	djnz	DisplayFilenamesLoop
 593  7934
 594  7934 C9           	ret
 595  7935
 596  7935
 597  7935              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 598  7935              ;Selects only valid filenames (not deleted and only from first extension)
 599  7935              GetFileNames:
 600  7935 DD 21 20 95  	ld ix, TrackBuf
 601  7939 11 BC 88     	ld de, FileCache
 602  793C 06 80        	ld b, MAX_EXT_CNT
 603  793E
 604  793E              StoreFilenamesLoop:
 605  793E AF           	xor a
 606  793F DD BE 00     	cp (ix + EXT_DEL_FLAG)
 607  7942 C2 BE 79     	jp nz, NextExt			;check for deleted
 608  7945
 609  7945              	;count AU
 610  7945 D9           	exx
 611  7946 E5           	push hl
 612  7947 CD 02 7D     		call CheckExtAlloc
 613  794A EB           		ex de, hl			;save first AU no.
 614  794B
 615  794B              		;store disk alocated AU count
 616  794B 2A B8 88     		ld hl, (AUCnt)
 617  794E 48           		ld c, b
 618  794F 06 00        		ld b, 0
 619  7951 09           		add hl, bc
 620  7952 22 B8 88     		ld (AUCnt), hl
 621  7955 E1           	pop hl
 622  7956 D9           	exx
 623  7957
 624  7957 AF           	xor	a
 625  7958 DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 626  795B 20 3A        	jr nz, FindExt
 627  795D
 628  795D DD E5        	push ix
 629  795F E1           	pop hl
 630  7960 23           	inc hl					;skip del flag
 631  7961
 632  7961 C5           	push bc
 633  7962 D5           		push de
 634  7963 E5           			push hl
 635  7964 EB           				ex de, hl
 636  7965 CD EC 78     				call DisplayFilename
 637  7968 E1           			pop hl
 638  7969 D1           		pop de
 639  796A 01 0B 00     		ld bc, NAMELEN
 640  796D ED B0        		ldir				;save file name
 641  796F
 642  796F D9           		exx
 643  7970 D5           		push 	de			;de = first AU
 644  7971 D9           		exx
 645  7972 E1           		pop		hl
 646  7973 EB           		ex		de, hl
 647  7974 73 23 72 2B  		ld		(hl), de	;save first AU
 648  7978
 649  7978 23           		inc		hl
 650  7979 23           		inc		hl
 651  797A
 652  797A D9           		exx					;save AU cnt for file
 653  797B C5           		push	bc
 654  797C D9           		exx
 655  797D C1           		pop		bc
 656  797E 71 23 70 2B  		ld		(hl), bc
 657  7982
 658  7982 23           		inc		hl
 659  7983 23           		inc		hl
 660  7984
 661  7984              		;xor		a			;make flag 0 to signal that header is not read yet
 662  7984              		;ld		(hl), a
 663  7984
 664  7984 01 0A 00     		ld		bc, HDR_SZ + 1
 665  7987 09           		add		hl, bc
 666  7988
 667  7988 EB           		ex		de, hl
 668  7989 C1           	pop bc
 669  798A
 670  798A
 671  798A 3A B3 88     	ld 		a, (FileCnt)			;inc file counter
 672  798D 3C           	inc		a
 673  798E 32 B3 88     	ld 		(FileCnt), a
 674  7991 FE 5C        	cp		LST_MAX_FILES
 675  7993 38 29        	jr		c, NextExt
 676  7995 18 34        	jr		GetFileNamesEnd
 677  7997
 678  7997
 679  7997              FindExt:					;BC' = AU cnt for this ext
 680  7997 C5           	push	bc
 681  7998 D5           		push 	de
 682  7999 DD E5        			push	ix
 683  799B D1           			pop		de
 684  799C 13           			inc		de				;DE = name to find
 685  799D
 686  799D 21 BC 88     			ld		hl, FileCache
 687  79A0 3A B3 88     			ld		a, (FileCnt)
 688  79A3 4F           			ld		c, a
 689  79A4 CD BE 7E     			call	FindCache
 690  79A7 20 13        			jr		nz, FindExtEnd
 691  79A9
 692  79A9 01 0D 00     			ld		bc, CACHE_AU_CNT
 693  79AC 09           			add		hl, bc
 694  79AD D9           			exx
 695  79AE C5           			push	bc
 696  79AF D9           			exx
 697  79B0 C1           			pop		bc
 698  79B1
 699  79B1 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 700  79B5 EB           			ex		de, hl
 701  79B6 09           			add		hl, bc
 702  79B7 EB           			ex		de, hl
 703  79B8 73 23 72 2B  			ld		(hl), de
 704  79BC              FindExtEnd:
 705  79BC D1           		pop		de
 706  79BD C1           	pop		bc
 707  79BE
 708  79BE              NextExt:
 709  79BE C5           	push bc
 710  79BF 01 20 00     		ld bc, EXT_SZ
 711  79C2 DD 09        		add ix, bc
 712  79C4 C1           	pop	bc
 713  79C5
 714  79C5 05           	dec	b
 715  79C6 78           	ld	a, b
 716  79C7 B7           	or	a
 717  79C8 C2 3E 79     	jp	nz, StoreFilenamesLoop
 718  79CB              GetFileNamesEnd:
 719  79CB C9           	ret
 720  79CC
 721  79CC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 722  79CC
 723  79CC              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 724  79CC              ;IN: HL = file name
 725  79CC              HandleFile:
 726  79CC              	;Make HL point to the selected file
 727  79CC DD 2A BA 88  	ld		ix, (SelFileCache)
 728  79D0 DD E5        	push	ix
 729  79D2 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 730  79D5 B7           		or		a
 731  79D6 CC CF 7E     		call	z, ReadFileHeader
 732  79D9
 733  79D9 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 734  79DC FE 00        		cp		PROG_TYPE
 735  79DE 28 59        		jr		z, HandleFileProg
 736  79E0
 737  79E0 FE 03        		cp		BYTE_TYPE
 738  79E2 20 65        		jr		nz, HandleFileText
 739  79E4
 740  79E4 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 740  79E8 66 12
 741  79EA 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 742  79ED 19           		add		hl, de
 743  79EE 7C           		ld		a, h
 744  79EF B5           		or		l
 745  79F0 28 29        		jr		z, HandleFileSCR
 746  79F2
 747  79F2
 748  79F2              HandleFileCODE:
 749  79F2 21 67 87     		ld		hl, MsgLoadingCODE
 750  79F5 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 751  79F8 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 752  79FA CD B7 81     		call	PrintStrClr
 753  79FD
 754  79FD              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 755  79FD 21 39 7E     		ld		hl, IF1FileLoad
 756  7A00 11 00 5B     		ld		de, PRN_BUF
 757  7A03 01 41 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 758  7A06 ED B0        		ldir
 759  7A08 3E C9        		ld		a, $C9
 760  7A0A 12           		ld		(de), a				;put a RET here, since FileFree won't be called.
 761  7A0B
 762  7A0B E1           	pop		hl
 763  7A0C ED 5B 23 A5  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 764  7A10 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 765  7A11 C1           	pop		bc						;2nd, 3rd call for error handler
 766  7A12 C1           	pop		bc
 767  7A13 ED 43 3D 5C  	ld		(ERRSP), bc
 768  7A17 D5           	push	de						;push CODE address to return to = start of CODE block
 769  7A18 C3 00 5B     	jp		PRN_BUF
 770  7A1B
 771  7A1B
 772  7A1B
 773  7A1B
 774  7A1B              HandleFileSCR:
 775  7A1B 21 58 87     		ld		hl, MsgLoadingSCR
 776  7A1E 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 777  7A21 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 778  7A23 CD B7 81     		call	PrintStrClr
 779  7A26
 780  7A26 E1           	pop		hl
 781  7A27
 782  7A27              	IFDEF _ROM_FNT_
 783  7A27              		;Load to alternate SCREEN$ memory
 784  7A27 11 00 C0     		ld		de, HC_VID_BANK1
 785  7A2A CD 39 7E     		call	IF1FileLoad
 786  7A2D
 787  7A2D              		;Set display to alternate SCREEN$ memory
 788  7A2D 3E 08        		ld		a, HC_CFG_VID_C000
 789  7A2F D3 7E        		out 	(HC_CFG_PORT), a
 790  7A31 CD 53 81     		call	ReadChar
 791  7A34
 792  7A34              		;Set back to regular SCREEN$ memory
 793  7A34 3E 00        		ld		a, HC_CFG_VID_4000
 794  7A36 D3 7E        		out 	(HC_CFG_PORT), a
 795  7A38              	ELSE
 796  7A38 ~            		ld		de, HC_VID_BANK0
 797  7A38 ~            		call	IF1FileLoad
 798  7A38 ~            		call	ReadChar
 799  7A38              	ENDIF
 800  7A38
 801  7A38 C9           	ret
 802  7A39
 803  7A39              HandleFileProg:
 804  7A39 21 49 87     		ld		hl, MsgLoadingPrg
 805  7A3C 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 806  7A3F 3E 8F        		ld		a, SCR_DEF_CLR | CLR_FLASH
 807  7A41 CD B7 81     		call	PrintStrClr
 808  7A44 E1           	pop		hl
 809  7A45 CD 36 7F     	call	LoadProgram
 810  7A48 C9           	ret
 811  7A49
 812  7A49
 813  7A49              HandleFileText:
 814  7A49 E1           	pop		hl
 815  7A4A
 816  7A4A
 817  7A4A              ViewFile:
 818  7A4A CD 6F 81     	call	ClrScr
 819  7A4D 2A BA 88     	ld		hl, (SelFileCache)
 820  7A50 CD 09 81     	call	ReadFileSection					;DE = last address read
 821  7A53 21 20 A6     	ld		hl, FileData
 822  7A56              	;Calculate size of read buffer
 823  7A56 E5           	push	hl
 824  7A57 EB           		ex	de, hl
 825  7A58 B7           		or	a
 826  7A59 ED 52        		sbc	hl, de
 827  7A5B 44           		ld	b, h
 828  7A5C 4B           		ld	c, e
 829  7A5D E1           	pop		hl
 830  7A5E CD 16 83     	call	InitViewer
 831  7A61 CD 70 83     	call	PrintLoop
 832  7A64              ViewFileEnd:
 833  7A64 C9           	ret
 834  7A65
 835  7A65              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 836  7A65
 837  7A65
 838  7A65              DisplayFileInfo:
 839  7A65 2A BA 88     	ld		hl, (SelFileCache)
 840  7A68 E5           	push	hl
 841  7A69              		;disk size - at least 2KB ==1  AU
 842  7A69 01 0D 00     		ld		bc, CACHE_AU_CNT
 843  7A6C 09           		add		hl, bc
 844  7A6D 5E 23 56 2B  		ld		de, (hl)
 845  7A71 EB           		ex		de, hl
 846  7A72              		;*2, since one block (AU) is 2KB.
 847  7A72 CB 15        		rl	l
 848  7A74 CB 14        		rl	h
 849  7A76
 850  7A76 11 80 87     		ld		de, MsgFileSzDskN
 851  7A79 CD 33 7C     		call	Word2Txt
 852  7A7C 21 77 87     		ld		hl, MsgFileSzDsk
 853  7A7F 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
 854  7A82 CD 8F 81     		call	PrintStr
 855  7A85 E1           	pop		hl
 856  7A86 E5           	push	hl
 857  7A87              		;attributes
 858  7A87 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 859  7A8A 09           		add		hl, bc
 860  7A8B EB           		ex		de, hl
 861  7A8C 21 90 87     		ld		hl, MsgFileAttrN
 862  7A8F 1A           		ld		a, (de)
 863  7A90 E6 80        		and		%10000000
 864  7A92 28 14        		jr		z, NotRO
 865  7A94
 866  7A94 01 52 2F     		ld		bc, '/R'
 867  7A97 71 23 70 2B  		ld		(hl), bc
 868  7A9B 23           		inc		hl
 869  7A9C 23           		inc		hl
 870  7A9D 01 4F 2C     		ld		bc, ',O'
 871  7AA0 71 23 70 2B  		ld		(hl), bc
 872  7AA4 23           		inc		hl
 873  7AA5 23           		inc		hl
 874  7AA6 18 12        		jr		CheckSys
 875  7AA8              NotRO:
 876  7AA8 01 2D 2D     		ld		bc, '--'
 877  7AAB 71 23 70 2B  		ld		(hl), bc
 878  7AAF 23           		inc		hl
 879  7AB0 23           		inc		hl
 880  7AB1 01 2D 2C     		ld		bc, ',-'
 881  7AB4 71 23 70 2B  		ld		(hl), bc
 882  7AB8 23           		inc		hl
 883  7AB9 23           		inc		hl
 884  7ABA
 885  7ABA              CheckSys:
 886  7ABA 13           		inc		de
 887  7ABB 1A           		ld		a, (de)
 888  7ABC E6 80        		and		%10000000
 889  7ABE 28 0E        		jr		z, NotSYS
 890  7AC0
 891  7AC0 01 48 49     		ld		bc, 'IH'
 892  7AC3 71 23 70 2B  		ld		(hl), bc
 893  7AC7 23           		inc		hl
 894  7AC8 23           		inc		hl
 895  7AC9 3E C4        		ld		a, 'D' + $80
 896  7ACB 77           		ld		(hl), a
 897  7ACC 18 0C        		jr		AttrEnd
 898  7ACE              NotSYS:
 899  7ACE 01 2D 2D     		ld		bc, '--'
 900  7AD1 71 23 70 2B  		ld		(hl), bc
 901  7AD5 23           		inc		hl
 902  7AD6 23           		inc		hl
 903  7AD7 3E AD        		ld		a, '-' + $80
 904  7AD9 77           		ld		(hl), a
 905  7ADA              AttrEnd:
 906  7ADA 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
 907  7ADD 21 87 87     		ld		hl, MsgFileAttr
 908  7AE0 CD 8F 81     		call	PrintStr
 909  7AE3 DD E1        	pop		ix
 910  7AE5 DD E5        	push	ix
 911  7AE7 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 912  7AEA B7           		or		a
 913  7AEB CA 88 7B             jp		z, HeadNotRead
 914  7AEE
 915  7AEE DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
 916  7AF1 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
 917  7AF4 CA 88 7B             jp		z, HeadNotRead
 918  7AF7
 919  7AF7 DD 7E 10     		ld		a, (ix + CACHE_HDR)
 920  7AFA FE 00        		cp		PROG_TYPE
 921  7AFC 20 0B        		jr		nz, CheckNoArr
 922  7AFE
 923  7AFE 21 AA 87     		ld		hl, MsgFileTypePrg
 924  7B01 11 A0 87     		ld		de, MsgFileTypeN
 925  7B04 CD D1 7B     		call	MoveMsg
 926  7B07 18 4F        		jr		PrepFileLen
 927  7B09
 928  7B09              CheckNoArr:
 929  7B09 FE 01        		cp		NUMB_TYPE
 930  7B0B 20 0B        		jr		nz, CheckChrArr
 931  7B0D
 932  7B0D 21 C6 87     		ld		hl, MsgFileTypeNoA
 933  7B10 11 A0 87     		ld		de, MsgFileTypeN
 934  7B13 CD D1 7B     		call	MoveMsg
 935  7B16 18 40        		jr		PrepFileLen
 936  7B18
 937  7B18              CheckChrArr:
 938  7B18 FE 02        		cp		CHAR_TYPE
 939  7B1A 20 0B        		jr		nz, CheckByte
 940  7B1C
 941  7B1C 21 BF 87     		ld		hl, MsgFileTypeChrA
 942  7B1F 11 A0 87     		ld		de, MsgFileTypeN
 943  7B22 CD D1 7B     		call	MoveMsg
 944  7B25 18 31        		jr		PrepFileLen
 945  7B27
 946  7B27              CheckByte:
 947  7B27 FE 03        		cp		BYTE_TYPE
 948  7B29 20 24        		jr		nz, CheckText
 949  7B2B
 950  7B2B DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
 950  7B2F 66 12
 951  7B31 01 00 E5     		ld		bc, -SCR_LEN
 952  7B34 09           		add		hl, bc
 953  7B35 7C           		ld		a, h
 954  7B36 B5           		or		l
 955  7B37 20 0B        		jr		nz, NotScr
 956  7B39
 957  7B39 21 B8 87     		ld		hl, MsgFileTypeSCR
 958  7B3C 11 A0 87     		ld		de, MsgFileTypeN
 959  7B3F CD D1 7B     		call	MoveMsg
 960  7B42 18 14        		jr		PrepFileLen
 961  7B44              NotScr:
 962  7B44 21 B1 87     		ld		hl, MsgFileTypeByte
 963  7B47 11 A0 87     		ld		de, MsgFileTypeN
 964  7B4A CD D1 7B     		call	MoveMsg
 965  7B4D 18 09        		jr		PrepFileLen
 966  7B4F
 967  7B4F              CheckText:
 968  7B4F 21 CD 87     		ld		hl, MsgFileTypeText
 969  7B52 11 A0 87     		ld		de, MsgFileTypeN
 970  7B55 CD D1 7B     		call	MoveMsg
 971  7B58
 972  7B58              PrepFileLen:
 973  7B58              		;File len
 974  7B58 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
 975  7B5B DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 976  7B5E              PrepFileLenText:
 977  7B5E 11 E4 87     		ld		de, MsgFileLenN
 978  7B61 CD 33 7C     		call	Word2Txt
 979  7B64 26 C2        		ld		h, 'B' | $80
 980  7B66 2E 20        		ld		l, ' '
 981  7B68 22 E9 87     		ld		(MsgFileLenN + 5), hl
 982  7B6B
 983  7B6B DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 984  7B6E FE 00        		cp		PROG_TYPE
 985  7B70 28 06        		jr		z, PrintProgStart
 986  7B72
 987  7B72 FE 03        		cp		BYTE_TYPE
 988  7B74 28 0A        		jr		z, PrintByteStart
 989  7B76
 990  7B76 18 22        		jr		PrintStartNotRead
 991  7B78
 992  7B78              PrintProgStart:
 993  7B78 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
 994  7B7B DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
 995  7B7E 18 25        		jr		PrintStart
 996  7B80
 997  7B80              PrintByteStart:
 998  7B80 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
 999  7B83 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1000  7B86 18 1D        		jr		PrintStart
1001  7B88
1002  7B88              HeadNotRead:
1003  7B88 21 D4 87             ld        hl, MsgNA
1004  7B8B 11 A0 87             ld        de, MsgFileTypeN
1005  7B8E CD D1 7B             call    MoveMsg
1006  7B91
1007  7B91 21 D4 87     		ld		hl, MsgNA
1008  7B94 11 E4 87     		ld		de, MsgFileLenN
1009  7B97 CD D1 7B     		call	MoveMsg
1010  7B9A
1011  7B9A              PrintStartNotRead:
1012  7B9A 21 D4 87     		ld		hl, MsgNA
1013  7B9D 11 F4 87     		ld		de, MsgFileStartN
1014  7BA0 CD D1 7B     		call	MoveMsg
1015  7BA3 18 0E        		jr		PrintStartStr
1016  7BA5
1017  7BA5              PrintStart:
1018  7BA5 1E 20        	ld		e, ' '
1019  7BA7 16 A0        	ld		d, ' ' | $80
1020  7BA9 ED 53 F9 87  	ld		(MsgFileStartN + 5), de
1021  7BAD 11 F4 87     	ld		de, MsgFileStartN
1022  7BB0 CD 33 7C     	call	Word2Txt
1023  7BB3              PrintStartStr:
1024  7BB3 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1025  7BB6 21 EB 87     	ld		hl, MsgFileStart
1026  7BB9 CD 8F 81     	call	PrintStr
1027  7BBC
1028  7BBC DD E1        	pop		ix
1029  7BBE 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1030  7BC1 21 97 87     	ld		hl, MsgFileType
1031  7BC4 CD 8F 81     	call	PrintStr
1032  7BC7
1033  7BC7 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1034  7BCA 21 DB 87     	ld		hl, MsgFileLen
1035  7BCD CD 8F 81     	call	PrintStr
1036  7BD0
1037  7BD0 C9           	ret
1038  7BD1
1039  7BD1              MoveMsg:
1040  7BD1 01 07 00     	ld		bc, 7
1041  7BD4 ED B0        	ldir
1042  7BD6 C9           	ret
1043  7BD7
1044  7BD7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1045  7BD7
1046  7BD7              ReadAllHeaders:
1047  7BD7 21 FB 87     	ld		hl, MsgReadingExt
1048  7BDA 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1049  7BDD 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
1050  7BDF CD B7 81     	call	PrintStrClr
1051  7BE2
1052  7BE2 CD 8B 76     	call	CalcFileCache
1053  7BE5
1054  7BE5 3A B5 88     	ld		a, (SelFile)
1055  7BE8 47           	ld		b, a
1056  7BE9 3A B3 88     	ld		a, (FileCnt)
1057  7BEC 90           	sub		b
1058  7BED B7           	or		a
1059  7BEE C8           	ret		z
1060  7BEF
1061  7BEF 47           	ld		b, a
1062  7BF0
1063  7BF0 DD 2A BA 88  	ld		ix, (SelFileCache)
1064  7BF4              NextFile:
1065  7BF4 C5           	push	bc
1066  7BF5 CD CF 7E     		call	ReadFileHeader
1067  7BF8 01 19 00     		ld		bc, CACHE_SZ
1068  7BFB DD 09        		add		ix, bc
1069  7BFD DD E5        		push	ix
1070  7BFF CD 8B 76     			call	CalcFileCache
1071  7C02 CD 65 7A     			call	DisplayFileInfo
1072  7C05 DD E1        		pop		ix
1073  7C07
1074  7C07 CD 56 81     		call	KbdHit
1075  7C0A 38 03        		jr		c, AKey
1076  7C0C C1           	pop		bc
1077  7C0D 18 15        	jr		ReadAllHeadersEnd
1078  7C0F
1079  7C0F              AKey:
1080  7C0F 3A B5 88     		ld		a, (SelFile)
1081  7C12 3C           		inc		a
1082  7C13 47           		ld		b, a
1083  7C14 3A B3 88     		ld		a, (FileCnt)
1084  7C17 B8           		cp		b
1085  7C18 28 16        		jr		z, DontInc
1086  7C1A 78           		ld		a, b
1087  7C1B 32 B5 88     		ld		(SelFile), a
1088  7C1E CD 5A 82     		call	MoveCursor
1089  7C21 C1           	pop		bc
1090  7C22 10 D0        	djnz	NextFile
1091  7C24
1092  7C24              ReadAllHeadersEnd:
1093  7C24 21 09 88     	ld		hl, MsgClear
1094  7C27 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1095  7C2A 3E 0F        	ld		a, SCR_DEF_CLR
1096  7C2C CD B7 81     	call	PrintStrClr
1097  7C2F C9           	ret
1098  7C30
1099  7C30              DontInc:
1100  7C30 C1           	pop		bc
1101  7C31 18 F1        	jr		ReadAllHeadersEnd
1102  7C33              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1103  7C33
1104  7C33              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 7C33              	ifndef	_HCCFG_
   2+ 7C33              	define	_HCCFG_
   3+ 7C33
   4+ 7C33              ;HC specific code, for configuration
   5+ 7C33
   6+ 7C33              HC_CFG_PORT			EQU	$7E
   7+ 7C33
   8+ 7C33              ;BASIC/CPM ROM selection
   9+ 7C33              HC_CFG_ROM_BAS		EQU	%0
  10+ 7C33              HC_CFG_ROM_CPM		EQU	%1
  11+ 7C33
  12+ 7C33              ;Address for ROM paging: 0 or $E000
  13+ 7C33              HC_CFG_ROM_0000		EQU %00
  14+ 7C33              HC_CFG_ROM_E000		EQU %10
  15+ 7C33
  16+ 7C33              ;Cfg. port Enable/Disable
  17+ 7C33              HC_CFG_PORT_DIS		EQU %000
  18+ 7C33              HC_CFG_PORT_EN		EQU	%100
  19+ 7C33
  20+ 7C33              ;Video memory bank: $4000 or $C000
  21+ 7C33              HC_CFG_VID_4000		EQU	%0000
  22+ 7C33              HC_CFG_VID_C000		EQU	%1000
  23+ 7C33
  24+ 7C33
  25+ 7C33              ;Standar BASIC config
  26+ 7C33              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 7C33              ;Standar CP/M config
  28+ 7C33              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 7C33
  30+ 7C33
  31+ 7C33              HC_VID_BANK0		EQU	$4000
  32+ 7C33              HC_VID_BANK1		EQU	$C000
  33+ 7C33
  34+ 7C33              	endif
# file closed: hccfg.asm
1105  7C33              	include "disk.asm"
# file opened: disk.asm
   1+ 7C33              ;HC IF1 routines and constants
   2+ 7C33
   3+ 7C33              ;IF1 routines error codes, also returned by BASIC commands
   4+ 7C33              ;12 = Writing to a 'read' file
   5+ 7C33              ;13 = Reading a 'write' file
   6+ 7C33              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 7C33              ;15 = Disk full (disk or catalog full)
   8+ 7C33              ;16 = Disk error (hardware error)
   9+ 7C33              ;17 = File not found
  10+ 7C33              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 7C33              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 7C33
  13+ 7C33              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 7C33              ;00h = OK
  15+ 7C33              ;08h = cannot format disk
  16+ 7C33              ;10h = disk protected (read-only?)
  17+ 7C33              ;20h = volume error
  18+ 7C33              ;40h = drive error
  19+ 7C33              ;80h = reading error
  20+ 7C33              ;Codes I encountered:
  21+ 7C33              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 7C33
  23+ 7C33
  24+ 7C33              	ifndef	_DISK_
  25+ 7C33              	define	_DISK_
  26+ 7C33
  27+ 7C33              	include	"math.asm"
# file opened: math.asm
   1++7C33              	ifndef	_MATH_
   2++7C33              	define	_MATH_
   3++7C33
   4++7C33              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++7C33              ;http://map.tni.nl/sources/external/z80bits.html
   6++7C33
   7++7C33              Word2Txt:
   8++7C33              	IFUSED
   9++7C33 D5           	push	de
  10++7C34 CD 54 7C     		call	Word2Txt_
  11++7C37 D1           	pop		de
  12++7C38
  13++7C38 06 04        	ld		b, 4
  14++7C3A CD 49 7C     	call	StrippLeading0
  15++7C3D C9           	ret
  16++7C3E              	ENDIF
  17++7C3E
  18++7C3E              Byte2Txt:
  19++7C3E              	IFUSED
  20++7C3E D5           	push	de
  21++7C3F CD 60 7C     		call	Byte2Txt_
  22++7C42 D1           	pop		de
  23++7C43
  24++7C43 06 02        	ld		b, 2
  25++7C45 CD 49 7C     	call	StrippLeading0
  26++7C48 C9           	ret
  27++7C49              	ENDIF
  28++7C49
  29++7C49
  30++7C49              StrippLeading0:
  31++7C49 1A           	ld		a, (de)
  32++7C4A FE 31        	cp		'1'
  33++7C4C D0           	ret		nc
  34++7C4D
  35++7C4D 3E 20        	ld		a, ' '
  36++7C4F 12           	ld		(de), a
  37++7C50 13           	inc		de
  38++7C51 10 F6        	djnz	StrippLeading0
  39++7C53 C9           	ret
  40++7C54
  41++7C54              ;Converts the number in HL to ASCII in decimal string at DE
  42++7C54              Word2Txt_:
  43++7C54 01 F0 D8     	ld bc, -10000
  44++7C57 CD 6F 7C     	call DigitLoop
  45++7C5A 01 18 FC     	ld bc, -1000
  46++7C5D CD 6F 7C     	call DigitLoop
  47++7C60              Byte2Txt_:
  48++7C60 01 9C FF     	ld bc, -100
  49++7C63 CD 6F 7C     	call DigitLoop
  50++7C66 01 F6 FF     	ld bc, -10
  51++7C69 CD 6F 7C     	call DigitLoop
  52++7C6C 01 FF FF     	ld bc, -1
  53++7C6F
  54++7C6F              DigitLoop:
  55++7C6F 3E 2F        	ld	a, '0' - 1
  56++7C71              DivNrLoop:
  57++7C71 3C           	inc	a			;increase reminder
  58++7C72 09           	add	hl, bc		;substract divizor
  59++7C73 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++7C75 ED 42        	sbc	hl, bc		;nope, restore
  61++7C77
  62++7C77 12           	ld (de), a
  63++7C78 13           	inc de
  64++7C79 C9           	ret
  65++7C7A
  66++7C7A
  67++7C7A              ;Input: HL = Dividend, C = Divisor
  68++7C7A              ;Output: HL = Quotient, A = Remainder
  69++7C7A              ;Warning: doesn't work with divisor >= $80
  70++7C7A              Div:
  71++7C7A              	IFUSED
  72++7C7A AF           	xor a
  73++7C7B 06 10        	ld b, 16
  74++7C7D
  75++7C7D              DivLoop:
  76++7C7D 29           	add	hl,hl
  77++7C7E 17           	rla
  78++7C7F B9           	cp	c
  79++7C80 38 02        	jr	c, NoSub
  80++7C82 91           	sub	c
  81++7C83 2C           	inc	l
  82++7C84              NoSub:
  83++7C84 10 F7        	djnz DivLoop
  84++7C86
  85++7C86 C9           	ret
  86++7C87              	ENDIF
  87++7C87
  88++7C87              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++7C87              ;Output: A:C = Quotient, HL = Remainder
  90++7C87              Div2:
  91++7C87 21 00 00     	ld hl, 0
  92++7C8A 06 10        	ld b, 16
  93++7C8C              Div2Loop:
  94++7C8C CB 31        	sll c		; unroll 16 times
  95++7C8E 17           	rla			; ...
  96++7C8F ED 6A        	adc	hl,hl		; ...
  97++7C91 ED 52        	sbc	hl,de		; ...
  98++7C93 30 02        	jr	nc,$+4		; ...
  99++7C95 19           	add	hl,de		; ...
 100++7C96 0D           	dec	c		; ...
 101++7C97 10 F3        	djnz Div2Loop
 102++7C99 C9           	ret
 103++7C9A
 104++7C9A
 105++7C9A              ;Input: A = Multiplier, DE = Multiplicand
 106++7C9A              ;Output: A:HL = Product
 107++7C9A              Mul:
 108++7C9A              	IFUSED
 109++7C9A 21 00 00     	ld hl, 0
 110++7C9D 01 00 07     	ld bc, $0700
 111++7CA0
 112++7CA0 87           	add	a, a		; optimised 1st iteration
 113++7CA1 30 02        	jr	nc, MulLoop
 114++7CA3 62           	ld	h, d
 115++7CA4 6B           	ld	l, e
 116++7CA5
 117++7CA5              MulLoop:
 118++7CA5 29           	add	hl,hl
 119++7CA6 17           	rla
 120++7CA7 30 02        	jr	nc, NoAdd
 121++7CA9 19           	add	hl,de
 122++7CAA 89           	adc	a,c
 123++7CAB              NoAdd:
 124++7CAB 10 F8        	djnz MulLoop
 125++7CAD
 126++7CAD C9           	ret
 127++7CAE              	ENDIF
 128++7CAE
 129++7CAE              	endif
# file closed: math.asm
  28+ 7CAE
  29+ 7CAE              DRIVE_CUR_BAS	EQU 0
  30+ 7CAE              DRIVE_A_BAS		EQU	1
  31+ 7CAE              DRIVE_B_BAS		EQU	2
  32+ 7CAE              DRIVE_A_CPM		EQU	0
  33+ 7CAE              DRIVE_B_CPM		EQU	1
  34+ 7CAE              ;Disk geometry stuff
  35+ 7CAE              SPT				EQU	16			;sectors per track
  36+ 7CAE              SECT_SZ			EQU	256			;sector size in bytes
  37+ 7CAE              TRACK_CNT		EQU	80			;track count
  38+ 7CAE              HEAD_CNT		EQU	2			;disk face count
  39+ 7CAE              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 7CAE              EXT_SZ			EQU	32			;directory entry size
  41+ 7CAE              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 7CAE              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 7CAE              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 7CAE              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 7CAE              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 7CAE              REC_SZ			EQU 128			;cp/m record size
  47+ 7CAE              DEL_MARKER		EQU	$E5
  48+ 7CAE
  49+ 7CAE
  50+ 7CAE              ;Extension structure (directory entry)
  51+ 7CAE              EXT_DEL_FLAG	EQU	0
  52+ 7CAE              EXT_NAME		EQU 1
  53+ 7CAE              EXT_IDX			EQU 12
  54+ 7CAE              EXT_S1			EQU 13
  55+ 7CAE              EXT_S2			EQU 14
  56+ 7CAE              EXT_RC			EQU	15
  57+ 7CAE              EXT_AU0			EQU	16
  58+ 7CAE              EXT_AU1			EQU	18
  59+ 7CAE              EXT_AU2			EQU	20
  60+ 7CAE              EXT_AU3			EQU	22
  61+ 7CAE              EXT_AU4			EQU	24
  62+ 7CAE              EXT_AU5			EQU	26
  63+ 7CAE              EXT_AU6			EQU	28
  64+ 7CAE              EXT_AU7			EQU	30
  65+ 7CAE              EXT_SIZE		EQU 32
  66+ 7CAE
  67+ 7CAE              ;FCB structure
  68+ 7CAE              FCB_DRIVE		EQU 0
  69+ 7CAE              FCB_NAME		EQU EXT_NAME
  70+ 7CAE              FCB_EX_IDX		EQU EXT_IDX
  71+ 7CAE              FCB_S1			EQU EXT_S1
  72+ 7CAE              FCB_S2			EQU EXT_S2
  73+ 7CAE              FCB_RC			EQU	EXT_RC
  74+ 7CAE              FCB_AU			EQU	EXT_AU0
  75+ 7CAE              FCB_CR			EQU	32
  76+ 7CAE              FCB_R0			EQU 33
  77+ 7CAE              FCB_R1			EQU 34
  78+ 7CAE              FCB_R2			EQU 35
  79+ 7CAE              FCB_SIZE		EQU 36
  80+ 7CAE
  81+ 7CAE
  82+ 7CAE
  83+ 7CAE              ;System variables for disk
  84+ 7CAE              DSTR1			EQU	$5CD6		;drive
  85+ 7CAE              FSTR1			EQU	$5CDC		;file name
  86+ 7CAE              NSTR1			EQU	$5CDA		;name length
  87+ 7CAE              HD11			EQU	$5CED		;BDOS argument
  88+ 7CAE              COPIES			EQU	$5CEF		;BDOS function
  89+ 7CAE
  90+ 7CAE              ERRSP			EQU $5C3D
  91+ 7CAE              ERRNR			EQU $5C3A
  92+ 7CAE              ERRMSG			EQU	$0260
  93+ 7CAE
  94+ 7CAE              PROG			EQU $5C53
  95+ 7CAE              VARS			EQU	$5C4B
  96+ 7CAE              STKEND			EQU	$5C65
  97+ 7CAE
  98+ 7CAE              PRN_BUF			EQU	23296
  99+ 7CAE
 100+ 7CAE              ;STR_COPYRIGHT	EQU	$1539
 101+ 7CAE
 102+ 7CAE              REPDEL			EQU	23561
 103+ 7CAE              REPPER			EQU	23562
 104+ 7CAE              PIP				EQU	23609
 105+ 7CAE
 106+ 7CAE
 107+ 7CAE              ;RWTS routine commands
 108+ 7CAE              RWTS_CMD_POS	EQU	0			;position head
 109+ 7CAE              RWTS_CMD_READ	EQU	1			;read sector
 110+ 7CAE              RWTS_CMD_WRITE	EQU	2			;write sector
 111+ 7CAE              RWTS_CMD_FMT	EQU	4			;format all tracks
 112+ 7CAE
 113+ 7CAE
 114+ 7CAE              ;File name stuff
 115+ 7CAE              NAMELEN			EQU	11			;name length
 116+ 7CAE              RO_POS			EQU	8			;read-only attribute position in name
 117+ 7CAE              SYS_POS			EQU	9			;system attribute position in name
 118+ 7CAE
 119+ 7CAE              ;File types (first byte in header)
 120+ 7CAE              PROG_TYPE		EQU	0			;program
 121+ 7CAE              NUMB_TYPE		EQU	1			;number array
 122+ 7CAE              CHAR_TYPE		EQU	2			;char array
 123+ 7CAE              BYTE_TYPE		EQU	3			;bytes
 124+ 7CAE              TEXT_TYPE		EQU	4			;text, >= 4
 125+ 7CAE
 126+ 7CAE              ;File header offsets
 127+ 7CAE              HDR_TYPE		EQU	0
 128+ 7CAE              HDR_LEN			EQU 1
 129+ 7CAE              HDR_ADDR		EQU 3
 130+ 7CAE              HDR_PLEN		EQU	5
 131+ 7CAE              HDR_LINE		EQU 7
 132+ 7CAE              HDR_SZ			EQU	9
 133+ 7CAE
 134+ 7CAE              ;BASIC disk channel structure
 135+ 7CAE              CH_RW_FLAG		EQU 11
 136+ 7CAE              CH_FCB			EQU	12
 137+ 7CAE              CH_DATA			EQU	50
 138+ 7CAE              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 139+ 7CAE
 140+ 7CAE              CACHE_NAME		EQU	0					;11B
 141+ 7CAE              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 142+ 7CAE              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 143+ 7CAE              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 144+ 7CAE              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 145+ 7CAE              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 146+ 7CAE
 147+ 7CAE              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 148+ 7CAE
 149+ 7CAE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 150+ 7CAE              IF1Init:
 151+ 7CAE CF           	rst		08
 152+ 7CAF 31           	defb	49		;create system variables
 153+ 7CB0 C9           	ret
 154+ 7CB1
 155+ 7CB1              ;ReadWriteTrackSector
 156+ 7CB1              ;A=command: 0, 1, 2, 4
 157+ 7CB1              RWTS:
 158+ 7CB1 32 8E 7F     	ld (RWTSCmd), a
 159+ 7CB4 21 83 7F     	ld hl, RWTSParams
 160+ 7CB7 22 ED 5C     	ld (HD11), hl
 161+ 7CBA CF           	rst 08
 162+ 7CBB 3A           	DEFB 58
 163+ 7CBC C9           	ret
 164+ 7CBD
 165+ 7CBD
 166+ 7CBD              ;D = sector, E = track
 167+ 7CBD              ;HL = dma
 168+ 7CBD              ReadOneDiskSector:
 169+ 7CBD 22 88 7F     	ld (RWTSDMA), hl
 170+ 7CC0 ED 53 86 7F  	ld (RWTSTrack), de
 171+ 7CC4              	;ld (RWTSDrive), a
 172+ 7CC4 3E 01        	ld a, RWTS_CMD_READ
 173+ 7CC6 18 E9        	jr	RWTS
 174+ 7CC8
 175+ 7CC8              ;D = sector, E = track
 176+ 7CC8              ;HL = dma
 177+ 7CC8              WriteOneDiskSector:
 178+ 7CC8 22 88 7F     	ld (RWTSDMA), hl
 179+ 7CCB ED 53 86 7F  	ld (RWTSTrack), de
 180+ 7CCF              	;ld (RWTSDrive), a
 181+ 7CCF 3E 02        	ld a, RWTS_CMD_WRITE
 182+ 7CD1 18 DE        	jr	RWTS
 183+ 7CD3
 184+ 7CD3              FormatDisk:
 185+ 7CD3 21 20 A5     	ld		hl, DataBuf
 186+ 7CD6 36 E5        	ld		(hl), DEL_MARKER
 187+ 7CD8 22 88 7F     	ld 		(RWTSDMA), hl
 188+ 7CDB 3E 04        	ld 		a, RWTS_CMD_FMT
 189+ 7CDD CD B1 7C     	call	RWTS
 190+ 7CE0 3A 8F 7F     	ld		a, (RWTSRes)
 191+ 7CE3 C9           	ret
 192+ 7CE4
 193+ 7CE4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 194+ 7CE4
 195+ 7CE4              ;Allocation unit no. to track/sector
 196+ 7CE4              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 197+ 7CE4              ;IN:  HL=alloc. unit no.
 198+ 7CE4              ;OUT: B=sector; C=track (head is determined by the sector number)
 199+ 7CE4              AU2TS:
 200+ 7CE4 0E 02        	ld c, SPT/SPAL
 201+ 7CE6 CD 7A 7C     	call Div					;A = sector
 202+ 7CE9 F5           	push af
 203+ 7CEA ~            		/*
 204+ 7CEA ~            		ld c, HEAD_CNT
 205+ 7CEA ~            		call Div				;L = track, A = head (0 or 1)
 206+ 7CEA ~            		*/
 207+ 7CEA AF           		xor a
 208+ 7CEB CB 1C        		rr h
 209+ 7CED CB 1D        		rr l
 210+ 7CEF CB 1F        		rr a
 211+ 7CF1
 212+ 7CF1 4D           		ld c, l
 213+ 7CF2 06 00        		ld b, 0
 214+ 7CF4 B7           		or a
 215+ 7CF5 28 02        		jr z, Track0
 216+ 7CF7 06 10        		ld b, SPT
 217+ 7CF9              Track0:
 218+ 7CF9 F1           	pop af
 219+ 7CFA B7           	or a
 220+ 7CFB 28 02        	jr z, FirstAU
 221+ 7CFD 3E 08        	ld a, SPAL
 222+ 7CFF              FirstAU:
 223+ 7CFF 80           	add a, b
 224+ 7D00 47           	ld  b, a
 225+ 7D01 C9           	ret
 226+ 7D02
 227+ 7D02              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 228+ 7D02
 229+ 7D02              ;Checks the allocation units number used in extension
 230+ 7D02              ;IN:	IX = extension addr
 231+ 7D02              ;OUT:	B = no. of allocation units used
 232+ 7D02              ;		C = no. of records used in ext.
 233+ 7D02              ;		HL = first alloc. unit no.
 234+ 7D02              ;		DE = last alloc. unit no.
 235+ 7D02              CheckExtAlloc:
 236+ 7D02 DD E5        	push ix
 237+ 7D04 01 0F 00     		ld bc, EXT_RC
 238+ 7D07 DD 09        		add ix, bc
 239+ 7D09 DD 4E 00     		ld c, (ix)			;save rec. no.
 240+ 7D0C DD 23        		inc ix
 241+ 7D0E DD 6E 00     		ld l, (ix)
 242+ 7D11 DD 66 01     		ld h, (ix + 1)
 243+ 7D14 06 08        		ld b, EXT_AU_CNT
 244+ 7D16              CheckAU:
 245+ 7D16 DD 7E 00     		ld a, (ix)
 246+ 7D19 DD B6 01     		or (ix + 1)
 247+ 7D1C 28 0C        		jr z, CheckAUEnd
 248+ 7D1E DD 5E 00     		ld e, (ix)
 249+ 7D21 DD 56 01     		ld d, (ix + 1)
 250+ 7D24 DD 23        		inc ix
 251+ 7D26 DD 23        		inc ix
 252+ 7D28 10 EC        		djnz CheckAU
 253+ 7D2A              CheckAUEnd:
 254+ 7D2A 3E 08        		ld a, EXT_AU_CNT
 255+ 7D2C 90           		sub b
 256+ 7D2D 47           		ld b, a
 257+ 7D2E DD E1        	pop ix
 258+ 7D30 C9           	ret
 259+ 7D31
 260+ 7D31              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 261+ 7D31
 262+ 7D31              ;Input: TrackBuffer
 263+ 7D31              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 264+ 7D31              ReadUsedBlocksList:
 265+ 7D31 DD 21 20 95  	ld		ix, TrackBuf			;source buffer
 266+ 7D35 21 20 A5     	ld		hl, UsedBlockListCnt 	;destination buffer
 267+ 7D38 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 268+ 7D3B 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 269+ 7D3E 73           	ld		(hl), e
 270+ 7D3F 23           	inc		hl
 271+ 7D40 72           	ld		(hl), d
 272+ 7D41 23           	inc		hl
 273+ 7D42
 274+ 7D42              	;Add blocks 0 and 1 for directory
 275+ 7D42 11 00 00     	ld		de, 0
 276+ 7D45 73           	ld		(hl), e
 277+ 7D46 23           	inc		hl
 278+ 7D47 72           	ld		(hl), d
 279+ 7D48 23           	inc		hl
 280+ 7D49
 281+ 7D49 13           	inc		de
 282+ 7D4A 73           	ld		(hl), e
 283+ 7D4B 23           	inc		hl
 284+ 7D4C 72           	ld		(hl), d
 285+ 7D4D 23           	inc		hl
 286+ 7D4E
 287+ 7D4E              ReadUsedBlocksLoop:
 288+ 7D4E AF           	xor		a
 289+ 7D4F DD BE 00     	cp		(ix)
 290+ 7D52 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 291+ 7D54
 292+ 7D54 DD E5        	push	ix
 293+ 7D56 C5           	push	bc
 294+ 7D57 06 08        		ld		b, EXT_AU_CNT
 295+ 7D59 11 10 00     		ld		de, EXT_AU0
 296+ 7D5C DD 19        		add		ix, de
 297+ 7D5E
 298+ 7D5E              ReadUsedBlocksLoop2:
 299+ 7D5E DD 5E 00     		ld		e, (ix)
 300+ 7D61 DD 56 01     		ld		d, (ix+1)
 301+ 7D64 7B           		ld		a, e
 302+ 7D65 B2           		or		d
 303+ 7D66 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 304+ 7D68
 305+ 7D68 73           		ld		(hl), e
 306+ 7D69 23           		inc		hl
 307+ 7D6A 72           		ld		(hl), d
 308+ 7D6B 23           		inc		hl
 309+ 7D6C
 310+ 7D6C DD 23        		inc		ix
 311+ 7D6E DD 23        		inc		ix
 312+ 7D70
 313+ 7D70 ED 5B 20 A5  		ld		de, (UsedBlockListCnt)
 314+ 7D74 13           		inc		de
 315+ 7D75 ED 53 20 A5  		ld		(UsedBlockListCnt), de
 316+ 7D79
 317+ 7D79 10 E3        		djnz	ReadUsedBlocksLoop2
 318+ 7D7B
 319+ 7D7B
 320+ 7D7B              ReadUsedBlocksSkip:
 321+ 7D7B C1           	pop		bc
 322+ 7D7C DD E1        	pop		ix
 323+ 7D7E              ReadUsedBlocksSkip2:
 324+ 7D7E 11 20 00     	ld		de, EXT_SZ
 325+ 7D81 DD 19        	add		ix, de
 326+ 7D83
 327+ 7D83 0B           	dec		bc
 328+ 7D84 78           	ld		a, b
 329+ 7D85 B1           	or		c
 330+ 7D86 20 C6        	jr		nz, ReadUsedBlocksLoop
 331+ 7D88
 332+ 7D88 C9           	ret
 333+ 7D89
 334+ 7D89              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 335+ 7D89              ;Reads 8 sectors for an AU
 336+ 7D89              ;HL = block number, DE = destination buffer
 337+ 7D89              ReadFSBlock:
 338+ 7D89 D5           	push	de
 339+ 7D8A CD E4 7C     		call	AU2TS		;B=sector, C=track
 340+ 7D8D E1           	pop		hl				;HL=dest
 341+ 7D8E
 342+ 7D8E 50           	ld		d, b
 343+ 7D8F 59           	ld		e, c
 344+ 7D90 06 08        	ld		b, SPAL
 345+ 7D92
 346+ 7D92              ReadFSBlockLoop:
 347+ 7D92 CD 7F 7E     	call	ReadDiskSectors
 348+ 7D95 C9           	ret
 349+ 7D96
 350+ 7D96
 351+ 7D96              ;Write 8 sectors for an AU
 352+ 7D96              ;HL = block number, DE = source buffer
 353+ 7D96              WriteFSBlock:
 354+ 7D96 D5           	push	de
 355+ 7D97 CD E4 7C     		call	AU2TS		;B=sector, C=track
 356+ 7D9A E1           	pop		hl				;HL=dest
 357+ 7D9B
 358+ 7D9B 50           	ld		d, b
 359+ 7D9C 59           	ld		e, c
 360+ 7D9D 06 08        	ld		b, SPAL
 361+ 7D9F
 362+ 7D9F              WriteFSBlockLoop:
 363+ 7D9F CD 92 7E     	call	WriteDiskSectors
 364+ 7DA2 C9           	ret
 365+ 7DA3
 366+ 7DA3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 367+ 7DA3              ;Copies the allocated blocks from one disk to another.
 368+ 7DA3              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 369+ 7DA3              CopyDisk:
 370+ 7DA3              	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 371+ 7DA3 CD 31 7D     	call	ReadUsedBlocksList
 372+ 7DA6 DD 21 22 A5  	ld		ix, UsedBlockListBlk
 373+ 7DAA
 374+ 7DAA              CopyDiskLoop:
 375+ 7DAA 2A 20 A5     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 376+ 7DAD 11 A4 88     	ld		de, MsgBlocksLeft
 377+ 7DB0 CD 3E 7C     	call	Byte2Txt
 378+ 7DB3 21 A4 88     	ld		hl, MsgBlocksLeft
 379+ 7DB6 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 380+ 7DB9 3E 8F        	ld		a, SCR_DEF_CLR | CLR_FLASH
 381+ 7DBB CD B7 81     	call	PrintStrClr
 382+ 7DBE
 383+ 7DBE              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 384+ 7DBE 21 0A 00     	ld		hl, MAX_AU_RAM
 385+ 7DC1 ED 4B 20 A5  	ld		bc, (UsedBlockListCnt)
 386+ 7DC5 B7           	or		a
 387+ 7DC6 ED 42        	sbc		hl, bc
 388+ 7DC8 30 03        	jr		nc, CopyDiskLoopRead
 389+ 7DCA 01 0A 00     	ld		bc, MAX_AU_RAM
 390+ 7DCD
 391+ 7DCD              CopyDiskLoopRead:
 392+ 7DCD 41           	ld		b, c
 393+ 7DCE 11 A2 A7     	ld		de, CopyDiskBuf
 394+ 7DD1              	;save initial counter and initial block number array position
 395+ 7DD1 C5           	push	bc
 396+ 7DD2 DD E5        	push	ix
 397+ 7DD4
 398+ 7DD4              CopyDiskLoopReadLoop:
 399+ 7DD4 DD 6E 00     		ld		l, (ix)
 400+ 7DD7 DD 66 01     		ld		h, (ix+1)
 401+ 7DDA DD 23        		inc		ix
 402+ 7DDC DD 23        		inc		ix
 403+ 7DDE
 404+ 7DDE D5           		push	de
 405+ 7DDF C5           		push	bc
 406+ 7DE0 CD 89 7D     			call	ReadFSBlock			;Stop on error or continue?
 407+ 7DE3 C1           		pop		bc
 408+ 7DE4 D1           		pop		de
 409+ 7DE5
 410+ 7DE5              		;+2048
 411+ 7DE5 7A           		ld		a, d
 412+ 7DE6 C6 08        		add		8
 413+ 7DE8 57           		ld		d, a
 414+ 7DE9
 415+ 7DE9 10 E9        		djnz	CopyDiskLoopReadLoop
 416+ 7DEB
 417+ 7DEB              		;alternate drive
 418+ 7DEB 3A 84 7F     		ld		a, (RWTSDrive)
 419+ 7DEE EE 03        		xor		%11
 420+ 7DF0 32 84 7F     		ld		(RWTSDrive), a
 421+ 7DF3
 422+ 7DF3              	;restore initial counter and initial block number array position
 423+ 7DF3 DD E1        	pop		ix
 424+ 7DF5 C1           	pop		bc
 425+ 7DF6 11 A2 A7     	ld		de, CopyDiskBuf
 426+ 7DF9 C5           	push	bc
 427+ 7DFA
 428+ 7DFA              CopyDiskLoopWriteLoop:
 429+ 7DFA DD 6E 00     		ld		l, (ix)
 430+ 7DFD DD 66 01     		ld		h, (ix+1)
 431+ 7E00 DD 23        		inc		ix
 432+ 7E02 DD 23        		inc		ix
 433+ 7E04
 434+ 7E04 D5           		push	de
 435+ 7E05 C5           		push	bc
 436+ 7E06 CD 96 7D     			call	WriteFSBlock		;Stop on error or continue?
 437+ 7E09 C1           		pop		bc
 438+ 7E0A D1           		pop		de
 439+ 7E0B
 440+ 7E0B              		;+2048
 441+ 7E0B 7A           		ld		a, d
 442+ 7E0C C6 08        		add		8
 443+ 7E0E 57           		ld		d, a
 444+ 7E0F
 445+ 7E0F 10 E9        		djnz	CopyDiskLoopWriteLoop
 446+ 7E11
 447+ 7E11              		;alternate drive again
 448+ 7E11 3A 84 7F     		ld		a, (RWTSDrive)
 449+ 7E14 EE 03        		xor		%11
 450+ 7E16 32 84 7F     		ld		(RWTSDrive), a
 451+ 7E19
 452+ 7E19 C1           	pop		bc
 453+ 7E1A 48           	ld		c, b
 454+ 7E1B 06 00        	ld		b, 0
 455+ 7E1D
 456+ 7E1D              	;Decrease number of blocks read by now.
 457+ 7E1D 2A 20 A5     	ld		hl, (UsedBlockListCnt)
 458+ 7E20 B7           	or		a
 459+ 7E21 ED 42        	sbc		hl, bc
 460+ 7E23 22 20 A5     	ld		(UsedBlockListCnt), hl
 461+ 7E26
 462+ 7E26 7D           	ld		a, l
 463+ 7E27 B4           	or		h
 464+ 7E28 C2 AA 7D     	jp		nz, CopyDiskLoop
 465+ 7E2B
 466+ 7E2B C9           	ret
 467+ 7E2C
 468+ 7E2C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 469+ 7E2C
 470+ 7E2C              ;Compare string at HL with the one at DE, max length B
 471+ 7E2C              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 472+ 7E2C              ;OUT: z flag, set = match, reset = mismatch
 473+ 7E2C              StrCmp:
 474+ 7E2C E5           	push hl
 475+ 7E2D D5           	push de
 476+ 7E2E              Compare:
 477+ 7E2E 1A           		ld a, (de)
 478+ 7E2F BE           		cp (hl)
 479+ 7E30 20 04        		jr nz, MisMatch
 480+ 7E32 23           		inc hl
 481+ 7E33 13           		inc de
 482+ 7E34 10 F8        		djnz Compare
 483+ 7E36              MisMatch:
 484+ 7E36 D1           	pop de
 485+ 7E37 E1           	pop hl
 486+ 7E38 C9           	ret
 487+ 7E39
 488+ 7E39              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 489+ 7E39
 490+ 7E39              ;Read a file into a buffer, sector by sector.
 491+ 7E39              ;It's relocatable, to moved and be used when loading a CODE block.
 492+ 7E39              ;It's not using BDOS, but using similar calls provided by IF1.
 493+ 7E39              ;In: HL = Name address, DE = buffer
 494+ 7E39              IF1FileLoad:
 495+ 7E39 D5           	push	de
 496+ 7E3A 22 DC 5C     		ld (FSTR1), hl
 497+ 7E3D 26 00        		ld h, 0
 498+ 7E3F 3A 84 7F     		ld a, (RWTSDrive)
 499+ 7E42 3C           		inc  a			;CP/M drive number to BASIC drive number
 500+ 7E43 6F           		ld	l, a
 501+ 7E44 22 D6 5C     		ld (DSTR1), hl
 502+ 7E47 2E 0B        		ld l,NAMELEN
 503+ 7E49 22 DA 5C     		ld (NSTR1), hl
 504+ 7E4C CF           		rst 08
 505+ 7E4D 33           		DEFB 51			;open disk channel
 506+ 7E4E
 507+ 7E4E CF           		rst		8
 508+ 7E4F 35           		defb	53		;read sector
 509+ 7E50 D1           	pop		de
 510+ 7E51 30 27        	jr		nc, FileFree
 511+ 7E53
 512+ 7E53 DD 7E 32     	ld		a, (ix + CH_DATA)
 513+ 7E56 FE 04        	cp		TEXT_TYPE
 514+ 7E58 30 12        	jr		nc, FileLoadNoHeader
 515+ 7E5A
 516+ 7E5A              FileLoadHeader:
 517+ 7E5A DD E5        	push	ix
 518+ 7E5C E1           	pop		hl
 519+ 7E5D 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 520+ 7E60 09           	add		hl, bc
 521+ 7E61 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 522+ 7E64 ED B0        	ldir
 523+ 7E66
 524+ 7E66              FileReadLoop:
 525+ 7E66 D5           	push	de
 526+ 7E67 CF           		rst		8
 527+ 7E68 35           		defb	53		;read sector
 528+ 7E69 D1           	pop		de
 529+ 7E6A 30 0E        	jr		nc, FileFree
 530+ 7E6C
 531+ 7E6C              FileLoadNoHeader:
 532+ 7E6C DD E5        	push	ix
 533+ 7E6E E1           	pop		hl
 534+ 7E6F 01 32 00     	ld		bc, CH_DATA
 535+ 7E72 09           	add		hl, bc
 536+ 7E73 01 00 01     	ld		bc, SECT_SZ
 537+ 7E76 ED B0        	ldir
 538+ 7E78 18 EC        	jr		FileReadLoop
 539+ 7E7A              ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 540+ 7E7A              IF1FileLoadEnd:
 541+ 7E7A
 542+ 7E7A              FileFree:
 543+ 7E7A D5           	push	de
 544+ 7E7B CF           	rst		8
 545+ 7E7C 38           	defb	56			;close channel (52) or detroy channel (56)
 546+ 7E7D D1           	pop		de
 547+ 7E7E C9           	ret
 548+ 7E7F
 549+ 7E7F
 550+ 7E7F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 551+ 7E7F              ;HL = destination buffer, B = count of sectors, DE = track/sector
 552+ 7E7F              ;Out: A = error code, 0=OK
 553+ 7E7F              ReadDiskSectors:
 554+ 7E7F C5           	push bc
 555+ 7E80 E5           		push hl
 556+ 7E81 D5           			push de
 557+ 7E82 CD BD 7C     				call ReadOneDiskSector
 558+ 7E85 D1           			pop de
 559+ 7E86 E1           		pop hl
 560+ 7E87
 561+ 7E87 14           		inc d
 562+ 7E88 24           		inc h
 563+ 7E89 C1           	pop bc
 564+ 7E8A
 565+ 7E8A 3A 8F 7F     	ld	a, (RWTSRes)
 566+ 7E8D B7           	or	a
 567+ 7E8E C0           	ret nz
 568+ 7E8F
 569+ 7E8F 10 EE        	djnz ReadDiskSectors
 570+ 7E91 C9           	ret
 571+ 7E92
 572+ 7E92              ;HL = source buffer, B = count of sectors, DE = track/sector
 573+ 7E92              ;Out: A = error code, 0=OK
 574+ 7E92              WriteDiskSectors:
 575+ 7E92 C5           	push bc
 576+ 7E93 E5           		push hl
 577+ 7E94 D5           			push de
 578+ 7E95 CD C8 7C     				call WriteOneDiskSector
 579+ 7E98 D1           			pop de
 580+ 7E99 E1           		pop hl
 581+ 7E9A
 582+ 7E9A 14           		inc d
 583+ 7E9B 24           		inc h
 584+ 7E9C C1           	pop bc
 585+ 7E9D
 586+ 7E9D 3A 8F 7F     	ld	a, (RWTSRes)
 587+ 7EA0 B7           	or	a
 588+ 7EA1 C0           	ret nz
 589+ 7EA2
 590+ 7EA2 10 EE        	djnz WriteDiskSectors
 591+ 7EA4 C9           	ret
 592+ 7EA5
 593+ 7EA5
 594+ 7EA5              ;Reads disk catalog
 595+ 7EA5              ReadCatalogTrack:
 596+ 7EA5 21 20 95     	ld hl, TrackBuf
 597+ 7EA8 11 00 00     	ld de, 0
 598+ 7EAB 06 10        	ld b, SPT
 599+ 7EAD
 600+ 7EAD CD 7F 7E     	call ReadDiskSectors
 601+ 7EB0 B7           	or   a
 602+ 7EB1 C0           	ret  nz
 603+ 7EB2
 604+ 7EB2              	;Sync with BDOS, to avoid disk R/O error on disk change
 605+ 7EB2 F5           	push  af
 606+ 7EB3 3A 84 7F     		ld  a, (RWTSDrive)
 607+ 7EB6 CD 99 7F     		call BDOSSelectDisk
 608+ 7EB9 CD 96 7F     		call BDOSInit
 609+ 7EBC F1           	pop   af
 610+ 7EBD C9           	ret
 611+ 7EBE
 612+ 7EBE
 613+ 7EBE
 614+ 7EBE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 615+ 7EBE
 616+ 7EBE              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 617+ 7EBE              FindCache:
 618+ 7EBE 06 0B        	ld		b, NAMELEN
 619+ 7EC0 CD 2C 7E     	call	StrCmp			;find the file to wich this extension belongs
 620+ 7EC3 C8           	ret		z
 621+ 7EC4
 622+ 7EC4 0D           	dec		c
 623+ 7EC5 20 02        	jr		nz, CacheNotFinished
 624+ 7EC7 B1           	or		c
 625+ 7EC8 C9           	ret
 626+ 7EC9
 627+ 7EC9              CacheNotFinished:
 628+ 7EC9 01 19 00     	ld		bc, CACHE_SZ
 629+ 7ECC 09           	add		hl, bc			;to the next cache line
 630+ 7ECD 18 EF        	jr		FindCache
 631+ 7ECF
 632+ 7ECF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 633+ 7ECF
 634+ 7ECF              	;ld		ix, (SelFileCache)
 635+ 7ECF              ReadFileHeader:
 636+ 7ECF DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 637+ 7ED2 B7           	or		a
 638+ 7ED3 C0           	ret		nz				;return if already read
 639+ 7ED4
 640+ 7ED4 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 641+ 7ED7 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 642+ 7EDA 7C           	ld		a, h
 643+ 7EDB B5           	or		l
 644+ 7EDC 28 46        	jr		z, ReadHeaderEnd
 645+ 7EDE
 646+ 7EDE CD E4 7C     	call	AU2TS
 647+ 7EE1 50           	ld		d, b
 648+ 7EE2 59           	ld		e, c
 649+ 7EE3 21 20 A5     	ld		hl, DataBuf
 650+ 7EE6 DD E5        	push	ix
 651+ 7EE8 DD E5        	push	ix
 652+ 7EEA CD BD 7C     		call	ReadOneDiskSector
 653+ 7EED E1           	pop		hl
 654+ 7EEE DD E1        	pop		ix
 655+ 7EF0
 656+ 7EF0 E5           	push	hl
 657+ 7EF1 21 20 A5     		ld		hl, DataBuf
 658+ 7EF4 CD 28 7F     		call	IsFileHeaderValid
 659+ 7EF7 E1           	pop		hl
 660+ 7EF8 B7           	or		a
 661+ 7EF9 28 14        	jr		z, ReadFileHeaderIsTextFile
 662+ 7EFB
 663+ 7EFB 01 10 00     	ld		bc, CACHE_HDR
 664+ 7EFE 09           	add		hl, bc
 665+ 7EFF EB           	ex		hl, de
 666+ 7F00 21 20 A5     	ld		hl, DataBuf
 667+ 7F03 01 09 00     	ld		bc, HDR_SZ
 668+ 7F06 ED B0        	ldir
 669+ 7F08
 670+ 7F08              	;For text files, read file size as reported by BDOS, since we don't have a header.
 671+ 7F08 3E 03        	ld		a, BYTE_TYPE
 672+ 7F0A DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 673+ 7F0D 30 15        	jr		nc, ReadHeaderEnd
 674+ 7F0F
 675+ 7F0F              ReadFileHeaderIsTextFile:
 676+ 7F0F DD E5        	push	ix
 677+ 7F11 DD E5        	push	ix
 678+ 7F13 E1           	pop		hl
 679+ 7F14 CD E4 7F     		call	GetFileSize
 680+ 7F17 DD E1        	pop		ix
 681+ 7F19 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 682+ 7F1C DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 683+ 7F1F 3E 04        	ld		a, TEXT_TYPE
 684+ 7F21 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 685+ 7F24
 686+ 7F24              ReadHeaderEnd:
 687+ 7F24 DD 34 0F     	inc		(ix + CACHE_FLAG)
 688+ 7F27 C9           	ret
 689+ 7F28
 690+ 7F28              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 691+ 7F28              ;Checks if the file header is valid. For now it checks to not have all 0s.
 692+ 7F28              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 693+ 7F28              ;In: HL = header
 694+ 7F28              ;Out: A > 0 if valid
 695+ 7F28              IsFileHeaderValid:
 696+ 7F28              	IFUSED
 697+ 7F28 AF           	xor		a
 698+ 7F29 06 09        	ld		b, HDR_SZ
 699+ 7F2B              IsFileHeaderValidLoop:
 700+ 7F2B B6           	or		(hl)
 701+ 7F2C 23           	inc		hl
 702+ 7F2D 10 FC        	djnz	IsFileHeaderValidLoop
 703+ 7F2F
 704+ 7F2F C9           	ret
 705+ 7F30              	ENDIF
 706+ 7F30
 707+ 7F30              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 708+ 7F30
 709+ 7F30              ;IN: HL = address from IF1 to call
 710+ 7F30              IF1Call:
 711+ 7F30 22 ED 5C     	LD   (HD11), HL
 712+ 7F33 CF           	RST  8
 713+ 7F34 32           	DEFB 50
 714+ 7F35 C9           	RET
 715+ 7F36
 716+ 7F36              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 717+ 7F36
 718+ 7F36              ;Load a program from disk
 719+ 7F36              ;IN: HL = file name addr
 720+ 7F36              LoadProgram:
 721+ 7F36 22 DC 5C     	LD   (FSTR1), HL
 722+ 7F39 26 00        	LD   H, 0
 723+ 7F3B 2E 0B        	LD   L, NAMELEN
 724+ 7F3D 22 DA 5C     	LD   (NSTR1), HL
 725+ 7F40 3A 84 7F     	LD	 A, (RWTSDrive)
 726+ 7F43 3C           	INC  A					;Adapt for BASIC drive number
 727+ 7F44 6F           	LD   L, A
 728+ 7F45 22 D6 5C     	LD   (DSTR1), HL
 729+ 7F48 21 41 0A     	LD   HL, LOAD_ADDR
 730+ 7F4B CD 30 7F     	CALL IF1Call
 731+ 7F4E C9           	RET
 732+ 7F4F
 733+ 7F4F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 734+ 7F4F
 735+ 7F4F              SetFastKeys:
 736+ 7F4F 21 09 5C     	ld		hl, REPDEL
 737+ 7F52 11 0F 01     	ld		de, (1 << 8) | 15
 738+ 7F55 73 23 72 2B  	ld		(hl), de
 739+ 7F59
 740+ 7F59 C9           	ret
 741+ 7F5A
 742+ 7F5A
 743+ 7F5A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 744+ 7F5A              ;Reads the error message string from IF1 ROM.
 745+ 7F5A              GetErrMsg:
 746+ 7F5A 3C           	inc		a
 747+ 7F5B 08           	ex		af, af'
 748+ 7F5C
 749+ 7F5C 21 65 7F     	ld		hl, IF1Paged			;page-in IF1
 750+ 7F5F 22 ED 5C     	ld		(HD11), hl
 751+ 7F62 CF           	rst		8
 752+ 7F63 32           	defb	50
 753+ 7F64 C9           	ret								;return after accesing IF1
 754+ 7F65
 755+ 7F65              IF1Paged:
 756+ 7F65 21 60 02     	ld		hl, ERRMSG
 757+ 7F68 08           	ex		af, af'
 758+ 7F69 B7           	or		a
 759+ 7F6A 28 0B        	jr		z, SaveMsg
 760+ 7F6C
 761+ 7F6C 06 00        	ld		b, 0
 762+ 7F6E              SearchMsgEnd:
 763+ 7F6E CB 7E        	bit		7, (hl)
 764+ 7F70 23           	inc		hl
 765+ 7F71 28 FB        	jr		z, SearchMsgEnd
 766+ 7F73
 767+ 7F73 04           	inc		b
 768+ 7F74 B8           	cp		b
 769+ 7F75 20 F7        	jr		nz, SearchMsgEnd
 770+ 7F77
 771+ 7F77              SaveMsg:
 772+ 7F77 11 20 A5     	ld		de, DataBuf
 773+ 7F7A              CopyMsg:
 774+ 7F7A 7E           	ld		a, (hl)
 775+ 7F7B CB 7F        	bit		7, a
 776+ 7F7D 12           	ld		(de), a
 777+ 7F7E 23           	inc		hl
 778+ 7F7F 13           	inc		de
 779+ 7F80 28 F8        	jr		z, CopyMsg
 780+ 7F82
 781+ 7F82 C9           	ret
 782+ 7F83
 783+ 7F83              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 784+ 7F83
 785+ 7F83              ;RWTS routine I/O block
 786+ 7F83              ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 787+ 7F83              RWTSParams:
 788+ 7F83 01           RWTSBlockType	DEFB	1							;?
 789+ 7F84 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 790+ 7F85 00           RWTSVolNo		DEFB	0							;?
 791+ 7F86 00           RWTSTrack		DEFB	0
 792+ 7F87 00           RWTSSector		DEFB	0
 793+ 7F88 00 00        RWTSDMA			DEFW	0
 794+ 7F8A 32 29        RWTSExtBuf		DEFW	$2932
 795+ 7F8C 2A 1F        RWTSPrmTbl		DEFW	$1f2a
 796+ 7F8E 01           RWTSCmd			DEFB	RWTS_CMD_READ
 797+ 7F8F              ;Results
 798+ 7F8F 00           RWTSRes			DEFB	0
 799+ 7F90 00           RWTSResVolNo	DEFB	0
 800+ 7F91 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 800+ 7F95 00
 801+ 7F96
 802+ 7F96              ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 803+ 7F96 ~            /*
 804+ 7F96 ~            BasPrmTbl:
 805+ 7F96 ~            PrmDevType		DEFB	$01			;$01
 806+ 7F96 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 807+ 7F96 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 808+ 7F96 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 809+ 7F96 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 810+ 7F96 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 811+ 7F96 ~            */
 812+ 7F96
 813+ 7F96              	endif
# file closed: disk.asm
1106  7F96              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7F96              ;BDOS functions - similar to CP/M
   2+ 7F96
   3+ 7F96              ;Error codes returned by BDOS/CP/M, taken from https://www.seasip.info/Cpm/bdos.html
   4+ 7F96              ;0 OK,
   5+ 7F96              ;1 directory full,
   6+ 7F96              ;2 disc full,
   7+ 7F96              ;9 invalid FCB,
   8+ 7F96              ;10(CP/M) media changed;
   9+ 7F96              ;0FFh hardware error.
  10+ 7F96
  11+ 7F96              	IFNDEF	_BDOS_
  12+ 7F96              	DEFINE	_BDOS_
  13+ 7F96
  14+ 7F96              	include "disk.asm"
# file opened: disk.asm
   1++7F96              ;HC IF1 routines and constants
   2++7F96
   3++7F96              ;IF1 routines error codes, also returned by BASIC commands
   4++7F96              ;12 = Writing to a 'read' file
   5++7F96              ;13 = Reading a 'write' file
   6++7F96              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7F96              ;15 = Disk full (disk or catalog full)
   8++7F96              ;16 = Disk error (hardware error)
   9++7F96              ;17 = File not found
  10++7F96              ;23 = Disk R/O (disk change detected, software R/O)
  11++7F96              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7F96
  13++7F96              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7F96              ;00h = OK
  15++7F96              ;08h = cannot format disk
  16++7F96              ;10h = disk protected (read-only?)
  17++7F96              ;20h = volume error
  18++7F96              ;40h = drive error
  19++7F96              ;80h = reading error
  20++7F96              ;Codes I encountered:
  21++7F96              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7F96
  23++7F96
  24++7F96              	ifndef	_DISK_
  25++7F96 ~            	define	_DISK_
  26++7F96 ~
  27++7F96 ~            	include	"math.asm"
  28++7F96 ~
  29++7F96 ~            DRIVE_CUR_BAS	EQU 0
  30++7F96 ~            DRIVE_A_BAS		EQU	1
  31++7F96 ~            DRIVE_B_BAS		EQU	2
  32++7F96 ~            DRIVE_A_CPM		EQU	0
  33++7F96 ~            DRIVE_B_CPM		EQU	1
  34++7F96 ~            ;Disk geometry stuff
  35++7F96 ~            SPT				EQU	16			;sectors per track
  36++7F96 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7F96 ~            TRACK_CNT		EQU	80			;track count
  38++7F96 ~            HEAD_CNT		EQU	2			;disk face count
  39++7F96 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7F96 ~            EXT_SZ			EQU	32			;directory entry size
  41++7F96 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7F96 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7F96 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7F96 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7F96 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7F96 ~            REC_SZ			EQU 128			;cp/m record size
  47++7F96 ~            DEL_MARKER		EQU	$E5
  48++7F96 ~
  49++7F96 ~
  50++7F96 ~            ;Extension structure (directory entry)
  51++7F96 ~            EXT_DEL_FLAG	EQU	0
  52++7F96 ~            EXT_NAME		EQU 1
  53++7F96 ~            EXT_IDX			EQU 12
  54++7F96 ~            EXT_S1			EQU 13
  55++7F96 ~            EXT_S2			EQU 14
  56++7F96 ~            EXT_RC			EQU	15
  57++7F96 ~            EXT_AU0			EQU	16
  58++7F96 ~            EXT_AU1			EQU	18
  59++7F96 ~            EXT_AU2			EQU	20
  60++7F96 ~            EXT_AU3			EQU	22
  61++7F96 ~            EXT_AU4			EQU	24
  62++7F96 ~            EXT_AU5			EQU	26
  63++7F96 ~            EXT_AU6			EQU	28
  64++7F96 ~            EXT_AU7			EQU	30
  65++7F96 ~            EXT_SIZE		EQU 32
  66++7F96 ~
  67++7F96 ~            ;FCB structure
  68++7F96 ~            FCB_DRIVE		EQU 0
  69++7F96 ~            FCB_NAME		EQU EXT_NAME
  70++7F96 ~            FCB_EX_IDX		EQU EXT_IDX
  71++7F96 ~            FCB_S1			EQU EXT_S1
  72++7F96 ~            FCB_S2			EQU EXT_S2
  73++7F96 ~            FCB_RC			EQU	EXT_RC
  74++7F96 ~            FCB_AU			EQU	EXT_AU0
  75++7F96 ~            FCB_CR			EQU	32
  76++7F96 ~            FCB_R0			EQU 33
  77++7F96 ~            FCB_R1			EQU 34
  78++7F96 ~            FCB_R2			EQU 35
  79++7F96 ~            FCB_SIZE		EQU 36
  80++7F96 ~
  81++7F96 ~
  82++7F96 ~
  83++7F96 ~            ;System variables for disk
  84++7F96 ~            DSTR1			EQU	$5CD6		;drive
  85++7F96 ~            FSTR1			EQU	$5CDC		;file name
  86++7F96 ~            NSTR1			EQU	$5CDA		;name length
  87++7F96 ~            HD11			EQU	$5CED		;BDOS argument
  88++7F96 ~            COPIES			EQU	$5CEF		;BDOS function
  89++7F96 ~
  90++7F96 ~            ERRSP			EQU $5C3D
  91++7F96 ~            ERRNR			EQU $5C3A
  92++7F96 ~            ERRMSG			EQU	$0260
  93++7F96 ~
  94++7F96 ~            PROG			EQU $5C53
  95++7F96 ~            VARS			EQU	$5C4B
  96++7F96 ~            STKEND			EQU	$5C65
  97++7F96 ~
  98++7F96 ~            PRN_BUF			EQU	23296
  99++7F96 ~
 100++7F96 ~            ;STR_COPYRIGHT	EQU	$1539
 101++7F96 ~
 102++7F96 ~            REPDEL			EQU	23561
 103++7F96 ~            REPPER			EQU	23562
 104++7F96 ~            PIP				EQU	23609
 105++7F96 ~
 106++7F96 ~
 107++7F96 ~            ;RWTS routine commands
 108++7F96 ~            RWTS_CMD_POS	EQU	0			;position head
 109++7F96 ~            RWTS_CMD_READ	EQU	1			;read sector
 110++7F96 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 111++7F96 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 112++7F96 ~
 113++7F96 ~
 114++7F96 ~            ;File name stuff
 115++7F96 ~            NAMELEN			EQU	11			;name length
 116++7F96 ~            RO_POS			EQU	8			;read-only attribute position in name
 117++7F96 ~            SYS_POS			EQU	9			;system attribute position in name
 118++7F96 ~
 119++7F96 ~            ;File types (first byte in header)
 120++7F96 ~            PROG_TYPE		EQU	0			;program
 121++7F96 ~            NUMB_TYPE		EQU	1			;number array
 122++7F96 ~            CHAR_TYPE		EQU	2			;char array
 123++7F96 ~            BYTE_TYPE		EQU	3			;bytes
 124++7F96 ~            TEXT_TYPE		EQU	4			;text, >= 4
 125++7F96 ~
 126++7F96 ~            ;File header offsets
 127++7F96 ~            HDR_TYPE		EQU	0
 128++7F96 ~            HDR_LEN			EQU 1
 129++7F96 ~            HDR_ADDR		EQU 3
 130++7F96 ~            HDR_PLEN		EQU	5
 131++7F96 ~            HDR_LINE		EQU 7
 132++7F96 ~            HDR_SZ			EQU	9
 133++7F96 ~
 134++7F96 ~            ;BASIC disk channel structure
 135++7F96 ~            CH_RW_FLAG		EQU 11
 136++7F96 ~            CH_FCB			EQU	12
 137++7F96 ~            CH_DATA			EQU	50
 138++7F96 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 139++7F96 ~
 140++7F96 ~            CACHE_NAME		EQU	0					;11B
 141++7F96 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 142++7F96 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 143++7F96 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 144++7F96 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 145++7F96 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 146++7F96 ~
 147++7F96 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 148++7F96 ~
 149++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 150++7F96 ~            IF1Init:
 151++7F96 ~            	rst		08
 152++7F96 ~            	defb	49		;create system variables
 153++7F96 ~            	ret
 154++7F96 ~
 155++7F96 ~            ;ReadWriteTrackSector
 156++7F96 ~            ;A=command: 0, 1, 2, 4
 157++7F96 ~            RWTS:
 158++7F96 ~            	ld (RWTSCmd), a
 159++7F96 ~            	ld hl, RWTSParams
 160++7F96 ~            	ld (HD11), hl
 161++7F96 ~            	rst 08
 162++7F96 ~            	DEFB 58
 163++7F96 ~            	ret
 164++7F96 ~
 165++7F96 ~
 166++7F96 ~            ;D = sector, E = track
 167++7F96 ~            ;HL = dma
 168++7F96 ~            ReadOneDiskSector:
 169++7F96 ~            	ld (RWTSDMA), hl
 170++7F96 ~            	ld (RWTSTrack), de
 171++7F96 ~            	;ld (RWTSDrive), a
 172++7F96 ~            	ld a, RWTS_CMD_READ
 173++7F96 ~            	jr	RWTS
 174++7F96 ~
 175++7F96 ~            ;D = sector, E = track
 176++7F96 ~            ;HL = dma
 177++7F96 ~            WriteOneDiskSector:
 178++7F96 ~            	ld (RWTSDMA), hl
 179++7F96 ~            	ld (RWTSTrack), de
 180++7F96 ~            	;ld (RWTSDrive), a
 181++7F96 ~            	ld a, RWTS_CMD_WRITE
 182++7F96 ~            	jr	RWTS
 183++7F96 ~
 184++7F96 ~            FormatDisk:
 185++7F96 ~            	ld		hl, DataBuf
 186++7F96 ~            	ld		(hl), DEL_MARKER
 187++7F96 ~            	ld 		(RWTSDMA), hl
 188++7F96 ~            	ld 		a, RWTS_CMD_FMT
 189++7F96 ~            	call	RWTS
 190++7F96 ~            	ld		a, (RWTSRes)
 191++7F96 ~            	ret
 192++7F96 ~
 193++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 194++7F96 ~
 195++7F96 ~            ;Allocation unit no. to track/sector
 196++7F96 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 197++7F96 ~            ;IN:  HL=alloc. unit no.
 198++7F96 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 199++7F96 ~            AU2TS:
 200++7F96 ~            	ld c, SPT/SPAL
 201++7F96 ~            	call Div					;A = sector
 202++7F96 ~            	push af
 203++7F96 ~            		/*
 204++7F96 ~            		ld c, HEAD_CNT
 205++7F96 ~            		call Div				;L = track, A = head (0 or 1)
 206++7F96 ~            		*/
 207++7F96 ~            		xor a
 208++7F96 ~            		rr h
 209++7F96 ~            		rr l
 210++7F96 ~            		rr a
 211++7F96 ~
 212++7F96 ~            		ld c, l
 213++7F96 ~            		ld b, 0
 214++7F96 ~            		or a
 215++7F96 ~            		jr z, Track0
 216++7F96 ~            		ld b, SPT
 217++7F96 ~            Track0:
 218++7F96 ~            	pop af
 219++7F96 ~            	or a
 220++7F96 ~            	jr z, FirstAU
 221++7F96 ~            	ld a, SPAL
 222++7F96 ~            FirstAU:
 223++7F96 ~            	add a, b
 224++7F96 ~            	ld  b, a
 225++7F96 ~            	ret
 226++7F96 ~
 227++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 228++7F96 ~
 229++7F96 ~            ;Checks the allocation units number used in extension
 230++7F96 ~            ;IN:	IX = extension addr
 231++7F96 ~            ;OUT:	B = no. of allocation units used
 232++7F96 ~            ;		C = no. of records used in ext.
 233++7F96 ~            ;		HL = first alloc. unit no.
 234++7F96 ~            ;		DE = last alloc. unit no.
 235++7F96 ~            CheckExtAlloc:
 236++7F96 ~            	push ix
 237++7F96 ~            		ld bc, EXT_RC
 238++7F96 ~            		add ix, bc
 239++7F96 ~            		ld c, (ix)			;save rec. no.
 240++7F96 ~            		inc ix
 241++7F96 ~            		ld l, (ix)
 242++7F96 ~            		ld h, (ix + 1)
 243++7F96 ~            		ld b, EXT_AU_CNT
 244++7F96 ~            CheckAU:
 245++7F96 ~            		ld a, (ix)
 246++7F96 ~            		or (ix + 1)
 247++7F96 ~            		jr z, CheckAUEnd
 248++7F96 ~            		ld e, (ix)
 249++7F96 ~            		ld d, (ix + 1)
 250++7F96 ~            		inc ix
 251++7F96 ~            		inc ix
 252++7F96 ~            		djnz CheckAU
 253++7F96 ~            CheckAUEnd:
 254++7F96 ~            		ld a, EXT_AU_CNT
 255++7F96 ~            		sub b
 256++7F96 ~            		ld b, a
 257++7F96 ~            	pop ix
 258++7F96 ~            	ret
 259++7F96 ~
 260++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 261++7F96 ~
 262++7F96 ~            ;Input: TrackBuffer
 263++7F96 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 264++7F96 ~            ReadUsedBlocksList:
 265++7F96 ~            	ld		ix, TrackBuf			;source buffer
 266++7F96 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 267++7F96 ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 268++7F96 ~            	ld		de, 2					;counter of used blocks, start with 2
 269++7F96 ~            	ld		(hl), e
 270++7F96 ~            	inc		hl
 271++7F96 ~            	ld		(hl), d
 272++7F96 ~            	inc		hl
 273++7F96 ~
 274++7F96 ~            	;Add blocks 0 and 1 for directory
 275++7F96 ~            	ld		de, 0
 276++7F96 ~            	ld		(hl), e
 277++7F96 ~            	inc		hl
 278++7F96 ~            	ld		(hl), d
 279++7F96 ~            	inc		hl
 280++7F96 ~
 281++7F96 ~            	inc		de
 282++7F96 ~            	ld		(hl), e
 283++7F96 ~            	inc		hl
 284++7F96 ~            	ld		(hl), d
 285++7F96 ~            	inc		hl
 286++7F96 ~
 287++7F96 ~            ReadUsedBlocksLoop:
 288++7F96 ~            	xor		a
 289++7F96 ~            	cp		(ix)
 290++7F96 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 291++7F96 ~
 292++7F96 ~            	push	ix
 293++7F96 ~            	push	bc
 294++7F96 ~            		ld		b, EXT_AU_CNT
 295++7F96 ~            		ld		de, EXT_AU0
 296++7F96 ~            		add		ix, de
 297++7F96 ~
 298++7F96 ~            ReadUsedBlocksLoop2:
 299++7F96 ~            		ld		e, (ix)
 300++7F96 ~            		ld		d, (ix+1)
 301++7F96 ~            		ld		a, e
 302++7F96 ~            		or		d
 303++7F96 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 304++7F96 ~
 305++7F96 ~            		ld		(hl), e
 306++7F96 ~            		inc		hl
 307++7F96 ~            		ld		(hl), d
 308++7F96 ~            		inc		hl
 309++7F96 ~
 310++7F96 ~            		inc		ix
 311++7F96 ~            		inc		ix
 312++7F96 ~
 313++7F96 ~            		ld		de, (UsedBlockListCnt)
 314++7F96 ~            		inc		de
 315++7F96 ~            		ld		(UsedBlockListCnt), de
 316++7F96 ~
 317++7F96 ~            		djnz	ReadUsedBlocksLoop2
 318++7F96 ~
 319++7F96 ~
 320++7F96 ~            ReadUsedBlocksSkip:
 321++7F96 ~            	pop		bc
 322++7F96 ~            	pop		ix
 323++7F96 ~            ReadUsedBlocksSkip2:
 324++7F96 ~            	ld		de, EXT_SZ
 325++7F96 ~            	add		ix, de
 326++7F96 ~
 327++7F96 ~            	dec		bc
 328++7F96 ~            	ld		a, b
 329++7F96 ~            	or		c
 330++7F96 ~            	jr		nz, ReadUsedBlocksLoop
 331++7F96 ~
 332++7F96 ~            	ret
 333++7F96 ~
 334++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 335++7F96 ~            ;Reads 8 sectors for an AU
 336++7F96 ~            ;HL = block number, DE = destination buffer
 337++7F96 ~            ReadFSBlock:
 338++7F96 ~            	push	de
 339++7F96 ~            		call	AU2TS		;B=sector, C=track
 340++7F96 ~            	pop		hl				;HL=dest
 341++7F96 ~
 342++7F96 ~            	ld		d, b
 343++7F96 ~            	ld		e, c
 344++7F96 ~            	ld		b, SPAL
 345++7F96 ~
 346++7F96 ~            ReadFSBlockLoop:
 347++7F96 ~            	call	ReadDiskSectors
 348++7F96 ~            	ret
 349++7F96 ~
 350++7F96 ~
 351++7F96 ~            ;Write 8 sectors for an AU
 352++7F96 ~            ;HL = block number, DE = source buffer
 353++7F96 ~            WriteFSBlock:
 354++7F96 ~            	push	de
 355++7F96 ~            		call	AU2TS		;B=sector, C=track
 356++7F96 ~            	pop		hl				;HL=dest
 357++7F96 ~
 358++7F96 ~            	ld		d, b
 359++7F96 ~            	ld		e, c
 360++7F96 ~            	ld		b, SPAL
 361++7F96 ~
 362++7F96 ~            WriteFSBlockLoop:
 363++7F96 ~            	call	WriteDiskSectors
 364++7F96 ~            	ret
 365++7F96 ~
 366++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 367++7F96 ~            ;Copies the allocated blocks from one disk to another.
 368++7F96 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 369++7F96 ~            CopyDisk:
 370++7F96 ~            	;Get list of used blocks in current disk, stored in DataBuf, max 632 bytes
 371++7F96 ~            	call	ReadUsedBlocksList
 372++7F96 ~            	ld		ix, UsedBlockListBlk
 373++7F96 ~
 374++7F96 ~            CopyDiskLoop:
 375++7F96 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 376++7F96 ~            	ld		de, MsgBlocksLeft
 377++7F96 ~            	call	Byte2Txt
 378++7F96 ~            	ld		hl, MsgBlocksLeft
 379++7F96 ~            	ld		de, LST_LINE_MSG + 1 << 8
 380++7F96 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 381++7F96 ~            	call	PrintStrClr
 382++7F96 ~
 383++7F96 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 384++7F96 ~            	ld		hl, MAX_AU_RAM
 385++7F96 ~            	ld		bc, (UsedBlockListCnt)
 386++7F96 ~            	or		a
 387++7F96 ~            	sbc		hl, bc
 388++7F96 ~            	jr		nc, CopyDiskLoopRead
 389++7F96 ~            	ld		bc, MAX_AU_RAM
 390++7F96 ~
 391++7F96 ~            CopyDiskLoopRead:
 392++7F96 ~            	ld		b, c
 393++7F96 ~            	ld		de, CopyDiskBuf
 394++7F96 ~            	;save initial counter and initial block number array position
 395++7F96 ~            	push	bc
 396++7F96 ~            	push	ix
 397++7F96 ~
 398++7F96 ~            CopyDiskLoopReadLoop:
 399++7F96 ~            		ld		l, (ix)
 400++7F96 ~            		ld		h, (ix+1)
 401++7F96 ~            		inc		ix
 402++7F96 ~            		inc		ix
 403++7F96 ~
 404++7F96 ~            		push	de
 405++7F96 ~            		push	bc
 406++7F96 ~            			call	ReadFSBlock			;Stop on error or continue?
 407++7F96 ~            		pop		bc
 408++7F96 ~            		pop		de
 409++7F96 ~
 410++7F96 ~            		;+2048
 411++7F96 ~            		ld		a, d
 412++7F96 ~            		add		8
 413++7F96 ~            		ld		d, a
 414++7F96 ~
 415++7F96 ~            		djnz	CopyDiskLoopReadLoop
 416++7F96 ~
 417++7F96 ~            		;alternate drive
 418++7F96 ~            		ld		a, (RWTSDrive)
 419++7F96 ~            		xor		%11
 420++7F96 ~            		ld		(RWTSDrive), a
 421++7F96 ~
 422++7F96 ~            	;restore initial counter and initial block number array position
 423++7F96 ~            	pop		ix
 424++7F96 ~            	pop		bc
 425++7F96 ~            	ld		de, CopyDiskBuf
 426++7F96 ~            	push	bc
 427++7F96 ~
 428++7F96 ~            CopyDiskLoopWriteLoop:
 429++7F96 ~            		ld		l, (ix)
 430++7F96 ~            		ld		h, (ix+1)
 431++7F96 ~            		inc		ix
 432++7F96 ~            		inc		ix
 433++7F96 ~
 434++7F96 ~            		push	de
 435++7F96 ~            		push	bc
 436++7F96 ~            			call	WriteFSBlock		;Stop on error or continue?
 437++7F96 ~            		pop		bc
 438++7F96 ~            		pop		de
 439++7F96 ~
 440++7F96 ~            		;+2048
 441++7F96 ~            		ld		a, d
 442++7F96 ~            		add		8
 443++7F96 ~            		ld		d, a
 444++7F96 ~
 445++7F96 ~            		djnz	CopyDiskLoopWriteLoop
 446++7F96 ~
 447++7F96 ~            		;alternate drive again
 448++7F96 ~            		ld		a, (RWTSDrive)
 449++7F96 ~            		xor		%11
 450++7F96 ~            		ld		(RWTSDrive), a
 451++7F96 ~
 452++7F96 ~            	pop		bc
 453++7F96 ~            	ld		c, b
 454++7F96 ~            	ld		b, 0
 455++7F96 ~
 456++7F96 ~            	;Decrease number of blocks read by now.
 457++7F96 ~            	ld		hl, (UsedBlockListCnt)
 458++7F96 ~            	or		a
 459++7F96 ~            	sbc		hl, bc
 460++7F96 ~            	ld		(UsedBlockListCnt), hl
 461++7F96 ~
 462++7F96 ~            	ld		a, l
 463++7F96 ~            	or		h
 464++7F96 ~            	jp		nz, CopyDiskLoop
 465++7F96 ~
 466++7F96 ~            	ret
 467++7F96 ~
 468++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 469++7F96 ~
 470++7F96 ~            ;Compare string at HL with the one at DE, max length B
 471++7F96 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 472++7F96 ~            ;OUT: z flag, set = match, reset = mismatch
 473++7F96 ~            StrCmp:
 474++7F96 ~            	push hl
 475++7F96 ~            	push de
 476++7F96 ~            Compare:
 477++7F96 ~            		ld a, (de)
 478++7F96 ~            		cp (hl)
 479++7F96 ~            		jr nz, MisMatch
 480++7F96 ~            		inc hl
 481++7F96 ~            		inc de
 482++7F96 ~            		djnz Compare
 483++7F96 ~            MisMatch:
 484++7F96 ~            	pop de
 485++7F96 ~            	pop hl
 486++7F96 ~            	ret
 487++7F96 ~
 488++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 489++7F96 ~
 490++7F96 ~            ;Read a file into a buffer, sector by sector.
 491++7F96 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 492++7F96 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 493++7F96 ~            ;In: HL = Name address, DE = buffer
 494++7F96 ~            IF1FileLoad:
 495++7F96 ~            	push	de
 496++7F96 ~            		ld (FSTR1), hl
 497++7F96 ~            		ld h, 0
 498++7F96 ~            		ld a, (RWTSDrive)
 499++7F96 ~            		inc  a			;CP/M drive number to BASIC drive number
 500++7F96 ~            		ld	l, a
 501++7F96 ~            		ld (DSTR1), hl
 502++7F96 ~            		ld l,NAMELEN
 503++7F96 ~            		ld (NSTR1), hl
 504++7F96 ~            		rst 08
 505++7F96 ~            		DEFB 51			;open disk channel
 506++7F96 ~
 507++7F96 ~            		rst		8
 508++7F96 ~            		defb	53		;read sector
 509++7F96 ~            	pop		de
 510++7F96 ~            	jr		nc, FileFree
 511++7F96 ~
 512++7F96 ~            	ld		a, (ix + CH_DATA)
 513++7F96 ~            	cp		TEXT_TYPE
 514++7F96 ~            	jr		nc, FileLoadNoHeader
 515++7F96 ~
 516++7F96 ~            FileLoadHeader:
 517++7F96 ~            	push	ix
 518++7F96 ~            	pop		hl
 519++7F96 ~            	ld		bc, CH_DATA + HDR_SZ
 520++7F96 ~            	add		hl, bc
 521++7F96 ~            	ld		bc, SECT_SZ - HDR_SZ
 522++7F96 ~            	ldir
 523++7F96 ~
 524++7F96 ~            FileReadLoop:
 525++7F96 ~            	push	de
 526++7F96 ~            		rst		8
 527++7F96 ~            		defb	53		;read sector
 528++7F96 ~            	pop		de
 529++7F96 ~            	jr		nc, FileFree
 530++7F96 ~
 531++7F96 ~            FileLoadNoHeader:
 532++7F96 ~            	push	ix
 533++7F96 ~            	pop		hl
 534++7F96 ~            	ld		bc, CH_DATA
 535++7F96 ~            	add		hl, bc
 536++7F96 ~            	ld		bc, SECT_SZ
 537++7F96 ~            	ldir
 538++7F96 ~            	jr		FileReadLoop
 539++7F96 ~            ;Copy routine without FileFree as it messes the buffers, probably moves up variables.
 540++7F96 ~            IF1FileLoadEnd:
 541++7F96 ~
 542++7F96 ~            FileFree:
 543++7F96 ~            	push	de
 544++7F96 ~            	rst		8
 545++7F96 ~            	defb	56			;close channel (52) or detroy channel (56)
 546++7F96 ~            	pop		de
 547++7F96 ~            	ret
 548++7F96 ~
 549++7F96 ~
 550++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 551++7F96 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 552++7F96 ~            ;Out: A = error code, 0=OK
 553++7F96 ~            ReadDiskSectors:
 554++7F96 ~            	push bc
 555++7F96 ~            		push hl
 556++7F96 ~            			push de
 557++7F96 ~            				call ReadOneDiskSector
 558++7F96 ~            			pop de
 559++7F96 ~            		pop hl
 560++7F96 ~
 561++7F96 ~            		inc d
 562++7F96 ~            		inc h
 563++7F96 ~            	pop bc
 564++7F96 ~
 565++7F96 ~            	ld	a, (RWTSRes)
 566++7F96 ~            	or	a
 567++7F96 ~            	ret nz
 568++7F96 ~
 569++7F96 ~            	djnz ReadDiskSectors
 570++7F96 ~            	ret
 571++7F96 ~
 572++7F96 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 573++7F96 ~            ;Out: A = error code, 0=OK
 574++7F96 ~            WriteDiskSectors:
 575++7F96 ~            	push bc
 576++7F96 ~            		push hl
 577++7F96 ~            			push de
 578++7F96 ~            				call WriteOneDiskSector
 579++7F96 ~            			pop de
 580++7F96 ~            		pop hl
 581++7F96 ~
 582++7F96 ~            		inc d
 583++7F96 ~            		inc h
 584++7F96 ~            	pop bc
 585++7F96 ~
 586++7F96 ~            	ld	a, (RWTSRes)
 587++7F96 ~            	or	a
 588++7F96 ~            	ret nz
 589++7F96 ~
 590++7F96 ~            	djnz WriteDiskSectors
 591++7F96 ~            	ret
 592++7F96 ~
 593++7F96 ~
 594++7F96 ~            ;Reads disk catalog
 595++7F96 ~            ReadCatalogTrack:
 596++7F96 ~            	ld hl, TrackBuf
 597++7F96 ~            	ld de, 0
 598++7F96 ~            	ld b, SPT
 599++7F96 ~
 600++7F96 ~            	call ReadDiskSectors
 601++7F96 ~            	or   a
 602++7F96 ~            	ret  nz
 603++7F96 ~
 604++7F96 ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 605++7F96 ~            	push  af
 606++7F96 ~            		ld  a, (RWTSDrive)
 607++7F96 ~            		call BDOSSelectDisk
 608++7F96 ~            		call BDOSInit
 609++7F96 ~            	pop   af
 610++7F96 ~            	ret
 611++7F96 ~
 612++7F96 ~
 613++7F96 ~
 614++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 615++7F96 ~
 616++7F96 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 617++7F96 ~            FindCache:
 618++7F96 ~            	ld		b, NAMELEN
 619++7F96 ~            	call	StrCmp			;find the file to wich this extension belongs
 620++7F96 ~            	ret		z
 621++7F96 ~
 622++7F96 ~            	dec		c
 623++7F96 ~            	jr		nz, CacheNotFinished
 624++7F96 ~            	or		c
 625++7F96 ~            	ret
 626++7F96 ~
 627++7F96 ~            CacheNotFinished:
 628++7F96 ~            	ld		bc, CACHE_SZ
 629++7F96 ~            	add		hl, bc			;to the next cache line
 630++7F96 ~            	jr		FindCache
 631++7F96 ~
 632++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 633++7F96 ~
 634++7F96 ~            	;ld		ix, (SelFileCache)
 635++7F96 ~            ReadFileHeader:
 636++7F96 ~            	ld		a, (ix + CACHE_FLAG)
 637++7F96 ~            	or		a
 638++7F96 ~            	ret		nz				;return if already read
 639++7F96 ~
 640++7F96 ~            	ld		l, (ix + CACHE_FIRST_AU)
 641++7F96 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 642++7F96 ~            	ld		a, h
 643++7F96 ~            	or		l
 644++7F96 ~            	jr		z, ReadHeaderEnd
 645++7F96 ~
 646++7F96 ~            	call	AU2TS
 647++7F96 ~            	ld		d, b
 648++7F96 ~            	ld		e, c
 649++7F96 ~            	ld		hl, DataBuf
 650++7F96 ~            	push	ix
 651++7F96 ~            	push	ix
 652++7F96 ~            		call	ReadOneDiskSector
 653++7F96 ~            	pop		hl
 654++7F96 ~            	pop		ix
 655++7F96 ~
 656++7F96 ~            	push	hl
 657++7F96 ~            		ld		hl, DataBuf
 658++7F96 ~            		call	IsFileHeaderValid
 659++7F96 ~            	pop		hl
 660++7F96 ~            	or		a
 661++7F96 ~            	jr		z, ReadFileHeaderIsTextFile
 662++7F96 ~
 663++7F96 ~            	ld		bc, CACHE_HDR
 664++7F96 ~            	add		hl, bc
 665++7F96 ~            	ex		hl, de
 666++7F96 ~            	ld		hl, DataBuf
 667++7F96 ~            	ld		bc, HDR_SZ
 668++7F96 ~            	ldir
 669++7F96 ~
 670++7F96 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 671++7F96 ~            	ld		a, BYTE_TYPE
 672++7F96 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 673++7F96 ~            	jr		nc, ReadHeaderEnd
 674++7F96 ~
 675++7F96 ~            ReadFileHeaderIsTextFile:
 676++7F96 ~            	push	ix
 677++7F96 ~            	push	ix
 678++7F96 ~            	pop		hl
 679++7F96 ~            		call	GetFileSize
 680++7F96 ~            	pop		ix
 681++7F96 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 682++7F96 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 683++7F96 ~            	ld		a, TEXT_TYPE
 684++7F96 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 685++7F96 ~
 686++7F96 ~            ReadHeaderEnd:
 687++7F96 ~            	inc		(ix + CACHE_FLAG)
 688++7F96 ~            	ret
 689++7F96 ~
 690++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 691++7F96 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 692++7F96 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 693++7F96 ~            ;In: HL = header
 694++7F96 ~            ;Out: A > 0 if valid
 695++7F96 ~            IsFileHeaderValid:
 696++7F96 ~            	IFUSED
 697++7F96 ~            	xor		a
 698++7F96 ~            	ld		b, HDR_SZ
 699++7F96 ~            IsFileHeaderValidLoop:
 700++7F96 ~            	or		(hl)
 701++7F96 ~            	inc		hl
 702++7F96 ~            	djnz	IsFileHeaderValidLoop
 703++7F96 ~
 704++7F96 ~            	ret
 705++7F96 ~            	ENDIF
 706++7F96 ~
 707++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 708++7F96 ~
 709++7F96 ~            ;IN: HL = address from IF1 to call
 710++7F96 ~            IF1Call:
 711++7F96 ~            	LD   (HD11), HL
 712++7F96 ~            	RST  8
 713++7F96 ~            	DEFB 50
 714++7F96 ~            	RET
 715++7F96 ~
 716++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 717++7F96 ~
 718++7F96 ~            ;Load a program from disk
 719++7F96 ~            ;IN: HL = file name addr
 720++7F96 ~            LoadProgram:
 721++7F96 ~            	LD   (FSTR1), HL
 722++7F96 ~            	LD   H, 0
 723++7F96 ~            	LD   L, NAMELEN
 724++7F96 ~            	LD   (NSTR1), HL
 725++7F96 ~            	LD	 A, (RWTSDrive)
 726++7F96 ~            	INC  A					;Adapt for BASIC drive number
 727++7F96 ~            	LD   L, A
 728++7F96 ~            	LD   (DSTR1), HL
 729++7F96 ~            	LD   HL, LOAD_ADDR
 730++7F96 ~            	CALL IF1Call
 731++7F96 ~            	RET
 732++7F96 ~
 733++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 734++7F96 ~
 735++7F96 ~            SetFastKeys:
 736++7F96 ~            	ld		hl, REPDEL
 737++7F96 ~            	ld		de, (1 << 8) | 15
 738++7F96 ~            	ld		(hl), de
 739++7F96 ~
 740++7F96 ~            	ret
 741++7F96 ~
 742++7F96 ~
 743++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 744++7F96 ~            ;Reads the error message string from IF1 ROM.
 745++7F96 ~            GetErrMsg:
 746++7F96 ~            	inc		a
 747++7F96 ~            	ex		af, af'
 748++7F96 ~
 749++7F96 ~            	ld		hl, IF1Paged			;page-in IF1
 750++7F96 ~            	ld		(HD11), hl
 751++7F96 ~            	rst		8
 752++7F96 ~            	defb	50
 753++7F96 ~            	ret								;return after accesing IF1
 754++7F96 ~
 755++7F96 ~            IF1Paged:
 756++7F96 ~            	ld		hl, ERRMSG
 757++7F96 ~            	ex		af, af'
 758++7F96 ~            	or		a
 759++7F96 ~            	jr		z, SaveMsg
 760++7F96 ~
 761++7F96 ~            	ld		b, 0
 762++7F96 ~            SearchMsgEnd:
 763++7F96 ~            	bit		7, (hl)
 764++7F96 ~            	inc		hl
 765++7F96 ~            	jr		z, SearchMsgEnd
 766++7F96 ~
 767++7F96 ~            	inc		b
 768++7F96 ~            	cp		b
 769++7F96 ~            	jr		nz, SearchMsgEnd
 770++7F96 ~
 771++7F96 ~            SaveMsg:
 772++7F96 ~            	ld		de, DataBuf
 773++7F96 ~            CopyMsg:
 774++7F96 ~            	ld		a, (hl)
 775++7F96 ~            	bit		7, a
 776++7F96 ~            	ld		(de), a
 777++7F96 ~            	inc		hl
 778++7F96 ~            	inc		de
 779++7F96 ~            	jr		z, CopyMsg
 780++7F96 ~
 781++7F96 ~            	ret
 782++7F96 ~
 783++7F96 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 784++7F96 ~
 785++7F96 ~            ;RWTS routine I/O block
 786++7F96 ~            ;Only drive, track, sector seem to be considered, changing any other parameter doesn't have an effect.
 787++7F96 ~            RWTSParams:
 788++7F96 ~            RWTSBlockType	DEFB	1							;?
 789++7F96 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 790++7F96 ~            RWTSVolNo		DEFB	0							;?
 791++7F96 ~            RWTSTrack		DEFB	0
 792++7F96 ~            RWTSSector		DEFB	0
 793++7F96 ~            RWTSDMA			DEFW	0
 794++7F96 ~            RWTSExtBuf		DEFW	$2932
 795++7F96 ~            RWTSPrmTbl		DEFW	$1f2a
 796++7F96 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 797++7F96 ~            ;Results
 798++7F96 ~            RWTSRes			DEFB	0
 799++7F96 ~            RWTSResVolNo	DEFB	0
 800++7F96 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 801++7F96 ~
 802++7F96 ~            ;Param. table, found in ROM, cannot be overriden, it seems the IF1 routine always uses the constants from ROM.
 803++7F96 ~            /*
 804++7F96 ~            BasPrmTbl:
 805++7F96 ~            PrmDevType		DEFB	$01			;$01
 806++7F96 ~            PrmStepRate		DEFB	$06;$09		;$0D	(milisec)
 807++7F96 ~            PrmHeadLoad		DEFB	$10;$16		;$23	(milisec)
 808++7F96 ~            PrmSpinUp		DEFB	$20;$50		;$64	(1/100 sec)
 809++7F96 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 810++7F96 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 811++7F96 ~            */
 812++7F96 ~
 813++7F96              	endif
# file closed: disk.asm
  15+ 7F96
  16+ 7F96              BDOSInit:
  17+ 7F96 AF           	xor		a
  18+ 7F97 18 3D        	jr		BDOS
  19+ 7F99
  20+ 7F99
  21+ 7F99              ;IN: A = Drive to select
  22+ 7F99              BDOSSelectDisk:
  23+ 7F99              	IFUSED
  24+ 7F99 DD 6F        	ld		ixl, a
  25+ 7F9B DD 26 00     	ld		ixh, 0
  26+ 7F9E 3E 01        	ld		a, 1
  27+ 7FA0 18 34        	jr		BDOS
  28+ 7FA2              	ENDIF
  29+ 7FA2
  30+ 7FA2
  31+ 7FA2              BDOSMakeDiskRO:
  32+ 7FA2              	IFUSED
  33+ 7FA2 ~            	ld		a, 15
  34+ 7FA2 ~            	jr		BDOS
  35+ 7FA2              	ENDIF
  36+ 7FA2
  37+ 7FA2              ;Get Read Only flag
  38+ 7FA2              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  39+ 7FA2              BDOSGetDiskRO:
  40+ 7FA2              	IFUSED
  41+ 7FA2 ~            	ld	a, 16
  42+ 7FA2 ~            	jr	BDOS
  43+ 7FA2              	ENDIF
  44+ 7FA2
  45+ 7FA2              BDOSGetCurrentDisk:
  46+ 7FA2              	IFUSED
  47+ 7FA2 ~            	ld		a, 12
  48+ 7FA2 ~            	jr		BDOS
  49+ 7FA2              	ENDIF
  50+ 7FA2
  51+ 7FA2
  52+ 7FA2              ;Create a disk channel for BDOS access (does not open the file)
  53+ 7FA2              ;IN: HL=name addr, A=drive
  54+ 7FA2              ;OUT: IX=FCB
  55+ 7FA2              CreateChannel:
  56+ 7FA2 22 DC 5C     	ld (FSTR1), hl
  57+ 7FA5 26 00        	ld h,0
  58+ 7FA7 6F           	ld l,a
  59+ 7FA8 22 D6 5C     	ld (DSTR1), hl
  60+ 7FAB 2E 0B        	ld l,NAMELEN
  61+ 7FAD 22 DA 5C     	ld (NSTR1), hl
  62+ 7FB0 CF           	rst 08
  63+ 7FB1 37           	DEFB 55
  64+ 7FB2 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  65+ 7FB5 DD 09        	add ix, bc
  66+ 7FB7 C9           	ret
  67+ 7FB8
  68+ 7FB8
  69+ 7FB8              ;Destroy a BDOS channel
  70+ 7FB8              ;IN: IX=FCB
  71+ 7FB8              DestroyChannel:
  72+ 7FB8 C5           	push bc
  73+ 7FB9 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  74+ 7FBC DD 09        	add ix, bc
  75+ 7FBE CF           	rst 08
  76+ 7FBF 38           	DEFB 56
  77+ 7FC0 C1           	pop bc
  78+ 7FC1 C9           	ret
  79+ 7FC2
  80+ 7FC2
  81+ 7FC2              ;Input: IX=FCB
  82+ 7FC2              CreateFile:
  83+ 7FC2 3E 09        	ld	a, 9
  84+ 7FC4 18 10        	jr	BDOS
  85+ 7FC6
  86+ 7FC6              ;Input: IX=FCB
  87+ 7FC6              OpenFile:
  88+ 7FC6 3E 02        	ld	a, 2
  89+ 7FC8 18 0C        	jr	BDOS
  90+ 7FCA
  91+ 7FCA              ;IN: IX=FCB
  92+ 7FCA              CloseFile:
  93+ 7FCA 3E 03        	ld	a, 3
  94+ 7FCC 18 08        	jr	BDOS
  95+ 7FCE
  96+ 7FCE              ;IN: IX=FCB
  97+ 7FCE              ReadFileBlock:
  98+ 7FCE 3E 07        	ld	a, 7
  99+ 7FD0 18 04        	jr	BDOS
 100+ 7FD2
 101+ 7FD2              ;IN: IX=FCB
 102+ 7FD2              WriteFileBlock:
 103+ 7FD2 3E 08        	ld	a, 8
 104+ 7FD4 18 00        	jr	BDOS
 105+ 7FD6
 106+ 7FD6              ;Generic BDOS call
 107+ 7FD6              ;IX=arg, A=function
 108+ 7FD6              BDOS:
 109+ 7FD6 DD 22 ED 5C  	ld (HD11), ix
 110+ 7FDA 32 EF 5C     	ld (COPIES), a
 111+ 7FDD CF           	rst 08
 112+ 7FDE 39           	DEFB 57
 113+ 7FDF C9           	ret
 114+ 7FE0
 115+ 7FE0              ;FindFirst
 116+ 7FE0              ;IX=fcb
 117+ 7FE0              BDOSFindFirst:
 118+ 7FE0              	IFUSED
 119+ 7FE0 ~            	ld a, 4
 120+ 7FE0 ~            	jr BDOS
 121+ 7FE0              	ENDIF
 122+ 7FE0
 123+ 7FE0              ;FindNext
 124+ 7FE0              ;IX=fcb
 125+ 7FE0              BDOSFindNext:
 126+ 7FE0              	IFUSED
 127+ 7FE0 ~            	ld a, 5
 128+ 7FE0 ~            	jr BDOS
 129+ 7FE0              	ENDIF
 130+ 7FE0
 131+ 7FE0
 132+ 7FE0              ;Set DMA address for BDOS
 133+ 7FE0              ;IX=DMA
 134+ 7FE0              BDOSSetDMA:
 135+ 7FE0 3E 0D        	ld a, 13
 136+ 7FE2 18 F2        	jr BDOS
 137+ 7FE4
 138+ 7FE4
 139+ 7FE4              ;In: HL=filename
 140+ 7FE4              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 141+ 7FE4              GetFileSize:
 142+ 7FE4              	IFUSED
 143+ 7FE4
 144+ 7FE4 3A 84 7F     	ld 		a, (RWTSDrive)
 145+ 7FE7 3C           	inc		a					;Convert to BASIC drive number: 1,2
 146+ 7FE8 CD A2 7F     	call	CreateChannel
 147+ 7FEB
 148+ 7FEB 3E 14        	ld		a, 20
 149+ 7FED CD D6 7F     	call	BDOS
 150+ 7FF0              	;inc		a
 151+ 7FF0              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 152+ 7FF0
 153+ 7FF0 DD 6E 21     	ld		l, (ix + FCB_R0)
 154+ 7FF3 DD 66 22     	ld		h, (ix + FCB_R1)
 155+ 7FF6
 156+ 7FF6              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 157+ 7FF6 3E 01        	ld		a, 1
 158+ 7FF8 BC           	cp		h
 159+ 7FF9 30 05        	jr		nc, GetFileSizeOK
 160+ 7FFB 21 00 00     	ld		hl, 0
 161+ 7FFE 18 08        	jr		GetFileSizeEnd
 162+ 8000
 163+ 8000              GetFileSizeOK:
 164+ 8000              	;*128 == 2^7
 165+ 8000 06 07        	ld		b, 7
 166+ 8002              GetFileSizeMul:
 167+ 8002 CB 15        	rl		l
 168+ 8004 CB 14        	rl		h
 169+ 8006 10 FA        	djnz	GetFileSizeMul
 170+ 8008
 171+ 8008              GetFileSizeEnd:
 172+ 8008 E5           	push	hl
 173+ 8009 CD B8 7F     		call	DestroyChannel
 174+ 800C E1           	pop		hl
 175+ 800D
 176+ 800D C9           	ret
 177+ 800E              	ENDIF
 178+ 800E
 179+ 800E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 180+ 800E              ;HL=file name, A=drive
 181+ 800E              DeleteFile:
 182+ 800E CD A2 7F     	call	CreateChannel
 183+ 8011
 184+ 8011 3E 06        	ld		a, 6
 185+ 8013 CD D6 7F     	call	BDOS
 186+ 8016
 187+ 8016 CD B8 7F     	call	DestroyChannel
 188+ 8019 C9           	ret
 189+ 801A
 190+ 801A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 191+ 801A              ;IN: E0 = RO, E1 = SYS, HL=filename
 192+ 801A              ChangeFileAttrib:
 193+ 801A 3A 84 7F     	ld 		a, (RWTSDrive)
 194+ 801D 3C           	inc		a					;Convert to BASIC drive number: 1,2
 195+ 801E D5           	push	de
 196+ 801F CD A2 7F     	call	CreateChannel
 197+ 8022 D1           	pop		de
 198+ 8023
 199+ 8023 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 200+ 8026 CB 27        	sla		a								;reset existing attribute flag
 201+ 8028 CB 1B        	rr		e								;put wanted flag in Carry flag
 202+ 802A CB 1F        	rr		a								;put Carry flag in register L
 203+ 802C DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 204+ 802F
 205+ 802F DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 206+ 8032 CB 27        	sla		a
 207+ 8034 CB 1B        	rr		e
 208+ 8036 CB 1F        	rr		a
 209+ 8038 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 210+ 803B
 211+ 803B              FileAttribSet:
 212+ 803B 3E 11        	ld		a, 17
 213+ 803D CD D6 7F     	call	BDOS
 214+ 8040
 215+ 8040 CD B8 7F     	call	DestroyChannel
 216+ 8043 C9           	ret
 217+ 8044
 218+ 8044              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 219+ 8044
 220+ 8044              ;HL=original name, DE = new name
 221+ 8044              ;Works only on the same drive.
 222+ 8044              RenameFile:
 223+ 8044 3A 84 7F     	ld 		a, (RWTSDrive)
 224+ 8047 3C           	inc		a					;Convert to BASIC drive number: 1,2
 225+ 8048 D5           	push	de
 226+ 8049 CD A2 7F     	call	CreateChannel
 227+ 804C D1           	pop		de
 228+ 804D
 229+ 804D DD E5        	push	ix					;IX == FCB
 230+ 804F E1           	pop		hl
 231+ 8050 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 232+ 8053 09           	add		hl, bc
 233+ 8054 EB           	ex		de, hl
 234+ 8055 3A 84 7F     	ld		a, (RWTSDrive)
 235+ 8058 12           	ld		(de), a
 236+ 8059 01 0B 00     	ld		bc, NAMELEN
 237+ 805C ED B0        	ldir
 238+ 805E
 239+ 805E 3E 0A        	ld		a, 10
 240+ 8060 CD D6 7F     	call	BDOS
 241+ 8063
 242+ 8063 CD B8 7F     	call	DestroyChannel
 243+ 8066 C9           	ret
 244+ 8067
 245+ 8067              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 246+ 8067
 247+ 8067              ;Will copy a file from A: to B: or vice versa.
 248+ 8067              ;HL=source file name
 249+ 8067              CopyFile:
 250+ 8067              	;Prepare source file
 251+ 8067 E5           	push hl
 252+ 8068 3A 84 7F     		ld 		a, (RWTSDrive)
 253+ 806B 3C           		inc		a					;Convert to BASIC drive number: 1,2
 254+ 806C CD A2 7F     		call	CreateChannel
 255+ 806F CD C6 7F     		call 	OpenFile
 256+ 8072 DD 22 20 A5  		ld		(CopyFileFCBSrc), ix
 257+ 8076 E1           	pop hl
 258+ 8077 3C           	inc  	a						;Cancel if A==$FF
 259+ 8078 28 74        	jr   	z, CopyFileEnd
 260+ 807A
 261+ 807A              	;Create destination file
 262+ 807A DD 7E 00     	ld		a, (ix)
 263+ 807D EE 03        	xor		%11						;Alternate drive, A->B, B-A
 264+ 807F F5           	push	af
 265+ 8080 E5           	push	hl
 266+ 8081 CD 0E 80     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 267+ 8084 E1           	pop		hl
 268+ 8085 F1           	pop		af
 269+ 8086 CD A2 7F     	call	CreateChannel
 270+ 8089 CD C2 7F     	call 	CreateFile
 271+ 808C DD 22 22 A5  	ld		(CopyFileFCBDst), ix
 272+ 8090 3C           	inc  	a						;Cancel if A==$FF
 273+ 8091 28 5B        	jr   	z, CopyFileEnd
 274+ 8093
 275+ 8093              FileCopyLoop:
 276+ 8093 06 55        	ld		b, MAX_SECT_RAM
 277+ 8095 DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 278+ 8099 DD 36 00 CD  	ld		(ix), CopyFileDMA % $FF
 279+ 809D DD 36 01 A5  	ld		(ix+1), CopyFileDMA / $FF
 280+ 80A1              FileCopyReadLoop:
 281+ 80A1 C5           	push	bc
 282+ 80A2 DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 283+ 80A6 CD E0 7F     		call 	BDOSSetDMA
 284+ 80A9 DD 24        		inc		ixh
 285+ 80AB DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 286+ 80AF
 287+ 80AF DD 2A 20 A5  		ld		ix, (CopyFileFCBSrc)
 288+ 80B3 CD CE 7F     		call 	ReadFileBlock
 289+ 80B6 B7           		or		a
 290+ 80B7 32 24 A5     		ld		(CopyFileResRead), a
 291+ 80BA C1           	pop		bc
 292+ 80BB 20 02        	jr		nz, FileCopyWrite
 293+ 80BD 10 E2        	djnz	FileCopyReadLoop
 294+ 80BF
 295+ 80BF              FileCopyWrite:
 296+ 80BF DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 297+ 80C3 21 28 A5     	ld		hl, CopyFileDMA
 298+ 80C6 DD 75 00     	ld		(ix), l
 299+ 80C9 DD 74 01     	ld		(ix+1), h
 300+ 80CC
 301+ 80CC              	;Calculate how many sectors were read.
 302+ 80CC 3E 55        	ld		a, MAX_SECT_RAM
 303+ 80CE 90           	sub		b
 304+ 80CF 47           	ld		b, a
 305+ 80D0
 306+ 80D0              FileCopyWriteLoop:
 307+ 80D0 C5           	push	bc
 308+ 80D1 DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 309+ 80D5 CD E0 7F     		call 	BDOSSetDMA
 310+ 80D8 DD 24        		inc		ixh
 311+ 80DA DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 312+ 80DE
 313+ 80DE DD 2A 22 A5  		ld		ix, (CopyFileFCBDst)
 314+ 80E2 CD D2 7F     		call	WriteFileBlock
 315+ 80E5 B7           		or		a
 316+ 80E6 32 25 A5     		ld		(CopyFileResWrite), a
 317+ 80E9 C1           	pop		bc
 318+ 80EA 20 02        	jr		nz, CopyFileEnd
 319+ 80EC 10 E2        	djnz	FileCopyWriteLoop
 320+ 80EE
 321+ 80EE              CopyFileEnd:
 322+ 80EE              	;Check if file ended, if not, continue copying.
 323+ 80EE 3A 24 A5     	ld		a, (CopyFileResRead)
 324+ 80F1 B7           	or		a
 325+ 80F2 28 9F        	jr		z, FileCopyLoop
 326+ 80F4
 327+ 80F4 DD 2A 22 A5  	ld		ix, (CopyFileFCBDst)
 328+ 80F8 CD CA 7F     	call 	CloseFile				;close destination file
 329+ 80FB CD B8 7F     	call 	DestroyChannel
 330+ 80FE
 331+ 80FE              	;Don't need to close source file, but must free channel
 332+ 80FE DD 2A 20 A5  	ld		ix, (CopyFileFCBSrc)
 333+ 8102 CD B8 7F     	call 	DestroyChannel
 334+ 8105
 335+ 8105 3A 25 A5     	ld		a, (CopyFileResWrite)
 336+ 8108
 337+ 8108 C9           	ret
 338+ 8109
 339+ 8109              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 340+ 8109              ;Reads part of a file
 341+ 8109              ;In: HL = name, DE = file offset in bytes
 342+ 8109              ;Out: FileData = read buffer, DE = end of file
 343+ 8109              ReadFileSection:
 344+ 8109 3A 84 7F     	ld 		a, (RWTSDrive)
 345+ 810C 3C           	inc		a					;Convert to BASIC drive number: 1,2
 346+ 810D CD A2 7F     	call	CreateChannel
 347+ 8110 CD C6 7F     	call 	OpenFile
 348+ 8113 DD 22 20 A5  	ld		(CopyFileFCBSrc), ix
 349+ 8117 3C           	inc  	a						;Cancel if A==$FF
 350+ 8118 C8           	ret		z
 351+ 8119
 352+ 8119              	;Limit max sectors to read to leave space for the index too.
 353+ 8119 06 49        	ld		b, FileDataSize/SECT_SZ
 354+ 811B              	;Set destination memory pointer.
 355+ 811B DD 21 26 A5  	ld		ix, CopyFileDMAAddr
 356+ 811F 21 20 A6     	ld		hl, FileData
 357+ 8122 DD 75 00     	ld		(ix), l
 358+ 8125 DD 74 01     	ld		(ix+1), h
 359+ 8128              ReadFileSectionLoop:
 360+ 8128 C5           	push	bc
 361+ 8129 DD 2A 26 A5  		ld		ix, (CopyFileDMAAddr)
 362+ 812D CD E0 7F     		call 	BDOSSetDMA
 363+ 8130 DD 24        		inc		ixh
 364+ 8132 DD 22 26 A5  		ld		(CopyFileDMAAddr), ix
 365+ 8136
 366+ 8136 DD 2A 20 A5  		ld		ix, (CopyFileFCBSrc)
 367+ 813A CD CE 7F     		call 	ReadFileBlock
 368+ 813D B7           		or		a
 369+ 813E 32 24 A5     		ld		(CopyFileResRead), a
 370+ 8141 C1           	pop		bc
 371+ 8142 20 02        	jr		nz, ReadFileSectionEnd
 372+ 8144 10 E2        	djnz	ReadFileSectionLoop
 373+ 8146
 374+ 8146              ReadFileSectionEnd:
 375+ 8146 DD 2A 20 A5  	ld		ix, (CopyFileFCBSrc)
 376+ 814A CD B8 7F     	call 	DestroyChannel
 377+ 814D
 378+ 814D ED 5B 26 A5  	ld		de, (CopyFileDMAAddr)
 379+ 8151 15           	dec		d
 380+ 8152 C9           	ret
 381+ 8153
 382+ 8153              	ENDIF
 383+ 8153
# file closed: bdos.asm
1107  8153              	include "ui.asm"
# file opened: ui.asm
   1+ 8153              ;UI related functions
   2+ 8153
   3+ 8153              	ifndef	_UI_
   4+ 8153              	define	_UI_
   5+ 8153
   6+ 8153              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++8153              	ifndef	_HCCFG_
   2++8153 ~            	define	_HCCFG_
   3++8153 ~
   4++8153 ~            ;HC specific code, for configuration
   5++8153 ~
   6++8153 ~            HC_CFG_PORT			EQU	$7E
   7++8153 ~
   8++8153 ~            ;BASIC/CPM ROM selection
   9++8153 ~            HC_CFG_ROM_BAS		EQU	%0
  10++8153 ~            HC_CFG_ROM_CPM		EQU	%1
  11++8153 ~
  12++8153 ~            ;Address for ROM paging: 0 or $E000
  13++8153 ~            HC_CFG_ROM_0000		EQU %00
  14++8153 ~            HC_CFG_ROM_E000		EQU %10
  15++8153 ~
  16++8153 ~            ;Cfg. port Enable/Disable
  17++8153 ~            HC_CFG_PORT_DIS		EQU %000
  18++8153 ~            HC_CFG_PORT_EN		EQU	%100
  19++8153 ~
  20++8153 ~            ;Video memory bank: $4000 or $C000
  21++8153 ~            HC_CFG_VID_4000		EQU	%0000
  22++8153 ~            HC_CFG_VID_C000		EQU	%1000
  23++8153 ~
  24++8153 ~
  25++8153 ~            ;Standar BASIC config
  26++8153 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++8153 ~            ;Standar CP/M config
  28++8153 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++8153 ~
  30++8153 ~
  31++8153 ~            HC_VID_BANK0		EQU	$4000
  32++8153 ~            HC_VID_BANK1		EQU	$C000
  33++8153 ~
  34++8153              	endif
# file closed: hccfg.asm
   7+ 8153
   8+ 8153              COL             EQU 23728
   9+ 8153              LINE            EQU 23729               ;Coordinates
  10+ 8153              LineCol			EQU	COL
  11+ 8153              CODE			EQU 23681               ;Char to print
  12+ 8153
  13+ 8153              CPM_FNT         EQU $25AB
  14+ 8153
  15+ 8153              PORT_ZX			EQU	$FE
  16+ 8153
  17+ 8153              ;COLORS
  18+ 8153              CLR_BLACK		EQU 0
  19+ 8153              CLR_BLUE		EQU 1
  20+ 8153              CLR_RED			EQU 2
  21+ 8153              CLR_MAGENTA		EQU 3
  22+ 8153              CLR_GREEN		EQU 4
  23+ 8153              CLR_CYAN		EQU	5
  24+ 8153              CLR_YELLOW		EQU	6
  25+ 8153              CLR_WHITE		EQU	7
  26+ 8153              CLR_BRIGHT		EQU	%01000000
  27+ 8153              CLR_FLASH		EQU	%10000000
  28+ 8153
  29+ 8153              ;PAPER
  30+ 8153              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 8153              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 8153              PAPER_RED		EQU (CLR_RED << 3)
  33+ 8153              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 8153              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 8153              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 8153              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 8153              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 8153
  39+ 8153              ;INK
  40+ 8153              INK_BLACK		EQU CLR_BLACK
  41+ 8153              INK_BLUE		EQU CLR_BLUE
  42+ 8153              INK_RED			EQU CLR_RED
  43+ 8153              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 8153              INK_GREEN		EQU CLR_GREEN
  45+ 8153              INK_CYAN		EQU	CLR_CYAN
  46+ 8153              INK_YELLOW		EQU	CLR_YELLOW
  47+ 8153              INK_WHITE		EQU	CLR_WHITE
  48+ 8153
  49+ 8153
  50+ 8153              ;SCR_ATTR_ADDR	EQU 22528
  51+ 8153              SCR_PIX_LEN		EQU	6144
  52+ 8153              SCR_ATTR_LEN	EQU	768
  53+ 8153              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  54+ 8153              SCR_BYTES_PER_LINE	EQU	32
  55+ 8153
  56+ 8153              SCR_COLS		EQU	64
  57+ 8153              SCR_LINES		EQU 24
  58+ 8153
  59+ 8153              ;used for file names list positioning
  60+ 8153              LST_LINES_CNT	EQU	23
  61+ 8153              LST_FIRST_LINE	EQU	0
  62+ 8153              LST_DISK_INFO	EQU 3
  63+ 8153              LST_FILE_INFO	EQU 7
  64+ 8153              LST_LINE_MSG	EQU 13
  65+ 8153              LST_FIRST_COL	EQU	16
  66+ 8153              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  67+ 8153
  68+ 8153              ;key codes
  69+ 8153              KEY_ESC			EQU	7
  70+ 8153              KEY_LEFT		EQU	8
  71+ 8153              KEY_RIGHT		EQU	9
  72+ 8153              KEY_DOWN		EQU	10
  73+ 8153              KEY_UP			EQU	11
  74+ 8153              KEY_BACKSP		EQU 12
  75+ 8153              KEY_ENTER		EQU	13
  76+ 8153              KEY_CTRL		EQU	14
  77+ 8153
  78+ 8153              SCR_DEF_CLR		EQU INK_WHITE | PAPER_BLUE
  79+ 8153              SCR_SEL_CLR		EQU INK_BLACK | PAPER_CYAN
  80+ 8153              SCR_LBL_CLR		EQU	INK_BLACK | PAPER_CYAN
  81+ 8153
  82+ 8153              ;Special formating chars
  83+ 8153              CHR_CR			EQU	13
  84+ 8153              CHR_LF			EQU	10
  85+ 8153              CHR_TAB			EQU	09
  86+ 8153              CHR_EOF			EQU $1A
  87+ 8153
  88+ 8153
  89+ 8153              ;Semi-graphical chars
  90+ 8153              ;           UC
  91+ 8153              ;     UL +H-+--+UR
  92+ 8153              ;        |  |  |
  93+ 8153              ;     ML +--+--+MR
  94+ 8153              ;        V C|  |
  95+ 8153              ;     LL +--+--+LR
  96+ 8153              ;           DC
  97+ 8153              CHR_GRID        EQU 127
  98+ 8153              CHR_V           EQU	128
  99+ 8153              CHR_MR          EQU	129
 100+ 8153              CHR_UR          EQU 130
 101+ 8153              CHR_DL          EQU 131
 102+ 8153              CHR_DC          EQU 132
 103+ 8153              CHR_UC          EQU 133
 104+ 8153              CHR_ML          EQU 134
 105+ 8153              CHR_H           EQU 135
 106+ 8153              CHR_C           EQU 136
 107+ 8153              CHR_LR          EQU 137
 108+ 8153              CHR_UL          EQU 138
 109+ 8153              CHR_FULL        EQU 139
 110+ 8153              CHR_HALF        EQU 140
 111+ 8153
 112+ 8153              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 113+ 8153
 114+ 8153              ;Return read char in A
 115+ 8153              ReadChar:
 116+ 8153 CF           	rst 08
 117+ 8154 1B           	DEFB 27
 118+ 8155 C9           	ret
 119+ 8156
 120+ 8156              ;Checks if a key is pressed
 121+ 8156              ;Cy=1 if key is pressed
 122+ 8156              KbdHit:
 123+ 8156 CF           	rst 08
 124+ 8157 20           	DEFB 32
 125+ 8158 C9           	ret
 126+ 8159              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 127+ 8159
 128+ 8159              InitFonts:
 129+ 8159              	IFUSED
 130+ 8159                  ;page-in CPM ROM to get fonts
 131+ 8159 F3               di
 132+ 815A 3E 01            ld a, HC_CFG_ROM_CPM
 133+ 815C D3 7E            out	(HC_CFG_PORT), a
 134+ 815E
 135+ 815E 21 AB 25     	ld		hl, CPM_FNT
 136+ 8161 11 B8 91     	ld		de, FontTable
 137+ 8164 01 68 03     	ld		bc, 872
 138+ 8167 ED B0        	ldir
 139+ 8169
 140+ 8169                  ;restore BASIC ROM
 141+ 8169 3E 00            ld a, HC_CFG_ROM_BAS
 142+ 816B D3 7E            out	(HC_CFG_PORT), a
 143+ 816D FB               ei
 144+ 816E
 145+ 816E C9           	ret
 146+ 816F              	ENDIF
 147+ 816F
 148+ 816F              ClrScr:
 149+ 816F 2A 12 83     	ld		hl, (CurrScrAddr)
 150+ 8172 54           	ld		d, h
 151+ 8173 5D           	ld		e, l
 152+ 8174 13           	inc		de
 153+ 8175 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 154+ 8178 36 00        	ld		(hl), 0
 155+ 817A ED B0        	ldir
 156+ 817C
 157+ 817C 23           	inc 	hl
 158+ 817D 13           	inc		de
 159+ 817E
 160+ 817E 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 161+ 8181 36 0F        	ld		(hl), SCR_DEF_CLR
 162+ 8183 ED B0        	ldir
 163+ 8185
 164+ 8185              	;also set border color
 165+ 8185 3E 01        	ld		a, SCR_DEF_CLR >> 3
 166+ 8187 D3 FE        	out		(PORT_ZX), a
 167+ 8189
 168+ 8189 3E 0F        	ld		a, SCR_DEF_CLR
 169+ 818B 32 48 5C     	ld		(23624), a
 170+ 818E C9           	ret
 171+ 818F
 172+ 818F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 173+ 818F              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 174+ 818F              PrintStr:
 175+ 818F 7E           	ld		a, (hl)
 176+ 8190 FE 20        	cp		' '
 177+ 8192 30 02        	jr		nc, GoodChar
 178+ 8194 3E 3F        	ld		a, '?'
 179+ 8196              GoodChar:
 180+ 8196 CB 7F        	bit		7, a
 181+ 8198 CB BF        	res		7, a
 182+ 819A 32 81 5C     	ld		(CODE), a
 183+ 819D ED 53 B0 5C  	ld		(LineCol), de
 184+ 81A1 08           	ex		af, af'
 185+ 81A2 D9           	exx
 186+ 81A3 E5           	push	hl
 187+ 81A4 CD 92 82     	call 	PrintChar
 188+ 81A7 E1           	pop		hl
 189+ 81A8 D9           	exx
 190+ 81A9 08           	ex		af, af'
 191+ 81AA C0           	ret		nz
 192+ 81AB
 193+ 81AB 1C           	inc		e
 194+ 81AC 23           	inc		hl
 195+ 81AD
 196+ 81AD 7B           	ld		a, e
 197+ 81AE FE 40        	cp		64
 198+ 81B0 38 DD        	jr		c, PrintStr
 199+ 81B2 1E 00        	ld		e, 0
 200+ 81B4 14           	inc		d
 201+ 81B5
 202+ 81B5 18 D8        	jr		PrintStr
 203+ 81B7
 204+ 81B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 205+ 81B7
 206+ 81B7              ;IN: HL = string, DE = coords, A = color
 207+ 81B7              PrintStrClr:
 208+ 81B7 32 E3 81     	ld		(StrClr), a
 209+ 81BA D5           	push	de
 210+ 81BB CD 8F 81     		call	PrintStr
 211+ 81BE E1           	pop		hl
 212+ 81BF              	;get string len.
 213+ 81BF 7B           	ld		a, e
 214+ 81C0 95           	sub		l
 215+ 81C1 1F           	rra
 216+ 81C2 08           	ex		af, af'
 217+ 81C3              		;line * 32
 218+ 81C3 7C           		ld		a, h
 219+ 81C4 17           		rla
 220+ 81C5 17           		rla
 221+ 81C6 11 00 00     		ld	de, 0
 222+ 81C9 17           		rla
 223+ 81CA CB 12        		rl	d
 224+ 81CC 17           		rla
 225+ 81CD CB 12        		rl	d
 226+ 81CF 17           		rla
 227+ 81D0 CB 12        		rl	d
 228+ 81D2 5F           		ld	e, a
 229+ 81D3
 230+ 81D3 26 00        		ld		h, 0
 231+ 81D5 19           		add		hl, de
 232+ 81D6 ED 5B 14 83  		ld		de, (CurrScrAttrAddr)
 233+ 81DA 19           		add		hl, de
 234+ 81DB 08           	ex		af, af'
 235+ 81DC 4F           	ld		c, a
 236+ 81DD 06 00        	ld		b, 0
 237+ 81DF 54           	ld		d, h
 238+ 81E0 5D           	ld		e, l
 239+ 81E1 13           	inc 	de
 240+ 81E2              StrClr	EQU	$ + 1
 241+ 81E2 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 242+ 81E4 ED B0        	ldir
 243+ 81E6 C9           	ret
 244+ 81E7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 81E7
 246+ 81E7              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 247+ 81E7              DrawLine:
 248+ 81E7 32 81 5C     	ld		(CODE), a
 249+ 81EA
 250+ 81EA 38 04        	jr		c, VertDir
 251+ 81EC 3E 1C        	ld		a, $1C
 252+ 81EE 18 02        	jr		StoreDir
 253+ 81F0              VertDir:
 254+ 81F0 3E 14        	ld		a, $14
 255+ 81F2              StoreDir:
 256+ 81F2 32 02 82     	ld		(LineDir), a
 257+ 81F5
 258+ 81F5              DrawLineLoop:
 259+ 81F5 ED 53 B0 5C  	ld		(LineCol), de
 260+ 81F9 D5           	push	de
 261+ 81FA D9           		exx
 262+ 81FB E5           		push	hl
 263+ 81FC CD 92 82     		call 	PrintChar
 264+ 81FF E1           		pop		hl
 265+ 8200 D9           		exx
 266+ 8201 D1           	pop		de
 267+ 8202              LineDir:
 268+ 8202 1C           	inc		e
 269+ 8203 10 F0        	djnz	DrawLineLoop
 270+ 8205
 271+ 8205 C9           	ret
 272+ 8206
 273+ 8206              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 274+ 8206
 275+ 8206              DrawHLine:
 276+ 8206 32 15 82     	ld		(ChrParam), a
 277+ 8209
 278+ 8209 06 10        	ld		b, 16
 279+ 820B 3E 87        	ld		a, CHR_H
 280+ 820D B7           	or		a
 281+ 820E CD E7 81     	call	DrawLine
 282+ 8211
 283+ 8211 06 04        	ld		b, 4
 284+ 8213              DrawUpLine:
 285+ 8213 C5           	push	bc
 286+ 8214              ChrParam	EQU		$ + 1
 287+ 8214 3E 85        		ld		a, CHR_UC
 288+ 8216 D5           		push	de
 289+ 8217 CD 48 82     			call	PrintChar2
 290+ 821A D1           		pop		de
 291+ 821B 13           		inc		de
 292+ 821C
 293+ 821C 06 0B        		ld		b, NAMELEN
 294+ 821E 3E 87        		ld		a, CHR_H
 295+ 8220 B7           		or		a
 296+ 8221 CD E7 81     		call	DrawLine
 297+ 8224 C1           	pop		bc
 298+ 8225 10 EC        	djnz	DrawUpLine
 299+ 8227
 300+ 8227 06 04        	ld		b, 4
 301+ 8229 3E 87        	ld		a, CHR_H
 302+ 822B B7           	or		a
 303+ 822C CD E7 81     	call	DrawLine
 304+ 822F C9           	ret
 305+ 8230
 306+ 8230
 307+ 8230              DrawVLines:
 308+ 8230 06 04        	ld		b, 4
 309+ 8232 11 10 00     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 310+ 8235              DrawVLinesLoop:
 311+ 8235 C5           	push 	bc
 312+ 8236 D5           	push	de
 313+ 8237 06 17        		ld		b, LST_LINES_CNT
 314+ 8239 3E 80        		ld		a, CHR_V
 315+ 823B 37           		scf
 316+ 823C CD E7 81     		call	DrawLine
 317+ 823F D1           	pop		de
 318+ 8240 C1           	pop	bc
 319+ 8241 7B           	ld		a, e
 320+ 8242 C6 0C        	add		NAMELEN+1
 321+ 8244 5F           	ld		e, a
 322+ 8245 10 EE        	djnz	DrawVLinesLoop
 323+ 8247 C9           	ret
 324+ 8248
 325+ 8248              PrintChar2:
 326+ 8248 32 81 5C     	ld		(CODE), a
 327+ 824B ED 53 B0 5C  	ld		(LineCol), de
 328+ 824F
 329+ 824F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 330+ 824F
 331+ 824F              ;IN: A = color mask
 332+ 824F              DrawCursor:
 333+ 824F ED 5B B6 88  	ld	de, (CursorAddr)
 334+ 8253 06 06        	ld	b, 	(NAMELEN + 1)/2
 335+ 8255              DrawCursorLoop:
 336+ 8255 12           	ld	(de), a
 337+ 8256 13           	inc de
 338+ 8257 10 FC        	djnz DrawCursorLoop
 339+ 8259 C9           	ret
 340+ 825A
 341+ 825A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 342+ 825A
 343+ 825A              ;IN:	A = file idx.
 344+ 825A              MoveCursor:
 345+ 825A              	;File idx / SCR_LINES => cursor line & column
 346+ 825A 6F           	ld		l, a
 347+ 825B 26 00        	ld		h, 0
 348+ 825D 0E 17        	ld		c, LST_LINES_CNT
 349+ 825F CD 7A 7C     	call	Div					;HL = file column, A = line
 350+ 8262
 351+ 8262              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 352+ 8262 C6 00        	add		LST_FIRST_LINE
 353+ 8264
 354+ 8264
 355+ 8264 54           	ld d, h
 356+ 8265 5D           	ld e, l
 357+ 8266 21 00 00     	ld	hl, 0
 358+ 8269
 359+ 8269              	;line*32
 360+ 8269 17           	rla
 361+ 826A 17           	rla
 362+ 826B 17           	rla
 363+ 826C 17           	rla
 364+ 826D CB 14        	rl h
 365+ 826F 17           	rla
 366+ 8270 CB 14        	rl h
 367+ 8272 6F           	ld l, a
 368+ 8273
 369+ 8273
 370+ 8273              	;col * 6
 371+ 8273 E5           	push	hl					;save line * 32
 372+ 8274 3E 06        		ld		a, (NAMELEN + 1)/2
 373+ 8276 CD 9A 7C     		call	Mul				;HL = column * 12/2
 374+ 8279 D1           	pop		de
 375+ 827A 19           	add		hl, de
 376+ 827B
 377+ 827B 11 08 00     	ld		de, LST_FIRST_COL/2
 378+ 827E ED 4B 14 83  	ld		bc, (CurrScrAttrAddr)
 379+ 8282 19           	add		hl, de
 380+ 8283 09           	add		hl, bc
 381+ 8284
 382+ 8284              	;clear old cursor
 383+ 8284 3E 0F        	ld		a, SCR_DEF_CLR
 384+ 8286 CD 4F 82     	call	DrawCursor
 385+ 8289
 386+ 8289              	;draw new one
 387+ 8289 22 B6 88     	ld		(CursorAddr), hl
 388+ 828C 3E 28        	ld		a, SCR_SEL_CLR
 389+ 828E CD 4F 82     	call	DrawCursor
 390+ 8291
 391+ 8291 C9           	ret
 392+ 8292
 393+ 8292              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 394+ 8292
 395+ 8292              PrintChar:
 396+ 8292 ED 5B B0 5C      ld		de, (LineCol)
 397+ 8296
 398+ 8296                  ;calculate 64 column screen address
 399+ 8296              	;IN: D = line, E = col
 400+ 8296              	;OUT: HL = screen address
 401+ 8296
 402+ 8296 CB 3B            SRL     E                                       ;col = col/2
 403+ 8298 CB 19            RR      C                                       ;mark odd/even column
 404+ 829A 7A               LD      A, D                            ;A = line
 405+ 829B E6 18            AND 24                                  ;keep only %00011000
 406+ 829D 2A 12 83         ld		hl, (CurrScrAddr)
 407+ 82A0 B4               OR      h								;add screen start address
 408+ 82A1 67               LD      H, A                            ;save H
 409+ 82A2 7A               LD      A, D                            ;A = line
 410+ 82A3 E6 07            AND 7                                   ;keep only %00000111
 411+ 82A5 0F               RRCA                                    ;%10000011
 412+ 82A6 0F               RRCA                                    ;%11000001
 413+ 82A7 0F               RRCA                                    ;%11100000
 414+ 82A8 B3               OR      E                                       ;add column
 415+ 82A9 6F               LD      L, A                            ;HL = screen address
 416+ 82AA
 417+ 82AA              PrintChar3:
 418+ 82AA                  ;get font address
 419+ 82AA E5               PUSH HL
 420+ 82AB AF                   XOR A
 421+ 82AC 67                   LD  H, A
 422+ 82AD 3A 81 5C             LD  A, (CODE)
 423+ 82B0 D6 20                SUB ' '
 424+ 82B2 6F                   LD  L, A
 425+ 82B3 29                   ADD     HL, HL                  ;char code = char code * 8
 426+ 82B4 29                   ADD     HL, HL                  ;i.e. offset into font table
 427+ 82B5 29                   ADD     HL, HL
 428+ 82B6 11 B8 91             LD      DE, FontTable             ;get font table
 429+ 82B9 19                   ADD     HL, DE
 430+ 82BA EB                   EX      DE, HL                  ;DE = our char font address
 431+ 82BB E1               POP     HL
 432+ 82BC
 433+ 82BC
 434+ 82BC                  ;print a char
 435+ 82BC 06 08            LD      B, 8                            ;char height is 8 lines
 436+ 82BE              PrintCharLine:
 437+ 82BE 1A                   LD      A, (DE)                         ;load char line in A
 438+ 82BF
 439+ 82BF CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 440+ 82C1 20 06                JR  	NZ, NoTurn
 441+ 82C3
 442+ 82C3 07                   RLCA
 443+ 82C4 07                   RLCA
 444+ 82C5 07                   RLCA
 445+ 82C6 07                   RLCA
 446+ 82C7 18 01                JR      Store
 447+ 82C9              NoTurn:
 448+ 82C9 B6                   OR (HL)
 449+ 82CA              Store:
 450+ 82CA 77                   LD (HL), A
 451+ 82CB
 452+ 82CB 13                   INC     DE                                      ;next char line in font table
 453+ 82CC 24                   INC     H                                       ;next char line on screen
 454+ 82CD 10 EF            DJNZ PrintCharLine                  ;last line of char?
 455+ 82CF
 456+ 82CF C9               ret
 457+ 82D0
 458+ 82D0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 459+ 82D0
 460+ 82D0              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 461+ 82D0              ReadString:
 462+ 82D0 21 20 A5     	ld		hl, DataBuf
 463+ 82D3 D5           	push	de
 464+ 82D4 DD E1        	pop		ix
 465+ 82D6
 466+ 82D6              ReadStringLoop:
 467+ 82D6 D5           	push	de
 468+ 82D7 E5           	push	hl
 469+ 82D8 CD 53 81     		call ReadChar
 470+ 82DB E1           	pop		hl
 471+ 82DC D1           	pop		de
 472+ 82DD
 473+ 82DD FE 0D        	cp	KEY_ENTER
 474+ 82DF C8           	ret z
 475+ 82E0
 476+ 82E0 FE 0C        	cp  KEY_BACKSP
 477+ 82E2 20 0F        	jr	nz, ReadStrChar
 478+ 82E4
 479+ 82E4 E5           	push hl
 480+ 82E5 01 21 A5     	ld   bc, DataBuf+1
 481+ 82E8 ED 42        	sbc	 hl, bc
 482+ 82EA E1           	pop  hl
 483+ 82EB 38 16        	jr   c, ReadStrPrint
 484+ 82ED
 485+ 82ED 1B           	dec	de
 486+ 82EE 2B           	dec	hl
 487+ 82EF 36 20        	ld	(hl), ' '
 488+ 82F1 18 10        	jr	ReadStrPrint
 489+ 82F3
 490+ 82F3              ReadStrChar:
 491+ 82F3 FE 20        	cp	' '
 492+ 82F5 38 DF        	jr	c, ReadStringLoop
 493+ 82F7 FE 7F        	cp  127
 494+ 82F9 30 DB        	jr	nc, ReadStringLoop
 495+ 82FB
 496+ 82FB              	;Check end of string and go back if found.
 497+ 82FB 46           	ld	b, (hl)
 498+ 82FC CB 78        	bit 7, b
 499+ 82FE 20 03        	jr	nz, ReadStrPrint
 500+ 8300
 501+ 8300 77           	ld	(hl), a
 502+ 8301 23           	inc	hl
 503+ 8302 13           	inc	de
 504+ 8303
 505+ 8303              ReadStrPrint:
 506+ 8303 E5           	push	hl
 507+ 8304 D5           	push	de
 508+ 8305 21 20 A5     	ld		hl, DataBuf
 509+ 8308 DD E5        	push	ix
 510+ 830A D1           	pop		de
 511+ 830B CD 8F 81     	call	PrintStr
 512+ 830E D1           	pop		de
 513+ 830F E1           	pop		hl
 514+ 8310
 515+ 8310 18 C4        	jr		ReadStringLoop
 516+ 8312
 517+ 8312 00 40        CurrScrAddr		DEFW	16384
 518+ 8314 00 58        CurrScrAttrAddr	DEFW	22528
 519+ 8316
 520+ 8316                 	endif
# file closed: ui.asm
1108  8316              	include "math.asm"
# file opened: math.asm
   1+ 8316              	ifndef	_MATH_
   2+ 8316 ~            	define	_MATH_
   3+ 8316 ~
   4+ 8316 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 8316 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 8316 ~
   7+ 8316 ~            Word2Txt:
   8+ 8316 ~            	IFUSED
   9+ 8316 ~            	push	de
  10+ 8316 ~            		call	Word2Txt_
  11+ 8316 ~            	pop		de
  12+ 8316 ~
  13+ 8316 ~            	ld		b, 4
  14+ 8316 ~            	call	StrippLeading0
  15+ 8316 ~            	ret
  16+ 8316 ~            	ENDIF
  17+ 8316 ~
  18+ 8316 ~            Byte2Txt:
  19+ 8316 ~            	IFUSED
  20+ 8316 ~            	push	de
  21+ 8316 ~            		call	Byte2Txt_
  22+ 8316 ~            	pop		de
  23+ 8316 ~
  24+ 8316 ~            	ld		b, 2
  25+ 8316 ~            	call	StrippLeading0
  26+ 8316 ~            	ret
  27+ 8316 ~            	ENDIF
  28+ 8316 ~
  29+ 8316 ~
  30+ 8316 ~            StrippLeading0:
  31+ 8316 ~            	ld		a, (de)
  32+ 8316 ~            	cp		'1'
  33+ 8316 ~            	ret		nc
  34+ 8316 ~
  35+ 8316 ~            	ld		a, ' '
  36+ 8316 ~            	ld		(de), a
  37+ 8316 ~            	inc		de
  38+ 8316 ~            	djnz	StrippLeading0
  39+ 8316 ~            	ret
  40+ 8316 ~
  41+ 8316 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 8316 ~            Word2Txt_:
  43+ 8316 ~            	ld bc, -10000
  44+ 8316 ~            	call DigitLoop
  45+ 8316 ~            	ld bc, -1000
  46+ 8316 ~            	call DigitLoop
  47+ 8316 ~            Byte2Txt_:
  48+ 8316 ~            	ld bc, -100
  49+ 8316 ~            	call DigitLoop
  50+ 8316 ~            	ld bc, -10
  51+ 8316 ~            	call DigitLoop
  52+ 8316 ~            	ld bc, -1
  53+ 8316 ~
  54+ 8316 ~            DigitLoop:
  55+ 8316 ~            	ld	a, '0' - 1
  56+ 8316 ~            DivNrLoop:
  57+ 8316 ~            	inc	a			;increase reminder
  58+ 8316 ~            	add	hl, bc		;substract divizor
  59+ 8316 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 8316 ~            	sbc	hl, bc		;nope, restore
  61+ 8316 ~
  62+ 8316 ~            	ld (de), a
  63+ 8316 ~            	inc de
  64+ 8316 ~            	ret
  65+ 8316 ~
  66+ 8316 ~
  67+ 8316 ~            ;Input: HL = Dividend, C = Divisor
  68+ 8316 ~            ;Output: HL = Quotient, A = Remainder
  69+ 8316 ~            ;Warning: doesn't work with divisor >= $80
  70+ 8316 ~            Div:
  71+ 8316 ~            	IFUSED
  72+ 8316 ~            	xor a
  73+ 8316 ~            	ld b, 16
  74+ 8316 ~
  75+ 8316 ~            DivLoop:
  76+ 8316 ~            	add	hl,hl
  77+ 8316 ~            	rla
  78+ 8316 ~            	cp	c
  79+ 8316 ~            	jr	c, NoSub
  80+ 8316 ~            	sub	c
  81+ 8316 ~            	inc	l
  82+ 8316 ~            NoSub:
  83+ 8316 ~            	djnz DivLoop
  84+ 8316 ~
  85+ 8316 ~            	ret
  86+ 8316 ~            	ENDIF
  87+ 8316 ~
  88+ 8316 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 8316 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 8316 ~            Div2:
  91+ 8316 ~            	ld hl, 0
  92+ 8316 ~            	ld b, 16
  93+ 8316 ~            Div2Loop:
  94+ 8316 ~            	sll c		; unroll 16 times
  95+ 8316 ~            	rla			; ...
  96+ 8316 ~            	adc	hl,hl		; ...
  97+ 8316 ~            	sbc	hl,de		; ...
  98+ 8316 ~            	jr	nc,$+4		; ...
  99+ 8316 ~            	add	hl,de		; ...
 100+ 8316 ~            	dec	c		; ...
 101+ 8316 ~            	djnz Div2Loop
 102+ 8316 ~            	ret
 103+ 8316 ~
 104+ 8316 ~
 105+ 8316 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 8316 ~            ;Output: A:HL = Product
 107+ 8316 ~            Mul:
 108+ 8316 ~            	IFUSED
 109+ 8316 ~            	ld hl, 0
 110+ 8316 ~            	ld bc, $0700
 111+ 8316 ~
 112+ 8316 ~            	add	a, a		; optimised 1st iteration
 113+ 8316 ~            	jr	nc, MulLoop
 114+ 8316 ~            	ld	h, d
 115+ 8316 ~            	ld	l, e
 116+ 8316 ~
 117+ 8316 ~            MulLoop:
 118+ 8316 ~            	add	hl,hl
 119+ 8316 ~            	rla
 120+ 8316 ~            	jr	nc, NoAdd
 121+ 8316 ~            	add	hl,de
 122+ 8316 ~            	adc	a,c
 123+ 8316 ~            NoAdd:
 124+ 8316 ~            	djnz MulLoop
 125+ 8316 ~
 126+ 8316 ~            	ret
 127+ 8316 ~            	ENDIF
 128+ 8316 ~
 129+ 8316              	endif
# file closed: math.asm
1109  8316              	include "txtview.asm"
# file opened: txtview.asm
   1+ 8316              ; 	DEVICE ZXSPECTRUM48
   2+ 8316
   3+ 8316              LINE_CNT	EQU	23
   4+ 8316              COL_CNT		EQU	64
   5+ 8316
   6+ 8316              CHAR_CR		EQU	$0D
   7+ 8316              CHAR_LF		EQU	$0A
   8+ 8316              CHAR_TAB	EQU	$09
   9+ 8316              EOF_MARKER		EQU	$1A
  10+ 8316
  11+ 8316              COORDS		EQU	23728		;Coordinates
  12+ 8316
  13+ 8316
  14+ 8316              InitViewer:
  15+ 8316 22 62 86     	ld		 (FileBegin), hl
  16+ 8319 09           	add		hl, bc
  17+ 831A              	;must filter any EOF chars, max 256 of them.
  18+ 831A 25           	dec		h
  19+ 831B 3E 1A        	ld		a, EOF_MARKER
  20+ 831D ED B1        	cpir
  21+ 831F 2B           	dec		hl
  22+ 8320 22 66 86     	ld		(FileEnd), hl
  23+ 8323 ED 5B 62 86  	ld		de, (FileBegin)
  24+ 8327 B7           	or		a
  25+ 8328 ED 52        	sbc		hl, de
  26+ 832A 22 64 86     	ld		(FileLen), hl
  27+ 832D
  28+ 832D 3E 0D        	ld		a, CHAR_CR
  29+ 832F 77           	ld		(hl), a
  30+ 8330
  31+ 8330
  32+ 8330 21 04 02     	ld		hl, (2 << 8) | 4
  33+ 8333 22 09 5C     	ld		(23561), hl
  34+ 8336
  35+ 8336 21 00 00     	ld		hl, 0
  36+ 8339 22 B0 5C     	ld		(COORDS), hl
  37+ 833C
  38+ 833C 21 00 58     	ld		hl, 16384 + 6144
  39+ 833F 54           	ld		d, h
  40+ 8340 5D           	ld		e, l
  41+ 8341 13           	inc		de
  42+ 8342 01 FF 02     	ld		bc, 767
  43+ 8345 36 0F        	ld		(hl), (1 << 3) | 7
  44+ 8347 ED B0        	ldir
  45+ 8349
  46+ 8349 CD 68 85     	call	ScrollInit
  47+ 834C
  48+ 834C 11 00 00     	ld		de, 0
  49+ 834F ED 53 5D 86  	ld		(CurLine), de
  50+ 8353
  51+ 8353              	;prepare file progress %
  52+ 8353 2A 64 86     	ld		hl, (FileLen)
  53+ 8356 7C           	ld		a, h
  54+ 8357 4D           	ld		c, l
  55+ 8358 11 64 00     	ld		de, 100
  56+ 835B CD 87 7C     	call	Div2
  57+ 835E 67           	ld		h, a
  58+ 835F 69           	ld		l, c
  59+ 8360 22 68 86     	ld		(PROGR_PERC), hl
  60+ 8363
  61+ 8363 CD F7 84     	call	PrintMsg
  62+ 8366
  63+ 8366 DD 21 1E EF  	ld		ix, FileIdx	- 2
  64+ 836A 06 17        	ld		b, LINE_CNT
  65+ 836C 2A 62 86     	ld		hl, (FileBegin)
  66+ 836F
  67+ 836F C9           	ret
  68+ 8370
  69+ 8370              PrintLoop:
  70+ 8370 C5           	push	bc
  71+ 8371 DD 23        		inc		ix
  72+ 8373 DD 23        		inc		ix
  73+ 8375 DD 75 00     		ld		(ix), l
  74+ 8378 DD 74 01     		ld		(ix + 1), h
  75+ 837B
  76+ 837B CD 92 84     		call	GetLine
  77+ 837E CD 64 84     		call	PrintLine
  78+ 8381
  79+ 8381 ED 5B 5D 86  		ld		de, (CurLine)
  80+ 8385 13           		inc		de
  81+ 8386 ED 53 5D 86  		ld		(CurLine), de
  82+ 838A C1           	pop		bc
  83+ 838B CD 59 84     	call	CheckEnd
  84+ 838E 28 13        	jr		z, EOF
  85+ 8390
  86+ 8390 10 DE        	djnz	PrintLoop
  87+ 8392 18 17        	jr		PrintLoop2
  88+ 8394
  89+ 8394              GetKey:
  90+ 8394 76           	halt
  91+ 8395 FD CB 01 6E  	bit		5, (iy + 1);
  92+ 8399 28 F9        	jr		z, GetKey
  93+ 839B FD CB 01 AE  	res		5, (iy + 1)
  94+ 839F FD 7E CE     	ld		a, (iy - $32)
  95+ 83A2 C9           	ret
  96+ 83A3
  97+ 83A3              EOF:
  98+ 83A3 CD 94 83     	call	GetKey
  99+ 83A6 FE 30        	cp		'0'
 100+ 83A8 20 F9        	jr		nz, EOF
 101+ 83AA C9           	ret
 102+ 83AB
 103+ 83AB              PrintLoop2:
 104+ 83AB CD F7 84     	call	PrintMsg
 105+ 83AE
 106+ 83AE CD 94 83     	call	GetKey
 107+ 83B1 FE 30        	cp		'0'					;Exit on 0
 108+ 83B3 C8           	ret		z
 109+ 83B4
 110+ 83B4 FE 0A        	cp		KEY_DOWN
 111+ 83B6 28 5C        	jr		z, Down
 112+ 83B8
 113+ 83B8 FE 0B        	cp		KEY_UP
 114+ 83BA 28 2D        	jr		z, Up
 115+ 83BC
 116+ 83BC FE 32        	cp		'2'
 117+ 83BE 20 EB        	jr		nz, PrintLoop2
 118+ 83C0
 119+ 83C0 3A 61 86     	ld		a, (WrapFlag)
 120+ 83C3 EE 01        	xor		1
 121+ 83C5 32 61 86     	ld		(WrapFlag), a
 122+ 83C8 B7           	or		a
 123+ 83C9 28 0F        	jr		z, NoWrap
 124+ 83CB
 125+ 83CB 11 4F 6E     	ld		de, 'nO'
 126+ 83CE ED 53 13 86  	ld		(MsgLineWrF), de
 127+ 83D2 3E 20        	ld		a, ' '
 128+ 83D4 32 15 86     	ld		(MsgLineWrF + 2), a
 129+ 83D7 C3 AB 83     	jp		PrintLoop2
 130+ 83DA
 131+ 83DA              NoWrap:
 132+ 83DA 11 4F 66     	ld		de, 'fO'
 133+ 83DD ED 53 13 86  	ld		(MsgLineWrF), de
 134+ 83E1 3E 66        	ld		a, 'f'
 135+ 83E3 32 15 86     	ld		(MsgLineWrF + 2), a
 136+ 83E6
 137+ 83E6 C3 AB 83     	jp		PrintLoop2
 138+ 83E9
 139+ 83E9
 140+ 83E9              Up:
 141+ 83E9 CD 49 84     	call	CheckBegin
 142+ 83EC 28 BD        	jr		z, PrintLoop2
 143+ 83EE
 144+ 83EE CD 96 85     	call	ScrollUp
 145+ 83F1
 146+ 83F1 DD 2B        	dec		ix
 147+ 83F3 DD 2B        	dec		ix
 148+ 83F5 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 149+ 83F8 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 150+ 83FB CD 92 84     	call	GetLine						;extract previous line to display
 151+ 83FE
 152+ 83FE 11 00 00     	ld		de, 0
 153+ 8401 ED 53 B0 5C  	ld		(COORDS), de
 154+ 8405 CD 64 84     	call	PrintLine
 155+ 8408
 156+ 8408 2A 5D 86     	ld		hl, (CurLine)
 157+ 840B 2B           	dec		hl
 158+ 840C 22 5D 86     	ld		(CurLine), hl
 159+ 840F CD F7 84     	call	PrintMsg
 160+ 8412 18 97        	jr		PrintLoop2
 161+ 8414
 162+ 8414
 163+ 8414              Down:
 164+ 8414 DD 6E 00     	ld		l, (ix)
 165+ 8417 DD 66 01     	ld		h, (ix + 1)
 166+ 841A CD 92 84     	call	GetLine						;get next line pointer
 167+ 841D
 168+ 841D CD 59 84     	call	CheckEnd					;check if HL == file end
 169+ 8420 38 89        	jr		c, PrintLoop2
 170+ 8422
 171+ 8422 DD 23        	inc		ix								;save next line pointer
 172+ 8424 DD 23        	inc		ix
 173+ 8426 DD 75 00     	ld		(ix), l
 174+ 8429 DD 74 01     	ld		(ix + 1), h
 175+ 842C
 176+ 842C CD 92 84     	call	GetLine						;extract next line in buffer for display
 177+ 842F
 178+ 842F CD 9B 85     	call	ScrollDown
 179+ 8432
 180+ 8432 11 00 16     	ld		de, (LINE_CNT-1) << 8
 181+ 8435 ED 53 B0 5C  	ld		(COORDS), de
 182+ 8439 CD 64 84     	call	PrintLine
 183+ 843C
 184+ 843C 2A 5D 86     	ld		hl, (CurLine)
 185+ 843F 23           	inc		hl
 186+ 8440 22 5D 86     	ld		(CurLine), hl
 187+ 8443 CD F7 84     	call	PrintMsg
 188+ 8446
 189+ 8446 C3 AB 83     	jp		PrintLoop2
 190+ 8449
 191+ 8449
 192+ 8449              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 8449              ;check begining of buffer
 194+ 8449              CheckBegin:
 195+ 8449 E5           	push	hl
 196+ 844A DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 197+ 844D DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 198+ 8450 ED 5B 62 86  		ld		de, (FileBegin)
 199+ 8454 B7           		or		a
 200+ 8455 ED 52        		sbc		hl, de
 201+ 8457 E1           	pop		hl
 202+ 8458 C9           	ret
 203+ 8459
 204+ 8459              ;check end of buffer
 205+ 8459              CheckEnd:
 206+ 8459 E5           	push	hl
 207+ 845A ED 5B 66 86  		ld		de, (FileEnd)
 208+ 845E EB           		ex		de, hl
 209+ 845F B7           		or		a
 210+ 8460 ED 52        		sbc		hl, de
 211+ 8462 E1           	pop		hl
 212+ 8463 C9           	ret
 213+ 8464
 214+ 8464              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 215+ 8464              ;Print a line
 216+ 8464              PrintLine:
 217+ 8464 11 1D 86     	ld		de, LineBuf
 218+ 8467 06 40        	ld		b, COL_CNT
 219+ 8469
 220+ 8469 CD 78 84     	call	PrintStrTxt
 221+ 846C
 222+ 846C              	;go to the next screen line
 223+ 846C ED 5B B0 5C  	ld		de, (COORDS)
 224+ 8470 14           	inc		d
 225+ 8471 1E 00        	ld		e, 0
 226+ 8473 ED 53 B0 5C  	ld		(COORDS), de
 227+ 8477 C9           	ret
 228+ 8478
 229+ 8478              PrintStrTxt:
 230+ 8478 1A           	ld		a, (de)
 231+ 8479 13           	inc		de
 232+ 847A D5           	push	de
 233+ 847B 32 81 5C     		ld		(CODE), a
 234+ 847E C5           		push	bc
 235+ 847F E5           			push	hl
 236+ 8480 CD 92 82     				call	PrintChar
 237+ 8483 E1           			pop		hl
 238+ 8484 C1           		pop		bc
 239+ 8485
 240+ 8485 ED 5B B0 5C  		ld		de, (COORDS)
 241+ 8489 1C           		inc		e
 242+ 848A ED 53 B0 5C  		ld		(COORDS), de
 243+ 848E D1           	pop		de
 244+ 848F 10 E7        	djnz	PrintStrTxt
 245+ 8491 C9           	ret
 246+ 8492
 247+ 8492              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 248+ 8492              ;Extract a line of text to fit exactly on a 64 screen line
 249+ 8492              ;IN:	HL = current file pointer
 250+ 8492              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 251+ 8492              GetLine:
 252+ 8492 11 1D 86     	ld		de, LineBuf
 253+ 8495 06 40        	ld		b, COL_CNT
 254+ 8497              GetLineLoop:
 255+ 8497 7E           	ld		a, (hl)
 256+ 8498 23           	inc		hl
 257+ 8499
 258+ 8499 FE 0D        	cp		CHAR_CR
 259+ 849B 28 29        	jr		z, GetLineSkip0A
 260+ 849D
 261+ 849D FE 0A        	cp		CHAR_LF
 262+ 849F 28 25        	jr		z, GetLineSkip0A
 263+ 84A1
 264+ 84A1 FE 09        	cp		CHAR_TAB
 265+ 84A3 20 07        	jr		nz, GetLineNext
 266+ 84A5
 267+ 84A5 3E 20        	ld		a, ' '
 268+ 84A7 12           	ld		(de), a
 269+ 84A8 13           	inc		de
 270+ 84A9 05           	dec		b
 271+ 84AA 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 272+ 84AC
 273+ 84AC              GetLineNext:
 274+ 84AC FE 20        	cp		' '
 275+ 84AE 38 06        	jr		c, NotValid
 276+ 84B0
 277+ 84B0 FE 80        	cp		128
 278+ 84B2 30 02        	jr		nc, NotValid
 279+ 84B4 18 03        	jr		Valid
 280+ 84B6
 281+ 84B6              NotValid:
 282+ 84B6 CD 46 85     	call	ReplaceChars
 283+ 84B9
 284+ 84B9              Valid:
 285+ 84B9 12           	ld		(de), a
 286+ 84BA 13           	inc		de
 287+ 84BB 10 DA        	djnz	GetLineLoop
 288+ 84BD
 289+ 84BD              ;if line is exactly 64 char long, must skip the new line char(s)
 290+ 84BD              GetLineSkip0D:
 291+ 84BD 0E 00        	ld		c, 0
 292+ 84BF 3E 0D        	ld		a, CHAR_CR						;skip 0D
 293+ 84C1 BE           	cp		(hl)
 294+ 84C2 20 02        	jr		nz, GetLineSkip0A
 295+ 84C4 23           	inc		hl
 296+ 84C5 0C           	inc		c
 297+ 84C6
 298+ 84C6              GetLineSkip0A:						;skip 0A
 299+ 84C6 3E 0A        	ld		a, CHAR_LF
 300+ 84C8 BE           	cp		(hl)
 301+ 84C9 20 02        	jr		nz, GetLineFill
 302+ 84CB 23           	inc		hl
 303+ 84CC 0C           	inc		c
 304+ 84CD
 305+ 84CD              GetLineFill:
 306+ 84CD 78           	ld		a, b
 307+ 84CE B7           	or		a
 308+ 84CF 20 1F        	jr		nz, GetLineFillLoop
 309+ 84D1
 310+ 84D1 79           	ld		a, c
 311+ 84D2 B7           	or		a
 312+ 84D3 C0           	ret		nz
 313+ 84D4
 314+ 84D4              	;wrap or not
 315+ 84D4 3A 61 86     	ld		a, (WrapFlag)
 316+ 84D7 B7           	or		a
 317+ 84D8 C0           	ret		nz
 318+ 84D9
 319+ 84D9 ED 5B 66 86  	ld		de, (FileEnd)
 320+ 84DD E5           	push	hl
 321+ 84DE EB           	ex		de, hl
 322+ 84DF B7           	or		a
 323+ 84E0 ED 52        	sbc		hl, de
 324+ 84E2 44           	ld		b, h
 325+ 84E3 4D           	ld		c, l
 326+ 84E4 3E 0D        	ld		a, CHAR_CR
 327+ 84E6 E1           	pop		hl
 328+ 84E7 ED B1        	cpir
 329+ 84E9 C0           	ret		nz
 330+ 84EA 3E 0A        	ld		a, CHAR_LF
 331+ 84EC BE           	cp		(hl)
 332+ 84ED C0           	ret		nz
 333+ 84EE 23           	inc		hl
 334+ 84EF
 335+ 84EF C9           	ret
 336+ 84F0
 337+ 84F0              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 338+ 84F0 3E 20        	ld		a, ' '
 339+ 84F2 12           	ld		(de), a
 340+ 84F3 13           	inc		de
 341+ 84F4 10 FA        	djnz	GetLineFillLoop
 342+ 84F6 C9           	ret
 343+ 84F7
 344+ 84F7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 345+ 84F7              PrintMsg:
 346+ 84F7 ED 5B B0 5C  	ld		de, (COORDS)
 347+ 84FB D5           	push	de
 348+ 84FC 11 00 17     	ld		de, LINE_CNT<<8
 349+ 84FF ED 53 B0 5C  	ld		(COORDS), de
 350+ 8503
 351+ 8503              	;Get current file pointer
 352+ 8503 DD 6E 00     	ld		l, (ix)
 353+ 8506 DD 66 01     	ld		h, (ix + 1)
 354+ 8509 ED 4B 62 86  	ld		bc, (FileBegin)
 355+ 850D B7           	or		a
 356+ 850E ED 42        	sbc		hl, bc
 357+ 8510
 358+ 8510              	;Divide by one percent length
 359+ 8510 7C           	ld		a, h
 360+ 8511 4D           	ld		c, l
 361+ 8512 ED 5B 68 86  	ld		de, (PROGR_PERC)
 362+ 8516 CD 87 7C     	call	Div2
 363+ 8519
 364+ 8519              	;Display %
 365+ 8519 11 F9 85     	ld		de, MsgLinePr
 366+ 851C 67           	ld		h, a
 367+ 851D 69           	ld		l, c
 368+ 851E CD 3E 7C     	call	Byte2Txt
 369+ 8521
 370+ 8521
 371+ 8521 2A 5D 86     	ld		hl, (CurLine)
 372+ 8524 11 05 86     	ld		de, MsgLineNo
 373+ 8527 CD 33 7C     	call	Word2Txt
 374+ 852A
 375+ 852A 11 F0 85     	ld		de, MsgLine
 376+ 852D 06 2D        	ld		b, MsgLineLen
 377+ 852F CD 78 84     	call	PrintStrTxt
 378+ 8532 D1           	pop		de
 379+ 8533 ED 53 B0 5C  	ld		(COORDS), DE
 380+ 8537
 381+ 8537 21 E0 5A     	ld		hl, 16384 + 6144 + LINE_CNT*32
 382+ 853A 54           	ld		d, h
 383+ 853B 5D           	ld		e, l
 384+ 853C 13           	inc		de
 385+ 853D 3E 28        	ld		a, (5 << 3) | 0
 386+ 853F 77           	ld		(hl), a
 387+ 8540 01 1F 00     	ld		bc, 31
 388+ 8543 ED B0        	ldir
 389+ 8545 C9           	ret
 390+ 8546
 391+ 8546
 392+ 8546              ReplaceChars:
 393+ 8546 E5           	push	hl
 394+ 8547 C5           	push	bc
 395+ 8548 21 D6 85     		ld		hl, CharReplaceTbl
 396+ 854B 06 0D        		ld		b, CharReplTblLen
 397+ 854D              ReplaceSGCLoop:
 398+ 854D BE           		cp		(hl)
 399+ 854E 28 09        		jr		z, ReplaceMatch
 400+ 8550 23           		inc		hl
 401+ 8551 23           		inc		hl
 402+ 8552 10 F9        		djnz	ReplaceSGCLoop
 403+ 8554
 404+ 8554 3E 3F        		ld		a, '?'
 405+ 8556 C1           		pop		bc
 406+ 8557 E1           		pop		hl
 407+ 8558 C9           	ret
 408+ 8559
 409+ 8559              ReplaceMatch:
 410+ 8559 23           		inc		hl
 411+ 855A 7E           		ld		a, (hl)
 412+ 855B C1           	pop		bc
 413+ 855C E1           	pop		hl
 414+ 855D C9           	ret
 415+ 855E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 416+ 855E
 417+ 855E              	include	"scroll.asm"
# file opened: scroll.asm
   1++855E              ;Scrolling routines for UP/DOWN
   2++855E              ;They use 2 tables of pointers of screen cell rows.
   3++855E              ;One table has addresses in increasing order, for scroll down,
   4++855E              ;the other in decreasing order, for scroll up, so the same
   5++855E              ;scroll routine is used in both cases.
   6++855E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++855E
   8++855E              ; Char Down
   9++855E              ; Adjusts screen address HL to move eight pixels down on the display.
  10++855E              ; enter: HL = valid screen address
  11++855E              ; exit : HL = moves one character down
  12++855E              ; used : AF, HL
  13++855E              GetCellDown:
  14++855E 7D           	ld a,l
  15++855F C6 20        	add a,$20
  16++8561 6F           	ld l,a
  17++8562 D0           	ret nc
  18++8563 7C           	ld a,h
  19++8564 C6 08        	add a,$08
  20++8566 67           	ld h,a
  21++8567 C9           	ret
  22++8568
  23++8568              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++8568              ;Fills the two tables with pointers.
  25++8568              ScrollInit:
  26++8568 21 00 40     	ld		hl, 16384
  27++856B 06 17        	ld		b, LINE_CNT
  28++856D              FillScrLinesLoop:
  29++856D              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++856D 22 00 5B     	ld		(SCRLinesDown), hl
  31++8570              	;inc. pointer in destination table (of pointers to lines)
  32++8570 ED 5B 6E 85  	ld		de, (FillScrLinesPtr)
  33++8574 13           	inc		de
  34++8575 13           	inc		de
  35++8576 ED 53 6E 85  	ld		(FillScrLinesPtr), de
  36++857A CD 5E 85     	call	GetCellDown
  37++857D 10 EE        	djnz	FillScrLinesLoop
  38++857F
  39++857F              	;now fill the table in reverse
  40++857F ED 73 93 85  	ld		(FillScrLinesSPStore), sp
  41++8583 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++8586 06 17        	ld		b, LINE_CNT
  43++8588 21 00 5B     	ld		hl, SCRLinesDown
  44++858B              FillScrLinesRev:
  45++858B 5E           	ld		e, (hl)
  46++858C 23           	inc		hl
  47++858D 56           	ld		d, (hl)
  48++858E 23           	inc		hl
  49++858F D5           	push	de
  50++8590 10 F9        	djnz	FillScrLinesRev
  51++8592              FillScrLinesSPStore	EQU	$ + 1
  52++8592 31 00 00     	ld		sp, 0
  53++8595 C9           	ret
  54++8596
  55++8596              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++8596              ScrollUp:
  57++8596 21 2E 5B     	ld		hl, SCRLinesUp
  58++8599 18 03        	jr		Scroll
  59++859B
  60++859B              ScrollDown:
  61++859B 21 00 5B     	ld		hl, SCRLinesDown
  62++859E
  63++859E              Scroll:
  64++859E 22 AC 85     	ld		(ScrollDownPtrDest), hl
  65++85A1 23           	inc		hl
  66++85A2 23           	inc		hl
  67++85A3 22 AF 85     	ld		(ScrollDownPtrSrc), hl
  68++85A6 0E 16        	ld		c, LINE_CNT - 1
  69++85A8
  70++85A8              ScrollDownLoop2:
  71++85A8 06 04        	ld		b, 4
  72++85AA              ScrollDownPtrDest	EQU	$ + 2
  73++85AA ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++85AE              ScrollDownPtrSrc	EQU	$ + 1
  75++85AE 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++85B1
  77++85B1              ScrollDownLoop:					;copy a single char line
  78++85B1 C5           	push	bc
  79++85B2 01 20 00     	ld		bc, 32
  80++85B5 ED B0        	ldir
  81++85B7 2B           	dec		hl
  82++85B8 1B           	dec		de
  83++85B9 24           	inc		h
  84++85BA 14           	inc		d
  85++85BB 01 20 00     	ld		bc, 32
  86++85BE ED B8        	lddr
  87++85C0 23           	inc		hl
  88++85C1 13           	inc		de
  89++85C2 24           	inc		h
  90++85C3 14           	inc		d
  91++85C4 C1           	pop		bc
  92++85C5 10 EA        	djnz	ScrollDownLoop
  93++85C7
  94++85C7 0D           	dec		c
  95++85C8 C8           	ret		z
  96++85C9
  97++85C9 2A AF 85     	ld		hl, (ScrollDownPtrSrc)
  98++85CC 22 AC 85     	ld		(ScrollDownPtrDest), hl
  99++85CF 23           	inc		hl
 100++85D0 23           	inc		hl
 101++85D1 22 AF 85     	ld		(ScrollDownPtrSrc), hl
 102++85D4 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 418+ 85D6
 419+ 85D6              CharReplaceTbl:
 420+ 85D6 B3 80        	defb	179, 128
 421+ 85D8 B4 81        	defb	180, 129
 422+ 85DA BF 82        	defb	191, 130
 423+ 85DC C0 83        	defb	192, 131
 424+ 85DE C1 84        	defb	193, 132
 425+ 85E0 C2 85        	defb	194, 133
 426+ 85E2 C3 86        	defb	195, 134
 427+ 85E4 C4 87        	defb	196, 135
 428+ 85E6 C5 88        	defb	197, 136
 429+ 85E8 D9 89        	defb	217, 137
 430+ 85EA DA 8A        	defb	218, 138
 431+ 85EC DB 8B        	defb	219, 139
 432+ 85EE DC 8C        	defb	220, 140
 433+ 85F0              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 434+ 85F0
 435+ 85F0 50 72 6F 67  MsgLine		defb	'Progress:'
 435+ 85F4 72 65 73 73
 435+ 85F8 3A
 436+ 85F9 20 20 20 25  MsgLinePr	defb	'   %; '
 436+ 85FD 3B 20
 437+ 85FF 4C 69 6E 65  			defb	'Line: '
 437+ 8603 3A 20
 438+ 8605 20 20 20 20  MsgLineNo	defb	'     ; '
 438+ 8609 20 3B 20
 439+ 860C 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 439+ 8610 61 70 20
 440+ 8613 20 4F 6E     MsgLineWrF	defb	' On'
 441+ 8616 20 30 2D 45  			defb	' 0-Exit'
 441+ 861A 78 69 74
 442+ 861D              MsgLineLen	EQU		$ - MsgLine
 443+ 861D
 444+ 861D 20 20 20 20  LineBuf		defb	'                                                                '
 444+ 8621 20 20 20 20
 444+ 8625 20 20 20 20
 444+ 8629 20 20 20 20
 444+ 862D 20 20 20 20
 444+ 8631 20 20 20 20
 444+ 8635 20 20 20 20
 444+ 8639 20 20 20 20
 444+ 863D 20 20 20 20
 444+ 8641 20 20 20 20
 444+ 8645 20 20 20 20
 444+ 8649 20 20 20 20
 444+ 864D 20 20 20 20
 444+ 8651 20 20 20 20
 444+ 8655 20 20 20 20
 444+ 8659 20 20 20 20
 445+ 865D 00 00        CurLine		defw	0
 446+ 865F 00 00        MaxLine		defw	0
 447+ 8661 01           WrapFlag	defb	1
 448+ 8662 00 00        FileBegin	defw	0
 449+ 8664 00 00        FileLen		defw	0
 450+ 8666 00 00        FileEnd		defw	0
 451+ 8668 00 00        PROGR_PERC	defw	0
 452+ 866A
 453+ 866A              SCRLinesDown	EQU $5b00
 454+ 866A              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 455+ 866A              End:
 456+ 866A
# file closed: txtview.asm
1110  866A
1111  866A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1112  866A 48 43 20 43  VerMsg1			DEFM	'HC Commander 1.', '0' + $80
1112  866E 6F 6D 6D 61
1112  8672 6E 64 65 72
1112  8676 20 31 2E B0
1113  867A 67 65 6F 72  VerMsg2			DEFM	'george.chirtoac', 'a' + $80
1113  867E 67 65 2E 63
1113  8682 68 69 72 74
1113  8686 6F 61 63 E1
1114  868A 40 67 6D 61  VerMsg3			DEFM	'@gmail.com, 202', '3' + $80
1114  868E 69 6C 2E 63
1114  8692 6F 6D 2C 20
1114  8696 32 30 32 B3
1115  869A 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1115  869E 20 49 6E 66
1115  86A2 6F 20 20 20
1115  86A6 20 20 20 A0
1116  86AA 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1116  86AE 20 49 6E 66
1116  86B2 6F 20 20 20
1116  86B6 20 20 20 A0
1117  86BA 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1117  86BE 61 67 65 73
1117  86C2 20 20 20 20
1117  86C6 20 20 20 A0
1118  86CA 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1118  86CE 20 32 2D 42
1118  86D2 3A 20 33 2D
1118  86D6 56 69 65 77
1118  86DA 20 34 2D 50
1118  86DE 72 6F 70 20
1118  86E2 35 2D 43 6F
1118  86E6 70 79 20 36
1118  86EA 2D 52 65 6E
1118  86EE 20 37 2D 41
1118  86F2 74 74 72 20
1118  86F6 38 2D 44 65
1118  86FA 6C 20 39 2D
1118  86FE 44 69 73 6B
1118  8702 20 30 2D 45
1118  8706 78 69 F4
1119  8709 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1119  870D 65 20 20 20
1119  8711 3A 20 20 20
1119  8715 20 20 20
1120  8718 C1           MsgDriveLet		DEFM	'A' + $80
1121  8719 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1121  871D 73 20 20 20
1121  8721 3A
1122  8722 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1122  8726 31 32 B8
1123  8729 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1123  872D 20 4B 42 20
1123  8731 3A
1124  8732 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1124  8736 36 33 B6
1125  8739 45 72 72 6F  MsgErr			DEFM	'Error code '
1125  873D 72 20 63 6F
1125  8741 64 65 20
1126  8744 30 30 30 3A  MsgErrCode		DEFM	'000:',' ' + $80
1126  8748 A0
1127  8749 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1127  874D 69 6E 67 20
1127  8751 50 72 6F 67
1127  8755 72 61 ED
1128  8758 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1128  875C 69 6E 67 20
1128  8760 53 43 52 45
1128  8764 45 4E A4
1129  8767 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1129  876B 69 6E 67 20
1129  876F 43 4F 44 45
1129  8773 20 28 21 A9
1130  8777 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1130  877B 20 4C 65 6E
1130  877F 3A
1131  8780 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1131  8784 30 20 CB
1132  8787 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1132  878B 69 62 20 20
1132  878F 3A
1133  8790 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1133  8794 48 49 C4
1134  8797 46 69 6C 65  MsgFileType		DEFM	'FileType:'
1134  879B 54 79 70 65
1134  879F 3A
1135  87A0 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1135  87A4 20 20 20 20
1135  87A8 20 A0
1136  87AA 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1136  87AE 72 61 ED
1137  87B1 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1137  87B5 73 20 A0
1138  87B8 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1138  87BC 45 4E A4
1139  87BF 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1139  87C3 41 72 F2
1140  87C6 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1140  87CA 41 72 F2
1141  87CD 44 61 74 61  MsgFileTypeText	DEFM	'Data  ', ' ' + $80
1141  87D1 20 20 A0
1142  87D4 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1142  87D8 20 20 A0
1143  87DB 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1143  87DF 74 68 20 20
1143  87E3 3A
1144  87E4 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1144  87E8 35 20 C2
1145  87EB 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1145  87EF 74 20 20 20
1145  87F3 3A
1146  87F4 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1146  87F8 35 20 A0
1147  87FB 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1147  87FF 69 6E 67 20
1147  8803 68 65 61 64
1147  8807 65 F2
1148  8809 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1148  880D 20 20 20 20
1148  8811 20 20 20 20
1148  8815 20 20 20 A0
1149  8819 44 65 6C 20  MsgDelete		DEFM	'Del file (y/n)', '?' | $80
1149  881D 66 69 6C 65
1149  8821 20 28 79 2F
1149  8825 6E 29 BF
1150  8828 53 65 74 20  MsgSetRO		DEFM	'Set R/O (y/n)', '?' | $80
1150  882C 52 2F 4F 20
1150  8830 28 79 2F 6E
1150  8834 29 BF
1151  8836 53 65 74 20  MsgSetSYS		DEFM	'Set HID (y/n)', '?' | $80
1151  883A 48 49 44 20
1151  883E 28 79 2F 6E
1151  8842 29 BF
1152  8844 4E 61 6D 65  MsgNewFileName	DEFM	'Name,none=abort', ':' | $80
1152  8848 2C 6E 6F 6E
1152  884C 65 3D 61 62
1152  8850 6F 72 74 BA
1153  8854 43 6F 70 79  MsgCopyFile		DEFM	'Copying to '
1153  8858 69 6E 67 20
1153  885C 74 6F 20
1154  885F 41 BA        MsgCopyFileDrv	DEFM	'A', ':' | $80
1155  8861 44 69 73 6B  MsgMenu0		DEFM	'Disk options', ':' | $80
1155  8865 20 6F 70 74
1155  8869 69 6F 6E 73
1155  886D BA
1156  886E 31 2E 46 6F  MsgMenu1		DEFM	'1.Format disk '
1156  8872 72 6D 61 74
1156  8876 20 64 69 73
1156  887A 6B 20
1157  887C 41 BA        MsgMenu1Drv		DEFM	'A', ':' | $80
1158  887E 32 2E 43 6F  MsgMenu2		DEFM	'2.Copy disk '
1158  8882 70 79 20 64
1158  8886 69 73 6B 20
1159  888A 41 BA        MsgMenu2Drv		DEFM	'A', ':' | $80
1160  888C 33 2E 45 78  MsgMenu3		DEFM	'3.Exit men', 'u' | $80
1160  8890 69 74 20 6D
1160  8894 65 6E F5
1161  8897 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1161  889B 61 74 74 69
1161  889F 6E 67 20
1162  88A2 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1163  88A4 30 30 30 20  MsgBlocksLeft	DEFB	'000 blocks lef', 't' | $80
1163  88A8 62 6C 6F 63
1163  88AC 6B 73 20 6C
1163  88B0 65 66 F4
1164  88B3
1165  88B3              	IFNDEF	_ROM_FNT_
1166  88B3 ~            FontTable:
1167  88B3 ~            	incbin "cpmfnt.bin"
1168  88B3              	ENDIF
1169  88B3              EndCode:
1170  88B3
1171  88B3              ;Unalocated variables
1172  88B3              UnallocStart	EQU		$
1173  88B3              FileCnt			EQU		$						;File counter, 1B
1174  88B3              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1175  88B3              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1176  88B3              CursorAddr		EQU		SelFile + 1				;2 B
1177  88B3              AUCnt			EQU		CursorAddr + 2			;2 B
1178  88B3              SelFileCache	EQU		AUCnt + 2				;2 B
1179  88B3
1180  88B3
1181  88B3              FileCache		EQU		SelFileCache + 2					;cache table, size = 92 * 25 = 2300
1182  88B3              	IFDEF	_ROM_FNT_
1183  88B3              FontTable		EQU		FileCache + LST_MAX_FILES*CACHE_SZ
1184  88B3              TrackBuf		EQU		FontTable + 872						;size = 16 * 256 = 4096
1185  88B3              	ELSE
1186  88B3 ~            TrackBuf		EQU		FileCache + LST_MAX_FILES*CACHE_SZ	;size = 16 * 256 = 4096
1187  88B3              	ENDIF
1188  88B3              DataBuf			EQU		TrackBuf + SPT*SECT_SZ
1189  88B3
1190  88B3              CopyFileFCBSrc	EQU	DataBuf
1191  88B3              CopyFileFCBDst	EQU	DataBuf + 2
1192  88B3              CopyFileResRead	EQU DataBuf + 4
1193  88B3              CopyFileResWrite EQU DataBuf + 5
1194  88B3              CopyFileDMAAddr	EQU	DataBuf + 6
1195  88B3              CopyFileDMA		EQU	DataBuf + 8
1196  88B3
1197  88B3              TheEnd			EQU		DataBuf
1198  88B3
1199  88B3              ;File viewer constants
1200  88B3              FileData		EQU		DataBuf + SECT_SZ		;leave out room for a sector buffer
1201  88B3              ;File buffer size, without index
1202  88B3              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - 3*1024
1203  88B3              ;Set a few KB aside for file indexing
1204  88B3              FileIdx			EQU		FileData + FileDataSize
1205  88B3
1206  88B3              ;FS block list constants
1207  88B3              UsedBlockListCnt	EQU	DataBuf
1208  88B3              UsedBlockListBlk	EQU	DataBuf + 2
1209  88B3              UsedBlockListSz		EQU 320 * 2
1210  88B3              ;Copy buffer size
1211  88B3              CopyDiskBuf			EQU DataBuf + 2 + UsedBlockListSz
1212  88B3
1213  88B3              ;We can use up to about 30KB free space if we load at address 24000.
1214  88B3              ;but that requires distinct BASIC loader, meaning 2 files, wasted disk space and higher initial loading time.
1215  88B3              ;Testing with 15KB vs 25KB didn't show a big difference, around 2 seconds for total time of 42 seconds, for a 40KB file copy.
1216  88B3              MAX_RAM_FREE	EQU		$FF00 - DataBuf - 1024
1217  88B3              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1218  88B3              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1219  88B3
1220  88B3              	DISPLAY "DataBuf: ",/D,DataBuf
1221  88B3              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
1222  88B3              	DISPLAY "MAX_AU_RAM: ",/D,MAX_AU_RAM
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x7C84   NoSub
0x7C7D   DivLoop
0x55E0   MAX_RAM_FREE
0x0280   UsedBlockListSz
0xA520 X TheEnd
0x88B3 X UnallocStart
0x88B3 X EndCode
0x866A X End
0x865F X MaxLine
0x860C X MsgLineWrap
0x85B1   ScrollDownLoop
0x85A8   ScrollDownLoop2
0x85AF   ScrollDownPtrSrc
0x85AC   ScrollDownPtrDest
0x859E   Scroll
0x858B   FillScrLinesRev
0x5B2E   SCRLinesUp
0x8593   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x856E   FillScrLinesPtr
0x856D   FillScrLinesLoop
0x855E   GetCellDown
0x8559   ReplaceMatch
0x854D   ReplaceSGCLoop
0x000D   CharReplTblLen
0x85D6   CharReplaceTbl
0x002D   MsgLineLen
0x85F0   MsgLine
0x8605   MsgLineNo
0x85F9   MsgLinePr
0x84F0   GetLineFillLoop
0x84CD   GetLineFill
0x8546   ReplaceChars
0x84B9   Valid
0x84B6   NotValid
0x84BD   GetLineSkip0D
0x84AC   GetLineNext
0x84C6   GetLineSkip0A
0x8497   GetLineLoop
0x8478   PrintStrTxt
0x861D   LineBuf
0x859B   ScrollDown
0x8596   ScrollUp
0x8449   CheckBegin
0x8613   MsgLineWrF
0x83DA   NoWrap
0x8661   WrapFlag
0x83E9   Up
0x8414   Down
0x8394   GetKey
0x83AB   PrintLoop2
0x83A3   EOF
0x8459   CheckEnd
0x8464   PrintLine
0x8492   GetLine
0xEF20   FileIdx
0x84F7   PrintMsg
0x8668   PROGR_PERC
0x865D   CurLine
0x8568   ScrollInit
0x8664   FileLen
0x8666   FileEnd
0x8662   FileBegin
0x5CB0   COORDS
0x001A   EOF_MARKER
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x8303   ReadStrPrint
0x82F3   ReadStrChar
0x82D6   ReadStringLoop
0x82CA   Store
0x82C9   NoTurn
0x82BE   PrintCharLine
0x82AA X PrintChar3
0x8255   DrawCursorLoop
0x8235   DrawVLinesLoop
0x8248   PrintChar2
0x8213   DrawUpLine
0x8215   ChrParam
0x8206 X DrawHLine
0x81F5   DrawLineLoop
0x8202   LineDir
0x81F2   StoreDir
0x81F0   VertDir
0x81E7   DrawLine
0x81E3   StrClr
0x8196   GoodChar
0x8312   CurrScrAddr
0x91B8   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x001A X CHR_EOF
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x0007   INK_WHITE
0x0006 X INK_YELLOW
0x0005 X INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020 X PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008   PAPER_BLUE
0x0000 X PAPER_BLACK
0x0040 X CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x8146   ReadFileSectionEnd
0x8128   ReadFileSectionLoop
0x4900   FileDataSize
0xA525   CopyFileResWrite
0x80D0   FileCopyWriteLoop
0x80BF   FileCopyWrite
0xA524   CopyFileResRead
0x80A1   FileCopyReadLoop
0xA528   CopyFileDMA
0xA526   CopyFileDMAAddr
0x0055   MAX_SECT_RAM
0x8093   FileCopyLoop
0xA522   CopyFileFCBDst
0x80EE   CopyFileEnd
0xA520   CopyFileFCBSrc
0x803B X FileAttribSet
0x8002   GetFileSizeMul
0x8008   GetFileSizeEnd
0x8000   GetFileSizeOK
0x7FE0   BDOSSetDMA
0x7FE0 X BDOSFindNext
0x7FE0 X BDOSFindFirst
0x7FD2   WriteFileBlock
0x7FCE   ReadFileBlock
0x7FCA   CloseFile
0x7FC6   OpenFile
0x7FC2   CreateFile
0x7FB8   DestroyChannel
0x7FA2   CreateChannel
0x7FA2 X BDOSGetCurrentDisk
0x7FA2 X BDOSGetDiskRO
0x7FA2 X BDOSMakeDiskRO
0x7FD6   BDOS
0x7F91 X RWTSResTmp
0x7F90 X RWTSResVolNo
0x7F8C X RWTSPrmTbl
0x7F8A X RWTSExtBuf
0x7F87 X RWTSSector
0x7F85 X RWTSVolNo
0x7F83 X RWTSBlockType
0x7F7A   CopyMsg
0x7F6E   SearchMsgEnd
0x7F77   SaveMsg
0x7F65   IF1Paged
0x7F30   IF1Call
0x7F2B   IsFileHeaderValidLoop
0x7FE4   GetFileSize
0x7F0F   ReadFileHeaderIsTextFile
0x7F28   IsFileHeaderValid
0x7F24   ReadHeaderEnd
0x7EC9   CacheNotFinished
0x7F96   BDOSInit
0x7F99   BDOSSelectDisk
0x7E66   FileReadLoop
0x7E5A X FileLoadHeader
0x7E6C   FileLoadNoHeader
0x7E7A   FileFree
0x7E36   MisMatch
0x7E2E   Compare
0x7E2C   StrCmp
0x7DFA   CopyDiskLoopWriteLoop
0x7DD4   CopyDiskLoopReadLoop
0xA7A2   CopyDiskBuf
0x7DCD   CopyDiskLoopRead
0x000A   MAX_AU_RAM
0x88A4   MsgBlocksLeft
0x7DAA   CopyDiskLoop
0xA522   UsedBlockListBlk
0x7E92   WriteDiskSectors
0x7D9F X WriteFSBlockLoop
0x7D96   WriteFSBlock
0x7E7F   ReadDiskSectors
0x7D92 X ReadFSBlockLoop
0x7D89   ReadFSBlock
0x7D7B   ReadUsedBlocksSkip
0x7D5E   ReadUsedBlocksLoop2
0x7D7E   ReadUsedBlocksSkip2
0x7D4E   ReadUsedBlocksLoop
0xA520   UsedBlockListCnt
0x7D31   ReadUsedBlocksList
0x7D2A   CheckAUEnd
0x7D16   CheckAU
0x7CFF   FirstAU
0x7CF9   Track0
0x7CE4   AU2TS
0x7F8F   RWTSRes
0x7CC8   WriteOneDiskSector
0x7F86   RWTSTrack
0x7F88   RWTSDMA
0x7CBD   ReadOneDiskSector
0x7F83   RWTSParams
0x7F8E   RWTSCmd
0x7CB1   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x7CAB   NoAdd
0x7CA5   MulLoop
0x7C8C   Div2Loop
0x7C87   Div2
0x7C7A   Div
0x7C71   DivNrLoop
0x7C6F   DigitLoop
0x7C60   Byte2Txt_
0x7C49   StrippLeading0
0x7C54   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x7C30   DontInc
0x7C24   ReadAllHeadersEnd
0x7C0F   AKey
0x8156   KbdHit
0x7BF4   NextFile
0x87DB   MsgFileLen
0x8797   MsgFileType
0x87EB   MsgFileStart
0x7BB3   PrintStartStr
0x87F4   MsgFileStartN
0x87D4   MsgNA
0x7BA5   PrintStart
0x0007   HDR_LINE
0x7B80   PrintByteStart
0x7B78   PrintProgStart
0x87E4   MsgFileLenN
0x7B5E X PrepFileLenText
0x87CD   MsgFileTypeText
0x87B1   MsgFileTypeByte
0x87B8   MsgFileTypeSCR
0x7B44   NotScr
0x7B4F   CheckText
0x87BF   MsgFileTypeChrA
0x7B27   CheckByte
0x0002   CHAR_TYPE
0x87C6   MsgFileTypeNoA
0x7B18   CheckChrArr
0x0001   NUMB_TYPE
0x7B58   PrepFileLen
0x7BD1   MoveMsg
0x87A0   MsgFileTypeN
0x87AA   MsgFileTypePrg
0x7B09   CheckNoArr
0x000B   CACHE_FIRST_AU
0x7B88   HeadNotRead
0x8787   MsgFileAttr
0x7ADA   AttrEnd
0x7ACE   NotSYS
0x7ABA   CheckSys
0x7AA8   NotRO
0x8790   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x7B9A   PrintStartNotRead
0x8777   MsgFileSzDsk
0x8780   MsgFileSzDskN
0x7A64 X ViewFileEnd
0x8370   PrintLoop
0x8316   InitViewer
0xA620   FileData
0x8109   ReadFileSection
0x7F36   LoadProgram
0x8749   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x8758   MsgLoadingSCR
0x0003   HDR_ADDR
0x7E7A   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7E39   IF1FileLoad
0x8767   MsgLoadingCODE
0x79F2 X HandleFileCODE
0x7A1B   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x7A49   HandleFileText
0x0003   BYTE_TYPE
0x7A39   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x79BC   FindExtEnd
0x7EBE   FindCache
0x79CB   GetFileNamesEnd
0x0009   HDR_SZ
0x7997   FindExt
0x000C   EXT_IDX
0x7D02   CheckExtAlloc
0x79BE   NextExt
0x0000   EXT_DEL_FLAG
0x793E   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x7925   DisplayFilenamesLoop
0x791E X DisplayFilenames
0x7914   LineOK
0x5CB1   LINE
0x5CB0   COL
0x8292   PrintChar
0x5C81   CODE
0x78EE   DispLoop
0x78EC   DisplayFilename
0x825A   MoveCursor
0x7DA3   CopyDisk
0x7CD3   FormatDisk
0x8897   MsgFormat
0x78D2   CheckExtra2
0x78DB   ExtraMenuExit
0x888C   MsgMenu3
0x887E   MsgMenu2
0x886E   MsgMenu1
0x7863   CheckKeyExtraMenu
0x888A   MsgMenu2Drv
0x88A2   MsgFormatDrv
0x887C   MsgMenu1Drv
0x8861   MsgMenu0
0x78DE   CheckKeyExit
0x801A   ChangeFileAttrib
0x7836   AttrChange
0x8836   MsgSetSYS
0x781E   CheckSYS
0x8828   MsgSetRO
0x7845   CheckKeyExtra
0x800E   DeleteFile
0x77F7   DoFileDelete
0x8819   MsgDelete
0x7804   CheckKeyAttrib
0x8044   RenameFile
0x77C5   RenameCanceled
0x82D0   ReadString
0x000B   NAMELEN
0x8844   MsgNewFileName
0x77D3   CheckKeyDel
0x7A4A   ViewFile
0x7784   CheckKeyRename
0x0001   DRIVE_B_CPM
0x777A   CheckKeyView
0x783F   SelectDrive
0x7771   CheckKeyDriveB
0x7BD7   ReadAllHeaders
0x7768   CheckKeyDriveA
0x775B   CopyFileOK
0x8067   CopyFile
0x8854   MsgCopyFile
0x885F   MsgCopyFileDrv
0x775E   CheckKeyFileInfo
0x8809   MsgClear
0x7ECF   ReadFileHeader
0x87FB   MsgReadingExt
0x7721   CheckKeyCopy
0x79CC   HandleFile
0x76FD   CheckKeyInfo
0x000D   KEY_ENTER
0x76F2   CheckEnter
0x0008   KEY_LEFT
0x0017   LST_LINES_CNT
0x76E1   CheckLeft
0x0009   KEY_RIGHT
0x76CB   CheckRight
0x000B   KEY_UP
0x78E6   MoveIt
0x76BA   CheckUp
0x000A   KEY_DOWN
0x7A65   DisplayFileInfo
0x88BA   SelFileCache
0x7C9A   Mul
0x768B   CalcFileCache
0x8729   MsgFreeSpace
0x7C33   Word2Txt
0x8732   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x8719   MsgFilesCnt
0x8722   MsgFilesCntNo
0x8709   MsgDrive
0x8718   MsgDriveLet
0x7F4F   SetFastKeys
0x824F   DrawCursor
0x0028   SCR_SEL_CLR
0x88B8   AUCnt
0x5CB0   LineCol
0x86BA   MsgMessages
0x0007   LST_FILE_INFO
0x86AA   MsgFileInf
0x0003   LST_DISK_INFO
0x869A   MsgDskInf
0x868A   VerMsg3
0x867A   VerMsg2
0x818F   PrintStr
0x866A   VerMsg1
0x86CA   BtnBar
0x0028   SCR_LBL_CLR
0x8230   DrawVLines
0x0084   CHR_DC
0x816F   ClrScr
0x88B6   CursorAddr
0x8314   CurrScrAttrAddr
0x0000   LST_FIRST_LINE
0x0020   SCR_BYTES_PER_LINE
0x88B4   NameCol
0x0010   LST_FIRST_COL
0x88B3   FileCnt
0x88B5   SelFile
0xA520   DataBuf
0x7F5A   GetErrMsg
0x5C3A   ERRNR
0x758A   HCRunEnd
0x769C   ReadKeyLoop
0x7642   DisplayDiskInfo
0x7935   GetFileNames
0x75C2   InitUI
0x7F84   RWTSDrive
0x0000   DRIVE_A_CPM
0x8153   ReadChar
0x81B7   PrintStrClr
0x0080   CLR_FLASH
0x000F   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x8739   MsgErr
0x7C3E   Byte2Txt
0x8744   MsgErrCode
0x757E   HCRunMain
0x7EA5   ReadCatalogTrack
0x0019   CACHE_SZ
0x005C   LST_MAX_FILES
0x88BC   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x9520   TrackBuf
0x7542   HCRunInitDisk
0x7590   ErrorHandler
0x5C3D   ERRSP
0x7CAE   IF1Init
0x8159   InitFonts
0x7530   Start
