# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 26000
  12  6590
  13  6590              Start:
  14  6590              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  6590 CD FA 75     		call InitFonts
  16  6593              	ENDIF
  17  6593 CD C5 6D     	call IF1Init
  18  6596
  19  6596              	;install error handler
  20  6596 2A 3D 5C     	ld		hl, (ERRSP)
  21  6599 E5           	push	hl
  22  659A 21 F5 65     	ld		hl, ErrorHandler
  23  659D E5           	push	hl
  24  659E ED 73 3D 5C  	ld		(ERRSP), sp
  25  65A2
  26  65A2              HCRunInitDisk:
  27  65A2              	;Set track buffer to del marker
  28  65A2 21 FE 8C     	ld		hl, TrackBuf
  29  65A5 54           	ld		d, h
  30  65A6 5D           	ld		e, l
  31  65A7 13           	inc		de
  32  65A8 01 00 10     	ld		bc, SPT*SECT_SZ
  33  65AB 36 E5        	ld		(hl), DEL_MARKER
  34  65AD ED B0        	ldir
  35  65AF
  36  65AF              	;Invalidate file cache
  37  65AF 21 E0 7E     	ld		hl, FileCache
  38  65B2 54           	ld		d, h
  39  65B3 5D           	ld		e, l
  40  65B4 13           	inc		de
  41  65B5 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  65B8 36 00        	ld		(hl), 0
  43  65BA ED B0        	ldir
  44  65BC
  45  65BC              	;main program
  46  65BC CD AE 70     	call 	ReadCatalogTrack
  47  65BF B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  48  65C0 28 1E        	jr		z, HCRunCacheFiles
  49  65C2
  50  65C2 6F           	ld		l, a
  51  65C3 26 00        	ld		h, 0
  52  65C5 11 CB 7C     	ld		de, MsgErrCode
  53  65C8 CD 55 6D     	call	Byte2Txt
  54  65CB 21 C0 7C     	ld		hl, MsgErr
  55  65CE 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  56  65D1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  57  65D3 CD 58 76     	call	PrintStrClr
  58  65D6 CD F4 75     	call	ReadChar
  59  65D9 3E 00        	ld		a, DRIVE_A_CPM		;Reset drive to A in case B was selected but was empty.
  60  65DB 32 8A 71     	ld		(RWTSDrive), a
  61  65DE 18 C2        	jr		HCRunInitDisk
  62  65E0
  63  65E0              HCRunCacheFiles:
  64  65E0 CD 3F 6A     	call 	GetFileNames
  65  65E3
  66  65E3              HCRunMain:
  67  65E3 CD 27 66     	call 	InitUI
  68  65E6 CD 1F 6A     	call	DisplayFilenames
  69  65E9 CD A5 66     	call	DisplayDiskInfo
  70  65EC C3 FF 66     	jp		ReadKeyLoop
  71  65EF
  72  65EF              HCRunEnd:
  73  65EF              	;restore error handler
  74  65EF E1           	pop		hl
  75  65F0 E1           	pop		hl
  76  65F1 22 3D 5C     	ld		(ERRSP), hl
  77  65F4
  78  65F4 C9           	ret
  79  65F5
  80  65F5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  81  65F5
  82  65F5              ErrorHandler:
  83  65F5 E1           	pop		hl
  84  65F6 22 3D 5C     	ld		(ERRSP), hl
  85  65F9
  86  65F9 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
  87  65FC 6F           	ld		l, a
  88  65FD 26 00        	ld		h, 0
  89  65FF 11 CB 7C     	ld		de, MsgErrCode
  90  6602 CD 55 6D     	call	Byte2Txt
  91  6605 21 C0 7C     	ld		hl, MsgErr
  92  6608 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
  93  660B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  94  660D CD 58 76     	call	PrintStrClr
  95  6610
  96  6610 3A 3A 5C     	ld		a, (ERRNR)
  97  6613 CD 63 71     	call	GetErrMsg
  98  6616
  99  6616 21 FE 8C     	ld		hl, DataBuf
 100  6619 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 101  661C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 102  661E CD 58 76     	call	PrintStrClr
 103  6621
 104  6621 CD F4 75     	call	ReadChar
 105  6624 C3 90 65     	jp	Start
 106  6627
 107  6627
 108  6627
 109  6627
 110  6627              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 111  6627
 112  6627              InitUI:
 113  6627 AF           	xor		a
 114  6628 32 B6 7E     	ld		(SelFile), A
 115  662B 3E 11        	ld		a, LST_FIRST_COL + 1
 116  662D 32 B5 7E     	ld		(NameCol), A
 117  6630 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 118  6633 ED 53 B0 5C  	ld		(LineCol), de
 119  6637
 120  6637 CD 10 76     	call	ClrScr
 121  663A
 122  663A 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 123  663D ED 4B F1 77  	ld		bc, (CurrScrAttrAddr)
 124  6641 09           	add		hl, bc
 125  6642 22 B7 7E     	ld		(CursorAddr), hl
 126  6645
 127  6645 CD 01 77     	call	DrawVLines
 128  6648
 129  6648 CD A7 76     	call	DrawHLines
 130  664B
 131  664B 21 F1 7B     	ld		hl, VerMsg1
 132  664E 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 133  6651 3A 00 7C     	ld		a, (VerMsg1 + 15)
 134  6654 F6 80        	or		$80
 135  6656 32 00 7C     	ld		(VerMsg1 + 15), a
 136  6659 CD 30 76     	call	PrintStr
 137  665C 21 01 7C     	ld		hl, VerMsg2
 138  665F 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 139  6662 CD 30 76     	call	PrintStr
 140  6665
 141  6665 3E 20        	ld		a, SCR_LBL_CLR
 142  6667 11 00 17     	ld		de, 23 << 8
 143  666A 21 51 7C     	ld		hl, BtnBar
 144  666D CD 58 76     	call	PrintStrClr
 145  6670
 146  6670 3E 20        	ld		a, SCR_LBL_CLR
 147  6672 21 11 7C     	ld		hl, MsgSysInf
 148  6675 11 00 01     	ld		de, LST_PROG_INFO << 8
 149  6678 CD 58 76     	call	PrintStrClr
 150  667B
 151  667B 3E 20        	ld		a, SCR_LBL_CLR
 152  667D 21 21 7C     	ld		hl, MsgDskInf
 153  6680 11 00 04     	ld		de, LST_DISK_INFO << 8
 154  6683 CD 58 76     	call	PrintStrClr
 155  6686
 156  6686 3E 20        	ld		a, SCR_LBL_CLR
 157  6688 21 31 7C     	ld		hl, MsgFileInf
 158  668B 11 00 08     	ld		de, LST_FILE_INFO << 8
 159  668E CD 58 76     	call	PrintStrClr
 160  6691
 161  6691 3E 20        	ld		a, SCR_LBL_CLR
 162  6693 21 41 7C     	ld		hl, MsgMessages
 163  6696 11 00 0E     	ld		de, LST_LINE_MSG << 8
 164  6699 CD 58 76     	call	PrintStrClr
 165  669C
 166  669C 3E 20        	ld		a, SCR_SEL_CLR
 167  669E CD 19 77     	call	DrawCursor
 168  66A1
 169  66A1 CD 58 71     	call	SetFastKeys
 170  66A4
 171  66A4 C9           	ret
 172  66A5
 173  66A5
 174  66A5              DisplayDiskInfo:
 175  66A5 3A 8A 71     	ld		a, (RWTSDrive)
 176  66A8 C6 C1        	add		'A' + $80
 177  66AA 32 9F 7C     	ld		(MsgDriveLet), a
 178  66AD 21 90 7C     	ld		hl, MsgDrive
 179  66B0 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 180  66B3 CD 30 76     	call	PrintStr
 181  66B6
 182  66B6 3A B4 7E     	ld		a, (FileCnt)
 183  66B9 6F           	ld		l, a
 184  66BA 26 00        	ld		h, 0
 185  66BC 11 A9 7C     	ld		de, MsgFilesCntNo
 186  66BF CD 55 6D     	call	Byte2Txt
 187  66C2 21 A0 7C     	ld		hl, MsgFilesCnt
 188  66C5 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 189  66C8 CD 30 76     	call	PrintStr
 190  66CB
 191  66CB ED 5B B9 7E  	ld		de, (AUCnt)
 192  66CF 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
 193  66D2 B7           	or		a
 194  66D3 ED 52        	sbc		hl, de
 195  66D5 CB 15        	rl		l								;*2, 2K/AU
 196  66D7 CB 14        	rl		h
 197  66D9 11 B7 7C     	ld		de, MsgFreeSpaceNo - 2
 198  66DC CD 4A 6D     	call	Word2Txt
 199  66DF 3E 3A        	ld		a, ':'
 200  66E1 32 B8 7C     	ld		(MsgFreeSpaceNo -1), a
 201  66E4 21 B0 7C     	ld		hl, MsgFreeSpace
 202  66E7 11 00 07     	ld		de, LST_DISK_INFO + 3 << 8
 203  66EA CD 30 76     	call	PrintStr
 204  66ED
 205  66ED C9           	ret
 206  66EE
 207  66EE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 208  66EE
 209  66EE              CalcFileCache:
 210  66EE 3A B6 7E     	ld		a, (SelFile)
 211  66F1 11 19 00     	ld		de, CACHE_SZ
 212  66F4 CD B1 6D     	call	Mul
 213  66F7 01 E0 7E     	ld		bc, FileCache
 214  66FA 09           	add		hl, bc					;HL = file AU cnt
 215  66FB 22 BB 7E     	ld		(SelFileCache), hl
 216  66FE C9           	ret
 217  66FF
 218  66FF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 219  66FF
 220  66FF
 221  66FF              ReadKeyLoop:
 222  66FF CD EE 66     	call	CalcFileCache
 223  6702 CD 82 6B     	call	DisplayFileInfo
 224  6705
 225  6705 CD F4 75     	call	ReadChar
 226  6708
 227  6708 FE 0A        	cp		KEY_DOWN
 228  670A 28 04        	jr		z,  DoKeyDown
 229  670C FE 61        	cp 		'a'
 230  670E 20 11        	jr		nz, CheckUp
 231  6710
 232  6710              DoKeyDown:
 233  6710 3A B4 7E     	ld		a, (FileCnt)
 234  6713 47           	ld		b, a
 235  6714 3A B6 7E     	ld		a, (SelFile)
 236  6717 3C           	inc		a
 237  6718 B8           	cp		b
 238  6719 30 E4        	jr		nc, ReadKeyLoop
 239  671B 32 B6 7E     	ld		(SelFile), a
 240  671E C3 E7 69     	jp		MoveIt
 241  6721
 242  6721              CheckUp:
 243  6721 FE 0B        	cp		KEY_UP
 244  6723 28 04        	jr		z, DoKeyUp
 245  6725 FE 71        	cp 		'q'
 246  6727 20 0D        	jr		nz, CheckRight
 247  6729
 248  6729              DoKeyUp:
 249  6729 3A B6 7E     	ld		a, (SelFile)
 250  672C B7           	or		a
 251  672D 28 D0        	jr		z, ReadKeyLoop
 252  672F
 253  672F 3D           	dec		a
 254  6730 32 B6 7E     	ld		(SelFile), a
 255  6733 C3 E7 69     	jp		MoveIt
 256  6736
 257  6736              CheckRight:
 258  6736 FE 09        	cp		KEY_RIGHT
 259  6738 28 04        	jr		z, DoKeyRight
 260  673A FE 70        	cp 		'p'
 261  673C 20 12        	jr		nz, CheckLeft
 262  673E
 263  673E              DoKeyRight:
 264  673E 3A B4 7E     	ld		a, (FileCnt)
 265  6741 47           	ld		b, a
 266  6742 3A B6 7E     	ld		a, (SelFile)
 267  6745 C6 15        	add		LST_LINES_CNT
 268  6747 B8           	cp		b
 269  6748 30 B5        	jr		nc, ReadKeyLoop
 270  674A
 271  674A 32 B6 7E     	ld		(SelFile), a
 272  674D C3 E7 69     	jp		MoveIt
 273  6750
 274  6750              CheckLeft:
 275  6750 FE 08        	cp		KEY_LEFT
 276  6752 28 04        	jr		z, DoKeyLeft
 277  6754 FE 6F        	cp		'o'
 278  6756 20 0D        	jr		nz, CheckEnter
 279  6758
 280  6758              DoKeyLeft:
 281  6758 3A B6 7E     	ld		a, (SelFile)
 282  675B D6 15        	sub		LST_LINES_CNT
 283  675D 38 A0        	jr		c, ReadKeyLoop
 284  675F
 285  675F 32 B6 7E     	ld		(SelFile), a
 286  6762 C3 E7 69     	jp		MoveIt
 287  6765
 288  6765              CheckEnter:
 289  6765 FE 0D        	cp		KEY_ENTER
 290  6767 28 05        	jr		z, DoKeyEnter
 291  6769 FE 6D        	cp		'm'
 292  676B C2 74 67     	jp		nz, CheckKeyInfo
 293  676E
 294  676E              DoKeyEnter:
 295  676E CD D8 6A     	call	HandleFile
 296  6771 C3 E3 65     	jp		HCRunMain
 297  6774
 298  6774              CheckKeyInfo:
 299  6774 FE 34        	cp		'4'
 300  6776 20 21        	jr		nz, CheckKeyCopy
 301  6778
 302  6778 3A B4 7E     	ld		a, (FileCnt)
 303  677B B7           	or		a
 304  677C CA FF 66     	jp		z, ReadKeyLoop
 305  677F
 306  677F DD 2A BB 7E  	ld		ix, (SelFileCache)
 307  6783 21 81 7D     	ld		hl, MsgReadingExt
 308  6786 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 309  6789 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 310  678B CD 58 76     	call	PrintStrClr
 311  678E CD D8 70     	call	ReadFileHeader
 312  6791 06 01        	ld		b, 1
 313  6793 CD DC 77     	call	ClearNMsgLines
 314  6796 C3 FF 66     	jp		ReadKeyLoop
 315  6799
 316  6799              CheckKeyCopy:
 317  6799 FE 35        	cp		'5'
 318  679B C2 E2 67     	jp		nz, CheckKeyFileInfo
 319  679E
 320  679E 3A B4 7E     	ld		a, (FileCnt)
 321  67A1 B7           	or		a
 322  67A2 CA FF 66     	jp		z, ReadKeyLoop
 323  67A5
 324  67A5 2A BB 7E     	ld		hl, (SelFileCache)
 325  67A8 CD DC 72     	call	CopyFile
 326  67AB 3A C0 7E     	ld		a, (CopyFileRes)
 327  67AE B7           	or		a
 328  67AF 28 1A        	jr		z, CopyFileOK
 329  67B1
 330  67B1 6F           	ld		l, a
 331  67B2 26 00        	ld		h, 0
 332  67B4 11 CB 7C     	ld		de, MsgErrCode
 333  67B7 CD 55 6D     	call	Byte2Txt
 334  67BA 21 C0 7C     	ld		hl, MsgErr
 335  67BD 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 336  67C0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 337  67C2 CD 58 76     	call	PrintStrClr
 338  67C5 CD F4 75     	call	ReadChar
 339  67C8 C3 FF 66     	jp		ReadKeyLoop
 340  67CB
 341  67CB              CopyFileOK:
 342  67CB 06 02        	ld		b, 2
 343  67CD CD DC 77     	call	ClearNMsgLines
 344  67D0              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 345  67D0 3A BD 7E     	ld		a, (CopySelOption)
 346  67D3 FE 33        	cp		'3'
 347  67D5 CA FF 66     	jp		z, ReadKeyLoop
 348  67D8 3A D4 7E     	ld		a, (CopyFileDstDrv)
 349  67DB 3D           	dec		a
 350  67DC 32 8A 71     	ld		(RWTSDrive), a
 351  67DF C3 A2 65     	jp		HCRunInitDisk
 352  67E2
 353  67E2              CheckKeyFileInfo:
 354  67E2 FE 20        	cp		' '
 355  67E4 20 0D        	jr		nz, CheckKeyDriveA
 356  67E6
 357  67E6 3A B4 7E     	ld		a, (FileCnt)
 358  67E9 B7           	or		a
 359  67EA CA FF 66     	jp		z, ReadKeyLoop
 360  67ED
 361  67ED CD F4 6C     	call	ReadAllHeaders
 362  67F0 C3 FF 66     	jp		ReadKeyLoop
 363  67F3
 364  67F3              CheckKeyDriveA:
 365  67F3 FE 31        	cp		'1'
 366  67F5 20 05        	jr		nz, CheckKeyDriveB
 367  67F7 3E 00        	ld		a, DRIVE_A_CPM
 368  67F9 C3 FA 68     	jp		SelectDrive
 369  67FC
 370  67FC              CheckKeyDriveB:
 371  67FC FE 32        	cp		'2'
 372  67FE 20 05        	jr		nz, CheckKeyView
 373  6800 3E 01        	ld		a, DRIVE_B_CPM
 374  6802 C3 FA 68     	jp		SelectDrive
 375  6805
 376  6805              CheckKeyView:
 377  6805 FE 33        	cp		'3'
 378  6807 20 0D        	jr		nz, CheckKeyRename
 379  6809
 380  6809 3A B4 7E     	ld		a, (FileCnt)
 381  680C B7           	or		a
 382  680D CA FF 66     	jp		z, ReadKeyLoop
 383  6810
 384  6810 CD 53 6B     	call	ViewFile
 385  6813 C3 E3 65     	jp		HCRunMain
 386  6816
 387  6816              CheckKeyRename:
 388  6816 FE 36        	cp		'6'
 389  6818 20 6C        	jr		nz, CheckKeyDel
 390  681A
 391  681A 3A B4 7E     	ld		a, (FileCnt)
 392  681D B7           	or		a
 393  681E CA FF 66     	jp		z, ReadKeyLoop
 394  6821
 395  6821 21 C4 7D     	ld		hl, MsgNewFileName
 396  6824 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 397  6827 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 398  6829 CD 58 76     	call	PrintStrClr
 399  682C
 400  682C 21 8F 7D     	ld		hl, MsgClear
 401  682F 11 FE 8C     	ld		de, FileData
 402  6832 01 0B 00     	ld		bc, NAMELEN
 403  6835 ED B0        	ldir
 404  6837 3E A0        	ld		a, $80 | ' '
 405  6839 12           	ld		(de), a
 406  683A 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 407  683D 21 FE 8C     	ld		hl, FileData
 408  6840 CD 30 76     	call	PrintStr
 409  6843
 410  6843 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 411  6846 01 0B 00     	ld		bc, NAMELEN
 412  6849 CD 9A 77     	call	ReadString
 413  684C
 414  684C 11 FE 8C     	ld		de, FileData
 415  684F 1A           	ld		a, (de)
 416  6850 FE 20        	cp		' '					;If starting with space, input was canceled.
 417  6852 CA 7E 68     	jp		z, RenameCanceled
 418  6855
 419  6855              	;Check if new name doesn't exist already. Cancel if so.
 420  6855 21 FE 8C     	ld		hl, FileData
 421  6858 3A 8A 71     	ld 		a, (RWTSDrive)
 422  685B 3C           	inc		a
 423  685C CD 42 72     	call	DoesFileExist
 424  685F 3C           	inc		a
 425  6860 28 10        	jr		z, RenameFileNotExist
 426  6862
 427  6862 21 69 7E     	ld		hl, MsgFileExists
 428  6865 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 429  6868 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 430  686A CD 58 76     	call	PrintStrClr
 431  686D CD F4 75     	call	ReadChar
 432  6870 18 0C        	jr		RenameCanceled
 433  6872
 434  6872              RenameFileNotExist:
 435  6872 11 FE 8C     	ld		de, FileData
 436  6875 2A BB 7E     	ld		hl, (SelFileCache)
 437  6878 CD 85 72     	call	RenameFile
 438  687B C3 A2 65     	jp		HCRunInitDisk
 439  687E
 440  687E              RenameCanceled:
 441  687E 06 02        	ld		b, 2
 442  6880 CD DC 77     	call	ClearNMsgLines
 443  6883 C3 FF 66     	jp		ReadKeyLoop
 444  6886
 445  6886              CheckKeyDel:
 446  6886 FE 38        	cp		'8'
 447  6888 20 2E        	jr		nz, CheckKeyAttrib
 448  688A
 449  688A 3A B4 7E     	ld		a, (FileCnt)
 450  688D B7           	or		a
 451  688E CA FF 66     	jp		z, ReadKeyLoop
 452  6891
 453  6891 21 9F 7D     	ld		hl, MsgDelete
 454  6894 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 455  6897 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 456  6899 CD 58 76     	call	PrintStrClr
 457  689C CD F4 75     	call	ReadChar
 458  689F FE 79        	cp		'y'
 459  68A1 28 08        	jr		z, DoFileDelete
 460  68A3 06 01        	ld		b, 1
 461  68A5 CD DC 77     	call	ClearNMsgLines
 462  68A8 C3 FF 66     	jp		ReadKeyLoop
 463  68AB              DoFileDelete:
 464  68AB 2A BB 7E     	ld		hl, (SelFileCache)
 465  68AE 3A 8A 71     	ld 		a, (RWTSDrive)
 466  68B1 3C           	inc		a					;Convert to BASIC drive number: 1,2
 467  68B2 CD 36 72     	call	DeleteFile
 468  68B5 C3 A2 65     	jp		HCRunInitDisk
 469  68B8
 470  68B8              CheckKeyAttrib:
 471  68B8 FE 37        	cp		'7'
 472  68BA 20 44        	jr		nz, CheckKeyDiskMenu
 473  68BC
 474  68BC 3A B4 7E     	ld		a, (FileCnt)
 475  68BF B7           	or		a
 476  68C0 CA FF 66     	jp		z, ReadKeyLoop
 477  68C3
 478  68C3 21 AC 7D     	ld		hl, MsgSetRO
 479  68C6 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 480  68C9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 481  68CB CD 58 76     	call	PrintStrClr
 482  68CE CD F4 75     	call	ReadChar
 483  68D1 1E 00        	ld		e, 0
 484  68D3 FE 79        	cp		'y'
 485  68D5 20 02        	jr		nz, CheckSYS
 486  68D7 1E 01        	ld		e, 1
 487  68D9
 488  68D9              CheckSYS:
 489  68D9 D5           	push	de
 490  68DA 21 B8 7D     		ld		hl, MsgSetSYS
 491  68DD 11 00 10     		ld		de, LST_LINE_MSG + 2 << 8
 492  68E0 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 493  68E2 CD 58 76     		call	PrintStrClr
 494  68E5 CD F4 75     		call	ReadChar
 495  68E8 FE 79        		cp		'y'
 496  68EA D1           	pop		de
 497  68EB 20 04        	jr		nz, AttrChange
 498  68ED 3E 02        	ld		a, %10
 499  68EF B3           	or		e
 500  68F0 5F           	ld		e, a
 501  68F1
 502  68F1              AttrChange:
 503  68F1 2A BB 7E     	ld		hl, (SelFileCache)
 504  68F4 CD 5B 72     	call	ChangeFileAttrib
 505  68F7 C3 A2 65     	jp		HCRunInitDisk
 506  68FA
 507  68FA              SelectDrive:
 508  68FA 32 8A 71     	ld 		(RWTSDrive), a
 509  68FD C3 A2 65     	jp		HCRunInitDisk
 510  6900
 511  6900              CheckKeyDiskMenu:
 512  6900 FE 39        	cp		'9'
 513  6902 C2 DF 69     	jp		nz, CheckKeyExit
 514  6905
 515  6905 3A 8A 71     	ld		a, (RWTSDrive)
 516  6908 C6 41        	add		'A'
 517  690A              	;Update menu messages with current drive.
 518  690A 32 01 7E     	ld		(MsgMenuSingleDrv1), a
 519  690D 32 05 7E     	ld		(MsgMenuSingleDrv2), a
 520  6910 32 0F 7E     	ld		(MsgMenuDualDrv1), a
 521  6913 32 1D 7E     	ld		(MsgMenuToComDrv), a
 522  6916 32 31 7E     	ld		(MsgMenuFromCOMDrv), a
 523  6919 32 3D 7E     	ld		(MsgMenuFmtDrv), a
 524  691C 32 4A 7E     	ld		(MsgFormatDrv), a
 525  691F              	;Update menu messages with the alternate drive.
 526  691F 3A 8A 71     	ld		a, (RWTSDrive)
 527  6922 3C           	inc		a
 528  6923 EE 03        	xor		%11
 529  6925 C6 40        	add		'A'-1
 530  6927 32 13 7E     	ld		(MsgMenuDualDrv2), a
 531  692A
 532  692A 21 D4 7D     	ld		hl, MsgMenuDiskCopy
 533  692D 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 534  6930 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 535  6932 CD 58 76     	call	PrintStrClr
 536  6935 21 ED 7D     	ld		hl, MsgMenuBack
 537  6938 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 538  693B CD 30 76     	call	PrintStr
 539  693E 21 F9 7D     	ld		hl, MsgMenuSingle
 540  6941 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 541  6944 CD 30 76     	call	PrintStr
 542  6947 21 07 7E     	ld		hl, MsgMenuDual
 543  694A 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 544  694D CD 30 76     	call	PrintStr
 545  6950 21 15 7E     	ld		hl, MsgMenuToCOM
 546  6953 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 547  6956 CD 30 76     	call	PrintStr
 548  6959 21 24 7E     	ld		hl, MsgMenuFromCOM
 549  695C 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 550  695F CD 30 76     	call	PrintStr
 551  6962 21 33 7E     	ld		hl, MsgMenuFmt
 552  6965 11 00 15     	ld		de, LST_LINE_MSG + 7 << 8
 553  6968 CD 30 76     	call	PrintStr
 554  696B
 555  696B CD F4 75     	call	ReadChar
 556  696E F5           	push	af
 557  696F 06 07        		ld		b, 7
 558  6971 CD DC 77     		call	ClearNMsgLines
 559  6974 F1           	pop		af
 560  6975 32 BD 7E     	ld		(CopySelOption), a
 561  6978
 562  6978              CheckKeyDiskMenuLoop:
 563  6978 FE 30        	cp		'0'
 564  697A 28 60        	jr		z, DiskMenuExit
 565  697C
 566  697C              	;Single drive copy
 567  697C FE 31        	cp		'1'
 568  697E 20 0A        	jr		nz, CheckDiskMenuDualDrive
 569  6980 CD BA 6E     	call	CopyDisk
 570  6983 06 02        	ld		b, 2
 571  6985 CD DC 77     	call	ClearNMsgLines
 572  6988 18 52        	jr		DiskMenuExit
 573  698A
 574  698A              	;Dual drive copy
 575  698A              CheckDiskMenuDualDrive:
 576  698A FE 32        	cp		'2'
 577  698C 20 0A        	jr		nz, CheckDiskMenuToCOM
 578  698E CD BA 6E     	call	CopyDisk
 579  6991 06 02        	ld		b, 2
 580  6993 CD DC 77     	call	ClearNMsgLines
 581  6996 18 44        	jr		DiskMenuExit
 582  6998
 583  6998              CheckDiskMenuToCOM:
 584  6998 FE 33        	cp		'3'
 585  699A 20 05        	jr		nz, CheckDiskMenuFromCOM
 586  699C CD 73 6F     	call	CopyDiskToCOM
 587  699F 18 3B        	jr		DiskMenuExit
 588  69A1
 589  69A1              CheckDiskMenuFromCOM:
 590  69A1 FE 34        	cp		'4'
 591  69A3 20 06        	jr		nz, CheckDiskMenuFormat
 592  69A5 CD CF 6F     	call	CopyDiskFromCOM
 593  69A8 C3 A2 65     	jp		HCRunInitDisk
 594  69AB
 595  69AB              CheckDiskMenuFormat:
 596  69AB FE 35        	cp		'5'
 597  69AD C2 E3 65     	jp		nz, HCRunMain
 598  69B0
 599  69B0 21 3F 7E     	ld		hl, MsgFormat
 600  69B3 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 601  69B6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 602  69B8 CD 58 76     	call	PrintStrClr
 603  69BB
 604  69BB CD EA 6D     	call	FormatDisk
 605  69BE B7           	or		a
 606  69BF CA A2 65     	jp		z, HCRunInitDisk
 607  69C2
 608  69C2              	;Display error for format
 609  69C2 6F           	ld		l, a
 610  69C3 26 00        	ld		h, 0
 611  69C5 11 CB 7C     	ld		de, MsgErrCode
 612  69C8 CD 55 6D     	call	Byte2Txt
 613  69CB 21 C0 7C     	ld		hl, MsgErr
 614  69CE 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 615  69D1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 616  69D3 CD 58 76     	call	PrintStrClr
 617  69D6 CD F4 75     	call	ReadChar
 618  69D9 C3 A2 65     	jp		HCRunInitDisk
 619  69DC
 620  69DC              DiskMenuExit:
 621  69DC C3 FF 66     	jp		ReadKeyLoop
 622  69DF
 623  69DF              CheckKeyExit:
 624  69DF FE 30        	cp		'0'
 625  69E1 C2 FF 66     	jp		nz, ReadKeyLoop
 626  69E4              	;jp		HCRunEnd
 627  69E4 C3 00 00     	jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 628  69E7
 629  69E7              MoveIt:
 630  69E7 CD 24 77     	call 	MoveCursor
 631  69EA C3 FF 66     	jp		ReadKeyLoop
 632  69ED
 633  69ED              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 634  69ED
 635  69ED
 636  69ED              DisplayFilename:
 637  69ED 06 0B        	LD		B, NAMELEN
 638  69EF              DispLoop:
 639  69EF 1A           	LD		A, (DE)
 640  69F0
 641  69F0              	;clear bit 7
 642  69F0 CB BF        	RES 	7, A
 643  69F2 32 81 5C     	LD		(CODE), A
 644  69F5
 645  69F5 13           	INC		DE
 646  69F6 D5           	PUSH	DE
 647  69F7 C5           	PUSH	BC
 648  69F8 CD 5C 77     		CALL	PrintChar
 649  69FB C1           	POP		BC
 650  69FC D1           	POP 	DE
 651  69FD
 652  69FD 21 B0 5C     	LD		HL, COL
 653  6A00 34           	INC		(HL)
 654  6A01 10 EC        	DJNZ	DispLoop
 655  6A03              	;now a name is displayed
 656  6A03
 657  6A03              	;check bounds
 658  6A03 3A B1 5C     	LD		A, (LINE)
 659  6A06 3C           	INC		A
 660  6A07 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 661  6A09 38 0A        	JR		C, LineOK
 662  6A0B
 663  6A0B              	;set names column to the next one
 664  6A0B 3A B5 7E     	LD		A, (NameCol)
 665  6A0E C6 0C        	ADD		NAMELEN + 1
 666  6A10 32 B5 7E     	LD		(NameCol), A
 667  6A13
 668  6A13 3E 01        	LD		A, LST_FIRST_LINE
 669  6A15              LineOK:
 670  6A15 32 B1 5C     	LD		(LINE), A
 671  6A18
 672  6A18 3A B5 7E     	LD		A, (NameCol)
 673  6A1B 32 B0 5C     	LD		(COL), A
 674  6A1E
 675  6A1E C9           	RET
 676  6A1F
 677  6A1F
 678  6A1F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 679  6A1F
 680  6A1F              DisplayFilenames:
 681  6A1F 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 682  6A22 ED 53 B0 5C  	ld		(LineCol), de
 683  6A26
 684  6A26 11 E0 7E     	ld		de, FileCache
 685  6A29 3A B4 7E     	ld		a, (FileCnt)
 686  6A2C B7           	or		a
 687  6A2D C8           	ret		z
 688  6A2E
 689  6A2E 47           	ld		b,	a
 690  6A2F
 691  6A2F              DisplayFilenamesLoop:
 692  6A2F C5           	push	bc
 693  6A30 D5           		push	de
 694  6A31 CD ED 69     			call	DisplayFilename
 695  6A34 D1           		pop		de
 696  6A35 EB           		ex		de, hl
 697  6A36 01 19 00     		ld		bc, CACHE_SZ
 698  6A39 09           		add		hl, bc
 699  6A3A EB           		ex		de, hl
 700  6A3B C1           	pop		bc
 701  6A3C 10 F1        	djnz	DisplayFilenamesLoop
 702  6A3E
 703  6A3E C9           	ret
 704  6A3F
 705  6A3F
 706  6A3F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707  6A3F              ;Selects only valid filenames (not deleted and only from first extension)
 708  6A3F              GetFileNames:
 709  6A3F DD 21 FE 8C  	ld		ix, TrackBuf
 710  6A43 11 E0 7E     	ld		de, FileCache
 711  6A46 06 80        	ld		b, MAX_EXT_CNT
 712  6A48 AF           	xor		a
 713  6A49 32 B4 7E     	ld		(FileCnt), a
 714  6A4C 21 B9 7E     	ld		hl, AUCnt
 715  6A4F 77           	ld		(hl), a
 716  6A50 23           	inc		hl
 717  6A51 77           	ld		(hl), a
 718  6A52
 719  6A52              StoreFilenamesLoop:
 720  6A52 AF           	xor a
 721  6A53 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 722  6A56 C2 CA 6A     	jp nz, NextExt
 723  6A59
 724  6A59              	;count AU
 725  6A59 D9           	exx
 726  6A5A E5           	push hl
 727  6A5B CD 19 6E     		call CheckExtAlloc
 728  6A5E EB           		ex de, hl			;save first AU no.
 729  6A5F
 730  6A5F              		;store disk alocated AU count
 731  6A5F 2A B9 7E     		ld hl, (AUCnt)
 732  6A62 48           		ld c, b
 733  6A63 06 00        		ld b, 0
 734  6A65 09           		add hl, bc
 735  6A66 22 B9 7E     		ld (AUCnt), hl
 736  6A69 E1           	pop hl
 737  6A6A D9           	exx
 738  6A6B
 739  6A6B AF           	xor	a
 740  6A6C DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 741  6A6F 20 32        	jr nz, FindExt
 742  6A71
 743  6A71 DD E5        	push ix
 744  6A73 E1           	pop hl
 745  6A74 23           	inc hl					;skip del flag
 746  6A75
 747  6A75 C5           	push bc
 748  6A76 ~            		/*
 749  6A76 ~            		push de
 750  6A76 ~            			push hl
 751  6A76 ~            				ex de, hl
 752  6A76 ~            				call DisplayFilename
 753  6A76 ~            			pop hl
 754  6A76 ~            		pop de
 755  6A76 ~            		*/
 756  6A76 01 0B 00     		ld bc, NAMELEN
 757  6A79 ED B0        		ldir				;save file name
 758  6A7B
 759  6A7B D9           		exx
 760  6A7C D5           		push 	de			;de = first AU
 761  6A7D D9           		exx
 762  6A7E E1           		pop		hl
 763  6A7F EB           		ex		de, hl
 764  6A80 73 23 72 2B  		ld		(hl), de	;save first AU
 765  6A84
 766  6A84 23           		inc		hl
 767  6A85 23           		inc		hl
 768  6A86
 769  6A86 D9           		exx					;save AU cnt for file
 770  6A87 C5           		push	bc
 771  6A88 D9           		exx
 772  6A89 C1           		pop		bc
 773  6A8A 71 23 70 2B  		ld		(hl), bc
 774  6A8E
 775  6A8E 23           		inc		hl
 776  6A8F 23           		inc		hl
 777  6A90
 778  6A90              		;xor		a			;make flag 0 to signal that header is not read yet
 779  6A90              		;ld		(hl), a
 780  6A90
 781  6A90 01 0A 00     		ld		bc, HDR_SZ + 1
 782  6A93 09           		add		hl, bc
 783  6A94
 784  6A94 EB           		ex		de, hl
 785  6A95 C1           	pop bc
 786  6A96
 787  6A96
 788  6A96 3A B4 7E     	ld 		a, (FileCnt)			;inc file counter
 789  6A99 3C           	inc		a
 790  6A9A 32 B4 7E     	ld 		(FileCnt), a
 791  6A9D FE 54        	cp		LST_MAX_FILES
 792  6A9F 38 29        	jr		c, NextExt
 793  6AA1 18 34        	jr		GetFileNamesEnd
 794  6AA3
 795  6AA3
 796  6AA3              FindExt:					;BC' = AU cnt for this ext
 797  6AA3 C5           	push	bc
 798  6AA4 D5           		push 	de
 799  6AA5 DD E5        			push	ix
 800  6AA7 D1           			pop		de
 801  6AA8 13           			inc		de				;DE = name to find
 802  6AA9
 803  6AA9 21 E0 7E     			ld		hl, FileCache
 804  6AAC 3A B4 7E     			ld		a, (FileCnt)
 805  6AAF 4F           			ld		c, a
 806  6AB0 CD C7 70     			call	FindCache
 807  6AB3 20 13        			jr		nz, FindExtEnd
 808  6AB5
 809  6AB5 01 0D 00     			ld		bc, CACHE_AU_CNT
 810  6AB8 09           			add		hl, bc
 811  6AB9 D9           			exx
 812  6ABA C5           			push	bc
 813  6ABB D9           			exx
 814  6ABC C1           			pop		bc
 815  6ABD
 816  6ABD 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 817  6AC1 EB           			ex		de, hl
 818  6AC2 09           			add		hl, bc
 819  6AC3 EB           			ex		de, hl
 820  6AC4 73 23 72 2B  			ld		(hl), de
 821  6AC8              FindExtEnd:
 822  6AC8 D1           		pop		de
 823  6AC9 C1           	pop		bc
 824  6ACA
 825  6ACA              NextExt:
 826  6ACA C5           	push bc
 827  6ACB 01 20 00     		ld bc, EXT_SZ
 828  6ACE DD 09        		add ix, bc
 829  6AD0 C1           	pop	bc
 830  6AD1
 831  6AD1 05           	dec	b
 832  6AD2 78           	ld	a, b
 833  6AD3 B7           	or	a
 834  6AD4 C2 52 6A     	jp	nz, StoreFilenamesLoop
 835  6AD7              GetFileNamesEnd:
 836  6AD7 C9           	ret
 837  6AD8
 838  6AD8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 839  6AD8
 840  6AD8              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 841  6AD8              ;IN: HL = file name
 842  6AD8              HandleFile:
 843  6AD8              	;Make HL point to the selected file
 844  6AD8 DD 2A BB 7E  	ld		ix, (SelFileCache)
 845  6ADC DD E5        	push	ix
 846  6ADE DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 847  6AE1 B7           		or		a
 848  6AE2 CC D8 70     		call	z, ReadFileHeader
 849  6AE5
 850  6AE5 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 851  6AE8 FE 00        		cp		PROG_TYPE
 852  6AEA 28 56        		jr		z, HandleFileProg
 853  6AEC
 854  6AEC FE 03        		cp		BYTE_TYPE
 855  6AEE 20 62        		jr		nz, HandleFileText
 856  6AF0
 857  6AF0 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 857  6AF4 66 12
 858  6AF6 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 859  6AF9 19           		add		hl, de
 860  6AFA 7C           		ld		a, h
 861  6AFB B5           		or		l
 862  6AFC 28 26        		jr		z, HandleFileSCR
 863  6AFE
 864  6AFE
 865  6AFE              HandleFileCODE:
 866  6AFE 21 ED 7C     		ld		hl, MsgLoadingCODE
 867  6B01 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 868  6B04 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 869  6B06 CD 58 76     		call	PrintStrClr
 870  6B09
 871  6B09              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 872  6B09 21 42 70     		ld		hl, IF1FileLoad
 873  6B0C 11 00 5B     		ld		de, PRN_BUF
 874  6B0F 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 875  6B12 ED B0        		ldir
 876  6B14              		;ld		a, $C9
 877  6B14              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 878  6B14
 879  6B14 E1           	pop		hl
 880  6B15 ED 5B 01 8D  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 881  6B19 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 882  6B1A C1           	pop		bc						;2nd, 3rd call for error handler
 883  6B1B C1           	pop		bc
 884  6B1C ED 43 3D 5C  	ld		(ERRSP), bc
 885  6B20 D5           	push	de						;push CODE address to return to = start of CODE block
 886  6B21 C3 00 5B     	jp		PRN_BUF
 887  6B24
 888  6B24
 889  6B24
 890  6B24
 891  6B24              HandleFileSCR:
 892  6B24 21 DE 7C     		ld		hl, MsgLoadingSCR
 893  6B27 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 894  6B2A 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 895  6B2C CD 58 76     		call	PrintStrClr
 896  6B2F
 897  6B2F E1           	pop		hl
 898  6B30
 899  6B30              	IFDEF _REAL_HW_
 900  6B30              		;Load to alternate SCREEN$ memory
 901  6B30 11 00 C0     		ld		de, HC_VID_BANK1
 902  6B33 CD 42 70     		call	IF1FileLoad
 903  6B36
 904  6B36              		;Set display to alternate SCREEN$ memory
 905  6B36 3E 08        		ld		a, HC_CFG_VID_C000
 906  6B38 D3 7E        		out 	(HC_CFG_PORT), a
 907  6B3A CD F4 75     		call	ReadChar
 908  6B3D
 909  6B3D              		;Set back to regular SCREEN$ memory
 910  6B3D 3E 00        		ld		a, HC_CFG_VID_4000
 911  6B3F D3 7E        		out 	(HC_CFG_PORT), a
 912  6B41              	ELSE
 913  6B41 ~            		ld		de, HC_VID_BANK0
 914  6B41 ~            		call	IF1FileLoad
 915  6B41 ~            		call	ReadChar
 916  6B41              	ENDIF
 917  6B41
 918  6B41 C9           	ret
 919  6B42
 920  6B42              HandleFileProg:
 921  6B42 21 CF 7C     		ld		hl, MsgLoadingPrg
 922  6B45 11 00 0F     		ld		de, LST_LINE_MSG+1 << 8
 923  6B48 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 924  6B4A CD 58 76     		call	PrintStrClr
 925  6B4D E1           	pop		hl
 926  6B4E CD 3F 71     	call	LoadProgram
 927  6B51 C9           	ret
 928  6B52
 929  6B52
 930  6B52              HandleFileText:
 931  6B52 E1           	pop		hl
 932  6B53
 933  6B53
 934  6B53              ViewFile:
 935  6B53 CD 10 76     	call	ClrScr
 936  6B56 21 00 00     	ld		hl, 0
 937  6B59 22 C3 7E     	ld		(FilePosRead), hl
 938  6B5C              ViewFileLoop:
 939  6B5C 2A BB 7E     	ld		hl, (SelFileCache)
 940  6B5F 3A 8A 71     	ld 		a, (RWTSDrive)
 941  6B62 3C           	inc		a
 942  6B63 CD 41 75     	call	ReadFileSection					;DE = last address read
 943  6B66 21 FE 8C     	ld		hl, FileData
 944  6B69              	;Calculate size of read buffer
 945  6B69 E5           	push	hl
 946  6B6A EB           		ex	de, hl
 947  6B6B B7           		or	a
 948  6B6C ED 52        		sbc	hl, de
 949  6B6E 44           		ld	b, h
 950  6B6F 4B           		ld	c, e
 951  6B70 E1           	pop		hl
 952  6B71 CD F3 77     	call	InitViewer
 953  6B74 CD 51 78     	call	PrintLoop
 954  6B77              	;Check if exited viewer because user wanted to.
 955  6B77 C8           	ret		z
 956  6B78
 957  6B78              	;Check if file ended -> we need to load the next file segment.
 958  6B78 3A C0 7E     	ld		a, (CopyFileRes)
 959  6B7B B7           	or		a
 960  6B7C 28 DE        	jr		z, ViewFileLoop
 961  6B7E C3 8C 78     	jp		PrintLoop2
 962  6B81 C9           	ret
 963  6B82
 964  6B82              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 965  6B82
 966  6B82
 967  6B82              DisplayFileInfo:
 968  6B82 2A BB 7E     	ld		hl, (SelFileCache)
 969  6B85 E5           	push	hl
 970  6B86              		;disk size - at least 2KB ==1  AU
 971  6B86 01 0D 00     		ld		bc, CACHE_AU_CNT
 972  6B89 09           		add		hl, bc
 973  6B8A 5E 23 56 2B  		ld		de, (hl)
 974  6B8E EB           		ex		de, hl
 975  6B8F              		;*2, since one block (AU) is 2KB.
 976  6B8F CB 15        		rl	l
 977  6B91 CB 14        		rl	h
 978  6B93
 979  6B93 11 06 7D     		ld		de, MsgFileSzDskN
 980  6B96 CD 4A 6D     		call	Word2Txt
 981  6B99 21 FD 7C     		ld		hl, MsgFileSzDsk
 982  6B9C 11 00 09     		ld		de, LST_FILE_INFO + 1 << 8
 983  6B9F CD 30 76     		call	PrintStr
 984  6BA2 E1           	pop		hl
 985  6BA3 E5           	push	hl
 986  6BA4              		;attributes
 987  6BA4 01 08 00     		ld		bc, CACHE_NAME + RO_POS
 988  6BA7 09           		add		hl, bc
 989  6BA8 EB           		ex		de, hl
 990  6BA9 21 16 7D     		ld		hl, MsgFileAttrN
 991  6BAC 1A           		ld		a, (de)
 992  6BAD E6 80        		and		%10000000
 993  6BAF 28 14        		jr		z, NotRO
 994  6BB1
 995  6BB1 01 52 2F     		ld		bc, '/R'
 996  6BB4 71 23 70 2B  		ld		(hl), bc
 997  6BB8 23           		inc		hl
 998  6BB9 23           		inc		hl
 999  6BBA 01 4F 2C     		ld		bc, ',O'
1000  6BBD 71 23 70 2B  		ld		(hl), bc
1001  6BC1 23           		inc		hl
1002  6BC2 23           		inc		hl
1003  6BC3 18 12        		jr		CheckSys
1004  6BC5              NotRO:
1005  6BC5 01 2D 2D     		ld		bc, '--'
1006  6BC8 71 23 70 2B  		ld		(hl), bc
1007  6BCC 23           		inc		hl
1008  6BCD 23           		inc		hl
1009  6BCE 01 2D 2C     		ld		bc, ',-'
1010  6BD1 71 23 70 2B  		ld		(hl), bc
1011  6BD5 23           		inc		hl
1012  6BD6 23           		inc		hl
1013  6BD7
1014  6BD7              CheckSys:
1015  6BD7 13           		inc		de
1016  6BD8 1A           		ld		a, (de)
1017  6BD9 E6 80        		and		%10000000
1018  6BDB 28 0E        		jr		z, NotSYS
1019  6BDD
1020  6BDD 01 48 49     		ld		bc, 'IH'
1021  6BE0 71 23 70 2B  		ld		(hl), bc
1022  6BE4 23           		inc		hl
1023  6BE5 23           		inc		hl
1024  6BE6 3E C4        		ld		a, 'D' + $80
1025  6BE8 77           		ld		(hl), a
1026  6BE9 18 0C        		jr		AttrEnd
1027  6BEB              NotSYS:
1028  6BEB 01 2D 2D     		ld		bc, '--'
1029  6BEE 71 23 70 2B  		ld		(hl), bc
1030  6BF2 23           		inc		hl
1031  6BF3 23           		inc		hl
1032  6BF4 3E AD        		ld		a, '-' + $80
1033  6BF6 77           		ld		(hl), a
1034  6BF7              AttrEnd:
1035  6BF7 11 00 0A     		ld		de, LST_FILE_INFO + 2 << 8
1036  6BFA 21 0D 7D     		ld		hl, MsgFileAttr
1037  6BFD CD 30 76     		call	PrintStr
1038  6C00 DD E1        	pop		ix
1039  6C02 DD E5        	push	ix
1040  6C04 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1041  6C07 B7           		or		a
1042  6C08 CA A5 6C             jp		z, HeadNotRead
1043  6C0B
1044  6C0B DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1045  6C0E DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1046  6C11 CA A5 6C             jp		z, HeadNotRead
1047  6C14
1048  6C14 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1049  6C17 FE 00        		cp		PROG_TYPE
1050  6C19 20 0B        		jr		nz, CheckNoArr
1051  6C1B
1052  6C1B 21 30 7D     		ld		hl, MsgFileTypePrg
1053  6C1E 11 26 7D     		ld		de, MsgFileTypeN
1054  6C21 CD EE 6C     		call	MoveMsg
1055  6C24 18 4F        		jr		PrepFileLen
1056  6C26
1057  6C26              CheckNoArr:
1058  6C26 FE 01        		cp		NUMB_TYPE
1059  6C28 20 0B        		jr		nz, CheckChrArr
1060  6C2A
1061  6C2A 21 4C 7D     		ld		hl, MsgFileTypeNoA
1062  6C2D 11 26 7D     		ld		de, MsgFileTypeN
1063  6C30 CD EE 6C     		call	MoveMsg
1064  6C33 18 40        		jr		PrepFileLen
1065  6C35
1066  6C35              CheckChrArr:
1067  6C35 FE 02        		cp		CHAR_TYPE
1068  6C37 20 0B        		jr		nz, CheckByte
1069  6C39
1070  6C39 21 45 7D     		ld		hl, MsgFileTypeChrA
1071  6C3C 11 26 7D     		ld		de, MsgFileTypeN
1072  6C3F CD EE 6C     		call	MoveMsg
1073  6C42 18 31        		jr		PrepFileLen
1074  6C44
1075  6C44              CheckByte:
1076  6C44 FE 03        		cp		BYTE_TYPE
1077  6C46 20 24        		jr		nz, CheckText
1078  6C48
1079  6C48 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1079  6C4C 66 12
1080  6C4E 01 00 E5     		ld		bc, -SCR_LEN
1081  6C51 09           		add		hl, bc
1082  6C52 7C           		ld		a, h
1083  6C53 B5           		or		l
1084  6C54 20 0B        		jr		nz, NotScr
1085  6C56
1086  6C56 21 3E 7D     		ld		hl, MsgFileTypeSCR
1087  6C59 11 26 7D     		ld		de, MsgFileTypeN
1088  6C5C CD EE 6C     		call	MoveMsg
1089  6C5F 18 14        		jr		PrepFileLen
1090  6C61              NotScr:
1091  6C61 21 37 7D     		ld		hl, MsgFileTypeByte
1092  6C64 11 26 7D     		ld		de, MsgFileTypeN
1093  6C67 CD EE 6C     		call	MoveMsg
1094  6C6A 18 09        		jr		PrepFileLen
1095  6C6C
1096  6C6C              CheckText:
1097  6C6C 21 53 7D     		ld		hl, MsgFileTypeText
1098  6C6F 11 26 7D     		ld		de, MsgFileTypeN
1099  6C72 CD EE 6C     		call	MoveMsg
1100  6C75
1101  6C75              PrepFileLen:
1102  6C75              		;File len
1103  6C75 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1104  6C78 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1105  6C7B              PrepFileLenText:
1106  6C7B 11 6A 7D     		ld		de, MsgFileLenN
1107  6C7E CD 4A 6D     		call	Word2Txt
1108  6C81 26 C2        		ld		h, 'B' | $80
1109  6C83 2E 20        		ld		l, ' '
1110  6C85 22 6F 7D     		ld		(MsgFileLenN + 5), hl
1111  6C88
1112  6C88 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1113  6C8B FE 00        		cp		PROG_TYPE
1114  6C8D 28 06        		jr		z, PrintProgStart
1115  6C8F
1116  6C8F FE 03        		cp		BYTE_TYPE
1117  6C91 28 0A        		jr		z, PrintByteStart
1118  6C93
1119  6C93 18 22        		jr		PrintStartNotRead
1120  6C95
1121  6C95              PrintProgStart:
1122  6C95 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1123  6C98 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1124  6C9B 18 25        		jr		PrintStart
1125  6C9D
1126  6C9D              PrintByteStart:
1127  6C9D DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1128  6CA0 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1129  6CA3 18 1D        		jr		PrintStart
1130  6CA5
1131  6CA5              HeadNotRead:
1132  6CA5 21 5A 7D             ld        hl, MsgNA
1133  6CA8 11 26 7D             ld        de, MsgFileTypeN
1134  6CAB CD EE 6C             call    MoveMsg
1135  6CAE
1136  6CAE 21 5A 7D     		ld		hl, MsgNA
1137  6CB1 11 6A 7D     		ld		de, MsgFileLenN
1138  6CB4 CD EE 6C     		call	MoveMsg
1139  6CB7
1140  6CB7              PrintStartNotRead:
1141  6CB7 21 5A 7D     		ld		hl, MsgNA
1142  6CBA 11 7A 7D     		ld		de, MsgFileStartN
1143  6CBD CD EE 6C     		call	MoveMsg
1144  6CC0 18 0E        		jr		PrintStartStr
1145  6CC2
1146  6CC2              PrintStart:
1147  6CC2 1E 20        	ld		e, ' '
1148  6CC4 16 A0        	ld		d, ' ' | $80
1149  6CC6 ED 53 7F 7D  	ld		(MsgFileStartN + 5), de
1150  6CCA 11 7A 7D     	ld		de, MsgFileStartN
1151  6CCD CD 4A 6D     	call	Word2Txt
1152  6CD0              PrintStartStr:
1153  6CD0 11 00 0C     	ld		de, LST_FILE_INFO + 4 << 8
1154  6CD3 21 71 7D     	ld		hl, MsgFileStart
1155  6CD6 CD 30 76     	call	PrintStr
1156  6CD9
1157  6CD9 DD E1        	pop		ix
1158  6CDB 11 00 0B     	ld		de, LST_FILE_INFO + 3 << 8
1159  6CDE 21 1D 7D     	ld		hl, MsgFileType
1160  6CE1 CD 30 76     	call	PrintStr
1161  6CE4
1162  6CE4 11 00 0D     	ld		de, LST_FILE_INFO + 5 << 8
1163  6CE7 21 61 7D     	ld		hl, MsgFileLen
1164  6CEA CD 30 76     	call	PrintStr
1165  6CED
1166  6CED C9           	ret
1167  6CEE
1168  6CEE              MoveMsg:
1169  6CEE 01 07 00     	ld		bc, 7
1170  6CF1 ED B0        	ldir
1171  6CF3 C9           	ret
1172  6CF4
1173  6CF4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1174  6CF4
1175  6CF4              ReadAllHeaders:
1176  6CF4 21 81 7D     	ld		hl, MsgReadingExt
1177  6CF7 11 00 0F     	ld		de, LST_LINE_MSG+1 << 8
1178  6CFA 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1179  6CFC CD 58 76     	call	PrintStrClr
1180  6CFF
1181  6CFF CD EE 66     	call	CalcFileCache
1182  6D02
1183  6D02 3A B6 7E     	ld		a, (SelFile)
1184  6D05 47           	ld		b, a
1185  6D06 3A B4 7E     	ld		a, (FileCnt)
1186  6D09 90           	sub		b
1187  6D0A B7           	or		a
1188  6D0B C8           	ret		z
1189  6D0C
1190  6D0C 47           	ld		b, a
1191  6D0D
1192  6D0D DD 2A BB 7E  	ld		ix, (SelFileCache)
1193  6D11              NextFile:
1194  6D11 C5           	push	bc
1195  6D12 CD D8 70     		call	ReadFileHeader
1196  6D15 01 19 00     		ld		bc, CACHE_SZ
1197  6D18 DD 09        		add		ix, bc
1198  6D1A DD E5        		push	ix
1199  6D1C CD EE 66     			call	CalcFileCache
1200  6D1F CD 82 6B     			call	DisplayFileInfo
1201  6D22 DD E1        		pop		ix
1202  6D24
1203  6D24 CD F7 75     		call	KbdHit
1204  6D27 38 03        		jr		c, AKey
1205  6D29 C1           	pop		bc
1206  6D2A 18 15        	jr		ReadAllHeadersEnd
1207  6D2C
1208  6D2C              AKey:
1209  6D2C 3A B6 7E     		ld		a, (SelFile)
1210  6D2F 3C           		inc		a
1211  6D30 47           		ld		b, a
1212  6D31 3A B4 7E     		ld		a, (FileCnt)
1213  6D34 B8           		cp		b
1214  6D35 28 10        		jr		z, DontInc
1215  6D37 78           		ld		a, b
1216  6D38 32 B6 7E     		ld		(SelFile), a
1217  6D3B CD 24 77     		call	MoveCursor
1218  6D3E C1           	pop		bc
1219  6D3F 10 D0        	djnz	NextFile
1220  6D41
1221  6D41              ReadAllHeadersEnd:
1222  6D41 06 01        	ld		b, 1
1223  6D43 CD DC 77     	call	ClearNMsgLines
1224  6D46 C9           	ret
1225  6D47
1226  6D47              DontInc:
1227  6D47 C1           	pop		bc
1228  6D48 18 F7        	jr		ReadAllHeadersEnd
1229  6D4A
1230  6D4A
1231  6D4A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1232  6D4A
1233  6D4A              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6D4A              	ifndef	_HCCFG_
   2+ 6D4A              	define	_HCCFG_
   3+ 6D4A
   4+ 6D4A              ;HC specific code, for configuration
   5+ 6D4A
   6+ 6D4A              HC_CFG_PORT			EQU	$7E
   7+ 6D4A
   8+ 6D4A              ;BASIC/CPM ROM selection
   9+ 6D4A              HC_CFG_ROM_BAS		EQU	%0
  10+ 6D4A              HC_CFG_ROM_CPM		EQU	%1
  11+ 6D4A
  12+ 6D4A              ;Address for ROM paging: 0 or $E000
  13+ 6D4A              HC_CFG_ROM_0000		EQU %00
  14+ 6D4A              HC_CFG_ROM_E000		EQU %10
  15+ 6D4A
  16+ 6D4A              ;Cfg. port Enable/Disable
  17+ 6D4A              HC_CFG_PORT_DIS		EQU %000
  18+ 6D4A              HC_CFG_PORT_EN		EQU	%100
  19+ 6D4A
  20+ 6D4A              ;Video memory bank: $4000 or $C000
  21+ 6D4A              HC_CFG_VID_4000		EQU	%0000
  22+ 6D4A              HC_CFG_VID_C000		EQU	%1000
  23+ 6D4A
  24+ 6D4A
  25+ 6D4A              ;Standar BASIC config
  26+ 6D4A              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27+ 6D4A              ;Standar CP/M config
  28+ 6D4A              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29+ 6D4A
  30+ 6D4A
  31+ 6D4A              HC_VID_BANK0		EQU	$4000
  32+ 6D4A              HC_VID_BANK1		EQU	$C000
  33+ 6D4A
  34+ 6D4A              	endif
# file closed: hccfg.asm
1234  6D4A              	include "if1.asm"
# file opened: if1.asm
   1+ 6D4A              ;HC IF1 routines and constants
   2+ 6D4A
   3+ 6D4A              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6D4A              ;12 = Writing to a 'read' file
   5+ 6D4A              ;13 = Reading a 'write' file
   6+ 6D4A              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6D4A              ;15 = Disk full (disk or catalog full)
   8+ 6D4A              ;16 = Disk error (hardware error)
   9+ 6D4A              ;17 = File not found
  10+ 6D4A              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6D4A              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6D4A
  13+ 6D4A              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6D4A              ;00h = OK
  15+ 6D4A              ;08h = cannot format disk
  16+ 6D4A              ;10h = disk protected (read-only?)
  17+ 6D4A              ;20h = volume error
  18+ 6D4A              ;40h = drive error
  19+ 6D4A              ;80h = reading error
  20+ 6D4A              ;Codes I encountered:
  21+ 6D4A              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6D4A
  23+ 6D4A
  24+ 6D4A              	ifndef	_DISK_
  25+ 6D4A              	define	_DISK_
  26+ 6D4A
  27+ 6D4A              	include	"math.asm"
# file opened: math.asm
   1++6D4A              	ifndef	_MATH_
   2++6D4A              	define	_MATH_
   3++6D4A
   4++6D4A              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6D4A              ;http://map.tni.nl/sources/external/z80bits.html
   6++6D4A
   7++6D4A
   8++6D4A              Word2Txt:
   9++6D4A              	IFUSED
  10++6D4A D5           	push	de
  11++6D4B CD 6B 6D     		call	Word2Txt_
  12++6D4E D1           	pop		de
  13++6D4F
  14++6D4F 06 04        	ld		b, 4
  15++6D51 CD 60 6D     	call	StrippLeading0
  16++6D54 C9           	ret
  17++6D55
  18++6D55              Byte2Txt:
  19++6D55 D5           	push	de
  20++6D56 CD 77 6D     		call	Byte2Txt_
  21++6D59 D1           	pop		de
  22++6D5A
  23++6D5A 06 02        	ld		b, 2
  24++6D5C CD 60 6D     	call	StrippLeading0
  25++6D5F C9           	ret
  26++6D60              	ENDIF
  27++6D60
  28++6D60
  29++6D60              StrippLeading0:
  30++6D60 1A           	ld		a, (de)
  31++6D61 FE 31        	cp		'1'
  32++6D63 D0           	ret		nc
  33++6D64
  34++6D64 3E 20        	ld		a, ' '
  35++6D66 12           	ld		(de), a
  36++6D67 13           	inc		de
  37++6D68 10 F6        	djnz	StrippLeading0
  38++6D6A C9           	ret
  39++6D6B
  40++6D6B
  41++6D6B              ;Converts the number in HL to ASCII in decimal string at DE
  42++6D6B              Word2Txt_:
  43++6D6B 01 F0 D8     	ld bc, -10000
  44++6D6E CD 86 6D     	call DigitLoop
  45++6D71 01 18 FC     	ld bc, -1000
  46++6D74 CD 86 6D     	call DigitLoop
  47++6D77              Byte2Txt_:
  48++6D77 01 9C FF     	ld bc, -100
  49++6D7A CD 86 6D     	call DigitLoop
  50++6D7D 01 F6 FF     	ld bc, -10
  51++6D80 CD 86 6D     	call DigitLoop
  52++6D83 01 FF FF     	ld bc, -1
  53++6D86
  54++6D86              DigitLoop:
  55++6D86 3E 2F        	ld	a, '0' - 1
  56++6D88              DivNrLoop:
  57++6D88 3C           	inc	a			;increase reminder
  58++6D89 09           	add	hl, bc		;substract divizor
  59++6D8A 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6D8C ED 42        	sbc	hl, bc		;nope, restore
  61++6D8E
  62++6D8E 12           	ld (de), a
  63++6D8F 13           	inc de
  64++6D90 C9           	ret
  65++6D91
  66++6D91
  67++6D91              ;Input: HL = Dividend, C = Divisor
  68++6D91              ;Output: HL = Quotient, A = Remainder
  69++6D91              ;Warning: doesn't work with divisor >= $80
  70++6D91              Div:
  71++6D91              	IFUSED
  72++6D91 AF           	xor a
  73++6D92 06 10        	ld b, 16
  74++6D94
  75++6D94              DivLoop:
  76++6D94 29           	add	hl,hl
  77++6D95 17           	rla
  78++6D96 B9           	cp	c
  79++6D97 38 02        	jr	c, NoSub
  80++6D99 91           	sub	c
  81++6D9A 2C           	inc	l
  82++6D9B              NoSub:
  83++6D9B 10 F7        	djnz DivLoop
  84++6D9D
  85++6D9D C9           	ret
  86++6D9E              	ENDIF
  87++6D9E
  88++6D9E              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6D9E              ;Output: A:C = Quotient, HL = Remainder
  90++6D9E              Div2:
  91++6D9E 21 00 00     	ld hl, 0
  92++6DA1 06 10        	ld b, 16
  93++6DA3              Div2Loop:
  94++6DA3 CB 31        	sll c		; unroll 16 times
  95++6DA5 17           	rla			; ...
  96++6DA6 ED 6A        	adc	hl,hl		; ...
  97++6DA8 ED 52        	sbc	hl,de		; ...
  98++6DAA 30 02        	jr	nc,$+4		; ...
  99++6DAC 19           	add	hl,de		; ...
 100++6DAD 0D           	dec	c		; ...
 101++6DAE 10 F3        	djnz Div2Loop
 102++6DB0 C9           	ret
 103++6DB1
 104++6DB1
 105++6DB1              ;Input: A = Multiplier, DE = Multiplicand
 106++6DB1              ;Output: A:HL = Product
 107++6DB1              Mul:
 108++6DB1              	IFUSED
 109++6DB1 21 00 00     	ld hl, 0
 110++6DB4 01 00 07     	ld bc, $0700
 111++6DB7
 112++6DB7 87           	add	a, a		; optimised 1st iteration
 113++6DB8 30 02        	jr	nc, MulLoop
 114++6DBA 62           	ld	h, d
 115++6DBB 6B           	ld	l, e
 116++6DBC
 117++6DBC              MulLoop:
 118++6DBC 29           	add	hl,hl
 119++6DBD 17           	rla
 120++6DBE 30 02        	jr	nc, NoAdd
 121++6DC0 19           	add	hl,de
 122++6DC1 89           	adc	a,c
 123++6DC2              NoAdd:
 124++6DC2 10 F8        	djnz MulLoop
 125++6DC4
 126++6DC4 C9           	ret
 127++6DC5              	ENDIF
 128++6DC5
 129++6DC5              	endif
# file closed: math.asm
  28+ 6DC5
  29+ 6DC5              DRIVE_CUR_BAS	EQU 0
  30+ 6DC5              DRIVE_A_BAS		EQU	1
  31+ 6DC5              DRIVE_B_BAS		EQU	2
  32+ 6DC5              DRIVE_A_CPM		EQU	0
  33+ 6DC5              DRIVE_B_CPM		EQU	1
  34+ 6DC5              ;Disk geometry stuff
  35+ 6DC5              SPT				EQU	16			;sectors per track
  36+ 6DC5              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6DC5              TRACK_CNT		EQU	80			;track count
  38+ 6DC5              HEAD_CNT		EQU	2			;disk face count
  39+ 6DC5              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6DC5              EXT_SZ			EQU	32			;directory entry size
  41+ 6DC5              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6DC5              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6DC5              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6DC5              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6DC5              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6DC5              REC_SZ			EQU 128			;cp/m record size
  47+ 6DC5              DEL_MARKER		EQU	$E5
  48+ 6DC5
  49+ 6DC5
  50+ 6DC5              ;Extension structure (directory entry)
  51+ 6DC5              EXT_DEL_FLAG	EQU	0
  52+ 6DC5              EXT_NAME		EQU 1
  53+ 6DC5              EXT_IDX			EQU 12
  54+ 6DC5              EXT_S1			EQU 13
  55+ 6DC5              EXT_S2			EQU 14
  56+ 6DC5              EXT_RC			EQU	15
  57+ 6DC5              EXT_AU0			EQU	16
  58+ 6DC5              EXT_AU1			EQU	18
  59+ 6DC5              EXT_AU2			EQU	20
  60+ 6DC5              EXT_AU3			EQU	22
  61+ 6DC5              EXT_AU4			EQU	24
  62+ 6DC5              EXT_AU5			EQU	26
  63+ 6DC5              EXT_AU6			EQU	28
  64+ 6DC5              EXT_AU7			EQU	30
  65+ 6DC5              EXT_SIZE		EQU 32
  66+ 6DC5
  67+ 6DC5              ;FCB structure
  68+ 6DC5              FCB_DRIVE		EQU 0
  69+ 6DC5              FCB_NAME		EQU EXT_NAME
  70+ 6DC5              FCB_EX_IDX		EQU EXT_IDX
  71+ 6DC5              FCB_S1			EQU EXT_S1
  72+ 6DC5              FCB_S2			EQU EXT_S2
  73+ 6DC5              FCB_RC			EQU	EXT_RC
  74+ 6DC5              FCB_AU			EQU	EXT_AU0
  75+ 6DC5              FCB_CR			EQU	32
  76+ 6DC5              FCB_R0			EQU 33
  77+ 6DC5              FCB_R1			EQU 34
  78+ 6DC5              FCB_R2			EQU 35
  79+ 6DC5              FCB_SIZE		EQU 36
  80+ 6DC5
  81+ 6DC5
  82+ 6DC5
  83+ 6DC5              ;System variables for disk
  84+ 6DC5              DSTR1			EQU	$5CD6		;drive
  85+ 6DC5              FSTR1			EQU	$5CDC		;file name
  86+ 6DC5              NSTR1			EQU	$5CDA		;name length
  87+ 6DC5              HD11			EQU	$5CED		;BDOS argument
  88+ 6DC5              COPIES			EQU	$5CEF		;BDOS function
  89+ 6DC5
  90+ 6DC5              ERRSP			EQU $5C3D
  91+ 6DC5              ERRNR			EQU $5C3A
  92+ 6DC5              ERRMSG			EQU	$0260
  93+ 6DC5
  94+ 6DC5              PROG			EQU $5C53
  95+ 6DC5              VARS			EQU	$5C4B
  96+ 6DC5              STKEND			EQU	$5C65
  97+ 6DC5
  98+ 6DC5              PRN_BUF			EQU	23296
  99+ 6DC5
 100+ 6DC5              REPDEL			EQU	23561
 101+ 6DC5              REPPER			EQU	23562
 102+ 6DC5              PIP				EQU	23609
 103+ 6DC5
 104+ 6DC5
 105+ 6DC5              ;RWTS routine commands
 106+ 6DC5              RWTS_CMD_POS	EQU	0			;position head
 107+ 6DC5              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6DC5              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6DC5              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6DC5
 111+ 6DC5
 112+ 6DC5              ;File name stuff
 113+ 6DC5              NAMELEN			EQU	11			;name length
 114+ 6DC5              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6DC5              SYS_POS			EQU	9			;system attribute position in name
 116+ 6DC5
 117+ 6DC5              ;File types (first byte in header)
 118+ 6DC5              PROG_TYPE		EQU	0			;program
 119+ 6DC5              NUMB_TYPE		EQU	1			;number array
 120+ 6DC5              CHAR_TYPE		EQU	2			;char array
 121+ 6DC5              BYTE_TYPE		EQU	3			;bytes
 122+ 6DC5              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6DC5
 124+ 6DC5              ;File header offsets
 125+ 6DC5              HDR_TYPE		EQU	0
 126+ 6DC5              HDR_LEN			EQU 1
 127+ 6DC5              HDR_ADDR		EQU 3
 128+ 6DC5              HDR_PLEN		EQU	5
 129+ 6DC5              HDR_LINE		EQU 7
 130+ 6DC5              HDR_SZ			EQU	9
 131+ 6DC5
 132+ 6DC5              ;BASIC disk channel structure
 133+ 6DC5              CH_RW_FLAG		EQU 11
 134+ 6DC5              CH_FCB			EQU	12
 135+ 6DC5              CH_DATA			EQU	50
 136+ 6DC5              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6DC5
 138+ 6DC5              CACHE_NAME		EQU	0					;11B
 139+ 6DC5              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6DC5              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6DC5              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6DC5              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6DC5              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6DC5
 145+ 6DC5              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6DC5
 147+ 6DC5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6DC5              IF1Init:
 149+ 6DC5 CF           	rst		08
 150+ 6DC6 31           	defb	49		;create system variables
 151+ 6DC7 C9           	ret
 152+ 6DC8
 153+ 6DC8              ;ReadWriteTrackSector
 154+ 6DC8              ;A=command: 0, 1, 2, 4
 155+ 6DC8              RWTS:
 156+ 6DC8 32 94 71     	ld (RWTSCmd), a
 157+ 6DCB 21 89 71     	ld hl, RWTSParams
 158+ 6DCE 22 ED 5C     	ld (HD11), hl
 159+ 6DD1 CF           	rst 08
 160+ 6DD2 3A           	DEFB 58
 161+ 6DD3 C9           	ret
 162+ 6DD4
 163+ 6DD4
 164+ 6DD4              ;D = sector, E = track
 165+ 6DD4              ;HL = dma
 166+ 6DD4              ReadOneDiskSector:
 167+ 6DD4 22 8E 71     	ld (RWTSDMA), hl
 168+ 6DD7 ED 53 8C 71  	ld (RWTSTrack), de
 169+ 6DDB              	;ld (RWTSDrive), a
 170+ 6DDB 3E 01        	ld a, RWTS_CMD_READ
 171+ 6DDD 18 E9        	jr	RWTS
 172+ 6DDF
 173+ 6DDF              ;D = sector, E = track
 174+ 6DDF              ;HL = dma
 175+ 6DDF              WriteOneDiskSector:
 176+ 6DDF 22 8E 71     	ld (RWTSDMA), hl
 177+ 6DE2 ED 53 8C 71  	ld (RWTSTrack), de
 178+ 6DE6              	;ld (RWTSDrive), a
 179+ 6DE6 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6DE8 18 DE        	jr	RWTS
 181+ 6DEA
 182+ 6DEA              FormatDisk:
 183+ 6DEA 21 FE 8C     	ld		hl, DataBuf
 184+ 6DED 36 E5        	ld		(hl), DEL_MARKER
 185+ 6DEF 22 8E 71     	ld 		(RWTSDMA), hl
 186+ 6DF2 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 6DF4 CD C8 6D     	call	RWTS
 188+ 6DF7 3A 95 71     	ld		a, (RWTSRes)
 189+ 6DFA C9           	ret
 190+ 6DFB
 191+ 6DFB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 6DFB
 193+ 6DFB              ;Allocation unit no. to track/sector
 194+ 6DFB              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 6DFB              ;IN:  HL=alloc. unit no.
 196+ 6DFB              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 6DFB              AU2TS:
 198+ 6DFB 0E 02        	ld c, SPT/SPAL
 199+ 6DFD CD 91 6D     	call Div					;A = sector
 200+ 6E00 F5           	push af
 201+ 6E01 ~            		/*
 202+ 6E01 ~            		ld c, HEAD_CNT
 203+ 6E01 ~            		call Div				;L = track, A = head (0 or 1)
 204+ 6E01 ~            		*/
 205+ 6E01 AF           		xor a
 206+ 6E02 CB 1C        		rr h
 207+ 6E04 CB 1D        		rr l
 208+ 6E06 CB 1F        		rr a
 209+ 6E08
 210+ 6E08 4D           		ld c, l
 211+ 6E09 06 00        		ld b, 0
 212+ 6E0B B7           		or a
 213+ 6E0C 28 02        		jr z, Track0
 214+ 6E0E 06 10        		ld b, SPT
 215+ 6E10              Track0:
 216+ 6E10 F1           	pop af
 217+ 6E11 B7           	or a
 218+ 6E12 28 02        	jr z, FirstAU
 219+ 6E14 3E 08        	ld a, SPAL
 220+ 6E16              FirstAU:
 221+ 6E16 80           	add a, b
 222+ 6E17 47           	ld  b, a
 223+ 6E18 C9           	ret
 224+ 6E19
 225+ 6E19              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 6E19
 227+ 6E19              ;Checks the allocation units number used in extension
 228+ 6E19              ;IN:	IX = extension addr
 229+ 6E19              ;OUT:	B = no. of allocation units used
 230+ 6E19              ;		C = no. of records used in ext.
 231+ 6E19              ;		HL = first alloc. unit no.
 232+ 6E19              ;		DE = last alloc. unit no.
 233+ 6E19              CheckExtAlloc:
 234+ 6E19 DD E5        	push ix
 235+ 6E1B 01 0F 00     		ld bc, EXT_RC
 236+ 6E1E DD 09        		add ix, bc
 237+ 6E20 DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 6E23 DD 23        		inc ix
 239+ 6E25 DD 6E 00     		ld l, (ix)
 240+ 6E28 DD 66 01     		ld h, (ix + 1)
 241+ 6E2B 06 08        		ld b, EXT_AU_CNT
 242+ 6E2D              CheckAU:
 243+ 6E2D DD 7E 00     		ld a, (ix)
 244+ 6E30 DD B6 01     		or (ix + 1)
 245+ 6E33 28 0C        		jr z, CheckAUEnd
 246+ 6E35 DD 5E 00     		ld e, (ix)
 247+ 6E38 DD 56 01     		ld d, (ix + 1)
 248+ 6E3B DD 23        		inc ix
 249+ 6E3D DD 23        		inc ix
 250+ 6E3F 10 EC        		djnz CheckAU
 251+ 6E41              CheckAUEnd:
 252+ 6E41 3E 08        		ld a, EXT_AU_CNT
 253+ 6E43 90           		sub b
 254+ 6E44 47           		ld b, a
 255+ 6E45 DD E1        	pop ix
 256+ 6E47 C9           	ret
 257+ 6E48
 258+ 6E48              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 6E48
 260+ 6E48              ;Input: TrackBuffer
 261+ 6E48              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 6E48              ReadUsedBlocksList:
 263+ 6E48 DD 21 FE 8C  	ld		ix, TrackBuf			;source buffer
 264+ 6E4C 21 14 87     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 6E4F 01 3E 01     	ld		bc, MAX_FREE_AU_CNT		;loop counter
 266+ 6E52 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 6E55 73           	ld		(hl), e
 268+ 6E56 23           	inc		hl
 269+ 6E57 72           	ld		(hl), d
 270+ 6E58 23           	inc		hl
 271+ 6E59
 272+ 6E59              	;Add blocks 0 and 1 for directory
 273+ 6E59 11 00 00     	ld		de, 0
 274+ 6E5C 73           	ld		(hl), e
 275+ 6E5D 23           	inc		hl
 276+ 6E5E 72           	ld		(hl), d
 277+ 6E5F 23           	inc		hl
 278+ 6E60
 279+ 6E60 13           	inc		de
 280+ 6E61 73           	ld		(hl), e
 281+ 6E62 23           	inc		hl
 282+ 6E63 72           	ld		(hl), d
 283+ 6E64 23           	inc		hl
 284+ 6E65
 285+ 6E65              ReadUsedBlocksLoop:
 286+ 6E65 AF           	xor		a
 287+ 6E66 DD BE 00     	cp		(ix)
 288+ 6E69 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 6E6B
 290+ 6E6B DD E5        	push	ix
 291+ 6E6D C5           	push	bc
 292+ 6E6E 06 08        		ld		b, EXT_AU_CNT
 293+ 6E70 11 10 00     		ld		de, EXT_AU0
 294+ 6E73 DD 19        		add		ix, de
 295+ 6E75
 296+ 6E75              ReadUsedBlocksLoop2:
 297+ 6E75 DD 5E 00     		ld		e, (ix)
 298+ 6E78 DD 56 01     		ld		d, (ix+1)
 299+ 6E7B 7B           		ld		a, e
 300+ 6E7C B2           		or		d
 301+ 6E7D 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 6E7F
 303+ 6E7F 73           		ld		(hl), e
 304+ 6E80 23           		inc		hl
 305+ 6E81 72           		ld		(hl), d
 306+ 6E82 23           		inc		hl
 307+ 6E83
 308+ 6E83 DD 23        		inc		ix
 309+ 6E85 DD 23        		inc		ix
 310+ 6E87
 311+ 6E87 ED 5B 14 87  		ld		de, (UsedBlockListCnt)
 312+ 6E8B 13           		inc		de
 313+ 6E8C ED 53 14 87  		ld		(UsedBlockListCnt), de
 314+ 6E90
 315+ 6E90 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 6E92
 317+ 6E92
 318+ 6E92              ReadUsedBlocksSkip:
 319+ 6E92 C1           	pop		bc
 320+ 6E93 DD E1        	pop		ix
 321+ 6E95              ReadUsedBlocksSkip2:
 322+ 6E95 11 20 00     	ld		de, EXT_SZ
 323+ 6E98 DD 19        	add		ix, de
 324+ 6E9A
 325+ 6E9A 0B           	dec		bc
 326+ 6E9B 78           	ld		a, b
 327+ 6E9C B1           	or		c
 328+ 6E9D 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 6E9F
 330+ 6E9F C9           	ret
 331+ 6EA0
 332+ 6EA0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 6EA0              ;Reads 8 sectors for an AU
 334+ 6EA0              ;HL = block number, DE = destination buffer
 335+ 6EA0              ReadFSBlock:
 336+ 6EA0 D5           	push	de
 337+ 6EA1 CD FB 6D     		call	AU2TS		;B=sector, C=track
 338+ 6EA4 E1           	pop		hl				;HL=dest
 339+ 6EA5
 340+ 6EA5 50           	ld		d, b
 341+ 6EA6 59           	ld		e, c
 342+ 6EA7 06 08        	ld		b, SPAL
 343+ 6EA9
 344+ 6EA9 CD 88 70     	call	ReadDiskSectors
 345+ 6EAC C9           	ret
 346+ 6EAD
 347+ 6EAD
 348+ 6EAD              ;Write 8 sectors for an AU
 349+ 6EAD              ;HL = block number, DE = source buffer
 350+ 6EAD              WriteFSBlock:
 351+ 6EAD D5           	push	de
 352+ 6EAE CD FB 6D     		call	AU2TS		;B=sector, C=track
 353+ 6EB1 E1           	pop		hl				;HL=dest
 354+ 6EB2
 355+ 6EB2 50           	ld		d, b
 356+ 6EB3 59           	ld		e, c
 357+ 6EB4 06 08        	ld		b, SPAL
 358+ 6EB6
 359+ 6EB6 CD 9B 70     	call	WriteDiskSectors
 360+ 6EB9 C9           	ret
 361+ 6EBA
 362+ 6EBA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 6EBA              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 6EBA              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 6EBA              CopyDisk:
 366+ 6EBA              	;Get list of used blocks in current disk, max 632 bytes
 367+ 6EBA CD 48 6E     	call	ReadUsedBlocksList
 368+ 6EBD DD 21 16 87  	ld		ix, UsedBlockListBlk
 369+ 6EC1
 370+ 6EC1              CopyDiskLoop:
 371+ 6EC1 2A 14 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 6EC4 11 4C 7E     	ld		de, MsgBlocksLeft
 373+ 6EC7 CD 55 6D     	call	Byte2Txt
 374+ 6ECA 21 4C 7E     	ld		hl, MsgBlocksLeft
 375+ 6ECD 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 6ED0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 6ED2 CD 58 76     	call	PrintStrClr
 378+ 6ED5
 379+ 6ED5              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 6ED5 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 6ED8 ED 4B 14 87  	ld		bc, (UsedBlockListCnt)
 382+ 6EDC B7           	or		a
 383+ 6EDD ED 42        	sbc		hl, bc
 384+ 6EDF 30 03        	jr		nc, CopyDiskLoopRead
 385+ 6EE1 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 6EE4
 387+ 6EE4              CopyDiskLoopRead:
 388+ 6EE4 41           	ld		b, c
 389+ 6EE5 11 FE 8C     	ld		de, CopyDiskBuf
 390+ 6EE8              	;save initial counter and initial block number array position
 391+ 6EE8 C5           	push	bc
 392+ 6EE9 DD E5        	push	ix
 393+ 6EEB
 394+ 6EEB              CopyDiskLoopReadLoop:
 395+ 6EEB DD 6E 00     		ld		l, (ix)
 396+ 6EEE DD 66 01     		ld		h, (ix+1)
 397+ 6EF1 DD 23        		inc		ix
 398+ 6EF3 DD 23        		inc		ix
 399+ 6EF5
 400+ 6EF5 D5           		push	de
 401+ 6EF6 C5           		push	bc
 402+ 6EF7 CD A0 6E     			call	ReadFSBlock			;Stop on error or continue?
 403+ 6EFA C1           		pop		bc
 404+ 6EFB D1           		pop		de
 405+ 6EFC
 406+ 6EFC              		;+2048
 407+ 6EFC 7A           		ld		a, d
 408+ 6EFD C6 08        		add		8
 409+ 6EFF 57           		ld		d, a
 410+ 6F00
 411+ 6F00 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 6F02
 413+ 6F02              		;Check if selection is 1=single drive or 2=dual drive
 414+ 6F02 3A BD 7E     		ld		a, (CopySelOption)
 415+ 6F05 FE 31        		cp		'1'
 416+ 6F07 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 6F09
 418+ 6F09              		;Prompt for disk change
 419+ 6F09 CD A8 72     		call	PromptDiskChangeDst
 420+ 6F0C 3A 8A 71     		ld		a, (RWTSDrive)
 421+ 6F0F CD B2 71     		call	BDOSInit
 422+ 6F12 18 0A        		jr		CopyDiskReadEnd
 423+ 6F14
 424+ 6F14              CopyDiskDualDrive1:
 425+ 6F14              		;alternate drive
 426+ 6F14 3A 8A 71     		ld		a, (RWTSDrive)
 427+ 6F17 3C           		inc 	a
 428+ 6F18 EE 03        		xor		%11
 429+ 6F1A 3D           		dec		a
 430+ 6F1B 32 8A 71     		ld		(RWTSDrive), a
 431+ 6F1E
 432+ 6F1E              CopyDiskReadEnd:
 433+ 6F1E              	;restore initial counter and initial block number array position
 434+ 6F1E DD E1        	pop		ix
 435+ 6F20 C1           	pop		bc
 436+ 6F21 11 FE 8C     	ld		de, CopyDiskBuf
 437+ 6F24 C5           	push	bc
 438+ 6F25
 439+ 6F25              CopyDiskLoopWriteLoop:
 440+ 6F25 DD 6E 00     		ld		l, (ix)
 441+ 6F28 DD 66 01     		ld		h, (ix+1)
 442+ 6F2B DD 23        		inc		ix
 443+ 6F2D DD 23        		inc		ix
 444+ 6F2F
 445+ 6F2F D5           		push	de
 446+ 6F30 C5           		push	bc
 447+ 6F31 CD AD 6E     			call	WriteFSBlock		;Stop on error or continue?
 448+ 6F34 C1           		pop		bc
 449+ 6F35 D1           		pop		de
 450+ 6F36
 451+ 6F36              		;+2048
 452+ 6F36 7A           		ld		a, d
 453+ 6F37 C6 08        		add		8
 454+ 6F39 57           		ld		d, a
 455+ 6F3A
 456+ 6F3A 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 6F3C
 458+ 6F3C              CopyDiskWriteEnd:
 459+ 6F3C C1           	pop		bc
 460+ 6F3D 48           	ld		c, b
 461+ 6F3E 06 00        	ld		b, 0
 462+ 6F40
 463+ 6F40              	;Decrease number of blocks read by now.
 464+ 6F40 2A 14 87     	ld		hl, (UsedBlockListCnt)
 465+ 6F43 B7           	or		a
 466+ 6F44 ED 42        	sbc		hl, bc
 467+ 6F46 22 14 87     	ld		(UsedBlockListCnt), hl
 468+ 6F49
 469+ 6F49 7D           	ld		a, l
 470+ 6F4A B4           	or		h
 471+ 6F4B 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 6F4D
 473+ 6F4D              	;Check if selection is 1=single drive or 2=dual drive
 474+ 6F4D 3A BD 7E     	ld		a, (CopySelOption)
 475+ 6F50 FE 31        	cp		'1'
 476+ 6F52 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 6F54
 478+ 6F54              	;Prompt for disk change
 479+ 6F54 CD C2 72     	call	PromptDiskChangeSrc
 480+ 6F57 3A 8A 71     	ld		a, (RWTSDrive)
 481+ 6F5A CD B2 71     	call	BDOSInit
 482+ 6F5D C3 C1 6E     	jp		CopyDiskLoop
 483+ 6F60
 484+ 6F60              CopyDiskDualDrive2:
 485+ 6F60              	;alternate drive again
 486+ 6F60 3A 8A 71     	ld		a, (RWTSDrive)
 487+ 6F63 3C           	inc		a
 488+ 6F64 EE 03        	xor		%11
 489+ 6F66 3D           	dec		a
 490+ 6F67 32 8A 71     	ld		(RWTSDrive), a
 491+ 6F6A C3 C1 6E     	jp		CopyDiskLoop
 492+ 6F6D
 493+ 6F6D              CopyDiskEnd:
 494+ 6F6D 06 01        	ld		b, 1
 495+ 6F6F CD DC 77     	call	ClearNMsgLines
 496+ 6F72 C9           	ret
 497+ 6F73
 498+ 6F73              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 6F73              ;Copies the current disk blocks to COM port.
 500+ 6F73              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 6F73              CopyDiskToCOM:
 502+ 6F73              	;Get list of used blocks in current disk, max 632 bytes
 503+ 6F73 CD 48 6E     	call	ReadUsedBlocksList
 504+ 6F76
 505+ 6F76              	;Send block count and block indexes
 506+ 6F76 2A 14 87     	ld		hl, (UsedBlockListCnt)
 507+ 6F79 29           	add		hl, hl
 508+ 6F7A 23           	inc		hl
 509+ 6F7B 23           	inc		hl
 510+ 6F7C 44           	ld		b, h
 511+ 6F7D 4D           	ld		c, l
 512+ 6F7E 21 14 87     	ld		hl, UsedBlockListCnt
 513+ 6F81 CD BB 7B     	call	SERTB
 514+ 6F84
 515+ 6F84 DD 21 16 87  	ld		ix, UsedBlockListBlk
 516+ 6F88
 517+ 6F88              CopyDiskToCOMLoop:
 518+ 6F88              	;Print block count left
 519+ 6F88 2A 14 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 6F8B 11 4C 7E     	ld		de, MsgBlocksLeft
 521+ 6F8E CD 55 6D     	call	Byte2Txt
 522+ 6F91 21 4C 7E     	ld		hl, MsgBlocksLeft
 523+ 6F94 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 6F97 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 6F99 CD 58 76     	call	PrintStrClr
 526+ 6F9C
 527+ 6F9C              	;Read block into buffer
 528+ 6F9C DD 6E 00     	ld		l, (ix)
 529+ 6F9F DD 66 01     	ld		h, (ix+1)
 530+ 6FA2 11 FE 8C     	ld		de, CopyDiskBuf
 531+ 6FA5 DD E5        	push	ix
 532+ 6FA7 CD A0 6E     		call	ReadFSBlock
 533+ 6FAA DD E1        	pop		ix
 534+ 6FAC DD 23        	inc		ix
 535+ 6FAE DD 23        	inc		ix
 536+ 6FB0
 537+ 6FB0              	;Send block buffer
 538+ 6FB0 21 FE 8C     	ld		hl, CopyDiskBuf
 539+ 6FB3 01 00 08     	ld		bc, AU_SZ
 540+ 6FB6 CD BB 7B     	call	SERTB
 541+ 6FB9
 542+ 6FB9 ED 4B 14 87  	ld		bc, (UsedBlockListCnt)
 543+ 6FBD 0B           	dec		bc
 544+ 6FBE ED 43 14 87  	ld		(UsedBlockListCnt), bc
 545+ 6FC2
 546+ 6FC2 DD E5        	push	ix
 547+ 6FC4 CD F7 75     		call	KbdHit
 548+ 6FC7 DD E1        	pop		ix
 549+ 6FC9 D8           	ret		c
 550+ 6FCA
 551+ 6FCA 78           	ld		a, b
 552+ 6FCB B1           	or		c
 553+ 6FCC 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 6FCE
 555+ 6FCE C9           	ret
 556+ 6FCF
 557+ 6FCF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 6FCF              CopyDiskFromCOM:
 559+ 6FCF              	;Receive block count.
 560+ 6FCF 21 14 87     	ld		hl, UsedBlockListCnt
 561+ 6FD2 01 02 00     	ld		bc, 2
 562+ 6FD5 1E 00        	ld		e, 0
 563+ 6FD7 CD 88 7B     	call	SERRB
 564+ 6FDA
 565+ 6FDA              	;Receive block indexes.
 566+ 6FDA 2A 14 87     	ld		hl, (UsedBlockListCnt)
 567+ 6FDD 29           	add		hl, hl
 568+ 6FDE 44           	ld		b, h
 569+ 6FDF 4D           	ld		c, l
 570+ 6FE0 21 16 87     	ld		hl, UsedBlockListBlk
 571+ 6FE3 1E 00        	ld		e, 0
 572+ 6FE5 CD 88 7B     	call	SERRB
 573+ 6FE8
 574+ 6FE8              	;Read each block by index and write to disk
 575+ 6FE8 DD 21 16 87  	ld		ix, UsedBlockListBlk
 576+ 6FEC
 577+ 6FEC              CopyDiskFromCOMLoop:
 578+ 6FEC              	;Print block count left
 579+ 6FEC 2A 14 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 6FEF 11 4C 7E     	ld		de, MsgBlocksLeft
 581+ 6FF2 CD 55 6D     	call	Byte2Txt
 582+ 6FF5 21 4C 7E     	ld		hl, MsgBlocksLeft
 583+ 6FF8 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 6FFB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 6FFD CD 58 76     	call	PrintStrClr
 586+ 7000
 587+ 7000              	;Read block buffer
 588+ 7000 21 FE 8C     	ld		hl, CopyDiskBuf
 589+ 7003 01 00 08     	ld		bc, AU_SZ
 590+ 7006 1E 00        	ld		e, 0
 591+ 7008 CD 88 7B     	call	SERRB
 592+ 700B
 593+ 700B              	;Write block to disk
 594+ 700B DD 6E 00     	ld		l, (ix)
 595+ 700E DD 66 01     	ld		h, (ix+1)
 596+ 7011 11 FE 8C     	ld		de, CopyDiskBuf
 597+ 7014 DD E5        	push	ix
 598+ 7016 CD AD 6E     		call	WriteFSBlock			;Stop on error or continue?
 599+ 7019 DD E1        	pop		ix
 600+ 701B DD 23        	inc		ix
 601+ 701D DD 23        	inc		ix
 602+ 701F
 603+ 701F ED 4B 14 87  	ld		bc, (UsedBlockListCnt)
 604+ 7023 0B           	dec		bc
 605+ 7024 ED 43 14 87  	ld		(UsedBlockListCnt), bc
 606+ 7028
 607+ 7028 DD E5        	push	ix
 608+ 702A CD F7 75     		call	KbdHit
 609+ 702D DD E1        	pop		ix
 610+ 702F D8           	ret		c
 611+ 7030
 612+ 7030 78           	ld		a, b
 613+ 7031 B1           	or		c
 614+ 7032 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 7034 C9           	ret
 616+ 7035
 617+ 7035              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 7035
 619+ 7035              ;Compare string at HL with the one at DE, max length B
 620+ 7035              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 7035              ;OUT: z flag, set = match, reset = mismatch
 622+ 7035              StrCmp:
 623+ 7035 E5           	push hl
 624+ 7036 D5           	push de
 625+ 7037              Compare:
 626+ 7037 1A           		ld a, (de)
 627+ 7038 BE           		cp (hl)
 628+ 7039 20 04        		jr nz, MisMatch
 629+ 703B 23           		inc hl
 630+ 703C 13           		inc de
 631+ 703D 10 F8        		djnz Compare
 632+ 703F              MisMatch:
 633+ 703F D1           	pop de
 634+ 7040 E1           	pop hl
 635+ 7041 C9           	ret
 636+ 7042
 637+ 7042              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 7042
 639+ 7042              ;Read a file into a buffer, sector by sector.
 640+ 7042              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 7042              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 7042              ;In: HL = Name address, DE = buffer
 643+ 7042              IF1FileLoad:
 644+ 7042 D5           	push	de
 645+ 7043 22 DC 5C     		ld (FSTR1), hl
 646+ 7046 26 00        		ld h, 0
 647+ 7048 3A 8A 71     		ld a, (RWTSDrive)
 648+ 704B 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 704C 6F           		ld	l, a
 650+ 704D 22 D6 5C     		ld (DSTR1), hl
 651+ 7050 2E 0B        		ld l,NAMELEN
 652+ 7052 22 DA 5C     		ld (NSTR1), hl
 653+ 7055 CF           		rst 08
 654+ 7056 33           		DEFB 51			;open disk channel
 655+ 7057
 656+ 7057 CF           		rst		8
 657+ 7058 35           		defb	53		;read sector
 658+ 7059 D1           	pop		de
 659+ 705A 30 27        	jr		nc, FileFree
 660+ 705C
 661+ 705C DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 705F FE 04        	cp		TEXT_TYPE
 663+ 7061 30 12        	jr		nc, FileLoadNoHeader
 664+ 7063
 665+ 7063              FileLoadHeader:
 666+ 7063 DD E5        	push	ix
 667+ 7065 E1           	pop		hl
 668+ 7066 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 7069 09           	add		hl, bc
 670+ 706A 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 706D ED B0        	ldir
 672+ 706F
 673+ 706F              FileReadLoop:
 674+ 706F D5           	push	de
 675+ 7070 CF           		rst		8
 676+ 7071 35           		defb	53		;read sector
 677+ 7072 D1           	pop		de
 678+ 7073 30 0E        	jr		nc, FileFree
 679+ 7075
 680+ 7075              FileLoadNoHeader:
 681+ 7075 DD E5        	push	ix
 682+ 7077 E1           	pop		hl
 683+ 7078 01 32 00     	ld		bc, CH_DATA
 684+ 707B 09           	add		hl, bc
 685+ 707C 01 00 01     	ld		bc, SECT_SZ
 686+ 707F ED B0        	ldir
 687+ 7081 18 EC        	jr		FileReadLoop
 688+ 7083
 689+ 7083              FileFree:
 690+ 7083 D5           	push	de
 691+ 7084 CF           	rst		8
 692+ 7085 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 7086 D1           	pop		de
 694+ 7087 C9           	ret
 695+ 7088              IF1FileLoadEnd:
 696+ 7088
 697+ 7088              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 7088              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 7088              ;Out: A = error code, 0=OK
 700+ 7088              ReadDiskSectors:
 701+ 7088 C5           	push bc
 702+ 7089 E5           		push hl
 703+ 708A D5           			push de
 704+ 708B CD D4 6D     				call ReadOneDiskSector
 705+ 708E D1           			pop de
 706+ 708F E1           		pop hl
 707+ 7090
 708+ 7090 14           		inc d
 709+ 7091 24           		inc h
 710+ 7092 C1           	pop bc
 711+ 7093
 712+ 7093 3A 95 71     	ld	a, (RWTSRes)
 713+ 7096 B7           	or	a
 714+ 7097 C0           	ret nz
 715+ 7098
 716+ 7098 10 EE        	djnz ReadDiskSectors
 717+ 709A C9           	ret
 718+ 709B
 719+ 709B              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 709B              ;Out: A = error code, 0=OK
 721+ 709B              WriteDiskSectors:
 722+ 709B C5           	push bc
 723+ 709C E5           		push hl
 724+ 709D D5           			push de
 725+ 709E CD DF 6D     				call WriteOneDiskSector
 726+ 70A1 D1           			pop de
 727+ 70A2 E1           		pop hl
 728+ 70A3
 729+ 70A3 14           		inc d
 730+ 70A4 24           		inc h
 731+ 70A5 C1           	pop bc
 732+ 70A6
 733+ 70A6 3A 95 71     	ld	a, (RWTSRes)
 734+ 70A9 B7           	or	a
 735+ 70AA C0           	ret nz
 736+ 70AB
 737+ 70AB 10 EE        	djnz WriteDiskSectors
 738+ 70AD C9           	ret
 739+ 70AE
 740+ 70AE
 741+ 70AE              ;Reads disk catalog
 742+ 70AE              ReadCatalogTrack:
 743+ 70AE 21 FE 8C     	ld hl, TrackBuf
 744+ 70B1 11 00 00     	ld de, 0
 745+ 70B4 06 10        	ld b, SPT
 746+ 70B6
 747+ 70B6 CD 88 70     	call ReadDiskSectors
 748+ 70B9 B7           	or   a
 749+ 70BA C0           	ret  nz
 750+ 70BB
 751+ 70BB              	;Sync with BDOS, to avoid disk R/O error on disk change
 752+ 70BB F5           	push  af
 753+ 70BC 3A 8A 71     		ld  a, (RWTSDrive)
 754+ 70BF CD B5 71     		call BDOSSelectDisk
 755+ 70C2 CD B2 71     		call BDOSInit
 756+ 70C5 F1           	pop   af
 757+ 70C6 C9           	ret
 758+ 70C7
 759+ 70C7
 760+ 70C7
 761+ 70C7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 762+ 70C7
 763+ 70C7              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 764+ 70C7              FindCache:
 765+ 70C7 06 0B        	ld		b, NAMELEN
 766+ 70C9 CD 35 70     	call	StrCmp			;find the file to wich this extension belongs
 767+ 70CC C8           	ret		z
 768+ 70CD
 769+ 70CD 0D           	dec		c
 770+ 70CE 20 02        	jr		nz, CacheNotFinished
 771+ 70D0 B1           	or		c
 772+ 70D1 C9           	ret
 773+ 70D2
 774+ 70D2              CacheNotFinished:
 775+ 70D2 01 19 00     	ld		bc, CACHE_SZ
 776+ 70D5 09           	add		hl, bc			;to the next cache line
 777+ 70D6 18 EF        	jr		FindCache
 778+ 70D8
 779+ 70D8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 780+ 70D8
 781+ 70D8              	;ld		ix, (SelFileCache)
 782+ 70D8              ReadFileHeader:
 783+ 70D8 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 784+ 70DB B7           	or		a
 785+ 70DC C0           	ret		nz				;return if already read
 786+ 70DD
 787+ 70DD DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 788+ 70E0 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 789+ 70E3 7C           	ld		a, h
 790+ 70E4 B5           	or		l
 791+ 70E5 28 46        	jr		z, ReadHeaderEnd
 792+ 70E7
 793+ 70E7 CD FB 6D     	call	AU2TS
 794+ 70EA 50           	ld		d, b
 795+ 70EB 59           	ld		e, c
 796+ 70EC 21 FE 8C     	ld		hl, DataBuf
 797+ 70EF DD E5        	push	ix
 798+ 70F1 DD E5        	push	ix
 799+ 70F3 CD D4 6D     		call	ReadOneDiskSector
 800+ 70F6 E1           	pop		hl
 801+ 70F7 DD E1        	pop		ix
 802+ 70F9
 803+ 70F9 E5           	push	hl
 804+ 70FA 21 FE 8C     		ld		hl, DataBuf
 805+ 70FD CD 31 71     		call	IsFileHeaderValid
 806+ 7100 E1           	pop		hl
 807+ 7101 B7           	or		a
 808+ 7102 28 14        	jr		z, ReadFileHeaderIsTextFile
 809+ 7104
 810+ 7104 01 10 00     	ld		bc, CACHE_HDR
 811+ 7107 09           	add		hl, bc
 812+ 7108 EB           	ex		hl, de
 813+ 7109 21 FE 8C     	ld		hl, DataBuf
 814+ 710C 01 09 00     	ld		bc, HDR_SZ
 815+ 710F ED B0        	ldir
 816+ 7111
 817+ 7111              	;For text files, read file size as reported by BDOS, since we don't have a header.
 818+ 7111 3E 03        	ld		a, BYTE_TYPE
 819+ 7113 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 820+ 7116 30 15        	jr		nc, ReadHeaderEnd
 821+ 7118
 822+ 7118              ReadFileHeaderIsTextFile:
 823+ 7118 DD E5        	push	ix
 824+ 711A DD E5        	push	ix
 825+ 711C E1           	pop		hl
 826+ 711D CD 0C 72     		call	GetFileSize
 827+ 7120 DD E1        	pop		ix
 828+ 7122 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 829+ 7125 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 830+ 7128 3E 04        	ld		a, TEXT_TYPE
 831+ 712A DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 832+ 712D
 833+ 712D              ReadHeaderEnd:
 834+ 712D DD 34 0F     	inc		(ix + CACHE_FLAG)
 835+ 7130 C9           	ret
 836+ 7131
 837+ 7131              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 838+ 7131              ;Checks if the file header is valid. For now it checks to not have all 0s.
 839+ 7131              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 840+ 7131              ;In: HL = header
 841+ 7131              ;Out: A > 0 if valid
 842+ 7131              IsFileHeaderValid:
 843+ 7131              	IFUSED
 844+ 7131 AF           	xor		a
 845+ 7132 06 09        	ld		b, HDR_SZ
 846+ 7134              IsFileHeaderValidLoop:
 847+ 7134 B6           	or		(hl)
 848+ 7135 23           	inc		hl
 849+ 7136 10 FC        	djnz	IsFileHeaderValidLoop
 850+ 7138
 851+ 7138 C9           	ret
 852+ 7139              	ENDIF
 853+ 7139
 854+ 7139              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 855+ 7139
 856+ 7139              ;IN: HL = address from IF1 to call
 857+ 7139              IF1Call:
 858+ 7139 22 ED 5C     	LD   (HD11), HL
 859+ 713C CF           	RST  8
 860+ 713D 32           	DEFB 50
 861+ 713E C9           	RET
 862+ 713F
 863+ 713F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864+ 713F
 865+ 713F              ;Load a program from disk
 866+ 713F              ;IN: HL = file name addr
 867+ 713F              LoadProgram:
 868+ 713F 22 DC 5C     	LD   (FSTR1), HL
 869+ 7142 26 00        	LD   H, 0
 870+ 7144 2E 0B        	LD   L, NAMELEN
 871+ 7146 22 DA 5C     	LD   (NSTR1), HL
 872+ 7149 3A 8A 71     	LD	 A, (RWTSDrive)
 873+ 714C 3C           	INC  A					;Adapt for BASIC drive number
 874+ 714D 6F           	LD   L, A
 875+ 714E 22 D6 5C     	LD   (DSTR1), HL
 876+ 7151 21 41 0A     	LD   HL, LOAD_ADDR
 877+ 7154 CD 39 71     	CALL IF1Call
 878+ 7157 C9           	RET
 879+ 7158
 880+ 7158              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 881+ 7158
 882+ 7158              SetFastKeys:
 883+ 7158 21 09 5C     	ld		hl, REPDEL
 884+ 715B 11 0F 01     	ld		de, (1 << 8) | 15
 885+ 715E 73 23 72 2B  	ld		(hl), de
 886+ 7162
 887+ 7162 C9           	ret
 888+ 7163
 889+ 7163
 890+ 7163              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 891+ 7163              ;Reads the error message string from IF1 ROM.
 892+ 7163              GetErrMsg:
 893+ 7163 3C           	inc		a
 894+ 7164 08           	ex		af, af'
 895+ 7165
 896+ 7165 21 6B 71     	ld		hl, IF1Paged			;page-in IF1
 897+ 7168 C3 39 71     	jp		IF1Call
 898+ 716B
 899+ 716B              IF1Paged:
 900+ 716B 21 60 02     	ld		hl, ERRMSG
 901+ 716E 08           	ex		af, af'
 902+ 716F B7           	or		a
 903+ 7170 28 0B        	jr		z, SaveMsg
 904+ 7172
 905+ 7172 06 00        	ld		b, 0
 906+ 7174              SearchMsgEnd:
 907+ 7174 CB 7E        	bit		7, (hl)
 908+ 7176 23           	inc		hl
 909+ 7177 28 FB        	jr		z, SearchMsgEnd
 910+ 7179
 911+ 7179 04           	inc		b
 912+ 717A B8           	cp		b
 913+ 717B 20 F7        	jr		nz, SearchMsgEnd
 914+ 717D
 915+ 717D              SaveMsg:
 916+ 717D 11 FE 8C     	ld		de, DataBuf
 917+ 7180              CopyMsg:
 918+ 7180 7E           	ld		a, (hl)
 919+ 7181 CB 7F        	bit		7, a
 920+ 7183 12           	ld		(de), a
 921+ 7184 23           	inc		hl
 922+ 7185 13           	inc		de
 923+ 7186 28 F8        	jr		z, CopyMsg
 924+ 7188
 925+ 7188 C9           	ret
 926+ 7189
 927+ 7189              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 928+ 7189
 929+ 7189              ;RWTS routine I/O block
 930+ 7189              RWTSParams:
 931+ 7189 01           RWTSBlockType	DEFB	1							;?
 932+ 718A 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 933+ 718B 00           RWTSVolNo		DEFB	0							;?
 934+ 718C 00           RWTSTrack		DEFB	0
 935+ 718D 00           RWTSSector		DEFB	0
 936+ 718E 00 00        RWTSDMA			DEFW	0
 937+ 7190 32 29        RWTSExtBuf		DEFW	$2932
 938+ 7192              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 939+ 7192              	IFDEF _REAL_HW_
 940+ 7192 9C 71        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 941+ 7194              	ELSE
 942+ 7194 ~            RWTSPrmTbl		DEFW	$1f2a
 943+ 7194              	ENDIF
 944+ 7194 01           RWTSCmd			DEFB	RWTS_CMD_READ
 945+ 7195              ;Results
 946+ 7195 00           RWTSRes			DEFB	0
 947+ 7196 00           RWTSResVolNo	DEFB	0
 948+ 7197 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 948+ 719B 00
 949+ 719C
 950+ 719C              ;Param. table, usualy found in ROM.
 951+ 719C              	IFDEF _REAL_HW_
 952+ 719C              BasPrmTbl:
 953+ 719C 01           PrmDevType		DEFB	$01		;$01
 954+ 719D 01           PrmStepRate		DEFB	$01		;$0D	(milisec)
 955+ 719E 01           PrmHeadLoad		DEFB	$01		;$23	(milisec)
 956+ 719F 01           PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 957+ 71A0 A2 71        PrmIntrlvTbl	DEFW	InterleaveTbl
 958+ 71A2 01 03 05 07  InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 958+ 71A6 09 0B 0D 0F
 958+ 71AA 02 04 06 08
 958+ 71AE 0A 0C 0E 10
 959+ 71B2              	ENDIF
 960+ 71B2
 961+ 71B2              	endif
# file closed: if1.asm
1235  71B2              	include "bdos.asm"
# file opened: bdos.asm
   1+ 71B2              ;BDOS functions - similar to CP/M
   2+ 71B2
   3+ 71B2              	IFNDEF	_BDOS_
   4+ 71B2              	DEFINE	_BDOS_
   5+ 71B2
   6+ 71B2              	include "if1.asm"
# file opened: if1.asm
   1++71B2              ;HC IF1 routines and constants
   2++71B2
   3++71B2              ;IF1 routines error codes, also returned by BASIC commands
   4++71B2              ;12 = Writing to a 'read' file
   5++71B2              ;13 = Reading a 'write' file
   6++71B2              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++71B2              ;15 = Disk full (disk or catalog full)
   8++71B2              ;16 = Disk error (hardware error)
   9++71B2              ;17 = File not found
  10++71B2              ;23 = Disk R/O (disk change detected, software R/O)
  11++71B2              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++71B2
  13++71B2              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++71B2              ;00h = OK
  15++71B2              ;08h = cannot format disk
  16++71B2              ;10h = disk protected (read-only?)
  17++71B2              ;20h = volume error
  18++71B2              ;40h = drive error
  19++71B2              ;80h = reading error
  20++71B2              ;Codes I encountered:
  21++71B2              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++71B2
  23++71B2
  24++71B2              	ifndef	_DISK_
  25++71B2 ~            	define	_DISK_
  26++71B2 ~
  27++71B2 ~            	include	"math.asm"
  28++71B2 ~
  29++71B2 ~            DRIVE_CUR_BAS	EQU 0
  30++71B2 ~            DRIVE_A_BAS		EQU	1
  31++71B2 ~            DRIVE_B_BAS		EQU	2
  32++71B2 ~            DRIVE_A_CPM		EQU	0
  33++71B2 ~            DRIVE_B_CPM		EQU	1
  34++71B2 ~            ;Disk geometry stuff
  35++71B2 ~            SPT				EQU	16			;sectors per track
  36++71B2 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++71B2 ~            TRACK_CNT		EQU	80			;track count
  38++71B2 ~            HEAD_CNT		EQU	2			;disk face count
  39++71B2 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++71B2 ~            EXT_SZ			EQU	32			;directory entry size
  41++71B2 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++71B2 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++71B2 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++71B2 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++71B2 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++71B2 ~            REC_SZ			EQU 128			;cp/m record size
  47++71B2 ~            DEL_MARKER		EQU	$E5
  48++71B2 ~
  49++71B2 ~
  50++71B2 ~            ;Extension structure (directory entry)
  51++71B2 ~            EXT_DEL_FLAG	EQU	0
  52++71B2 ~            EXT_NAME		EQU 1
  53++71B2 ~            EXT_IDX			EQU 12
  54++71B2 ~            EXT_S1			EQU 13
  55++71B2 ~            EXT_S2			EQU 14
  56++71B2 ~            EXT_RC			EQU	15
  57++71B2 ~            EXT_AU0			EQU	16
  58++71B2 ~            EXT_AU1			EQU	18
  59++71B2 ~            EXT_AU2			EQU	20
  60++71B2 ~            EXT_AU3			EQU	22
  61++71B2 ~            EXT_AU4			EQU	24
  62++71B2 ~            EXT_AU5			EQU	26
  63++71B2 ~            EXT_AU6			EQU	28
  64++71B2 ~            EXT_AU7			EQU	30
  65++71B2 ~            EXT_SIZE		EQU 32
  66++71B2 ~
  67++71B2 ~            ;FCB structure
  68++71B2 ~            FCB_DRIVE		EQU 0
  69++71B2 ~            FCB_NAME		EQU EXT_NAME
  70++71B2 ~            FCB_EX_IDX		EQU EXT_IDX
  71++71B2 ~            FCB_S1			EQU EXT_S1
  72++71B2 ~            FCB_S2			EQU EXT_S2
  73++71B2 ~            FCB_RC			EQU	EXT_RC
  74++71B2 ~            FCB_AU			EQU	EXT_AU0
  75++71B2 ~            FCB_CR			EQU	32
  76++71B2 ~            FCB_R0			EQU 33
  77++71B2 ~            FCB_R1			EQU 34
  78++71B2 ~            FCB_R2			EQU 35
  79++71B2 ~            FCB_SIZE		EQU 36
  80++71B2 ~
  81++71B2 ~
  82++71B2 ~
  83++71B2 ~            ;System variables for disk
  84++71B2 ~            DSTR1			EQU	$5CD6		;drive
  85++71B2 ~            FSTR1			EQU	$5CDC		;file name
  86++71B2 ~            NSTR1			EQU	$5CDA		;name length
  87++71B2 ~            HD11			EQU	$5CED		;BDOS argument
  88++71B2 ~            COPIES			EQU	$5CEF		;BDOS function
  89++71B2 ~
  90++71B2 ~            ERRSP			EQU $5C3D
  91++71B2 ~            ERRNR			EQU $5C3A
  92++71B2 ~            ERRMSG			EQU	$0260
  93++71B2 ~
  94++71B2 ~            PROG			EQU $5C53
  95++71B2 ~            VARS			EQU	$5C4B
  96++71B2 ~            STKEND			EQU	$5C65
  97++71B2 ~
  98++71B2 ~            PRN_BUF			EQU	23296
  99++71B2 ~
 100++71B2 ~            REPDEL			EQU	23561
 101++71B2 ~            REPPER			EQU	23562
 102++71B2 ~            PIP				EQU	23609
 103++71B2 ~
 104++71B2 ~
 105++71B2 ~            ;RWTS routine commands
 106++71B2 ~            RWTS_CMD_POS	EQU	0			;position head
 107++71B2 ~            RWTS_CMD_READ	EQU	1			;read sector
 108++71B2 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++71B2 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++71B2 ~
 111++71B2 ~
 112++71B2 ~            ;File name stuff
 113++71B2 ~            NAMELEN			EQU	11			;name length
 114++71B2 ~            RO_POS			EQU	8			;read-only attribute position in name
 115++71B2 ~            SYS_POS			EQU	9			;system attribute position in name
 116++71B2 ~
 117++71B2 ~            ;File types (first byte in header)
 118++71B2 ~            PROG_TYPE		EQU	0			;program
 119++71B2 ~            NUMB_TYPE		EQU	1			;number array
 120++71B2 ~            CHAR_TYPE		EQU	2			;char array
 121++71B2 ~            BYTE_TYPE		EQU	3			;bytes
 122++71B2 ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++71B2 ~
 124++71B2 ~            ;File header offsets
 125++71B2 ~            HDR_TYPE		EQU	0
 126++71B2 ~            HDR_LEN			EQU 1
 127++71B2 ~            HDR_ADDR		EQU 3
 128++71B2 ~            HDR_PLEN		EQU	5
 129++71B2 ~            HDR_LINE		EQU 7
 130++71B2 ~            HDR_SZ			EQU	9
 131++71B2 ~
 132++71B2 ~            ;BASIC disk channel structure
 133++71B2 ~            CH_RW_FLAG		EQU 11
 134++71B2 ~            CH_FCB			EQU	12
 135++71B2 ~            CH_DATA			EQU	50
 136++71B2 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++71B2 ~
 138++71B2 ~            CACHE_NAME		EQU	0					;11B
 139++71B2 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++71B2 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++71B2 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++71B2 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++71B2 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++71B2 ~
 145++71B2 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++71B2 ~
 147++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++71B2 ~            IF1Init:
 149++71B2 ~            	rst		08
 150++71B2 ~            	defb	49		;create system variables
 151++71B2 ~            	ret
 152++71B2 ~
 153++71B2 ~            ;ReadWriteTrackSector
 154++71B2 ~            ;A=command: 0, 1, 2, 4
 155++71B2 ~            RWTS:
 156++71B2 ~            	ld (RWTSCmd), a
 157++71B2 ~            	ld hl, RWTSParams
 158++71B2 ~            	ld (HD11), hl
 159++71B2 ~            	rst 08
 160++71B2 ~            	DEFB 58
 161++71B2 ~            	ret
 162++71B2 ~
 163++71B2 ~
 164++71B2 ~            ;D = sector, E = track
 165++71B2 ~            ;HL = dma
 166++71B2 ~            ReadOneDiskSector:
 167++71B2 ~            	ld (RWTSDMA), hl
 168++71B2 ~            	ld (RWTSTrack), de
 169++71B2 ~            	;ld (RWTSDrive), a
 170++71B2 ~            	ld a, RWTS_CMD_READ
 171++71B2 ~            	jr	RWTS
 172++71B2 ~
 173++71B2 ~            ;D = sector, E = track
 174++71B2 ~            ;HL = dma
 175++71B2 ~            WriteOneDiskSector:
 176++71B2 ~            	ld (RWTSDMA), hl
 177++71B2 ~            	ld (RWTSTrack), de
 178++71B2 ~            	;ld (RWTSDrive), a
 179++71B2 ~            	ld a, RWTS_CMD_WRITE
 180++71B2 ~            	jr	RWTS
 181++71B2 ~
 182++71B2 ~            FormatDisk:
 183++71B2 ~            	ld		hl, DataBuf
 184++71B2 ~            	ld		(hl), DEL_MARKER
 185++71B2 ~            	ld 		(RWTSDMA), hl
 186++71B2 ~            	ld 		a, RWTS_CMD_FMT
 187++71B2 ~            	call	RWTS
 188++71B2 ~            	ld		a, (RWTSRes)
 189++71B2 ~            	ret
 190++71B2 ~
 191++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++71B2 ~
 193++71B2 ~            ;Allocation unit no. to track/sector
 194++71B2 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++71B2 ~            ;IN:  HL=alloc. unit no.
 196++71B2 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++71B2 ~            AU2TS:
 198++71B2 ~            	ld c, SPT/SPAL
 199++71B2 ~            	call Div					;A = sector
 200++71B2 ~            	push af
 201++71B2 ~            		/*
 202++71B2 ~            		ld c, HEAD_CNT
 203++71B2 ~            		call Div				;L = track, A = head (0 or 1)
 204++71B2 ~            		*/
 205++71B2 ~            		xor a
 206++71B2 ~            		rr h
 207++71B2 ~            		rr l
 208++71B2 ~            		rr a
 209++71B2 ~
 210++71B2 ~            		ld c, l
 211++71B2 ~            		ld b, 0
 212++71B2 ~            		or a
 213++71B2 ~            		jr z, Track0
 214++71B2 ~            		ld b, SPT
 215++71B2 ~            Track0:
 216++71B2 ~            	pop af
 217++71B2 ~            	or a
 218++71B2 ~            	jr z, FirstAU
 219++71B2 ~            	ld a, SPAL
 220++71B2 ~            FirstAU:
 221++71B2 ~            	add a, b
 222++71B2 ~            	ld  b, a
 223++71B2 ~            	ret
 224++71B2 ~
 225++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++71B2 ~
 227++71B2 ~            ;Checks the allocation units number used in extension
 228++71B2 ~            ;IN:	IX = extension addr
 229++71B2 ~            ;OUT:	B = no. of allocation units used
 230++71B2 ~            ;		C = no. of records used in ext.
 231++71B2 ~            ;		HL = first alloc. unit no.
 232++71B2 ~            ;		DE = last alloc. unit no.
 233++71B2 ~            CheckExtAlloc:
 234++71B2 ~            	push ix
 235++71B2 ~            		ld bc, EXT_RC
 236++71B2 ~            		add ix, bc
 237++71B2 ~            		ld c, (ix)			;save rec. no.
 238++71B2 ~            		inc ix
 239++71B2 ~            		ld l, (ix)
 240++71B2 ~            		ld h, (ix + 1)
 241++71B2 ~            		ld b, EXT_AU_CNT
 242++71B2 ~            CheckAU:
 243++71B2 ~            		ld a, (ix)
 244++71B2 ~            		or (ix + 1)
 245++71B2 ~            		jr z, CheckAUEnd
 246++71B2 ~            		ld e, (ix)
 247++71B2 ~            		ld d, (ix + 1)
 248++71B2 ~            		inc ix
 249++71B2 ~            		inc ix
 250++71B2 ~            		djnz CheckAU
 251++71B2 ~            CheckAUEnd:
 252++71B2 ~            		ld a, EXT_AU_CNT
 253++71B2 ~            		sub b
 254++71B2 ~            		ld b, a
 255++71B2 ~            	pop ix
 256++71B2 ~            	ret
 257++71B2 ~
 258++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++71B2 ~
 260++71B2 ~            ;Input: TrackBuffer
 261++71B2 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++71B2 ~            ReadUsedBlocksList:
 263++71B2 ~            	ld		ix, TrackBuf			;source buffer
 264++71B2 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++71B2 ~            	ld		bc, MAX_FREE_AU_CNT		;loop counter
 266++71B2 ~            	ld		de, 2					;counter of used blocks, start with 2
 267++71B2 ~            	ld		(hl), e
 268++71B2 ~            	inc		hl
 269++71B2 ~            	ld		(hl), d
 270++71B2 ~            	inc		hl
 271++71B2 ~
 272++71B2 ~            	;Add blocks 0 and 1 for directory
 273++71B2 ~            	ld		de, 0
 274++71B2 ~            	ld		(hl), e
 275++71B2 ~            	inc		hl
 276++71B2 ~            	ld		(hl), d
 277++71B2 ~            	inc		hl
 278++71B2 ~
 279++71B2 ~            	inc		de
 280++71B2 ~            	ld		(hl), e
 281++71B2 ~            	inc		hl
 282++71B2 ~            	ld		(hl), d
 283++71B2 ~            	inc		hl
 284++71B2 ~
 285++71B2 ~            ReadUsedBlocksLoop:
 286++71B2 ~            	xor		a
 287++71B2 ~            	cp		(ix)
 288++71B2 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++71B2 ~
 290++71B2 ~            	push	ix
 291++71B2 ~            	push	bc
 292++71B2 ~            		ld		b, EXT_AU_CNT
 293++71B2 ~            		ld		de, EXT_AU0
 294++71B2 ~            		add		ix, de
 295++71B2 ~
 296++71B2 ~            ReadUsedBlocksLoop2:
 297++71B2 ~            		ld		e, (ix)
 298++71B2 ~            		ld		d, (ix+1)
 299++71B2 ~            		ld		a, e
 300++71B2 ~            		or		d
 301++71B2 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++71B2 ~
 303++71B2 ~            		ld		(hl), e
 304++71B2 ~            		inc		hl
 305++71B2 ~            		ld		(hl), d
 306++71B2 ~            		inc		hl
 307++71B2 ~
 308++71B2 ~            		inc		ix
 309++71B2 ~            		inc		ix
 310++71B2 ~
 311++71B2 ~            		ld		de, (UsedBlockListCnt)
 312++71B2 ~            		inc		de
 313++71B2 ~            		ld		(UsedBlockListCnt), de
 314++71B2 ~
 315++71B2 ~            		djnz	ReadUsedBlocksLoop2
 316++71B2 ~
 317++71B2 ~
 318++71B2 ~            ReadUsedBlocksSkip:
 319++71B2 ~            	pop		bc
 320++71B2 ~            	pop		ix
 321++71B2 ~            ReadUsedBlocksSkip2:
 322++71B2 ~            	ld		de, EXT_SZ
 323++71B2 ~            	add		ix, de
 324++71B2 ~
 325++71B2 ~            	dec		bc
 326++71B2 ~            	ld		a, b
 327++71B2 ~            	or		c
 328++71B2 ~            	jr		nz, ReadUsedBlocksLoop
 329++71B2 ~
 330++71B2 ~            	ret
 331++71B2 ~
 332++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++71B2 ~            ;Reads 8 sectors for an AU
 334++71B2 ~            ;HL = block number, DE = destination buffer
 335++71B2 ~            ReadFSBlock:
 336++71B2 ~            	push	de
 337++71B2 ~            		call	AU2TS		;B=sector, C=track
 338++71B2 ~            	pop		hl				;HL=dest
 339++71B2 ~
 340++71B2 ~            	ld		d, b
 341++71B2 ~            	ld		e, c
 342++71B2 ~            	ld		b, SPAL
 343++71B2 ~
 344++71B2 ~            	call	ReadDiskSectors
 345++71B2 ~            	ret
 346++71B2 ~
 347++71B2 ~
 348++71B2 ~            ;Write 8 sectors for an AU
 349++71B2 ~            ;HL = block number, DE = source buffer
 350++71B2 ~            WriteFSBlock:
 351++71B2 ~            	push	de
 352++71B2 ~            		call	AU2TS		;B=sector, C=track
 353++71B2 ~            	pop		hl				;HL=dest
 354++71B2 ~
 355++71B2 ~            	ld		d, b
 356++71B2 ~            	ld		e, c
 357++71B2 ~            	ld		b, SPAL
 358++71B2 ~
 359++71B2 ~            	call	WriteDiskSectors
 360++71B2 ~            	ret
 361++71B2 ~
 362++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++71B2 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++71B2 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++71B2 ~            CopyDisk:
 366++71B2 ~            	;Get list of used blocks in current disk, max 632 bytes
 367++71B2 ~            	call	ReadUsedBlocksList
 368++71B2 ~            	ld		ix, UsedBlockListBlk
 369++71B2 ~
 370++71B2 ~            CopyDiskLoop:
 371++71B2 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++71B2 ~            	ld		de, MsgBlocksLeft
 373++71B2 ~            	call	Byte2Txt
 374++71B2 ~            	ld		hl, MsgBlocksLeft
 375++71B2 ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++71B2 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++71B2 ~            	call	PrintStrClr
 378++71B2 ~
 379++71B2 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++71B2 ~            	ld		hl, MAX_AU_RAM
 381++71B2 ~            	ld		bc, (UsedBlockListCnt)
 382++71B2 ~            	or		a
 383++71B2 ~            	sbc		hl, bc
 384++71B2 ~            	jr		nc, CopyDiskLoopRead
 385++71B2 ~            	ld		bc, MAX_AU_RAM
 386++71B2 ~
 387++71B2 ~            CopyDiskLoopRead:
 388++71B2 ~            	ld		b, c
 389++71B2 ~            	ld		de, CopyDiskBuf
 390++71B2 ~            	;save initial counter and initial block number array position
 391++71B2 ~            	push	bc
 392++71B2 ~            	push	ix
 393++71B2 ~
 394++71B2 ~            CopyDiskLoopReadLoop:
 395++71B2 ~            		ld		l, (ix)
 396++71B2 ~            		ld		h, (ix+1)
 397++71B2 ~            		inc		ix
 398++71B2 ~            		inc		ix
 399++71B2 ~
 400++71B2 ~            		push	de
 401++71B2 ~            		push	bc
 402++71B2 ~            			call	ReadFSBlock			;Stop on error or continue?
 403++71B2 ~            		pop		bc
 404++71B2 ~            		pop		de
 405++71B2 ~
 406++71B2 ~            		;+2048
 407++71B2 ~            		ld		a, d
 408++71B2 ~            		add		8
 409++71B2 ~            		ld		d, a
 410++71B2 ~
 411++71B2 ~            		djnz	CopyDiskLoopReadLoop
 412++71B2 ~
 413++71B2 ~            		;Check if selection is 1=single drive or 2=dual drive
 414++71B2 ~            		ld		a, (CopySelOption)
 415++71B2 ~            		cp		'1'
 416++71B2 ~            		jr		nz, CopyDiskDualDrive1
 417++71B2 ~
 418++71B2 ~            		;Prompt for disk change
 419++71B2 ~            		call	PromptDiskChangeDst
 420++71B2 ~            		ld		a, (RWTSDrive)
 421++71B2 ~            		call	BDOSInit
 422++71B2 ~            		jr		CopyDiskReadEnd
 423++71B2 ~
 424++71B2 ~            CopyDiskDualDrive1:
 425++71B2 ~            		;alternate drive
 426++71B2 ~            		ld		a, (RWTSDrive)
 427++71B2 ~            		inc 	a
 428++71B2 ~            		xor		%11
 429++71B2 ~            		dec		a
 430++71B2 ~            		ld		(RWTSDrive), a
 431++71B2 ~
 432++71B2 ~            CopyDiskReadEnd:
 433++71B2 ~            	;restore initial counter and initial block number array position
 434++71B2 ~            	pop		ix
 435++71B2 ~            	pop		bc
 436++71B2 ~            	ld		de, CopyDiskBuf
 437++71B2 ~            	push	bc
 438++71B2 ~
 439++71B2 ~            CopyDiskLoopWriteLoop:
 440++71B2 ~            		ld		l, (ix)
 441++71B2 ~            		ld		h, (ix+1)
 442++71B2 ~            		inc		ix
 443++71B2 ~            		inc		ix
 444++71B2 ~
 445++71B2 ~            		push	de
 446++71B2 ~            		push	bc
 447++71B2 ~            			call	WriteFSBlock		;Stop on error or continue?
 448++71B2 ~            		pop		bc
 449++71B2 ~            		pop		de
 450++71B2 ~
 451++71B2 ~            		;+2048
 452++71B2 ~            		ld		a, d
 453++71B2 ~            		add		8
 454++71B2 ~            		ld		d, a
 455++71B2 ~
 456++71B2 ~            		djnz	CopyDiskLoopWriteLoop
 457++71B2 ~
 458++71B2 ~            CopyDiskWriteEnd:
 459++71B2 ~            	pop		bc
 460++71B2 ~            	ld		c, b
 461++71B2 ~            	ld		b, 0
 462++71B2 ~
 463++71B2 ~            	;Decrease number of blocks read by now.
 464++71B2 ~            	ld		hl, (UsedBlockListCnt)
 465++71B2 ~            	or		a
 466++71B2 ~            	sbc		hl, bc
 467++71B2 ~            	ld		(UsedBlockListCnt), hl
 468++71B2 ~
 469++71B2 ~            	ld		a, l
 470++71B2 ~            	or		h
 471++71B2 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++71B2 ~
 473++71B2 ~            	;Check if selection is 1=single drive or 2=dual drive
 474++71B2 ~            	ld		a, (CopySelOption)
 475++71B2 ~            	cp		'1'
 476++71B2 ~            	jr		nz, CopyDiskDualDrive2
 477++71B2 ~
 478++71B2 ~            	;Prompt for disk change
 479++71B2 ~            	call	PromptDiskChangeSrc
 480++71B2 ~            	ld		a, (RWTSDrive)
 481++71B2 ~            	call	BDOSInit
 482++71B2 ~            	jp		CopyDiskLoop
 483++71B2 ~
 484++71B2 ~            CopyDiskDualDrive2:
 485++71B2 ~            	;alternate drive again
 486++71B2 ~            	ld		a, (RWTSDrive)
 487++71B2 ~            	inc		a
 488++71B2 ~            	xor		%11
 489++71B2 ~            	dec		a
 490++71B2 ~            	ld		(RWTSDrive), a
 491++71B2 ~            	jp		CopyDiskLoop
 492++71B2 ~
 493++71B2 ~            CopyDiskEnd:
 494++71B2 ~            	ld		b, 1
 495++71B2 ~            	call	ClearNMsgLines
 496++71B2 ~            	ret
 497++71B2 ~
 498++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++71B2 ~            ;Copies the current disk blocks to COM port.
 500++71B2 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++71B2 ~            CopyDiskToCOM:
 502++71B2 ~            	;Get list of used blocks in current disk, max 632 bytes
 503++71B2 ~            	call	ReadUsedBlocksList
 504++71B2 ~
 505++71B2 ~            	;Send block count and block indexes
 506++71B2 ~            	ld		hl, (UsedBlockListCnt)
 507++71B2 ~            	add		hl, hl
 508++71B2 ~            	inc		hl
 509++71B2 ~            	inc		hl
 510++71B2 ~            	ld		b, h
 511++71B2 ~            	ld		c, l
 512++71B2 ~            	ld		hl, UsedBlockListCnt
 513++71B2 ~            	call	SERTB
 514++71B2 ~
 515++71B2 ~            	ld		ix, UsedBlockListBlk
 516++71B2 ~
 517++71B2 ~            CopyDiskToCOMLoop:
 518++71B2 ~            	;Print block count left
 519++71B2 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++71B2 ~            	ld		de, MsgBlocksLeft
 521++71B2 ~            	call	Byte2Txt
 522++71B2 ~            	ld		hl, MsgBlocksLeft
 523++71B2 ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++71B2 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++71B2 ~            	call	PrintStrClr
 526++71B2 ~
 527++71B2 ~            	;Read block into buffer
 528++71B2 ~            	ld		l, (ix)
 529++71B2 ~            	ld		h, (ix+1)
 530++71B2 ~            	ld		de, CopyDiskBuf
 531++71B2 ~            	push	ix
 532++71B2 ~            		call	ReadFSBlock
 533++71B2 ~            	pop		ix
 534++71B2 ~            	inc		ix
 535++71B2 ~            	inc		ix
 536++71B2 ~
 537++71B2 ~            	;Send block buffer
 538++71B2 ~            	ld		hl, CopyDiskBuf
 539++71B2 ~            	ld		bc, AU_SZ
 540++71B2 ~            	call	SERTB
 541++71B2 ~
 542++71B2 ~            	ld		bc, (UsedBlockListCnt)
 543++71B2 ~            	dec		bc
 544++71B2 ~            	ld		(UsedBlockListCnt), bc
 545++71B2 ~
 546++71B2 ~            	push	ix
 547++71B2 ~            		call	KbdHit
 548++71B2 ~            	pop		ix
 549++71B2 ~            	ret		c
 550++71B2 ~
 551++71B2 ~            	ld		a, b
 552++71B2 ~            	or		c
 553++71B2 ~            	jr		nz, CopyDiskToCOMLoop
 554++71B2 ~
 555++71B2 ~            	ret
 556++71B2 ~
 557++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++71B2 ~            CopyDiskFromCOM:
 559++71B2 ~            	;Receive block count.
 560++71B2 ~            	ld		hl, UsedBlockListCnt
 561++71B2 ~            	ld		bc, 2
 562++71B2 ~            	ld		e, 0
 563++71B2 ~            	call	SERRB
 564++71B2 ~
 565++71B2 ~            	;Receive block indexes.
 566++71B2 ~            	ld		hl, (UsedBlockListCnt)
 567++71B2 ~            	add		hl, hl
 568++71B2 ~            	ld		b, h
 569++71B2 ~            	ld		c, l
 570++71B2 ~            	ld		hl, UsedBlockListBlk
 571++71B2 ~            	ld		e, 0
 572++71B2 ~            	call	SERRB
 573++71B2 ~
 574++71B2 ~            	;Read each block by index and write to disk
 575++71B2 ~            	ld		ix, UsedBlockListBlk
 576++71B2 ~
 577++71B2 ~            CopyDiskFromCOMLoop:
 578++71B2 ~            	;Print block count left
 579++71B2 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++71B2 ~            	ld		de, MsgBlocksLeft
 581++71B2 ~            	call	Byte2Txt
 582++71B2 ~            	ld		hl, MsgBlocksLeft
 583++71B2 ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++71B2 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++71B2 ~            	call	PrintStrClr
 586++71B2 ~
 587++71B2 ~            	;Read block buffer
 588++71B2 ~            	ld		hl, CopyDiskBuf
 589++71B2 ~            	ld		bc, AU_SZ
 590++71B2 ~            	ld		e, 0
 591++71B2 ~            	call	SERRB
 592++71B2 ~
 593++71B2 ~            	;Write block to disk
 594++71B2 ~            	ld		l, (ix)
 595++71B2 ~            	ld		h, (ix+1)
 596++71B2 ~            	ld		de, CopyDiskBuf
 597++71B2 ~            	push	ix
 598++71B2 ~            		call	WriteFSBlock			;Stop on error or continue?
 599++71B2 ~            	pop		ix
 600++71B2 ~            	inc		ix
 601++71B2 ~            	inc		ix
 602++71B2 ~
 603++71B2 ~            	ld		bc, (UsedBlockListCnt)
 604++71B2 ~            	dec		bc
 605++71B2 ~            	ld		(UsedBlockListCnt), bc
 606++71B2 ~
 607++71B2 ~            	push	ix
 608++71B2 ~            		call	KbdHit
 609++71B2 ~            	pop		ix
 610++71B2 ~            	ret		c
 611++71B2 ~
 612++71B2 ~            	ld		a, b
 613++71B2 ~            	or		c
 614++71B2 ~            	jr		nz, CopyDiskFromCOMLoop
 615++71B2 ~            	ret
 616++71B2 ~
 617++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++71B2 ~
 619++71B2 ~            ;Compare string at HL with the one at DE, max length B
 620++71B2 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++71B2 ~            ;OUT: z flag, set = match, reset = mismatch
 622++71B2 ~            StrCmp:
 623++71B2 ~            	push hl
 624++71B2 ~            	push de
 625++71B2 ~            Compare:
 626++71B2 ~            		ld a, (de)
 627++71B2 ~            		cp (hl)
 628++71B2 ~            		jr nz, MisMatch
 629++71B2 ~            		inc hl
 630++71B2 ~            		inc de
 631++71B2 ~            		djnz Compare
 632++71B2 ~            MisMatch:
 633++71B2 ~            	pop de
 634++71B2 ~            	pop hl
 635++71B2 ~            	ret
 636++71B2 ~
 637++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++71B2 ~
 639++71B2 ~            ;Read a file into a buffer, sector by sector.
 640++71B2 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++71B2 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++71B2 ~            ;In: HL = Name address, DE = buffer
 643++71B2 ~            IF1FileLoad:
 644++71B2 ~            	push	de
 645++71B2 ~            		ld (FSTR1), hl
 646++71B2 ~            		ld h, 0
 647++71B2 ~            		ld a, (RWTSDrive)
 648++71B2 ~            		inc  a			;CP/M drive number to BASIC drive number
 649++71B2 ~            		ld	l, a
 650++71B2 ~            		ld (DSTR1), hl
 651++71B2 ~            		ld l,NAMELEN
 652++71B2 ~            		ld (NSTR1), hl
 653++71B2 ~            		rst 08
 654++71B2 ~            		DEFB 51			;open disk channel
 655++71B2 ~
 656++71B2 ~            		rst		8
 657++71B2 ~            		defb	53		;read sector
 658++71B2 ~            	pop		de
 659++71B2 ~            	jr		nc, FileFree
 660++71B2 ~
 661++71B2 ~            	ld		a, (ix + CH_DATA)
 662++71B2 ~            	cp		TEXT_TYPE
 663++71B2 ~            	jr		nc, FileLoadNoHeader
 664++71B2 ~
 665++71B2 ~            FileLoadHeader:
 666++71B2 ~            	push	ix
 667++71B2 ~            	pop		hl
 668++71B2 ~            	ld		bc, CH_DATA + HDR_SZ
 669++71B2 ~            	add		hl, bc
 670++71B2 ~            	ld		bc, SECT_SZ - HDR_SZ
 671++71B2 ~            	ldir
 672++71B2 ~
 673++71B2 ~            FileReadLoop:
 674++71B2 ~            	push	de
 675++71B2 ~            		rst		8
 676++71B2 ~            		defb	53		;read sector
 677++71B2 ~            	pop		de
 678++71B2 ~            	jr		nc, FileFree
 679++71B2 ~
 680++71B2 ~            FileLoadNoHeader:
 681++71B2 ~            	push	ix
 682++71B2 ~            	pop		hl
 683++71B2 ~            	ld		bc, CH_DATA
 684++71B2 ~            	add		hl, bc
 685++71B2 ~            	ld		bc, SECT_SZ
 686++71B2 ~            	ldir
 687++71B2 ~            	jr		FileReadLoop
 688++71B2 ~
 689++71B2 ~            FileFree:
 690++71B2 ~            	push	de
 691++71B2 ~            	rst		8
 692++71B2 ~            	defb	56			;close channel (52) or detroy channel (56)
 693++71B2 ~            	pop		de
 694++71B2 ~            	ret
 695++71B2 ~            IF1FileLoadEnd:
 696++71B2 ~
 697++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++71B2 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++71B2 ~            ;Out: A = error code, 0=OK
 700++71B2 ~            ReadDiskSectors:
 701++71B2 ~            	push bc
 702++71B2 ~            		push hl
 703++71B2 ~            			push de
 704++71B2 ~            				call ReadOneDiskSector
 705++71B2 ~            			pop de
 706++71B2 ~            		pop hl
 707++71B2 ~
 708++71B2 ~            		inc d
 709++71B2 ~            		inc h
 710++71B2 ~            	pop bc
 711++71B2 ~
 712++71B2 ~            	ld	a, (RWTSRes)
 713++71B2 ~            	or	a
 714++71B2 ~            	ret nz
 715++71B2 ~
 716++71B2 ~            	djnz ReadDiskSectors
 717++71B2 ~            	ret
 718++71B2 ~
 719++71B2 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++71B2 ~            ;Out: A = error code, 0=OK
 721++71B2 ~            WriteDiskSectors:
 722++71B2 ~            	push bc
 723++71B2 ~            		push hl
 724++71B2 ~            			push de
 725++71B2 ~            				call WriteOneDiskSector
 726++71B2 ~            			pop de
 727++71B2 ~            		pop hl
 728++71B2 ~
 729++71B2 ~            		inc d
 730++71B2 ~            		inc h
 731++71B2 ~            	pop bc
 732++71B2 ~
 733++71B2 ~            	ld	a, (RWTSRes)
 734++71B2 ~            	or	a
 735++71B2 ~            	ret nz
 736++71B2 ~
 737++71B2 ~            	djnz WriteDiskSectors
 738++71B2 ~            	ret
 739++71B2 ~
 740++71B2 ~
 741++71B2 ~            ;Reads disk catalog
 742++71B2 ~            ReadCatalogTrack:
 743++71B2 ~            	ld hl, TrackBuf
 744++71B2 ~            	ld de, 0
 745++71B2 ~            	ld b, SPT
 746++71B2 ~
 747++71B2 ~            	call ReadDiskSectors
 748++71B2 ~            	or   a
 749++71B2 ~            	ret  nz
 750++71B2 ~
 751++71B2 ~            	;Sync with BDOS, to avoid disk R/O error on disk change
 752++71B2 ~            	push  af
 753++71B2 ~            		ld  a, (RWTSDrive)
 754++71B2 ~            		call BDOSSelectDisk
 755++71B2 ~            		call BDOSInit
 756++71B2 ~            	pop   af
 757++71B2 ~            	ret
 758++71B2 ~
 759++71B2 ~
 760++71B2 ~
 761++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 762++71B2 ~
 763++71B2 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 764++71B2 ~            FindCache:
 765++71B2 ~            	ld		b, NAMELEN
 766++71B2 ~            	call	StrCmp			;find the file to wich this extension belongs
 767++71B2 ~            	ret		z
 768++71B2 ~
 769++71B2 ~            	dec		c
 770++71B2 ~            	jr		nz, CacheNotFinished
 771++71B2 ~            	or		c
 772++71B2 ~            	ret
 773++71B2 ~
 774++71B2 ~            CacheNotFinished:
 775++71B2 ~            	ld		bc, CACHE_SZ
 776++71B2 ~            	add		hl, bc			;to the next cache line
 777++71B2 ~            	jr		FindCache
 778++71B2 ~
 779++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 780++71B2 ~
 781++71B2 ~            	;ld		ix, (SelFileCache)
 782++71B2 ~            ReadFileHeader:
 783++71B2 ~            	ld		a, (ix + CACHE_FLAG)
 784++71B2 ~            	or		a
 785++71B2 ~            	ret		nz				;return if already read
 786++71B2 ~
 787++71B2 ~            	ld		l, (ix + CACHE_FIRST_AU)
 788++71B2 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 789++71B2 ~            	ld		a, h
 790++71B2 ~            	or		l
 791++71B2 ~            	jr		z, ReadHeaderEnd
 792++71B2 ~
 793++71B2 ~            	call	AU2TS
 794++71B2 ~            	ld		d, b
 795++71B2 ~            	ld		e, c
 796++71B2 ~            	ld		hl, DataBuf
 797++71B2 ~            	push	ix
 798++71B2 ~            	push	ix
 799++71B2 ~            		call	ReadOneDiskSector
 800++71B2 ~            	pop		hl
 801++71B2 ~            	pop		ix
 802++71B2 ~
 803++71B2 ~            	push	hl
 804++71B2 ~            		ld		hl, DataBuf
 805++71B2 ~            		call	IsFileHeaderValid
 806++71B2 ~            	pop		hl
 807++71B2 ~            	or		a
 808++71B2 ~            	jr		z, ReadFileHeaderIsTextFile
 809++71B2 ~
 810++71B2 ~            	ld		bc, CACHE_HDR
 811++71B2 ~            	add		hl, bc
 812++71B2 ~            	ex		hl, de
 813++71B2 ~            	ld		hl, DataBuf
 814++71B2 ~            	ld		bc, HDR_SZ
 815++71B2 ~            	ldir
 816++71B2 ~
 817++71B2 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 818++71B2 ~            	ld		a, BYTE_TYPE
 819++71B2 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 820++71B2 ~            	jr		nc, ReadHeaderEnd
 821++71B2 ~
 822++71B2 ~            ReadFileHeaderIsTextFile:
 823++71B2 ~            	push	ix
 824++71B2 ~            	push	ix
 825++71B2 ~            	pop		hl
 826++71B2 ~            		call	GetFileSize
 827++71B2 ~            	pop		ix
 828++71B2 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 829++71B2 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 830++71B2 ~            	ld		a, TEXT_TYPE
 831++71B2 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 832++71B2 ~
 833++71B2 ~            ReadHeaderEnd:
 834++71B2 ~            	inc		(ix + CACHE_FLAG)
 835++71B2 ~            	ret
 836++71B2 ~
 837++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 838++71B2 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 839++71B2 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 840++71B2 ~            ;In: HL = header
 841++71B2 ~            ;Out: A > 0 if valid
 842++71B2 ~            IsFileHeaderValid:
 843++71B2 ~            	IFUSED
 844++71B2 ~            	xor		a
 845++71B2 ~            	ld		b, HDR_SZ
 846++71B2 ~            IsFileHeaderValidLoop:
 847++71B2 ~            	or		(hl)
 848++71B2 ~            	inc		hl
 849++71B2 ~            	djnz	IsFileHeaderValidLoop
 850++71B2 ~
 851++71B2 ~            	ret
 852++71B2 ~            	ENDIF
 853++71B2 ~
 854++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 855++71B2 ~
 856++71B2 ~            ;IN: HL = address from IF1 to call
 857++71B2 ~            IF1Call:
 858++71B2 ~            	LD   (HD11), HL
 859++71B2 ~            	RST  8
 860++71B2 ~            	DEFB 50
 861++71B2 ~            	RET
 862++71B2 ~
 863++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 864++71B2 ~
 865++71B2 ~            ;Load a program from disk
 866++71B2 ~            ;IN: HL = file name addr
 867++71B2 ~            LoadProgram:
 868++71B2 ~            	LD   (FSTR1), HL
 869++71B2 ~            	LD   H, 0
 870++71B2 ~            	LD   L, NAMELEN
 871++71B2 ~            	LD   (NSTR1), HL
 872++71B2 ~            	LD	 A, (RWTSDrive)
 873++71B2 ~            	INC  A					;Adapt for BASIC drive number
 874++71B2 ~            	LD   L, A
 875++71B2 ~            	LD   (DSTR1), HL
 876++71B2 ~            	LD   HL, LOAD_ADDR
 877++71B2 ~            	CALL IF1Call
 878++71B2 ~            	RET
 879++71B2 ~
 880++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 881++71B2 ~
 882++71B2 ~            SetFastKeys:
 883++71B2 ~            	ld		hl, REPDEL
 884++71B2 ~            	ld		de, (1 << 8) | 15
 885++71B2 ~            	ld		(hl), de
 886++71B2 ~
 887++71B2 ~            	ret
 888++71B2 ~
 889++71B2 ~
 890++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 891++71B2 ~            ;Reads the error message string from IF1 ROM.
 892++71B2 ~            GetErrMsg:
 893++71B2 ~            	inc		a
 894++71B2 ~            	ex		af, af'
 895++71B2 ~
 896++71B2 ~            	ld		hl, IF1Paged			;page-in IF1
 897++71B2 ~            	jp		IF1Call
 898++71B2 ~
 899++71B2 ~            IF1Paged:
 900++71B2 ~            	ld		hl, ERRMSG
 901++71B2 ~            	ex		af, af'
 902++71B2 ~            	or		a
 903++71B2 ~            	jr		z, SaveMsg
 904++71B2 ~
 905++71B2 ~            	ld		b, 0
 906++71B2 ~            SearchMsgEnd:
 907++71B2 ~            	bit		7, (hl)
 908++71B2 ~            	inc		hl
 909++71B2 ~            	jr		z, SearchMsgEnd
 910++71B2 ~
 911++71B2 ~            	inc		b
 912++71B2 ~            	cp		b
 913++71B2 ~            	jr		nz, SearchMsgEnd
 914++71B2 ~
 915++71B2 ~            SaveMsg:
 916++71B2 ~            	ld		de, DataBuf
 917++71B2 ~            CopyMsg:
 918++71B2 ~            	ld		a, (hl)
 919++71B2 ~            	bit		7, a
 920++71B2 ~            	ld		(de), a
 921++71B2 ~            	inc		hl
 922++71B2 ~            	inc		de
 923++71B2 ~            	jr		z, CopyMsg
 924++71B2 ~
 925++71B2 ~            	ret
 926++71B2 ~
 927++71B2 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 928++71B2 ~
 929++71B2 ~            ;RWTS routine I/O block
 930++71B2 ~            RWTSParams:
 931++71B2 ~            RWTSBlockType	DEFB	1							;?
 932++71B2 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 933++71B2 ~            RWTSVolNo		DEFB	0							;?
 934++71B2 ~            RWTSTrack		DEFB	0
 935++71B2 ~            RWTSSector		DEFB	0
 936++71B2 ~            RWTSDMA			DEFW	0
 937++71B2 ~            RWTSExtBuf		DEFW	$2932
 938++71B2 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 939++71B2 ~            	IFDEF _REAL_HW_
 940++71B2 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 941++71B2 ~            	ELSE
 942++71B2 ~            RWTSPrmTbl		DEFW	$1f2a
 943++71B2 ~            	ENDIF
 944++71B2 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 945++71B2 ~            ;Results
 946++71B2 ~            RWTSRes			DEFB	0
 947++71B2 ~            RWTSResVolNo	DEFB	0
 948++71B2 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 949++71B2 ~
 950++71B2 ~            ;Param. table, usualy found in ROM.
 951++71B2 ~            	IFDEF _REAL_HW_
 952++71B2 ~            BasPrmTbl:
 953++71B2 ~            PrmDevType		DEFB	$01		;$01
 954++71B2 ~            PrmStepRate		DEFB	$01		;$0D	(milisec)
 955++71B2 ~            PrmHeadLoad		DEFB	$01		;$23	(milisec)
 956++71B2 ~            PrmSpinUp		DEFB	$01		;$64	(1/100 sec)
 957++71B2 ~            PrmIntrlvTbl	DEFW	InterleaveTbl
 958++71B2 ~            InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 959++71B2 ~            	ENDIF
 960++71B2 ~
 961++71B2              	endif
# file closed: if1.asm
   7+ 71B2
   8+ 71B2              BDOSInit:
   9+ 71B2 AF           	xor		a
  10+ 71B3 18 45        	jr		BDOS
  11+ 71B5
  12+ 71B5
  13+ 71B5              ;IN: A = Drive to select
  14+ 71B5              BDOSSelectDisk:
  15+ 71B5              	IFUSED
  16+ 71B5 DD 6F        	ld		ixl, a
  17+ 71B7 DD 26 00     	ld		ixh, 0
  18+ 71BA 3E 01        	ld		a, 1
  19+ 71BC 18 3C        	jr		BDOS
  20+ 71BE              	ENDIF
  21+ 71BE
  22+ 71BE
  23+ 71BE              BDOSMakeDiskRO:
  24+ 71BE              	IFUSED
  25+ 71BE ~            	ld		a, 15
  26+ 71BE ~            	jr		BDOS
  27+ 71BE              	ENDIF
  28+ 71BE
  29+ 71BE              ;Get Read Only flag
  30+ 71BE              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 71BE              BDOSGetDiskRO:
  32+ 71BE              	IFUSED
  33+ 71BE ~            	ld	a, 16
  34+ 71BE ~            	jr	BDOS
  35+ 71BE              	ENDIF
  36+ 71BE
  37+ 71BE              BDOSGetCurrentDisk:
  38+ 71BE              	IFUSED
  39+ 71BE ~            	ld		a, 12
  40+ 71BE ~            	jr		BDOS
  41+ 71BE              	ENDIF
  42+ 71BE
  43+ 71BE
  44+ 71BE              ;Create a disk channel for BDOS access (does not open the file)
  45+ 71BE              ;IN: HL=name addr, A=drive
  46+ 71BE              ;OUT: IX=FCB
  47+ 71BE              CreateChannel:
  48+ 71BE 22 DC 5C     	ld (FSTR1), hl
  49+ 71C1 26 00        	ld h,0
  50+ 71C3 6F           	ld l,a
  51+ 71C4 22 D6 5C     	ld (DSTR1), hl
  52+ 71C7 2E 0B        	ld l,NAMELEN
  53+ 71C9 22 DA 5C     	ld (NSTR1), hl
  54+ 71CC CF           	rst 08
  55+ 71CD 37           	DEFB 55
  56+ 71CE 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  57+ 71D1 DD 09        	add ix, bc
  58+ 71D3 C9           	ret
  59+ 71D4
  60+ 71D4
  61+ 71D4              ;Destroy a BDOS channel
  62+ 71D4              ;IN: IX=FCB
  63+ 71D4              DestroyChannel:
  64+ 71D4 C5           	push bc
  65+ 71D5 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  66+ 71D8 DD 09        	add ix, bc
  67+ 71DA CF           	rst 08
  68+ 71DB 38           	DEFB 56
  69+ 71DC C1           	pop bc
  70+ 71DD C9           	ret
  71+ 71DE
  72+ 71DE
  73+ 71DE              ;Input: IX=FCB
  74+ 71DE              BDOSCreateFile:
  75+ 71DE 3E 09        	ld	a, 9
  76+ 71E0 18 18        	jr	BDOS
  77+ 71E2
  78+ 71E2              ;Input: IX=FCB
  79+ 71E2              BDOSOpenFile:
  80+ 71E2 3E 02        	ld	a, 2
  81+ 71E4 18 14        	jr	BDOS
  82+ 71E6
  83+ 71E6              ;IN: IX=FCB
  84+ 71E6              BDOSCloseFile:
  85+ 71E6 3E 03        	ld	a, 3
  86+ 71E8 18 10        	jr	BDOS
  87+ 71EA
  88+ 71EA
  89+ 71EA              ;0 OK,
  90+ 71EA              ;1 end of file,
  91+ 71EA              ;9 invalid FCB,
  92+ 71EA              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
  93+ 71EA              ;11 (MP/M) unlocked file verification error,
  94+ 71EA              ;0FFh hardware error.
  95+ 71EA
  96+ 71EA              ;IN: IX=FCB
  97+ 71EA              BDOSReadFileBlockSeq:
  98+ 71EA 3E 07        	ld	a, 7
  99+ 71EC 18 0C        	jr	BDOS
 100+ 71EE
 101+ 71EE
 102+ 71EE              ;0 OK,
 103+ 71EE              ;1 directory full,
 104+ 71EE              ;2 disc full,
 105+ 71EE              ;8 (MP/M) record locked by another process,
 106+ 71EE              ;9 invalid FCB,
 107+ 71EE              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 108+ 71EE              ;11 (MP/M) unlocked file verification error,
 109+ 71EE              ;0FFh hardware error.
 110+ 71EE
 111+ 71EE              ;IN: IX=FCB
 112+ 71EE              BDOSWriteFileBlockSeq:
 113+ 71EE 3E 08        	ld	a, 8
 114+ 71F0 18 08        	jr	BDOS
 115+ 71F2
 116+ 71F2
 117+ 71F2              ;0 OK
 118+ 71F2              ;1 Reading unwritten data
 119+ 71F2              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 120+ 71F2              ;6 Record number out of range
 121+ 71F2              ;9 Invalid FCB
 122+ 71F2              BDOSReadFileBlockRandom:
 123+ 71F2 3E 12        	ld	a, 18
 124+ 71F4 18 04        	jr	BDOS
 125+ 71F6
 126+ 71F6              ;0 OK
 127+ 71F6              ;2 Disc full
 128+ 71F6              ;3 Cannot close extent
 129+ 71F6              ;5 Directory full
 130+ 71F6              ;6 Record number out of range
 131+ 71F6              ;8 Record is locked by another process (MP/M)
 132+ 71F6              ;9 Invalid FCB
 133+ 71F6              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 134+ 71F6              BDOSWriteFileBlockRandom:
 135+ 71F6 3E 13        	ld	a, 19
 136+ 71F8 18 00        	jr	BDOS
 137+ 71FA
 138+ 71FA
 139+ 71FA              ;Generic BDOS call
 140+ 71FA              ;IX=arg, A=function
 141+ 71FA              BDOS:
 142+ 71FA DD 22 ED 5C  	ld (HD11), ix
 143+ 71FE 32 EF 5C     	ld (COPIES), a
 144+ 7201 CF           	rst 08
 145+ 7202 39           	DEFB 57
 146+ 7203 C9           	ret
 147+ 7204
 148+ 7204              ;Set DMA address for BDOS
 149+ 7204              ;IX=DMA
 150+ 7204              BDOSSetDMA:
 151+ 7204 3E 0D        	ld a, 13
 152+ 7206 18 F2        	jr BDOS
 153+ 7208
 154+ 7208              ;In: IX=FCB
 155+ 7208              BDOSSetRandFilePtr:
 156+ 7208 3E 15        	ld	a, 21
 157+ 720A 18 EE        	jr	BDOS
 158+ 720C
 159+ 720C              ;In: HL=filename
 160+ 720C              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 161+ 720C              GetFileSize:
 162+ 720C              	IFUSED
 163+ 720C
 164+ 720C 3A 8A 71     	ld 		a, (RWTSDrive)
 165+ 720F 3C           	inc		a					;Convert to BASIC drive number: 1,2
 166+ 7210 CD BE 71     	call	CreateChannel
 167+ 7213
 168+ 7213 3E 14        	ld		a, 20
 169+ 7215 CD FA 71     	call	BDOS
 170+ 7218              	;inc		a
 171+ 7218              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 172+ 7218
 173+ 7218 DD 6E 21     	ld		l, (ix + FCB_R0)
 174+ 721B DD 66 22     	ld		h, (ix + FCB_R1)
 175+ 721E
 176+ 721E              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 177+ 721E 3E 01        	ld		a, 1
 178+ 7220 BC           	cp		h
 179+ 7221 30 05        	jr		nc, GetFileSizeOK
 180+ 7223 21 00 00     	ld		hl, 0
 181+ 7226 18 08        	jr		GetFileSizeEnd
 182+ 7228
 183+ 7228              GetFileSizeOK:
 184+ 7228              	;*128 == 2^7
 185+ 7228 06 07        	ld		b, 7
 186+ 722A              GetFileSizeMul:
 187+ 722A CB 15        	rl		l
 188+ 722C CB 14        	rl		h
 189+ 722E 10 FA        	djnz	GetFileSizeMul
 190+ 7230
 191+ 7230              GetFileSizeEnd:
 192+ 7230 E5           	push	hl
 193+ 7231 CD D4 71     		call	DestroyChannel
 194+ 7234 E1           	pop		hl
 195+ 7235
 196+ 7235 C9           	ret
 197+ 7236              	ENDIF
 198+ 7236
 199+ 7236              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 200+ 7236              ;HL=file name, A=drive
 201+ 7236              DeleteFile:
 202+ 7236 CD BE 71     	call	CreateChannel
 203+ 7239
 204+ 7239 3E 06        	ld		a, 6
 205+ 723B CD FA 71     	call	BDOS
 206+ 723E
 207+ 723E CD D4 71     	call	DestroyChannel
 208+ 7241 C9           	ret
 209+ 7242
 210+ 7242              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 211+ 7242              ;Returns A >= 0 if the file exists, returns $FF on error.
 212+ 7242              ;HL=file name, A=drive
 213+ 7242              DoesFileExist:
 214+ 7242              	IFUSED
 215+ 7242              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 216+ 7242 F5           	push	af
 217+ 7243 E5           	push	hl
 218+ 7244 DD 21 FE F6  		ld		ix, FileIdx
 219+ 7248 CD 04 72     		call 	BDOSSetDMA
 220+ 724B E1           	pop		hl
 221+ 724C F1           	pop		af
 222+ 724D
 223+ 724D CD BE 71     	call	CreateChannel
 224+ 7250
 225+ 7250              	;Uses FindFirst system call.
 226+ 7250 3E 04        	ld		a, 4
 227+ 7252 CD FA 71     	call	BDOS
 228+ 7255
 229+ 7255 F5           	push	af
 230+ 7256 CD D4 71     		call	DestroyChannel
 231+ 7259 F1           	pop		af
 232+ 725A C9           	ret
 233+ 725B              	ENDIF
 234+ 725B
 235+ 725B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 236+ 725B              ;IN: E0 = RO, E1 = SYS, HL=filename
 237+ 725B              ChangeFileAttrib:
 238+ 725B 3A 8A 71     	ld 		a, (RWTSDrive)
 239+ 725E 3C           	inc		a					;Convert to BASIC drive number: 1,2
 240+ 725F D5           	push	de
 241+ 7260 CD BE 71     	call	CreateChannel
 242+ 7263 D1           	pop		de
 243+ 7264
 244+ 7264 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 245+ 7267 CB 27        	sla		a								;reset existing attribute flag
 246+ 7269 CB 1B        	rr		e								;put wanted flag in Carry flag
 247+ 726B CB 1F        	rr		a								;put Carry flag in register L
 248+ 726D DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 249+ 7270
 250+ 7270 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 251+ 7273 CB 27        	sla		a
 252+ 7275 CB 1B        	rr		e
 253+ 7277 CB 1F        	rr		a
 254+ 7279 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 255+ 727C
 256+ 727C              FileAttribSet:
 257+ 727C 3E 11        	ld		a, 17
 258+ 727E CD FA 71     	call	BDOS
 259+ 7281
 260+ 7281 CD D4 71     	call	DestroyChannel
 261+ 7284 C9           	ret
 262+ 7285
 263+ 7285              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 264+ 7285
 265+ 7285              ;HL=original name, DE = new name
 266+ 7285              ;Works only on the same drive.
 267+ 7285              RenameFile:
 268+ 7285 3A 8A 71     	ld 		a, (RWTSDrive)
 269+ 7288 3C           	inc		a					;Convert to BASIC drive number: 1,2
 270+ 7289 D5           	push	de
 271+ 728A CD BE 71     	call	CreateChannel
 272+ 728D D1           	pop		de
 273+ 728E
 274+ 728E DD E5        	push	ix					;IX == FCB
 275+ 7290 E1           	pop		hl
 276+ 7291 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 277+ 7294 09           	add		hl, bc
 278+ 7295 EB           	ex		de, hl
 279+ 7296 3A 8A 71     	ld		a, (RWTSDrive)
 280+ 7299 12           	ld		(de), a
 281+ 729A 01 0B 00     	ld		bc, NAMELEN
 282+ 729D ED B0        	ldir
 283+ 729F
 284+ 729F 3E 0A        	ld		a, 10
 285+ 72A1 CD FA 71     	call	BDOS
 286+ 72A4
 287+ 72A4 CD D4 71     	call	DestroyChannel
 288+ 72A7 C9           	ret
 289+ 72A8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 290+ 72A8              PromptDiskChangeDst:
 291+ 72A8 21 88 7E     	ld		hl, MsgInsertDstDsk
 292+ 72AB 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 293+ 72AE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 294+ 72B0 CD 58 76     	call	PrintStrClr
 295+ 72B3 21 97 7E     	ld		hl, MsgPressAnyKey
 296+ 72B6 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 297+ 72B9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 298+ 72BB CD 58 76     	call	PrintStrClr
 299+ 72BE CD F4 75     	call	ReadChar
 300+ 72C1 C9           	ret
 301+ 72C2
 302+ 72C2              PromptDiskChangeSrc:
 303+ 72C2 21 79 7E     	ld		hl, MsgInsertSrcDsk
 304+ 72C5 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 305+ 72C8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 306+ 72CA CD 58 76     	call	PrintStrClr
 307+ 72CD 21 97 7E     	ld		hl, MsgPressAnyKey
 308+ 72D0 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 309+ 72D3 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 310+ 72D5 CD 58 76     	call	PrintStrClr
 311+ 72D8 CD F4 75     	call	ReadChar
 312+ 72DB C9           	ret
 313+ 72DC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 314+ 72DC
 315+ 72DC              ;HL = source file name, A = source drive
 316+ 72DC              ;Use cases:
 317+ 72DC              ;1. Copy from A: to B: or B: to A:.
 318+ 72DC              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 319+ 72DC              ;3. Copy from A:/B: to COM.
 320+ 72DC              ;4. Copy from COM to A:/B:.
 321+ 72DC              ;Single drive scenario:
 322+ 72DC              ;1. Read first file part,
 323+ 72DC              ;2. Ask for dest disk,
 324+ 72DC              ;3. check if file exists/ask for overwrite,
 325+ 72DC              ;4. create empty dest file,
 326+ 72DC              ;5. write first file part,
 327+ 72DC              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 328+ 72DC              CopyFile:
 329+ 72DC 3A 8A 71     	ld 		a, (RWTSDrive)
 330+ 72DF 3C           	inc		a					;Convert to BASIC drive number: 1,2
 331+ 72E0 32 C8 7E     	ld		(CopyFileSrcDrv), a
 332+ 72E3 32 D4 7E     	ld		(CopyFileDstDrv), a
 333+ 72E6 11 C9 7E     	ld		de, CopyFileSrcName
 334+ 72E9 01 0B 00     	ld		bc, NAMELEN
 335+ 72EC E5           	push	hl
 336+ 72ED C5           	push	bc
 337+ 72EE ED B0        	ldir
 338+ 72F0 C1           	pop		bc
 339+ 72F1 E1           	pop		hl
 340+ 72F2 11 D5 7E     	ld		de, CopyFileDstName
 341+ 72F5 ED B0        	ldir
 342+ 72F7
 343+ 72F7              	;Reset R/O attribute for destination, to allow file write.
 344+ 72F7 3A DD 7E     	ld		a, (CopyFileDstName+RO_POS)
 345+ 72FA CB BF        	res		7, a
 346+ 72FC 32 DD 7E     	ld		(CopyFileDstName+RO_POS), a
 347+ 72FF
 348+ 72FF AF           	xor		a
 349+ 7300 32 C0 7E     	ld		(CopyFileRes), a
 350+ 7303 11 00 00     	ld		de, 0
 351+ 7306 ED 53 C3 7E  	ld		(FilePosRead), de
 352+ 730A ED 53 C5 7E  	ld		(FilePosWrite), de
 353+ 730E
 354+ 730E 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 355+ 7311 C6 40        	add		'A'-1
 356+ 7313              	;Update menu messages with current drive.
 357+ 7313 32 01 7E     	ld		(MsgMenuSingleDrv1), a
 358+ 7316 32 05 7E     	ld		(MsgMenuSingleDrv2), a
 359+ 7319 32 0F 7E     	ld		(MsgMenuDualDrv1), a
 360+ 731C 32 1D 7E     	ld		(MsgMenuToComDrv), a
 361+ 731F 32 31 7E     	ld		(MsgMenuFromCOMDrv), a
 362+ 7322              	;Update menu messages with the alternate drive.
 363+ 7322 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 364+ 7325 EE 03        	xor		%11
 365+ 7327 C6 40        	add		'A'-1
 366+ 7329 32 13 7E     	ld		(MsgMenuDualDrv2), a
 367+ 732C
 368+ 732C 21 DE 7D     	ld		hl, MsgMenuFileCopy
 369+ 732F 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 370+ 7332 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371+ 7334 CD 58 76     	call	PrintStrClr
 372+ 7337 21 ED 7D     	ld		hl, MsgMenuBack
 373+ 733A 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 374+ 733D CD 30 76     	call	PrintStr
 375+ 7340 21 F9 7D     	ld		hl, MsgMenuSingle
 376+ 7343 11 00 11     	ld		de, LST_LINE_MSG + 3 << 8
 377+ 7346 CD 30 76     	call	PrintStr
 378+ 7349 21 07 7E     	ld		hl, MsgMenuDual
 379+ 734C 11 00 12     	ld		de, LST_LINE_MSG + 4 << 8
 380+ 734F CD 30 76     	call	PrintStr
 381+ 7352 21 15 7E     	ld		hl, MsgMenuToCOM
 382+ 7355 11 00 13     	ld		de, LST_LINE_MSG + 5 << 8
 383+ 7358 CD 30 76     	call	PrintStr
 384+ 735B 21 24 7E     	ld		hl, MsgMenuFromCOM
 385+ 735E 11 00 14     	ld		de, LST_LINE_MSG + 6 << 8
 386+ 7361 CD 30 76     	call	PrintStr
 387+ 7364
 388+ 7364 CD F4 75     	call	ReadChar
 389+ 7367 32 BD 7E     	ld		(CopySelOption), a
 390+ 736A
 391+ 736A F5           	push	af
 392+ 736B 06 06        		ld		b, 6
 393+ 736D CD DC 77     		call	ClearNMsgLines
 394+ 7370 F1           	pop		af
 395+ 7371
 396+ 7371              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 397+ 7371 FE 30        	cp		'0'
 398+ 7373 20 04        	jr		nz, CopyFileNotExit
 399+ 7375 E1           	pop		hl
 400+ 7376 C3 FF 66     	jp		ReadKeyLoop
 401+ 7379
 402+ 7379              CopyFileNotExit:
 403+ 7379 FE 31        	cp		'1'
 404+ 737B 28 4D        	jr		z, CopyFileSameDrive
 405+ 737D
 406+ 737D FE 32        	cp		'2'
 407+ 737F CA 45 74     	jp		z, CopyFileDualDrive
 408+ 7382
 409+ 7382 FE 33        	cp		'3'
 410+ 7384 CA 8D 74     	jp		z, CopyFileToCOM
 411+ 7387
 412+ 7387 FE 34        	cp		'4'
 413+ 7389 CA BE 74     	jp		z, CopyFileFromCOM
 414+ 738C
 415+ 738C E1           	pop		hl
 416+ 738D C3 FF 66     	jp		ReadKeyLoop
 417+ 7390
 418+ 7390
 419+ 7390              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 420+ 7390              CopyFileCheckOverwrite:
 421+ 7390              	;Check if destination file exists.
 422+ 7390 3A D4 7E     	ld		a, (CopyFileDstDrv)
 423+ 7393 21 D5 7E     	ld		hl, CopyFileDstName
 424+ 7396 CD 42 72     	call	DoesFileExist
 425+ 7399 3C           	inc		a
 426+ 739A C8           	ret		z						;return Z=1 when file doesn't exist
 427+ 739B
 428+ 739B              	;Ask overwrite confirmation.
 429+ 739B 21 5B 7E     	ld		hl, MsgFileOverwrite
 430+ 739E 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 431+ 73A1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 432+ 73A3 CD 58 76     	call	PrintStrClr
 433+ 73A6 CD F4 75     	call	ReadChar
 434+ 73A9 FE 79        	cp		'y'
 435+ 73AB C9           	ret								;return Z=1 when user confirmed file overwrite
 436+ 73AC
 437+ 73AC
 438+ 73AC              CopyFileCreateNewFile:
 439+ 73AC 3A D4 7E     	ld		a, (CopyFileDstDrv)
 440+ 73AF 21 D5 7E     	ld		hl, CopyFileDstName
 441+ 73B2 F5           	push	af
 442+ 73B3 E5           	push	hl
 443+ 73B4 CD 36 72     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 444+ 73B7 E1           	pop		hl
 445+ 73B8 F1           	pop		af
 446+ 73B9 CD BE 71     	call	CreateChannel
 447+ 73BC CD DE 71     	call 	BDOSCreateFile
 448+ 73BF 3C           	inc  	a						;Cancel if A==$FF
 449+ 73C0 C8           	ret		z
 450+ 73C1
 451+ 73C1              	;Close dest file once created.
 452+ 73C1 F5           	push	af
 453+ 73C2 CD E6 71     		call	BDOSCloseFile
 454+ 73C5 CD D4 71     		call	DestroyChannel
 455+ 73C8 F1           	pop		af
 456+ 73C9 C9           	ret
 457+ 73CA
 458+ 73CA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 459+ 73CA              CopyFileSameDrive:
 460+ 73CA              	;Read first file section from SRC.
 461+ 73CA 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 462+ 73CD 21 C9 7E     	ld		hl, CopyFileSrcName
 463+ 73D0 CD 41 75     	call	ReadFileSection
 464+ 73D3 3A C7 7E     	ld		a, (CopyFileSectCnt)
 465+ 73D6 B7           	or		a
 466+ 73D7 C8           	ret		z
 467+ 73D8
 468+ 73D8              	;Prompt for DST disk change.
 469+ 73D8 CD A8 72     	call	PromptDiskChangeDst
 470+ 73DB 3A 8A 71     	ld		a, (RWTSDrive)
 471+ 73DE CD B2 71     	call	BDOSInit
 472+ 73E1
 473+ 73E1 06 02        	ld		b, 2
 474+ 73E3 CD DC 77     	call	ClearNMsgLines
 475+ 73E6
 476+ 73E6 CD 90 73     	call	CopyFileCheckOverwrite
 477+ 73E9 C0           	ret		nz
 478+ 73EA
 479+ 73EA CD AC 73     	call	CopyFileCreateNewFile
 480+ 73ED C8           	ret		z
 481+ 73EE
 482+ 73EE              CopyFileSameDriveLoop:
 483+ 73EE 3A C7 7E     	ld		a, (CopyFileSectCnt)
 484+ 73F1 6F           	ld		l, a
 485+ 73F2 26 00        	ld		h, 0
 486+ 73F4 11 A4 7E     	ld		de, MsgCopySectors
 487+ 73F7 CD 55 6D     	call	Byte2Txt
 488+ 73FA 21 A4 7E     	ld		hl, MsgCopySectors
 489+ 73FD 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 490+ 7400 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 491+ 7402 CD 58 76     	call	PrintStrClr
 492+ 7405
 493+ 7405 3A C0 7E     	ld		a, (CopyFileRes)			;Save read status code.
 494+ 7408 F5           	push	af
 495+ 7409 3A D4 7E     		ld		a, (CopyFileDstDrv)
 496+ 740C 21 D5 7E     		ld		hl, CopyFileDstName
 497+ 740F CD 63 75     		call	WriteFileSection
 498+ 7412 3A C0 7E     		ld		a, (CopyFileRes)
 499+ 7415 6F           		ld		l, a
 500+ 7416 F1           	pop		af
 501+ 7417 B5           	or		l
 502+ 7418 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 503+ 7419
 504+ 7419
 505+ 7419              	;Prompt for SRC disk change.
 506+ 7419 CD C2 72     	call	PromptDiskChangeSrc
 507+ 741C 3A 8A 71     	ld		a, (RWTSDrive)
 508+ 741F CD B2 71     	call	BDOSInit
 509+ 7422
 510+ 7422 06 02        	ld		b, 2
 511+ 7424 CD DC 77     	call	ClearNMsgLines
 512+ 7427
 513+ 7427 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 514+ 742A 21 C9 7E     	ld		hl, CopyFileSrcName
 515+ 742D CD 41 75     	call	ReadFileSection
 516+ 7430 3A C7 7E     	ld		a, (CopyFileSectCnt)
 517+ 7433 B7           	or		a
 518+ 7434 C8           	ret		z
 519+ 7435
 520+ 7435              	;Prompt for DST disk change.
 521+ 7435 CD A8 72     	call	PromptDiskChangeDst
 522+ 7438 3A 8A 71     	ld		a, (RWTSDrive)
 523+ 743B CD B2 71     	call	BDOSInit
 524+ 743E
 525+ 743E 06 02        	ld		b, 2
 526+ 7440 CD DC 77     	call	ClearNMsgLines
 527+ 7443
 528+ 7443 18 A9        	jr		CopyFileSameDriveLoop
 529+ 7445
 530+ 7445              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 531+ 7445
 532+ 7445              CopyFileDualDrive:
 533+ 7445 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 534+ 7448 EE 03        	xor		%11
 535+ 744A 32 D4 7E     	ld		(CopyFileDstDrv), a
 536+ 744D
 537+ 744D CD 90 73     	call	CopyFileCheckOverwrite
 538+ 7450 C0           	ret		nz
 539+ 7451
 540+ 7451 CD AC 73     	call	CopyFileCreateNewFile
 541+ 7454 C8           	ret		z
 542+ 7455
 543+ 7455              CopyFileDualDriveLoop:
 544+ 7455 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 545+ 7458 21 C9 7E     	ld		hl, CopyFileSrcName
 546+ 745B CD 41 75     	call	ReadFileSection
 547+ 745E 3A C7 7E     	ld		a, (CopyFileSectCnt)
 548+ 7461 B7           	or		a
 549+ 7462 C8           	ret		z
 550+ 7463
 551+ 7463 3A C7 7E     	ld		a, (CopyFileSectCnt)
 552+ 7466 6F           	ld		l, a
 553+ 7467 26 00        	ld		h, 0
 554+ 7469 11 A4 7E     	ld		de, MsgCopySectors
 555+ 746C CD 55 6D     	call	Byte2Txt
 556+ 746F 21 A4 7E     	ld		hl, MsgCopySectors
 557+ 7472 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 558+ 7475 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 559+ 7477
 560+ 7477 3A C0 7E     	ld		a, (CopyFileRes)
 561+ 747A F5           	push	af
 562+ 747B 3A D4 7E     		ld		a, (CopyFileDstDrv)
 563+ 747E 21 D5 7E     		ld		hl, CopyFileDstName
 564+ 7481 CD 63 75     		call	WriteFileSection
 565+ 7484 3A C0 7E     		ld		a, (CopyFileRes)
 566+ 7487 6F           		ld		l, a
 567+ 7488 F1           	pop		af
 568+ 7489 B5           	or		l
 569+ 748A C0           	ret		nz
 570+ 748B
 571+ 748B 18 C8        	jr		CopyFileDualDriveLoop
 572+ 748D
 573+ 748D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 574+ 748D              CopyFileToCOM:
 575+ 748D AF           	xor		a
 576+ 748E 32 C0 7E     	ld		(CopyFileRes), a
 577+ 7491 32 C7 7E     	ld		(CopyFileSectCnt), a
 578+ 7494 11 00 00     	ld		de, 0
 579+ 7497 ED 53 C3 7E  	ld		(FilePosRead), de
 580+ 749B
 581+ 749B              CopyFileToCOMLoop:
 582+ 749B 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 583+ 749E 21 C9 7E     	ld		hl, CopyFileSrcName
 584+ 74A1 CD 41 75     	call	ReadFileSection
 585+ 74A4
 586+ 74A4 3A C7 7E     	ld		a, (CopyFileSectCnt)
 587+ 74A7 B7           	or		a
 588+ 74A8 28 0F        	jr		z, CopyFileToCOMEnd
 589+ 74AA
 590+ 74AA              	;Send buffer to COM port.
 591+ 74AA 21 FE 8C     	ld		hl, FileData
 592+ 74AD 47           	ld		b, a					;Sector size is 256.
 593+ 74AE 0E 00        	ld		c, 0
 594+ 74B0 CD BB 7B     	call	SERTB
 595+ 74B3
 596+ 74B3 3A C0 7E     	ld		a, (CopyFileRes)
 597+ 74B6 B7           	or		a
 598+ 74B7 28 E2        	jr		z, CopyFileToCOMLoop
 599+ 74B9
 600+ 74B9              CopyFileToCOMEnd:
 601+ 74B9              	;Reset read error code, as 1 is returned when file is finished reading.
 602+ 74B9 AF           	xor		a
 603+ 74BA 32 C0 7E     	ld		(CopyFileRes), a
 604+ 74BD
 605+ 74BD C9           	ret
 606+ 74BE
 607+ 74BE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 608+ 74BE              CopyFileFromCOM:
 609+ 74BE AF           	xor		a
 610+ 74BF 32 C0 7E     	ld		(CopyFileRes), a
 611+ 74C2 11 00 00     	ld		de, 0
 612+ 74C5 ED 53 C5 7E  	ld		(FilePosWrite), de
 613+ 74C9
 614+ 74C9              	;Must ask for the new file name and check to not exist.
 615+ 74C9 21 C4 7D     	ld		hl, MsgNewFileName
 616+ 74CC 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 617+ 74CF 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 618+ 74D1 CD 58 76     	call	PrintStrClr
 619+ 74D4
 620+ 74D4 21 8F 7D     	ld		hl, MsgClear
 621+ 74D7 11 FE 8C     	ld		de, FileData
 622+ 74DA 01 0B 00     	ld		bc, NAMELEN
 623+ 74DD ED B0        	ldir
 624+ 74DF 3E A0        	ld		a, $80 | ' '
 625+ 74E1 12           	ld		(de), a
 626+ 74E2 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 627+ 74E5 21 FE 8C     	ld		hl, FileData
 628+ 74E8 CD 30 76     	call	PrintStr
 629+ 74EB
 630+ 74EB 11 00 10     	ld		de, LST_LINE_MSG + 2 << 8
 631+ 74EE 01 0B 00     	ld		bc, NAMELEN
 632+ 74F1 CD 9A 77     	call	ReadString
 633+ 74F4
 634+ 74F4 11 FE 8C     	ld		de, FileData
 635+ 74F7 1A           	ld		a, (de)
 636+ 74F8 FE 20        	cp		' '					;If starting with space, input was canceled.
 637+ 74FA C8           	ret		z
 638+ 74FB
 639+ 74FB              	;Copy new file name
 640+ 74FB 21 FE 8C     	ld		hl, FileData
 641+ 74FE 11 D5 7E     	ld		de, CopyFileDstName
 642+ 7501 01 0B 00     	ld		bc, NAMELEN
 643+ 7504 ED B0        	ldir
 644+ 7506
 645+ 7506              	;Check if new name doesn't exist already.
 646+ 7506 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 647+ 7509 21 D5 7E     	ld		hl, CopyFileDstName
 648+ 750C CD 90 73     	call	CopyFileCheckOverwrite
 649+ 750F C0           	ret		nz
 650+ 7510
 651+ 7510              	;Delete and re-create empty destination file
 652+ 7510 3A C8 7E     	ld		a, (CopyFileSrcDrv)
 653+ 7513 21 D5 7E     	ld		hl, CopyFileDstName
 654+ 7516 CD AC 73     	call	CopyFileCreateNewFile
 655+ 7519 C8           	ret		z
 656+ 751A
 657+ 751A              CopyFileFromCOMLoop:
 658+ 751A 21 FE 8C     	ld		hl, FileData
 659+ 751D 01 00 6A     	ld		bc, FileDataSize
 660+ 7520 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 661+ 7522 CD 88 7B     	call	SERRB				;BC = Number of bytes read from COM
 662+ 7525 79           	ld		a, c
 663+ 7526 B0           	or		b
 664+ 7527 C8           	ret		z
 665+ 7528
 666+ 7528              	;If C is not 0, add one more sector.
 667+ 7528 79           	ld 		a, c
 668+ 7529 B7           	or		a
 669+ 752A 28 01        	jr		z, CopyFileFromCOMDontInc
 670+ 752C 04           	inc		b
 671+ 752D              CopyFileFromCOMDontInc:
 672+ 752D 78           	ld		a, b				;Sector size is 256
 673+ 752E 32 C7 7E     	ld		(CopyFileSectCnt), a
 674+ 7531 3A D4 7E     	ld		a, (CopyFileDstDrv)
 675+ 7534 21 D5 7E     	ld		hl, CopyFileDstName
 676+ 7537 CD 63 75     	call	WriteFileSection
 677+ 753A
 678+ 753A 3A C0 7E     	ld		a, (CopyFileRes)
 679+ 753D B7           	or		a
 680+ 753E 28 DA        	jr		z, CopyFileFromCOMLoop
 681+ 7540
 682+ 7540 C9           	ret
 683+ 7541
 684+ 7541              ;Reads/Writes disk file portion to/from memory.
 685+ 7541              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 686+ 7541              ;This should work with single-drive file copy from one disk to another.
 687+ 7541              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records
 688+ 7541              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 689+ 7541              ;
 690+ 7541              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 691+ 7541              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 692+ 7541              ;Must use sequential read/write. But for the first operation must use random read/write.
 693+ 7541              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 694+ 7541              ReadFileSection:
 695+ 7541 11 F2 71     	ld		de, BDOSReadFileBlockRandom
 696+ 7544 ED 53 AB 75  	ld		(CopyFileOperAddr1), de
 697+ 7548 11 EA 71     	ld		de, BDOSReadFileBlockSeq
 698+ 754B ED 53 CA 75  	ld		(CopyFileOperAddr2), de
 699+ 754F 11 C3 7E     	ld		de, FilePosRead
 700+ 7552 ED 53 A2 75  	ld		(CopyFilePtr), de
 701+ 7556 ED 53 E6 75  	ld		(CopyFilePtr2), de
 702+ 755A
 703+ 755A              	;Limit max sectors to read to leave space for the index too.
 704+ 755A F5           	push	af
 705+ 755B 3E 6A        		ld		a, MAX_SECT_BUF
 706+ 755D 32 C7 7E     		ld		(CopyFileSectCnt), a
 707+ 7560 F1           	pop		af
 708+ 7561 18 19        	jr		ReadWriteFileSection
 709+ 7563
 710+ 7563              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 711+ 7563
 712+ 7563              WriteFileSection:
 713+ 7563 11 F6 71     	ld		de, BDOSWriteFileBlockRandom
 714+ 7566 ED 53 AB 75  	ld		(CopyFileOperAddr1), de
 715+ 756A 11 EE 71     	ld		de, BDOSWriteFileBlockSeq
 716+ 756D ED 53 CA 75  	ld		(CopyFileOperAddr2), de
 717+ 7571 11 C5 7E     	ld		de, FilePosWrite
 718+ 7574 ED 53 A2 75  	ld		(CopyFilePtr), de
 719+ 7578 ED 53 E6 75  	ld		(CopyFilePtr2), de
 720+ 757C
 721+ 757C
 722+ 757C              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 723+ 757C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 724+ 757C              ReadWriteFileSection:
 725+ 757C CD BE 71     	call	CreateChannel
 726+ 757F DD 22 BE 7E  	ld		(CopyFileFCB), ix
 727+ 7583 CD E2 71     	call 	BDOSOpenFile
 728+ 7586 3C           	inc  	a						;Cancel if A==$FF
 729+ 7587 C8           	ret		z
 730+ 7588
 731+ 7588              	;Set DMA initial pointer = FileData
 732+ 7588 DD E5        	push	ix
 733+ 758A 21 FE 8C     		ld		hl, FileData
 734+ 758D DD 21 C1 7E  		ld		ix, CopyFileDMAAddr
 735+ 7591 DD 75 00     		ld		(ix), l
 736+ 7594 DD 74 01     		ld		(ix+1), h
 737+ 7597 DD 21 FE 8C  		ld		ix, FileData
 738+ 759B CD 04 72     		call 	BDOSSetDMA
 739+ 759E DD E1        	pop		ix
 740+ 75A0
 741+ 75A0              CopyFilePtr EQU $+2
 742+ 75A0              	;Update file pointer using read/write random call.
 743+ 75A0 ED 5B C3 7E  	ld		de, (FilePosRead)
 744+ 75A4 DD 73 21     	ld		(ix + FCB_R0), e
 745+ 75A7 DD 72 22     	ld		(ix + FCB_R1), d
 746+ 75AA              CopyFileOperAddr1 EQU $ + 1
 747+ 75AA CD F2 71     	call 	BDOSReadFileBlockRandom
 748+ 75AD
 749+ 75AD 32 C0 7E     	ld		(CopyFileRes), a
 750+ 75B0 B7           	or		a
 751+ 75B1 20 22        	jr		nz, ReadWriteFileSectionEnd
 752+ 75B3
 753+ 75B3 3A C7 7E     	ld		a, (CopyFileSectCnt)
 754+ 75B6 47           	ld		b, a
 755+ 75B7
 756+ 75B7              ReadWriteFileSectionLoop:
 757+ 75B7 C5           	push	bc
 758+ 75B8 DD 2A C1 7E  		ld		ix, (CopyFileDMAAddr)
 759+ 75BC CD 04 72     		call 	BDOSSetDMA
 760+ 75BF DD 24        		inc		ixh
 761+ 75C1 DD 22 C1 7E  		ld		(CopyFileDMAAddr), ix
 762+ 75C5
 763+ 75C5 DD 2A BE 7E  		ld		ix, (CopyFileFCB)
 764+ 75C9              CopyFileOperAddr2 EQU $ + 1
 765+ 75C9 CD EA 71     		call 	BDOSReadFileBlockSeq
 766+ 75CC 32 C0 7E     		ld		(CopyFileRes), a
 767+ 75CF C1           	pop		bc
 768+ 75D0 B7           	or		a
 769+ 75D1 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 770+ 75D3 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 771+ 75D5
 772+ 75D5              ReadWriteFileSectionEnd:
 773+ 75D5              	;Update sector count variable with how many sectors were transfered.
 774+ 75D5 3E 6A        	ld 		a, MAX_SECT_BUF
 775+ 75D7 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 776+ 75D8 32 C7 7E     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 777+ 75DB
 778+ 75DB              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 779+ 75DB CD 08 72     	call	BDOSSetRandFilePtr
 780+ 75DE DD 5E 21     	ld		e, (ix + FCB_R0)
 781+ 75E1 DD 56 22     	ld		d, (ix + FCB_R1)
 782+ 75E4              CopyFilePtr2 EQU $+2
 783+ 75E4 ED 53 C3 7E  	ld		(FilePosRead), de
 784+ 75E8
 785+ 75E8 CD E6 71     	call 	BDOSCloseFile
 786+ 75EB CD D4 71     	call 	DestroyChannel
 787+ 75EE
 788+ 75EE ED 5B C1 7E  	ld		de, (CopyFileDMAAddr)
 789+ 75F2 15           	dec		d
 790+ 75F3 C9           	ret
 791+ 75F4
 792+ 75F4              	ENDIF
 793+ 75F4
# file closed: bdos.asm
1236  75F4              	include "ui.asm"
# file opened: ui.asm
   1+ 75F4              ;UI related functions
   2+ 75F4
   3+ 75F4              	ifndef	_UI_
   4+ 75F4              	define	_UI_
   5+ 75F4
   6+ 75F4              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++75F4              	ifndef	_HCCFG_
   2++75F4 ~            	define	_HCCFG_
   3++75F4 ~
   4++75F4 ~            ;HC specific code, for configuration
   5++75F4 ~
   6++75F4 ~            HC_CFG_PORT			EQU	$7E
   7++75F4 ~
   8++75F4 ~            ;BASIC/CPM ROM selection
   9++75F4 ~            HC_CFG_ROM_BAS		EQU	%0
  10++75F4 ~            HC_CFG_ROM_CPM		EQU	%1
  11++75F4 ~
  12++75F4 ~            ;Address for ROM paging: 0 or $E000
  13++75F4 ~            HC_CFG_ROM_0000		EQU %00
  14++75F4 ~            HC_CFG_ROM_E000		EQU %10
  15++75F4 ~
  16++75F4 ~            ;Cfg. port Enable/Disable
  17++75F4 ~            HC_CFG_PORT_DIS		EQU %000
  18++75F4 ~            HC_CFG_PORT_EN		EQU	%100
  19++75F4 ~
  20++75F4 ~            ;Video memory bank: $4000 or $C000
  21++75F4 ~            HC_CFG_VID_4000		EQU	%0000
  22++75F4 ~            HC_CFG_VID_C000		EQU	%1000
  23++75F4 ~
  24++75F4 ~
  25++75F4 ~            ;Standar BASIC config
  26++75F4 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  27++75F4 ~            ;Standar CP/M config
  28++75F4 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  29++75F4 ~
  30++75F4 ~
  31++75F4 ~            HC_VID_BANK0		EQU	$4000
  32++75F4 ~            HC_VID_BANK1		EQU	$C000
  33++75F4 ~
  34++75F4              	endif
# file closed: hccfg.asm
   7+ 75F4
   8+ 75F4              COL             EQU 23728
   9+ 75F4              LINE            EQU 23729               ;Coordinates
  10+ 75F4              LineCol			EQU	COL
  11+ 75F4              CODE			EQU 23681               ;Char to print
  12+ 75F4
  13+ 75F4              CPM_FNT         EQU $25AB
  14+ 75F4
  15+ 75F4              PORT_ZX			EQU	$FE
  16+ 75F4
  17+ 75F4              ;COLORS
  18+ 75F4              CLR_BLACK		EQU 0
  19+ 75F4              CLR_BLUE		EQU 1
  20+ 75F4              CLR_RED			EQU 2
  21+ 75F4              CLR_MAGENTA		EQU 3
  22+ 75F4              CLR_GREEN		EQU 4
  23+ 75F4              CLR_CYAN		EQU	5
  24+ 75F4              CLR_YELLOW		EQU	6
  25+ 75F4              CLR_WHITE		EQU	7
  26+ 75F4              CLR_BRIGHT		EQU	%01000000
  27+ 75F4              CLR_FLASH		EQU	%10000000
  28+ 75F4
  29+ 75F4              ;PAPER
  30+ 75F4              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 75F4              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 75F4              PAPER_RED		EQU (CLR_RED << 3)
  33+ 75F4              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 75F4              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 75F4              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 75F4              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 75F4              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 75F4
  39+ 75F4              ;INK
  40+ 75F4              INK_BLACK		EQU CLR_BLACK
  41+ 75F4              INK_BLUE		EQU CLR_BLUE
  42+ 75F4              INK_RED			EQU CLR_RED
  43+ 75F4              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 75F4              INK_GREEN		EQU CLR_GREEN
  45+ 75F4              INK_CYAN		EQU	CLR_CYAN
  46+ 75F4              INK_YELLOW		EQU	CLR_YELLOW
  47+ 75F4              INK_WHITE		EQU	CLR_WHITE
  48+ 75F4
  49+ 75F4
  50+ 75F4              SCR_ATTR_ADDR	EQU 22528
  51+ 75F4              SCR_ADDR		EQU 16384
  52+ 75F4              SCR_PIX_LEN		EQU	6144
  53+ 75F4              SCR_ATTR_LEN	EQU	768
  54+ 75F4              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 75F4              SCR_BYTES_PER_LINE	EQU	32
  56+ 75F4
  57+ 75F4              SCR_COLS		EQU	64
  58+ 75F4              SCR_LINES		EQU 24
  59+ 75F4
  60+ 75F4              ;used for file names list positioning
  61+ 75F4              LST_LINES_CNT	EQU	21
  62+ 75F4              LST_FIRST_LINE	EQU	1
  63+ 75F4              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 75F4              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 75F4              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 75F4              LST_FILE_INFO	EQU LST_DISK_INFO + 4
  67+ 75F4              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 75F4              LST_FIRST_COL	EQU	16
  69+ 75F4              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 75F4
  71+ 75F4              ;key codes
  72+ 75F4              KEY_ESC			EQU	7
  73+ 75F4              KEY_LEFT		EQU	8
  74+ 75F4              KEY_RIGHT		EQU	9
  75+ 75F4              KEY_DOWN		EQU	10
  76+ 75F4              KEY_UP			EQU	11
  77+ 75F4              KEY_BACKSP		EQU 12
  78+ 75F4              KEY_ENTER		EQU	13
  79+ 75F4              KEY_CTRL		EQU	14
  80+ 75F4
  81+ 75F4              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 75F4              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN
  83+ 75F4              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 75F4
  85+ 75F4              ;Special formating chars
  86+ 75F4              CHR_CR			EQU	13
  87+ 75F4              CHR_LF			EQU	10
  88+ 75F4              CHR_TAB			EQU	09
  89+ 75F4
  90+ 75F4
  91+ 75F4              ;Semi-graphical chars
  92+ 75F4              ;           UC
  93+ 75F4              ;     UL +H-+--+UR
  94+ 75F4              ;        |  |  |
  95+ 75F4              ;     ML +--+--+MR
  96+ 75F4              ;        V C|  |
  97+ 75F4              ;     LL +--+--+LR
  98+ 75F4              ;           DC
  99+ 75F4              CHR_GRID        EQU 127
 100+ 75F4              CHR_V           EQU	128
 101+ 75F4              CHR_MR          EQU	129
 102+ 75F4              CHR_UR          EQU 130
 103+ 75F4              CHR_DL          EQU 131
 104+ 75F4              CHR_DC          EQU 132
 105+ 75F4              CHR_UC          EQU 133
 106+ 75F4              CHR_ML          EQU 134
 107+ 75F4              CHR_H           EQU 135
 108+ 75F4              CHR_C           EQU 136
 109+ 75F4              CHR_LR          EQU 137
 110+ 75F4              CHR_UL          EQU 138
 111+ 75F4              CHR_FULL        EQU 139
 112+ 75F4              CHR_HALF        EQU 140
 113+ 75F4
 114+ 75F4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 75F4
 116+ 75F4              ;Return read char in A
 117+ 75F4              ReadChar:
 118+ 75F4 CF           	rst 08
 119+ 75F5 1B           	DEFB 27
 120+ 75F6 C9           	ret
 121+ 75F7
 122+ 75F7              ;Checks if a key is pressed
 123+ 75F7              ;Cy=1 if key is pressed
 124+ 75F7              KbdHit:
 125+ 75F7 CF           	rst 08
 126+ 75F8 20           	DEFB 32
 127+ 75F9 C9           	ret
 128+ 75FA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 75FA
 130+ 75FA              InitFonts:
 131+ 75FA              	IFUSED
 132+ 75FA                  ;page-in CPM ROM to get fonts
 133+ 75FA F3               di
 134+ 75FB 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 75FD D3 7E            out	(HC_CFG_PORT), a
 136+ 75FF
 137+ 75FF 21 AB 25     	ld		hl, CPM_FNT
 138+ 7602 11 96 89     	ld		de, FontTable
 139+ 7605 01 68 03     	ld		bc, 872
 140+ 7608 ED B0        	ldir
 141+ 760A
 142+ 760A                  ;restore BASIC ROM
 143+ 760A 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 760C D3 7E            out	(HC_CFG_PORT), a
 145+ 760E FB               ei
 146+ 760F
 147+ 760F C9           	ret
 148+ 7610              	ENDIF
 149+ 7610
 150+ 7610              ClrScr:
 151+ 7610 2A EF 77     	ld		hl, (CurrScrAddr)
 152+ 7613 54           	ld		d, h
 153+ 7614 5D           	ld		e, l
 154+ 7615 13           	inc		de
 155+ 7616 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 7619 36 00        	ld		(hl), 0
 157+ 761B ED B0        	ldir
 158+ 761D
 159+ 761D 23           	inc 	hl
 160+ 761E 13           	inc		de
 161+ 761F
 162+ 761F 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 7622 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 7624 ED B0        	ldir
 165+ 7626
 166+ 7626              	;also set border color
 167+ 7626 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 7628 D3 FE        	out		(PORT_ZX), a
 169+ 762A
 170+ 762A 3E 45        	ld		a, SCR_DEF_CLR
 171+ 762C 32 48 5C     	ld		(23624), a
 172+ 762F C9           	ret
 173+ 7630
 174+ 7630              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 7630              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 7630              PrintStr:
 177+ 7630 7E           	ld		a, (hl)
 178+ 7631 FE 20        	cp		' '
 179+ 7633 30 02        	jr		nc, GoodChar
 180+ 7635 3E 3F        	ld		a, '?'
 181+ 7637              GoodChar:
 182+ 7637 CB 7F        	bit		7, a
 183+ 7639 CB BF        	res		7, a
 184+ 763B 32 81 5C     	ld		(CODE), a
 185+ 763E ED 53 B0 5C  	ld		(LineCol), de
 186+ 7642 08           	ex		af, af'
 187+ 7643 D9           	exx
 188+ 7644 E5           	push	hl
 189+ 7645 CD 5C 77     	call 	PrintChar
 190+ 7648 E1           	pop		hl
 191+ 7649 D9           	exx
 192+ 764A 08           	ex		af, af'
 193+ 764B C0           	ret		nz
 194+ 764C
 195+ 764C 1C           	inc		e
 196+ 764D 23           	inc		hl
 197+ 764E
 198+ 764E 7B           	ld		a, e
 199+ 764F FE 40        	cp		64
 200+ 7651 38 DD        	jr		c, PrintStr
 201+ 7653 1E 00        	ld		e, 0
 202+ 7655 14           	inc		d
 203+ 7656
 204+ 7656 18 D8        	jr		PrintStr
 205+ 7658
 206+ 7658              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 7658
 208+ 7658              ;IN: HL = string, DE = coords, A = color
 209+ 7658              PrintStrClr:
 210+ 7658 32 84 76     	ld		(StrClr), a
 211+ 765B D5           	push	de
 212+ 765C CD 30 76     		call	PrintStr
 213+ 765F E1           	pop		hl
 214+ 7660              	;get string len.
 215+ 7660 7B           	ld		a, e
 216+ 7661 95           	sub		l
 217+ 7662 1F           	rra
 218+ 7663 08           	ex		af, af'
 219+ 7664              		;line * 32
 220+ 7664 7C           		ld		a, h
 221+ 7665 17           		rla
 222+ 7666 17           		rla
 223+ 7667 11 00 00     		ld	de, 0
 224+ 766A 17           		rla
 225+ 766B CB 12        		rl	d
 226+ 766D 17           		rla
 227+ 766E CB 12        		rl	d
 228+ 7670 17           		rla
 229+ 7671 CB 12        		rl	d
 230+ 7673 5F           		ld	e, a
 231+ 7674
 232+ 7674 26 00        		ld		h, 0
 233+ 7676 19           		add		hl, de
 234+ 7677 ED 5B F1 77  		ld		de, (CurrScrAttrAddr)
 235+ 767B 19           		add		hl, de
 236+ 767C 08           	ex		af, af'
 237+ 767D 4F           	ld		c, a
 238+ 767E 06 00        	ld		b, 0
 239+ 7680 54           	ld		d, h
 240+ 7681 5D           	ld		e, l
 241+ 7682 13           	inc 	de
 242+ 7683              StrClr	EQU	$ + 1
 243+ 7683 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 7685 ED B0        	ldir
 245+ 7687 C9           	ret
 246+ 7688              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 7688
 248+ 7688              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 7688              DrawLine:
 250+ 7688 32 81 5C     	ld		(CODE), a
 251+ 768B
 252+ 768B 38 04        	jr		c, VertDir
 253+ 768D 3E 1C        	ld		a, $1C
 254+ 768F 18 02        	jr		StoreDir
 255+ 7691              VertDir:
 256+ 7691 3E 14        	ld		a, $14
 257+ 7693              StoreDir:
 258+ 7693 32 A3 76     	ld		(LineDir), a
 259+ 7696
 260+ 7696              DrawLineLoop:
 261+ 7696 ED 53 B0 5C  	ld		(LineCol), de
 262+ 769A D5           	push	de
 263+ 769B D9           		exx
 264+ 769C E5           		push	hl
 265+ 769D CD 5C 77     		call 	PrintChar
 266+ 76A0 E1           		pop		hl
 267+ 76A1 D9           		exx
 268+ 76A2 D1           	pop		de
 269+ 76A3              LineDir:
 270+ 76A3 1C           	inc		e
 271+ 76A4 10 F0        	djnz	DrawLineLoop
 272+ 76A6
 273+ 76A6 C9           	ret
 274+ 76A7
 275+ 76A7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 76A7
 277+ 76A7              DrawHLines:
 278+ 76A7 11 00 00     	ld		de, 0
 279+ 76AA 06 40        	ld		b, 64
 280+ 76AC 3E 87        	ld		a, CHR_H
 281+ 76AE B7           	or		a
 282+ 76AF CD 88 76     	call	DrawLine
 283+ 76B2
 284+ 76B2 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 76B5 06 40        	ld		b, 64
 286+ 76B7 3E 87        	ld		a, CHR_H
 287+ 76B9 B7           	or		a
 288+ 76BA CD 88 76     	call	DrawLine
 289+ 76BD
 290+ 76BD 06 04        	ld		b, 4
 291+ 76BF 11 10 00     	ld		de, LST_FIRST_COL
 292+ 76C2              DrawUpperIntersectLoop:
 293+ 76C2 C5           	push	bc
 294+ 76C3 D5           	push	de
 295+ 76C4 3E 85        		ld		a, CHR_UC
 296+ 76C6 CD E8 76     		call	DrawIntersect
 297+ 76C9 D1           	pop		de
 298+ 76CA C1           	pop		bc
 299+ 76CB 21 0C 00     	ld		hl, NAMELEN+1
 300+ 76CE 19           	add		hl, de
 301+ 76CF EB           	ex		de, hl
 302+ 76D0 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 76D2
 304+ 76D2 06 04        	ld		b, 4
 305+ 76D4 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 76D7              DrawLowerIntersectLoop:
 307+ 76D7 C5           	push	bc
 308+ 76D8 D5           	push	de
 309+ 76D9 3E 84        		ld		a, CHR_DC
 310+ 76DB CD E8 76     		call	DrawIntersect
 311+ 76DE D1           	pop		de
 312+ 76DF C1           	pop		bc
 313+ 76E0 21 0C 00     	ld		hl, NAMELEN+1
 314+ 76E3 19           	add		hl, de
 315+ 76E4 EB           	ex		de, hl
 316+ 76E5 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 76E7
 318+ 76E7 C9           	ret
 319+ 76E8
 320+ 76E8
 321+ 76E8              DrawIntersect:
 322+ 76E8 21 B0 5C     	ld		hl, LineCol
 323+ 76EB 73 23 72 2B  	ld		(hl), de
 324+ 76EF 32 81 5C     	ld		(CODE), a
 325+ 76F2 E5           	push	hl
 326+ 76F3 CD 5C 77     	call	PrintChar
 327+ 76F6 E1           	pop		hl
 328+ 76F7 34           	inc		(hl)
 329+ 76F8 3E 87        	ld		a, CHR_H
 330+ 76FA 32 81 5C     	ld		(CODE), a
 331+ 76FD CD 5C 77     	call	PrintChar
 332+ 7700 C9           	ret
 333+ 7701
 334+ 7701
 335+ 7701              DrawVLines:
 336+ 7701 06 04        	ld		b, 4
 337+ 7703 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 338+ 7706              DrawVLinesLoop:
 339+ 7706 C5           	push 	bc
 340+ 7707 D5           	push	de
 341+ 7708 06 15        		ld		b, LST_LINES_CNT
 342+ 770A 3E 80        		ld		a, CHR_V
 343+ 770C 37           		scf
 344+ 770D CD 88 76     		call	DrawLine
 345+ 7710 D1           	pop		de
 346+ 7711 C1           	pop	bc
 347+ 7712 7B           	ld		a, e
 348+ 7713 C6 0C        	add		NAMELEN+1
 349+ 7715 5F           	ld		e, a
 350+ 7716 10 EE        	djnz	DrawVLinesLoop
 351+ 7718 C9           	ret
 352+ 7719
 353+ 7719              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 354+ 7719
 355+ 7719              ;IN: A = color mask
 356+ 7719              DrawCursor:
 357+ 7719 ED 5B B7 7E  	ld	de, (CursorAddr)
 358+ 771D 06 06        	ld	b, 	(NAMELEN + 1)/2
 359+ 771F              DrawCursorLoop:
 360+ 771F 12           	ld	(de), a
 361+ 7720 13           	inc de
 362+ 7721 10 FC        	djnz DrawCursorLoop
 363+ 7723 C9           	ret
 364+ 7724
 365+ 7724              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 366+ 7724
 367+ 7724              ;IN:	A = file idx.
 368+ 7724              MoveCursor:
 369+ 7724              	;File idx / SCR_LINES => cursor line & column
 370+ 7724 6F           	ld		l, a
 371+ 7725 26 00        	ld		h, 0
 372+ 7727 0E 15        	ld		c, LST_LINES_CNT
 373+ 7729 CD 91 6D     	call	Div					;HL = file column, A = line
 374+ 772C
 375+ 772C              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 376+ 772C C6 01        	add		LST_FIRST_LINE
 377+ 772E
 378+ 772E
 379+ 772E 54           	ld d, h
 380+ 772F 5D           	ld e, l
 381+ 7730 21 00 00     	ld	hl, 0
 382+ 7733
 383+ 7733              	;line*32
 384+ 7733 17           	rla
 385+ 7734 17           	rla
 386+ 7735 17           	rla
 387+ 7736 17           	rla
 388+ 7737 CB 14        	rl h
 389+ 7739 17           	rla
 390+ 773A CB 14        	rl h
 391+ 773C 6F           	ld l, a
 392+ 773D
 393+ 773D
 394+ 773D              	;col * 6
 395+ 773D E5           	push	hl					;save line * 32
 396+ 773E 3E 06        		ld		a, (NAMELEN + 1)/2
 397+ 7740 CD B1 6D     		call	Mul				;HL = column * 12/2
 398+ 7743 D1           	pop		de
 399+ 7744 19           	add		hl, de
 400+ 7745
 401+ 7745 11 08 00     	ld		de, LST_FIRST_COL/2
 402+ 7748 ED 4B F1 77  	ld		bc, (CurrScrAttrAddr)
 403+ 774C 19           	add		hl, de
 404+ 774D 09           	add		hl, bc
 405+ 774E
 406+ 774E              	;clear old cursor
 407+ 774E 3E 45        	ld		a, SCR_DEF_CLR
 408+ 7750 CD 19 77     	call	DrawCursor
 409+ 7753
 410+ 7753              	;draw new one
 411+ 7753 22 B7 7E     	ld		(CursorAddr), hl
 412+ 7756 3E 20        	ld		a, SCR_SEL_CLR
 413+ 7758 CD 19 77     	call	DrawCursor
 414+ 775B
 415+ 775B C9           	ret
 416+ 775C
 417+ 775C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 418+ 775C
 419+ 775C              PrintChar:
 420+ 775C ED 5B B0 5C      ld		de, (LineCol)
 421+ 7760
 422+ 7760                  ;calculate 64 column screen address
 423+ 7760              	;IN: D = line, E = col
 424+ 7760              	;OUT: HL = screen address
 425+ 7760
 426+ 7760 CB 3B            SRL     E                                       ;col = col/2
 427+ 7762 CB 19            RR      C                                       ;mark odd/even column
 428+ 7764 7A               LD      A, D                            ;A = line
 429+ 7765 E6 18            AND 24                                  ;keep only %00011000
 430+ 7767 2A EF 77         ld		hl, (CurrScrAddr)
 431+ 776A B4               OR      h								;add screen start address
 432+ 776B 67               LD      H, A                            ;save H
 433+ 776C 7A               LD      A, D                            ;A = line
 434+ 776D E6 07            AND 7                                   ;keep only %00000111
 435+ 776F 0F               RRCA                                    ;%10000011
 436+ 7770 0F               RRCA                                    ;%11000001
 437+ 7771 0F               RRCA                                    ;%11100000
 438+ 7772 B3               OR      E                                       ;add column
 439+ 7773 6F               LD      L, A                            ;HL = screen address
 440+ 7774
 441+ 7774              PrintChar3:
 442+ 7774                  ;get font address
 443+ 7774 E5               PUSH HL
 444+ 7775 AF                   XOR A
 445+ 7776 67                   LD  H, A
 446+ 7777 3A 81 5C             LD  A, (CODE)
 447+ 777A D6 20                SUB ' '
 448+ 777C 6F                   LD  L, A
 449+ 777D 29                   ADD     HL, HL                  ;char code = char code * 8
 450+ 777E 29                   ADD     HL, HL                  ;i.e. offset into font table
 451+ 777F 29                   ADD     HL, HL
 452+ 7780 11 96 89             LD      DE, FontTable             ;get font table
 453+ 7783 19                   ADD     HL, DE
 454+ 7784 EB                   EX      DE, HL                  ;DE = our char font address
 455+ 7785 E1               POP     HL
 456+ 7786
 457+ 7786
 458+ 7786                  ;print a char
 459+ 7786 06 08            LD      B, 8                            ;char height is 8 lines
 460+ 7788              PrintCharLine:
 461+ 7788 1A                   LD      A, (DE)                         ;load char line in A
 462+ 7789
 463+ 7789 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 464+ 778B 20 06                JR  	NZ, NoTurn
 465+ 778D
 466+ 778D 07                   RLCA
 467+ 778E 07                   RLCA
 468+ 778F 07                   RLCA
 469+ 7790 07                   RLCA
 470+ 7791 18 01                JR      Store
 471+ 7793              NoTurn:
 472+ 7793 B6                   OR (HL)
 473+ 7794              Store:
 474+ 7794 77                   LD (HL), A
 475+ 7795
 476+ 7795 13                   INC     DE                                      ;next char line in font table
 477+ 7796 24                   INC     H                                       ;next char line on screen
 478+ 7797 10 EF            DJNZ PrintCharLine                  ;last line of char?
 479+ 7799
 480+ 7799 C9               ret
 481+ 779A
 482+ 779A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 483+ 779A
 484+ 779A              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 485+ 779A              ReadString:
 486+ 779A 21 FE 8C     	ld		hl, FileData
 487+ 779D D5           	push	de
 488+ 779E DD E1        	pop		ix
 489+ 77A0
 490+ 77A0              ReadStringLoop:
 491+ 77A0 D5           	push	de
 492+ 77A1 E5           	push	hl
 493+ 77A2 CD F4 75     		call ReadChar
 494+ 77A5 E1           	pop		hl
 495+ 77A6 D1           	pop		de
 496+ 77A7
 497+ 77A7 FE 0D        	cp	KEY_ENTER
 498+ 77A9 C8           	ret z
 499+ 77AA
 500+ 77AA FE 0C        	cp  KEY_BACKSP
 501+ 77AC 20 0F        	jr	nz, ReadStrChar
 502+ 77AE
 503+ 77AE E5           	push hl
 504+ 77AF 01 FF 8C     	ld   bc, FileData+1
 505+ 77B2 ED 42        	sbc	 hl, bc
 506+ 77B4 E1           	pop  hl
 507+ 77B5 38 16        	jr   c, ReadStrPrint
 508+ 77B7
 509+ 77B7 1B           	dec	de
 510+ 77B8 2B           	dec	hl
 511+ 77B9 36 20        	ld	(hl), ' '
 512+ 77BB 18 10        	jr	ReadStrPrint
 513+ 77BD
 514+ 77BD              ReadStrChar:
 515+ 77BD FE 20        	cp	' '
 516+ 77BF 38 DF        	jr	c, ReadStringLoop
 517+ 77C1 FE 7F        	cp  127
 518+ 77C3 30 DB        	jr	nc, ReadStringLoop
 519+ 77C5
 520+ 77C5              	;Check end of string and go back if found.
 521+ 77C5 46           	ld	b, (hl)
 522+ 77C6 CB 78        	bit 7, b
 523+ 77C8 20 03        	jr	nz, ReadStrPrint
 524+ 77CA
 525+ 77CA 77           	ld	(hl), a
 526+ 77CB 23           	inc	hl
 527+ 77CC 13           	inc	de
 528+ 77CD
 529+ 77CD              ReadStrPrint:
 530+ 77CD E5           	push	hl
 531+ 77CE D5           	push	de
 532+ 77CF 21 FE 8C     	ld		hl, FileData
 533+ 77D2 DD E5        	push	ix
 534+ 77D4 D1           	pop		de
 535+ 77D5 CD 30 76     	call	PrintStr
 536+ 77D8 D1           	pop		de
 537+ 77D9 E1           	pop		hl
 538+ 77DA
 539+ 77DA 18 C4        	jr		ReadStringLoop
 540+ 77DC
 541+ 77DC              ClearNMsgLines:
 542+ 77DC 11 00 0F     	ld		de, LST_LINE_MSG + 1 << 8
 543+ 77DF              ClearNMsgLinesLoop:
 544+ 77DF D5           	push	de
 545+ 77E0 C5           	push	bc
 546+ 77E1 21 8F 7D     	ld		hl, MsgClear
 547+ 77E4 3E 45        	ld		a, SCR_DEF_CLR
 548+ 77E6 CD 58 76     	call	PrintStrClr
 549+ 77E9 C1           	pop		bc
 550+ 77EA D1           	pop		de
 551+ 77EB 14           	inc		d
 552+ 77EC 10 F1        	djnz	ClearNMsgLinesLoop
 553+ 77EE
 554+ 77EE C9           	ret
 555+ 77EF
 556+ 77EF 00 40        CurrScrAddr		DEFW	SCR_ADDR
 557+ 77F1 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 558+ 77F3
 559+ 77F3                 	endif
# file closed: ui.asm
1237  77F3              	include "math.asm"
# file opened: math.asm
   1+ 77F3              	ifndef	_MATH_
   2+ 77F3 ~            	define	_MATH_
   3+ 77F3 ~
   4+ 77F3 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 77F3 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 77F3 ~
   7+ 77F3 ~
   8+ 77F3 ~            Word2Txt:
   9+ 77F3 ~            	IFUSED
  10+ 77F3 ~            	push	de
  11+ 77F3 ~            		call	Word2Txt_
  12+ 77F3 ~            	pop		de
  13+ 77F3 ~
  14+ 77F3 ~            	ld		b, 4
  15+ 77F3 ~            	call	StrippLeading0
  16+ 77F3 ~            	ret
  17+ 77F3 ~
  18+ 77F3 ~            Byte2Txt:
  19+ 77F3 ~            	push	de
  20+ 77F3 ~            		call	Byte2Txt_
  21+ 77F3 ~            	pop		de
  22+ 77F3 ~
  23+ 77F3 ~            	ld		b, 2
  24+ 77F3 ~            	call	StrippLeading0
  25+ 77F3 ~            	ret
  26+ 77F3 ~            	ENDIF
  27+ 77F3 ~
  28+ 77F3 ~
  29+ 77F3 ~            StrippLeading0:
  30+ 77F3 ~            	ld		a, (de)
  31+ 77F3 ~            	cp		'1'
  32+ 77F3 ~            	ret		nc
  33+ 77F3 ~
  34+ 77F3 ~            	ld		a, ' '
  35+ 77F3 ~            	ld		(de), a
  36+ 77F3 ~            	inc		de
  37+ 77F3 ~            	djnz	StrippLeading0
  38+ 77F3 ~            	ret
  39+ 77F3 ~
  40+ 77F3 ~
  41+ 77F3 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 77F3 ~            Word2Txt_:
  43+ 77F3 ~            	ld bc, -10000
  44+ 77F3 ~            	call DigitLoop
  45+ 77F3 ~            	ld bc, -1000
  46+ 77F3 ~            	call DigitLoop
  47+ 77F3 ~            Byte2Txt_:
  48+ 77F3 ~            	ld bc, -100
  49+ 77F3 ~            	call DigitLoop
  50+ 77F3 ~            	ld bc, -10
  51+ 77F3 ~            	call DigitLoop
  52+ 77F3 ~            	ld bc, -1
  53+ 77F3 ~
  54+ 77F3 ~            DigitLoop:
  55+ 77F3 ~            	ld	a, '0' - 1
  56+ 77F3 ~            DivNrLoop:
  57+ 77F3 ~            	inc	a			;increase reminder
  58+ 77F3 ~            	add	hl, bc		;substract divizor
  59+ 77F3 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 77F3 ~            	sbc	hl, bc		;nope, restore
  61+ 77F3 ~
  62+ 77F3 ~            	ld (de), a
  63+ 77F3 ~            	inc de
  64+ 77F3 ~            	ret
  65+ 77F3 ~
  66+ 77F3 ~
  67+ 77F3 ~            ;Input: HL = Dividend, C = Divisor
  68+ 77F3 ~            ;Output: HL = Quotient, A = Remainder
  69+ 77F3 ~            ;Warning: doesn't work with divisor >= $80
  70+ 77F3 ~            Div:
  71+ 77F3 ~            	IFUSED
  72+ 77F3 ~            	xor a
  73+ 77F3 ~            	ld b, 16
  74+ 77F3 ~
  75+ 77F3 ~            DivLoop:
  76+ 77F3 ~            	add	hl,hl
  77+ 77F3 ~            	rla
  78+ 77F3 ~            	cp	c
  79+ 77F3 ~            	jr	c, NoSub
  80+ 77F3 ~            	sub	c
  81+ 77F3 ~            	inc	l
  82+ 77F3 ~            NoSub:
  83+ 77F3 ~            	djnz DivLoop
  84+ 77F3 ~
  85+ 77F3 ~            	ret
  86+ 77F3 ~            	ENDIF
  87+ 77F3 ~
  88+ 77F3 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 77F3 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 77F3 ~            Div2:
  91+ 77F3 ~            	ld hl, 0
  92+ 77F3 ~            	ld b, 16
  93+ 77F3 ~            Div2Loop:
  94+ 77F3 ~            	sll c		; unroll 16 times
  95+ 77F3 ~            	rla			; ...
  96+ 77F3 ~            	adc	hl,hl		; ...
  97+ 77F3 ~            	sbc	hl,de		; ...
  98+ 77F3 ~            	jr	nc,$+4		; ...
  99+ 77F3 ~            	add	hl,de		; ...
 100+ 77F3 ~            	dec	c		; ...
 101+ 77F3 ~            	djnz Div2Loop
 102+ 77F3 ~            	ret
 103+ 77F3 ~
 104+ 77F3 ~
 105+ 77F3 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 77F3 ~            ;Output: A:HL = Product
 107+ 77F3 ~            Mul:
 108+ 77F3 ~            	IFUSED
 109+ 77F3 ~            	ld hl, 0
 110+ 77F3 ~            	ld bc, $0700
 111+ 77F3 ~
 112+ 77F3 ~            	add	a, a		; optimised 1st iteration
 113+ 77F3 ~            	jr	nc, MulLoop
 114+ 77F3 ~            	ld	h, d
 115+ 77F3 ~            	ld	l, e
 116+ 77F3 ~
 117+ 77F3 ~            MulLoop:
 118+ 77F3 ~            	add	hl,hl
 119+ 77F3 ~            	rla
 120+ 77F3 ~            	jr	nc, NoAdd
 121+ 77F3 ~            	add	hl,de
 122+ 77F3 ~            	adc	a,c
 123+ 77F3 ~            NoAdd:
 124+ 77F3 ~            	djnz MulLoop
 125+ 77F3 ~
 126+ 77F3 ~            	ret
 127+ 77F3 ~            	ENDIF
 128+ 77F3 ~
 129+ 77F3              	endif
# file closed: math.asm
1238  77F3              	include "txtview.asm"
# file opened: txtview.asm
   1+ 77F3              ; 	DEVICE ZXSPECTRUM48
   2+ 77F3
   3+ 77F3              LINE_CNT	EQU	23
   4+ 77F3              COL_CNT		EQU	64
   5+ 77F3
   6+ 77F3              CHAR_CR		EQU	$0D
   7+ 77F3              CHAR_LF		EQU	$0A
   8+ 77F3              CHAR_TAB	EQU	$09
   9+ 77F3              CHAR_EOF	EQU	$1A
  10+ 77F3
  11+ 77F3              COORDS		EQU	23728		;Coordinates
  12+ 77F3
  13+ 77F3
  14+ 77F3              InitViewer:
  15+ 77F3 22 3E 7B     	ld		 (FileBegin), hl
  16+ 77F6 09           	add		hl, bc
  17+ 77F7              	;must filter any EOF chars.
  18+ 77F7 3E 1A        	ld		a, CHAR_EOF
  19+ 77F9 25           	dec		h
  20+ 77FA 25           	dec		h
  21+ 77FB 01 00 04     	ld		bc, SECT_SZ	* 4
  22+ 77FE ED B1        	cpir
  23+ 7800 2B           	dec		hl
  24+ 7801 22 42 7B     	ld		(FileEnd), hl
  25+ 7804 ED 5B 3E 7B  	ld		de, (FileBegin)
  26+ 7808 B7           	or		a
  27+ 7809 ED 52        	sbc		hl, de
  28+ 780B 22 40 7B     	ld		(FileLen), hl
  29+ 780E
  30+ 780E 3E 0D        	ld		a, CHAR_CR
  31+ 7810 77           	ld		(hl), a
  32+ 7811
  33+ 7811
  34+ 7811 21 04 02     	ld		hl, (2 << 8) | 4
  35+ 7814 22 09 5C     	ld		(REPDEL), hl
  36+ 7817
  37+ 7817 21 00 00     	ld		hl, 0
  38+ 781A 22 B0 5C     	ld		(COORDS), hl
  39+ 781D
  40+ 781D 21 00 58     	ld		hl, SCR_ADDR + SCR_PIX_LEN
  41+ 7820 54           	ld		d, h
  42+ 7821 5D           	ld		e, l
  43+ 7822 13           	inc		de
  44+ 7823 01 FF 02     	ld		bc, 767
  45+ 7826 36 45        	ld		(hl), SCR_DEF_CLR
  46+ 7828 ED B0        	ldir
  47+ 782A
  48+ 782A CD 45 7A     	call	ScrollInit
  49+ 782D
  50+ 782D 11 00 00     	ld		de, 0
  51+ 7830 ED 53 3B 7B  	ld		(CurLine), de
  52+ 7834
  53+ 7834              	;prepare file progress %
  54+ 7834 2A 40 7B     	ld		hl, (FileLen)
  55+ 7837 7C           	ld		a, h
  56+ 7838 4D           	ld		c, l
  57+ 7839 11 64 00     	ld		de, 100
  58+ 783C CD 9E 6D     	call	Div2
  59+ 783F 67           	ld		h, a
  60+ 7840 69           	ld		l, c
  61+ 7841 22 44 7B     	ld		(PROGR_PERC), hl
  62+ 7844
  63+ 7844 CD D4 79     	call	PrintMsg
  64+ 7847
  65+ 7847 DD 21 FC F6  	ld		ix, FileIdx	- 2
  66+ 784B 06 17        	ld		b, LINE_CNT
  67+ 784D 2A 3E 7B     	ld		hl, (FileBegin)
  68+ 7850
  69+ 7850 C9           	ret
  70+ 7851
  71+ 7851
  72+ 7851              PrintLoop:
  73+ 7851 C5           	push	bc
  74+ 7852 DD 23        		inc		ix
  75+ 7854 DD 23        		inc		ix
  76+ 7856 DD 75 00     		ld		(ix), l
  77+ 7859 DD 74 01     		ld		(ix + 1), h
  78+ 785C
  79+ 785C CD 72 79     		call	GetLine
  80+ 785F CD 44 79     		call	PrintLine
  81+ 7862
  82+ 7862 ED 5B 3B 7B  		ld		de, (CurLine)
  83+ 7866 13           		inc		de
  84+ 7867 ED 53 3B 7B  		ld		(CurLine), de
  85+ 786B C1           	pop		bc
  86+ 786C CD 39 79     	call	CheckEnd
  87+ 786F 38 13        	jr		c, ViewFileEOF
  88+ 7871
  89+ 7871 10 DE        	djnz	PrintLoop
  90+ 7873 18 17        	jr		PrintLoop2
  91+ 7875
  92+ 7875              GetKey:
  93+ 7875 76           	halt
  94+ 7876 FD CB 01 6E  	bit		5, (iy + 1);
  95+ 787A 28 F9        	jr		z, GetKey
  96+ 787C FD CB 01 AE  	res		5, (iy + 1)
  97+ 7880 FD 7E CE     	ld		a, (iy - $32)
  98+ 7883 C9           	ret
  99+ 7884
 100+ 7884              ViewFileEOF:
 101+ 7884 CD 75 78     	call	GetKey
 102+ 7887 FE 30        	cp		'0'
 103+ 7889 20 F9        	jr		nz, ViewFileEOF
 104+ 788B C9           	ret
 105+ 788C
 106+ 788C              PrintLoop2:
 107+ 788C CD D4 79     	call	PrintMsg
 108+ 788F
 109+ 788F CD 75 78     	call	GetKey
 110+ 7892 FE 30        	cp		'0'					;Exit on 0
 111+ 7894 C8           	ret		z
 112+ 7895
 113+ 7895 FE 0A        	cp		KEY_DOWN
 114+ 7897 28 5C        	jr		z, Down
 115+ 7899
 116+ 7899 FE 0B        	cp		KEY_UP
 117+ 789B 28 2D        	jr		z, Up
 118+ 789D
 119+ 789D FE 32        	cp		'2'
 120+ 789F 20 EB        	jr		nz, PrintLoop2
 121+ 78A1
 122+ 78A1 3A 3D 7B     	ld		a, (WrapFlag)
 123+ 78A4 EE 01        	xor		1
 124+ 78A6 32 3D 7B     	ld		(WrapFlag), a
 125+ 78A9 B7           	or		a
 126+ 78AA 28 0F        	jr		z, NoWrap
 127+ 78AC
 128+ 78AC 11 4F 6E     	ld		de, 'nO'
 129+ 78AF ED 53 F0 7A  	ld		(MsgLineWrF), de
 130+ 78B3 3E 20        	ld		a, ' '
 131+ 78B5 32 F2 7A     	ld		(MsgLineWrF + 2), a
 132+ 78B8 C3 8C 78     	jp		PrintLoop2
 133+ 78BB
 134+ 78BB              NoWrap:
 135+ 78BB 11 4F 66     	ld		de, 'fO'
 136+ 78BE ED 53 F0 7A  	ld		(MsgLineWrF), de
 137+ 78C2 3E 66        	ld		a, 'f'
 138+ 78C4 32 F2 7A     	ld		(MsgLineWrF + 2), a
 139+ 78C7
 140+ 78C7 C3 8C 78     	jp		PrintLoop2
 141+ 78CA
 142+ 78CA
 143+ 78CA              Up:
 144+ 78CA CD 29 79     	call	CheckBegin
 145+ 78CD 28 BD        	jr		z, PrintLoop2
 146+ 78CF
 147+ 78CF CD 73 7A     	call	ScrollUp
 148+ 78D2
 149+ 78D2 DD 2B        	dec		ix
 150+ 78D4 DD 2B        	dec		ix
 151+ 78D6 DD 6E D4     	ld		l, (ix - (LINE_CNT-1)*2)
 152+ 78D9 DD 66 D5     	ld		h, (ix - (LINE_CNT-1)*2 + 1)
 153+ 78DC CD 72 79     	call	GetLine						;extract previous line to display
 154+ 78DF
 155+ 78DF 11 00 00     	ld		de, 0
 156+ 78E2 ED 53 B0 5C  	ld		(COORDS), de
 157+ 78E6 CD 44 79     	call	PrintLine
 158+ 78E9
 159+ 78E9 2A 3B 7B     	ld		hl, (CurLine)
 160+ 78EC 2B           	dec		hl
 161+ 78ED 22 3B 7B     	ld		(CurLine), hl
 162+ 78F0 CD D4 79     	call	PrintMsg
 163+ 78F3 18 97        	jr		PrintLoop2
 164+ 78F5
 165+ 78F5
 166+ 78F5              Down:
 167+ 78F5 DD 6E 00     	ld		l, (ix)
 168+ 78F8 DD 66 01     	ld		h, (ix + 1)
 169+ 78FB CD 72 79     	call	GetLine						;get next line pointer
 170+ 78FE
 171+ 78FE CD 39 79     	call	CheckEnd					;check if HL == file end
 172+ 7901 D8           	ret		c
 173+ 7902
 174+ 7902 DD 23        	inc		ix								;save next line pointer
 175+ 7904 DD 23        	inc		ix
 176+ 7906 DD 75 00     	ld		(ix), l
 177+ 7909 DD 74 01     	ld		(ix + 1), h
 178+ 790C
 179+ 790C CD 72 79     	call	GetLine						;extract next line in buffer for display
 180+ 790F
 181+ 790F CD 78 7A     	call	ScrollDown
 182+ 7912
 183+ 7912 11 00 16     	ld		de, (LINE_CNT-1) << 8
 184+ 7915 ED 53 B0 5C  	ld		(COORDS), de
 185+ 7919 CD 44 79     	call	PrintLine
 186+ 791C
 187+ 791C 2A 3B 7B     	ld		hl, (CurLine)
 188+ 791F 23           	inc		hl
 189+ 7920 22 3B 7B     	ld		(CurLine), hl
 190+ 7923 CD D4 79     	call	PrintMsg
 191+ 7926
 192+ 7926 C3 8C 78     	jp		PrintLoop2
 193+ 7929
 194+ 7929
 195+ 7929              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 196+ 7929              ;check begining of buffer
 197+ 7929              CheckBegin:
 198+ 7929 E5           	push	hl
 199+ 792A DD 6E D4     		ld		l, (ix - (LINE_CNT-1) * 2)
 200+ 792D DD 66 D5     		ld		h, (ix - (LINE_CNT-1) * 2 + 1)
 201+ 7930 ED 5B 3E 7B  		ld		de, (FileBegin)
 202+ 7934 B7           		or		a
 203+ 7935 ED 52        		sbc		hl, de
 204+ 7937 E1           	pop		hl
 205+ 7938 C9           	ret
 206+ 7939
 207+ 7939              ;check end of buffer
 208+ 7939              CheckEnd:
 209+ 7939 E5           	push	hl
 210+ 793A ED 5B 42 7B  		ld		de, (FileEnd)
 211+ 793E EB           		ex		de, hl
 212+ 793F B7           		or		a
 213+ 7940 ED 52        		sbc		hl, de
 214+ 7942 E1           	pop		hl
 215+ 7943 C9           	ret
 216+ 7944
 217+ 7944              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 218+ 7944              ;Print a line
 219+ 7944              PrintLine:
 220+ 7944 11 FB 7A     	ld		de, LineBuf
 221+ 7947 06 40        	ld		b, COL_CNT
 222+ 7949
 223+ 7949 CD 58 79     	call	PrintStrTxt
 224+ 794C
 225+ 794C              	;go to the next screen line
 226+ 794C ED 5B B0 5C  	ld		de, (COORDS)
 227+ 7950 14           	inc		d
 228+ 7951 1E 00        	ld		e, 0
 229+ 7953 ED 53 B0 5C  	ld		(COORDS), de
 230+ 7957 C9           	ret
 231+ 7958
 232+ 7958              PrintStrTxt:
 233+ 7958 1A           	ld		a, (de)
 234+ 7959 13           	inc		de
 235+ 795A D5           	push	de
 236+ 795B 32 81 5C     		ld		(CODE), a
 237+ 795E C5           		push	bc
 238+ 795F E5           			push	hl
 239+ 7960 CD 5C 77     				call	PrintChar
 240+ 7963 E1           			pop		hl
 241+ 7964 C1           		pop		bc
 242+ 7965
 243+ 7965 ED 5B B0 5C  		ld		de, (COORDS)
 244+ 7969 1C           		inc		e
 245+ 796A ED 53 B0 5C  		ld		(COORDS), de
 246+ 796E D1           	pop		de
 247+ 796F 10 E7        	djnz	PrintStrTxt
 248+ 7971 C9           	ret
 249+ 7972
 250+ 7972              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 251+ 7972              ;Extract a line of text to fit exactly on a 64 screen line
 252+ 7972              ;IN:	HL = current file pointer
 253+ 7972              ;OUT:	LineBuf = new line for display, HL = pointer to the next line
 254+ 7972              GetLine:
 255+ 7972 11 FB 7A     	ld		de, LineBuf
 256+ 7975 06 40        	ld		b, COL_CNT
 257+ 7977              GetLineLoop:
 258+ 7977 7E           	ld		a, (hl)
 259+ 7978 23           	inc		hl
 260+ 7979
 261+ 7979 FE 0D        	cp		CHAR_CR
 262+ 797B 28 2F        	jr		z, GetLineSkip0A
 263+ 797D
 264+ 797D FE 0A        	cp		CHAR_LF
 265+ 797F 28 2B        	jr		z, GetLineSkip0A
 266+ 7981
 267+ 7981 FE 09        	cp		CHAR_TAB
 268+ 7983 28 06        	jr		z, GetLineTab
 269+ 7985
 270+ 7985 FE 1A        	cp		CHAR_EOF
 271+ 7987 28 44        	jr		z, GetLineFillLoop
 272+ 7989
 273+ 7989 18 07        	jr		GetLineNext
 274+ 798B
 275+ 798B              GetLineTab:
 276+ 798B              	;1 space tab
 277+ 798B 3E 20        	ld		a, ' '
 278+ 798D 12           	ld		(de), a
 279+ 798E 13           	inc		de
 280+ 798F 05           	dec		b
 281+ 7990 28 11        	jr		z, GetLineSkip0D	;skip tab on end of line
 282+ 7992
 283+ 7992              GetLineNext:
 284+ 7992 FE 20        	cp		' '
 285+ 7994 38 06        	jr		c, NotValid
 286+ 7996
 287+ 7996 FE 80        	cp		128
 288+ 7998 30 02        	jr		nc, NotValid
 289+ 799A 18 03        	jr		Valid
 290+ 799C
 291+ 799C              NotValid:
 292+ 799C CD 23 7A     	call	ReplaceChars
 293+ 799F
 294+ 799F              Valid:
 295+ 799F 12           	ld		(de), a
 296+ 79A0 13           	inc		de
 297+ 79A1 10 D4        	djnz	GetLineLoop
 298+ 79A3
 299+ 79A3              ;if line is exactly 64 char long, must skip the new line char(s)
 300+ 79A3              GetLineSkip0D:
 301+ 79A3 0E 00        	ld		c, 0
 302+ 79A5 3E 0D        	ld		a, CHAR_CR						;skip 0D
 303+ 79A7 BE           	cp		(hl)
 304+ 79A8 20 02        	jr		nz, GetLineSkip0A
 305+ 79AA 23           	inc		hl
 306+ 79AB 0C           	inc		c
 307+ 79AC
 308+ 79AC              GetLineSkip0A:						;skip 0A
 309+ 79AC 3E 0A        	ld		a, CHAR_LF
 310+ 79AE BE           	cp		(hl)
 311+ 79AF 20 02        	jr		nz, GetLineFill
 312+ 79B1 23           	inc		hl
 313+ 79B2 0C           	inc		c
 314+ 79B3
 315+ 79B3              GetLineFill:
 316+ 79B3 78           	ld		a, b
 317+ 79B4 B7           	or		a
 318+ 79B5 20 16        	jr		nz, GetLineFillLoop
 319+ 79B7
 320+ 79B7 79           	ld		a, c
 321+ 79B8 B7           	or		a
 322+ 79B9 C0           	ret		nz
 323+ 79BA
 324+ 79BA              	;wrap or not
 325+ 79BA 3A 3D 7B     	ld		a, (WrapFlag)
 326+ 79BD B7           	or		a
 327+ 79BE C0           	ret		nz
 328+ 79BF
 329+ 79BF ~            	/*
 330+ 79BF ~            	ld		de, (FileEnd)
 331+ 79BF ~            	push	hl
 332+ 79BF ~            		ex		de, hl
 333+ 79BF ~            		or		a
 334+ 79BF ~            		sbc		hl, de
 335+ 79BF ~            		ld		b, h
 336+ 79BF ~            		ld		c, l
 337+ 79BF ~            	pop		hl
 338+ 79BF ~            	*/
 339+ 79BF
 340+ 79BF 3E 0D        	ld		a, CHAR_CR
 341+ 79C1 01 40 00     	ld		bc, COL_CNT
 342+ 79C4 ED B1        	cpir
 343+ 79C6 C0           	ret		nz
 344+ 79C7 3E 0A        	ld		a, CHAR_LF
 345+ 79C9 BE           	cp		(hl)
 346+ 79CA C0           	ret		nz
 347+ 79CB 23           	inc		hl
 348+ 79CC
 349+ 79CC C9           	ret
 350+ 79CD
 351+ 79CD              GetLineFillLoop:				;fill the rest of the displayed line with blanks
 352+ 79CD 3E 20        	ld		a, ' '
 353+ 79CF 12           	ld		(de), a
 354+ 79D0 13           	inc		de
 355+ 79D1 10 FA        	djnz	GetLineFillLoop
 356+ 79D3 C9           	ret
 357+ 79D4
 358+ 79D4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 359+ 79D4              PrintMsg:
 360+ 79D4 ED 5B B0 5C  	ld		de, (COORDS)
 361+ 79D8 D5           	push	de
 362+ 79D9 11 00 17     	ld		de, LINE_CNT<<8
 363+ 79DC ED 53 B0 5C  	ld		(COORDS), de
 364+ 79E0
 365+ 79E0              	;Get current file pointer
 366+ 79E0 DD 6E 00     	ld		l, (ix)
 367+ 79E3 DD 66 01     	ld		h, (ix + 1)
 368+ 79E6 ED 4B 3E 7B  	ld		bc, (FileBegin)
 369+ 79EA B7           	or		a
 370+ 79EB ED 42        	sbc		hl, bc
 371+ 79ED
 372+ 79ED              	;Divide by one percent length
 373+ 79ED 7C           	ld		a, h
 374+ 79EE 4D           	ld		c, l
 375+ 79EF ED 5B 44 7B  	ld		de, (PROGR_PERC)
 376+ 79F3 CD 9E 6D     	call	Div2
 377+ 79F6
 378+ 79F6              	;Display %
 379+ 79F6 11 D6 7A     	ld		de, MsgLinePr
 380+ 79F9 67           	ld		h, a
 381+ 79FA 69           	ld		l, c
 382+ 79FB CD 55 6D     	call	Byte2Txt
 383+ 79FE
 384+ 79FE
 385+ 79FE 2A 3B 7B     	ld		hl, (CurLine)
 386+ 7A01 11 E2 7A     	ld		de, MsgLineNo
 387+ 7A04 CD 4A 6D     	call	Word2Txt
 388+ 7A07
 389+ 7A07 11 CD 7A     	ld		de, MsgLine
 390+ 7A0A 06 2E        	ld		b, MsgLineLen
 391+ 7A0C CD 58 79     	call	PrintStrTxt
 392+ 7A0F D1           	pop		de
 393+ 7A10 ED 53 B0 5C  	ld		(COORDS), DE
 394+ 7A14
 395+ 7A14 21 E0 5A     	ld		hl, SCR_ADDR + SCR_PIX_LEN + LINE_CNT*32
 396+ 7A17 54           	ld		d, h
 397+ 7A18 5D           	ld		e, l
 398+ 7A19 13           	inc		de
 399+ 7A1A 3E 20        	ld		a, SCR_LBL_CLR
 400+ 7A1C 77           	ld		(hl), a
 401+ 7A1D 01 1F 00     	ld		bc, SCR_BYTES_PER_LINE-1
 402+ 7A20 ED B0        	ldir
 403+ 7A22 C9           	ret
 404+ 7A23
 405+ 7A23
 406+ 7A23              ReplaceChars:
 407+ 7A23 E5           	push	hl
 408+ 7A24 C5           	push	bc
 409+ 7A25 21 B3 7A     		ld		hl, CharReplaceTbl
 410+ 7A28 06 0D        		ld		b, CharReplTblLen
 411+ 7A2A              ReplaceSGCLoop:
 412+ 7A2A BE           		cp		(hl)
 413+ 7A2B 28 09        		jr		z, ReplaceMatch
 414+ 7A2D 23           		inc		hl
 415+ 7A2E 23           		inc		hl
 416+ 7A2F 10 F9        		djnz	ReplaceSGCLoop
 417+ 7A31
 418+ 7A31 3E 3F        		ld		a, '?'
 419+ 7A33 C1           		pop		bc
 420+ 7A34 E1           		pop		hl
 421+ 7A35 C9           	ret
 422+ 7A36
 423+ 7A36              ReplaceMatch:
 424+ 7A36 23           		inc		hl
 425+ 7A37 7E           		ld		a, (hl)
 426+ 7A38 C1           	pop		bc
 427+ 7A39 E1           	pop		hl
 428+ 7A3A C9           	ret
 429+ 7A3B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 430+ 7A3B
 431+ 7A3B              	include	"scroll.asm"
# file opened: scroll.asm
   1++7A3B              ;Scrolling routines for UP/DOWN
   2++7A3B              ;They use 2 tables of pointers of screen cell rows.
   3++7A3B              ;One table has addresses in increasing order, for scroll down,
   4++7A3B              ;the other in decreasing order, for scroll up, so the same
   5++7A3B              ;scroll routine is used in both cases.
   6++7A3B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++7A3B
   8++7A3B              ; Char Down
   9++7A3B              ; Adjusts screen address HL to move eight pixels down on the display.
  10++7A3B              ; enter: HL = valid screen address
  11++7A3B              ; exit : HL = moves one character down
  12++7A3B              ; used : AF, HL
  13++7A3B              GetCellDown:
  14++7A3B 7D           	ld a,l
  15++7A3C C6 20        	add a,$20
  16++7A3E 6F           	ld l,a
  17++7A3F D0           	ret nc
  18++7A40 7C           	ld a,h
  19++7A41 C6 08        	add a,$08
  20++7A43 67           	ld h,a
  21++7A44 C9           	ret
  22++7A45
  23++7A45              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++7A45              ;Fills the two tables with pointers.
  25++7A45              ScrollInit:
  26++7A45 21 00 40     	ld		hl, SCR_ADDR
  27++7A48 06 17        	ld		b, LINE_CNT
  28++7A4A              FillScrLinesLoop:
  29++7A4A              FillScrLinesPtr	EQU	$ + 1			;pointer in table
  30++7A4A 22 00 5B     	ld		(SCRLinesDown), hl
  31++7A4D              	;inc. pointer in destination table (of pointers to lines)
  32++7A4D ED 5B 4B 7A  	ld		de, (FillScrLinesPtr)
  33++7A51 13           	inc		de
  34++7A52 13           	inc		de
  35++7A53 ED 53 4B 7A  	ld		(FillScrLinesPtr), de
  36++7A57 CD 3B 7A     	call	GetCellDown
  37++7A5A 10 EE        	djnz	FillScrLinesLoop
  38++7A5C
  39++7A5C              	;now fill the table in reverse
  40++7A5C ED 73 70 7A  	ld		(FillScrLinesSPStore), sp
  41++7A60 31 5C 5B     	ld		sp, SCRLinesUp + LINE_CNT*2
  42++7A63 06 17        	ld		b, LINE_CNT
  43++7A65 21 00 5B     	ld		hl, SCRLinesDown
  44++7A68              FillScrLinesRev:
  45++7A68 5E           	ld		e, (hl)
  46++7A69 23           	inc		hl
  47++7A6A 56           	ld		d, (hl)
  48++7A6B 23           	inc		hl
  49++7A6C D5           	push	de
  50++7A6D 10 F9        	djnz	FillScrLinesRev
  51++7A6F              FillScrLinesSPStore	EQU	$ + 1
  52++7A6F 31 00 00     	ld		sp, 0
  53++7A72 C9           	ret
  54++7A73
  55++7A73              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  56++7A73              ScrollUp:
  57++7A73 21 2E 5B     	ld		hl, SCRLinesUp
  58++7A76 18 03        	jr		Scroll
  59++7A78
  60++7A78              ScrollDown:
  61++7A78 21 00 5B     	ld		hl, SCRLinesDown
  62++7A7B
  63++7A7B              Scroll:
  64++7A7B 22 89 7A     	ld		(ScrollDownPtrDest), hl
  65++7A7E 23           	inc		hl
  66++7A7F 23           	inc		hl
  67++7A80 22 8C 7A     	ld		(ScrollDownPtrSrc), hl
  68++7A83 0E 16        	ld		c, LINE_CNT - 1
  69++7A85
  70++7A85              ScrollDownLoop2:
  71++7A85 06 04        	ld		b, 4
  72++7A87              ScrollDownPtrDest	EQU	$ + 2
  73++7A87 ED 5B 00 5B  	ld		de, (SCRLinesDown)
  74++7A8B              ScrollDownPtrSrc	EQU	$ + 1
  75++7A8B 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  76++7A8E
  77++7A8E              ScrollDownLoop:					;copy a single char line
  78++7A8E C5           	push	bc
  79++7A8F 01 20 00     	ld		bc, 32
  80++7A92 ED B0        	ldir
  81++7A94 2B           	dec		hl
  82++7A95 1B           	dec		de
  83++7A96 24           	inc		h
  84++7A97 14           	inc		d
  85++7A98 01 20 00     	ld		bc, 32
  86++7A9B ED B8        	lddr
  87++7A9D 23           	inc		hl
  88++7A9E 13           	inc		de
  89++7A9F 24           	inc		h
  90++7AA0 14           	inc		d
  91++7AA1 C1           	pop		bc
  92++7AA2 10 EA        	djnz	ScrollDownLoop
  93++7AA4
  94++7AA4 0D           	dec		c
  95++7AA5 C8           	ret		z
  96++7AA6
  97++7AA6 2A 8C 7A     	ld		hl, (ScrollDownPtrSrc)
  98++7AA9 22 89 7A     	ld		(ScrollDownPtrDest), hl
  99++7AAC 23           	inc		hl
 100++7AAD 23           	inc		hl
 101++7AAE 22 8C 7A     	ld		(ScrollDownPtrSrc), hl
 102++7AB1 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
 432+ 7AB3
 433+ 7AB3              CharReplaceTbl:
 434+ 7AB3 B3 80        	defb	179, 128
 435+ 7AB5 B4 81        	defb	180, 129
 436+ 7AB7 BF 82        	defb	191, 130
 437+ 7AB9 C0 83        	defb	192, 131
 438+ 7ABB C1 84        	defb	193, 132
 439+ 7ABD C2 85        	defb	194, 133
 440+ 7ABF C3 86        	defb	195, 134
 441+ 7AC1 C4 87        	defb	196, 135
 442+ 7AC3 C5 88        	defb	197, 136
 443+ 7AC5 D9 89        	defb	217, 137
 444+ 7AC7 DA 8A        	defb	218, 138
 445+ 7AC9 DB 8B        	defb	219, 139
 446+ 7ACB DC 8C        	defb	220, 140
 447+ 7ACD              CharReplTblLen EQU	($ - CharReplaceTbl)/2
 448+ 7ACD
 449+ 7ACD 50 72 6F 67  MsgLine		defb	'Progress:'
 449+ 7AD1 72 65 73 73
 449+ 7AD5 3A
 450+ 7AD6 20 20 20 25  MsgLinePr	defb	'   %; '
 450+ 7ADA 3B 20
 451+ 7ADC 4C 69 6E 65  			defb	'Line: '
 451+ 7AE0 3A 20
 452+ 7AE2 20 20 20 20  MsgLineNo	defb	'     ; '
 452+ 7AE6 20 3B 20
 453+ 7AE9 32 2D 57 72  MsgLineWrap	defb	'2-Wrap '
 453+ 7AED 61 70 20
 454+ 7AF0 20 4F 6E     MsgLineWrF	defb	' On'
 455+ 7AF3 3B 20 30 2D  			defb	'; 0-Exit'
 455+ 7AF7 45 78 69 74
 456+ 7AFB              MsgLineLen	EQU		$ - MsgLine
 457+ 7AFB
 458+ 7AFB 20 20 20 20  LineBuf		defb	'                                                                '
 458+ 7AFF 20 20 20 20
 458+ 7B03 20 20 20 20
 458+ 7B07 20 20 20 20
 458+ 7B0B 20 20 20 20
 458+ 7B0F 20 20 20 20
 458+ 7B13 20 20 20 20
 458+ 7B17 20 20 20 20
 458+ 7B1B 20 20 20 20
 458+ 7B1F 20 20 20 20
 458+ 7B23 20 20 20 20
 458+ 7B27 20 20 20 20
 458+ 7B2B 20 20 20 20
 458+ 7B2F 20 20 20 20
 458+ 7B33 20 20 20 20
 458+ 7B37 20 20 20 20
 459+ 7B3B 00 00        CurLine		defw	0
 460+ 7B3D 01           WrapFlag	defb	1
 461+ 7B3E 00 00        FileBegin	defw	0
 462+ 7B40 00 00        FileLen		defw	0
 463+ 7B42 00 00        FileEnd		defw	0
 464+ 7B44 00 00        PROGR_PERC	defw	0
 465+ 7B46
 466+ 7B46              SCRLinesDown	EQU PRN_BUF
 467+ 7B46              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
 468+ 7B46              End:
 469+ 7B46
# file closed: txtview.asm
1239  7B46              	include "serial.asm"
# file opened: serial.asm
   1+ 7B46              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7B46              ;They work with 19200 theoretical speed.
   3+ 7B46              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7B46
   5+ 7B46              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7B46              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7B46
   8+ 7B46
   9+ 7B46              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7B46              ; A=1 IF FRAMING ERROR
  11+ 7B46              ; USES BC,D _DOES NOT USE E!_
  12+ 7B46              SERRXI:
  12+ 7B46
  13+ 7B46 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7B49 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 7B4B D3 EF        	OUT	(0EFH),A
  16+ 7B4D
  17+ 7B4D              	; WAIT FOR START
  18+ 7B4D              SERWSL:
  19+ 7B4D 0B           	DEC	BC
  20+ 7B4E AF           	XOR	A
  21+ 7B4F B8           	CP	B
  22+ 7B50 20 03        	JR	NZ,SERWS
  23+ 7B52 B9           	CP	C
  24+ 7B53 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7B55 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7B57 CB 7F        	BIT	7,A
  27+ 7B59 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 7B5B
  29+ 7B5B              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 7B5B              ; OF BIT 0
  31+ 7B5B 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 7B5D 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 7B5F
  34+ 7B5F              ; GET AND SHIFT BITS
  35+ 7B5F              SERRL:
  36+ 7B5F 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7B61 00           	NOP			; 4 (TIMING)
  38+ 7B62 00           	NOP			; 4 (TIMING)
  39+ 7B63 00           	NOP			; 4 (TIMING)
  40+ 7B64 DB F7        	IN	A,(0F7H)	; 11
  41+ 7B66 17           	RLA			; 4
  42+ 7B67 CB 1A        	RR	D		; 8
  43+ 7B69 06 0A        	LD	B,CBAUD		; 7
  44+ 7B6B 0D           	DEC	C		; 4
  45+ 7B6C 20 F1        	JR	NZ,SERRL	; 12
  46+ 7B6E
  47+ 7B6E              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 7B6E              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 7B6E              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 7B6E              ; IDLE UNTIL NEXT START BIT
  51+ 7B6E 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7B70 D3 EF        	OUT	(0EFH),A
  53+ 7B72
  54+ 7B72 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7B74              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7B74              SERWIL:
  57+ 7B74 05           	DEC	B
  58+ 7B75 28 0E        	JR	Z,SERRTF
  59+ 7B77 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7B79 CB 7F        	BIT	7,A
  61+ 7B7B 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 7B7D
  63+ 7B7D              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 7B7D 7A           	LD	A,D
  65+ 7B7E 2F           	CPL			; INVERT BITS
  66+ 7B7F 57           	LD	D,A
  67+ 7B80 AF           	XOR	A		; 0 = SUCCESS
  68+ 7B81 C9           	RET
  69+ 7B82
  70+ 7B82              ; TIMEOUT
  71+ 7B82              SERRTO:
  72+ 7B82 3E FF        	LD	A,0FFH
  73+ 7B84 C9           	RET
  74+ 7B85
  75+ 7B85              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7B85              SERRTF:
  77+ 7B85 3E 01        	LD	A,01H
  78+ 7B87 C9           	RET
  79+ 7B88
  80+ 7B88
  81+ 7B88
  82+ 7B88              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7B88              SERRB:
  83+ 7B88
  84+ 7B88              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7B88              ; BITMAPPED OPTIONS IN E:
  86+ 7B88              ; XXXXXXIT
  87+ 7B88              ; I SET = leave Interrupts disabled at exit
  88+ 7B88              ; T SET = return after Timeout
  89+ 7B88              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7B88              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7B88              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7B88 F3           	DI
  93+ 7B89 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 7B8A              				; OF RECEIVED BYTES
  95+ 7B8A
  96+ 7B8A              SERRBL:
  97+ 7B8A C5           	PUSH	BC
  98+ 7B8B CD 46 7B     	CALL	SERRXI
  99+ 7B8E C1           	POP	BC
 100+ 7B8F B7           	OR	A
 101+ 7B90 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7B92 72           	LD	(HL),D
 103+ 7B93 23           	INC	HL
 104+ 7B94 0B           	DEC	BC
 105+ 7B95 AF           	XOR	A
 106+ 7B96 B8           	CP	B
 107+ 7B97 20 F1        	JR	NZ,SERRBL
 108+ 7B99 B9           	CP	C
 109+ 7B9A 20 EE        	JR	NZ,SERRBL
 110+ 7B9C              ; FULL RECEIVE
 111+ 7B9C C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 7B9D
 113+ 7B9D              SERRBX:				; EXIT
 114+ 7B9D CB 4B        	BIT	1,E
 115+ 7B9F C0           	RET	NZ
 116+ 7BA0 FB           	EI
 117+ 7BA1 C9           	RET
 118+ 7BA2
 119+ 7BA2              SERRBT:
 120+ 7BA2 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7BA4 28 04        	JR	Z,SERRBC
 122+ 7BA6 CB 43        	BIT	0,E
 123+ 7BA8 28 E0        	JR	Z,SERRBL
 124+ 7BAA
 125+ 7BAA              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7BAA EB           	EX	DE,HL		; PRESERVE HL
 127+ 7BAB E1           	POP	HL		; GET INITIAL COUNT
 128+ 7BAC 37           	SCF
 129+ 7BAD 3F           	CCF
 130+ 7BAE ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7BB0 44           	LD	B,H
 132+ 7BB1 4D           	LD	C,L		; BC = COUNT
 133+ 7BB2 EB           	EX	DE,HL		; RESTORE HL
 134+ 7BB3
 135+ 7BB3 18 E8        	JR	SERRBX
 136+ 7BB5
 137+ 7BB5              SERRX:
 137+ 7BB5
 138+ 7BB5              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7BB5              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7BB5              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7BB5 F3           	DI
 142+ 7BB6 CD 46 7B     	CALL	SERRXI
 143+ 7BB9 FB           	EI
 144+ 7BBA C9           	RET
 145+ 7BBB
 146+ 7BBB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7BBB              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7BBB              SERTB:
 148+ 7BBB
 149+ 7BBB 7E           	LD	A,(HL)
 150+ 7BBC C5           	PUSH	BC
 151+ 7BBD CD C8 7B     		CALL	SERTX
 152+ 7BC0 C1           	POP	BC
 153+ 7BC1 23           	INC	HL
 154+ 7BC2 0B           	DEC BC
 155+ 7BC3 78           	LD	A, B
 156+ 7BC4 B1           	OR	C
 157+ 7BC5 20 F4        	JR	NZ, SERTB
 158+ 7BC7 C9           	RET
 159+ 7BC8
 160+ 7BC8              ; SEND CHAR ROUTINE
 161+ 7BC8              SERTX:
 161+ 7BC8
 162+ 7BC8 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7BC9 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7BCA F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7BCB 3E 01        	LD	A,01H
 166+ 7BCD D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7BCF 1E 20        	LD	E,20H	; PORT MASK
 168+ 7BD1 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 7BD3 3E 01        	LD	A,1
 170+ 7BD5 C3 DC 7B     	JP	SBIT
 171+ 7BD8
 172+ 7BD8 AF           SHLOOP:	XOR	A		; 4
 173+ 7BD9 CB 3A        	SRL	D		; 8
 174+ 7BDB 17           	RLA			; 4
 175+ 7BDC              SBIT:
 176+ 7BDC B3           	OR	E		; 4
 177+ 7BDD D3 EF        	OUT	(0EFH),A	; 11
 178+ 7BDF 06 0A        	LD	B,CBAUD		; 7
 179+ 7BE1              SBITDL:
 180+ 7BE1 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 7BE3 00           	NOP			; 4 (TIMING)
 182+ 7BE4 0D           	DEC	C		; 4
 183+ 7BE5 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 7BE7              ; STOP BIT
 185+ 7BE7 3E 20        	LD	A,20H
 186+ 7BE9 D3 EF        	OUT	(0EFH),A
 187+ 7BEB 06 0A        	LD	B,CBAUD
 188+ 7BED 10 FE        STOPL:	DJNZ	STOPL
 189+ 7BEF FB           	EI
 190+ 7BF0 C9           	RET
# file closed: serial.asm
1240  7BF1
1241  7BF1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1242  7BF1 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-07-11"
1242  7BF5 64 20 32 30
1242  7BF9 32 33 2D 30
1242  7BFD 37 2D 31 31
1243  7C01 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1243  7C05 67 65 20 43
1243  7C09 68 69 72 74
1243  7C0D 6F 61 63 E1
1244  7C11 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1244  7C15 72 61 6D 20
1244  7C19 49 6E 66 6F
1244  7C1D 20 20 20 A0
1245  7C21 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1245  7C25 20 49 6E 66
1245  7C29 6F 20 20 20
1245  7C2D 20 20 20 A0
1246  7C31 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1246  7C35 20 49 6E 66
1246  7C39 6F 20 20 20
1246  7C3D 20 20 20 A0
1247  7C41 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1247  7C45 61 67 65 73
1247  7C49 20 20 20 20
1247  7C4D 20 20 20 A0
1248  7C51 31 2D 41 3A  BtnBar			DEFM	'1-A: 2-B: 3-View 4-Prop 5-Copy 6-Ren 7-Attr 8-Del 9-Disk 0-Exi', 't' + $80
1248  7C55 20 32 2D 42
1248  7C59 3A 20 33 2D
1248  7C5D 56 69 65 77
1248  7C61 20 34 2D 50
1248  7C65 72 6F 70 20
1248  7C69 35 2D 43 6F
1248  7C6D 70 79 20 36
1248  7C71 2D 52 65 6E
1248  7C75 20 37 2D 41
1248  7C79 74 74 72 20
1248  7C7D 38 2D 44 65
1248  7C81 6C 20 39 2D
1248  7C85 44 69 73 6B
1248  7C89 20 30 2D 45
1248  7C8D 78 69 F4
1249  7C90 44 72 69 76  MsgDrive		DEFM	'Drive   :      '
1249  7C94 65 20 20 20
1249  7C98 3A 20 20 20
1249  7C9C 20 20 20
1250  7C9F C1           MsgDriveLet		DEFM	'A' | $80
1251  7CA0 46 69 6C 65  MsgFilesCnt		DEFM	'Files   :'
1251  7CA4 73 20 20 20
1251  7CA8 3A
1252  7CA9 30 30 30 2F  MsgFilesCntNo	DEFM	'000/12', '8' + $80
1252  7CAD 31 32 B8
1253  7CB0 46 72 65 65  MsgFreeSpace	DEFM	'Free KB :'
1253  7CB4 20 4B 42 20
1253  7CB8 3A
1254  7CB9 30 30 30 2F  MsgFreeSpaceNo	DEFM	'000/63', '6' + $80
1254  7CBD 36 33 B6
1255  7CC0 45 72 72 6F  MsgErr			DEFM	'Error code '
1255  7CC4 72 20 63 6F
1255  7CC8 64 65 20
1256  7CCB 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1257  7CCF 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1257  7CD3 69 6E 67 20
1257  7CD7 50 72 6F 67
1257  7CDB 72 61 ED
1258  7CDE 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1258  7CE2 69 6E 67 20
1258  7CE6 53 43 52 45
1258  7CEA 45 4E A4
1259  7CED 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1259  7CF1 69 6E 67 20
1259  7CF5 43 4F 44 45
1259  7CF9 20 28 21 A9
1260  7CFD 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1260  7D01 20 4C 65 6E
1260  7D05 3A
1261  7D06 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1261  7D0A 30 20 CB
1262  7D0D 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1262  7D11 69 62 20 20
1262  7D15 3A
1263  7D16 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1263  7D1A 48 49 C4
1264  7D1D 54 79 70 65  MsgFileType		DEFM	'Type    :'
1264  7D21 20 20 20 20
1264  7D25 3A
1265  7D26 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1265  7D2A 20 20 20 20
1265  7D2E 20 A0
1266  7D30 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1266  7D34 72 61 ED
1267  7D37 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1267  7D3B 73 20 A0
1268  7D3E 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1268  7D42 45 4E A4
1269  7D45 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1269  7D49 41 72 F2
1270  7D4C 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1270  7D50 41 72 F2
1271  7D53 4E 6F 6E 65  MsgFileTypeText	DEFM	'None  ', ' ' + $80
1271  7D57 20 20 A0
1272  7D5A 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1272  7D5E 20 20 A0
1273  7D61 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1273  7D65 74 68 20 20
1273  7D69 3A
1274  7D6A 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1274  7D6E 35 20 C2
1275  7D71 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1275  7D75 74 20 20 20
1275  7D79 3A
1276  7D7A 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1276  7D7E 35 20 A0
1277  7D81 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1277  7D85 69 6E 67 20
1277  7D89 68 65 61 64
1277  7D8D 65 F2
1278  7D8F 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1278  7D93 20 20 20 20
1278  7D97 20 20 20 20
1278  7D9B 20 20 20 A0
1279  7D9F 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1279  7DA3 66 69 6C 65
1279  7DA7 3F 20 79 2F
1279  7DAB EE
1280  7DAC 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1280  7DB0 52 2F 4F 3F
1280  7DB4 20 79 2F EE
1281  7DB8 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1281  7DBC 48 49 44 3F
1281  7DC0 20 79 2F EE
1282  7DC4 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1282  7DC8 3F 6E 6F 6E
1282  7DCC 65 3D 61 62
1282  7DD0 6F 72 74 BA
1283  7DD4 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1283  7DD8 20 6D 65 6E
1283  7DDC 75 BA
1284  7DDE 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1284  7DE2 20 63 6F 70
1284  7DE6 79 20 6D 65
1284  7DEA 6E 75 BA
1285  7DED 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1285  7DF1 78 69 74 20
1285  7DF5 6D 65 6E F5
1286  7DF9
1287  7DF9 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1287  7DFD 6F 70 79 20
1288  7E01 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1289  7E05 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1290  7E07
1291  7E07 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1291  7E0B 6F 70 79 20
1292  7E0F 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1293  7E13 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1294  7E15
1295  7E15 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1295  7E19 6F 70 79 20
1296  7E1D 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1296  7E21 43 4F CD
1297  7E24
1298  7E24 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1298  7E28 6F 70 79 20
1298  7E2C 43 4F 4D 2D
1298  7E30 3E
1299  7E31 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1300  7E33
1301  7E33 35 2E 20 46  MsgMenuFmt		DEFM	'5. Format '
1301  7E37 6F 72 6D 61
1301  7E3B 74 20
1302  7E3D 41 BA        MsgMenuFmtDrv	DEFM	'A', ':' | $80
1303  7E3F
1304  7E3F 46 6F 72 6D  MsgFormat		DEFM	'Formatting '
1304  7E43 61 74 74 69
1304  7E47 6E 67 20
1305  7E4A 41 BA        MsgFormatDrv	DEFM	'A', ':' | $80
1306  7E4C
1307  7E4C 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1307  7E50 62 6C 6F 63
1307  7E54 6B 73 20 6C
1307  7E58 65 66 F4
1308  7E5B 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1308  7E5F 77 72 69 74
1308  7E63 65 3F 20 79
1308  7E67 2F EE
1309  7E69 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1309  7E6D 20 6E 61 6D
1309  7E71 65 20 65 78
1309  7E75 69 73 74 F3
1310  7E79 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1310  7E7D 53 4F 55 52
1310  7E81 43 45 20 64
1310  7E85 69 73 EB
1311  7E88 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1311  7E8C 44 45 53 54
1311  7E90 2E 20 64 69
1311  7E94 73 6B A0
1312  7E97 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1312  7E9B 73 20 61 6E
1312  7E9F 79 20 6B 65
1312  7EA3 F9
1313  7EA4 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1313  7EA8 73 65 63 74
1313  7EAC 6F 72 73 20
1313  7EB0 63 6F 70 F9
1314  7EB4
1315  7EB4              	IFNDEF	_REAL_HW_
1316  7EB4 ~            FontTable:
1317  7EB4 ~            	incbin "cpmfnt.bin"
1318  7EB4              	ENDIF
1319  7EB4              EndCode:
1320  7EB4
1321  7EB4              ;Unalocated variables
1322  7EB4              UnallocStart	EQU		EndCode
1323  7EB4              FileCnt			EQU		UnallocStart			;File counter, 1B
1324  7EB4              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1325  7EB4              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1326  7EB4              CursorAddr		EQU		SelFile + 1				;2 B
1327  7EB4              AUCnt			EQU		CursorAddr + 2			;2 B
1328  7EB4              SelFileCache	EQU		AUCnt + 2				;2 B
1329  7EB4              CopySelOption	EQU		SelFileCache+2			;1 B
1330  7EB4
1331  7EB4              CopyFileFCB		EQU	CopySelOption + 1
1332  7EB4              CopyFileRes		EQU CopyFileFCB + 2
1333  7EB4              CopyFileDMAAddr	EQU	CopyFileRes + 1
1334  7EB4              FilePosRead		EQU	CopyFileDMAAddr + 2
1335  7EB4              FilePosWrite	EQU	FilePosRead + 2
1336  7EB4              CopyFileSectCnt EQU FilePosWrite + 2
1337  7EB4              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1338  7EB4              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1339  7EB4              CopyFileDstDrv	EQU CopyFileSrcName + 11
1340  7EB4              CopyFileDstName	EQU CopyFileDstDrv + 1
1341  7EB4
1342  7EB4              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1343  7EB4              ;FS block list constants
1344  7EB4              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1345  7EB4              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1346  7EB4              UsedBlockListSz		EQU 320 * 2 + 2							;640
1347  7EB4
1348  7EB4              	IFDEF	_REAL_HW_
1349  7EB4              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1350  7EB4              DataBuf			EQU		FontTable + 872
1351  7EB4              	ELSE
1352  7EB4 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1353  7EB4              	ENDIF
1354  7EB4
1355  7EB4              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1356  7EB4
1357  7EB4
1358  7EB4              ;File viewer constants
1359  7EB4              FileData		EQU		DataBuf
1360  7EB4              ;File buffer size, without index
1361  7EB4              FileIdxSize		EQU		2 * 1024
1362  7EB4              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1363  7EB4              ;Set a few KB aside for file indexing
1364  7EB4              FileIdx			EQU		FileData + FileDataSize
1365  7EB4              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1366  7EB4
1367  7EB4
1368  7EB4              ;Copy buffer size, follows
1369  7EB4              CopyDiskBuf			EQU DataBuf
1370  7EB4
1371  7EB4              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1372  7EB4              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1373  7EB4              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1374  7EB4
1375  7EB4              	DISPLAY "DataBuf: ", /D,DataBuf
1376  7EB4              	DISPLAY "BinSize: ", /D, EndCode - Start
1377  7EB4              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1378  7EB4              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6D9B   NoSub
0x6D94   DivLoop
0x7202   MAX_RAM_FREE
0x0072   MAX_SECT_RAM
0x0800   FileIdxSize
0x0282   UsedBlockListSz
0x7EB4   UnallocStart
0x7EB4   EndCode
0x7BED   STOPL
0x7BD8   SHLOOP
0x7BDC   SBIT
0x7BE1   SBITDL
0x7BC8   SERTX
0x7BB5 X SERRX
0x7BAA   SERRBC
0x7B9D   SERRBX
0x7BA2   SERRBT
0x7B8A   SERRBL
0x7B77 X SERWI
0x7B85   SERRTF
0x7B74   SERWIL
0x7B5F   SERRL
0x7B82   SERRTO
0x7B55   SERWS
0x7B4D   SERWSL
0x7B46   SERRXI
0x000A   CBAUD
0x7B46 X End
0x7AE9 X MsgLineWrap
0x7A8E   ScrollDownLoop
0x7A85   ScrollDownLoop2
0x7A8C   ScrollDownPtrSrc
0x7A89   ScrollDownPtrDest
0x7A7B   Scroll
0x7A68   FillScrLinesRev
0x5B2E   SCRLinesUp
0x7A70   FillScrLinesSPStore
0x5B00   SCRLinesDown
0x7A4B   FillScrLinesPtr
0x7A4A   FillScrLinesLoop
0x7A3B   GetCellDown
0x7A36   ReplaceMatch
0x7A2A   ReplaceSGCLoop
0x000D   CharReplTblLen
0x7AB3   CharReplaceTbl
0x002E   MsgLineLen
0x7ACD   MsgLine
0x7AE2   MsgLineNo
0x7AD6   MsgLinePr
0x79B3   GetLineFill
0x7A23   ReplaceChars
0x799F   Valid
0x799C   NotValid
0x79A3   GetLineSkip0D
0x7992   GetLineNext
0x79CD   GetLineFillLoop
0x798B   GetLineTab
0x79AC   GetLineSkip0A
0x7977   GetLineLoop
0x7958   PrintStrTxt
0x7AFB   LineBuf
0x7A78   ScrollDown
0x7A73   ScrollUp
0x7929   CheckBegin
0x7AF0   MsgLineWrF
0x78BB   NoWrap
0x7B3D   WrapFlag
0x78CA   Up
0x78F5   Down
0x7875   GetKey
0x7884   ViewFileEOF
0x7939   CheckEnd
0x7944   PrintLine
0x7972   GetLine
0x79D4   PrintMsg
0x7B44   PROGR_PERC
0x7B3B   CurLine
0x7A45   ScrollInit
0x7B40   FileLen
0x7B42   FileEnd
0x7B3E   FileBegin
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A   CHAR_LF
0x000D   CHAR_CR
0x0040   COL_CNT
0x0017   LINE_CNT
0x77DF   ClearNMsgLinesLoop
0x77CD   ReadStrPrint
0x77BD   ReadStrChar
0x77A0   ReadStringLoop
0x7794   Store
0x7793   NoTurn
0x7788   PrintCharLine
0x7774 X PrintChar3
0x771F   DrawCursorLoop
0x7706   DrawVLinesLoop
0x76D7   DrawLowerIntersectLoop
0x76E8   DrawIntersect
0x76C2   DrawUpperIntersectLoop
0x7696   DrawLineLoop
0x76A3   LineDir
0x7693   StoreDir
0x7691   VertDir
0x7688   DrawLine
0x7684   StrClr
0x7637   GoodChar
0x77EF   CurrScrAddr
0x8996   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A X CHR_LF
0x000D X CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x75B7   ReadWriteFileSectionLoop
0x75D5   ReadWriteFileSectionEnd
0x7EC1   CopyFileDMAAddr
0x7EBE   CopyFileFCB
0x757C   ReadWriteFileSection
0x006A   MAX_SECT_BUF
0x75E6   CopyFilePtr2
0x75A2   CopyFilePtr
0x75CA   CopyFileOperAddr2
0x75AB   CopyFileOperAddr1
0x752D   CopyFileFromCOMDontInc
0x6A00   FileDataSize
0x751A   CopyFileFromCOMLoop
0x74B9   CopyFileToCOMEnd
0x749B   CopyFileToCOMLoop
0x7455   CopyFileDualDriveLoop
0x7563   WriteFileSection
0x7EA4   MsgCopySectors
0x73EE   CopyFileSameDriveLoop
0x7EC7   CopyFileSectCnt
0x73AC   CopyFileCreateNewFile
0x7E5B   MsgFileOverwrite
0x7390   CopyFileCheckOverwrite
0x74BE   CopyFileFromCOM
0x748D   CopyFileToCOM
0x7445   CopyFileDualDrive
0x73CA   CopyFileSameDrive
0x7379   CopyFileNotExit
0x7DDE   MsgMenuFileCopy
0x7EC5   FilePosWrite
0x7ED5   CopyFileDstName
0x7EC9   CopyFileSrcName
0x7E79   MsgInsertSrcDsk
0x7E97   MsgPressAnyKey
0x7E88   MsgInsertDstDsk
0x727C X FileAttribSet
0xF6FE   FileIdx
0x722A   GetFileSizeMul
0x7230   GetFileSizeEnd
0x7228   GetFileSizeOK
0x7208   BDOSSetRandFilePtr
0x7204   BDOSSetDMA
0x71F6   BDOSWriteFileBlockRandom
0x71F2   BDOSReadFileBlockRandom
0x71EE   BDOSWriteFileBlockSeq
0x71EA   BDOSReadFileBlockSeq
0x71E6   BDOSCloseFile
0x71E2   BDOSOpenFile
0x71DE   BDOSCreateFile
0x71D4   DestroyChannel
0x71BE   CreateChannel
0x71BE X BDOSGetCurrentDisk
0x71BE X BDOSGetDiskRO
0x71BE X BDOSMakeDiskRO
0x71FA   BDOS
0x71A2   InterleaveTbl
0x71A0 X PrmIntrlvTbl
0x719F X PrmSpinUp
0x719E X PrmHeadLoad
0x719C X PrmDevType
0x7197 X RWTSResTmp
0x7196 X RWTSResVolNo
0x719C   BasPrmTbl
0x7192 X RWTSPrmTbl
0x7190 X RWTSExtBuf
0x718D X RWTSSector
0x718B X RWTSVolNo
0x7189 X RWTSBlockType
0x7180   CopyMsg
0x7174   SearchMsgEnd
0x717D   SaveMsg
0x716B   IF1Paged
0x7139   IF1Call
0x7134   IsFileHeaderValidLoop
0x720C   GetFileSize
0x7118   ReadFileHeaderIsTextFile
0x7131   IsFileHeaderValid
0x712D   ReadHeaderEnd
0x70D2   CacheNotFinished
0x71B5   BDOSSelectDisk
0x706F   FileReadLoop
0x7063 X FileLoadHeader
0x7075   FileLoadNoHeader
0x7083   FileFree
0x703F   MisMatch
0x7037   Compare
0x7035   StrCmp
0x6FEC   CopyDiskFromCOMLoop
0x7B88   SERRB
0x6F88   CopyDiskToCOMLoop
0x7BBB   SERTB
0x72C2   PromptDiskChangeSrc
0x6F60   CopyDiskDualDrive2
0x6F6D   CopyDiskEnd
0x6F3C X CopyDiskWriteEnd
0x6F25   CopyDiskLoopWriteLoop
0x6F1E   CopyDiskReadEnd
0x71B2   BDOSInit
0x72A8   PromptDiskChangeDst
0x6F14   CopyDiskDualDrive1
0x6EEB   CopyDiskLoopReadLoop
0x8CFE   CopyDiskBuf
0x6EE4   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7E4C   MsgBlocksLeft
0x6EC1   CopyDiskLoop
0x8716   UsedBlockListBlk
0x709B   WriteDiskSectors
0x6EAD   WriteFSBlock
0x7088   ReadDiskSectors
0x6EA0   ReadFSBlock
0x6E92   ReadUsedBlocksSkip
0x6E75   ReadUsedBlocksLoop2
0x6E95   ReadUsedBlocksSkip2
0x6E65   ReadUsedBlocksLoop
0x8714   UsedBlockListCnt
0x6E48   ReadUsedBlocksList
0x6E41   CheckAUEnd
0x6E2D   CheckAU
0x6E16   FirstAU
0x6E10   Track0
0x6DFB   AU2TS
0x7195   RWTSRes
0x6DDF   WriteOneDiskSector
0x718C   RWTSTrack
0x718E   RWTSDMA
0x6DD4   ReadOneDiskSector
0x7189   RWTSParams
0x7194   RWTSCmd
0x6DC8   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0005 X HDR_PLEN
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_POS
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x001A   CHAR_EOF
0x5CED   HD11
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0050   TRACK_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6DC2   NoAdd
0x6DBC   MulLoop
0x6DA3   Div2Loop
0x6D9E   Div2
0x6D91   Div
0x6D88   DivNrLoop
0x6D86   DigitLoop
0x6D77   Byte2Txt_
0x6D60   StrippLeading0
0x6D6B   Word2Txt_
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x6D47   DontInc
0x6D41   ReadAllHeadersEnd
0x6D2C   AKey
0x75F7   KbdHit
0x6D11   NextFile
0x7D61   MsgFileLen
0x7D1D   MsgFileType
0x7D71   MsgFileStart
0x6CD0   PrintStartStr
0x7D7A   MsgFileStartN
0x7D5A   MsgNA
0x6CC2   PrintStart
0x0007   HDR_LINE
0x6C9D   PrintByteStart
0x6C95   PrintProgStart
0x7D6A   MsgFileLenN
0x6C7B X PrepFileLenText
0x7D53   MsgFileTypeText
0x7D37   MsgFileTypeByte
0x7D3E   MsgFileTypeSCR
0x6C61   NotScr
0x6C6C   CheckText
0x7D45   MsgFileTypeChrA
0x6C44   CheckByte
0x0002   CHAR_TYPE
0x7D4C   MsgFileTypeNoA
0x6C35   CheckChrArr
0x0001   NUMB_TYPE
0x6C75   PrepFileLen
0x719D X PrmStepRate
0x6CEE   MoveMsg
0x7D26   MsgFileTypeN
0x7D30   MsgFileTypePrg
0x6C26   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6CA5   HeadNotRead
0x7D0D   MsgFileAttr
0x6BF7   AttrEnd
0x6BEB   NotSYS
0x6BD7   CheckSys
0x6BC5   NotRO
0x7D16   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x6CB7   PrintStartNotRead
0x7CFD   MsgFileSzDsk
0x7D06   MsgFileSzDskN
0x788C   PrintLoop2
0x7851   PrintLoop
0x77F3   InitViewer
0x7541   ReadFileSection
0x6B5C   ViewFileLoop
0x7EC3   FilePosRead
0x713F   LoadProgram
0x7EC8   CopyFileSrcDrv
0x7CCF   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7CDE   MsgLoadingSCR
0x0003   HDR_ADDR
0x7088   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7042   IF1FileLoad
0x7CED   MsgLoadingCODE
0x6AFE X HandleFileCODE
0x6B24   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6B52   HandleFileText
0x0003   BYTE_TYPE
0x6B42   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6AC8   FindExtEnd
0x70C7   FindCache
0x6AD7   GetFileNamesEnd
0x0009   HDR_SZ
0x6AA3   FindExt
0x000C   EXT_IDX
0x6E19   CheckExtAlloc
0x6ACA   NextExt
0x0000   EXT_DEL_FLAG
0x6A52   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6A2F   DisplayFilenamesLoop
0x6A15   LineOK
0x5CB1   LINE
0x5CB0   COL
0x775C   PrintChar
0x5C81   CODE
0x69EF   DispLoop
0x69ED   DisplayFilename
0x7724   MoveCursor
0x6DEA   FormatDisk
0x7E3F   MsgFormat
0x6FCF   CopyDiskFromCOM
0x69AB   CheckDiskMenuFormat
0x6F73   CopyDiskToCOM
0x69A1   CheckDiskMenuFromCOM
0x6998   CheckDiskMenuToCOM
0x6EBA   CopyDisk
0x698A   CheckDiskMenuDualDrive
0x69DC   DiskMenuExit
0x6978 X CheckKeyDiskMenuLoop
0x7E33   MsgMenuFmt
0x7E24   MsgMenuFromCOM
0x7E15   MsgMenuToCOM
0x7E07   MsgMenuDual
0x7DF9   MsgMenuSingle
0x7DED   MsgMenuBack
0x7DD4   MsgMenuDiskCopy
0x7E13   MsgMenuDualDrv2
0x7E4A   MsgFormatDrv
0x7E3D   MsgMenuFmtDrv
0x7E31   MsgMenuFromCOMDrv
0x7E1D   MsgMenuToComDrv
0x7E0F   MsgMenuDualDrv1
0x7E05   MsgMenuSingleDrv2
0x7E01   MsgMenuSingleDrv1
0x69DF   CheckKeyExit
0x725B   ChangeFileAttrib
0x68F1   AttrChange
0x7DB8   MsgSetSYS
0x68D9   CheckSYS
0x7DAC   MsgSetRO
0x6900   CheckKeyDiskMenu
0x7236   DeleteFile
0x68AB   DoFileDelete
0x7D9F   MsgDelete
0x68B8   CheckKeyAttrib
0x7285   RenameFile
0x7E69   MsgFileExists
0x6872   RenameFileNotExist
0x7242   DoesFileExist
0x687E   RenameCanceled
0x779A   ReadString
0x000B   NAMELEN
0x8CFE   FileData
0x7D8F   MsgClear
0x7DC4   MsgNewFileName
0x6886   CheckKeyDel
0x6B53   ViewFile
0x6816   CheckKeyRename
0x0001   DRIVE_B_CPM
0x6805   CheckKeyView
0x68FA   SelectDrive
0x67FC   CheckKeyDriveB
0x6CF4   ReadAllHeaders
0x67F3   CheckKeyDriveA
0x7ED4   CopyFileDstDrv
0x7EBD   CopySelOption
0x67CB   CopyFileOK
0x7EC0   CopyFileRes
0x72DC   CopyFile
0x67E2   CheckKeyFileInfo
0x77DC   ClearNMsgLines
0x70D8   ReadFileHeader
0x7D81   MsgReadingExt
0x6799   CheckKeyCopy
0x6AD8   HandleFile
0x6774   CheckKeyInfo
0x676E   DoKeyEnter
0x000D   KEY_ENTER
0x6765   CheckEnter
0x6758   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6750   CheckLeft
0x673E   DoKeyRight
0x0009   KEY_RIGHT
0x6736   CheckRight
0x6729   DoKeyUp
0x000B   KEY_UP
0x69E7   MoveIt
0x6721   CheckUp
0x6710   DoKeyDown
0x000A   KEY_DOWN
0x6B82   DisplayFileInfo
0x7EBB   SelFileCache
0x6DB1   Mul
0x66EE   CalcFileCache
0x7CB0   MsgFreeSpace
0x6D4A   Word2Txt
0x7CB9   MsgFreeSpaceNo
0x013E   MAX_FREE_AU_CNT
0x7EB9   AUCnt
0x7CA0   MsgFilesCnt
0x7CA9   MsgFilesCntNo
0x7EB4   FileCnt
0x7C90   MsgDrive
0x7C9F   MsgDriveLet
0x7158   SetFastKeys
0x7719   DrawCursor
0x0020   SCR_SEL_CLR
0x7C41   MsgMessages
0x0008   LST_FILE_INFO
0x7C31   MsgFileInf
0x0004   LST_DISK_INFO
0x7C21   MsgDskInf
0x7C11   MsgSysInf
0x7C51   BtnBar
0x0020   SCR_LBL_CLR
0x7C01   VerMsg2
0x7630   PrintStr
0x0001   LST_PROG_INFO
0x7BF1   VerMsg1
0x76A7   DrawHLines
0x7701   DrawVLines
0x7EB7   CursorAddr
0x77F1   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x7610   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x7EB5   NameCol
0x0010   LST_FIRST_COL
0x7EB6   SelFile
0x8CFE   DataBuf
0x7163   GetErrMsg
0x5C3A   ERRNR
0x65EF X HCRunEnd
0x66FF   ReadKeyLoop
0x66A5   DisplayDiskInfo
0x6A1F   DisplayFilenames
0x6627   InitUI
0x65E3   HCRunMain
0x6A3F   GetFileNames
0x718A   RWTSDrive
0x0000   DRIVE_A_CPM
0x75F4   ReadChar
0x7658   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000E   LST_LINE_MSG
0x7CC0   MsgErr
0x6D55   Byte2Txt
0x7CCB   MsgErrCode
0x65E0   HCRunCacheFiles
0x70AE   ReadCatalogTrack
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x7EE0   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8CFE   TrackBuf
0x65A2   HCRunInitDisk
0x65F5   ErrorHandler
0x5C3D   ERRSP
0x6DC5   IF1Init
0x75FA   InitFonts
0x6590   Start
