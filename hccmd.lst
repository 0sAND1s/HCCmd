# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 26000
  12  6590
  13  6590              Start:
  14  6590              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  6590 CD D9 76     		call InitFonts
  16  6593              	ENDIF
  17  6593 CD B0 6E     	call IF1Init
  18  6596
  19  6596              	;install error handler
  20  6596 2A 3D 5C     	ld		hl, (ERRSP)
  21  6599 E5           	push	hl
  22  659A 21 1E 66     	ld		hl, ErrorHandler
  23  659D E5           	push	hl
  24  659E ED 73 3D 5C  	ld		(ERRSP), sp
  25  65A2
  26  65A2              HCRunInitDisk:
  27  65A2              	;Set track buffer to del marker
  28  65A2 21 C6 8D     	ld		hl, TrackBuf
  29  65A5 54           	ld		d, h
  30  65A6 5D           	ld		e, l
  31  65A7 13           	inc		de
  32  65A8 01 00 10     	ld		bc, SPT*SECT_SZ
  33  65AB 36 E5        	ld		(hl), DEL_MARKER
  34  65AD ED B0        	ldir
  35  65AF
  36  65AF              	;Invalidate file cache
  37  65AF 21 A8 7F     	ld		hl, FileCache
  38  65B2 54           	ld		d, h
  39  65B3 5D           	ld		e, l
  40  65B4 13           	inc		de
  41  65B5 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  65B8 36 00        	ld		(hl), 0
  43  65BA ED B0        	ldir
  44  65BC
  45  65BC              	;main program
  46  65BC CD 8D 72     	call	BDOSGetCurrentDrive
  47  65BF FE FF        	cp		$FF
  48  65C1 20 02        	jr		nz, DetectTrackCount
  49  65C3
  50  65C3 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  51  65C5
  52  65C5              DetectTrackCount:
  53  65C5 F5           	push	af
  54  65C6 CD 81 72     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  55  65C9 F1           	pop		af
  56  65CA 32 69 72     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  57  65CD CD 84 72     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  58  65D0
  59  65D0              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  60  65D0 1E 28        	ld		e, TRACK_CNT/2
  61  65D2 21 C6 8D     	ld		hl, FileData
  62  65D5 CD BF 6E     	call	ReadOneDiskSector
  63  65D8 3A 74 72     	ld		a, (RWTSRes)
  64  65DB B7           	or		a
  65  65DC 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  66  65DF 28 03        	jr		z, DriveIs80Tracks
  67  65E1 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  68  65E4              DriveIs80Tracks:
  69  65E4 22 81 7F     	ld		(AUCntMaxFree), hl
  70  65E7
  71  65E7 CD 9A 71     	call 	ReadCatalogTrack
  72  65EA B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  73  65EB 28 1A        	jr		z, HCRunCacheFiles
  74  65ED
  75  65ED 6F           	ld		l, a
  76  65EE 26 00        	ld		h, 0
  77  65F0 11 73 7D     	ld		de, MsgErrCode
  78  65F3 CD 40 6E     	call	Byte2Txt
  79  65F6 21 68 7D     	ld		hl, MsgErr
  80  65F9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  81  65FC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  82  65FE CD 37 77     	call	PrintStrClr
  83  6601 CD 81 72     	call	BDOSInit
  84  6604 C3 A2 65     	jp		HCRunInitDisk
  85  6607
  86  6607
  87  6607              HCRunCacheFiles:
  88  6607 CD C1 6A     	call 	GetFileNames
  89  660A
  90  660A              HCRunMain:
  91  660A CD 53 66     	call 	InitUI
  92  660D CD A1 6A     	call	DisplayFilenames
  93  6610 CD D1 66     	call	DisplayDiskInfo
  94  6613 C3 44 67     	jp		ReadKeyLoop
  95  6616
  96  6616              HCRunEnd:
  97  6616              	;restore error handler
  98  6616 E1           	pop		hl
  99  6617 E1           	pop		hl
 100  6618 22 3D 5C     	ld		(ERRSP), hl
 101  661B
 102  661B              	;ret
 103  661B C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 104  661E
 105  661E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 106  661E
 107  661E              ErrorHandler:
 108  661E E1           	pop		hl
 109  661F 22 3D 5C     	ld		(ERRSP), hl
 110  6622
 111  6622 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 112  6625 6F           	ld		l, a
 113  6626 26 00        	ld		h, 0
 114  6628 11 73 7D     	ld		de, MsgErrCode
 115  662B CD 40 6E     	call	Byte2Txt
 116  662E 21 68 7D     	ld		hl, MsgErr
 117  6631 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 118  6634 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 119  6636 CD 37 77     	call	PrintStrClr
 120  6639
 121  6639 3A 3A 5C     	ld		a, (ERRNR)
 122  663C CD 42 72     	call	GetErrMsg
 123  663F
 124  663F 21 C6 8D     	ld		hl, DataBuf
 125  6642 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 126  6645 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 127  6647 CD 37 77     	call	PrintStrClr
 128  664A
 129  664A CD D3 76     	call	ReadChar
 130  664D CD 81 72     	call	BDOSInit
 131  6650 C3 90 65     	jp		Start
 132  6653
 133  6653
 134  6653
 135  6653
 136  6653              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 137  6653
 138  6653              InitUI:
 139  6653 AF           	xor		a
 140  6654 32 7C 7F     	ld		(SelFile), A
 141  6657 3E 11        	ld		a, LST_FIRST_COL + 1
 142  6659 32 7B 7F     	ld		(NameCol), A
 143  665C 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 144  665F ED 53 B0 5C  	ld		(LineCol), de
 145  6663
 146  6663 CD EF 76     	call	ClrScr
 147  6666
 148  6666 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 149  6669 ED 4B D0 78  	ld		bc, (CurrScrAttrAddr)
 150  666D 09           	add		hl, bc
 151  666E 22 7D 7F     	ld		(CursorAddr), hl
 152  6671
 153  6671 CD E0 77     	call	DrawVLines
 154  6674
 155  6674 CD 86 77     	call	DrawHLines
 156  6677
 157  6677 21 A9 7C     	ld		hl, VerMsg1
 158  667A 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 159  667D 3A B8 7C     	ld		a, (VerMsg1 + 15)
 160  6680 F6 80        	or		$80
 161  6682 32 B8 7C     	ld		(VerMsg1 + 15), a
 162  6685 CD 0F 77     	call	PrintStr
 163  6688 21 B9 7C     	ld		hl, VerMsg2
 164  668B 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 165  668E CD 0F 77     	call	PrintStr
 166  6691
 167  6691 3E 60        	ld		a, SCR_LBL_CLR
 168  6693 11 00 17     	ld		de, 23 << 8
 169  6696 21 09 7D     	ld		hl, BtnBar
 170  6699 CD 37 77     	call	PrintStrClr
 171  669C
 172  669C 3E 60        	ld		a, SCR_LBL_CLR
 173  669E 21 C9 7C     	ld		hl, MsgSysInf
 174  66A1 11 00 01     	ld		de, LST_PROG_INFO << 8
 175  66A4 CD 37 77     	call	PrintStrClr
 176  66A7
 177  66A7 3E 60        	ld		a, SCR_LBL_CLR
 178  66A9 21 D9 7C     	ld		hl, MsgDskInf
 179  66AC 11 00 04     	ld		de, LST_DISK_INFO << 8
 180  66AF CD 37 77     	call	PrintStrClr
 181  66B2
 182  66B2 3E 60        	ld		a, SCR_LBL_CLR
 183  66B4 21 E9 7C     	ld		hl, MsgFileInf
 184  66B7 11 00 07     	ld		de, LST_FILE_INFO << 8
 185  66BA CD 37 77     	call	PrintStrClr
 186  66BD
 187  66BD 3E 60        	ld		a, SCR_LBL_CLR
 188  66BF 21 F9 7C     	ld		hl, MsgMessages
 189  66C2 11 00 0D     	ld		de, LST_LINE_MSG << 8
 190  66C5 CD 37 77     	call	PrintStrClr
 191  66C8
 192  66C8 3E 60        	ld		a, SCR_SEL_CLR
 193  66CA CD F8 77     	call	DrawCursor
 194  66CD
 195  66CD CD 37 72     	call	SetFastKeys
 196  66D0
 197  66D0 C9           	ret
 198  66D1
 199  66D1
 200  66D1              DisplayDiskInfo:
 201  66D1 2A 81 7F     	ld		hl, (AUCntMaxFree)
 202  66D4 ED 5B 7F 7F  	ld		de, (AUCntUsed)
 203  66D8 B7           	or		a
 204  66D9 ED 52        	sbc		hl, de
 205  66DB CB 15        	rl		l								;*2, 2K/AU
 206  66DD CB 14        	rl		h
 207  66DF
 208  66DF 11 53 7D     	ld		de, MsgDriveLet
 209  66E2 CD 35 6E     	call	Word2Txt
 210  66E5 3A 57 7D     	ld		a, (MsgDriveLet+4)
 211  66E8 F6 80        	or		$80
 212  66EA 32 57 7D     	ld		(MsgDriveLet+4), a
 213  66ED
 214  66ED 3A 69 72     	ld		a, (RWTSDrive)
 215  66F0 C6 41        	add		'A'
 216  66F2 32 53 7D     	ld		(MsgDriveLet), a
 217  66F5 3E 2F        	ld		a, '/'
 218  66F7 32 54 7D     	ld		(MsgDriveLet+1), a
 219  66FA
 220  66FA 21 48 7D     	ld		hl, MsgDrive
 221  66FD 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 222  6700 CD 0F 77     	call	PrintStr
 223  6703
 224  6703 2A 7F 7F     	ld		hl, (AUCntUsed)
 225  6706 CB 15        	rl		l								;*2, 2K/AU
 226  6708 CB 14        	rl		h
 227  670A 11 63 7D     	ld		de, MsgFilesCntNo+2
 228  670D CD 35 6E     	call	Word2Txt
 229  6710 3A 67 7D     	ld		a, (MsgFilesCntNo+6)
 230  6713 F6 80        	or		$80
 231  6715 32 67 7D     	ld		(MsgFilesCntNo+6), a
 232  6718 3E 2F        	ld		a, '/'
 233  671A 32 64 7D     	ld		(MsgFilesCntNo+3), a
 234  671D
 235  671D 3A 7A 7F     	ld		a, (FileCnt)
 236  6720 6F           	ld		l, a
 237  6721 26 00        	ld		h, 0
 238  6723 11 61 7D     	ld		de, MsgFilesCntNo
 239  6726 CD 40 6E     	call	Byte2Txt
 240  6729 21 58 7D     	ld		hl, MsgFilesCnt
 241  672C 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 242  672F CD 0F 77     	call	PrintStr
 243  6732
 244  6732 C9           	ret
 245  6733
 246  6733              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247  6733
 248  6733              CalcFileCache:
 249  6733 3A 7C 7F     	ld		a, (SelFile)
 250  6736 11 19 00     	ld		de, CACHE_SZ
 251  6739 CD 9C 6E     	call	Mul
 252  673C 01 A8 7F     	ld		bc, FileCache
 253  673F 09           	add		hl, bc					;HL = file AU cnt
 254  6740 22 83 7F     	ld		(SelFileCache), hl
 255  6743 C9           	ret
 256  6744
 257  6744              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 258  6744
 259  6744
 260  6744              ReadKeyLoop:
 261  6744 CD 33 67     	call	CalcFileCache
 262  6747 CD 6D 6C     	call	DisplayFileInfo
 263  674A
 264  674A CD D3 76     	call	ReadChar
 265  674D
 266  674D FE 0A        	cp		KEY_DOWN
 267  674F 28 04        	jr		z,  DoKeyDown
 268  6751 FE 61        	cp 		'a'
 269  6753 20 11        	jr		nz, CheckUp
 270  6755
 271  6755              DoKeyDown:
 272  6755 3A 7A 7F     	ld		a, (FileCnt)
 273  6758 47           	ld		b, a
 274  6759 3A 7C 7F     	ld		a, (SelFile)
 275  675C 3C           	inc		a
 276  675D B8           	cp		b
 277  675E 30 E4        	jr		nc, ReadKeyLoop
 278  6760 32 7C 7F     	ld		(SelFile), a
 279  6763 C3 69 6A     	jp		MoveIt
 280  6766
 281  6766              CheckUp:
 282  6766 FE 0B        	cp		KEY_UP
 283  6768 28 04        	jr		z, DoKeyUp
 284  676A FE 71        	cp 		'q'
 285  676C 20 0D        	jr		nz, CheckRight
 286  676E
 287  676E              DoKeyUp:
 288  676E 3A 7C 7F     	ld		a, (SelFile)
 289  6771 B7           	or		a
 290  6772 28 D0        	jr		z, ReadKeyLoop
 291  6774
 292  6774 3D           	dec		a
 293  6775 32 7C 7F     	ld		(SelFile), a
 294  6778 C3 69 6A     	jp		MoveIt
 295  677B
 296  677B              CheckRight:
 297  677B FE 09        	cp		KEY_RIGHT
 298  677D 28 04        	jr		z, DoKeyRight
 299  677F FE 70        	cp 		'p'
 300  6781 20 12        	jr		nz, CheckLeft
 301  6783
 302  6783              DoKeyRight:
 303  6783 3A 7A 7F     	ld		a, (FileCnt)
 304  6786 47           	ld		b, a
 305  6787 3A 7C 7F     	ld		a, (SelFile)
 306  678A C6 15        	add		LST_LINES_CNT
 307  678C B8           	cp		b
 308  678D 30 B5        	jr		nc, ReadKeyLoop
 309  678F
 310  678F 32 7C 7F     	ld		(SelFile), a
 311  6792 C3 69 6A     	jp		MoveIt
 312  6795
 313  6795              CheckLeft:
 314  6795 FE 08        	cp		KEY_LEFT
 315  6797 28 04        	jr		z, DoKeyLeft
 316  6799 FE 6F        	cp		'o'
 317  679B 20 0D        	jr		nz, CheckEnter
 318  679D
 319  679D              DoKeyLeft:
 320  679D 3A 7C 7F     	ld		a, (SelFile)
 321  67A0 D6 15        	sub		LST_LINES_CNT
 322  67A2 38 A0        	jr		c, ReadKeyLoop
 323  67A4
 324  67A4 32 7C 7F     	ld		(SelFile), a
 325  67A7 C3 69 6A     	jp		MoveIt
 326  67AA
 327  67AA              CheckEnter:
 328  67AA FE 0D        	cp		KEY_ENTER
 329  67AC 28 05        	jr		z, DoKeyEnter
 330  67AE FE 6D        	cp		'm'
 331  67B0 C2 B9 67     	jp		nz, CheckKeyInfo
 332  67B3
 333  67B3              DoKeyEnter:
 334  67B3 CD 5A 6B     	call	HandleFile
 335  67B6 C3 0A 66     	jp		HCRunMain
 336  67B9
 337  67B9              CheckKeyInfo:
 338  67B9 FE 34        	cp		'4'
 339  67BB 20 21        	jr		nz, CheckKeyCopy
 340  67BD
 341  67BD 3A 7A 7F     	ld		a, (FileCnt)
 342  67C0 B7           	or		a
 343  67C1 CA 44 67     	jp		z, ReadKeyLoop
 344  67C4
 345  67C4 DD 2A 83 7F  	ld		ix, (SelFileCache)
 346  67C8 21 29 7E     	ld		hl, MsgReadingExt
 347  67CB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 348  67CE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 349  67D0 CD 37 77     	call	PrintStrClr
 350  67D3 CD B7 71     	call	ReadFileHeader
 351  67D6 06 01        	ld		b, 1
 352  67D8 CD BB 78     	call	ClearNMsgLines
 353  67DB C3 44 67     	jp		ReadKeyLoop
 354  67DE
 355  67DE              CheckKeyCopy:
 356  67DE FE 35        	cp		'5'
 357  67E0 C2 2A 68     	jp		nz, CheckKeyFileInfo
 358  67E3
 359  67E3 3A 7A 7F     	ld		a, (FileCnt)
 360  67E6 B7           	or		a
 361  67E7 CA 44 67     	jp		z, ReadKeyLoop
 362  67EA
 363  67EA 2A 83 7F     	ld		hl, (SelFileCache)
 364  67ED CD AF 73     	call	CopyFile
 365  67F0 3A 88 7F     	ld		a, (CopyFileRes)
 366  67F3 B7           	or		a
 367  67F4 28 1A        	jr		z, CopyFileOK
 368  67F6
 369  67F6 6F           	ld		l, a
 370  67F7 26 00        	ld		h, 0
 371  67F9 11 73 7D     	ld		de, MsgErrCode
 372  67FC CD 40 6E     	call	Byte2Txt
 373  67FF 21 68 7D     	ld		hl, MsgErr
 374  6802 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 375  6805 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 376  6807 CD 37 77     	call	PrintStrClr
 377  680A CD D3 76     	call	ReadChar
 378  680D C3 44 67     	jp		ReadKeyLoop
 379  6810
 380  6810              CopyFileOK:
 381  6810 06 02        	ld		b, 2
 382  6812 CD BB 78     	call	ClearNMsgLines
 383  6815              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 384  6815 3A 85 7F     	ld		a, (CopySelOption)
 385  6818 FE 33        	cp		'3'
 386  681A CA 44 67     	jp		z, ReadKeyLoop
 387  681D 3A 9C 7F     	ld		a, (CopyFileDstDrv)
 388  6820 3D           	dec		a
 389  6821 32 69 72     	ld		(RWTSDrive), a
 390  6824 CD 84 72     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 391  6827 C3 A2 65     	jp		HCRunInitDisk
 392  682A
 393  682A              CheckKeyFileInfo:
 394  682A FE 20        	cp		' '
 395  682C 20 0D        	jr		nz, CheckKeyDriveA
 396  682E
 397  682E 3A 7A 7F     	ld		a, (FileCnt)
 398  6831 B7           	or		a
 399  6832 CA 44 67     	jp		z, ReadKeyLoop
 400  6835
 401  6835 CD DF 6D     	call	ReadAllHeaders
 402  6838 C3 44 67     	jp		ReadKeyLoop
 403  683B
 404  683B              CheckKeyDriveA:
 405  683B FE 31        	cp		'1'
 406  683D 20 05        	jr		nz, CheckKeyDriveB
 407  683F 3E 00        	ld		a, DRIVE_A_CPM
 408  6841 C3 42 69     	jp		SelectDrive
 409  6844
 410  6844              CheckKeyDriveB:
 411  6844 FE 32        	cp		'2'
 412  6846 20 05        	jr		nz, CheckKeyView
 413  6848 3E 01        	ld		a, DRIVE_B_CPM
 414  684A C3 42 69     	jp		SelectDrive
 415  684D
 416  684D              CheckKeyView:
 417  684D FE 33        	cp		'3'
 418  684F 20 0D        	jr		nz, CheckKeyRename
 419  6851
 420  6851 3A 7A 7F     	ld		a, (FileCnt)
 421  6854 B7           	or		a
 422  6855 CA 44 67     	jp		z, ReadKeyLoop
 423  6858
 424  6858 CD D5 6B     	call	ViewFile
 425  685B C3 0A 66     	jp		HCRunMain
 426  685E
 427  685E              CheckKeyRename:
 428  685E FE 36        	cp		'6'
 429  6860 20 6C        	jr		nz, CheckKeyDel
 430  6862
 431  6862 3A 7A 7F     	ld		a, (FileCnt)
 432  6865 B7           	or		a
 433  6866 CA 44 67     	jp		z, ReadKeyLoop
 434  6869
 435  6869 21 6C 7E     	ld		hl, MsgNewFileName
 436  686C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 437  686F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 438  6871 CD 37 77     	call	PrintStrClr
 439  6874
 440  6874 21 37 7E     	ld		hl, MsgClear
 441  6877 11 C6 8D     	ld		de, FileData
 442  687A 01 0B 00     	ld		bc, NAMELEN
 443  687D ED B0        	ldir
 444  687F 3E A0        	ld		a, $80 | ' '
 445  6881 12           	ld		(de), a
 446  6882 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 447  6885 21 C6 8D     	ld		hl, FileData
 448  6888 CD 0F 77     	call	PrintStr
 449  688B
 450  688B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 451  688E 01 0B 00     	ld		bc, NAMELEN
 452  6891 CD 79 78     	call	ReadString
 453  6894
 454  6894 11 C6 8D     	ld		de, FileData
 455  6897 1A           	ld		a, (de)
 456  6898 FE 20        	cp		' '					;If starting with space, input was canceled.
 457  689A CA C6 68     	jp		z, RenameCanceled
 458  689D
 459  689D              	;Check if new name doesn't exist already. Cancel if so.
 460  689D 21 C6 8D     	ld		hl, FileData
 461  68A0 3A 69 72     	ld 		a, (RWTSDrive)
 462  68A3 3C           	inc		a
 463  68A4 CD 15 73     	call	DoesFileExist
 464  68A7 3C           	inc		a
 465  68A8 28 10        	jr		z, RenameFileNotExist
 466  68AA
 467  68AA 21 10 7F     	ld		hl, MsgFileExists
 468  68AD 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 469  68B0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 470  68B2 CD 37 77     	call	PrintStrClr
 471  68B5 CD D3 76     	call	ReadChar
 472  68B8 18 0C        	jr		RenameCanceled
 473  68BA
 474  68BA              RenameFileNotExist:
 475  68BA 11 C6 8D     	ld		de, FileData
 476  68BD 2A 83 7F     	ld		hl, (SelFileCache)
 477  68C0 CD 58 73     	call	RenameFile
 478  68C3 C3 A2 65     	jp		HCRunInitDisk
 479  68C6
 480  68C6              RenameCanceled:
 481  68C6 06 02        	ld		b, 2
 482  68C8 CD BB 78     	call	ClearNMsgLines
 483  68CB C3 44 67     	jp		ReadKeyLoop
 484  68CE
 485  68CE              CheckKeyDel:
 486  68CE FE 38        	cp		'8'
 487  68D0 20 2E        	jr		nz, CheckKeyAttrib
 488  68D2
 489  68D2 3A 7A 7F     	ld		a, (FileCnt)
 490  68D5 B7           	or		a
 491  68D6 CA 44 67     	jp		z, ReadKeyLoop
 492  68D9
 493  68D9 21 47 7E     	ld		hl, MsgDelete
 494  68DC 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 495  68DF 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 496  68E1 CD 37 77     	call	PrintStrClr
 497  68E4 CD D3 76     	call	ReadChar
 498  68E7 FE 79        	cp		'y'
 499  68E9 28 08        	jr		z, DoFileDelete
 500  68EB 06 01        	ld		b, 1
 501  68ED CD BB 78     	call	ClearNMsgLines
 502  68F0 C3 44 67     	jp		ReadKeyLoop
 503  68F3              DoFileDelete:
 504  68F3 2A 83 7F     	ld		hl, (SelFileCache)
 505  68F6 3A 69 72     	ld 		a, (RWTSDrive)
 506  68F9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 507  68FA CD 09 73     	call	DeleteFile
 508  68FD C3 A2 65     	jp		HCRunInitDisk
 509  6900
 510  6900              CheckKeyAttrib:
 511  6900 FE 37        	cp		'7'
 512  6902 20 47        	jr		nz, CheckKeyDiskMenu
 513  6904
 514  6904 3A 7A 7F     	ld		a, (FileCnt)
 515  6907 B7           	or		a
 516  6908 CA 44 67     	jp		z, ReadKeyLoop
 517  690B
 518  690B 21 54 7E     	ld		hl, MsgSetRO
 519  690E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 520  6911 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 521  6913 CD 37 77     	call	PrintStrClr
 522  6916 CD D3 76     	call	ReadChar
 523  6919 1E 00        	ld		e, 0
 524  691B FE 79        	cp		'y'
 525  691D 20 02        	jr		nz, CheckSYS
 526  691F 1E 01        	ld		e, 1
 527  6921
 528  6921              CheckSYS:
 529  6921 D5           	push	de
 530  6922 21 60 7E     		ld		hl, MsgSetSYS
 531  6925 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 532  6928 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 533  692A CD 37 77     		call	PrintStrClr
 534  692D CD D3 76     		call	ReadChar
 535  6930 FE 79        		cp		'y'
 536  6932 D1           	pop		de
 537  6933 20 04        	jr		nz, AttrChange
 538  6935 3E 02        	ld		a, %10
 539  6937 B3           	or		e
 540  6938 5F           	ld		e, a
 541  6939
 542  6939              AttrChange:
 543  6939 2A 83 7F     	ld		hl, (SelFileCache)
 544  693C CD 2E 73     	call	ChangeFileAttrib
 545  693F C3 A2 65     	jp		HCRunInitDisk
 546  6942
 547  6942              SelectDrive:
 548  6942 32 69 72     	ld 		(RWTSDrive), a
 549  6945 CD 84 72     	call	BDOSSelectDisk
 550  6948              	;call	BDOSInit
 551  6948 C3 A2 65     	jp		HCRunInitDisk
 552  694B
 553  694B              CheckKeyDiskMenu:
 554  694B FE 39        	cp		'9'
 555  694D C2 61 6A     	jp		nz, CheckKeyExit
 556  6950
 557  6950 3A 69 72     	ld		a, (RWTSDrive)
 558  6953 C6 41        	add		'A'
 559  6955              	;Update menu messages with current drive.
 560  6955 32 A9 7E     	ld		(MsgMenuSingleDrv1), a
 561  6958 32 AD 7E     	ld		(MsgMenuSingleDrv2), a
 562  695B 32 B7 7E     	ld		(MsgMenuDualDrv1), a
 563  695E 32 C5 7E     	ld		(MsgMenuToComDrv), a
 564  6961 32 D9 7E     	ld		(MsgMenuFromCOMDrv), a
 565  6964              	;Update menu messages with the alternate drive.
 566  6964 3A 69 72     	ld		a, (RWTSDrive)
 567  6967 3C           	inc		a
 568  6968 EE 03        	xor		%11
 569  696A C6 40        	add		'A'-1
 570  696C 32 BB 7E     	ld		(MsgMenuDualDrv2), a
 571  696F
 572  696F 21 7C 7E     	ld		hl, MsgMenuDiskCopy
 573  6972 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 574  6975 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 575  6977 CD 37 77     	call	PrintStrClr
 576  697A 21 95 7E     	ld		hl, MsgMenuBack
 577  697D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 578  6980 CD 0F 77     	call	PrintStr
 579  6983 21 A1 7E     	ld		hl, MsgMenuSingle
 580  6986 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 581  6989 CD 0F 77     	call	PrintStr
 582  698C 21 AF 7E     	ld		hl, MsgMenuDual
 583  698F 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 584  6992 CD 0F 77     	call	PrintStr
 585  6995 21 BD 7E     	ld		hl, MsgMenuToCOM
 586  6998 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 587  699B CD 0F 77     	call	PrintStr
 588  699E 21 CC 7E     	ld		hl, MsgMenuFromCOM
 589  69A1 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 590  69A4 CD 0F 77     	call	PrintStr
 591  69A7 21 DB 7E     	ld		hl, MsgMenuFmt1
 592  69AA 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 593  69AD CD 0F 77     	call	PrintStr
 594  69B0 21 E7 7E     	ld		hl, MsgMenuFmt2
 595  69B3 11 00 15     	ld		de, LST_LINE_MSG + 8 << 8
 596  69B6 CD 0F 77     	call	PrintStr
 597  69B9
 598  69B9 CD D3 76     	call	ReadChar
 599  69BC F5           	push	af
 600  69BD 06 08        		ld		b, 8
 601  69BF CD BB 78     		call	ClearNMsgLines
 602  69C2 F1           	pop		af
 603  69C3 32 85 7F     	ld		(CopySelOption), a
 604  69C6
 605  69C6              CheckKeyDiskMenuLoop:
 606  69C6 FE 30        	cp		'0'
 607  69C8 CA 5E 6A     	jp		z, DiskMenuExit
 608  69CB
 609  69CB              	;Single drive copy
 610  69CB FE 31        	cp		'1'
 611  69CD 20 0B        	jr		nz, CheckDiskMenuDualDrive
 612  69CF CD A6 6F     	call	CopyDisk
 613  69D2 06 02        	ld		b, 2
 614  69D4 CD BB 78     	call	ClearNMsgLines
 615  69D7 C3 5E 6A     	jp		DiskMenuExit
 616  69DA
 617  69DA              	;Dual drive copy
 618  69DA              CheckDiskMenuDualDrive:
 619  69DA FE 32        	cp		'2'
 620  69DC 20 0A        	jr		nz, CheckDiskMenuToCOM
 621  69DE CD A6 6F     	call	CopyDisk
 622  69E1 06 02        	ld		b, 2
 623  69E3 CD BB 78     	call	ClearNMsgLines
 624  69E6 18 76        	jr		DiskMenuExit
 625  69E8
 626  69E8              CheckDiskMenuToCOM:
 627  69E8 FE 33        	cp		'3'
 628  69EA 20 05        	jr		nz, CheckDiskMenuFromCOM
 629  69EC CD 5F 70     	call	CopyDiskToCOM
 630  69EF 18 6D        	jr		DiskMenuExit
 631  69F1
 632  69F1              CheckDiskMenuFromCOM:
 633  69F1 FE 34        	cp		'4'
 634  69F3 20 06        	jr		nz, CheckDiskMenuFormat1
 635  69F5 CD BB 70     	call	CopyDiskFromCOM
 636  69F8 C3 A2 65     	jp		HCRunInitDisk
 637  69FB
 638  69FB              CheckDiskMenuFormat1:
 639  69FB FE 35        	cp		'5'
 640  69FD C2 0A 6A     	jp		nz, CheckDiskMenuFormat2
 641  6A00
 642  6A00 3E 00        	ld		a, DRIVE_A_CPM
 643  6A02 32 69 72     	ld		(RWTSDrive), a
 644  6A05 21 DE 7E     	ld		hl, MsgMenuFmt1+3
 645  6A08 18 0D        	jr		FormatDiskAction
 646  6A0A
 647  6A0A              CheckDiskMenuFormat2:
 648  6A0A FE 36        	cp		'6'
 649  6A0C C2 0A 66     	jp		nz, HCRunMain
 650  6A0F
 651  6A0F 3E 01        	ld		a, DRIVE_B_CPM
 652  6A11 32 69 72     	ld		(RWTSDrive), a
 653  6A14 21 EA 7E     	ld		hl, MsgMenuFmt2+3
 654  6A17
 655  6A17              FormatDiskAction:
 656  6A17 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 657  6A1A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 658  6A1C CD 37 77     	call	PrintStrClr
 659  6A1F
 660  6A1F 21 5B 7F     	ld		hl, MsgAreYouSure
 661  6A22 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 662  6A25 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 663  6A27 CD 37 77     	call	PrintStrClr
 664  6A2A CD D3 76     	call	ReadChar
 665  6A2D FE 79        	cp		'y'
 666  6A2F C2 0A 66     	jp		nz, HCRunMain
 667  6A32
 668  6A32 21 37 7E     	ld		hl, MsgClear
 669  6A35 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 670  6A38 3E 45        	ld		a, SCR_DEF_CLR
 671  6A3A CD 37 77     	call	PrintStrClr
 672  6A3D
 673  6A3D CD D5 6E     	call	FormatDisk
 674  6A40 B7           	or		a
 675  6A41 CA A2 65     	jp		z, HCRunInitDisk
 676  6A44
 677  6A44              	;Display error for format
 678  6A44 6F           	ld		l, a
 679  6A45 26 00        	ld		h, 0
 680  6A47 11 73 7D     	ld		de, MsgErrCode
 681  6A4A CD 40 6E     	call	Byte2Txt
 682  6A4D 21 68 7D     	ld		hl, MsgErr
 683  6A50 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 684  6A53 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 685  6A55 CD 37 77     	call	PrintStrClr
 686  6A58 CD D3 76     	call	ReadChar
 687  6A5B C3 A2 65     	jp		HCRunInitDisk
 688  6A5E
 689  6A5E              DiskMenuExit:
 690  6A5E C3 44 67     	jp		ReadKeyLoop
 691  6A61
 692  6A61              CheckKeyExit:
 693  6A61 FE 30        	cp		'0'
 694  6A63 C2 44 67     	jp		nz, ReadKeyLoop
 695  6A66 C3 16 66     	jp		HCRunEnd
 696  6A69              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 697  6A69
 698  6A69              MoveIt:
 699  6A69 CD 03 78     	call 	MoveCursor
 700  6A6C C3 44 67     	jp		ReadKeyLoop
 701  6A6F
 702  6A6F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 703  6A6F
 704  6A6F
 705  6A6F              DisplayFilename:
 706  6A6F 06 0B        	LD		B, NAMELEN
 707  6A71              DispLoop:
 708  6A71 1A           	LD		A, (DE)
 709  6A72
 710  6A72              	;clear bit 7
 711  6A72 CB BF        	RES 	7, A
 712  6A74 32 81 5C     	LD		(CODE), A
 713  6A77
 714  6A77 13           	INC		DE
 715  6A78 D5           	PUSH	DE
 716  6A79 C5           	PUSH	BC
 717  6A7A CD 3B 78     		CALL	PrintChar
 718  6A7D C1           	POP		BC
 719  6A7E D1           	POP 	DE
 720  6A7F
 721  6A7F 21 B0 5C     	LD		HL, COL
 722  6A82 34           	INC		(HL)
 723  6A83 10 EC        	DJNZ	DispLoop
 724  6A85              	;now a name is displayed
 725  6A85
 726  6A85              	;check bounds
 727  6A85 3A B1 5C     	LD		A, (LINE)
 728  6A88 3C           	INC		A
 729  6A89 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 730  6A8B 38 0A        	JR		C, LineOK
 731  6A8D
 732  6A8D              	;set names column to the next one
 733  6A8D 3A 7B 7F     	LD		A, (NameCol)
 734  6A90 C6 0C        	ADD		NAMELEN + 1
 735  6A92 32 7B 7F     	LD		(NameCol), A
 736  6A95
 737  6A95 3E 01        	LD		A, LST_FIRST_LINE
 738  6A97              LineOK:
 739  6A97 32 B1 5C     	LD		(LINE), A
 740  6A9A
 741  6A9A 3A 7B 7F     	LD		A, (NameCol)
 742  6A9D 32 B0 5C     	LD		(COL), A
 743  6AA0
 744  6AA0 C9           	RET
 745  6AA1
 746  6AA1
 747  6AA1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 748  6AA1
 749  6AA1              DisplayFilenames:
 750  6AA1 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 751  6AA4 ED 53 B0 5C  	ld		(LineCol), de
 752  6AA8
 753  6AA8 11 A8 7F     	ld		de, FileCache
 754  6AAB 3A 7A 7F     	ld		a, (FileCnt)
 755  6AAE B7           	or		a
 756  6AAF C8           	ret		z
 757  6AB0
 758  6AB0 47           	ld		b,	a
 759  6AB1
 760  6AB1              DisplayFilenamesLoop:
 761  6AB1 C5           	push	bc
 762  6AB2 D5           		push	de
 763  6AB3 CD 6F 6A     			call	DisplayFilename
 764  6AB6 D1           		pop		de
 765  6AB7 EB           		ex		de, hl
 766  6AB8 01 19 00     		ld		bc, CACHE_SZ
 767  6ABB 09           		add		hl, bc
 768  6ABC EB           		ex		de, hl
 769  6ABD C1           	pop		bc
 770  6ABE 10 F1        	djnz	DisplayFilenamesLoop
 771  6AC0
 772  6AC0 C9           	ret
 773  6AC1
 774  6AC1
 775  6AC1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 776  6AC1              ;Selects only valid filenames (not deleted and only from first extension)
 777  6AC1              GetFileNames:
 778  6AC1 DD 21 C6 8D  	ld		ix, TrackBuf
 779  6AC5 11 A8 7F     	ld		de, FileCache
 780  6AC8 06 80        	ld		b, MAX_EXT_CNT
 781  6ACA AF           	xor		a
 782  6ACB 32 7A 7F     	ld		(FileCnt), a
 783  6ACE 21 7F 7F     	ld		hl, AUCntUsed
 784  6AD1 77           	ld		(hl), a
 785  6AD2 23           	inc		hl
 786  6AD3 77           	ld		(hl), a
 787  6AD4
 788  6AD4              StoreFilenamesLoop:
 789  6AD4 AF           	xor a
 790  6AD5 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 791  6AD8 C2 4C 6B     	jp nz, NextExt
 792  6ADB
 793  6ADB              	;count AU
 794  6ADB D9           	exx
 795  6ADC E5           	push hl
 796  6ADD CD 04 6F     		call CheckExtAlloc
 797  6AE0 EB           		ex de, hl			;save first AU no.
 798  6AE1
 799  6AE1              		;store disk alocated AU count
 800  6AE1 2A 7F 7F     		ld hl, (AUCntUsed)
 801  6AE4 48           		ld c, b
 802  6AE5 06 00        		ld b, 0
 803  6AE7 09           		add hl, bc
 804  6AE8 22 7F 7F     		ld (AUCntUsed), hl
 805  6AEB E1           	pop hl
 806  6AEC D9           	exx
 807  6AED
 808  6AED AF           	xor	a
 809  6AEE DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 810  6AF1 20 32        	jr nz, FindExt
 811  6AF3
 812  6AF3 DD E5        	push ix
 813  6AF5 E1           	pop hl
 814  6AF6 23           	inc hl					;skip del flag
 815  6AF7
 816  6AF7 C5           	push bc
 817  6AF8 ~            		/*
 818  6AF8 ~            		push de
 819  6AF8 ~            			push hl
 820  6AF8 ~            				ex de, hl
 821  6AF8 ~            				call DisplayFilename
 822  6AF8 ~            			pop hl
 823  6AF8 ~            		pop de
 824  6AF8 ~            		*/
 825  6AF8 01 0B 00     		ld bc, NAMELEN
 826  6AFB ED B0        		ldir				;save file name
 827  6AFD
 828  6AFD D9           		exx
 829  6AFE D5           		push 	de			;de = first AU
 830  6AFF D9           		exx
 831  6B00 E1           		pop		hl
 832  6B01 EB           		ex		de, hl
 833  6B02 73 23 72 2B  		ld		(hl), de	;save first AU
 834  6B06
 835  6B06 23           		inc		hl
 836  6B07 23           		inc		hl
 837  6B08
 838  6B08 D9           		exx					;save AU cnt for file
 839  6B09 C5           		push	bc
 840  6B0A D9           		exx
 841  6B0B C1           		pop		bc
 842  6B0C 71 23 70 2B  		ld		(hl), bc
 843  6B10
 844  6B10 23           		inc		hl
 845  6B11 23           		inc		hl
 846  6B12
 847  6B12              		;xor		a			;make flag 0 to signal that header is not read yet
 848  6B12              		;ld		(hl), a
 849  6B12
 850  6B12 01 0A 00     		ld		bc, HDR_SZ + 1
 851  6B15 09           		add		hl, bc
 852  6B16
 853  6B16 EB           		ex		de, hl
 854  6B17 C1           	pop bc
 855  6B18
 856  6B18
 857  6B18 3A 7A 7F     	ld 		a, (FileCnt)			;inc file counter
 858  6B1B 3C           	inc		a
 859  6B1C 32 7A 7F     	ld 		(FileCnt), a
 860  6B1F FE 54        	cp		LST_MAX_FILES
 861  6B21 38 29        	jr		c, NextExt
 862  6B23 18 34        	jr		GetFileNamesEnd
 863  6B25
 864  6B25
 865  6B25              FindExt:					;BC' = AU cnt for this ext
 866  6B25 C5           	push	bc
 867  6B26 D5           		push 	de
 868  6B27 DD E5        			push	ix
 869  6B29 D1           			pop		de
 870  6B2A 13           			inc		de				;DE = name to find
 871  6B2B
 872  6B2B 21 A8 7F     			ld		hl, FileCache
 873  6B2E 3A 7A 7F     			ld		a, (FileCnt)
 874  6B31 4F           			ld		c, a
 875  6B32 CD A6 71     			call	FindCache
 876  6B35 20 13        			jr		nz, FindExtEnd
 877  6B37
 878  6B37 01 0D 00     			ld		bc, CACHE_AU_CNT
 879  6B3A 09           			add		hl, bc
 880  6B3B D9           			exx
 881  6B3C C5           			push	bc
 882  6B3D D9           			exx
 883  6B3E C1           			pop		bc
 884  6B3F
 885  6B3F 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 886  6B43 EB           			ex		de, hl
 887  6B44 09           			add		hl, bc
 888  6B45 EB           			ex		de, hl
 889  6B46 73 23 72 2B  			ld		(hl), de
 890  6B4A              FindExtEnd:
 891  6B4A D1           		pop		de
 892  6B4B C1           	pop		bc
 893  6B4C
 894  6B4C              NextExt:
 895  6B4C C5           	push bc
 896  6B4D 01 20 00     		ld bc, EXT_SZ
 897  6B50 DD 09        		add ix, bc
 898  6B52 C1           	pop	bc
 899  6B53
 900  6B53 05           	dec	b
 901  6B54 78           	ld	a, b
 902  6B55 B7           	or	a
 903  6B56 C2 D4 6A     	jp	nz, StoreFilenamesLoop
 904  6B59              GetFileNamesEnd:
 905  6B59 C9           	ret
 906  6B5A
 907  6B5A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 908  6B5A
 909  6B5A              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 910  6B5A              ;IN: HL = file name
 911  6B5A              HandleFile:
 912  6B5A              	;Make HL point to the selected file
 913  6B5A DD 2A 83 7F  	ld		ix, (SelFileCache)
 914  6B5E DD E5        	push	ix
 915  6B60 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 916  6B63 B7           		or		a
 917  6B64 CC B7 71     		call	z, ReadFileHeader
 918  6B67
 919  6B67 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 920  6B6A FE 00        		cp		PROG_TYPE
 921  6B6C 28 56        		jr		z, HandleFileProg
 922  6B6E
 923  6B6E FE 03        		cp		BYTE_TYPE
 924  6B70 20 62        		jr		nz, HandleFileText
 925  6B72
 926  6B72 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)		;get length
 926  6B76 66 12
 927  6B78 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 928  6B7B 19           		add		hl, de
 929  6B7C 7C           		ld		a, h
 930  6B7D B5           		or		l
 931  6B7E 28 26        		jr		z, HandleFileSCR
 932  6B80
 933  6B80
 934  6B80              HandleFileCODE:
 935  6B80 21 95 7D     		ld		hl, MsgLoadingCODE
 936  6B83 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 937  6B86 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 938  6B88 CD 37 77     		call	PrintStrClr
 939  6B8B
 940  6B8B              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 941  6B8B 21 2E 71     		ld		hl, IF1FileLoad
 942  6B8E 11 00 5B     		ld		de, PRN_BUF
 943  6B91 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 944  6B94 ED B0        		ldir
 945  6B96              		;ld		a, $C9
 946  6B96              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 947  6B96
 948  6B96 E1           	pop		hl
 949  6B97 ED 5B C9 8D  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 950  6B9B C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 951  6B9C C1           	pop		bc						;2nd, 3rd call for error handler
 952  6B9D C1           	pop		bc
 953  6B9E ED 43 3D 5C  	ld		(ERRSP), bc
 954  6BA2 D5           	push	de						;push CODE address to return to = start of CODE block
 955  6BA3 C3 00 5B     	jp		PRN_BUF
 956  6BA6
 957  6BA6
 958  6BA6
 959  6BA6
 960  6BA6              HandleFileSCR:
 961  6BA6 21 86 7D     		ld		hl, MsgLoadingSCR
 962  6BA9 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 963  6BAC 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 964  6BAE CD 37 77     		call	PrintStrClr
 965  6BB1
 966  6BB1 E1           	pop		hl
 967  6BB2
 968  6BB2              	IFDEF _REAL_HW_
 969  6BB2              		;Load to alternate SCREEN$ memory
 970  6BB2 11 00 C0     		ld		de, HC_VID_BANK1
 971  6BB5 CD 2E 71     		call	IF1FileLoad
 972  6BB8
 973  6BB8              		;Set display to alternate SCREEN$ memory
 974  6BB8 3E 08        		ld		a, HC_CFG_VID_C000
 975  6BBA D3 7E        		out 	(HC_CFG_PORT), a
 976  6BBC CD D3 76     		call	ReadChar
 977  6BBF
 978  6BBF              		;Set back to regular SCREEN$ memory
 979  6BBF 3E 00        		ld		a, HC_CFG_VID_4000
 980  6BC1 D3 7E        		out 	(HC_CFG_PORT), a
 981  6BC3              	ELSE
 982  6BC3 ~            		ld		de, HC_VID_BANK0
 983  6BC3 ~            		call	IF1FileLoad
 984  6BC3 ~            		call	ReadChar
 985  6BC3              	ENDIF
 986  6BC3
 987  6BC3 C9           	ret
 988  6BC4
 989  6BC4              HandleFileProg:
 990  6BC4 21 77 7D     		ld		hl, MsgLoadingPrg
 991  6BC7 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 992  6BCA 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 993  6BCC CD 37 77     		call	PrintStrClr
 994  6BCF E1           	pop		hl
 995  6BD0 CD 1E 72     	call	LoadProgram
 996  6BD3 C9           	ret
 997  6BD4
 998  6BD4
 999  6BD4              HandleFileText:
1000  6BD4 E1           	pop		hl
1001  6BD5
1002  6BD5              ViewFile:
1003  6BD5 21 6B 7F     	ld		hl, MsgFileLoading
1004  6BD8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
1005  6BDB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1006  6BDD CD 37 77     	call	PrintStrClr
1007  6BE0
1008  6BE0              	;Read file header if not yet read.
1009  6BE0 DD 2A 83 7F  	ld		ix, (SelFileCache)
1010  6BE4 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
1011  6BE7 B7           	or		a
1012  6BE8 CC B7 71     	call	z, ReadFileHeader
1013  6BEB
1014  6BEB              	;Determine file type from header.
1015  6BEB DD 2A 83 7F  	ld		ix, (SelFileCache)
1016  6BEF DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1017  6BF2 FE 00        	cp		PROG_TYPE
1018  6BF4 28 2D        	jr		z, ViewProgramFile
1019  6BF6
1020  6BF6              	;If not program, load as much as possible to RAM.
1021  6BF6 21 00 00     	ld		hl, 0
1022  6BF9 22 8B 7F     	ld		(FilePosRead), hl
1023  6BFC 2A 83 7F     	ld		hl, (SelFileCache)
1024  6BFF 3A 69 72     	ld 		a, (RWTSDrive)
1025  6C02 3C           	inc		a
1026  6C03 06 61        	ld		b, MAX_SECT_BUF
1027  6C05 CD 1C 76     	call	ReadFileSection					;DE = last address read
1028  6C08
1029  6C08 DD 2A 83 7F  	ld		ix, (SelFileCache)
1030  6C0C 3E 03        	ld		a, BYTE_TYPE
1031  6C0E DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
1032  6C11 21 CF 8D     	ld		hl, FileData+HDR_SZ
1033  6C14 30 03        	jr		nc, ViewFileWithHeader
1034  6C16 21 C6 8D     	ld		hl, FileData
1035  6C19
1036  6C19              ViewFileWithHeader:
1037  6C19              	;Calculate size of read buffer
1038  6C19 E5           	push	hl
1039  6C1A EB           		ex	de, hl
1040  6C1B B7           		or	a
1041  6C1C ED 52        		sbc	hl, de
1042  6C1E 44           		ld	b, h
1043  6C1F 4D           		ld	c, l
1044  6C20 E1           	pop		hl
1045  6C21 18 3F        	jr		ViewFileAsText
1046  6C23
1047  6C23              ViewProgramFile:
1048  6C23 21 00 00     	ld		hl, 0
1049  6C26 22 8B 7F     	ld		(FilePosRead), hl
1050  6C29 2A 83 7F     	ld		hl, (SelFileCache)
1051  6C2C 3A 69 72     	ld 		a, (RWTSDrive)
1052  6C2F 3C           	inc		a
1053  6C30 06 30        	ld		b, MAX_SECT_BUF/2				;Load half of available RAM with program bytecode, leave half for decoded text.
1054  6C32 CD 1C 76     	call	ReadFileSection					;DE = last address read
1055  6C35 21 C6 8D     	ld		hl, FileData
1056  6C38 3E 0D        	ld		a, CHAR_CR
1057  6C3A 13           	inc		de
1058  6C3B 12           	ld		(de), a
1059  6C3C
1060  6C3C DD 2A 83 7F  	ld		ix, (SelFileCache)
1061  6C40 DD 4E 15     	ld		c, (ix + CACHE_HDR + HDR_PLEN)
1062  6C43 DD 46 16     	ld		b, (ix + CACHE_HDR + HDR_PLEN + 1)
1063  6C46 21 CF 8D     	ld		hl, FileData + HDR_SZ						;Read program bytecode after the header.
1064  6C49 11 C6 BD     	ld		de, FileData + (MAX_SECT_BUF/2)*SECT_SZ		;Store text of program after read block.
1065  6C4C D5           	push	de
1066  6C4D CD DF 7B     		call	BASIC2TXT
1067  6C50 E1           	pop		hl
1068  6C51
1069  6C51              	;Get decoded text length
1070  6C51 11 C6 BD     	ld		de, FileData + (MAX_SECT_BUF/2)*SECT_SZ
1071  6C54 2A A7 7C     	ld		hl, (DestinationAddr)
1072  6C57 3E 1A        	ld		a, CHAR_EOF
1073  6C59 77           	ld		(hl), a								;Force EOF char at end of decoded basic program.
1074  6C5A 23           	inc		hl
1075  6C5B D5           	push	de
1076  6C5C B7           		or	a
1077  6C5D ED 52        		sbc	hl, de
1078  6C5F 44           		ld	b, h
1079  6C60 4D           		ld	c, l
1080  6C61 E1           	pop		hl
1081  6C62
1082  6C62              ViewFileAsText:
1083  6C62 E5           	push	hl
1084  6C63 C5           	push	bc
1085  6C64 CD EF 76     		call	ClrScr
1086  6C67 C1           	pop		bc
1087  6C68 E1           	pop		hl
1088  6C69 CD 56 79     	call	TextViewer
1089  6C6C C9           	ret
1090  6C6D
1091  6C6D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1092  6C6D
1093  6C6D
1094  6C6D              DisplayFileInfo:
1095  6C6D 2A 83 7F     	ld		hl, (SelFileCache)
1096  6C70 E5           	push	hl
1097  6C71              		;disk size - at least 2KB ==1  AU
1098  6C71 01 0D 00     		ld		bc, CACHE_AU_CNT
1099  6C74 09           		add		hl, bc
1100  6C75 5E 23 56 2B  		ld		de, (hl)
1101  6C79 EB           		ex		de, hl
1102  6C7A              		;*2, since one block (AU) is 2KB.
1103  6C7A CB 15        		rl	l
1104  6C7C CB 14        		rl	h
1105  6C7E
1106  6C7E 11 AE 7D     		ld		de, MsgFileSzDskN
1107  6C81 CD 35 6E     		call	Word2Txt
1108  6C84 21 A5 7D     		ld		hl, MsgFileSzDsk
1109  6C87 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1110  6C8A CD 0F 77     		call	PrintStr
1111  6C8D E1           	pop		hl
1112  6C8E E5           	push	hl
1113  6C8F              		;attributes
1114  6C8F 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1115  6C92 09           		add		hl, bc
1116  6C93 EB           		ex		de, hl
1117  6C94 21 BE 7D     		ld		hl, MsgFileAttrN
1118  6C97 1A           		ld		a, (de)
1119  6C98 E6 80        		and		%10000000
1120  6C9A 28 14        		jr		z, NotRO
1121  6C9C
1122  6C9C 01 52 2F     		ld		bc, '/R'
1123  6C9F 71 23 70 2B  		ld		(hl), bc
1124  6CA3 23           		inc		hl
1125  6CA4 23           		inc		hl
1126  6CA5 01 4F 2C     		ld		bc, ',O'
1127  6CA8 71 23 70 2B  		ld		(hl), bc
1128  6CAC 23           		inc		hl
1129  6CAD 23           		inc		hl
1130  6CAE 18 12        		jr		CheckSys
1131  6CB0              NotRO:
1132  6CB0 01 2D 2D     		ld		bc, '--'
1133  6CB3 71 23 70 2B  		ld		(hl), bc
1134  6CB7 23           		inc		hl
1135  6CB8 23           		inc		hl
1136  6CB9 01 2D 2C     		ld		bc, ',-'
1137  6CBC 71 23 70 2B  		ld		(hl), bc
1138  6CC0 23           		inc		hl
1139  6CC1 23           		inc		hl
1140  6CC2
1141  6CC2              CheckSys:
1142  6CC2 13           		inc		de
1143  6CC3 1A           		ld		a, (de)
1144  6CC4 E6 80        		and		%10000000
1145  6CC6 28 0E        		jr		z, NotSYS
1146  6CC8
1147  6CC8 01 48 49     		ld		bc, 'IH'
1148  6CCB 71 23 70 2B  		ld		(hl), bc
1149  6CCF 23           		inc		hl
1150  6CD0 23           		inc		hl
1151  6CD1 3E C4        		ld		a, 'D' + $80
1152  6CD3 77           		ld		(hl), a
1153  6CD4 18 0C        		jr		AttrEnd
1154  6CD6              NotSYS:
1155  6CD6 01 2D 2D     		ld		bc, '--'
1156  6CD9 71 23 70 2B  		ld		(hl), bc
1157  6CDD 23           		inc		hl
1158  6CDE 23           		inc		hl
1159  6CDF 3E AD        		ld		a, '-' + $80
1160  6CE1 77           		ld		(hl), a
1161  6CE2              AttrEnd:
1162  6CE2 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1163  6CE5 21 B5 7D     		ld		hl, MsgFileAttr
1164  6CE8 CD 0F 77     		call	PrintStr
1165  6CEB DD E1        	pop		ix
1166  6CED DD E5        	push	ix
1167  6CEF DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1168  6CF2 B7           		or		a
1169  6CF3 CA 90 6D             jp		z, HeadNotRead
1170  6CF6
1171  6CF6 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1172  6CF9 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1173  6CFC CA 90 6D             jp		z, HeadNotRead
1174  6CFF
1175  6CFF DD 7E 10     		ld		a, (ix + CACHE_HDR)
1176  6D02 FE 00        		cp		PROG_TYPE
1177  6D04 20 0B        		jr		nz, CheckNoArr
1178  6D06
1179  6D06 21 D8 7D     		ld		hl, MsgFileTypePrg
1180  6D09 11 CE 7D     		ld		de, MsgFileTypeN
1181  6D0C CD D9 6D     		call	MoveMsg
1182  6D0F 18 4F        		jr		PrepFileLen
1183  6D11
1184  6D11              CheckNoArr:
1185  6D11 FE 01        		cp		NUMB_TYPE
1186  6D13 20 0B        		jr		nz, CheckChrArr
1187  6D15
1188  6D15 21 F4 7D     		ld		hl, MsgFileTypeNoA
1189  6D18 11 CE 7D     		ld		de, MsgFileTypeN
1190  6D1B CD D9 6D     		call	MoveMsg
1191  6D1E 18 40        		jr		PrepFileLen
1192  6D20
1193  6D20              CheckChrArr:
1194  6D20 FE 02        		cp		CHAR_TYPE
1195  6D22 20 0B        		jr		nz, CheckByte
1196  6D24
1197  6D24 21 ED 7D     		ld		hl, MsgFileTypeChrA
1198  6D27 11 CE 7D     		ld		de, MsgFileTypeN
1199  6D2A CD D9 6D     		call	MoveMsg
1200  6D2D 18 31        		jr		PrepFileLen
1201  6D2F
1202  6D2F              CheckByte:
1203  6D2F FE 03        		cp		BYTE_TYPE
1204  6D31 20 24        		jr		nz, CheckText
1205  6D33
1206  6D33 DD 6E 11 DD  		ld		hl, (ix + CACHE_HDR + HDR_LEN)
1206  6D37 66 12
1207  6D39 01 00 E5     		ld		bc, -SCR_LEN
1208  6D3C 09           		add		hl, bc
1209  6D3D 7C           		ld		a, h
1210  6D3E B5           		or		l
1211  6D3F 20 0B        		jr		nz, NotScr
1212  6D41
1213  6D41 21 E6 7D     		ld		hl, MsgFileTypeSCR
1214  6D44 11 CE 7D     		ld		de, MsgFileTypeN
1215  6D47 CD D9 6D     		call	MoveMsg
1216  6D4A 18 14        		jr		PrepFileLen
1217  6D4C              NotScr:
1218  6D4C 21 DF 7D     		ld		hl, MsgFileTypeByte
1219  6D4F 11 CE 7D     		ld		de, MsgFileTypeN
1220  6D52 CD D9 6D     		call	MoveMsg
1221  6D55 18 09        		jr		PrepFileLen
1222  6D57
1223  6D57              CheckText:
1224  6D57 21 FB 7D     		ld		hl, MsgFileTypeText
1225  6D5A 11 CE 7D     		ld		de, MsgFileTypeN
1226  6D5D CD D9 6D     		call	MoveMsg
1227  6D60
1228  6D60              PrepFileLen:
1229  6D60              		;File len
1230  6D60 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1231  6D63 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1232  6D66              PrepFileLenText:
1233  6D66 11 12 7E     		ld		de, MsgFileLenN
1234  6D69 CD 35 6E     		call	Word2Txt
1235  6D6C 26 C2        		ld		h, 'B' | $80
1236  6D6E 2E 20        		ld		l, ' '
1237  6D70 22 17 7E     		ld		(MsgFileLenN + 5), hl
1238  6D73
1239  6D73 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1240  6D76 FE 00        		cp		PROG_TYPE
1241  6D78 28 06        		jr		z, PrintProgStart
1242  6D7A
1243  6D7A FE 03        		cp		BYTE_TYPE
1244  6D7C 28 0A        		jr		z, PrintByteStart
1245  6D7E
1246  6D7E 18 22        		jr		PrintStartNotRead
1247  6D80
1248  6D80              PrintProgStart:
1249  6D80 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1250  6D83 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1251  6D86 18 25        		jr		PrintStart
1252  6D88
1253  6D88              PrintByteStart:
1254  6D88 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1255  6D8B DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1256  6D8E 18 1D        		jr		PrintStart
1257  6D90
1258  6D90              HeadNotRead:
1259  6D90 21 02 7E             ld        hl, MsgNA
1260  6D93 11 CE 7D             ld        de, MsgFileTypeN
1261  6D96 CD D9 6D             call    MoveMsg
1262  6D99
1263  6D99 21 02 7E     		ld		hl, MsgNA
1264  6D9C 11 12 7E     		ld		de, MsgFileLenN
1265  6D9F CD D9 6D     		call	MoveMsg
1266  6DA2
1267  6DA2              PrintStartNotRead:
1268  6DA2 21 02 7E     		ld		hl, MsgNA
1269  6DA5 11 22 7E     		ld		de, MsgFileStartN
1270  6DA8 CD D9 6D     		call	MoveMsg
1271  6DAB 18 0E        		jr		PrintStartStr
1272  6DAD
1273  6DAD              PrintStart:
1274  6DAD 1E 20        	ld		e, ' '
1275  6DAF 16 A0        	ld		d, ' ' | $80
1276  6DB1 ED 53 27 7E  	ld		(MsgFileStartN + 5), de
1277  6DB5 11 22 7E     	ld		de, MsgFileStartN
1278  6DB8 CD 35 6E     	call	Word2Txt
1279  6DBB              PrintStartStr:
1280  6DBB 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1281  6DBE 21 19 7E     	ld		hl, MsgFileStart
1282  6DC1 CD 0F 77     	call	PrintStr
1283  6DC4
1284  6DC4 DD E1        	pop		ix
1285  6DC6 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1286  6DC9 21 C5 7D     	ld		hl, MsgFileType
1287  6DCC CD 0F 77     	call	PrintStr
1288  6DCF
1289  6DCF 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1290  6DD2 21 09 7E     	ld		hl, MsgFileLen
1291  6DD5 CD 0F 77     	call	PrintStr
1292  6DD8
1293  6DD8 C9           	ret
1294  6DD9
1295  6DD9              MoveMsg:
1296  6DD9 01 07 00     	ld		bc, 7
1297  6DDC ED B0        	ldir
1298  6DDE C9           	ret
1299  6DDF
1300  6DDF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1301  6DDF
1302  6DDF              ReadAllHeaders:
1303  6DDF 21 29 7E     	ld		hl, MsgReadingExt
1304  6DE2 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1305  6DE5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1306  6DE7 CD 37 77     	call	PrintStrClr
1307  6DEA
1308  6DEA CD 33 67     	call	CalcFileCache
1309  6DED
1310  6DED 3A 7C 7F     	ld		a, (SelFile)
1311  6DF0 47           	ld		b, a
1312  6DF1 3A 7A 7F     	ld		a, (FileCnt)
1313  6DF4 90           	sub		b
1314  6DF5 B7           	or		a
1315  6DF6 C8           	ret		z
1316  6DF7
1317  6DF7 47           	ld		b, a
1318  6DF8
1319  6DF8 DD 2A 83 7F  	ld		ix, (SelFileCache)
1320  6DFC              NextFile:
1321  6DFC C5           	push	bc
1322  6DFD CD B7 71     		call	ReadFileHeader
1323  6E00 01 19 00     		ld		bc, CACHE_SZ
1324  6E03 DD 09        		add		ix, bc
1325  6E05 DD E5        		push	ix
1326  6E07 CD 33 67     			call	CalcFileCache
1327  6E0A CD 6D 6C     			call	DisplayFileInfo
1328  6E0D DD E1        		pop		ix
1329  6E0F
1330  6E0F CD D6 76     		call	KbdHit
1331  6E12 38 03        		jr		c, AKey
1332  6E14 C1           	pop		bc
1333  6E15 18 15        	jr		ReadAllHeadersEnd
1334  6E17
1335  6E17              AKey:
1336  6E17 3A 7C 7F     		ld		a, (SelFile)
1337  6E1A 3C           		inc		a
1338  6E1B 47           		ld		b, a
1339  6E1C 3A 7A 7F     		ld		a, (FileCnt)
1340  6E1F B8           		cp		b
1341  6E20 28 10        		jr		z, DontInc
1342  6E22 78           		ld		a, b
1343  6E23 32 7C 7F     		ld		(SelFile), a
1344  6E26 CD 03 78     		call	MoveCursor
1345  6E29 C1           	pop		bc
1346  6E2A 10 D0        	djnz	NextFile
1347  6E2C
1348  6E2C              ReadAllHeadersEnd:
1349  6E2C 06 01        	ld		b, 1
1350  6E2E CD BB 78     	call	ClearNMsgLines
1351  6E31 C9           	ret
1352  6E32
1353  6E32              DontInc:
1354  6E32 C1           	pop		bc
1355  6E33 18 F7        	jr		ReadAllHeadersEnd
1356  6E35
1357  6E35
1358  6E35              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1359  6E35
1360  6E35              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6E35              	ifndef	_HCCFG_
   2+ 6E35              	define	_HCCFG_
   3+ 6E35
   4+ 6E35              ;HC specific code, for configuration
   5+ 6E35
   6+ 6E35              HC_CFG_PORT			EQU	$7E
   7+ 6E35              HC_FLOPPY_PORT		EQU 7
   8+ 6E35
   9+ 6E35              ;BASIC/CPM ROM selection
  10+ 6E35              HC_CFG_ROM_BAS		EQU	%0
  11+ 6E35              HC_CFG_ROM_CPM		EQU	%1
  12+ 6E35
  13+ 6E35              ;Address for ROM paging: 0 or $E000
  14+ 6E35              HC_CFG_ROM_0000		EQU %00
  15+ 6E35              HC_CFG_ROM_E000		EQU %10
  16+ 6E35
  17+ 6E35              ;Cfg. port Enable/Disable
  18+ 6E35              HC_CFG_PORT_DIS		EQU %000
  19+ 6E35              HC_CFG_PORT_EN		EQU	%100
  20+ 6E35
  21+ 6E35              ;Video memory bank: $4000 or $C000
  22+ 6E35              HC_CFG_VID_4000		EQU	%0000
  23+ 6E35              HC_CFG_VID_C000		EQU	%1000
  24+ 6E35
  25+ 6E35
  26+ 6E35              ;Standar BASIC config
  27+ 6E35              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 6E35              ;Standar CP/M config
  29+ 6E35              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 6E35
  31+ 6E35
  32+ 6E35              HC_VID_BANK0		EQU	$4000
  33+ 6E35              HC_VID_BANK1		EQU	$C000
  34+ 6E35
  35+ 6E35              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 6E35              ;Info from Rares Atodiresei.
  37+ 6E35              IsDrive2_80Tracks:
  38+ 6E35              	IFUSED
  39+ 6E35 ~            	in	a, (HC_FLOPPY_PORT)
  40+ 6E35 ~            	and %10
  41+ 6E35 ~            	ret
  42+ 6E35              	ENDIF
  43+ 6E35
  44+ 6E35              	endif
# file closed: hccfg.asm
1361  6E35              	include "if1.asm"
# file opened: if1.asm
   1+ 6E35              ;HC IF1 routines and constants
   2+ 6E35
   3+ 6E35              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6E35              ;12 = Writing to a 'read' file
   5+ 6E35              ;13 = Reading a 'write' file
   6+ 6E35              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6E35              ;15 = Disk full (disk or catalog full)
   8+ 6E35              ;16 = Disk error (hardware error)
   9+ 6E35              ;17 = File not found
  10+ 6E35              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6E35              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6E35
  13+ 6E35              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6E35              ;00h = OK
  15+ 6E35              ;08h = cannot format disk
  16+ 6E35              ;10h = disk protected (read-only?)
  17+ 6E35              ;20h = volume error
  18+ 6E35              ;40h = drive error
  19+ 6E35              ;80h = reading error
  20+ 6E35              ;Codes I encountered:
  21+ 6E35              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6E35
  23+ 6E35
  24+ 6E35              	ifndef	_DISK_
  25+ 6E35              	define	_DISK_
  26+ 6E35
  27+ 6E35              	include	"math.asm"
# file opened: math.asm
   1++6E35              	ifndef	_MATH_
   2++6E35              	define	_MATH_
   3++6E35
   4++6E35              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6E35              ;http://map.tni.nl/sources/external/z80bits.html
   6++6E35
   7++6E35
   8++6E35              Word2Txt:
   9++6E35              	IFUSED
  10++6E35 D5           	push	de
  11++6E36 CD 56 6E     		call	Word2Txt_
  12++6E39 D1           	pop		de
  13++6E3A
  14++6E3A 06 04        	ld		b, 4
  15++6E3C CD 4B 6E     	call	StrippLeading0
  16++6E3F C9           	ret
  17++6E40
  18++6E40              Byte2Txt:
  19++6E40 D5           	push	de
  20++6E41 CD 62 6E     		call	Byte2Txt_
  21++6E44 D1           	pop		de
  22++6E45
  23++6E45 06 02        	ld		b, 2
  24++6E47 CD 4B 6E     	call	StrippLeading0
  25++6E4A C9           	ret
  26++6E4B              	ENDIF
  27++6E4B
  28++6E4B
  29++6E4B              StrippLeading0:
  30++6E4B 1A           	ld		a, (de)
  31++6E4C FE 31        	cp		'1'
  32++6E4E D0           	ret		nc
  33++6E4F
  34++6E4F 3E 20        	ld		a, ' '
  35++6E51 12           	ld		(de), a
  36++6E52 13           	inc		de
  37++6E53 10 F6        	djnz	StrippLeading0
  38++6E55 C9           	ret
  39++6E56
  40++6E56
  41++6E56              ;Converts the number in HL to ASCII in decimal string at DE
  42++6E56              Word2Txt_:
  43++6E56 01 F0 D8     	ld bc, -10000
  44++6E59 CD 71 6E     	call DigitLoop
  45++6E5C 01 18 FC     	ld bc, -1000
  46++6E5F CD 71 6E     	call DigitLoop
  47++6E62              Byte2Txt_:
  48++6E62 01 9C FF     	ld bc, -100
  49++6E65 CD 71 6E     	call DigitLoop
  50++6E68 01 F6 FF     	ld bc, -10
  51++6E6B CD 71 6E     	call DigitLoop
  52++6E6E 01 FF FF     	ld bc, -1
  53++6E71
  54++6E71              DigitLoop:
  55++6E71 3E 2F        	ld	a, '0' - 1
  56++6E73              DivNrLoop:
  57++6E73 3C           	inc	a			;increase reminder
  58++6E74 09           	add	hl, bc		;substract divizor
  59++6E75 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6E77 ED 42        	sbc	hl, bc		;nope, restore
  61++6E79
  62++6E79 12           	ld (de), a
  63++6E7A 13           	inc de
  64++6E7B C9           	ret
  65++6E7C
  66++6E7C
  67++6E7C              ;Input: HL = Dividend, C = Divisor
  68++6E7C              ;Output: HL = Quotient, A = Remainder
  69++6E7C              ;Warning: doesn't work with divisor >= $80
  70++6E7C              Div:
  71++6E7C              	IFUSED
  72++6E7C AF           	xor a
  73++6E7D 06 10        	ld b, 16
  74++6E7F
  75++6E7F              DivLoop:
  76++6E7F 29           	add	hl,hl
  77++6E80 17           	rla
  78++6E81 B9           	cp	c
  79++6E82 38 02        	jr	c, NoSub
  80++6E84 91           	sub	c
  81++6E85 2C           	inc	l
  82++6E86              NoSub:
  83++6E86 10 F7        	djnz DivLoop
  84++6E88
  85++6E88 C9           	ret
  86++6E89              	ENDIF
  87++6E89
  88++6E89              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6E89              ;Output: A:C = Quotient, HL = Remainder
  90++6E89              Div2:
  91++6E89 21 00 00     	ld hl, 0
  92++6E8C 06 10        	ld b, 16
  93++6E8E              Div2Loop:
  94++6E8E CB 31        	sll c		; unroll 16 times
  95++6E90 17           	rla			; ...
  96++6E91 ED 6A        	adc	hl,hl		; ...
  97++6E93 ED 52        	sbc	hl,de		; ...
  98++6E95 30 02        	jr	nc,$+4		; ...
  99++6E97 19           	add	hl,de		; ...
 100++6E98 0D           	dec	c		; ...
 101++6E99 10 F3        	djnz Div2Loop
 102++6E9B C9           	ret
 103++6E9C
 104++6E9C
 105++6E9C              ;Input: A = Multiplier, DE = Multiplicand
 106++6E9C              ;Output: A:HL = Product
 107++6E9C              Mul:
 108++6E9C              	IFUSED
 109++6E9C 21 00 00     	ld hl, 0
 110++6E9F 01 00 07     	ld bc, $0700
 111++6EA2
 112++6EA2 87           	add	a, a		; optimised 1st iteration
 113++6EA3 30 02        	jr	nc, MulLoop
 114++6EA5 62           	ld	h, d
 115++6EA6 6B           	ld	l, e
 116++6EA7
 117++6EA7              MulLoop:
 118++6EA7 29           	add	hl,hl
 119++6EA8 17           	rla
 120++6EA9 30 02        	jr	nc, NoAdd
 121++6EAB 19           	add	hl,de
 122++6EAC 89           	adc	a,c
 123++6EAD              NoAdd:
 124++6EAD 10 F8        	djnz MulLoop
 125++6EAF
 126++6EAF C9           	ret
 127++6EB0              	ENDIF
 128++6EB0
 129++6EB0              	endif
# file closed: math.asm
  28+ 6EB0
  29+ 6EB0              DRIVE_CUR_BAS	EQU 0
  30+ 6EB0              DRIVE_A_BAS		EQU	1
  31+ 6EB0              DRIVE_B_BAS		EQU	2
  32+ 6EB0              DRIVE_A_CPM		EQU	0
  33+ 6EB0              DRIVE_B_CPM		EQU	1
  34+ 6EB0              ;Disk geometry stuff
  35+ 6EB0              SPT				EQU	16			;sectors per track
  36+ 6EB0              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6EB0              TRACK_CNT		EQU	80			;track count
  38+ 6EB0              HEAD_CNT		EQU	2			;disk face count
  39+ 6EB0              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6EB0              EXT_SZ			EQU	32			;directory entry size
  41+ 6EB0              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6EB0              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6EB0              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6EB0              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6EB0              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6EB0              REC_SZ			EQU 128			;cp/m record size
  47+ 6EB0              DEL_MARKER		EQU	$E5
  48+ 6EB0
  49+ 6EB0
  50+ 6EB0              ;Extension structure (directory entry)
  51+ 6EB0              EXT_DEL_FLAG	EQU	0
  52+ 6EB0              EXT_NAME		EQU 1
  53+ 6EB0              EXT_IDX			EQU 12
  54+ 6EB0              EXT_S1			EQU 13
  55+ 6EB0              EXT_S2			EQU 14
  56+ 6EB0              EXT_RC			EQU	15
  57+ 6EB0              EXT_AU0			EQU	16
  58+ 6EB0              EXT_AU1			EQU	18
  59+ 6EB0              EXT_AU2			EQU	20
  60+ 6EB0              EXT_AU3			EQU	22
  61+ 6EB0              EXT_AU4			EQU	24
  62+ 6EB0              EXT_AU5			EQU	26
  63+ 6EB0              EXT_AU6			EQU	28
  64+ 6EB0              EXT_AU7			EQU	30
  65+ 6EB0              EXT_SIZE		EQU 32
  66+ 6EB0
  67+ 6EB0              ;FCB structure
  68+ 6EB0              FCB_DRIVE		EQU 0
  69+ 6EB0              FCB_NAME		EQU EXT_NAME
  70+ 6EB0              FCB_EX_IDX		EQU EXT_IDX
  71+ 6EB0              FCB_S1			EQU EXT_S1
  72+ 6EB0              FCB_S2			EQU EXT_S2
  73+ 6EB0              FCB_RC			EQU	EXT_RC
  74+ 6EB0              FCB_AU			EQU	EXT_AU0
  75+ 6EB0              FCB_CR			EQU	32
  76+ 6EB0              FCB_R0			EQU 33
  77+ 6EB0              FCB_R1			EQU 34
  78+ 6EB0              FCB_R2			EQU 35
  79+ 6EB0              FCB_SIZE		EQU 36
  80+ 6EB0
  81+ 6EB0
  82+ 6EB0
  83+ 6EB0              ;System variables for disk
  84+ 6EB0              DSTR1			EQU	$5CD6		;drive
  85+ 6EB0              FSTR1			EQU	$5CDC		;file name
  86+ 6EB0              NSTR1			EQU	$5CDA		;name length
  87+ 6EB0              HD11			EQU	$5CED		;BDOS argument
  88+ 6EB0              COPIES			EQU	$5CEF		;BDOS function
  89+ 6EB0
  90+ 6EB0              ERRSP			EQU $5C3D
  91+ 6EB0              ERRNR			EQU $5C3A
  92+ 6EB0              ERRMSG			EQU	$0260
  93+ 6EB0
  94+ 6EB0              PROG			EQU $5C53
  95+ 6EB0              VARS			EQU	$5C4B
  96+ 6EB0              STKEND			EQU	$5C65
  97+ 6EB0
  98+ 6EB0              PRN_BUF			EQU	23296
  99+ 6EB0
 100+ 6EB0              REPDEL			EQU	23561
 101+ 6EB0              REPPER			EQU	23562
 102+ 6EB0              PIP				EQU	23609
 103+ 6EB0
 104+ 6EB0
 105+ 6EB0              ;RWTS routine commands
 106+ 6EB0              RWTS_CMD_SEEK	EQU	0			;position head
 107+ 6EB0              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6EB0              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6EB0              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6EB0
 111+ 6EB0
 112+ 6EB0              ;File name stuff
 113+ 6EB0              NAMELEN			EQU	11			;name length
 114+ 6EB0              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6EB0              SYS_POS			EQU	9			;system attribute position in name
 116+ 6EB0
 117+ 6EB0              ;File types (first byte in header)
 118+ 6EB0              PROG_TYPE		EQU	0			;program
 119+ 6EB0              NUMB_TYPE		EQU	1			;number array
 120+ 6EB0              CHAR_TYPE		EQU	2			;char array
 121+ 6EB0              BYTE_TYPE		EQU	3			;bytes
 122+ 6EB0              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6EB0
 124+ 6EB0              ;File header offsets
 125+ 6EB0              HDR_TYPE		EQU	0
 126+ 6EB0              HDR_LEN			EQU 1
 127+ 6EB0              HDR_ADDR		EQU 3
 128+ 6EB0              HDR_PLEN		EQU	5
 129+ 6EB0              HDR_LINE		EQU 7
 130+ 6EB0              HDR_SZ			EQU	9
 131+ 6EB0
 132+ 6EB0              ;BASIC disk channel structure
 133+ 6EB0              CH_RW_FLAG		EQU 11
 134+ 6EB0              CH_FCB			EQU	12
 135+ 6EB0              CH_DATA			EQU	50
 136+ 6EB0              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6EB0
 138+ 6EB0              CACHE_NAME		EQU	0					;11B
 139+ 6EB0              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6EB0              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6EB0              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6EB0              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6EB0              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6EB0
 145+ 6EB0              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6EB0
 147+ 6EB0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6EB0              IF1Init:
 149+ 6EB0 CF           	rst		08
 150+ 6EB1 31           	defb	49		;create system variables
 151+ 6EB2 C9           	ret
 152+ 6EB3
 153+ 6EB3              ;ReadWriteTrackSector
 154+ 6EB3              ;A=command: 0, 1, 2, 4
 155+ 6EB3              RWTS:
 156+ 6EB3 32 73 72     	ld (RWTSCmd), a
 157+ 6EB6 21 68 72     	ld hl, RWTSParams
 158+ 6EB9 22 ED 5C     	ld (HD11), hl
 159+ 6EBC CF           	rst 08
 160+ 6EBD 3A           	DEFB 58
 161+ 6EBE C9           	ret
 162+ 6EBF
 163+ 6EBF
 164+ 6EBF              ;D = sector, E = track
 165+ 6EBF              ;HL = dma
 166+ 6EBF              ReadOneDiskSector:
 167+ 6EBF 22 6D 72     	ld (RWTSDMA), hl
 168+ 6EC2 ED 53 6B 72  	ld (RWTSTrack), de
 169+ 6EC6              	;ld (RWTSDrive), a
 170+ 6EC6 3E 01        	ld a, RWTS_CMD_READ
 171+ 6EC8 18 E9        	jr	RWTS
 172+ 6ECA
 173+ 6ECA              ;D = sector, E = track
 174+ 6ECA              ;HL = dma
 175+ 6ECA              WriteOneDiskSector:
 176+ 6ECA 22 6D 72     	ld (RWTSDMA), hl
 177+ 6ECD ED 53 6B 72  	ld (RWTSTrack), de
 178+ 6ED1              	;ld (RWTSDrive), a
 179+ 6ED1 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6ED3 18 DE        	jr	RWTS
 181+ 6ED5
 182+ 6ED5              FormatDisk:
 183+ 6ED5 21 C6 8D     	ld		hl, DataBuf
 184+ 6ED8 36 E5        	ld		(hl), DEL_MARKER
 185+ 6EDA 22 6D 72     	ld 		(RWTSDMA), hl
 186+ 6EDD 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 6EDF CD B3 6E     	call	RWTS
 188+ 6EE2 3A 74 72     	ld		a, (RWTSRes)
 189+ 6EE5 C9           	ret
 190+ 6EE6
 191+ 6EE6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 6EE6
 193+ 6EE6              ;Allocation unit no. to track/sector
 194+ 6EE6              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 6EE6              ;IN:  HL=alloc. unit no.
 196+ 6EE6              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 6EE6              AU2TS:
 198+ 6EE6 0E 02        	ld c, SPT/SPAL
 199+ 6EE8 CD 7C 6E     	call Div					;A = sector
 200+ 6EEB F5           	push af
 201+ 6EEC ~            		/*
 202+ 6EEC ~            		ld c, HEAD_CNT
 203+ 6EEC ~            		call Div				;L = track, A = head (0 or 1)
 204+ 6EEC ~            		*/
 205+ 6EEC AF           		xor a
 206+ 6EED CB 1C        		rr h
 207+ 6EEF CB 1D        		rr l
 208+ 6EF1 CB 1F        		rr a
 209+ 6EF3
 210+ 6EF3 4D           		ld c, l
 211+ 6EF4 06 00        		ld b, 0
 212+ 6EF6 B7           		or a
 213+ 6EF7 28 02        		jr z, Track0
 214+ 6EF9 06 10        		ld b, SPT
 215+ 6EFB              Track0:
 216+ 6EFB F1           	pop af
 217+ 6EFC B7           	or a
 218+ 6EFD 28 02        	jr z, FirstAU
 219+ 6EFF 3E 08        	ld a, SPAL
 220+ 6F01              FirstAU:
 221+ 6F01 80           	add a, b
 222+ 6F02 47           	ld  b, a
 223+ 6F03 C9           	ret
 224+ 6F04
 225+ 6F04              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 6F04
 227+ 6F04              ;Checks the allocation units number used in extension
 228+ 6F04              ;IN:	IX = extension addr
 229+ 6F04              ;OUT:	B = no. of allocation units used
 230+ 6F04              ;		C = no. of records used in ext.
 231+ 6F04              ;		HL = first alloc. unit no.
 232+ 6F04              ;		DE = last alloc. unit no.
 233+ 6F04              CheckExtAlloc:
 234+ 6F04 DD E5        	push ix
 235+ 6F06 01 0F 00     		ld bc, EXT_RC
 236+ 6F09 DD 09        		add ix, bc
 237+ 6F0B DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 6F0E DD 23        		inc ix
 239+ 6F10 DD 6E 00     		ld l, (ix)
 240+ 6F13 DD 66 01     		ld h, (ix + 1)
 241+ 6F16 06 08        		ld b, EXT_AU_CNT
 242+ 6F18              CheckAU:
 243+ 6F18 DD 7E 00     		ld a, (ix)
 244+ 6F1B DD B6 01     		or (ix + 1)
 245+ 6F1E 28 0C        		jr z, CheckAUEnd
 246+ 6F20 DD 5E 00     		ld e, (ix)
 247+ 6F23 DD 56 01     		ld d, (ix + 1)
 248+ 6F26 DD 23        		inc ix
 249+ 6F28 DD 23        		inc ix
 250+ 6F2A 10 EC        		djnz CheckAU
 251+ 6F2C              CheckAUEnd:
 252+ 6F2C 3E 08        		ld a, EXT_AU_CNT
 253+ 6F2E 90           		sub b
 254+ 6F2F 47           		ld b, a
 255+ 6F30 DD E1        	pop ix
 256+ 6F32 C9           	ret
 257+ 6F33
 258+ 6F33              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 6F33
 260+ 6F33              ;Input: TrackBuffer
 261+ 6F33              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 6F33              ReadUsedBlocksList:
 263+ 6F33 DD 21 C6 8D  	ld		ix, TrackBuf			;source buffer
 264+ 6F37 21 DC 87     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 6F3A ED 4B 81 7F  	ld		bc, (AUCntMaxFree)		;loop counter
 266+ 6F3E 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 6F41 73           	ld		(hl), e
 268+ 6F42 23           	inc		hl
 269+ 6F43 72           	ld		(hl), d
 270+ 6F44 23           	inc		hl
 271+ 6F45
 272+ 6F45              	;Add blocks 0 and 1 for directory
 273+ 6F45 11 00 00     	ld		de, 0
 274+ 6F48 73           	ld		(hl), e
 275+ 6F49 23           	inc		hl
 276+ 6F4A 72           	ld		(hl), d
 277+ 6F4B 23           	inc		hl
 278+ 6F4C
 279+ 6F4C 13           	inc		de
 280+ 6F4D 73           	ld		(hl), e
 281+ 6F4E 23           	inc		hl
 282+ 6F4F 72           	ld		(hl), d
 283+ 6F50 23           	inc		hl
 284+ 6F51
 285+ 6F51              ReadUsedBlocksLoop:
 286+ 6F51 AF           	xor		a
 287+ 6F52 DD BE 00     	cp		(ix)
 288+ 6F55 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 6F57
 290+ 6F57 DD E5        	push	ix
 291+ 6F59 C5           	push	bc
 292+ 6F5A 06 08        		ld		b, EXT_AU_CNT
 293+ 6F5C 11 10 00     		ld		de, EXT_AU0
 294+ 6F5F DD 19        		add		ix, de
 295+ 6F61
 296+ 6F61              ReadUsedBlocksLoop2:
 297+ 6F61 DD 5E 00     		ld		e, (ix)
 298+ 6F64 DD 56 01     		ld		d, (ix+1)
 299+ 6F67 7B           		ld		a, e
 300+ 6F68 B2           		or		d
 301+ 6F69 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 6F6B
 303+ 6F6B 73           		ld		(hl), e
 304+ 6F6C 23           		inc		hl
 305+ 6F6D 72           		ld		(hl), d
 306+ 6F6E 23           		inc		hl
 307+ 6F6F
 308+ 6F6F DD 23        		inc		ix
 309+ 6F71 DD 23        		inc		ix
 310+ 6F73
 311+ 6F73 ED 5B DC 87  		ld		de, (UsedBlockListCnt)
 312+ 6F77 13           		inc		de
 313+ 6F78 ED 53 DC 87  		ld		(UsedBlockListCnt), de
 314+ 6F7C
 315+ 6F7C 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 6F7E
 317+ 6F7E
 318+ 6F7E              ReadUsedBlocksSkip:
 319+ 6F7E C1           	pop		bc
 320+ 6F7F DD E1        	pop		ix
 321+ 6F81              ReadUsedBlocksSkip2:
 322+ 6F81 11 20 00     	ld		de, EXT_SZ
 323+ 6F84 DD 19        	add		ix, de
 324+ 6F86
 325+ 6F86 0B           	dec		bc
 326+ 6F87 78           	ld		a, b
 327+ 6F88 B1           	or		c
 328+ 6F89 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 6F8B
 330+ 6F8B C9           	ret
 331+ 6F8C
 332+ 6F8C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 6F8C              ;Reads 8 sectors for an AU
 334+ 6F8C              ;HL = block number, DE = destination buffer
 335+ 6F8C              ReadFSBlock:
 336+ 6F8C D5           	push	de
 337+ 6F8D CD E6 6E     		call	AU2TS		;B=sector, C=track
 338+ 6F90 E1           	pop		hl				;HL=dest
 339+ 6F91
 340+ 6F91 50           	ld		d, b
 341+ 6F92 59           	ld		e, c
 342+ 6F93 06 08        	ld		b, SPAL
 343+ 6F95
 344+ 6F95 CD 74 71     	call	ReadDiskSectors
 345+ 6F98 C9           	ret
 346+ 6F99
 347+ 6F99
 348+ 6F99              ;Write 8 sectors for an AU
 349+ 6F99              ;HL = block number, DE = source buffer
 350+ 6F99              WriteFSBlock:
 351+ 6F99 D5           	push	de
 352+ 6F9A CD E6 6E     		call	AU2TS		;B=sector, C=track
 353+ 6F9D E1           	pop		hl				;HL=dest
 354+ 6F9E
 355+ 6F9E 50           	ld		d, b
 356+ 6F9F 59           	ld		e, c
 357+ 6FA0 06 08        	ld		b, SPAL
 358+ 6FA2
 359+ 6FA2 CD 87 71     	call	WriteDiskSectors
 360+ 6FA5 C9           	ret
 361+ 6FA6
 362+ 6FA6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 6FA6              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 6FA6              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 6FA6              CopyDisk:
 366+ 6FA6              	;Get list of used blocks in current disk, max 632 bytes
 367+ 6FA6 CD 33 6F     	call	ReadUsedBlocksList
 368+ 6FA9 DD 21 DE 87  	ld		ix, UsedBlockListBlk
 369+ 6FAD
 370+ 6FAD              CopyDiskLoop:
 371+ 6FAD 2A DC 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 6FB0 11 F3 7E     	ld		de, MsgBlocksLeft
 373+ 6FB3 CD 40 6E     	call	Byte2Txt
 374+ 6FB6 21 F3 7E     	ld		hl, MsgBlocksLeft
 375+ 6FB9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 6FBC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 6FBE CD 37 77     	call	PrintStrClr
 378+ 6FC1
 379+ 6FC1              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 6FC1 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 6FC4 ED 4B DC 87  	ld		bc, (UsedBlockListCnt)
 382+ 6FC8 B7           	or		a
 383+ 6FC9 ED 42        	sbc		hl, bc
 384+ 6FCB 30 03        	jr		nc, CopyDiskLoopRead
 385+ 6FCD 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 6FD0
 387+ 6FD0              CopyDiskLoopRead:
 388+ 6FD0 41           	ld		b, c
 389+ 6FD1 11 C6 8D     	ld		de, CopyDiskBuf
 390+ 6FD4              	;save initial counter and initial block number array position
 391+ 6FD4 C5           	push	bc
 392+ 6FD5 DD E5        	push	ix
 393+ 6FD7
 394+ 6FD7              CopyDiskLoopReadLoop:
 395+ 6FD7 DD 6E 00     		ld		l, (ix)
 396+ 6FDA DD 66 01     		ld		h, (ix+1)
 397+ 6FDD DD 23        		inc		ix
 398+ 6FDF DD 23        		inc		ix
 399+ 6FE1
 400+ 6FE1 D5           		push	de
 401+ 6FE2 C5           		push	bc
 402+ 6FE3 CD 8C 6F     			call	ReadFSBlock			;Stop on error or continue?
 403+ 6FE6 C1           		pop		bc
 404+ 6FE7 D1           		pop		de
 405+ 6FE8
 406+ 6FE8              		;+2048
 407+ 6FE8 7A           		ld		a, d
 408+ 6FE9 C6 08        		add		8
 409+ 6FEB 57           		ld		d, a
 410+ 6FEC
 411+ 6FEC 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 6FEE
 413+ 6FEE              		;Check if selection is 1=single drive or 2=dual drive
 414+ 6FEE 3A 85 7F     		ld		a, (CopySelOption)
 415+ 6FF1 FE 31        		cp		'1'
 416+ 6FF3 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 6FF5
 418+ 6FF5              		;Prompt for disk change
 419+ 6FF5 CD 7B 73     		call	PromptDiskChangeDst
 420+ 6FF8 3A 69 72     		ld		a, (RWTSDrive)
 421+ 6FFB CD 81 72     		call	BDOSInit
 422+ 6FFE 18 0A        		jr		CopyDiskReadEnd
 423+ 7000
 424+ 7000              CopyDiskDualDrive1:
 425+ 7000              		;alternate drive
 426+ 7000 3A 69 72     		ld		a, (RWTSDrive)
 427+ 7003 3C           		inc 	a
 428+ 7004 EE 03        		xor		%11
 429+ 7006 3D           		dec		a
 430+ 7007 32 69 72     		ld		(RWTSDrive), a
 431+ 700A
 432+ 700A              CopyDiskReadEnd:
 433+ 700A              	;restore initial counter and initial block number array position
 434+ 700A DD E1        	pop		ix
 435+ 700C C1           	pop		bc
 436+ 700D 11 C6 8D     	ld		de, CopyDiskBuf
 437+ 7010 C5           	push	bc
 438+ 7011
 439+ 7011              CopyDiskLoopWriteLoop:
 440+ 7011 DD 6E 00     		ld		l, (ix)
 441+ 7014 DD 66 01     		ld		h, (ix+1)
 442+ 7017 DD 23        		inc		ix
 443+ 7019 DD 23        		inc		ix
 444+ 701B
 445+ 701B D5           		push	de
 446+ 701C C5           		push	bc
 447+ 701D CD 99 6F     			call	WriteFSBlock		;Stop on error or continue?
 448+ 7020 C1           		pop		bc
 449+ 7021 D1           		pop		de
 450+ 7022
 451+ 7022              		;+2048
 452+ 7022 7A           		ld		a, d
 453+ 7023 C6 08        		add		8
 454+ 7025 57           		ld		d, a
 455+ 7026
 456+ 7026 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 7028
 458+ 7028              CopyDiskWriteEnd:
 459+ 7028 C1           	pop		bc
 460+ 7029 48           	ld		c, b
 461+ 702A 06 00        	ld		b, 0
 462+ 702C
 463+ 702C              	;Decrease number of blocks read by now.
 464+ 702C 2A DC 87     	ld		hl, (UsedBlockListCnt)
 465+ 702F B7           	or		a
 466+ 7030 ED 42        	sbc		hl, bc
 467+ 7032 22 DC 87     	ld		(UsedBlockListCnt), hl
 468+ 7035
 469+ 7035 7D           	ld		a, l
 470+ 7036 B4           	or		h
 471+ 7037 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 7039
 473+ 7039              	;Check if selection is 1=single drive or 2=dual drive
 474+ 7039 3A 85 7F     	ld		a, (CopySelOption)
 475+ 703C FE 31        	cp		'1'
 476+ 703E 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 7040
 478+ 7040              	;Prompt for disk change
 479+ 7040 CD 95 73     	call	PromptDiskChangeSrc
 480+ 7043 3A 69 72     	ld		a, (RWTSDrive)
 481+ 7046 CD 81 72     	call	BDOSInit
 482+ 7049 C3 AD 6F     	jp		CopyDiskLoop
 483+ 704C
 484+ 704C              CopyDiskDualDrive2:
 485+ 704C              	;alternate drive again
 486+ 704C 3A 69 72     	ld		a, (RWTSDrive)
 487+ 704F 3C           	inc		a
 488+ 7050 EE 03        	xor		%11
 489+ 7052 3D           	dec		a
 490+ 7053 32 69 72     	ld		(RWTSDrive), a
 491+ 7056 C3 AD 6F     	jp		CopyDiskLoop
 492+ 7059
 493+ 7059              CopyDiskEnd:
 494+ 7059 06 01        	ld		b, 1
 495+ 705B CD BB 78     	call	ClearNMsgLines
 496+ 705E C9           	ret
 497+ 705F
 498+ 705F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 705F              ;Copies the current disk blocks to COM port.
 500+ 705F              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 705F              CopyDiskToCOM:
 502+ 705F              	;Get list of used blocks in current disk, max 632 bytes
 503+ 705F CD 33 6F     	call	ReadUsedBlocksList
 504+ 7062
 505+ 7062              	;Send block count and block indexes
 506+ 7062 2A DC 87     	ld		hl, (UsedBlockListCnt)
 507+ 7065 29           	add		hl, hl
 508+ 7066 23           	inc		hl
 509+ 7067 23           	inc		hl
 510+ 7068 44           	ld		b, h
 511+ 7069 4D           	ld		c, l
 512+ 706A 21 DC 87     	ld		hl, UsedBlockListCnt
 513+ 706D CD A9 7B     	call	SERTB
 514+ 7070
 515+ 7070 DD 21 DE 87  	ld		ix, UsedBlockListBlk
 516+ 7074
 517+ 7074              CopyDiskToCOMLoop:
 518+ 7074              	;Print block count left
 519+ 7074 2A DC 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 7077 11 F3 7E     	ld		de, MsgBlocksLeft
 521+ 707A CD 40 6E     	call	Byte2Txt
 522+ 707D 21 F3 7E     	ld		hl, MsgBlocksLeft
 523+ 7080 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 7083 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 7085 CD 37 77     	call	PrintStrClr
 526+ 7088
 527+ 7088              	;Read block into buffer
 528+ 7088 DD 6E 00     	ld		l, (ix)
 529+ 708B DD 66 01     	ld		h, (ix+1)
 530+ 708E 11 C6 8D     	ld		de, CopyDiskBuf
 531+ 7091 DD E5        	push	ix
 532+ 7093 CD 8C 6F     		call	ReadFSBlock
 533+ 7096 DD E1        	pop		ix
 534+ 7098 DD 23        	inc		ix
 535+ 709A DD 23        	inc		ix
 536+ 709C
 537+ 709C              	;Send block buffer
 538+ 709C 21 C6 8D     	ld		hl, CopyDiskBuf
 539+ 709F 01 00 08     	ld		bc, AU_SZ
 540+ 70A2 CD A9 7B     	call	SERTB
 541+ 70A5
 542+ 70A5 ED 4B DC 87  	ld		bc, (UsedBlockListCnt)
 543+ 70A9 0B           	dec		bc
 544+ 70AA ED 43 DC 87  	ld		(UsedBlockListCnt), bc
 545+ 70AE
 546+ 70AE DD E5        	push	ix
 547+ 70B0 CD D6 76     		call	KbdHit
 548+ 70B3 DD E1        	pop		ix
 549+ 70B5 D8           	ret		c
 550+ 70B6
 551+ 70B6 78           	ld		a, b
 552+ 70B7 B1           	or		c
 553+ 70B8 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 70BA
 555+ 70BA C9           	ret
 556+ 70BB
 557+ 70BB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 70BB              CopyDiskFromCOM:
 559+ 70BB              	;Receive block count.
 560+ 70BB 21 DC 87     	ld		hl, UsedBlockListCnt
 561+ 70BE 01 02 00     	ld		bc, 2
 562+ 70C1 1E 00        	ld		e, 0
 563+ 70C3 CD 76 7B     	call	SERRB
 564+ 70C6
 565+ 70C6              	;Receive block indexes.
 566+ 70C6 2A DC 87     	ld		hl, (UsedBlockListCnt)
 567+ 70C9 29           	add		hl, hl
 568+ 70CA 44           	ld		b, h
 569+ 70CB 4D           	ld		c, l
 570+ 70CC 21 DE 87     	ld		hl, UsedBlockListBlk
 571+ 70CF 1E 00        	ld		e, 0
 572+ 70D1 CD 76 7B     	call	SERRB
 573+ 70D4
 574+ 70D4              	;Read each block by index and write to disk
 575+ 70D4 DD 21 DE 87  	ld		ix, UsedBlockListBlk
 576+ 70D8
 577+ 70D8              CopyDiskFromCOMLoop:
 578+ 70D8              	;Print block count left
 579+ 70D8 2A DC 87     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 70DB 11 F3 7E     	ld		de, MsgBlocksLeft
 581+ 70DE CD 40 6E     	call	Byte2Txt
 582+ 70E1 21 F3 7E     	ld		hl, MsgBlocksLeft
 583+ 70E4 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 70E7 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 70E9 CD 37 77     	call	PrintStrClr
 586+ 70EC
 587+ 70EC              	;Read block buffer
 588+ 70EC 21 C6 8D     	ld		hl, CopyDiskBuf
 589+ 70EF 01 00 08     	ld		bc, AU_SZ
 590+ 70F2 1E 00        	ld		e, 0
 591+ 70F4 CD 76 7B     	call	SERRB
 592+ 70F7
 593+ 70F7              	;Write block to disk
 594+ 70F7 DD 6E 00     	ld		l, (ix)
 595+ 70FA DD 66 01     	ld		h, (ix+1)
 596+ 70FD 11 C6 8D     	ld		de, CopyDiskBuf
 597+ 7100 DD E5        	push	ix
 598+ 7102 CD 99 6F     		call	WriteFSBlock			;Stop on error or continue?
 599+ 7105 DD E1        	pop		ix
 600+ 7107 DD 23        	inc		ix
 601+ 7109 DD 23        	inc		ix
 602+ 710B
 603+ 710B ED 4B DC 87  	ld		bc, (UsedBlockListCnt)
 604+ 710F 0B           	dec		bc
 605+ 7110 ED 43 DC 87  	ld		(UsedBlockListCnt), bc
 606+ 7114
 607+ 7114 DD E5        	push	ix
 608+ 7116 CD D6 76     		call	KbdHit
 609+ 7119 DD E1        	pop		ix
 610+ 711B D8           	ret		c
 611+ 711C
 612+ 711C 78           	ld		a, b
 613+ 711D B1           	or		c
 614+ 711E 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 7120 C9           	ret
 616+ 7121
 617+ 7121              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 7121
 619+ 7121              ;Compare string at HL with the one at DE, max length B
 620+ 7121              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 7121              ;OUT: z flag, set = match, reset = mismatch
 622+ 7121              StrCmp:
 623+ 7121 E5           	push hl
 624+ 7122 D5           	push de
 625+ 7123              Compare:
 626+ 7123 1A           		ld a, (de)
 627+ 7124 BE           		cp (hl)
 628+ 7125 20 04        		jr nz, MisMatch
 629+ 7127 23           		inc hl
 630+ 7128 13           		inc de
 631+ 7129 10 F8        		djnz Compare
 632+ 712B              MisMatch:
 633+ 712B D1           	pop de
 634+ 712C E1           	pop hl
 635+ 712D C9           	ret
 636+ 712E
 637+ 712E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 712E
 639+ 712E              ;Read a file into a buffer, sector by sector.
 640+ 712E              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 712E              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 712E              ;In: HL = Name address, DE = buffer
 643+ 712E              IF1FileLoad:
 644+ 712E D5           	push	de
 645+ 712F 22 DC 5C     		ld (FSTR1), hl
 646+ 7132 26 00        		ld h, 0
 647+ 7134 3A 69 72     		ld a, (RWTSDrive)
 648+ 7137 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 7138 6F           		ld	l, a
 650+ 7139 22 D6 5C     		ld (DSTR1), hl
 651+ 713C 2E 0B        		ld l,NAMELEN
 652+ 713E 22 DA 5C     		ld (NSTR1), hl
 653+ 7141 CF           		rst 08
 654+ 7142 33           		DEFB 51			;open disk channel
 655+ 7143
 656+ 7143 CF           		rst		8
 657+ 7144 35           		defb	53		;read sector
 658+ 7145 D1           	pop		de
 659+ 7146 30 27        	jr		nc, FileFree
 660+ 7148
 661+ 7148 DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 714B FE 04        	cp		TEXT_TYPE
 663+ 714D 30 12        	jr		nc, FileLoadNoHeader
 664+ 714F
 665+ 714F              FileLoadHeader:
 666+ 714F DD E5        	push	ix
 667+ 7151 E1           	pop		hl
 668+ 7152 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 7155 09           	add		hl, bc
 670+ 7156 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 7159 ED B0        	ldir
 672+ 715B
 673+ 715B              FileReadLoop:
 674+ 715B D5           	push	de
 675+ 715C CF           		rst		8
 676+ 715D 35           		defb	53		;read sector
 677+ 715E D1           	pop		de
 678+ 715F 30 0E        	jr		nc, FileFree
 679+ 7161
 680+ 7161              FileLoadNoHeader:
 681+ 7161 DD E5        	push	ix
 682+ 7163 E1           	pop		hl
 683+ 7164 01 32 00     	ld		bc, CH_DATA
 684+ 7167 09           	add		hl, bc
 685+ 7168 01 00 01     	ld		bc, SECT_SZ
 686+ 716B ED B0        	ldir
 687+ 716D 18 EC        	jr		FileReadLoop
 688+ 716F
 689+ 716F              FileFree:
 690+ 716F D5           	push	de
 691+ 7170 CF           	rst		8
 692+ 7171 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 7172 D1           	pop		de
 694+ 7173 C9           	ret
 695+ 7174              IF1FileLoadEnd:
 696+ 7174
 697+ 7174              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 7174              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 7174              ;Out: A = error code, 0=OK
 700+ 7174              ReadDiskSectors:
 701+ 7174 C5           	push bc
 702+ 7175 E5           		push hl
 703+ 7176 D5           			push de
 704+ 7177 CD BF 6E     				call ReadOneDiskSector
 705+ 717A D1           			pop de
 706+ 717B E1           		pop hl
 707+ 717C
 708+ 717C 14           		inc d
 709+ 717D 24           		inc h
 710+ 717E C1           	pop bc
 711+ 717F
 712+ 717F 3A 74 72     	ld	a, (RWTSRes)
 713+ 7182 B7           	or	a
 714+ 7183 C0           	ret nz
 715+ 7184
 716+ 7184 10 EE        	djnz ReadDiskSectors
 717+ 7186 C9           	ret
 718+ 7187
 719+ 7187              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 7187              ;Out: A = error code, 0=OK
 721+ 7187              WriteDiskSectors:
 722+ 7187 C5           	push bc
 723+ 7188 E5           		push hl
 724+ 7189 D5           			push de
 725+ 718A CD CA 6E     				call WriteOneDiskSector
 726+ 718D D1           			pop de
 727+ 718E E1           		pop hl
 728+ 718F
 729+ 718F 14           		inc d
 730+ 7190 24           		inc h
 731+ 7191 C1           	pop bc
 732+ 7192
 733+ 7192 3A 74 72     	ld	a, (RWTSRes)
 734+ 7195 B7           	or	a
 735+ 7196 C0           	ret nz
 736+ 7197
 737+ 7197 10 EE        	djnz WriteDiskSectors
 738+ 7199 C9           	ret
 739+ 719A
 740+ 719A
 741+ 719A              ;Reads disk catalog
 742+ 719A              ReadCatalogTrack:
 743+ 719A 21 C6 8D     	ld hl, TrackBuf
 744+ 719D 11 00 00     	ld de, 0
 745+ 71A0 06 10        	ld b, SPT
 746+ 71A2
 747+ 71A2 CD 74 71     	call ReadDiskSectors
 748+ 71A5 C9           	ret
 749+ 71A6
 750+ 71A6              ;A = track
 751+ 71A6              SeekTrack:
 752+ 71A6              	IFUSED
 753+ 71A6 ~            	ld	(RWTSTrack), a
 754+ 71A6 ~            	ld 	a, RWTS_CMD_SEEK
 755+ 71A6 ~            	jp	RWTS
 756+ 71A6              	ENDIF
 757+ 71A6
 758+ 71A6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759+ 71A6
 760+ 71A6              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761+ 71A6              FindCache:
 762+ 71A6 06 0B        	ld		b, NAMELEN
 763+ 71A8 CD 21 71     	call	StrCmp			;find the file to wich this extension belongs
 764+ 71AB C8           	ret		z
 765+ 71AC
 766+ 71AC 0D           	dec		c
 767+ 71AD 20 02        	jr		nz, CacheNotFinished
 768+ 71AF B1           	or		c
 769+ 71B0 C9           	ret
 770+ 71B1
 771+ 71B1              CacheNotFinished:
 772+ 71B1 01 19 00     	ld		bc, CACHE_SZ
 773+ 71B4 09           	add		hl, bc			;to the next cache line
 774+ 71B5 18 EF        	jr		FindCache
 775+ 71B7
 776+ 71B7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777+ 71B7
 778+ 71B7              	;ld		ix, (SelFileCache)
 779+ 71B7              ReadFileHeader:
 780+ 71B7 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 781+ 71BA B7           	or		a
 782+ 71BB C0           	ret		nz				;return if already read
 783+ 71BC
 784+ 71BC DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 785+ 71BF DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 786+ 71C2 7C           	ld		a, h
 787+ 71C3 B5           	or		l
 788+ 71C4 28 46        	jr		z, ReadHeaderEnd
 789+ 71C6
 790+ 71C6 CD E6 6E     	call	AU2TS
 791+ 71C9 50           	ld		d, b
 792+ 71CA 59           	ld		e, c
 793+ 71CB 21 C6 8D     	ld		hl, DataBuf
 794+ 71CE DD E5        	push	ix
 795+ 71D0 DD E5        	push	ix
 796+ 71D2 CD BF 6E     		call	ReadOneDiskSector
 797+ 71D5 E1           	pop		hl
 798+ 71D6 DD E1        	pop		ix
 799+ 71D8
 800+ 71D8 E5           	push	hl
 801+ 71D9 21 C6 8D     		ld		hl, DataBuf
 802+ 71DC CD 10 72     		call	IsFileHeaderValid
 803+ 71DF E1           	pop		hl
 804+ 71E0 B7           	or		a
 805+ 71E1 28 14        	jr		z, ReadFileHeaderIsTextFile
 806+ 71E3
 807+ 71E3 01 10 00     	ld		bc, CACHE_HDR
 808+ 71E6 09           	add		hl, bc
 809+ 71E7 EB           	ex		hl, de
 810+ 71E8 21 C6 8D     	ld		hl, DataBuf
 811+ 71EB 01 09 00     	ld		bc, HDR_SZ
 812+ 71EE ED B0        	ldir
 813+ 71F0
 814+ 71F0              	;For text files, read file size as reported by BDOS, since we don't have a header.
 815+ 71F0 3E 03        	ld		a, BYTE_TYPE
 816+ 71F2 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 817+ 71F5 30 15        	jr		nc, ReadHeaderEnd
 818+ 71F7
 819+ 71F7              ReadFileHeaderIsTextFile:
 820+ 71F7 DD E5        	push	ix
 821+ 71F9 DD E5        	push	ix
 822+ 71FB E1           	pop		hl
 823+ 71FC CD DF 72     		call	GetFileSize
 824+ 71FF DD E1        	pop		ix
 825+ 7201 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 826+ 7204 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827+ 7207 3E 04        	ld		a, TEXT_TYPE
 828+ 7209 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829+ 720C
 830+ 720C              ReadHeaderEnd:
 831+ 720C DD 34 0F     	inc		(ix + CACHE_FLAG)
 832+ 720F C9           	ret
 833+ 7210
 834+ 7210              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835+ 7210              ;Checks if the file header is valid. For now it checks to not have all 0s.
 836+ 7210              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837+ 7210              ;In: HL = header
 838+ 7210              ;Out: A > 0 if valid
 839+ 7210              IsFileHeaderValid:
 840+ 7210              	IFUSED
 841+ 7210 AF           	xor		a
 842+ 7211 06 09        	ld		b, HDR_SZ
 843+ 7213              IsFileHeaderValidLoop:
 844+ 7213 B6           	or		(hl)
 845+ 7214 23           	inc		hl
 846+ 7215 10 FC        	djnz	IsFileHeaderValidLoop
 847+ 7217
 848+ 7217 C9           	ret
 849+ 7218              	ENDIF
 850+ 7218
 851+ 7218              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852+ 7218
 853+ 7218              ;IN: HL = address from IF1 to call
 854+ 7218              IF1Call:
 855+ 7218 22 ED 5C     	LD   (HD11), HL
 856+ 721B CF           	RST  8
 857+ 721C 32           	DEFB 50
 858+ 721D C9           	RET
 859+ 721E
 860+ 721E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861+ 721E
 862+ 721E              ;Load a program from disk
 863+ 721E              ;IN: HL = file name addr
 864+ 721E              LoadProgram:
 865+ 721E 22 DC 5C     	LD   (FSTR1), HL
 866+ 7221 26 00        	LD   H, 0
 867+ 7223 2E 0B        	LD   L, NAMELEN
 868+ 7225 22 DA 5C     	LD   (NSTR1), HL
 869+ 7228 3A 69 72     	LD	 A, (RWTSDrive)
 870+ 722B 3C           	INC  A					;Adapt for BASIC drive number
 871+ 722C 6F           	LD   L, A
 872+ 722D 22 D6 5C     	LD   (DSTR1), HL
 873+ 7230 21 41 0A     	LD   HL, LOAD_ADDR
 874+ 7233 CD 18 72     	CALL IF1Call
 875+ 7236 C9           	RET
 876+ 7237
 877+ 7237              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878+ 7237
 879+ 7237              SetFastKeys:
 880+ 7237 21 09 5C     	ld		hl, REPDEL
 881+ 723A              	;ld		de, (1 << 8) | 15
 882+ 723A 11 0A 01     	ld		de, (1 << 8) | 10
 883+ 723D 73 23 72 2B  	ld		(hl), de
 884+ 7241
 885+ 7241 C9           	ret
 886+ 7242
 887+ 7242
 888+ 7242              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889+ 7242              ;Reads the error message string from IF1 ROM.
 890+ 7242              GetErrMsg:
 891+ 7242 3C           	inc		a
 892+ 7243 08           	ex		af, af'
 893+ 7244
 894+ 7244 21 4A 72     	ld		hl, IF1Paged			;page-in IF1
 895+ 7247 C3 18 72     	jp		IF1Call
 896+ 724A
 897+ 724A              IF1Paged:
 898+ 724A 21 60 02     	ld		hl, ERRMSG
 899+ 724D 08           	ex		af, af'
 900+ 724E B7           	or		a
 901+ 724F 28 0B        	jr		z, SaveMsg
 902+ 7251
 903+ 7251 06 00        	ld		b, 0
 904+ 7253              SearchMsgEnd:
 905+ 7253 CB 7E        	bit		7, (hl)
 906+ 7255 23           	inc		hl
 907+ 7256 28 FB        	jr		z, SearchMsgEnd
 908+ 7258
 909+ 7258 04           	inc		b
 910+ 7259 B8           	cp		b
 911+ 725A 20 F7        	jr		nz, SearchMsgEnd
 912+ 725C
 913+ 725C              SaveMsg:
 914+ 725C 11 C6 8D     	ld		de, DataBuf
 915+ 725F              CopyMsg:
 916+ 725F 7E           	ld		a, (hl)
 917+ 7260 CB 7F        	bit		7, a
 918+ 7262 12           	ld		(de), a
 919+ 7263 23           	inc		hl
 920+ 7264 13           	inc		de
 921+ 7265 28 F8        	jr		z, CopyMsg
 922+ 7267
 923+ 7267 C9           	ret
 924+ 7268
 925+ 7268              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926+ 7268
 927+ 7268              ;RWTS routine I/O block
 928+ 7268              RWTSParams:
 929+ 7268 01           RWTSBlockType	DEFB	1							;?
 930+ 7269 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931+ 726A 00           RWTSVolNo		DEFB	0							;?
 932+ 726B 00           RWTSTrack		DEFB	0
 933+ 726C 00           RWTSSector		DEFB	0
 934+ 726D 00 00        RWTSDMA			DEFW	0
 935+ 726F 32 29        RWTSExtBuf		DEFW	$2932
 936+ 7271              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937+ 7271              	IFDEF _REAL_HW_
 938+ 7271 7B 72        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939+ 7273              	ELSE
 940+ 7273 ~            RWTSPrmTbl		DEFW	$1f2a
 941+ 7273              	ENDIF
 942+ 7273 01           RWTSCmd			DEFB	RWTS_CMD_READ
 943+ 7274              ;Results
 944+ 7274 00           RWTSRes			DEFB	0
 945+ 7275 00           RWTSResVolNo	DEFB	0
 946+ 7276 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 946+ 727A 00
 947+ 727B
 948+ 727B              ;Param. table, usualy found in ROM.
 949+ 727B              	IFDEF _REAL_HW_
 950+ 727B              BasPrmTbl:
 951+ 727B
 952+ 727B              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953+ 727B              	;DEFINE _STANDARD_DRIVE_PARAM_
 954+ 727B              	IFDEF _STANDARD_DRIVE_PARAM_
 955+ 727B ~            PrmDevType		DEFB	$01
 956+ 727B ~            PrmStepRate		DEFB	$0D		;(milisec)
 957+ 727B ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958+ 727B ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959+ 727B              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960+ 727B              PrmFastFactor	EQU		4
 961+ 727B 01           PrmDevType		DEFB	$01
 962+ 727C 03           PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963+ 727D 08           PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964+ 727E 19           PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965+ 727F              	ENDIF
 966+ 727F
 967+ 727F 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968+ 7281              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969+ 7281              	ENDIF
 970+ 7281
 971+ 7281              	endif
# file closed: if1.asm
1362  7281              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7281              ;BDOS functions - similar to CP/M
   2+ 7281
   3+ 7281              	IFNDEF	_BDOS_
   4+ 7281              	DEFINE	_BDOS_
   5+ 7281
   6+ 7281              	include "if1.asm"
# file opened: if1.asm
   1++7281              ;HC IF1 routines and constants
   2++7281
   3++7281              ;IF1 routines error codes, also returned by BASIC commands
   4++7281              ;12 = Writing to a 'read' file
   5++7281              ;13 = Reading a 'write' file
   6++7281              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7281              ;15 = Disk full (disk or catalog full)
   8++7281              ;16 = Disk error (hardware error)
   9++7281              ;17 = File not found
  10++7281              ;23 = Disk R/O (disk change detected, software R/O)
  11++7281              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7281
  13++7281              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7281              ;00h = OK
  15++7281              ;08h = cannot format disk
  16++7281              ;10h = disk protected (read-only?)
  17++7281              ;20h = volume error
  18++7281              ;40h = drive error
  19++7281              ;80h = reading error
  20++7281              ;Codes I encountered:
  21++7281              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7281
  23++7281
  24++7281              	ifndef	_DISK_
  25++7281 ~            	define	_DISK_
  26++7281 ~
  27++7281 ~            	include	"math.asm"
  28++7281 ~
  29++7281 ~            DRIVE_CUR_BAS	EQU 0
  30++7281 ~            DRIVE_A_BAS		EQU	1
  31++7281 ~            DRIVE_B_BAS		EQU	2
  32++7281 ~            DRIVE_A_CPM		EQU	0
  33++7281 ~            DRIVE_B_CPM		EQU	1
  34++7281 ~            ;Disk geometry stuff
  35++7281 ~            SPT				EQU	16			;sectors per track
  36++7281 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7281 ~            TRACK_CNT		EQU	80			;track count
  38++7281 ~            HEAD_CNT		EQU	2			;disk face count
  39++7281 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7281 ~            EXT_SZ			EQU	32			;directory entry size
  41++7281 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7281 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7281 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7281 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7281 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7281 ~            REC_SZ			EQU 128			;cp/m record size
  47++7281 ~            DEL_MARKER		EQU	$E5
  48++7281 ~
  49++7281 ~
  50++7281 ~            ;Extension structure (directory entry)
  51++7281 ~            EXT_DEL_FLAG	EQU	0
  52++7281 ~            EXT_NAME		EQU 1
  53++7281 ~            EXT_IDX			EQU 12
  54++7281 ~            EXT_S1			EQU 13
  55++7281 ~            EXT_S2			EQU 14
  56++7281 ~            EXT_RC			EQU	15
  57++7281 ~            EXT_AU0			EQU	16
  58++7281 ~            EXT_AU1			EQU	18
  59++7281 ~            EXT_AU2			EQU	20
  60++7281 ~            EXT_AU3			EQU	22
  61++7281 ~            EXT_AU4			EQU	24
  62++7281 ~            EXT_AU5			EQU	26
  63++7281 ~            EXT_AU6			EQU	28
  64++7281 ~            EXT_AU7			EQU	30
  65++7281 ~            EXT_SIZE		EQU 32
  66++7281 ~
  67++7281 ~            ;FCB structure
  68++7281 ~            FCB_DRIVE		EQU 0
  69++7281 ~            FCB_NAME		EQU EXT_NAME
  70++7281 ~            FCB_EX_IDX		EQU EXT_IDX
  71++7281 ~            FCB_S1			EQU EXT_S1
  72++7281 ~            FCB_S2			EQU EXT_S2
  73++7281 ~            FCB_RC			EQU	EXT_RC
  74++7281 ~            FCB_AU			EQU	EXT_AU0
  75++7281 ~            FCB_CR			EQU	32
  76++7281 ~            FCB_R0			EQU 33
  77++7281 ~            FCB_R1			EQU 34
  78++7281 ~            FCB_R2			EQU 35
  79++7281 ~            FCB_SIZE		EQU 36
  80++7281 ~
  81++7281 ~
  82++7281 ~
  83++7281 ~            ;System variables for disk
  84++7281 ~            DSTR1			EQU	$5CD6		;drive
  85++7281 ~            FSTR1			EQU	$5CDC		;file name
  86++7281 ~            NSTR1			EQU	$5CDA		;name length
  87++7281 ~            HD11			EQU	$5CED		;BDOS argument
  88++7281 ~            COPIES			EQU	$5CEF		;BDOS function
  89++7281 ~
  90++7281 ~            ERRSP			EQU $5C3D
  91++7281 ~            ERRNR			EQU $5C3A
  92++7281 ~            ERRMSG			EQU	$0260
  93++7281 ~
  94++7281 ~            PROG			EQU $5C53
  95++7281 ~            VARS			EQU	$5C4B
  96++7281 ~            STKEND			EQU	$5C65
  97++7281 ~
  98++7281 ~            PRN_BUF			EQU	23296
  99++7281 ~
 100++7281 ~            REPDEL			EQU	23561
 101++7281 ~            REPPER			EQU	23562
 102++7281 ~            PIP				EQU	23609
 103++7281 ~
 104++7281 ~
 105++7281 ~            ;RWTS routine commands
 106++7281 ~            RWTS_CMD_SEEK	EQU	0			;position head
 107++7281 ~            RWTS_CMD_READ	EQU	1			;read sector
 108++7281 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++7281 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++7281 ~
 111++7281 ~
 112++7281 ~            ;File name stuff
 113++7281 ~            NAMELEN			EQU	11			;name length
 114++7281 ~            RO_POS			EQU	8			;read-only attribute position in name
 115++7281 ~            SYS_POS			EQU	9			;system attribute position in name
 116++7281 ~
 117++7281 ~            ;File types (first byte in header)
 118++7281 ~            PROG_TYPE		EQU	0			;program
 119++7281 ~            NUMB_TYPE		EQU	1			;number array
 120++7281 ~            CHAR_TYPE		EQU	2			;char array
 121++7281 ~            BYTE_TYPE		EQU	3			;bytes
 122++7281 ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++7281 ~
 124++7281 ~            ;File header offsets
 125++7281 ~            HDR_TYPE		EQU	0
 126++7281 ~            HDR_LEN			EQU 1
 127++7281 ~            HDR_ADDR		EQU 3
 128++7281 ~            HDR_PLEN		EQU	5
 129++7281 ~            HDR_LINE		EQU 7
 130++7281 ~            HDR_SZ			EQU	9
 131++7281 ~
 132++7281 ~            ;BASIC disk channel structure
 133++7281 ~            CH_RW_FLAG		EQU 11
 134++7281 ~            CH_FCB			EQU	12
 135++7281 ~            CH_DATA			EQU	50
 136++7281 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++7281 ~
 138++7281 ~            CACHE_NAME		EQU	0					;11B
 139++7281 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++7281 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++7281 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++7281 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++7281 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++7281 ~
 145++7281 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++7281 ~
 147++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++7281 ~            IF1Init:
 149++7281 ~            	rst		08
 150++7281 ~            	defb	49		;create system variables
 151++7281 ~            	ret
 152++7281 ~
 153++7281 ~            ;ReadWriteTrackSector
 154++7281 ~            ;A=command: 0, 1, 2, 4
 155++7281 ~            RWTS:
 156++7281 ~            	ld (RWTSCmd), a
 157++7281 ~            	ld hl, RWTSParams
 158++7281 ~            	ld (HD11), hl
 159++7281 ~            	rst 08
 160++7281 ~            	DEFB 58
 161++7281 ~            	ret
 162++7281 ~
 163++7281 ~
 164++7281 ~            ;D = sector, E = track
 165++7281 ~            ;HL = dma
 166++7281 ~            ReadOneDiskSector:
 167++7281 ~            	ld (RWTSDMA), hl
 168++7281 ~            	ld (RWTSTrack), de
 169++7281 ~            	;ld (RWTSDrive), a
 170++7281 ~            	ld a, RWTS_CMD_READ
 171++7281 ~            	jr	RWTS
 172++7281 ~
 173++7281 ~            ;D = sector, E = track
 174++7281 ~            ;HL = dma
 175++7281 ~            WriteOneDiskSector:
 176++7281 ~            	ld (RWTSDMA), hl
 177++7281 ~            	ld (RWTSTrack), de
 178++7281 ~            	;ld (RWTSDrive), a
 179++7281 ~            	ld a, RWTS_CMD_WRITE
 180++7281 ~            	jr	RWTS
 181++7281 ~
 182++7281 ~            FormatDisk:
 183++7281 ~            	ld		hl, DataBuf
 184++7281 ~            	ld		(hl), DEL_MARKER
 185++7281 ~            	ld 		(RWTSDMA), hl
 186++7281 ~            	ld 		a, RWTS_CMD_FMT
 187++7281 ~            	call	RWTS
 188++7281 ~            	ld		a, (RWTSRes)
 189++7281 ~            	ret
 190++7281 ~
 191++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++7281 ~
 193++7281 ~            ;Allocation unit no. to track/sector
 194++7281 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++7281 ~            ;IN:  HL=alloc. unit no.
 196++7281 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++7281 ~            AU2TS:
 198++7281 ~            	ld c, SPT/SPAL
 199++7281 ~            	call Div					;A = sector
 200++7281 ~            	push af
 201++7281 ~            		/*
 202++7281 ~            		ld c, HEAD_CNT
 203++7281 ~            		call Div				;L = track, A = head (0 or 1)
 204++7281 ~            		*/
 205++7281 ~            		xor a
 206++7281 ~            		rr h
 207++7281 ~            		rr l
 208++7281 ~            		rr a
 209++7281 ~
 210++7281 ~            		ld c, l
 211++7281 ~            		ld b, 0
 212++7281 ~            		or a
 213++7281 ~            		jr z, Track0
 214++7281 ~            		ld b, SPT
 215++7281 ~            Track0:
 216++7281 ~            	pop af
 217++7281 ~            	or a
 218++7281 ~            	jr z, FirstAU
 219++7281 ~            	ld a, SPAL
 220++7281 ~            FirstAU:
 221++7281 ~            	add a, b
 222++7281 ~            	ld  b, a
 223++7281 ~            	ret
 224++7281 ~
 225++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++7281 ~
 227++7281 ~            ;Checks the allocation units number used in extension
 228++7281 ~            ;IN:	IX = extension addr
 229++7281 ~            ;OUT:	B = no. of allocation units used
 230++7281 ~            ;		C = no. of records used in ext.
 231++7281 ~            ;		HL = first alloc. unit no.
 232++7281 ~            ;		DE = last alloc. unit no.
 233++7281 ~            CheckExtAlloc:
 234++7281 ~            	push ix
 235++7281 ~            		ld bc, EXT_RC
 236++7281 ~            		add ix, bc
 237++7281 ~            		ld c, (ix)			;save rec. no.
 238++7281 ~            		inc ix
 239++7281 ~            		ld l, (ix)
 240++7281 ~            		ld h, (ix + 1)
 241++7281 ~            		ld b, EXT_AU_CNT
 242++7281 ~            CheckAU:
 243++7281 ~            		ld a, (ix)
 244++7281 ~            		or (ix + 1)
 245++7281 ~            		jr z, CheckAUEnd
 246++7281 ~            		ld e, (ix)
 247++7281 ~            		ld d, (ix + 1)
 248++7281 ~            		inc ix
 249++7281 ~            		inc ix
 250++7281 ~            		djnz CheckAU
 251++7281 ~            CheckAUEnd:
 252++7281 ~            		ld a, EXT_AU_CNT
 253++7281 ~            		sub b
 254++7281 ~            		ld b, a
 255++7281 ~            	pop ix
 256++7281 ~            	ret
 257++7281 ~
 258++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++7281 ~
 260++7281 ~            ;Input: TrackBuffer
 261++7281 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++7281 ~            ReadUsedBlocksList:
 263++7281 ~            	ld		ix, TrackBuf			;source buffer
 264++7281 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++7281 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 266++7281 ~            	ld		de, 2					;counter of used blocks, start with 2
 267++7281 ~            	ld		(hl), e
 268++7281 ~            	inc		hl
 269++7281 ~            	ld		(hl), d
 270++7281 ~            	inc		hl
 271++7281 ~
 272++7281 ~            	;Add blocks 0 and 1 for directory
 273++7281 ~            	ld		de, 0
 274++7281 ~            	ld		(hl), e
 275++7281 ~            	inc		hl
 276++7281 ~            	ld		(hl), d
 277++7281 ~            	inc		hl
 278++7281 ~
 279++7281 ~            	inc		de
 280++7281 ~            	ld		(hl), e
 281++7281 ~            	inc		hl
 282++7281 ~            	ld		(hl), d
 283++7281 ~            	inc		hl
 284++7281 ~
 285++7281 ~            ReadUsedBlocksLoop:
 286++7281 ~            	xor		a
 287++7281 ~            	cp		(ix)
 288++7281 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++7281 ~
 290++7281 ~            	push	ix
 291++7281 ~            	push	bc
 292++7281 ~            		ld		b, EXT_AU_CNT
 293++7281 ~            		ld		de, EXT_AU0
 294++7281 ~            		add		ix, de
 295++7281 ~
 296++7281 ~            ReadUsedBlocksLoop2:
 297++7281 ~            		ld		e, (ix)
 298++7281 ~            		ld		d, (ix+1)
 299++7281 ~            		ld		a, e
 300++7281 ~            		or		d
 301++7281 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++7281 ~
 303++7281 ~            		ld		(hl), e
 304++7281 ~            		inc		hl
 305++7281 ~            		ld		(hl), d
 306++7281 ~            		inc		hl
 307++7281 ~
 308++7281 ~            		inc		ix
 309++7281 ~            		inc		ix
 310++7281 ~
 311++7281 ~            		ld		de, (UsedBlockListCnt)
 312++7281 ~            		inc		de
 313++7281 ~            		ld		(UsedBlockListCnt), de
 314++7281 ~
 315++7281 ~            		djnz	ReadUsedBlocksLoop2
 316++7281 ~
 317++7281 ~
 318++7281 ~            ReadUsedBlocksSkip:
 319++7281 ~            	pop		bc
 320++7281 ~            	pop		ix
 321++7281 ~            ReadUsedBlocksSkip2:
 322++7281 ~            	ld		de, EXT_SZ
 323++7281 ~            	add		ix, de
 324++7281 ~
 325++7281 ~            	dec		bc
 326++7281 ~            	ld		a, b
 327++7281 ~            	or		c
 328++7281 ~            	jr		nz, ReadUsedBlocksLoop
 329++7281 ~
 330++7281 ~            	ret
 331++7281 ~
 332++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++7281 ~            ;Reads 8 sectors for an AU
 334++7281 ~            ;HL = block number, DE = destination buffer
 335++7281 ~            ReadFSBlock:
 336++7281 ~            	push	de
 337++7281 ~            		call	AU2TS		;B=sector, C=track
 338++7281 ~            	pop		hl				;HL=dest
 339++7281 ~
 340++7281 ~            	ld		d, b
 341++7281 ~            	ld		e, c
 342++7281 ~            	ld		b, SPAL
 343++7281 ~
 344++7281 ~            	call	ReadDiskSectors
 345++7281 ~            	ret
 346++7281 ~
 347++7281 ~
 348++7281 ~            ;Write 8 sectors for an AU
 349++7281 ~            ;HL = block number, DE = source buffer
 350++7281 ~            WriteFSBlock:
 351++7281 ~            	push	de
 352++7281 ~            		call	AU2TS		;B=sector, C=track
 353++7281 ~            	pop		hl				;HL=dest
 354++7281 ~
 355++7281 ~            	ld		d, b
 356++7281 ~            	ld		e, c
 357++7281 ~            	ld		b, SPAL
 358++7281 ~
 359++7281 ~            	call	WriteDiskSectors
 360++7281 ~            	ret
 361++7281 ~
 362++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++7281 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++7281 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++7281 ~            CopyDisk:
 366++7281 ~            	;Get list of used blocks in current disk, max 632 bytes
 367++7281 ~            	call	ReadUsedBlocksList
 368++7281 ~            	ld		ix, UsedBlockListBlk
 369++7281 ~
 370++7281 ~            CopyDiskLoop:
 371++7281 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++7281 ~            	ld		de, MsgBlocksLeft
 373++7281 ~            	call	Byte2Txt
 374++7281 ~            	ld		hl, MsgBlocksLeft
 375++7281 ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++7281 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++7281 ~            	call	PrintStrClr
 378++7281 ~
 379++7281 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++7281 ~            	ld		hl, MAX_AU_RAM
 381++7281 ~            	ld		bc, (UsedBlockListCnt)
 382++7281 ~            	or		a
 383++7281 ~            	sbc		hl, bc
 384++7281 ~            	jr		nc, CopyDiskLoopRead
 385++7281 ~            	ld		bc, MAX_AU_RAM
 386++7281 ~
 387++7281 ~            CopyDiskLoopRead:
 388++7281 ~            	ld		b, c
 389++7281 ~            	ld		de, CopyDiskBuf
 390++7281 ~            	;save initial counter and initial block number array position
 391++7281 ~            	push	bc
 392++7281 ~            	push	ix
 393++7281 ~
 394++7281 ~            CopyDiskLoopReadLoop:
 395++7281 ~            		ld		l, (ix)
 396++7281 ~            		ld		h, (ix+1)
 397++7281 ~            		inc		ix
 398++7281 ~            		inc		ix
 399++7281 ~
 400++7281 ~            		push	de
 401++7281 ~            		push	bc
 402++7281 ~            			call	ReadFSBlock			;Stop on error or continue?
 403++7281 ~            		pop		bc
 404++7281 ~            		pop		de
 405++7281 ~
 406++7281 ~            		;+2048
 407++7281 ~            		ld		a, d
 408++7281 ~            		add		8
 409++7281 ~            		ld		d, a
 410++7281 ~
 411++7281 ~            		djnz	CopyDiskLoopReadLoop
 412++7281 ~
 413++7281 ~            		;Check if selection is 1=single drive or 2=dual drive
 414++7281 ~            		ld		a, (CopySelOption)
 415++7281 ~            		cp		'1'
 416++7281 ~            		jr		nz, CopyDiskDualDrive1
 417++7281 ~
 418++7281 ~            		;Prompt for disk change
 419++7281 ~            		call	PromptDiskChangeDst
 420++7281 ~            		ld		a, (RWTSDrive)
 421++7281 ~            		call	BDOSInit
 422++7281 ~            		jr		CopyDiskReadEnd
 423++7281 ~
 424++7281 ~            CopyDiskDualDrive1:
 425++7281 ~            		;alternate drive
 426++7281 ~            		ld		a, (RWTSDrive)
 427++7281 ~            		inc 	a
 428++7281 ~            		xor		%11
 429++7281 ~            		dec		a
 430++7281 ~            		ld		(RWTSDrive), a
 431++7281 ~
 432++7281 ~            CopyDiskReadEnd:
 433++7281 ~            	;restore initial counter and initial block number array position
 434++7281 ~            	pop		ix
 435++7281 ~            	pop		bc
 436++7281 ~            	ld		de, CopyDiskBuf
 437++7281 ~            	push	bc
 438++7281 ~
 439++7281 ~            CopyDiskLoopWriteLoop:
 440++7281 ~            		ld		l, (ix)
 441++7281 ~            		ld		h, (ix+1)
 442++7281 ~            		inc		ix
 443++7281 ~            		inc		ix
 444++7281 ~
 445++7281 ~            		push	de
 446++7281 ~            		push	bc
 447++7281 ~            			call	WriteFSBlock		;Stop on error or continue?
 448++7281 ~            		pop		bc
 449++7281 ~            		pop		de
 450++7281 ~
 451++7281 ~            		;+2048
 452++7281 ~            		ld		a, d
 453++7281 ~            		add		8
 454++7281 ~            		ld		d, a
 455++7281 ~
 456++7281 ~            		djnz	CopyDiskLoopWriteLoop
 457++7281 ~
 458++7281 ~            CopyDiskWriteEnd:
 459++7281 ~            	pop		bc
 460++7281 ~            	ld		c, b
 461++7281 ~            	ld		b, 0
 462++7281 ~
 463++7281 ~            	;Decrease number of blocks read by now.
 464++7281 ~            	ld		hl, (UsedBlockListCnt)
 465++7281 ~            	or		a
 466++7281 ~            	sbc		hl, bc
 467++7281 ~            	ld		(UsedBlockListCnt), hl
 468++7281 ~
 469++7281 ~            	ld		a, l
 470++7281 ~            	or		h
 471++7281 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++7281 ~
 473++7281 ~            	;Check if selection is 1=single drive or 2=dual drive
 474++7281 ~            	ld		a, (CopySelOption)
 475++7281 ~            	cp		'1'
 476++7281 ~            	jr		nz, CopyDiskDualDrive2
 477++7281 ~
 478++7281 ~            	;Prompt for disk change
 479++7281 ~            	call	PromptDiskChangeSrc
 480++7281 ~            	ld		a, (RWTSDrive)
 481++7281 ~            	call	BDOSInit
 482++7281 ~            	jp		CopyDiskLoop
 483++7281 ~
 484++7281 ~            CopyDiskDualDrive2:
 485++7281 ~            	;alternate drive again
 486++7281 ~            	ld		a, (RWTSDrive)
 487++7281 ~            	inc		a
 488++7281 ~            	xor		%11
 489++7281 ~            	dec		a
 490++7281 ~            	ld		(RWTSDrive), a
 491++7281 ~            	jp		CopyDiskLoop
 492++7281 ~
 493++7281 ~            CopyDiskEnd:
 494++7281 ~            	ld		b, 1
 495++7281 ~            	call	ClearNMsgLines
 496++7281 ~            	ret
 497++7281 ~
 498++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++7281 ~            ;Copies the current disk blocks to COM port.
 500++7281 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++7281 ~            CopyDiskToCOM:
 502++7281 ~            	;Get list of used blocks in current disk, max 632 bytes
 503++7281 ~            	call	ReadUsedBlocksList
 504++7281 ~
 505++7281 ~            	;Send block count and block indexes
 506++7281 ~            	ld		hl, (UsedBlockListCnt)
 507++7281 ~            	add		hl, hl
 508++7281 ~            	inc		hl
 509++7281 ~            	inc		hl
 510++7281 ~            	ld		b, h
 511++7281 ~            	ld		c, l
 512++7281 ~            	ld		hl, UsedBlockListCnt
 513++7281 ~            	call	SERTB
 514++7281 ~
 515++7281 ~            	ld		ix, UsedBlockListBlk
 516++7281 ~
 517++7281 ~            CopyDiskToCOMLoop:
 518++7281 ~            	;Print block count left
 519++7281 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++7281 ~            	ld		de, MsgBlocksLeft
 521++7281 ~            	call	Byte2Txt
 522++7281 ~            	ld		hl, MsgBlocksLeft
 523++7281 ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++7281 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++7281 ~            	call	PrintStrClr
 526++7281 ~
 527++7281 ~            	;Read block into buffer
 528++7281 ~            	ld		l, (ix)
 529++7281 ~            	ld		h, (ix+1)
 530++7281 ~            	ld		de, CopyDiskBuf
 531++7281 ~            	push	ix
 532++7281 ~            		call	ReadFSBlock
 533++7281 ~            	pop		ix
 534++7281 ~            	inc		ix
 535++7281 ~            	inc		ix
 536++7281 ~
 537++7281 ~            	;Send block buffer
 538++7281 ~            	ld		hl, CopyDiskBuf
 539++7281 ~            	ld		bc, AU_SZ
 540++7281 ~            	call	SERTB
 541++7281 ~
 542++7281 ~            	ld		bc, (UsedBlockListCnt)
 543++7281 ~            	dec		bc
 544++7281 ~            	ld		(UsedBlockListCnt), bc
 545++7281 ~
 546++7281 ~            	push	ix
 547++7281 ~            		call	KbdHit
 548++7281 ~            	pop		ix
 549++7281 ~            	ret		c
 550++7281 ~
 551++7281 ~            	ld		a, b
 552++7281 ~            	or		c
 553++7281 ~            	jr		nz, CopyDiskToCOMLoop
 554++7281 ~
 555++7281 ~            	ret
 556++7281 ~
 557++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++7281 ~            CopyDiskFromCOM:
 559++7281 ~            	;Receive block count.
 560++7281 ~            	ld		hl, UsedBlockListCnt
 561++7281 ~            	ld		bc, 2
 562++7281 ~            	ld		e, 0
 563++7281 ~            	call	SERRB
 564++7281 ~
 565++7281 ~            	;Receive block indexes.
 566++7281 ~            	ld		hl, (UsedBlockListCnt)
 567++7281 ~            	add		hl, hl
 568++7281 ~            	ld		b, h
 569++7281 ~            	ld		c, l
 570++7281 ~            	ld		hl, UsedBlockListBlk
 571++7281 ~            	ld		e, 0
 572++7281 ~            	call	SERRB
 573++7281 ~
 574++7281 ~            	;Read each block by index and write to disk
 575++7281 ~            	ld		ix, UsedBlockListBlk
 576++7281 ~
 577++7281 ~            CopyDiskFromCOMLoop:
 578++7281 ~            	;Print block count left
 579++7281 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++7281 ~            	ld		de, MsgBlocksLeft
 581++7281 ~            	call	Byte2Txt
 582++7281 ~            	ld		hl, MsgBlocksLeft
 583++7281 ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++7281 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++7281 ~            	call	PrintStrClr
 586++7281 ~
 587++7281 ~            	;Read block buffer
 588++7281 ~            	ld		hl, CopyDiskBuf
 589++7281 ~            	ld		bc, AU_SZ
 590++7281 ~            	ld		e, 0
 591++7281 ~            	call	SERRB
 592++7281 ~
 593++7281 ~            	;Write block to disk
 594++7281 ~            	ld		l, (ix)
 595++7281 ~            	ld		h, (ix+1)
 596++7281 ~            	ld		de, CopyDiskBuf
 597++7281 ~            	push	ix
 598++7281 ~            		call	WriteFSBlock			;Stop on error or continue?
 599++7281 ~            	pop		ix
 600++7281 ~            	inc		ix
 601++7281 ~            	inc		ix
 602++7281 ~
 603++7281 ~            	ld		bc, (UsedBlockListCnt)
 604++7281 ~            	dec		bc
 605++7281 ~            	ld		(UsedBlockListCnt), bc
 606++7281 ~
 607++7281 ~            	push	ix
 608++7281 ~            		call	KbdHit
 609++7281 ~            	pop		ix
 610++7281 ~            	ret		c
 611++7281 ~
 612++7281 ~            	ld		a, b
 613++7281 ~            	or		c
 614++7281 ~            	jr		nz, CopyDiskFromCOMLoop
 615++7281 ~            	ret
 616++7281 ~
 617++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++7281 ~
 619++7281 ~            ;Compare string at HL with the one at DE, max length B
 620++7281 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++7281 ~            ;OUT: z flag, set = match, reset = mismatch
 622++7281 ~            StrCmp:
 623++7281 ~            	push hl
 624++7281 ~            	push de
 625++7281 ~            Compare:
 626++7281 ~            		ld a, (de)
 627++7281 ~            		cp (hl)
 628++7281 ~            		jr nz, MisMatch
 629++7281 ~            		inc hl
 630++7281 ~            		inc de
 631++7281 ~            		djnz Compare
 632++7281 ~            MisMatch:
 633++7281 ~            	pop de
 634++7281 ~            	pop hl
 635++7281 ~            	ret
 636++7281 ~
 637++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++7281 ~
 639++7281 ~            ;Read a file into a buffer, sector by sector.
 640++7281 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++7281 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++7281 ~            ;In: HL = Name address, DE = buffer
 643++7281 ~            IF1FileLoad:
 644++7281 ~            	push	de
 645++7281 ~            		ld (FSTR1), hl
 646++7281 ~            		ld h, 0
 647++7281 ~            		ld a, (RWTSDrive)
 648++7281 ~            		inc  a			;CP/M drive number to BASIC drive number
 649++7281 ~            		ld	l, a
 650++7281 ~            		ld (DSTR1), hl
 651++7281 ~            		ld l,NAMELEN
 652++7281 ~            		ld (NSTR1), hl
 653++7281 ~            		rst 08
 654++7281 ~            		DEFB 51			;open disk channel
 655++7281 ~
 656++7281 ~            		rst		8
 657++7281 ~            		defb	53		;read sector
 658++7281 ~            	pop		de
 659++7281 ~            	jr		nc, FileFree
 660++7281 ~
 661++7281 ~            	ld		a, (ix + CH_DATA)
 662++7281 ~            	cp		TEXT_TYPE
 663++7281 ~            	jr		nc, FileLoadNoHeader
 664++7281 ~
 665++7281 ~            FileLoadHeader:
 666++7281 ~            	push	ix
 667++7281 ~            	pop		hl
 668++7281 ~            	ld		bc, CH_DATA + HDR_SZ
 669++7281 ~            	add		hl, bc
 670++7281 ~            	ld		bc, SECT_SZ - HDR_SZ
 671++7281 ~            	ldir
 672++7281 ~
 673++7281 ~            FileReadLoop:
 674++7281 ~            	push	de
 675++7281 ~            		rst		8
 676++7281 ~            		defb	53		;read sector
 677++7281 ~            	pop		de
 678++7281 ~            	jr		nc, FileFree
 679++7281 ~
 680++7281 ~            FileLoadNoHeader:
 681++7281 ~            	push	ix
 682++7281 ~            	pop		hl
 683++7281 ~            	ld		bc, CH_DATA
 684++7281 ~            	add		hl, bc
 685++7281 ~            	ld		bc, SECT_SZ
 686++7281 ~            	ldir
 687++7281 ~            	jr		FileReadLoop
 688++7281 ~
 689++7281 ~            FileFree:
 690++7281 ~            	push	de
 691++7281 ~            	rst		8
 692++7281 ~            	defb	56			;close channel (52) or detroy channel (56)
 693++7281 ~            	pop		de
 694++7281 ~            	ret
 695++7281 ~            IF1FileLoadEnd:
 696++7281 ~
 697++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++7281 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++7281 ~            ;Out: A = error code, 0=OK
 700++7281 ~            ReadDiskSectors:
 701++7281 ~            	push bc
 702++7281 ~            		push hl
 703++7281 ~            			push de
 704++7281 ~            				call ReadOneDiskSector
 705++7281 ~            			pop de
 706++7281 ~            		pop hl
 707++7281 ~
 708++7281 ~            		inc d
 709++7281 ~            		inc h
 710++7281 ~            	pop bc
 711++7281 ~
 712++7281 ~            	ld	a, (RWTSRes)
 713++7281 ~            	or	a
 714++7281 ~            	ret nz
 715++7281 ~
 716++7281 ~            	djnz ReadDiskSectors
 717++7281 ~            	ret
 718++7281 ~
 719++7281 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++7281 ~            ;Out: A = error code, 0=OK
 721++7281 ~            WriteDiskSectors:
 722++7281 ~            	push bc
 723++7281 ~            		push hl
 724++7281 ~            			push de
 725++7281 ~            				call WriteOneDiskSector
 726++7281 ~            			pop de
 727++7281 ~            		pop hl
 728++7281 ~
 729++7281 ~            		inc d
 730++7281 ~            		inc h
 731++7281 ~            	pop bc
 732++7281 ~
 733++7281 ~            	ld	a, (RWTSRes)
 734++7281 ~            	or	a
 735++7281 ~            	ret nz
 736++7281 ~
 737++7281 ~            	djnz WriteDiskSectors
 738++7281 ~            	ret
 739++7281 ~
 740++7281 ~
 741++7281 ~            ;Reads disk catalog
 742++7281 ~            ReadCatalogTrack:
 743++7281 ~            	ld hl, TrackBuf
 744++7281 ~            	ld de, 0
 745++7281 ~            	ld b, SPT
 746++7281 ~
 747++7281 ~            	call ReadDiskSectors
 748++7281 ~            	ret
 749++7281 ~
 750++7281 ~            ;A = track
 751++7281 ~            SeekTrack:
 752++7281 ~            	IFUSED
 753++7281 ~            	ld	(RWTSTrack), a
 754++7281 ~            	ld 	a, RWTS_CMD_SEEK
 755++7281 ~            	jp	RWTS
 756++7281 ~            	ENDIF
 757++7281 ~
 758++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759++7281 ~
 760++7281 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761++7281 ~            FindCache:
 762++7281 ~            	ld		b, NAMELEN
 763++7281 ~            	call	StrCmp			;find the file to wich this extension belongs
 764++7281 ~            	ret		z
 765++7281 ~
 766++7281 ~            	dec		c
 767++7281 ~            	jr		nz, CacheNotFinished
 768++7281 ~            	or		c
 769++7281 ~            	ret
 770++7281 ~
 771++7281 ~            CacheNotFinished:
 772++7281 ~            	ld		bc, CACHE_SZ
 773++7281 ~            	add		hl, bc			;to the next cache line
 774++7281 ~            	jr		FindCache
 775++7281 ~
 776++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777++7281 ~
 778++7281 ~            	;ld		ix, (SelFileCache)
 779++7281 ~            ReadFileHeader:
 780++7281 ~            	ld		a, (ix + CACHE_FLAG)
 781++7281 ~            	or		a
 782++7281 ~            	ret		nz				;return if already read
 783++7281 ~
 784++7281 ~            	ld		l, (ix + CACHE_FIRST_AU)
 785++7281 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 786++7281 ~            	ld		a, h
 787++7281 ~            	or		l
 788++7281 ~            	jr		z, ReadHeaderEnd
 789++7281 ~
 790++7281 ~            	call	AU2TS
 791++7281 ~            	ld		d, b
 792++7281 ~            	ld		e, c
 793++7281 ~            	ld		hl, DataBuf
 794++7281 ~            	push	ix
 795++7281 ~            	push	ix
 796++7281 ~            		call	ReadOneDiskSector
 797++7281 ~            	pop		hl
 798++7281 ~            	pop		ix
 799++7281 ~
 800++7281 ~            	push	hl
 801++7281 ~            		ld		hl, DataBuf
 802++7281 ~            		call	IsFileHeaderValid
 803++7281 ~            	pop		hl
 804++7281 ~            	or		a
 805++7281 ~            	jr		z, ReadFileHeaderIsTextFile
 806++7281 ~
 807++7281 ~            	ld		bc, CACHE_HDR
 808++7281 ~            	add		hl, bc
 809++7281 ~            	ex		hl, de
 810++7281 ~            	ld		hl, DataBuf
 811++7281 ~            	ld		bc, HDR_SZ
 812++7281 ~            	ldir
 813++7281 ~
 814++7281 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 815++7281 ~            	ld		a, BYTE_TYPE
 816++7281 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 817++7281 ~            	jr		nc, ReadHeaderEnd
 818++7281 ~
 819++7281 ~            ReadFileHeaderIsTextFile:
 820++7281 ~            	push	ix
 821++7281 ~            	push	ix
 822++7281 ~            	pop		hl
 823++7281 ~            		call	GetFileSize
 824++7281 ~            	pop		ix
 825++7281 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 826++7281 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827++7281 ~            	ld		a, TEXT_TYPE
 828++7281 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829++7281 ~
 830++7281 ~            ReadHeaderEnd:
 831++7281 ~            	inc		(ix + CACHE_FLAG)
 832++7281 ~            	ret
 833++7281 ~
 834++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835++7281 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 836++7281 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837++7281 ~            ;In: HL = header
 838++7281 ~            ;Out: A > 0 if valid
 839++7281 ~            IsFileHeaderValid:
 840++7281 ~            	IFUSED
 841++7281 ~            	xor		a
 842++7281 ~            	ld		b, HDR_SZ
 843++7281 ~            IsFileHeaderValidLoop:
 844++7281 ~            	or		(hl)
 845++7281 ~            	inc		hl
 846++7281 ~            	djnz	IsFileHeaderValidLoop
 847++7281 ~
 848++7281 ~            	ret
 849++7281 ~            	ENDIF
 850++7281 ~
 851++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852++7281 ~
 853++7281 ~            ;IN: HL = address from IF1 to call
 854++7281 ~            IF1Call:
 855++7281 ~            	LD   (HD11), HL
 856++7281 ~            	RST  8
 857++7281 ~            	DEFB 50
 858++7281 ~            	RET
 859++7281 ~
 860++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861++7281 ~
 862++7281 ~            ;Load a program from disk
 863++7281 ~            ;IN: HL = file name addr
 864++7281 ~            LoadProgram:
 865++7281 ~            	LD   (FSTR1), HL
 866++7281 ~            	LD   H, 0
 867++7281 ~            	LD   L, NAMELEN
 868++7281 ~            	LD   (NSTR1), HL
 869++7281 ~            	LD	 A, (RWTSDrive)
 870++7281 ~            	INC  A					;Adapt for BASIC drive number
 871++7281 ~            	LD   L, A
 872++7281 ~            	LD   (DSTR1), HL
 873++7281 ~            	LD   HL, LOAD_ADDR
 874++7281 ~            	CALL IF1Call
 875++7281 ~            	RET
 876++7281 ~
 877++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878++7281 ~
 879++7281 ~            SetFastKeys:
 880++7281 ~            	ld		hl, REPDEL
 881++7281 ~            	;ld		de, (1 << 8) | 15
 882++7281 ~            	ld		de, (1 << 8) | 10
 883++7281 ~            	ld		(hl), de
 884++7281 ~
 885++7281 ~            	ret
 886++7281 ~
 887++7281 ~
 888++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889++7281 ~            ;Reads the error message string from IF1 ROM.
 890++7281 ~            GetErrMsg:
 891++7281 ~            	inc		a
 892++7281 ~            	ex		af, af'
 893++7281 ~
 894++7281 ~            	ld		hl, IF1Paged			;page-in IF1
 895++7281 ~            	jp		IF1Call
 896++7281 ~
 897++7281 ~            IF1Paged:
 898++7281 ~            	ld		hl, ERRMSG
 899++7281 ~            	ex		af, af'
 900++7281 ~            	or		a
 901++7281 ~            	jr		z, SaveMsg
 902++7281 ~
 903++7281 ~            	ld		b, 0
 904++7281 ~            SearchMsgEnd:
 905++7281 ~            	bit		7, (hl)
 906++7281 ~            	inc		hl
 907++7281 ~            	jr		z, SearchMsgEnd
 908++7281 ~
 909++7281 ~            	inc		b
 910++7281 ~            	cp		b
 911++7281 ~            	jr		nz, SearchMsgEnd
 912++7281 ~
 913++7281 ~            SaveMsg:
 914++7281 ~            	ld		de, DataBuf
 915++7281 ~            CopyMsg:
 916++7281 ~            	ld		a, (hl)
 917++7281 ~            	bit		7, a
 918++7281 ~            	ld		(de), a
 919++7281 ~            	inc		hl
 920++7281 ~            	inc		de
 921++7281 ~            	jr		z, CopyMsg
 922++7281 ~
 923++7281 ~            	ret
 924++7281 ~
 925++7281 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926++7281 ~
 927++7281 ~            ;RWTS routine I/O block
 928++7281 ~            RWTSParams:
 929++7281 ~            RWTSBlockType	DEFB	1							;?
 930++7281 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931++7281 ~            RWTSVolNo		DEFB	0							;?
 932++7281 ~            RWTSTrack		DEFB	0
 933++7281 ~            RWTSSector		DEFB	0
 934++7281 ~            RWTSDMA			DEFW	0
 935++7281 ~            RWTSExtBuf		DEFW	$2932
 936++7281 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937++7281 ~            	IFDEF _REAL_HW_
 938++7281 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939++7281 ~            	ELSE
 940++7281 ~            RWTSPrmTbl		DEFW	$1f2a
 941++7281 ~            	ENDIF
 942++7281 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 943++7281 ~            ;Results
 944++7281 ~            RWTSRes			DEFB	0
 945++7281 ~            RWTSResVolNo	DEFB	0
 946++7281 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 947++7281 ~
 948++7281 ~            ;Param. table, usualy found in ROM.
 949++7281 ~            	IFDEF _REAL_HW_
 950++7281 ~            BasPrmTbl:
 951++7281 ~
 952++7281 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953++7281 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 954++7281 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 955++7281 ~            PrmDevType		DEFB	$01
 956++7281 ~            PrmStepRate		DEFB	$0D		;(milisec)
 957++7281 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958++7281 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959++7281 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960++7281 ~            PrmFastFactor	EQU		4
 961++7281 ~            PrmDevType		DEFB	$01
 962++7281 ~            PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963++7281 ~            PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964++7281 ~            PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965++7281 ~            	ENDIF
 966++7281 ~
 967++7281 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968++7281 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969++7281 ~            	ENDIF
 970++7281 ~
 971++7281              	endif
# file closed: if1.asm
   7+ 7281
   8+ 7281              BDOSInit:
   9+ 7281 AF           	xor		a
  10+ 7282 18 49        	jr		BDOS
  11+ 7284
  12+ 7284
  13+ 7284              ;IN: A = Drive to select
  14+ 7284              BDOSSelectDisk:
  15+ 7284              	IFUSED
  16+ 7284 DD 6F        	ld		ixl, a
  17+ 7286 DD 26 00     	ld		ixh, 0
  18+ 7289 3E 01        	ld		a, 1
  19+ 728B 18 40        	jr		BDOS
  20+ 728D              	ENDIF
  21+ 728D
  22+ 728D
  23+ 728D              BDOSMakeDiskRO:
  24+ 728D              	IFUSED
  25+ 728D ~            	ld		a, 15
  26+ 728D ~            	jr		BDOS
  27+ 728D              	ENDIF
  28+ 728D
  29+ 728D              ;Get Read Only flag
  30+ 728D              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 728D              BDOSGetDiskRO:
  32+ 728D              	IFUSED
  33+ 728D ~            	ld	a, 16
  34+ 728D ~            	jr	BDOS
  35+ 728D              	ENDIF
  36+ 728D
  37+ 728D              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 728D              BDOSGetCurrentDrive:
  39+ 728D              	IFUSED
  40+ 728D 3E 0C        	ld		a, 12
  41+ 728F 18 3C        	jr		BDOS
  42+ 7291              	ENDIF
  43+ 7291
  44+ 7291              ;Does log-off for all drives?
  45+ 7291              BDOSCloseDrives:
  46+ 7291              	IFUSED
  47+ 7291 ~            	ld		ixl, a
  48+ 7291 ~            	ld		ixh, 0
  49+ 7291 ~            	ld		a, 22
  50+ 7291 ~            	jr		BDOS
  51+ 7291              	ENDIF
  52+ 7291
  53+ 7291              ;Create a disk channel for BDOS access (does not open the file)
  54+ 7291              ;IN: HL=name addr, A=drive
  55+ 7291              ;OUT: IX=FCB
  56+ 7291              CreateChannel:
  57+ 7291 22 DC 5C     	ld (FSTR1), hl
  58+ 7294 26 00        	ld h,0
  59+ 7296 6F           	ld l,a
  60+ 7297 22 D6 5C     	ld (DSTR1), hl
  61+ 729A 2E 0B        	ld l,NAMELEN
  62+ 729C 22 DA 5C     	ld (NSTR1), hl
  63+ 729F CF           	rst 08
  64+ 72A0 37           	DEFB 55
  65+ 72A1 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 72A4 DD 09        	add ix, bc
  67+ 72A6 C9           	ret
  68+ 72A7
  69+ 72A7
  70+ 72A7              ;Destroy a BDOS channel
  71+ 72A7              ;IN: IX=FCB
  72+ 72A7              DestroyChannel:
  73+ 72A7 C5           	push bc
  74+ 72A8 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 72AB DD 09        	add ix, bc
  76+ 72AD CF           	rst 08
  77+ 72AE 38           	DEFB 56
  78+ 72AF C1           	pop bc
  79+ 72B0 C9           	ret
  80+ 72B1
  81+ 72B1
  82+ 72B1              ;Input: IX=FCB
  83+ 72B1              BDOSCreateFile:
  84+ 72B1 3E 09        	ld	a, 9
  85+ 72B3 18 18        	jr	BDOS
  86+ 72B5
  87+ 72B5              ;Input: IX=FCB
  88+ 72B5              BDOSOpenFile:
  89+ 72B5 3E 02        	ld	a, 2
  90+ 72B7 18 14        	jr	BDOS
  91+ 72B9
  92+ 72B9              ;IN: IX=FCB
  93+ 72B9              BDOSCloseFile:
  94+ 72B9 3E 03        	ld	a, 3
  95+ 72BB 18 10        	jr	BDOS
  96+ 72BD
  97+ 72BD
  98+ 72BD              ;0 OK,
  99+ 72BD              ;1 end of file,
 100+ 72BD              ;9 invalid FCB,
 101+ 72BD              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 72BD              ;11 (MP/M) unlocked file verification error,
 103+ 72BD              ;0FFh hardware error.
 104+ 72BD
 105+ 72BD              ;IN: IX=FCB
 106+ 72BD              BDOSReadFileBlockSeq:
 107+ 72BD 3E 07        	ld	a, 7
 108+ 72BF 18 0C        	jr	BDOS
 109+ 72C1
 110+ 72C1
 111+ 72C1              ;0 OK,
 112+ 72C1              ;1 directory full,
 113+ 72C1              ;2 disc full,
 114+ 72C1              ;8 (MP/M) record locked by another process,
 115+ 72C1              ;9 invalid FCB,
 116+ 72C1              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 72C1              ;11 (MP/M) unlocked file verification error,
 118+ 72C1              ;0FFh hardware error.
 119+ 72C1
 120+ 72C1              ;IN: IX=FCB
 121+ 72C1              BDOSWriteFileBlockSeq:
 122+ 72C1 3E 08        	ld	a, 8
 123+ 72C3 18 08        	jr	BDOS
 124+ 72C5
 125+ 72C5
 126+ 72C5              ;0 OK
 127+ 72C5              ;1 Reading unwritten data
 128+ 72C5              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 72C5              ;6 Record number out of range
 130+ 72C5              ;9 Invalid FCB
 131+ 72C5              BDOSReadFileBlockRandom:
 132+ 72C5 3E 12        	ld	a, 18
 133+ 72C7 18 04        	jr	BDOS
 134+ 72C9
 135+ 72C9              ;0 OK
 136+ 72C9              ;2 Disc full
 137+ 72C9              ;3 Cannot close extent
 138+ 72C9              ;5 Directory full
 139+ 72C9              ;6 Record number out of range
 140+ 72C9              ;8 Record is locked by another process (MP/M)
 141+ 72C9              ;9 Invalid FCB
 142+ 72C9              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 72C9              BDOSWriteFileBlockRandom:
 144+ 72C9 3E 13        	ld	a, 19
 145+ 72CB 18 00        	jr	BDOS
 146+ 72CD
 147+ 72CD
 148+ 72CD              ;Generic BDOS call
 149+ 72CD              ;IX=arg, A=function
 150+ 72CD              BDOS:
 151+ 72CD DD 22 ED 5C  	ld (HD11), ix
 152+ 72D1 32 EF 5C     	ld (COPIES), a
 153+ 72D4 CF           	rst 08
 154+ 72D5 39           	DEFB 57
 155+ 72D6 C9           	ret
 156+ 72D7
 157+ 72D7              ;Set DMA address for BDOS
 158+ 72D7              ;IX=DMA
 159+ 72D7              BDOSSetDMA:
 160+ 72D7 3E 0D        	ld a, 13
 161+ 72D9 18 F2        	jr BDOS
 162+ 72DB
 163+ 72DB              ;In: IX=FCB
 164+ 72DB              BDOSSetRandFilePtr:
 165+ 72DB 3E 15        	ld	a, 21
 166+ 72DD 18 EE        	jr	BDOS
 167+ 72DF
 168+ 72DF              ;In: HL=filename
 169+ 72DF              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 72DF              GetFileSize:
 171+ 72DF              	IFUSED
 172+ 72DF
 173+ 72DF 3A 69 72     	ld 		a, (RWTSDrive)
 174+ 72E2 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 72E3 CD 91 72     	call	CreateChannel
 176+ 72E6
 177+ 72E6 3E 14        	ld		a, 20
 178+ 72E8 CD CD 72     	call	BDOS
 179+ 72EB              	;inc		a
 180+ 72EB              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 72EB
 182+ 72EB DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 72EE DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 72F1
 185+ 72F1              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 72F1 3E 01        	ld		a, 1
 187+ 72F3 BC           	cp		h
 188+ 72F4 30 05        	jr		nc, GetFileSizeOK
 189+ 72F6 21 00 00     	ld		hl, 0
 190+ 72F9 18 08        	jr		GetFileSizeEnd
 191+ 72FB
 192+ 72FB              GetFileSizeOK:
 193+ 72FB              	;*128 == 2^7
 194+ 72FB 06 07        	ld		b, 7
 195+ 72FD              GetFileSizeMul:
 196+ 72FD CB 15        	rl		l
 197+ 72FF CB 14        	rl		h
 198+ 7301 10 FA        	djnz	GetFileSizeMul
 199+ 7303
 200+ 7303              GetFileSizeEnd:
 201+ 7303 E5           	push	hl
 202+ 7304 CD A7 72     		call	DestroyChannel
 203+ 7307 E1           	pop		hl
 204+ 7308
 205+ 7308 C9           	ret
 206+ 7309              	ENDIF
 207+ 7309
 208+ 7309              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 7309              ;HL=file name, A=drive
 210+ 7309              DeleteFile:
 211+ 7309 CD 91 72     	call	CreateChannel
 212+ 730C
 213+ 730C 3E 06        	ld		a, 6
 214+ 730E CD CD 72     	call	BDOS
 215+ 7311
 216+ 7311 CD A7 72     	call	DestroyChannel
 217+ 7314 C9           	ret
 218+ 7315
 219+ 7315              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 7315              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 7315              ;HL=file name, A=drive
 222+ 7315              DoesFileExist:
 223+ 7315              	IFUSED
 224+ 7315              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 7315 F5           	push	af
 226+ 7316 E5           	push	hl
 227+ 7317 DD 21 C6 EE  		ld		ix, FileIdx
 228+ 731B CD D7 72     		call 	BDOSSetDMA
 229+ 731E E1           	pop		hl
 230+ 731F F1           	pop		af
 231+ 7320
 232+ 7320 CD 91 72     	call	CreateChannel
 233+ 7323
 234+ 7323              	;Uses FindFirst system call.
 235+ 7323 3E 04        	ld		a, 4
 236+ 7325 CD CD 72     	call	BDOS
 237+ 7328
 238+ 7328 F5           	push	af
 239+ 7329 CD A7 72     		call	DestroyChannel
 240+ 732C F1           	pop		af
 241+ 732D C9           	ret
 242+ 732E              	ENDIF
 243+ 732E
 244+ 732E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 732E              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 732E              ChangeFileAttrib:
 247+ 732E 3A 69 72     	ld 		a, (RWTSDrive)
 248+ 7331 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 7332 D5           	push	de
 250+ 7333 CD 91 72     	call	CreateChannel
 251+ 7336 D1           	pop		de
 252+ 7337
 253+ 7337 DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 733A CB 27        	sla		a								;reset existing attribute flag
 255+ 733C CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 733E CB 1F        	rr		a								;put Carry flag in register L
 257+ 7340 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 7343
 259+ 7343 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 7346 CB 27        	sla		a
 261+ 7348 CB 1B        	rr		e
 262+ 734A CB 1F        	rr		a
 263+ 734C DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 734F
 265+ 734F              FileAttribSet:
 266+ 734F 3E 11        	ld		a, 17
 267+ 7351 CD CD 72     	call	BDOS
 268+ 7354
 269+ 7354 CD A7 72     	call	DestroyChannel
 270+ 7357 C9           	ret
 271+ 7358
 272+ 7358              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 7358
 274+ 7358              ;HL=original name, DE = new name
 275+ 7358              ;Works only on the same drive.
 276+ 7358              RenameFile:
 277+ 7358 3A 69 72     	ld 		a, (RWTSDrive)
 278+ 735B 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 735C D5           	push	de
 280+ 735D CD 91 72     	call	CreateChannel
 281+ 7360 D1           	pop		de
 282+ 7361
 283+ 7361 DD E5        	push	ix					;IX == FCB
 284+ 7363 E1           	pop		hl
 285+ 7364 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 7367 09           	add		hl, bc
 287+ 7368 EB           	ex		de, hl
 288+ 7369 3A 69 72     	ld		a, (RWTSDrive)
 289+ 736C 12           	ld		(de), a
 290+ 736D 01 0B 00     	ld		bc, NAMELEN
 291+ 7370 ED B0        	ldir
 292+ 7372
 293+ 7372 3E 0A        	ld		a, 10
 294+ 7374 CD CD 72     	call	BDOS
 295+ 7377
 296+ 7377 CD A7 72     	call	DestroyChannel
 297+ 737A C9           	ret
 298+ 737B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 737B              PromptDiskChangeDst:
 300+ 737B 21 2F 7F     	ld		hl, MsgInsertDstDsk
 301+ 737E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 7381 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 7383 CD 37 77     	call	PrintStrClr
 304+ 7386 21 3E 7F     	ld		hl, MsgPressAnyKey
 305+ 7389 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 738C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 738E CD 37 77     	call	PrintStrClr
 308+ 7391 CD D3 76     	call	ReadChar
 309+ 7394 C9           	ret
 310+ 7395
 311+ 7395              PromptDiskChangeSrc:
 312+ 7395 21 20 7F     	ld		hl, MsgInsertSrcDsk
 313+ 7398 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 739B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 739D CD 37 77     	call	PrintStrClr
 316+ 73A0 21 3E 7F     	ld		hl, MsgPressAnyKey
 317+ 73A3 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 73A6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 73A8 CD 37 77     	call	PrintStrClr
 320+ 73AB CD D3 76     	call	ReadChar
 321+ 73AE C9           	ret
 322+ 73AF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 73AF
 324+ 73AF              ;HL = source file name, A = source drive
 325+ 73AF              ;Use cases:
 326+ 73AF              ;1. Copy from A: to B: or B: to A:.
 327+ 73AF              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 73AF              ;3. Copy from A:/B: to COM.
 329+ 73AF              ;4. Copy from COM to A:/B:.
 330+ 73AF              ;Single drive scenario:
 331+ 73AF              ;1. Read first file part,
 332+ 73AF              ;2. Ask for dest disk,
 333+ 73AF              ;3. check if file exists/ask for overwrite,
 334+ 73AF              ;4. create empty dest file,
 335+ 73AF              ;5. write first file part,
 336+ 73AF              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 73AF              CopyFile:
 338+ 73AF 3A 69 72     	ld 		a, (RWTSDrive)
 339+ 73B2 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 73B3 32 90 7F     	ld		(CopyFileSrcDrv), a
 341+ 73B6 32 9C 7F     	ld		(CopyFileDstDrv), a
 342+ 73B9 11 91 7F     	ld		de, CopyFileSrcName
 343+ 73BC 01 0B 00     	ld		bc, NAMELEN
 344+ 73BF E5           	push	hl
 345+ 73C0 C5           	push	bc
 346+ 73C1 ED B0        	ldir
 347+ 73C3 C1           	pop		bc
 348+ 73C4 E1           	pop		hl
 349+ 73C5 11 9D 7F     	ld		de, CopyFileDstName
 350+ 73C8 ED B0        	ldir
 351+ 73CA
 352+ 73CA              	;Reset R/O attribute for destination, to allow file write.
 353+ 73CA 3A A5 7F     	ld		a, (CopyFileDstName+RO_POS)
 354+ 73CD CB BF        	res		7, a
 355+ 73CF 32 A5 7F     	ld		(CopyFileDstName+RO_POS), a
 356+ 73D2
 357+ 73D2 AF           	xor		a
 358+ 73D3 32 88 7F     	ld		(CopyFileRes), a
 359+ 73D6 11 00 00     	ld		de, 0
 360+ 73D9 ED 53 8B 7F  	ld		(FilePosRead), de
 361+ 73DD ED 53 8D 7F  	ld		(FilePosWrite), de
 362+ 73E1
 363+ 73E1 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 364+ 73E4 C6 40        	add		'A'-1
 365+ 73E6              	;Update menu messages with current drive.
 366+ 73E6 32 A9 7E     	ld		(MsgMenuSingleDrv1), a
 367+ 73E9 32 AD 7E     	ld		(MsgMenuSingleDrv2), a
 368+ 73EC 32 B7 7E     	ld		(MsgMenuDualDrv1), a
 369+ 73EF 32 C5 7E     	ld		(MsgMenuToComDrv), a
 370+ 73F2 32 D9 7E     	ld		(MsgMenuFromCOMDrv), a
 371+ 73F5              	;Update menu messages with the alternate drive.
 372+ 73F5 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 373+ 73F8 EE 03        	xor		%11
 374+ 73FA C6 40        	add		'A'-1
 375+ 73FC 32 BB 7E     	ld		(MsgMenuDualDrv2), a
 376+ 73FF
 377+ 73FF 21 86 7E     	ld		hl, MsgMenuFileCopy
 378+ 7402 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 7405 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 7407 CD 37 77     	call	PrintStrClr
 381+ 740A 21 95 7E     	ld		hl, MsgMenuBack
 382+ 740D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 7410 CD 0F 77     	call	PrintStr
 384+ 7413 21 A1 7E     	ld		hl, MsgMenuSingle
 385+ 7416 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 7419 CD 0F 77     	call	PrintStr
 387+ 741C 21 AF 7E     	ld		hl, MsgMenuDual
 388+ 741F 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 7422 CD 0F 77     	call	PrintStr
 390+ 7425 21 BD 7E     	ld		hl, MsgMenuToCOM
 391+ 7428 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 742B CD 0F 77     	call	PrintStr
 393+ 742E 21 CC 7E     	ld		hl, MsgMenuFromCOM
 394+ 7431 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 7434 CD 0F 77     	call	PrintStr
 396+ 7437
 397+ 7437 CD D3 76     	call	ReadChar
 398+ 743A 32 85 7F     	ld		(CopySelOption), a
 399+ 743D
 400+ 743D F5           	push	af
 401+ 743E 06 06        		ld		b, 6
 402+ 7440 CD BB 78     		call	ClearNMsgLines
 403+ 7443 F1           	pop		af
 404+ 7444
 405+ 7444              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 7444 FE 30        	cp		'0'
 407+ 7446 20 04        	jr		nz, CopyFileNotExit
 408+ 7448 E1           	pop		hl
 409+ 7449 C3 44 67     	jp		ReadKeyLoop
 410+ 744C
 411+ 744C              CopyFileNotExit:
 412+ 744C FE 31        	cp		'1'
 413+ 744E 28 4D        	jr		z, CopyFileSameDrive
 414+ 7450
 415+ 7450 FE 32        	cp		'2'
 416+ 7452 CA 1C 75     	jp		z, CopyFileDualDrive
 417+ 7455
 418+ 7455 FE 33        	cp		'3'
 419+ 7457 CA 66 75     	jp		z, CopyFileToCOM
 420+ 745A
 421+ 745A FE 34        	cp		'4'
 422+ 745C CA 99 75     	jp		z, CopyFileFromCOM
 423+ 745F
 424+ 745F E1           	pop		hl
 425+ 7460 C3 44 67     	jp		ReadKeyLoop
 426+ 7463
 427+ 7463
 428+ 7463              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 7463              CopyFileCheckOverwrite:
 430+ 7463              	;Check if destination file exists.
 431+ 7463 3A 9C 7F     	ld		a, (CopyFileDstDrv)
 432+ 7466 21 9D 7F     	ld		hl, CopyFileDstName
 433+ 7469 CD 15 73     	call	DoesFileExist
 434+ 746C 3C           	inc		a
 435+ 746D C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 746E
 437+ 746E              	;Ask overwrite confirmation.
 438+ 746E 21 02 7F     	ld		hl, MsgFileOverwrite
 439+ 7471 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 7474 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 7476 CD 37 77     	call	PrintStrClr
 442+ 7479 CD D3 76     	call	ReadChar
 443+ 747C FE 79        	cp		'y'
 444+ 747E C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 747F
 446+ 747F
 447+ 747F              CopyFileCreateNewFile:
 448+ 747F 3A 9C 7F     	ld		a, (CopyFileDstDrv)
 449+ 7482 21 9D 7F     	ld		hl, CopyFileDstName
 450+ 7485 F5           	push	af
 451+ 7486 E5           	push	hl
 452+ 7487 CD 09 73     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 748A E1           	pop		hl
 454+ 748B F1           	pop		af
 455+ 748C CD 91 72     	call	CreateChannel
 456+ 748F CD B1 72     	call 	BDOSCreateFile
 457+ 7492 3C           	inc  	a						;Cancel if A==$FF
 458+ 7493 C8           	ret		z
 459+ 7494
 460+ 7494              	;Close dest file once created.
 461+ 7494 F5           	push	af
 462+ 7495 CD B9 72     		call	BDOSCloseFile
 463+ 7498 CD A7 72     		call	DestroyChannel
 464+ 749B F1           	pop		af
 465+ 749C C9           	ret
 466+ 749D
 467+ 749D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 749D              CopyFileSameDrive:
 469+ 749D              	;Read first file section from SRC.
 470+ 749D 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 471+ 74A0 21 91 7F     	ld		hl, CopyFileSrcName
 472+ 74A3 06 61        	ld		b, MAX_SECT_BUF
 473+ 74A5 CD 1C 76     	call	ReadFileSection
 474+ 74A8 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 475+ 74AB B7           	or		a
 476+ 74AC C8           	ret		z
 477+ 74AD
 478+ 74AD              	;Prompt for DST disk change.
 479+ 74AD CD 7B 73     	call	PromptDiskChangeDst
 480+ 74B0 3A 69 72     	ld		a, (RWTSDrive)
 481+ 74B3 CD 81 72     	call	BDOSInit
 482+ 74B6
 483+ 74B6 06 02        	ld		b, 2
 484+ 74B8 CD BB 78     	call	ClearNMsgLines
 485+ 74BB
 486+ 74BB CD 63 74     	call	CopyFileCheckOverwrite
 487+ 74BE C0           	ret		nz
 488+ 74BF
 489+ 74BF CD 7F 74     	call	CopyFileCreateNewFile
 490+ 74C2 C8           	ret		z
 491+ 74C3
 492+ 74C3              CopyFileSameDriveLoop:
 493+ 74C3 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 494+ 74C6 6F           	ld		l, a
 495+ 74C7 26 00        	ld		h, 0
 496+ 74C9 11 4B 7F     	ld		de, MsgCopySectors
 497+ 74CC CD 40 6E     	call	Byte2Txt
 498+ 74CF 21 4B 7F     	ld		hl, MsgCopySectors
 499+ 74D2 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500+ 74D5 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501+ 74D7 CD 37 77     	call	PrintStrClr
 502+ 74DA
 503+ 74DA 3A 88 7F     	ld		a, (CopyFileRes)			;Save read status code.
 504+ 74DD F5           	push	af
 505+ 74DE 3A 9C 7F     		ld		a, (CopyFileDstDrv)
 506+ 74E1 21 9D 7F     		ld		hl, CopyFileDstName
 507+ 74E4 CD 41 76     		call	WriteFileSection
 508+ 74E7 3A 88 7F     		ld		a, (CopyFileRes)
 509+ 74EA 6F           		ld		l, a
 510+ 74EB F1           	pop		af
 511+ 74EC B5           	or		l
 512+ 74ED C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 513+ 74EE
 514+ 74EE
 515+ 74EE              	;Prompt for SRC disk change.
 516+ 74EE CD 95 73     	call	PromptDiskChangeSrc
 517+ 74F1 3A 69 72     	ld		a, (RWTSDrive)
 518+ 74F4 CD 81 72     	call	BDOSInit
 519+ 74F7
 520+ 74F7 06 02        	ld		b, 2
 521+ 74F9 CD BB 78     	call	ClearNMsgLines
 522+ 74FC
 523+ 74FC 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 524+ 74FF 21 91 7F     	ld		hl, CopyFileSrcName
 525+ 7502 06 61        	ld		b, MAX_SECT_BUF
 526+ 7504 CD 1C 76     	call	ReadFileSection
 527+ 7507 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 528+ 750A B7           	or		a
 529+ 750B C8           	ret		z
 530+ 750C
 531+ 750C              	;Prompt for DST disk change.
 532+ 750C CD 7B 73     	call	PromptDiskChangeDst
 533+ 750F 3A 69 72     	ld		a, (RWTSDrive)
 534+ 7512 CD 81 72     	call	BDOSInit
 535+ 7515
 536+ 7515 06 02        	ld		b, 2
 537+ 7517 CD BB 78     	call	ClearNMsgLines
 538+ 751A
 539+ 751A 18 A7        	jr		CopyFileSameDriveLoop
 540+ 751C
 541+ 751C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 542+ 751C
 543+ 751C              CopyFileDualDrive:
 544+ 751C 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 545+ 751F EE 03        	xor		%11
 546+ 7521 32 9C 7F     	ld		(CopyFileDstDrv), a
 547+ 7524
 548+ 7524 CD 63 74     	call	CopyFileCheckOverwrite
 549+ 7527 C0           	ret		nz
 550+ 7528
 551+ 7528 CD 7F 74     	call	CopyFileCreateNewFile
 552+ 752B C8           	ret		z
 553+ 752C
 554+ 752C              CopyFileDualDriveLoop:
 555+ 752C 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 556+ 752F 21 91 7F     	ld		hl, CopyFileSrcName
 557+ 7532 06 61        	ld		b, MAX_SECT_BUF
 558+ 7534 CD 1C 76     	call	ReadFileSection
 559+ 7537 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 560+ 753A B7           	or		a
 561+ 753B C8           	ret		z
 562+ 753C
 563+ 753C 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 564+ 753F 6F           	ld		l, a
 565+ 7540 26 00        	ld		h, 0
 566+ 7542 11 4B 7F     	ld		de, MsgCopySectors
 567+ 7545 CD 40 6E     	call	Byte2Txt
 568+ 7548 21 4B 7F     	ld		hl, MsgCopySectors
 569+ 754B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 570+ 754E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 571+ 7550
 572+ 7550 3A 88 7F     	ld		a, (CopyFileRes)
 573+ 7553 F5           	push	af
 574+ 7554 3A 9C 7F     		ld		a, (CopyFileDstDrv)
 575+ 7557 21 9D 7F     		ld		hl, CopyFileDstName
 576+ 755A CD 41 76     		call	WriteFileSection
 577+ 755D 3A 88 7F     		ld		a, (CopyFileRes)
 578+ 7560 6F           		ld		l, a
 579+ 7561 F1           	pop		af
 580+ 7562 B5           	or		l
 581+ 7563 C0           	ret		nz
 582+ 7564
 583+ 7564 18 C6        	jr		CopyFileDualDriveLoop
 584+ 7566
 585+ 7566              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 586+ 7566              CopyFileToCOM:
 587+ 7566 AF           	xor		a
 588+ 7567 32 88 7F     	ld		(CopyFileRes), a
 589+ 756A 32 8F 7F     	ld		(CopyFileSectCnt), a
 590+ 756D 11 00 00     	ld		de, 0
 591+ 7570 ED 53 8B 7F  	ld		(FilePosRead), de
 592+ 7574
 593+ 7574              CopyFileToCOMLoop:
 594+ 7574 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 595+ 7577 21 91 7F     	ld		hl, CopyFileSrcName
 596+ 757A 06 61        	ld		b, MAX_SECT_BUF
 597+ 757C CD 1C 76     	call	ReadFileSection
 598+ 757F
 599+ 757F 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 600+ 7582 B7           	or		a
 601+ 7583 28 0F        	jr		z, CopyFileToCOMEnd
 602+ 7585
 603+ 7585              	;Send buffer to COM port.
 604+ 7585 21 C6 8D     	ld		hl, FileData
 605+ 7588 47           	ld		b, a					;Sector size is 256.
 606+ 7589 0E 00        	ld		c, 0
 607+ 758B CD A9 7B     	call	SERTB
 608+ 758E
 609+ 758E 3A 88 7F     	ld		a, (CopyFileRes)
 610+ 7591 B7           	or		a
 611+ 7592 28 E0        	jr		z, CopyFileToCOMLoop
 612+ 7594
 613+ 7594              CopyFileToCOMEnd:
 614+ 7594              	;Reset read error code, as 1 is returned when file is finished reading.
 615+ 7594 AF           	xor		a
 616+ 7595 32 88 7F     	ld		(CopyFileRes), a
 617+ 7598
 618+ 7598 C9           	ret
 619+ 7599
 620+ 7599              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 621+ 7599              CopyFileFromCOM:
 622+ 7599 AF           	xor		a
 623+ 759A 32 88 7F     	ld		(CopyFileRes), a
 624+ 759D 11 00 00     	ld		de, 0
 625+ 75A0 ED 53 8D 7F  	ld		(FilePosWrite), de
 626+ 75A4
 627+ 75A4              	;Must ask for the new file name and check to not exist.
 628+ 75A4 21 6C 7E     	ld		hl, MsgNewFileName
 629+ 75A7 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 630+ 75AA 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 631+ 75AC CD 37 77     	call	PrintStrClr
 632+ 75AF
 633+ 75AF 21 37 7E     	ld		hl, MsgClear
 634+ 75B2 11 C6 8D     	ld		de, FileData
 635+ 75B5 01 0B 00     	ld		bc, NAMELEN
 636+ 75B8 ED B0        	ldir
 637+ 75BA 3E A0        	ld		a, $80 | ' '
 638+ 75BC 12           	ld		(de), a
 639+ 75BD 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 75C0 21 C6 8D     	ld		hl, FileData
 641+ 75C3 CD 0F 77     	call	PrintStr
 642+ 75C6
 643+ 75C6 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 644+ 75C9 01 0B 00     	ld		bc, NAMELEN
 645+ 75CC CD 79 78     	call	ReadString
 646+ 75CF
 647+ 75CF 11 C6 8D     	ld		de, FileData
 648+ 75D2 1A           	ld		a, (de)
 649+ 75D3 FE 20        	cp		' '					;If starting with space, input was canceled.
 650+ 75D5 C8           	ret		z
 651+ 75D6
 652+ 75D6              	;Copy new file name
 653+ 75D6 21 C6 8D     	ld		hl, FileData
 654+ 75D9 11 9D 7F     	ld		de, CopyFileDstName
 655+ 75DC 01 0B 00     	ld		bc, NAMELEN
 656+ 75DF ED B0        	ldir
 657+ 75E1
 658+ 75E1              	;Check if new name doesn't exist already.
 659+ 75E1 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 660+ 75E4 21 9D 7F     	ld		hl, CopyFileDstName
 661+ 75E7 CD 63 74     	call	CopyFileCheckOverwrite
 662+ 75EA C0           	ret		nz
 663+ 75EB
 664+ 75EB              	;Delete and re-create empty destination file
 665+ 75EB 3A 90 7F     	ld		a, (CopyFileSrcDrv)
 666+ 75EE 21 9D 7F     	ld		hl, CopyFileDstName
 667+ 75F1 CD 7F 74     	call	CopyFileCreateNewFile
 668+ 75F4 C8           	ret		z
 669+ 75F5
 670+ 75F5              CopyFileFromCOMLoop:
 671+ 75F5 21 C6 8D     	ld		hl, FileData
 672+ 75F8 01 00 61     	ld		bc, FileDataSize
 673+ 75FB 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 674+ 75FD CD 76 7B     	call	SERRB				;BC = Number of bytes read from COM
 675+ 7600 79           	ld		a, c
 676+ 7601 B0           	or		b
 677+ 7602 C8           	ret		z
 678+ 7603
 679+ 7603              	;If C is not 0, add one more sector.
 680+ 7603 79           	ld 		a, c
 681+ 7604 B7           	or		a
 682+ 7605 28 01        	jr		z, CopyFileFromCOMDontInc
 683+ 7607 04           	inc		b
 684+ 7608              CopyFileFromCOMDontInc:
 685+ 7608 78           	ld		a, b				;Sector size is 256
 686+ 7609 32 8F 7F     	ld		(CopyFileSectCnt), a
 687+ 760C 3A 9C 7F     	ld		a, (CopyFileDstDrv)
 688+ 760F 21 9D 7F     	ld		hl, CopyFileDstName
 689+ 7612 CD 41 76     	call	WriteFileSection
 690+ 7615
 691+ 7615 3A 88 7F     	ld		a, (CopyFileRes)
 692+ 7618 B7           	or		a
 693+ 7619 28 DA        	jr		z, CopyFileFromCOMLoop
 694+ 761B
 695+ 761B C9           	ret
 696+ 761C
 697+ 761C              ;Reads/Writes disk file portion to/from memory.
 698+ 761C              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 699+ 761C              ;This should work with single-drive file copy from one disk to another.
 700+ 761C              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records, B = max sectors to read
 701+ 761C              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 702+ 761C              ;
 703+ 761C              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 704+ 761C              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 705+ 761C              ;Must use sequential read/write. But for the first operation must use random read/write.
 706+ 761C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 761C              ReadFileSection:
 708+ 761C 11 C5 72     	ld		de, BDOSReadFileBlockRandom
 709+ 761F ED 53 89 76  	ld		(CopyFileOperAddr1), de
 710+ 7623 11 BD 72     	ld		de, BDOSReadFileBlockSeq
 711+ 7626 ED 53 A8 76  	ld		(CopyFileOperAddr2), de
 712+ 762A 11 8B 7F     	ld		de, FilePosRead
 713+ 762D ED 53 80 76  	ld		(CopyFilePtr), de
 714+ 7631 ED 53 C5 76  	ld		(CopyFilePtr2), de
 715+ 7635
 716+ 7635              	;Limit max sectors to read to leave space for the index too.
 717+ 7635 F5           	push	af
 718+ 7636 78           		ld		a, b
 719+ 7637 32 8F 7F     		ld		(CopyFileSectCnt), a
 720+ 763A C5           		push	bc
 721+ 763B D9           		exx
 722+ 763C C1           		pop		bc
 723+ 763D D9           		exx
 724+ 763E F1           	pop		af
 725+ 763F 18 19        	jr		ReadWriteFileSection
 726+ 7641
 727+ 7641              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 728+ 7641
 729+ 7641              WriteFileSection:
 730+ 7641 11 C9 72     	ld		de, BDOSWriteFileBlockRandom
 731+ 7644 ED 53 89 76  	ld		(CopyFileOperAddr1), de
 732+ 7648 11 C1 72     	ld		de, BDOSWriteFileBlockSeq
 733+ 764B ED 53 A8 76  	ld		(CopyFileOperAddr2), de
 734+ 764F 11 8D 7F     	ld		de, FilePosWrite
 735+ 7652 ED 53 80 76  	ld		(CopyFilePtr), de
 736+ 7656 ED 53 C5 76  	ld		(CopyFilePtr2), de
 737+ 765A
 738+ 765A
 739+ 765A              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 740+ 765A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 741+ 765A              ReadWriteFileSection:
 742+ 765A CD 91 72     	call	CreateChannel
 743+ 765D DD 22 86 7F  	ld		(CopyFileFCB), ix
 744+ 7661 CD B5 72     	call 	BDOSOpenFile
 745+ 7664 3C           	inc  	a						;Cancel if A==$FF
 746+ 7665 C8           	ret		z
 747+ 7666
 748+ 7666              	;Set DMA initial pointer = FileData
 749+ 7666 DD E5        	push	ix
 750+ 7668 21 C6 8D     		ld		hl, FileData
 751+ 766B DD 21 89 7F  		ld		ix, CopyFileDMAAddr
 752+ 766F DD 75 00     		ld		(ix), l
 753+ 7672 DD 74 01     		ld		(ix+1), h
 754+ 7675 DD 21 C6 8D  		ld		ix, FileData
 755+ 7679 CD D7 72     		call 	BDOSSetDMA
 756+ 767C DD E1        	pop		ix
 757+ 767E
 758+ 767E              CopyFilePtr EQU $+2
 759+ 767E              	;Update file pointer using read/write random call.
 760+ 767E ED 5B 8B 7F  	ld		de, (FilePosRead)
 761+ 7682 DD 73 21     	ld		(ix + FCB_R0), e
 762+ 7685 DD 72 22     	ld		(ix + FCB_R1), d
 763+ 7688              CopyFileOperAddr1 EQU $ + 1
 764+ 7688 CD C5 72     	call 	BDOSReadFileBlockRandom
 765+ 768B
 766+ 768B 32 88 7F     	ld		(CopyFileRes), a
 767+ 768E B7           	or		a
 768+ 768F 20 22        	jr		nz, ReadWriteFileSectionEnd
 769+ 7691
 770+ 7691 3A 8F 7F     	ld		a, (CopyFileSectCnt)
 771+ 7694 47           	ld		b, a
 772+ 7695
 773+ 7695              ReadWriteFileSectionLoop:
 774+ 7695 C5           	push	bc
 775+ 7696 DD 2A 89 7F  		ld		ix, (CopyFileDMAAddr)
 776+ 769A CD D7 72     		call 	BDOSSetDMA
 777+ 769D DD 24        		inc		ixh
 778+ 769F DD 22 89 7F  		ld		(CopyFileDMAAddr), ix
 779+ 76A3
 780+ 76A3 DD 2A 86 7F  		ld		ix, (CopyFileFCB)
 781+ 76A7              CopyFileOperAddr2 EQU $ + 1
 782+ 76A7 CD BD 72     		call 	BDOSReadFileBlockSeq
 783+ 76AA 32 88 7F     		ld		(CopyFileRes), a
 784+ 76AD C1           	pop		bc
 785+ 76AE B7           	or		a
 786+ 76AF 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 787+ 76B1 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 788+ 76B3
 789+ 76B3              ReadWriteFileSectionEnd:
 790+ 76B3              	;Update sector count variable with how many sectors were transfered.
 791+ 76B3 D9           	exx
 792+ 76B4 78           	ld		a, b
 793+ 76B5 D9           	exx
 794+ 76B6 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 795+ 76B7 32 8F 7F     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 796+ 76BA
 797+ 76BA              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 798+ 76BA CD DB 72     	call	BDOSSetRandFilePtr
 799+ 76BD DD 5E 21     	ld		e, (ix + FCB_R0)
 800+ 76C0 DD 56 22     	ld		d, (ix + FCB_R1)
 801+ 76C3              CopyFilePtr2 EQU $+2
 802+ 76C3 ED 53 8B 7F  	ld		(FilePosRead), de
 803+ 76C7
 804+ 76C7 CD B9 72     	call 	BDOSCloseFile
 805+ 76CA CD A7 72     	call 	DestroyChannel
 806+ 76CD
 807+ 76CD ED 5B 89 7F  	ld		de, (CopyFileDMAAddr)
 808+ 76D1 15           	dec		d
 809+ 76D2 C9           	ret
 810+ 76D3
 811+ 76D3              	ENDIF
 812+ 76D3
# file closed: bdos.asm
1363  76D3              	include "ui.asm"
# file opened: ui.asm
   1+ 76D3              ;UI related functions
   2+ 76D3
   3+ 76D3              	ifndef	_UI_
   4+ 76D3              	define	_UI_
   5+ 76D3
   6+ 76D3              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++76D3              	ifndef	_HCCFG_
   2++76D3 ~            	define	_HCCFG_
   3++76D3 ~
   4++76D3 ~            ;HC specific code, for configuration
   5++76D3 ~
   6++76D3 ~            HC_CFG_PORT			EQU	$7E
   7++76D3 ~            HC_FLOPPY_PORT		EQU 7
   8++76D3 ~
   9++76D3 ~            ;BASIC/CPM ROM selection
  10++76D3 ~            HC_CFG_ROM_BAS		EQU	%0
  11++76D3 ~            HC_CFG_ROM_CPM		EQU	%1
  12++76D3 ~
  13++76D3 ~            ;Address for ROM paging: 0 or $E000
  14++76D3 ~            HC_CFG_ROM_0000		EQU %00
  15++76D3 ~            HC_CFG_ROM_E000		EQU %10
  16++76D3 ~
  17++76D3 ~            ;Cfg. port Enable/Disable
  18++76D3 ~            HC_CFG_PORT_DIS		EQU %000
  19++76D3 ~            HC_CFG_PORT_EN		EQU	%100
  20++76D3 ~
  21++76D3 ~            ;Video memory bank: $4000 or $C000
  22++76D3 ~            HC_CFG_VID_4000		EQU	%0000
  23++76D3 ~            HC_CFG_VID_C000		EQU	%1000
  24++76D3 ~
  25++76D3 ~
  26++76D3 ~            ;Standar BASIC config
  27++76D3 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++76D3 ~            ;Standar CP/M config
  29++76D3 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++76D3 ~
  31++76D3 ~
  32++76D3 ~            HC_VID_BANK0		EQU	$4000
  33++76D3 ~            HC_VID_BANK1		EQU	$C000
  34++76D3 ~
  35++76D3 ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++76D3 ~            ;Info from Rares Atodiresei.
  37++76D3 ~            IsDrive2_80Tracks:
  38++76D3 ~            	IFUSED
  39++76D3 ~            	in	a, (HC_FLOPPY_PORT)
  40++76D3 ~            	and %10
  41++76D3 ~            	ret
  42++76D3 ~            	ENDIF
  43++76D3 ~
  44++76D3              	endif
# file closed: hccfg.asm
   7+ 76D3
   8+ 76D3              COL             EQU 23728
   9+ 76D3              LINE            EQU 23729               ;Coordinates
  10+ 76D3              LineCol			EQU	COL
  11+ 76D3              CODE			EQU 23681               ;Char to print
  12+ 76D3
  13+ 76D3              CPM_FNT         EQU $25AB
  14+ 76D3
  15+ 76D3              PORT_ZX			EQU	$FE
  16+ 76D3
  17+ 76D3              ;COLORS
  18+ 76D3              CLR_BLACK		EQU 0
  19+ 76D3              CLR_BLUE		EQU 1
  20+ 76D3              CLR_RED			EQU 2
  21+ 76D3              CLR_MAGENTA		EQU 3
  22+ 76D3              CLR_GREEN		EQU 4
  23+ 76D3              CLR_CYAN		EQU	5
  24+ 76D3              CLR_YELLOW		EQU	6
  25+ 76D3              CLR_WHITE		EQU	7
  26+ 76D3              CLR_BRIGHT		EQU	%01000000
  27+ 76D3              CLR_FLASH		EQU	%10000000
  28+ 76D3
  29+ 76D3              ;PAPER
  30+ 76D3              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 76D3              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 76D3              PAPER_RED		EQU (CLR_RED << 3)
  33+ 76D3              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 76D3              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 76D3              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 76D3              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 76D3              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 76D3
  39+ 76D3              ;INK
  40+ 76D3              INK_BLACK		EQU CLR_BLACK
  41+ 76D3              INK_BLUE		EQU CLR_BLUE
  42+ 76D3              INK_RED			EQU CLR_RED
  43+ 76D3              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 76D3              INK_GREEN		EQU CLR_GREEN
  45+ 76D3              INK_CYAN		EQU	CLR_CYAN
  46+ 76D3              INK_YELLOW		EQU	CLR_YELLOW
  47+ 76D3              INK_WHITE		EQU	CLR_WHITE
  48+ 76D3
  49+ 76D3
  50+ 76D3              SCR_ATTR_ADDR	EQU 22528
  51+ 76D3              SCR_ADDR		EQU 16384
  52+ 76D3              SCR_PIX_LEN		EQU	6144
  53+ 76D3              SCR_ATTR_LEN	EQU	768
  54+ 76D3              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 76D3              SCR_BYTES_PER_LINE	EQU	32
  56+ 76D3
  57+ 76D3              SCR_COLS		EQU	64
  58+ 76D3              SCR_LINES		EQU 24
  59+ 76D3
  60+ 76D3              ;used for file names list positioning
  61+ 76D3              LST_LINES_CNT	EQU	21
  62+ 76D3              LST_FIRST_LINE	EQU	1
  63+ 76D3              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 76D3              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 76D3              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 76D3              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 76D3              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 76D3              LST_FIRST_COL	EQU	16
  69+ 76D3              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 76D3
  71+ 76D3              ;key codes
  72+ 76D3              KEY_ESC			EQU	7
  73+ 76D3              KEY_LEFT		EQU	8
  74+ 76D3              KEY_RIGHT		EQU	9
  75+ 76D3              KEY_DOWN		EQU	10
  76+ 76D3              KEY_UP			EQU	11
  77+ 76D3              KEY_BACKSP		EQU 12
  78+ 76D3              KEY_ENTER		EQU	13
  79+ 76D3              KEY_CTRL		EQU	14
  80+ 76D3
  81+ 76D3              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 76D3              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 76D3              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 76D3
  85+ 76D3              ;Special formating chars
  86+ 76D3              CHR_CR			EQU	13
  87+ 76D3              CHR_LF			EQU	10
  88+ 76D3              CHR_TAB			EQU	09
  89+ 76D3
  90+ 76D3
  91+ 76D3              ;Semi-graphical chars
  92+ 76D3              ;           UC
  93+ 76D3              ;     UL +H-+--+UR
  94+ 76D3              ;        |  |  |
  95+ 76D3              ;     ML +--+--+MR
  96+ 76D3              ;        V C|  |
  97+ 76D3              ;     LL +--+--+LR
  98+ 76D3              ;           DC
  99+ 76D3              CHR_GRID        EQU 127
 100+ 76D3              CHR_V           EQU	128
 101+ 76D3              CHR_MR          EQU	129
 102+ 76D3              CHR_UR          EQU 130
 103+ 76D3              CHR_DL          EQU 131
 104+ 76D3              CHR_DC          EQU 132
 105+ 76D3              CHR_UC          EQU 133
 106+ 76D3              CHR_ML          EQU 134
 107+ 76D3              CHR_H           EQU 135
 108+ 76D3              CHR_C           EQU 136
 109+ 76D3              CHR_LR          EQU 137
 110+ 76D3              CHR_UL          EQU 138
 111+ 76D3              CHR_FULL        EQU 139
 112+ 76D3              CHR_HALF        EQU 140
 113+ 76D3
 114+ 76D3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 76D3
 116+ 76D3              ;Return read char in A
 117+ 76D3              ReadChar:
 118+ 76D3 CF           	rst 08
 119+ 76D4 1B           	DEFB 27
 120+ 76D5 C9           	ret
 121+ 76D6
 122+ 76D6              ;Checks if a key is pressed
 123+ 76D6              ;Cy=1 if key is pressed
 124+ 76D6              KbdHit:
 125+ 76D6 CF           	rst 08
 126+ 76D7 20           	DEFB 32
 127+ 76D8 C9           	ret
 128+ 76D9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 76D9
 130+ 76D9              InitFonts:
 131+ 76D9              	IFUSED
 132+ 76D9                  ;page-in CPM ROM to get fonts
 133+ 76D9 F3               di
 134+ 76DA 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 76DC D3 7E            out	(HC_CFG_PORT), a
 136+ 76DE
 137+ 76DE 21 AB 25     	ld		hl, CPM_FNT
 138+ 76E1 11 5E 8A     	ld		de, FontTable
 139+ 76E4 01 68 03     	ld		bc, 872
 140+ 76E7 ED B0        	ldir
 141+ 76E9
 142+ 76E9                  ;restore BASIC ROM
 143+ 76E9 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 76EB D3 7E            out	(HC_CFG_PORT), a
 145+ 76ED FB               ei
 146+ 76EE
 147+ 76EE C9           	ret
 148+ 76EF              	ENDIF
 149+ 76EF
 150+ 76EF              ClrScr:
 151+ 76EF 2A CE 78     	ld		hl, (CurrScrAddr)
 152+ 76F2 54           	ld		d, h
 153+ 76F3 5D           	ld		e, l
 154+ 76F4 13           	inc		de
 155+ 76F5 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 76F8 36 00        	ld		(hl), 0
 157+ 76FA ED B0        	ldir
 158+ 76FC
 159+ 76FC 23           	inc 	hl
 160+ 76FD 13           	inc		de
 161+ 76FE
 162+ 76FE 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 7701 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 7703 ED B0        	ldir
 165+ 7705
 166+ 7705              	;also set border color
 167+ 7705 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 7707 D3 FE        	out		(PORT_ZX), a
 169+ 7709
 170+ 7709 3E 45        	ld		a, SCR_DEF_CLR
 171+ 770B 32 48 5C     	ld		(23624), a
 172+ 770E C9           	ret
 173+ 770F
 174+ 770F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 770F              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 770F              PrintStr:
 177+ 770F 7E           	ld		a, (hl)
 178+ 7710 FE 20        	cp		' '
 179+ 7712 30 02        	jr		nc, GoodChar
 180+ 7714 3E 3F        	ld		a, '?'
 181+ 7716              GoodChar:
 182+ 7716 CB 7F        	bit		7, a
 183+ 7718 CB BF        	res		7, a
 184+ 771A 32 81 5C     	ld		(CODE), a
 185+ 771D ED 53 B0 5C  	ld		(LineCol), de
 186+ 7721 08           	ex		af, af'
 187+ 7722 D9           	exx
 188+ 7723 E5           	push	hl
 189+ 7724 CD 3B 78     	call 	PrintChar
 190+ 7727 E1           	pop		hl
 191+ 7728 D9           	exx
 192+ 7729 08           	ex		af, af'
 193+ 772A C0           	ret		nz
 194+ 772B
 195+ 772B 1C           	inc		e
 196+ 772C 23           	inc		hl
 197+ 772D
 198+ 772D 7B           	ld		a, e
 199+ 772E FE 40        	cp		64
 200+ 7730 38 DD        	jr		c, PrintStr
 201+ 7732 1E 00        	ld		e, 0
 202+ 7734 14           	inc		d
 203+ 7735
 204+ 7735 18 D8        	jr		PrintStr
 205+ 7737
 206+ 7737              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 7737
 208+ 7737              ;IN: HL = string, DE = coords, A = color
 209+ 7737              PrintStrClr:
 210+ 7737 32 63 77     	ld		(StrClr), a
 211+ 773A D5           	push	de
 212+ 773B CD 0F 77     		call	PrintStr
 213+ 773E E1           	pop		hl
 214+ 773F              	;get string len.
 215+ 773F 7B           	ld		a, e
 216+ 7740 95           	sub		l
 217+ 7741 1F           	rra
 218+ 7742 08           	ex		af, af'
 219+ 7743              		;line * 32
 220+ 7743 7C           		ld		a, h
 221+ 7744 17           		rla
 222+ 7745 17           		rla
 223+ 7746 11 00 00     		ld	de, 0
 224+ 7749 17           		rla
 225+ 774A CB 12        		rl	d
 226+ 774C 17           		rla
 227+ 774D CB 12        		rl	d
 228+ 774F 17           		rla
 229+ 7750 CB 12        		rl	d
 230+ 7752 5F           		ld	e, a
 231+ 7753
 232+ 7753 26 00        		ld		h, 0
 233+ 7755 19           		add		hl, de
 234+ 7756 ED 5B D0 78  		ld		de, (CurrScrAttrAddr)
 235+ 775A 19           		add		hl, de
 236+ 775B 08           	ex		af, af'
 237+ 775C 4F           	ld		c, a
 238+ 775D 06 00        	ld		b, 0
 239+ 775F 54           	ld		d, h
 240+ 7760 5D           	ld		e, l
 241+ 7761 13           	inc 	de
 242+ 7762              StrClr	EQU	$ + 1
 243+ 7762 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 7764 ED B0        	ldir
 245+ 7766 C9           	ret
 246+ 7767              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 7767
 248+ 7767              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 7767              DrawLine:
 250+ 7767 32 81 5C     	ld		(CODE), a
 251+ 776A
 252+ 776A 38 04        	jr		c, VertDir
 253+ 776C 3E 1C        	ld		a, $1C
 254+ 776E 18 02        	jr		StoreDir
 255+ 7770              VertDir:
 256+ 7770 3E 14        	ld		a, $14
 257+ 7772              StoreDir:
 258+ 7772 32 82 77     	ld		(LineDir), a
 259+ 7775
 260+ 7775              DrawLineLoop:
 261+ 7775 ED 53 B0 5C  	ld		(LineCol), de
 262+ 7779 D5           	push	de
 263+ 777A D9           		exx
 264+ 777B E5           		push	hl
 265+ 777C CD 3B 78     		call 	PrintChar
 266+ 777F E1           		pop		hl
 267+ 7780 D9           		exx
 268+ 7781 D1           	pop		de
 269+ 7782              LineDir:
 270+ 7782 1C           	inc		e
 271+ 7783 10 F0        	djnz	DrawLineLoop
 272+ 7785
 273+ 7785 C9           	ret
 274+ 7786
 275+ 7786              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 7786
 277+ 7786              DrawHLines:
 278+ 7786 11 00 00     	ld		de, 0
 279+ 7789 06 40        	ld		b, 64
 280+ 778B 3E 87        	ld		a, CHR_H
 281+ 778D B7           	or		a
 282+ 778E CD 67 77     	call	DrawLine
 283+ 7791
 284+ 7791 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 7794 06 40        	ld		b, 64
 286+ 7796 3E 87        	ld		a, CHR_H
 287+ 7798 B7           	or		a
 288+ 7799 CD 67 77     	call	DrawLine
 289+ 779C
 290+ 779C 06 04        	ld		b, 4
 291+ 779E 11 10 00     	ld		de, LST_FIRST_COL
 292+ 77A1              DrawUpperIntersectLoop:
 293+ 77A1 C5           	push	bc
 294+ 77A2 D5           	push	de
 295+ 77A3 3E 85        		ld		a, CHR_UC
 296+ 77A5 CD C7 77     		call	DrawIntersect
 297+ 77A8 D1           	pop		de
 298+ 77A9 C1           	pop		bc
 299+ 77AA 21 0C 00     	ld		hl, NAMELEN+1
 300+ 77AD 19           	add		hl, de
 301+ 77AE EB           	ex		de, hl
 302+ 77AF 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 77B1
 304+ 77B1 06 04        	ld		b, 4
 305+ 77B3 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 77B6              DrawLowerIntersectLoop:
 307+ 77B6 C5           	push	bc
 308+ 77B7 D5           	push	de
 309+ 77B8 3E 84        		ld		a, CHR_DC
 310+ 77BA CD C7 77     		call	DrawIntersect
 311+ 77BD D1           	pop		de
 312+ 77BE C1           	pop		bc
 313+ 77BF 21 0C 00     	ld		hl, NAMELEN+1
 314+ 77C2 19           	add		hl, de
 315+ 77C3 EB           	ex		de, hl
 316+ 77C4 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 77C6
 318+ 77C6 C9           	ret
 319+ 77C7
 320+ 77C7
 321+ 77C7              DrawIntersect:
 322+ 77C7 21 B0 5C     	ld		hl, LineCol
 323+ 77CA 73 23 72 2B  	ld		(hl), de
 324+ 77CE 32 81 5C     	ld		(CODE), a
 325+ 77D1 E5           	push	hl
 326+ 77D2 CD 3B 78     	call	PrintChar
 327+ 77D5 E1           	pop		hl
 328+ 77D6 34           	inc		(hl)
 329+ 77D7 3E 87        	ld		a, CHR_H
 330+ 77D9 32 81 5C     	ld		(CODE), a
 331+ 77DC CD 3B 78     	call	PrintChar
 332+ 77DF C9           	ret
 333+ 77E0
 334+ 77E0
 335+ 77E0              DrawVLines:
 336+ 77E0 06 04        	ld		b, 4
 337+ 77E2 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 338+ 77E5              DrawVLinesLoop:
 339+ 77E5 C5           	push 	bc
 340+ 77E6 D5           	push	de
 341+ 77E7 06 15        		ld		b, LST_LINES_CNT
 342+ 77E9 3E 80        		ld		a, CHR_V
 343+ 77EB 37           		scf
 344+ 77EC CD 67 77     		call	DrawLine
 345+ 77EF D1           	pop		de
 346+ 77F0 C1           	pop	bc
 347+ 77F1 7B           	ld		a, e
 348+ 77F2 C6 0C        	add		NAMELEN+1
 349+ 77F4 5F           	ld		e, a
 350+ 77F5 10 EE        	djnz	DrawVLinesLoop
 351+ 77F7 C9           	ret
 352+ 77F8
 353+ 77F8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 354+ 77F8
 355+ 77F8              ;IN: A = color mask
 356+ 77F8              DrawCursor:
 357+ 77F8 ED 5B 7D 7F  	ld	de, (CursorAddr)
 358+ 77FC 06 06        	ld	b, 	(NAMELEN + 1)/2
 359+ 77FE              DrawCursorLoop:
 360+ 77FE 12           	ld	(de), a
 361+ 77FF 13           	inc de
 362+ 7800 10 FC        	djnz DrawCursorLoop
 363+ 7802 C9           	ret
 364+ 7803
 365+ 7803              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 366+ 7803
 367+ 7803              ;IN:	A = file idx.
 368+ 7803              MoveCursor:
 369+ 7803              	;File idx / SCR_LINES => cursor line & column
 370+ 7803 6F           	ld		l, a
 371+ 7804 26 00        	ld		h, 0
 372+ 7806 0E 15        	ld		c, LST_LINES_CNT
 373+ 7808 CD 7C 6E     	call	Div					;HL = file column, A = line
 374+ 780B
 375+ 780B              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 376+ 780B C6 01        	add		LST_FIRST_LINE
 377+ 780D
 378+ 780D
 379+ 780D 54           	ld d, h
 380+ 780E 5D           	ld e, l
 381+ 780F 21 00 00     	ld	hl, 0
 382+ 7812
 383+ 7812              	;line*32
 384+ 7812 17           	rla
 385+ 7813 17           	rla
 386+ 7814 17           	rla
 387+ 7815 17           	rla
 388+ 7816 CB 14        	rl h
 389+ 7818 17           	rla
 390+ 7819 CB 14        	rl h
 391+ 781B 6F           	ld l, a
 392+ 781C
 393+ 781C
 394+ 781C              	;col * 6
 395+ 781C E5           	push	hl					;save line * 32
 396+ 781D 3E 06        		ld		a, (NAMELEN + 1)/2
 397+ 781F CD 9C 6E     		call	Mul				;HL = column * 12/2
 398+ 7822 D1           	pop		de
 399+ 7823 19           	add		hl, de
 400+ 7824
 401+ 7824 11 08 00     	ld		de, LST_FIRST_COL/2
 402+ 7827 ED 4B D0 78  	ld		bc, (CurrScrAttrAddr)
 403+ 782B 19           	add		hl, de
 404+ 782C 09           	add		hl, bc
 405+ 782D
 406+ 782D              	;clear old cursor
 407+ 782D 3E 45        	ld		a, SCR_DEF_CLR
 408+ 782F CD F8 77     	call	DrawCursor
 409+ 7832
 410+ 7832              	;draw new one
 411+ 7832 22 7D 7F     	ld		(CursorAddr), hl
 412+ 7835 3E 60        	ld		a, SCR_SEL_CLR
 413+ 7837 CD F8 77     	call	DrawCursor
 414+ 783A
 415+ 783A C9           	ret
 416+ 783B
 417+ 783B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 418+ 783B
 419+ 783B              PrintChar:
 420+ 783B ED 5B B0 5C      ld		de, (LineCol)
 421+ 783F
 422+ 783F                  ;calculate 64 column screen address
 423+ 783F              	;IN: D = line, E = col
 424+ 783F              	;OUT: HL = screen address
 425+ 783F
 426+ 783F CB 3B            SRL     E                                       ;col = col/2
 427+ 7841 CB 19            RR      C                                       ;mark odd/even column
 428+ 7843 7A               LD      A, D                            ;A = line
 429+ 7844 E6 18            AND 24                                  ;keep only %00011000
 430+ 7846 2A CE 78         ld		hl, (CurrScrAddr)
 431+ 7849 B4               OR      h								;add screen start address
 432+ 784A 67               LD      H, A                            ;save H
 433+ 784B 7A               LD      A, D                            ;A = line
 434+ 784C E6 07            AND 7                                   ;keep only %00000111
 435+ 784E 0F               RRCA                                    ;%10000011
 436+ 784F 0F               RRCA                                    ;%11000001
 437+ 7850 0F               RRCA                                    ;%11100000
 438+ 7851 B3               OR      E                                       ;add column
 439+ 7852 6F               LD      L, A                            ;HL = screen address
 440+ 7853
 441+ 7853              PrintChar3:
 442+ 7853                  ;get font address
 443+ 7853 E5               PUSH HL
 444+ 7854 AF                   XOR A
 445+ 7855 67                   LD  H, A
 446+ 7856 3A 81 5C             LD  A, (CODE)
 447+ 7859 D6 20                SUB ' '
 448+ 785B 6F                   LD  L, A
 449+ 785C 29                   ADD     HL, HL                  ;char code = char code * 8
 450+ 785D 29                   ADD     HL, HL                  ;i.e. offset into font table
 451+ 785E 29                   ADD     HL, HL
 452+ 785F 11 5E 8A             LD      DE, FontTable             ;get font table
 453+ 7862 19                   ADD     HL, DE
 454+ 7863 EB                   EX      DE, HL                  ;DE = our char font address
 455+ 7864 E1               POP     HL
 456+ 7865
 457+ 7865
 458+ 7865                  ;print a char
 459+ 7865 06 08            LD      B, 8                            ;char height is 8 lines
 460+ 7867              PrintCharLine:
 461+ 7867 1A                   LD      A, (DE)                         ;load char line in A
 462+ 7868
 463+ 7868 CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 464+ 786A 20 06                JR  	NZ, NoTurn
 465+ 786C
 466+ 786C 07                   RLCA
 467+ 786D 07                   RLCA
 468+ 786E 07                   RLCA
 469+ 786F 07                   RLCA
 470+ 7870 18 01                JR      Store
 471+ 7872              NoTurn:
 472+ 7872 B6                   OR (HL)
 473+ 7873              Store:
 474+ 7873 77                   LD (HL), A
 475+ 7874
 476+ 7874 13                   INC     DE                                      ;next char line in font table
 477+ 7875 24                   INC     H                                       ;next char line on screen
 478+ 7876 10 EF            DJNZ PrintCharLine                  ;last line of char?
 479+ 7878
 480+ 7878 C9               ret
 481+ 7879
 482+ 7879              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 483+ 7879
 484+ 7879              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 485+ 7879              ReadString:
 486+ 7879 21 C6 8D     	ld		hl, FileData
 487+ 787C D5           	push	de
 488+ 787D DD E1        	pop		ix
 489+ 787F
 490+ 787F              ReadStringLoop:
 491+ 787F D5           	push	de
 492+ 7880 E5           	push	hl
 493+ 7881 CD D3 76     		call ReadChar
 494+ 7884 E1           	pop		hl
 495+ 7885 D1           	pop		de
 496+ 7886
 497+ 7886 FE 0D        	cp	KEY_ENTER
 498+ 7888 C8           	ret z
 499+ 7889
 500+ 7889 FE 0C        	cp  KEY_BACKSP
 501+ 788B 20 0F        	jr	nz, ReadStrChar
 502+ 788D
 503+ 788D E5           	push hl
 504+ 788E 01 C7 8D     	ld   bc, FileData+1
 505+ 7891 ED 42        	sbc	 hl, bc
 506+ 7893 E1           	pop  hl
 507+ 7894 38 16        	jr   c, ReadStrPrint
 508+ 7896
 509+ 7896 1B           	dec	de
 510+ 7897 2B           	dec	hl
 511+ 7898 36 20        	ld	(hl), ' '
 512+ 789A 18 10        	jr	ReadStrPrint
 513+ 789C
 514+ 789C              ReadStrChar:
 515+ 789C FE 20        	cp	' '
 516+ 789E 38 DF        	jr	c, ReadStringLoop
 517+ 78A0 FE 7F        	cp  127
 518+ 78A2 30 DB        	jr	nc, ReadStringLoop
 519+ 78A4
 520+ 78A4              	;Check end of string and go back if found.
 521+ 78A4 46           	ld	b, (hl)
 522+ 78A5 CB 78        	bit 7, b
 523+ 78A7 20 03        	jr	nz, ReadStrPrint
 524+ 78A9
 525+ 78A9 77           	ld	(hl), a
 526+ 78AA 23           	inc	hl
 527+ 78AB 13           	inc	de
 528+ 78AC
 529+ 78AC              ReadStrPrint:
 530+ 78AC E5           	push	hl
 531+ 78AD D5           	push	de
 532+ 78AE 21 C6 8D     	ld		hl, FileData
 533+ 78B1 DD E5        	push	ix
 534+ 78B3 D1           	pop		de
 535+ 78B4 CD 0F 77     	call	PrintStr
 536+ 78B7 D1           	pop		de
 537+ 78B8 E1           	pop		hl
 538+ 78B9
 539+ 78B9 18 C4        	jr		ReadStringLoop
 540+ 78BB
 541+ 78BB              ClearNMsgLines:
 542+ 78BB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 543+ 78BE              ClearNMsgLinesLoop:
 544+ 78BE D5           	push	de
 545+ 78BF C5           	push	bc
 546+ 78C0 21 37 7E     	ld		hl, MsgClear
 547+ 78C3 3E 45        	ld		a, SCR_DEF_CLR
 548+ 78C5 CD 37 77     	call	PrintStrClr
 549+ 78C8 C1           	pop		bc
 550+ 78C9 D1           	pop		de
 551+ 78CA 14           	inc		d
 552+ 78CB 10 F1        	djnz	ClearNMsgLinesLoop
 553+ 78CD
 554+ 78CD C9           	ret
 555+ 78CE
 556+ 78CE 00 40        CurrScrAddr		DEFW	SCR_ADDR
 557+ 78D0 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 558+ 78D2
 559+ 78D2                 	endif
# file closed: ui.asm
1364  78D2              	include "math.asm"
# file opened: math.asm
   1+ 78D2              	ifndef	_MATH_
   2+ 78D2 ~            	define	_MATH_
   3+ 78D2 ~
   4+ 78D2 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 78D2 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 78D2 ~
   7+ 78D2 ~
   8+ 78D2 ~            Word2Txt:
   9+ 78D2 ~            	IFUSED
  10+ 78D2 ~            	push	de
  11+ 78D2 ~            		call	Word2Txt_
  12+ 78D2 ~            	pop		de
  13+ 78D2 ~
  14+ 78D2 ~            	ld		b, 4
  15+ 78D2 ~            	call	StrippLeading0
  16+ 78D2 ~            	ret
  17+ 78D2 ~
  18+ 78D2 ~            Byte2Txt:
  19+ 78D2 ~            	push	de
  20+ 78D2 ~            		call	Byte2Txt_
  21+ 78D2 ~            	pop		de
  22+ 78D2 ~
  23+ 78D2 ~            	ld		b, 2
  24+ 78D2 ~            	call	StrippLeading0
  25+ 78D2 ~            	ret
  26+ 78D2 ~            	ENDIF
  27+ 78D2 ~
  28+ 78D2 ~
  29+ 78D2 ~            StrippLeading0:
  30+ 78D2 ~            	ld		a, (de)
  31+ 78D2 ~            	cp		'1'
  32+ 78D2 ~            	ret		nc
  33+ 78D2 ~
  34+ 78D2 ~            	ld		a, ' '
  35+ 78D2 ~            	ld		(de), a
  36+ 78D2 ~            	inc		de
  37+ 78D2 ~            	djnz	StrippLeading0
  38+ 78D2 ~            	ret
  39+ 78D2 ~
  40+ 78D2 ~
  41+ 78D2 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 78D2 ~            Word2Txt_:
  43+ 78D2 ~            	ld bc, -10000
  44+ 78D2 ~            	call DigitLoop
  45+ 78D2 ~            	ld bc, -1000
  46+ 78D2 ~            	call DigitLoop
  47+ 78D2 ~            Byte2Txt_:
  48+ 78D2 ~            	ld bc, -100
  49+ 78D2 ~            	call DigitLoop
  50+ 78D2 ~            	ld bc, -10
  51+ 78D2 ~            	call DigitLoop
  52+ 78D2 ~            	ld bc, -1
  53+ 78D2 ~
  54+ 78D2 ~            DigitLoop:
  55+ 78D2 ~            	ld	a, '0' - 1
  56+ 78D2 ~            DivNrLoop:
  57+ 78D2 ~            	inc	a			;increase reminder
  58+ 78D2 ~            	add	hl, bc		;substract divizor
  59+ 78D2 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 78D2 ~            	sbc	hl, bc		;nope, restore
  61+ 78D2 ~
  62+ 78D2 ~            	ld (de), a
  63+ 78D2 ~            	inc de
  64+ 78D2 ~            	ret
  65+ 78D2 ~
  66+ 78D2 ~
  67+ 78D2 ~            ;Input: HL = Dividend, C = Divisor
  68+ 78D2 ~            ;Output: HL = Quotient, A = Remainder
  69+ 78D2 ~            ;Warning: doesn't work with divisor >= $80
  70+ 78D2 ~            Div:
  71+ 78D2 ~            	IFUSED
  72+ 78D2 ~            	xor a
  73+ 78D2 ~            	ld b, 16
  74+ 78D2 ~
  75+ 78D2 ~            DivLoop:
  76+ 78D2 ~            	add	hl,hl
  77+ 78D2 ~            	rla
  78+ 78D2 ~            	cp	c
  79+ 78D2 ~            	jr	c, NoSub
  80+ 78D2 ~            	sub	c
  81+ 78D2 ~            	inc	l
  82+ 78D2 ~            NoSub:
  83+ 78D2 ~            	djnz DivLoop
  84+ 78D2 ~
  85+ 78D2 ~            	ret
  86+ 78D2 ~            	ENDIF
  87+ 78D2 ~
  88+ 78D2 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 78D2 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 78D2 ~            Div2:
  91+ 78D2 ~            	ld hl, 0
  92+ 78D2 ~            	ld b, 16
  93+ 78D2 ~            Div2Loop:
  94+ 78D2 ~            	sll c		; unroll 16 times
  95+ 78D2 ~            	rla			; ...
  96+ 78D2 ~            	adc	hl,hl		; ...
  97+ 78D2 ~            	sbc	hl,de		; ...
  98+ 78D2 ~            	jr	nc,$+4		; ...
  99+ 78D2 ~            	add	hl,de		; ...
 100+ 78D2 ~            	dec	c		; ...
 101+ 78D2 ~            	djnz Div2Loop
 102+ 78D2 ~            	ret
 103+ 78D2 ~
 104+ 78D2 ~
 105+ 78D2 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 78D2 ~            ;Output: A:HL = Product
 107+ 78D2 ~            Mul:
 108+ 78D2 ~            	IFUSED
 109+ 78D2 ~            	ld hl, 0
 110+ 78D2 ~            	ld bc, $0700
 111+ 78D2 ~
 112+ 78D2 ~            	add	a, a		; optimised 1st iteration
 113+ 78D2 ~            	jr	nc, MulLoop
 114+ 78D2 ~            	ld	h, d
 115+ 78D2 ~            	ld	l, e
 116+ 78D2 ~
 117+ 78D2 ~            MulLoop:
 118+ 78D2 ~            	add	hl,hl
 119+ 78D2 ~            	rla
 120+ 78D2 ~            	jr	nc, NoAdd
 121+ 78D2 ~            	add	hl,de
 122+ 78D2 ~            	adc	a,c
 123+ 78D2 ~            NoAdd:
 124+ 78D2 ~            	djnz MulLoop
 125+ 78D2 ~
 126+ 78D2 ~            	ret
 127+ 78D2 ~            	ENDIF
 128+ 78D2 ~
 129+ 78D2              	endif
# file closed: math.asm
1365  78D2              	include "txtview.asm"
# file opened: txtview.asm
   1+ 78D2              LINE_CNT	EQU	23
   2+ 78D2              COL_CNT		EQU	64
   3+ 78D2
   4+ 78D2              CHAR_CR		EQU	$0D
   5+ 78D2              CHAR_LF		EQU	$0A
   6+ 78D2              CHAR_TAB	EQU	$09
   7+ 78D2              CHAR_EOF	EQU	$1A
   8+ 78D2
   9+ 78D2              COORDS		EQU	23728		;Coordinates
  10+ 78D2              SCRLinesDown	EQU PRN_BUF
  11+ 78D2              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
  12+ 78D2
  13+ 78D2
  14+ 78D2              	include "scroll.asm"
# file opened: scroll.asm
   1++78D2              ;Scrolling routines for UP/DOWN
   2++78D2              ;They use 2 tables of pointers of screen cell rows.
   3++78D2              ;One table has addresses in increasing order, for scroll down,
   4++78D2              ;the other in decreasing order, for scroll up, so the same
   5++78D2              ;scroll routine is used in both cases.
   6++78D2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++78D2
   8++78D2              ; Char Down
   9++78D2              ; Adjusts screen address HL to move eight pixels down on the display.
  10++78D2              ; enter: HL = valid screen address
  11++78D2              ; exit : HL = moves one character down
  12++78D2              ; used : AF, HL
  13++78D2              GetCellDown:
  14++78D2 7D           	ld a,l
  15++78D3 C6 20        	add a,$20
  16++78D5 6F           	ld l,a
  17++78D6 D0           	ret nc
  18++78D7 7C           	ld a,h
  19++78D8 C6 08        	add a,$08
  20++78DA 67           	ld h,a
  21++78DB C9           	ret
  22++78DC
  23++78DC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++78DC              ;Fills the two tables with pointers.
  25++78DC              ScrollInit:
  26++78DC 21 00 40     	ld		hl, SCR_ADDR
  27++78DF 06 17        	ld		b, LINE_CNT
  28++78E1 DD 21 00 5B  	ld		ix, SCRLinesDown
  29++78E5
  30++78E5              	;Don't init again if already did it.
  31++78E5 DD 7E 00     	ld		a, (ix)
  32++78E8 BD           	cp		l
  33++78E9 20 05        	jr		nz, FillScrLinesLoop
  34++78EB DD 7E 01     	ld		a, (ix+1)
  35++78EE BC           	cp		h
  36++78EF C8           	ret		z
  37++78F0
  38++78F0              FillScrLinesLoop:
  39++78F0 DD 75 00     	ld		(ix), l
  40++78F3 DD 74 01     	ld		(ix+1), h
  41++78F6 DD 23        	inc		ix
  42++78F8 DD 23        	inc		ix
  43++78FA              	;inc. pointer in destination table (of pointers to lines)
  44++78FA CD D2 78     	call	GetCellDown
  45++78FD 10 F1        	djnz	FillScrLinesLoop
  46++78FF
  47++78FF              	;now fill the table in reverse, every 2 bytes
  48++78FF DD E5        	push	ix
  49++7901 E1           	pop		hl
  50++7902 2B           	dec		hl
  51++7903 06 17        	ld		b, LINE_CNT
  52++7905              FillScrLinesRev:
  53++7905 56           	ld		d, (hl)
  54++7906 2B           	dec		hl
  55++7907 5E           	ld		e, (hl)
  56++7908 2B           	dec		hl
  57++7909
  58++7909 DD 73 00     	ld		(ix), e
  59++790C DD 72 01     	ld		(ix+1), d
  60++790F DD 23        	inc		ix
  61++7911 DD 23        	inc		ix
  62++7913 10 F0        	djnz	FillScrLinesRev
  63++7915 C9           	ret
  64++7916
  65++7916              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  66++7916              ScrollUp:
  67++7916 21 2E 5B     	ld		hl, SCRLinesUp
  68++7919 18 03        	jr		Scroll
  69++791B
  70++791B              ScrollDown:
  71++791B 21 00 5B     	ld		hl, SCRLinesDown
  72++791E
  73++791E              Scroll:
  74++791E 22 2C 79     	ld		(ScrollDownPtrDest), hl
  75++7921 23           	inc		hl
  76++7922 23           	inc		hl
  77++7923 22 2F 79     	ld		(ScrollDownPtrSrc), hl
  78++7926 0E 16        	ld		c, LINE_CNT - 1
  79++7928
  80++7928              ScrollDownLoop2:
  81++7928 06 04        	ld		b, 4
  82++792A              ScrollDownPtrDest	EQU	$ + 2
  83++792A ED 5B 00 5B  	ld		de, (SCRLinesDown)
  84++792E              ScrollDownPtrSrc	EQU	$ + 1
  85++792E 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  86++7931
  87++7931              ScrollDownLoop:					;copy a single char line
  88++7931 C5           	push	bc
  89++7932 01 20 00     	ld		bc, 32
  90++7935 ED B0        	ldir
  91++7937 2B           	dec		hl
  92++7938 1B           	dec		de
  93++7939 24           	inc		h
  94++793A 14           	inc		d
  95++793B 01 20 00     	ld		bc, 32
  96++793E ED B8        	lddr
  97++7940 23           	inc		hl
  98++7941 13           	inc		de
  99++7942 24           	inc		h
 100++7943 14           	inc		d
 101++7944 C1           	pop		bc
 102++7945 10 EA        	djnz	ScrollDownLoop
 103++7947
 104++7947 0D           	dec		c
 105++7948 C8           	ret		z
 106++7949
 107++7949 2A 2F 79     	ld		hl, (ScrollDownPtrSrc)
 108++794C 22 2C 79     	ld		(ScrollDownPtrDest), hl
 109++794F 23           	inc		hl
 110++7950 23           	inc		hl
 111++7951 22 2F 79     	ld		(ScrollDownPtrSrc), hl
 112++7954 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
  15+ 7956              	include "math.asm"
# file opened: math.asm
   1++7956              	ifndef	_MATH_
   2++7956 ~            	define	_MATH_
   3++7956 ~
   4++7956 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++7956 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6++7956 ~
   7++7956 ~
   8++7956 ~            Word2Txt:
   9++7956 ~            	IFUSED
  10++7956 ~            	push	de
  11++7956 ~            		call	Word2Txt_
  12++7956 ~            	pop		de
  13++7956 ~
  14++7956 ~            	ld		b, 4
  15++7956 ~            	call	StrippLeading0
  16++7956 ~            	ret
  17++7956 ~
  18++7956 ~            Byte2Txt:
  19++7956 ~            	push	de
  20++7956 ~            		call	Byte2Txt_
  21++7956 ~            	pop		de
  22++7956 ~
  23++7956 ~            	ld		b, 2
  24++7956 ~            	call	StrippLeading0
  25++7956 ~            	ret
  26++7956 ~            	ENDIF
  27++7956 ~
  28++7956 ~
  29++7956 ~            StrippLeading0:
  30++7956 ~            	ld		a, (de)
  31++7956 ~            	cp		'1'
  32++7956 ~            	ret		nc
  33++7956 ~
  34++7956 ~            	ld		a, ' '
  35++7956 ~            	ld		(de), a
  36++7956 ~            	inc		de
  37++7956 ~            	djnz	StrippLeading0
  38++7956 ~            	ret
  39++7956 ~
  40++7956 ~
  41++7956 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42++7956 ~            Word2Txt_:
  43++7956 ~            	ld bc, -10000
  44++7956 ~            	call DigitLoop
  45++7956 ~            	ld bc, -1000
  46++7956 ~            	call DigitLoop
  47++7956 ~            Byte2Txt_:
  48++7956 ~            	ld bc, -100
  49++7956 ~            	call DigitLoop
  50++7956 ~            	ld bc, -10
  51++7956 ~            	call DigitLoop
  52++7956 ~            	ld bc, -1
  53++7956 ~
  54++7956 ~            DigitLoop:
  55++7956 ~            	ld	a, '0' - 1
  56++7956 ~            DivNrLoop:
  57++7956 ~            	inc	a			;increase reminder
  58++7956 ~            	add	hl, bc		;substract divizor
  59++7956 ~            	jr	c, DivNrLoop	;still dividing?
  60++7956 ~            	sbc	hl, bc		;nope, restore
  61++7956 ~
  62++7956 ~            	ld (de), a
  63++7956 ~            	inc de
  64++7956 ~            	ret
  65++7956 ~
  66++7956 ~
  67++7956 ~            ;Input: HL = Dividend, C = Divisor
  68++7956 ~            ;Output: HL = Quotient, A = Remainder
  69++7956 ~            ;Warning: doesn't work with divisor >= $80
  70++7956 ~            Div:
  71++7956 ~            	IFUSED
  72++7956 ~            	xor a
  73++7956 ~            	ld b, 16
  74++7956 ~
  75++7956 ~            DivLoop:
  76++7956 ~            	add	hl,hl
  77++7956 ~            	rla
  78++7956 ~            	cp	c
  79++7956 ~            	jr	c, NoSub
  80++7956 ~            	sub	c
  81++7956 ~            	inc	l
  82++7956 ~            NoSub:
  83++7956 ~            	djnz DivLoop
  84++7956 ~
  85++7956 ~            	ret
  86++7956 ~            	ENDIF
  87++7956 ~
  88++7956 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++7956 ~            ;Output: A:C = Quotient, HL = Remainder
  90++7956 ~            Div2:
  91++7956 ~            	ld hl, 0
  92++7956 ~            	ld b, 16
  93++7956 ~            Div2Loop:
  94++7956 ~            	sll c		; unroll 16 times
  95++7956 ~            	rla			; ...
  96++7956 ~            	adc	hl,hl		; ...
  97++7956 ~            	sbc	hl,de		; ...
  98++7956 ~            	jr	nc,$+4		; ...
  99++7956 ~            	add	hl,de		; ...
 100++7956 ~            	dec	c		; ...
 101++7956 ~            	djnz Div2Loop
 102++7956 ~            	ret
 103++7956 ~
 104++7956 ~
 105++7956 ~            ;Input: A = Multiplier, DE = Multiplicand
 106++7956 ~            ;Output: A:HL = Product
 107++7956 ~            Mul:
 108++7956 ~            	IFUSED
 109++7956 ~            	ld hl, 0
 110++7956 ~            	ld bc, $0700
 111++7956 ~
 112++7956 ~            	add	a, a		; optimised 1st iteration
 113++7956 ~            	jr	nc, MulLoop
 114++7956 ~            	ld	h, d
 115++7956 ~            	ld	l, e
 116++7956 ~
 117++7956 ~            MulLoop:
 118++7956 ~            	add	hl,hl
 119++7956 ~            	rla
 120++7956 ~            	jr	nc, NoAdd
 121++7956 ~            	add	hl,de
 122++7956 ~            	adc	a,c
 123++7956 ~            NoAdd:
 124++7956 ~            	djnz MulLoop
 125++7956 ~
 126++7956 ~            	ret
 127++7956 ~            	ENDIF
 128++7956 ~
 129++7956              	endif
# file closed: math.asm
  16+ 7956
  17+ 7956              TextViewer:
  18+ 7956 CD 4B 7A     	call	TextViewIndex
  19+ 7959
  20+ 7959 21 00 00     	ld		hl, 0
  21+ 795C 22 B0 5C     	ld		(COORDS), hl
  22+ 795F CD DC 78     	call	ScrollInit
  23+ 7962
  24+ 7962              TextViewerLoop2:
  25+ 7962              	;Display 23 lines or less.
  26+ 7962 2A F0 7A     	ld		hl, (LineCount)
  27+ 7965 01 17 00     	ld		bc, LINE_CNT
  28+ 7968 B7           	or		a
  29+ 7969 ED 42        	sbc		hl, bc
  30+ 796B 06 17        	ld		b, LINE_CNT
  31+ 796D 30 04        	jr		nc, MoreThan23LinesInFile
  32+ 796F 2A F0 7A     	ld		hl, (LineCount)
  33+ 7972 45           	ld		b, l
  34+ 7973              MoreThan23LinesInFile:
  35+ 7973 DD 21 C6 EE  	ld		ix, FileIdx
  36+ 7977
  37+ 7977              ;Display first screen of text.
  38+ 7977              TextViewerLoop:
  39+ 7977 C5           	push	bc
  40+ 7978 CD A2 7A     		call	PrintOneLine
  41+ 797B DD 23        		inc		ix
  42+ 797D DD 23        		inc		ix
  43+ 797F DD 23        		inc		ix
  44+ 7981
  45+ 7981 ED 5B B0 5C  		ld		de, (COORDS)
  46+ 7985 14           		inc		d
  47+ 7986 1E 00        		ld		e, 0
  48+ 7988 ED 53 B0 5C  		ld		(COORDS), de
  49+ 798C C1           	pop		bc
  50+ 798D 10 E8        	djnz	TextViewerLoop
  51+ 798F
  52+ 798F 11 00 00     	ld		de, 0
  53+ 7992 ED 53 F2 7A  	ld		(FirstLineShown), de
  54+ 7996
  55+ 7996 DD 2B        	dec		ix
  56+ 7998 DD 2B        	dec		ix
  57+ 799A DD 2B        	dec		ix
  58+ 799C
  59+ 799C 2A F0 7A     	ld		hl, (LineCount)
  60+ 799F 11 12 7B     	ld		de, MsgLineTotal
  61+ 79A2 CD 35 6E     	call	Word2Txt
  62+ 79A5
  63+ 79A5              TextViewerLoop3:
  64+ 79A5 2A F2 7A     	ld		hl, (FirstLineShown)
  65+ 79A8 23           	inc		hl
  66+ 79A9 11 0C 7B     	ld		de, MsgLineNo
  67+ 79AC CD 35 6E     	call	Word2Txt
  68+ 79AF
  69+ 79AF 2A 83 7F     	ld		hl, (SelFileCache)
  70+ 79B2 11 FA 7A     	ld		de, MsgLineFileName
  71+ 79B5 06 0B        	ld		b, NAMELEN
  72+ 79B7              TextViewerShowFilename:
  73+ 79B7 7E           	ld		a, (hl)
  74+ 79B8 E6 7F        	and		$7F
  75+ 79BA 12           	ld		(de), a
  76+ 79BB 23           	inc		hl
  77+ 79BC 13           	inc		de
  78+ 79BD 10 F8        	djnz	TextViewerShowFilename
  79+ 79BF
  80+ 79BF 21 F4 7A     	ld		hl, MsgLine
  81+ 79C2 11 00 17     	ld		de, LINE_CNT << 8
  82+ 79C5 3E 60        	ld		a, SCR_SEL_CLR
  83+ 79C7 CD 37 77     	call	PrintStrClr
  84+ 79CA
  85+ 79CA CD D3 76     	call	ReadChar
  86+ 79CD
  87+ 79CD FE 0A        	cp		KEY_DOWN
  88+ 79CF 28 3A        	jr		z, TextViewerScrollDown
  89+ 79D1
  90+ 79D1 FE 0B        	cp		KEY_UP
  91+ 79D3 28 05        	jr		z, TextViewerScrollUp
  92+ 79D5
  93+ 79D5 FE 30        	cp		'0'
  94+ 79D7 C8           	ret		z
  95+ 79D8
  96+ 79D8 18 CB        	jr		TextViewerLoop3
  97+ 79DA
  98+ 79DA              TextViewerScrollUp:
  99+ 79DA              	;Do nothing if showing begining of file.
 100+ 79DA ED 5B F2 7A  	ld		de, (FirstLineShown)
 101+ 79DE 7A           	ld		a, d
 102+ 79DF B3           	or		e
 103+ 79E0 28 C3        	jr		z, TextViewerLoop3
 104+ 79E2
 105+ 79E2 1B           	dec		de
 106+ 79E3 ED 53 F2 7A  	ld		(FirstLineShown), de
 107+ 79E7
 108+ 79E7 7A           	ld		a, d
 109+ 79E8 B3           	or		e
 110+ 79E9 DD 21 C6 EE  	ld		ix, FileIdx
 111+ 79ED 28 09        	jr		z, TextViewerScrollUp1
 112+ 79EF
 113+ 79EF              	;3*FirstLineShown
 114+ 79EF 3E 03        	ld		a, 3
 115+ 79F1 CD 9C 6E     	call	Mul
 116+ 79F4 EB           	ex		de, hl
 117+ 79F5 B7           	or		a
 118+ 79F6 DD 19        	add		ix, de
 119+ 79F8
 120+ 79F8
 121+ 79F8              TextViewerScrollUp1:
 122+ 79F8 CD 16 79     	call	ScrollUp
 123+ 79FB ED 5B B0 5C  	ld		de, (COORDS)
 124+ 79FF 11 00 00     	ld		de, 0
 125+ 7A02 ED 53 B0 5C  	ld		(COORDS), de
 126+ 7A06 CD A2 7A     	call	PrintOneLine
 127+ 7A09
 128+ 7A09 18 9A        	jr		TextViewerLoop3
 129+ 7A0B
 130+ 7A0B              TextViewerScrollDown:
 131+ 7A0B              	;Exit if reached last line from file.
 132+ 7A0B 2A F2 7A     	ld		hl, (FirstLineShown)
 133+ 7A0E 01 18 00     	ld		bc, LINE_CNT+1
 134+ 7A11 B7           	or		a
 135+ 7A12 ED 4A        	adc		hl, bc
 136+ 7A14 EB           	ex		de, hl
 137+ 7A15 2A F0 7A     	ld		hl, (LineCount)
 138+ 7A18 B7           	or		a
 139+ 7A19 ED 52        	sbc		hl, de
 140+ 7A1B 38 88        	jr		c, TextViewerLoop3
 141+ 7A1D
 142+ 7A1D 2A F2 7A     	ld		hl, (FirstLineShown)
 143+ 7A20 23           	inc		hl
 144+ 7A21 22 F2 7A     	ld		(FirstLineShown), hl
 145+ 7A24 01 16 00     	ld		bc, LINE_CNT-1
 146+ 7A27 B7           	or		a
 147+ 7A28 ED 4A        	adc		hl, bc
 148+ 7A2A EB           	ex		de, hl
 149+ 7A2B
 150+ 7A2B              	;(FirstLineShown + 23	) * 3
 151+ 7A2B 3E 03        	ld		a, 3
 152+ 7A2D CD 9C 6E     	call	Mul
 153+ 7A30 EB           	ex		de, hl
 154+ 7A31 DD 21 C6 EE  	ld		ix, FileIdx
 155+ 7A35 DD 19        	add		ix, de
 156+ 7A37
 157+ 7A37 CD 1B 79     	call	ScrollDown
 158+ 7A3A ED 5B B0 5C  	ld		de, (COORDS)
 159+ 7A3E 11 00 16     	ld		de, (LINE_CNT - 1) << 8
 160+ 7A41 ED 53 B0 5C  	ld		(COORDS), de
 161+ 7A45
 162+ 7A45 CD A2 7A     	call	PrintOneLine
 163+ 7A48
 164+ 7A48 C3 A5 79     	jp		TextViewerLoop3
 165+ 7A4B
 166+ 7A4B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 167+ 7A4B
 168+ 7A4B              ;Creates line start indexes, with 2 byte address and 1 byte length for each line. Stores total line count.
 169+ 7A4B              ;IN: HL=start address, BC: length
 170+ 7A4B              TextViewIndex:
 171+ 7A4B DD 21 C6 EE  	ld		ix, FileIdx
 172+ 7A4F
 173+ 7A4F              	;Search for CHAR_EOF, to mark end of buffer there, if found.
 174+ 7A4F              	;Save initial length in DE.
 175+ 7A4F E5           	push	hl
 176+ 7A50 C5           		push	bc
 177+ 7A51 3E 1A        			ld		a, CHAR_EOF
 178+ 7A53 ED B1        			cpir
 179+ 7A55
 180+ 7A55 E5           			push	hl
 181+ 7A56 D1           			pop		de				;DE will contain the address of EOF char or end of file.
 182+ 7A57 C1           		pop		bc
 183+ 7A58 E1           	pop		hl
 184+ 7A59
 185+ 7A59 1B           	dec		de
 186+ 7A5A ED 53 EE 7A  	ld		(FileEnd), de
 187+ 7A5E
 188+ 7A5E 11 00 00     	ld		de, 0					;Assume at least one line is shown, even if empty.
 189+ 7A61 ED 53 F0 7A  	ld		(LineCount), de
 190+ 7A65
 191+ 7A65              TextViewIndexLoop:
 192+ 7A65 DD 75 00 DD  	ld		(ix), hl
 192+ 7A69 74 01
 193+ 7A6B
 194+ 7A6B 01 40 00     	ld		bc, COL_CNT			;Search CR char, might be on position 65.
 195+ 7A6E 3E 0D        	ld		a, CHAR_CR
 196+ 7A70 ED B1        	cpir
 197+ 7A72
 198+ 7A72 3E 0A        	ld		a, CHR_LF
 199+ 7A74 BE           	cp		(hl)
 200+ 7A75 20 01        	jr		nz, TextViewIndexNoLF
 201+ 7A77 23           	inc		hl						;Skip LF char.
 202+ 7A78              TextViewIndexNoLF:
 203+ 7A78
 204+ 7A78              	;If line shorter than 64 chars, calculate actual length.
 205+ 7A78 79           	ld		a, c
 206+ 7A79 B7           	or		a						;if c==0, line was 64 chars
 207+ 7A7A 3E 40        	ld		a, COL_CNT
 208+ 7A7C 28 02        	jr		z, TextViewIndexStoreLineLen
 209+ 7A7E 0C           	inc		c						;account for the CR char found.
 210+ 7A7F 91           	sub		c
 211+ 7A80
 212+ 7A80              TextViewIndexStoreLineLen:
 213+ 7A80 DD 77 02     	ld		(ix+2), a
 214+ 7A83 ED 5B F0 7A  	ld		de, (LineCount)
 215+ 7A87 13           	inc		de
 216+ 7A88 ED 53 F0 7A  	ld		(LineCount), de
 217+ 7A8C
 218+ 7A8C              	;Check end of file.
 219+ 7A8C 3E 1A        	ld		a, CHAR_EOF
 220+ 7A8E BE           	cp		(hl)
 221+ 7A8F C8           	ret		z
 222+ 7A90
 223+ 7A90              TextViewerIncrementIndex:
 224+ 7A90              	;Point to the next index position.
 225+ 7A90 DD 23        	inc		ix
 226+ 7A92 DD 23        	inc		ix
 227+ 7A94 DD 23        	inc		ix
 228+ 7A96
 229+ 7A96              TextViewerCheckEnd:
 230+ 7A96 E5           	push	hl
 231+ 7A97 EB           		ex		de, hl
 232+ 7A98 2A EE 7A     		ld		hl, (FileEnd)
 233+ 7A9B B7           		or		a
 234+ 7A9C ED 52        		sbc		hl, de
 235+ 7A9E E1           	pop		hl
 236+ 7A9F 30 C4        	jr		nc, TextViewIndexLoop
 237+ 7AA1
 238+ 7AA1              TextViewerEnd:
 239+ 7AA1 C9           	ret
 240+ 7AA2
 241+ 7AA2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 242+ 7AA2              PrintOneLine:
 243+ 7AA2 DD 6E 00 DD  	ld		hl, (ix)
 243+ 7AA6 66 01
 244+ 7AA8 DD 7E 02     	ld		a, (ix+2)
 245+ 7AAB
 246+ 7AAB B7           	or		a
 247+ 7AAC 06 40        	ld		b, COL_CNT
 248+ 7AAE 28 28        	jr		z, PrintOneLineCleanLine
 249+ 7AB0
 250+ 7AB0 47           	ld		b, a
 251+ 7AB1              PrintOneLineLoop:
 252+ 7AB1 7E           	ld		a, (hl)
 253+ 7AB2
 254+ 7AB2              	;Put space instead of tab
 255+ 7AB2 FE 09        	cp		CHAR_TAB
 256+ 7AB4 20 02        	jr		nz, PrintOneLineNotTab
 257+ 7AB6 3E 20        	ld		a, ' '
 258+ 7AB8
 259+ 7AB8              PrintOneLineNotTab:
 260+ 7AB8 E5           	push	hl
 261+ 7AB9 32 81 5C     		ld		(CODE), a
 262+ 7ABC C5           		push	bc
 263+ 7ABD CD 3B 78     			call	PrintChar
 264+ 7AC0 C1           		pop		bc
 265+ 7AC1
 266+ 7AC1 ED 5B B0 5C  		ld		de, (COORDS)
 267+ 7AC5 1C           		inc		e
 268+ 7AC6 ED 53 B0 5C  		ld		(COORDS), de
 269+ 7ACA E1           	pop		hl
 270+ 7ACB 23           	inc		hl
 271+ 7ACC 10 E3        	djnz	PrintOneLineLoop
 272+ 7ACE
 273+ 7ACE              	;Fill rest of line with spaces.
 274+ 7ACE DD 46 02     	ld		b, (ix+2)
 275+ 7AD1 3E 40        	ld		a, COL_CNT
 276+ 7AD3 B8           	cp		b
 277+ 7AD4 C8           	ret		z
 278+ 7AD5
 279+ 7AD5 B7           	or		a
 280+ 7AD6 98           	sbc		b
 281+ 7AD7 47           	ld		b, a
 282+ 7AD8
 283+ 7AD8              PrintOneLineCleanLine:
 284+ 7AD8 3E 20        	ld		a, ' '
 285+ 7ADA 32 81 5C     	ld		(CODE), a
 286+ 7ADD C5           	push	bc
 287+ 7ADE CD 3B 78     		call	PrintChar
 288+ 7AE1 ED 5B B0 5C  		ld		de, (COORDS)
 289+ 7AE5 1C           		inc		e
 290+ 7AE6 ED 53 B0 5C  		ld		(COORDS), de
 291+ 7AEA C1           	pop		bc
 292+ 7AEB 10 EB        	djnz	PrintOneLineCleanLine
 293+ 7AED
 294+ 7AED C9           	ret
 295+ 7AEE
 296+ 7AEE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 297+ 7AEE
 298+ 7AEE 00 00        FileEnd			DEFW	0
 299+ 7AF0 00 00        LineCount		DEFW	0
 300+ 7AF2 00 00        FirstLineShown	DEFW	0
 301+ 7AF4
 302+ 7AF4 46 69 6C 65  MsgLine			defb	'File: '
 302+ 7AF8 3A 20
 303+ 7AFA 20 20 20 20  MsgLineFileName defb 	'           |'
 303+ 7AFE 20 20 20 20
 303+ 7B02 20 20 20 7C
 304+ 7B06 4C 69 6E 65  				defb	'Line: '
 304+ 7B0A 3A 20
 305+ 7B0C 20 20 20 20  MsgLineNo		defb	'     /'
 305+ 7B10 20 2F
 306+ 7B12 20 20 20 20  MsgLineTotal	defb	'     |'
 306+ 7B16 20 7C
 307+ 7B18 20 20 20...  				defs	21, ' '
 308+ 7B2D 7C 30 3A 45  				defb	'|0:Exi', 't' | $80
 308+ 7B31 78 69 F4
 309+ 7B34
# file closed: txtview.asm
1366  7B34              	include "serial.asm"
# file opened: serial.asm
   1+ 7B34              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7B34              ;They work with 19200 theoretical speed.
   3+ 7B34              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7B34
   5+ 7B34              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7B34              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7B34
   8+ 7B34
   9+ 7B34              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7B34              ; A=1 IF FRAMING ERROR
  11+ 7B34              ; USES BC,D _DOES NOT USE E!_
  12+ 7B34              SERRXI:
  12+ 7B34
  13+ 7B34 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7B37 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 7B39 D3 EF        	OUT	(0EFH),A
  16+ 7B3B
  17+ 7B3B              	; WAIT FOR START
  18+ 7B3B              SERWSL:
  19+ 7B3B 0B           	DEC	BC
  20+ 7B3C AF           	XOR	A
  21+ 7B3D B8           	CP	B
  22+ 7B3E 20 03        	JR	NZ,SERWS
  23+ 7B40 B9           	CP	C
  24+ 7B41 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7B43 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7B45 CB 7F        	BIT	7,A
  27+ 7B47 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 7B49
  29+ 7B49              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 7B49              ; OF BIT 0
  31+ 7B49 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 7B4B 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 7B4D
  34+ 7B4D              ; GET AND SHIFT BITS
  35+ 7B4D              SERRL:
  36+ 7B4D 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7B4F 00           	NOP			; 4 (TIMING)
  38+ 7B50 00           	NOP			; 4 (TIMING)
  39+ 7B51 00           	NOP			; 4 (TIMING)
  40+ 7B52 DB F7        	IN	A,(0F7H)	; 11
  41+ 7B54 17           	RLA			; 4
  42+ 7B55 CB 1A        	RR	D		; 8
  43+ 7B57 06 0A        	LD	B,CBAUD		; 7
  44+ 7B59 0D           	DEC	C		; 4
  45+ 7B5A 20 F1        	JR	NZ,SERRL	; 12
  46+ 7B5C
  47+ 7B5C              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 7B5C              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 7B5C              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 7B5C              ; IDLE UNTIL NEXT START BIT
  51+ 7B5C 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7B5E D3 EF        	OUT	(0EFH),A
  53+ 7B60
  54+ 7B60 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7B62              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7B62              SERWIL:
  57+ 7B62 05           	DEC	B
  58+ 7B63 28 0E        	JR	Z,SERRTF
  59+ 7B65 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7B67 CB 7F        	BIT	7,A
  61+ 7B69 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 7B6B
  63+ 7B6B              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 7B6B 7A           	LD	A,D
  65+ 7B6C 2F           	CPL			; INVERT BITS
  66+ 7B6D 57           	LD	D,A
  67+ 7B6E AF           	XOR	A		; 0 = SUCCESS
  68+ 7B6F C9           	RET
  69+ 7B70
  70+ 7B70              ; TIMEOUT
  71+ 7B70              SERRTO:
  72+ 7B70 3E FF        	LD	A,0FFH
  73+ 7B72 C9           	RET
  74+ 7B73
  75+ 7B73              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7B73              SERRTF:
  77+ 7B73 3E 01        	LD	A,01H
  78+ 7B75 C9           	RET
  79+ 7B76
  80+ 7B76
  81+ 7B76
  82+ 7B76              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7B76              SERRB:
  83+ 7B76
  84+ 7B76              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7B76              ; BITMAPPED OPTIONS IN E:
  86+ 7B76              ; XXXXXXIT
  87+ 7B76              ; I SET = leave Interrupts disabled at exit
  88+ 7B76              ; T SET = return after Timeout
  89+ 7B76              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7B76              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7B76              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7B76 F3           	DI
  93+ 7B77 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 7B78              				; OF RECEIVED BYTES
  95+ 7B78
  96+ 7B78              SERRBL:
  97+ 7B78 C5           	PUSH	BC
  98+ 7B79 CD 34 7B     	CALL	SERRXI
  99+ 7B7C C1           	POP	BC
 100+ 7B7D B7           	OR	A
 101+ 7B7E 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7B80 72           	LD	(HL),D
 103+ 7B81 23           	INC	HL
 104+ 7B82 0B           	DEC	BC
 105+ 7B83 AF           	XOR	A
 106+ 7B84 B8           	CP	B
 107+ 7B85 20 F1        	JR	NZ,SERRBL
 108+ 7B87 B9           	CP	C
 109+ 7B88 20 EE        	JR	NZ,SERRBL
 110+ 7B8A              ; FULL RECEIVE
 111+ 7B8A C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 7B8B
 113+ 7B8B              SERRBX:				; EXIT
 114+ 7B8B CB 4B        	BIT	1,E
 115+ 7B8D C0           	RET	NZ
 116+ 7B8E FB           	EI
 117+ 7B8F C9           	RET
 118+ 7B90
 119+ 7B90              SERRBT:
 120+ 7B90 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7B92 28 04        	JR	Z,SERRBC
 122+ 7B94 CB 43        	BIT	0,E
 123+ 7B96 28 E0        	JR	Z,SERRBL
 124+ 7B98
 125+ 7B98              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7B98 EB           	EX	DE,HL		; PRESERVE HL
 127+ 7B99 E1           	POP	HL		; GET INITIAL COUNT
 128+ 7B9A 37           	SCF
 129+ 7B9B 3F           	CCF
 130+ 7B9C ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7B9E 44           	LD	B,H
 132+ 7B9F 4D           	LD	C,L		; BC = COUNT
 133+ 7BA0 EB           	EX	DE,HL		; RESTORE HL
 134+ 7BA1
 135+ 7BA1 18 E8        	JR	SERRBX
 136+ 7BA3
 137+ 7BA3              SERRX:
 137+ 7BA3
 138+ 7BA3              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7BA3              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7BA3              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7BA3 F3           	DI
 142+ 7BA4 CD 34 7B     	CALL	SERRXI
 143+ 7BA7 FB           	EI
 144+ 7BA8 C9           	RET
 145+ 7BA9
 146+ 7BA9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7BA9              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7BA9              SERTB:
 148+ 7BA9
 149+ 7BA9 7E           	LD	A,(HL)
 150+ 7BAA C5           	PUSH	BC
 151+ 7BAB CD B6 7B     		CALL	SERTX
 152+ 7BAE C1           	POP	BC
 153+ 7BAF 23           	INC	HL
 154+ 7BB0 0B           	DEC BC
 155+ 7BB1 78           	LD	A, B
 156+ 7BB2 B1           	OR	C
 157+ 7BB3 20 F4        	JR	NZ, SERTB
 158+ 7BB5 C9           	RET
 159+ 7BB6
 160+ 7BB6              ; SEND CHAR ROUTINE
 161+ 7BB6              SERTX:
 161+ 7BB6
 162+ 7BB6 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7BB7 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7BB8 F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7BB9 3E 01        	LD	A,01H
 166+ 7BBB D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7BBD 1E 20        	LD	E,20H	; PORT MASK
 168+ 7BBF 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 7BC1 3E 01        	LD	A,1
 170+ 7BC3 C3 CA 7B     	JP	SBIT
 171+ 7BC6
 172+ 7BC6 AF           SHLOOP:	XOR	A		; 4
 173+ 7BC7 CB 3A        	SRL	D		; 8
 174+ 7BC9 17           	RLA			; 4
 175+ 7BCA              SBIT:
 176+ 7BCA B3           	OR	E		; 4
 177+ 7BCB D3 EF        	OUT	(0EFH),A	; 11
 178+ 7BCD 06 0A        	LD	B,CBAUD		; 7
 179+ 7BCF              SBITDL:
 180+ 7BCF 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 7BD1 00           	NOP			; 4 (TIMING)
 182+ 7BD2 0D           	DEC	C		; 4
 183+ 7BD3 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 7BD5              ; STOP BIT
 185+ 7BD5 3E 20        	LD	A,20H
 186+ 7BD7 D3 EF        	OUT	(0EFH),A
 187+ 7BD9 06 0A        	LD	B,CBAUD
 188+ 7BDB 10 FE        STOPL:	DJNZ	STOPL
 189+ 7BDD FB           	EI
 190+ 7BDE C9           	RET
# file closed: serial.asm
1367  7BDF              	include "bas2txt.asm"
# file opened: bas2txt.asm
   1+ 7BDF              	DEVICE	ZXSPECTRUM48
   2+ 7BDF
   3+ 7BDF              CHANS		EQU		23631
   4+ 7BDF              CH_LEN		EQU		5
   5+ 7BDF              CHANNEL		EQU		3
   6+ 7BDF              CHAN_OPEN	EQU		$1601
   7+ 7BDF
   8+ 7BDF              NumMarker	EQU		$0E
   9+ 7BDF
  10+ 7BDF              PO_SEARCH	EQU		$0C41
  11+ 7BDF              TKN_TABLE	EQU		$0095
  12+ 7BDF
  13+ 7BDF
  14+ 7BDF              ;Input: HL=source of program, BC=length of program, DE=text output address
  15+ 7BDF              ;Output: DE=end of text
  16+ 7BDF              BASIC2TXT:
  17+ 7BDF 22 A3 7C     	ld		(ProgramStartAddr), hl
  18+ 7BE2 09           	add		hl, bc
  19+ 7BE3 22 A5 7C     	ld		(ProgramEndAddr), hl
  20+ 7BE6 ED 53 A7 7C  	ld		(DestinationAddr), de
  21+ 7BEA
  22+ 7BEA              	;Open channel.
  23+ 7BEA 3E 03        	LD   A, CHANNEL
  24+ 7BEC CD 01 16     	CALL CHAN_OPEN		;
  25+ 7BEF
  26+ 7BEF              	;modify output routine
  27+ 7BEF 2A 4F 5C     	ld   hl, (CHANS)
  28+ 7BF2 01 0F 00     	ld	 bc, CH_LEN * CHANNEL
  29+ 7BF5 09           	add	 hl, bc
  30+ 7BF6 11 76 7C     	ld   de, OutputFnct
  31+ 7BF9 73 23 72 2B  	ld   (hl), de
  32+ 7BFD
  33+ 7BFD 2A A3 7C     	ld	hl, (ProgramStartAddr)
  34+ 7C00
  35+ 7C00              NextLine:
  36+ 7C00 E5           	PUSH HL
  37+ 7C01 B7           		or	 a
  38+ 7C02 ED 5B A5 7C  		ld   de, (ProgramEndAddr)
  39+ 7C06 EB           		ex	de, hl
  40+ 7C07 ED 52        		SBC  HL,DE
  41+ 7C09 7C           		LD   A,H
  42+ 7C0A B5           		OR   L
  43+ 7C0B E1           	POP  HL
  44+ 7C0C C8           	RET  Z				;Return if length == 0.
  45+ 7C0D
  46+ 7C0D              	;Print line number
  47+ 7C0D 3E 20        	ld		a, ' '
  48+ 7C0F CD 94 7C     	call	PrintIt
  49+ 7C12 46           	LD   B,(HL)
  50+ 7C13 23           	INC  HL
  51+ 7C14 4E           	LD   C,(HL)
  52+ 7C15 23           	INC  HL
  53+ 7C16 E5           	PUSH HL
  54+ 7C17 CD 2B 2D     		CALL $2D2B		;STACK_BC
  55+ 7C1A CD E3 2D     		CALL $2DE3		;PRINT_FP
  56+ 7C1D 3E 20        		ld		a, ' '
  57+ 7C1F CD 94 7C     		call	PrintIt
  58+ 7C22 E1           	POP  HL
  59+ 7C23
  60+ 7C23              	;Get line length in BC.
  61+ 7C23 4E           	LD   C,(HL)
  62+ 7C24 23           	INC  HL
  63+ 7C25 46           	LD   B,(HL)
  64+ 7C26 23           	INC  HL
  65+ 7C27
  66+ 7C27              	;Save line end address.
  67+ 7C27 E5           	PUSH HL
  68+ 7C28 09           		ADD  HL,BC
  69+ 7C29 22 A1 7C     		LD   (LineEndAddr),HL
  70+ 7C2C E1           	POP  HL
  71+ 7C2D
  72+ 7C2D              GetCharLoop:
  73+ 7C2D              	;Load a char
  74+ 7C2D 7E           	LD   A, (HL)
  75+ 7C2E FE 0D        	CP   CHR_CR
  76+ 7C30 20 04        	JR   NZ, IsNotCR		; A == CR
  77+ 7C32
  78+ 7C32              	;Print CR and process next line.
  79+ 7C32 23           	INC  HL
  80+ 7C33 D7           	RST  $10			;PRINT_A_1
  81+ 7C34 18 CA        	JR   NextLine
  82+ 7C36
  83+ 7C36              IsNotCR:
  84+ 7C36 FE 2E        	CP   '.'
  85+ 7C38 28 08        	JR   Z, SearchNum	; A == '.'
  86+ 7C3A
  87+ 7C3A FE 3A        	CP   ':'
  88+ 7C3C 30 13        	JR   NC, TestSPC1	; A >= ':'
  89+ 7C3E
  90+ 7C3E FE 30        	CP   '0'
  91+ 7C40 38 0F        	JR   C, TestSPC1	; A < '0'
  92+ 7C42
  93+ 7C42              SearchNum:
  94+ 7C42 44           	LD   B, H
  95+ 7C43 3E 0E        	LD   A, NumMarker
  96+ 7C45 ED B1        	CPIR
  97+ 7C47 CD B4 33     	CALL $33B4			;STACK_NUM
  98+ 7C4A E5           	PUSH HL
  99+ 7C4B CD E3 2D     		CALL $2DE3		;PRINT_FP
 100+ 7C4E E1           	POP  HL
 101+ 7C4F 18 DC        	JR   GetCharLoop
 102+ 7C51
 103+ 7C51              TestSPC1:
 104+ 7C51 FE 20        	CP   ' '
 105+ 7C53 38 02        	JR   C, TestREM		; A < ' '
 106+ 7C55
 107+ 7C55              	;Print char >= ' '
 108+ 7C55 D7           	RST  $10			;PRINT_A_1
 109+ 7C56 7E           	LD   A,(HL)
 110+ 7C57
 111+ 7C57              TestREM:
 112+ 7C57 FE EA        	CP   $EA			;RND token
 113+ 7C59 20 08        	JR   NZ, TestQuote1	; A != RND
 114+ 7C5B
 115+ 7C5B              	;Print CR.
 116+ 7C5B 3E 0D        	LD   A, CHR_CR
 117+ 7C5D D7           	RST  $10			;PRINT_A_1
 118+ 7C5E 2A A1 7C     	LD   HL,(LineEndAddr)	;Ingore chars after REM.
 119+ 7C61 18 9D        	JR   NextLine
 120+ 7C63
 121+ 7C63              TestQuote1:
 122+ 7C63 FE 22        	CP   '"'
 123+ 7C65 20 0C        	JR   NZ, SkipChar	; A != '"'
 124+ 7C67
 125+ 7C67              TestSPC2:
 126+ 7C67 23           	INC  HL
 127+ 7C68 7E           	LD   A,(HL)
 128+ 7C69 FE 20        	CP   ' '
 129+ 7C6B 38 02        	JR   C, TestQuote2	; A < ' '
 130+ 7C6D
 131+ 7C6D              	;Print >= ' '.
 132+ 7C6D D7           	RST  $10			;PRINT_A_1
 133+ 7C6E 7E           	LD   A,(HL)
 134+ 7C6F
 135+ 7C6F              TestQuote2:
 136+ 7C6F FE 22        	CP   '"'
 137+ 7C71 20 F4        	JR   NZ, TestSPC2	; A != '"'
 138+ 7C73
 139+ 7C73              SkipChar:
 140+ 7C73 23           	INC  HL
 141+ 7C74 18 B7        	JR   GetCharLoop
 142+ 7C76
 143+ 7C76              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 144+ 7C76
 145+ 7C76              OutputFnct:
 146+ 7C76 FE A4        	cp	164
 147+ 7C78 38 1A        	jr	c, PrintIt	; A <= 164 ?
 148+ 7C7A
 149+ 7C7A D6 A5        	sub		165
 150+ 7C7C 11 95 00     	ld		de, TKN_TABLE
 151+ 7C7F CD 41 0C     	call	PO_SEARCH
 152+ 7C82
 153+ 7C82              NextTokenChar:
 154+ 7C82 1A           	ld		a, (de)
 155+ 7C83 13           	inc		de
 156+ 7C84 CB 7F        	bit		7, a
 157+ 7C86 20 05        	jr		nz, LastChar
 158+ 7C88 CD 94 7C     	call	PrintIt
 159+ 7C8B 18 F5        	jr		NextTokenChar
 160+ 7C8D
 161+ 7C8D              LastChar:
 162+ 7C8D E6 7F        	and		%01111111
 163+ 7C8F CD 94 7C     	call	PrintIt
 164+ 7C92 3E 20        	ld		a, ' '
 165+ 7C94
 166+ 7C94              PrintIt:
 167+ 7C94 D5           	push	de
 168+ 7C95 ED 5B A7 7C  		ld	de, (DestinationAddr)
 169+ 7C99 12           		ld	(de), a
 170+ 7C9A 13           		inc	de
 171+ 7C9B ED 53 A7 7C  		ld	(DestinationAddr), de
 172+ 7C9F D1           	pop		de
 173+ 7CA0 C9           	ret
 174+ 7CA1
 175+ 7CA1 00 00        LineEndAddr			DEFW 0
 176+ 7CA3 00 00        ProgramStartAddr	DEFW 0
 177+ 7CA5 00 00        ProgramEndAddr		DEFW 0
 178+ 7CA7 00 00        DestinationAddr		DEFW 0
 179+ 7CA9
# file closed: bas2txt.asm
1368  7CA9
1369  7CA9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1370  7CA9 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-18"
1370  7CAD 64 20 32 30
1370  7CB1 32 33 2D 31
1370  7CB5 32 2D 31 38
1371  7CB9 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1371  7CBD 67 65 20 43
1371  7CC1 68 69 72 74
1371  7CC5 6F 61 63 E1
1372  7CC9 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1372  7CCD 72 61 6D 20
1372  7CD1 49 6E 66 6F
1372  7CD5 20 20 20 A0
1373  7CD9 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1373  7CDD 20 49 6E 66
1373  7CE1 6F 20 20 20
1373  7CE5 20 20 20 A0
1374  7CE9 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1374  7CED 20 49 6E 66
1374  7CF1 6F 20 20 20
1374  7CF5 20 20 20 A0
1375  7CF9 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1375  7CFD 61 67 65 73
1375  7D01 20 20 20 20
1375  7D05 20 20 20 A0
1376  7D09 31 2D 41 3A  BtnBar			DEFM	'1-A:|2-B:|3-View|4-Prop|5-Copy|6-Ren|7-Attr|8-Del|9-Disk|0-Exi', 't' + $80
1376  7D0D 7C 32 2D 42
1376  7D11 3A 7C 33 2D
1376  7D15 56 69 65 77
1376  7D19 7C 34 2D 50
1376  7D1D 72 6F 70 7C
1376  7D21 35 2D 43 6F
1376  7D25 70 79 7C 36
1376  7D29 2D 52 65 6E
1376  7D2D 7C 37 2D 41
1376  7D31 74 74 72 7C
1376  7D35 38 2D 44 65
1376  7D39 6C 7C 39 2D
1376  7D3D 44 69 73 6B
1376  7D41 7C 30 2D 45
1376  7D45 78 69 F4
1377  7D48 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1377  7D4C 46 72 65 65
1377  7D50 3A 20 20
1378  7D53 41 2F        MsgDriveLet		DEFM	'A', '/'
1379  7D55 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1380  7D58 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1380  7D5C 73 2F 4B 42
1380  7D60 3A
1381  7D61 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1381  7D65 30 30 30
1382  7D68 45 72 72 6F  MsgErr			DEFM	'Error code '
1382  7D6C 72 20 63 6F
1382  7D70 64 65 20
1383  7D73 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1384  7D77 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1384  7D7B 69 6E 67 20
1384  7D7F 50 72 6F 67
1384  7D83 72 61 ED
1385  7D86 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1385  7D8A 69 6E 67 20
1385  7D8E 53 43 52 45
1385  7D92 45 4E A4
1386  7D95 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1386  7D99 69 6E 67 20
1386  7D9D 43 4F 44 45
1386  7DA1 20 28 21 A9
1387  7DA5 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1387  7DA9 20 4C 65 6E
1387  7DAD 3A
1388  7DAE 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1388  7DB2 30 20 CB
1389  7DB5 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1389  7DB9 69 62 20 20
1389  7DBD 3A
1390  7DBE 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1390  7DC2 48 49 C4
1391  7DC5 54 79 70 65  MsgFileType		DEFM	'Type    :'
1391  7DC9 20 20 20 20
1391  7DCD 3A
1392  7DCE 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1392  7DD2 20 20 20 20
1392  7DD6 20 A0
1393  7DD8 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1393  7DDC 72 61 ED
1394  7DDF 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1394  7DE3 73 20 A0
1395  7DE6 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1395  7DEA 45 4E A4
1396  7DED 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1396  7DF1 41 72 F2
1397  7DF4 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1397  7DF8 41 72 F2
1398  7DFB 55 6E 74 79  MsgFileTypeText	DEFM	'Untype', 'd' + $80
1398  7DFF 70 65 E4
1399  7E02 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1399  7E06 20 20 A0
1400  7E09 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1400  7E0D 74 68 20 20
1400  7E11 3A
1401  7E12 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1401  7E16 35 20 C2
1402  7E19 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1402  7E1D 74 20 20 20
1402  7E21 3A
1403  7E22 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1403  7E26 35 20 A0
1404  7E29 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1404  7E2D 69 6E 67 20
1404  7E31 68 65 61 64
1404  7E35 65 F2
1405  7E37 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1405  7E3B 20 20 20 20
1405  7E3F 20 20 20 20
1405  7E43 20 20 20 A0
1406  7E47 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1406  7E4B 66 69 6C 65
1406  7E4F 3F 20 79 2F
1406  7E53 EE
1407  7E54 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1407  7E58 52 2F 4F 3F
1407  7E5C 20 79 2F EE
1408  7E60 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1408  7E64 48 49 44 3F
1408  7E68 20 79 2F EE
1409  7E6C 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1409  7E70 3F 6E 6F 6E
1409  7E74 65 3D 61 62
1409  7E78 6F 72 74 BA
1410  7E7C 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1410  7E80 20 6D 65 6E
1410  7E84 75 BA
1411  7E86 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1411  7E8A 20 63 6F 70
1411  7E8E 79 20 6D 65
1411  7E92 6E 75 BA
1412  7E95 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1412  7E99 78 69 74 20
1412  7E9D 6D 65 6E F5
1413  7EA1
1414  7EA1 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1414  7EA5 6F 70 79 20
1415  7EA9 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1416  7EAD 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1417  7EAF
1418  7EAF 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1418  7EB3 6F 70 79 20
1419  7EB7 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1420  7EBB 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1421  7EBD
1422  7EBD 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1422  7EC1 6F 70 79 20
1423  7EC5 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1423  7EC9 43 4F CD
1424  7ECC
1425  7ECC 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1425  7ED0 6F 70 79 20
1425  7ED4 43 4F 4D 2D
1425  7ED8 3E
1426  7ED9 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1427  7EDB
1428  7EDB 35 2E 20 46  MsgMenuFmt1		DEFM	'5. Format A', ':' | $80
1428  7EDF 6F 72 6D 61
1428  7EE3 74 20 41 BA
1429  7EE7 36 2E 20 46  MsgMenuFmt2		DEFM	'6. Format B', ':' | $80
1429  7EEB 6F 72 6D 61
1429  7EEF 74 20 42 BA
1430  7EF3
1431  7EF3 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1431  7EF7 62 6C 6F 63
1431  7EFB 6B 73 20 6C
1431  7EFF 65 66 F4
1432  7F02 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1432  7F06 77 72 69 74
1432  7F0A 65 3F 20 79
1432  7F0E 2F EE
1433  7F10 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1433  7F14 20 6E 61 6D
1433  7F18 65 20 65 78
1433  7F1C 69 73 74 F3
1434  7F20 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1434  7F24 53 4F 55 52
1434  7F28 43 45 20 64
1434  7F2C 69 73 EB
1435  7F2F 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1435  7F33 44 45 53 54
1435  7F37 2E 20 64 69
1435  7F3B 73 6B A0
1436  7F3E 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1436  7F42 73 20 61 6E
1436  7F46 79 20 6B 65
1436  7F4A F9
1437  7F4B 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1437  7F4F 73 65 63 74
1437  7F53 6F 72 73 20
1437  7F57 63 6F 70 F9
1438  7F5B 41 72 65 20  MsgAreYouSure	DEFM	'Are you sure?y/', 'n' | $80
1438  7F5F 79 6F 75 20
1438  7F63 73 75 72 65
1438  7F67 3F 79 2F EE
1439  7F6B 4C 6F 61 64  MsgFileLoading	DEFM	'Loading file..', '.' | $80
1439  7F6F 69 6E 67 20
1439  7F73 66 69 6C 65
1439  7F77 2E 2E AE
1440  7F7A
1441  7F7A              	IFNDEF	_REAL_HW_
1442  7F7A ~            FontTable:
1443  7F7A ~            	incbin "cpmfnt.bin"
1444  7F7A              	ENDIF
1445  7F7A              EndCode:
1446  7F7A
1447  7F7A              ;Unalocated variables
1448  7F7A              UnallocStart	EQU		EndCode
1449  7F7A              FileCnt			EQU		UnallocStart			;File counter, 1B
1450  7F7A              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1451  7F7A              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1452  7F7A              CursorAddr		EQU		SelFile + 1				;2 B
1453  7F7A              AUCntUsed		EQU		CursorAddr + 2			;2 B
1454  7F7A              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1455  7F7A              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1456  7F7A              CopySelOption	EQU		SelFileCache+2			;1 B
1457  7F7A
1458  7F7A              CopyFileFCB		EQU	CopySelOption + 1
1459  7F7A              CopyFileRes		EQU CopyFileFCB + 2
1460  7F7A              CopyFileDMAAddr	EQU	CopyFileRes + 1
1461  7F7A              FilePosRead		EQU	CopyFileDMAAddr + 2
1462  7F7A              FilePosWrite	EQU	FilePosRead + 2
1463  7F7A              CopyFileSectCnt EQU FilePosWrite + 2
1464  7F7A              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1465  7F7A              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1466  7F7A              CopyFileDstDrv	EQU CopyFileSrcName + 11
1467  7F7A              CopyFileDstName	EQU CopyFileDstDrv + 1
1468  7F7A
1469  7F7A              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1470  7F7A              ;FS block list constants
1471  7F7A              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1472  7F7A              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1473  7F7A              UsedBlockListSz		EQU 320 * 2 + 2							;640
1474  7F7A
1475  7F7A              	IFDEF	_REAL_HW_
1476  7F7A              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1477  7F7A              DataBuf			EQU		FontTable + 872
1478  7F7A              	ELSE
1479  7F7A ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1480  7F7A              	ENDIF
1481  7F7A
1482  7F7A              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1483  7F7A
1484  7F7A
1485  7F7A              ;File viewer constants
1486  7F7A              FileData		EQU		DataBuf
1487  7F7A              ;File buffer size, without index
1488  7F7A              FileIdxSize		EQU		4	 * 1024
1489  7F7A              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1490  7F7A              ;Set a few KB aside for file indexing
1491  7F7A              FileIdx			EQU		FileData + FileDataSize
1492  7F7A              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1493  7F7A
1494  7F7A
1495  7F7A              ;Copy buffer size, follows
1496  7F7A              CopyDiskBuf			EQU DataBuf
1497  7F7A
1498  7F7A              ;256 bytes for the stack should be enough.
1499  7F7A              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1500  7F7A              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1501  7F7A              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1502  7F7A
1503  7F7A              	DISPLAY "DataBuf: ", /D,DataBuf
1504  7F7A              	DISPLAY "BinSize: ", /D, EndCode - Start
1505  7F7A              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1506  7F7A              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6E86   NoSub
0x6E7F   DivLoop
0x713A   MAX_RAM_FREE
0x0071   MAX_SECT_RAM
0x1000   FileIdxSize
0x0282   UsedBlockListSz
0x7F7A   UnallocStart
0x7F7A   EndCode
0x7D55 X MsgFreeSpaceNo
0x7C8D   LastChar
0x7C82   NextTokenChar
0x7C6F   TestQuote2
0x7C67   TestSPC2
0x7C73   SkipChar
0x7C63   TestQuote1
0x7C57   TestREM
0x7C51   TestSPC1
0x7C42   SearchNum
0x7C36   IsNotCR
0x7C2D   GetCharLoop
0x7CA1   LineEndAddr
0x7C94   PrintIt
0x7C00   NextLine
0x7C76   OutputFnct
0x7CA5   ProgramEndAddr
0x7CA3   ProgramStartAddr
0x0095   TKN_TABLE
0x0C41   PO_SEARCH
0x000E   NumMarker
0x1601   CHAN_OPEN
0x0003   CHANNEL
0x0005   CH_LEN
0x5C4F   CHANS
0x7BDB   STOPL
0x7BC6   SHLOOP
0x7BCA   SBIT
0x7BCF   SBITDL
0x7BB6   SERTX
0x7BA3 X SERRX
0x7B98   SERRBC
0x7B8B   SERRBX
0x7B90   SERRBT
0x7B78   SERRBL
0x7B65 X SERWI
0x7B73   SERRTF
0x7B62   SERWIL
0x7B4D   SERRL
0x7B70   SERRTO
0x7B43   SERWS
0x7B3B   SERWSL
0x7B34   SERRXI
0x000A   CBAUD
0x7AB8   PrintOneLineNotTab
0x7AB1   PrintOneLineLoop
0x7AA1 X TextViewerEnd
0x7A96 X TextViewerCheckEnd
0x7A90 X TextViewerIncrementIndex
0x7A80   TextViewIndexStoreLineLen
0x7A78   TextViewIndexNoLF
0x7A65   TextViewIndexLoop
0x7AEE   FileEnd
0x79F8   TextViewerScrollUp1
0x79DA   TextViewerScrollUp
0x7A0B   TextViewerScrollDown
0x7AF4   MsgLine
0x79B7   TextViewerShowFilename
0x7AFA   MsgLineFileName
0x7B0C   MsgLineNo
0x79A5   TextViewerLoop3
0x7B12   MsgLineTotal
0x7AF2   FirstLineShown
0x7AA2   PrintOneLine
0x7977   TextViewerLoop
0x7973   MoreThan23LinesInFile
0x7AF0   LineCount
0x7962 X TextViewerLoop2
0x7A4B   TextViewIndex
0x7931   ScrollDownLoop
0x7928   ScrollDownLoop2
0x792F   ScrollDownPtrSrc
0x792C   ScrollDownPtrDest
0x791B   ScrollDown
0x791E   Scroll
0x7916   ScrollUp
0x7905   FillScrLinesRev
0x78F0   FillScrLinesLoop
0x78DC   ScrollInit
0x78D2   GetCellDown
0x5B2E   SCRLinesUp
0x5B00   SCRLinesDown
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A X CHAR_LF
0x0040   COL_CNT
0x0017   LINE_CNT
0x78BE   ClearNMsgLinesLoop
0x78AC   ReadStrPrint
0x789C   ReadStrChar
0x787F   ReadStringLoop
0x7873   Store
0x7872   NoTurn
0x7867   PrintCharLine
0x7853 X PrintChar3
0x77FE   DrawCursorLoop
0x77E5   DrawVLinesLoop
0x77B6   DrawLowerIntersectLoop
0x77C7   DrawIntersect
0x77A1   DrawUpperIntersectLoop
0x7775   DrawLineLoop
0x7782   LineDir
0x7772   StoreDir
0x7770   VertDir
0x7767   DrawLine
0x7763   StrClr
0x7716   GoodChar
0x78CE   CurrScrAddr
0x8A5E   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A   CHR_LF
0x000D   CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x7695   ReadWriteFileSectionLoop
0x76B3   ReadWriteFileSectionEnd
0x7F89   CopyFileDMAAddr
0x7F86   CopyFileFCB
0x765A   ReadWriteFileSection
0x76C5   CopyFilePtr2
0x7680   CopyFilePtr
0x76A8   CopyFileOperAddr2
0x7689   CopyFileOperAddr1
0x7608   CopyFileFromCOMDontInc
0x6100   FileDataSize
0x75F5   CopyFileFromCOMLoop
0x7594   CopyFileToCOMEnd
0x7574   CopyFileToCOMLoop
0x752C   CopyFileDualDriveLoop
0x7641   WriteFileSection
0x7F4B   MsgCopySectors
0x74C3   CopyFileSameDriveLoop
0x7F8F   CopyFileSectCnt
0x747F   CopyFileCreateNewFile
0x7F02   MsgFileOverwrite
0x7463   CopyFileCheckOverwrite
0x7599   CopyFileFromCOM
0x7566   CopyFileToCOM
0x751C   CopyFileDualDrive
0x749D   CopyFileSameDrive
0x744C   CopyFileNotExit
0x7E86   MsgMenuFileCopy
0x7F8D   FilePosWrite
0x7F9D   CopyFileDstName
0x7F91   CopyFileSrcName
0x7F20   MsgInsertSrcDsk
0x7F3E   MsgPressAnyKey
0x7F2F   MsgInsertDstDsk
0x734F X FileAttribSet
0xEEC6   FileIdx
0x72FD   GetFileSizeMul
0x7303   GetFileSizeEnd
0x72FB   GetFileSizeOK
0x72DB   BDOSSetRandFilePtr
0x72D7   BDOSSetDMA
0x72C9   BDOSWriteFileBlockRandom
0x72C5   BDOSReadFileBlockRandom
0x72C1   BDOSWriteFileBlockSeq
0x72BD   BDOSReadFileBlockSeq
0x72B9   BDOSCloseFile
0x72B5   BDOSOpenFile
0x72B1   BDOSCreateFile
0x72A7   DestroyChannel
0x7291   CreateChannel
0x7291 X BDOSCloseDrives
0x728D X BDOSGetDiskRO
0x728D X BDOSMakeDiskRO
0x72CD   BDOS
0x727F X PrmIntrlvTbl
0x727E X PrmSpinUp
0x727D X PrmHeadLoad
0x727B X PrmDevType
0x0004   PrmFastFactor
0x7276 X RWTSResTmp
0x7275 X RWTSResVolNo
0x727B   BasPrmTbl
0x7271 X RWTSPrmTbl
0x726F X RWTSExtBuf
0x726C X RWTSSector
0x726A X RWTSVolNo
0x7268 X RWTSBlockType
0x725F   CopyMsg
0x7253   SearchMsgEnd
0x725C   SaveMsg
0x724A   IF1Paged
0x7218   IF1Call
0x7213   IsFileHeaderValidLoop
0x72DF   GetFileSize
0x71F7   ReadFileHeaderIsTextFile
0x7210   IsFileHeaderValid
0x720C   ReadHeaderEnd
0x71B1   CacheNotFinished
0x71A6 X SeekTrack
0x715B   FileReadLoop
0x714F X FileLoadHeader
0x7161   FileLoadNoHeader
0x716F   FileFree
0x712B   MisMatch
0x7123   Compare
0x7121   StrCmp
0x70D8   CopyDiskFromCOMLoop
0x7B76   SERRB
0x7074   CopyDiskToCOMLoop
0x7BA9   SERTB
0x7395   PromptDiskChangeSrc
0x704C   CopyDiskDualDrive2
0x7059   CopyDiskEnd
0x7028 X CopyDiskWriteEnd
0x7011   CopyDiskLoopWriteLoop
0x700A   CopyDiskReadEnd
0x737B   PromptDiskChangeDst
0x7000   CopyDiskDualDrive1
0x6FD7   CopyDiskLoopReadLoop
0x8DC6   CopyDiskBuf
0x6FD0   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7EF3   MsgBlocksLeft
0x6FAD   CopyDiskLoop
0x87DE   UsedBlockListBlk
0x7187   WriteDiskSectors
0x6F99   WriteFSBlock
0x7174   ReadDiskSectors
0x6F8C   ReadFSBlock
0x6F7E   ReadUsedBlocksSkip
0x6F61   ReadUsedBlocksLoop2
0x6F81   ReadUsedBlocksSkip2
0x6F51   ReadUsedBlocksLoop
0x87DC   UsedBlockListCnt
0x6F33   ReadUsedBlocksList
0x6F2C   CheckAUEnd
0x6F18   CheckAU
0x6F01   FirstAU
0x6EFB   Track0
0x6EE6   AU2TS
0x6ECA   WriteOneDiskSector
0x726B   RWTSTrack
0x726D   RWTSDMA
0x7268   RWTSParams
0x7273   RWTSCmd
0x6EB3   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6EAD   NoAdd
0x6EA7   MulLoop
0x6E8E   Div2Loop
0x6E89 X Div2
0x6E7C   Div
0x6E73   DivNrLoop
0x6E71   DigitLoop
0x6E62   Byte2Txt_
0x6E4B   StrippLeading0
0x6E56   Word2Txt_
0x6E35 X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x6E32   DontInc
0x6E2C   ReadAllHeadersEnd
0x6E17   AKey
0x76D6   KbdHit
0x6DFC   NextFile
0x7E09   MsgFileLen
0x7DC5   MsgFileType
0x7E19   MsgFileStart
0x6DBB   PrintStartStr
0x7E22   MsgFileStartN
0x7E02   MsgNA
0x6DAD   PrintStart
0x0007   HDR_LINE
0x6D88   PrintByteStart
0x6D80   PrintProgStart
0x7E12   MsgFileLenN
0x6D66 X PrepFileLenText
0x7DFB   MsgFileTypeText
0x7DDF   MsgFileTypeByte
0x7DE6   MsgFileTypeSCR
0x6D4C   NotScr
0x6D57   CheckText
0x7DED   MsgFileTypeChrA
0x6D2F   CheckByte
0x0002   CHAR_TYPE
0x7DF4   MsgFileTypeNoA
0x6D20   CheckChrArr
0x0001   NUMB_TYPE
0x6D60   PrepFileLen
0x727C X PrmStepRate
0x6DD9   MoveMsg
0x7DCE   MsgFileTypeN
0x7DD8   MsgFileTypePrg
0x6D11   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6D90   HeadNotRead
0x7DB5   MsgFileAttr
0x6CE2   AttrEnd
0x6CD6   NotSYS
0x6CC2   CheckSys
0x6CB0   NotRO
0x7DBE   MsgFileAttrN
0x0008   RO_POS
0x0000   CACHE_NAME
0x6DA2   PrintStartNotRead
0x7DA5   MsgFileSzDsk
0x7DAE   MsgFileSzDskN
0x7956   TextViewer
0x5CED   HD11
0x001A   CHAR_EOF
0x7CA7   DestinationAddr
0x7BDF   BASIC2TXT
0x0005   HDR_PLEN
0x000D   CHAR_CR
0x6C62   ViewFileAsText
0x6C19   ViewFileWithHeader
0x761C   ReadFileSection
0x0061   MAX_SECT_BUF
0x7F8B   FilePosRead
0x6C23   ViewProgramFile
0x7F6B   MsgFileLoading
0x721E   LoadProgram
0x7F90   CopyFileSrcDrv
0x7D77   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7D86   MsgLoadingSCR
0x0003   HDR_ADDR
0x7174   IF1FileLoadEnd
0x5B00   PRN_BUF
0x712E   IF1FileLoad
0x7D95   MsgLoadingCODE
0x6B80 X HandleFileCODE
0x6BA6   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6BD4   HandleFileText
0x0003   BYTE_TYPE
0x6BC4   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6B4A   FindExtEnd
0x71A6   FindCache
0x6B59   GetFileNamesEnd
0x0009   HDR_SZ
0x6B25   FindExt
0x000C   EXT_IDX
0x6F04   CheckExtAlloc
0x6B4C   NextExt
0x0000   EXT_DEL_FLAG
0x6AD4   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6AB1   DisplayFilenamesLoop
0x6A97   LineOK
0x5CB1   LINE
0x5CB0   COL
0x783B   PrintChar
0x5C81   CODE
0x6A71   DispLoop
0x6A6F   DisplayFilename
0x7803   MoveCursor
0x6ED5   FormatDisk
0x7F5B   MsgAreYouSure
0x6A17   FormatDiskAction
0x6A0A   CheckDiskMenuFormat2
0x70BB   CopyDiskFromCOM
0x69FB   CheckDiskMenuFormat1
0x705F   CopyDiskToCOM
0x69F1   CheckDiskMenuFromCOM
0x69E8   CheckDiskMenuToCOM
0x6FA6   CopyDisk
0x69DA   CheckDiskMenuDualDrive
0x6A5E   DiskMenuExit
0x69C6 X CheckKeyDiskMenuLoop
0x7EE7   MsgMenuFmt2
0x7EDB   MsgMenuFmt1
0x7ECC   MsgMenuFromCOM
0x7EBD   MsgMenuToCOM
0x7EAF   MsgMenuDual
0x7EA1   MsgMenuSingle
0x7E95   MsgMenuBack
0x7E7C   MsgMenuDiskCopy
0x7EBB   MsgMenuDualDrv2
0x7ED9   MsgMenuFromCOMDrv
0x7EC5   MsgMenuToComDrv
0x7EB7   MsgMenuDualDrv1
0x7EAD   MsgMenuSingleDrv2
0x7EA9   MsgMenuSingleDrv1
0x6A61   CheckKeyExit
0x732E   ChangeFileAttrib
0x6939   AttrChange
0x7E60   MsgSetSYS
0x6921   CheckSYS
0x7E54   MsgSetRO
0x694B   CheckKeyDiskMenu
0x7309   DeleteFile
0x68F3   DoFileDelete
0x7E47   MsgDelete
0x6900   CheckKeyAttrib
0x7358   RenameFile
0x7F10   MsgFileExists
0x68BA   RenameFileNotExist
0x7315   DoesFileExist
0x68C6   RenameCanceled
0x7879   ReadString
0x000B   NAMELEN
0x7E37   MsgClear
0x7E6C   MsgNewFileName
0x68CE   CheckKeyDel
0x6BD5   ViewFile
0x685E   CheckKeyRename
0x0001   DRIVE_B_CPM
0x684D   CheckKeyView
0x6942   SelectDrive
0x6844   CheckKeyDriveB
0x6DDF   ReadAllHeaders
0x683B   CheckKeyDriveA
0x7F9C   CopyFileDstDrv
0x7F85   CopySelOption
0x6810   CopyFileOK
0x7F88   CopyFileRes
0x73AF   CopyFile
0x682A   CheckKeyFileInfo
0x78BB   ClearNMsgLines
0x71B7   ReadFileHeader
0x7E29   MsgReadingExt
0x67DE   CheckKeyCopy
0x6B5A   HandleFile
0x67B9   CheckKeyInfo
0x67B3   DoKeyEnter
0x000D   KEY_ENTER
0x67AA   CheckEnter
0x679D   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6795   CheckLeft
0x6783   DoKeyRight
0x0009   KEY_RIGHT
0x677B   CheckRight
0x676E   DoKeyUp
0x000B   KEY_UP
0x6A69   MoveIt
0x6766   CheckUp
0x6755   DoKeyDown
0x000A   KEY_DOWN
0x6C6D   DisplayFileInfo
0x7F83   SelFileCache
0x6E9C   Mul
0x6733   CalcFileCache
0x7D58   MsgFilesCnt
0x7F7A   FileCnt
0x7D61   MsgFilesCntNo
0x7D48   MsgDrive
0x6E35   Word2Txt
0x7D53   MsgDriveLet
0x7F7F   AUCntUsed
0x7237   SetFastKeys
0x77F8   DrawCursor
0x0060   SCR_SEL_CLR
0x7CF9   MsgMessages
0x0007   LST_FILE_INFO
0x7CE9   MsgFileInf
0x0004   LST_DISK_INFO
0x7CD9   MsgDskInf
0x7CC9   MsgSysInf
0x7D09   BtnBar
0x0060   SCR_LBL_CLR
0x7CB9   VerMsg2
0x770F   PrintStr
0x0001   LST_PROG_INFO
0x7CA9   VerMsg1
0x7786   DrawHLines
0x77E0   DrawVLines
0x7F7D   CursorAddr
0x78D0   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x76EF   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x7F7B   NameCol
0x0010   LST_FIRST_COL
0x7F7C   SelFile
0x76D3   ReadChar
0x8DC6   DataBuf
0x7242   GetErrMsg
0x5C3A   ERRNR
0x6616   HCRunEnd
0x6744   ReadKeyLoop
0x66D1   DisplayDiskInfo
0x6AA1   DisplayFilenames
0x6653   InitUI
0x660A   HCRunMain
0x6AC1   GetFileNames
0x7737   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7D68   MsgErr
0x6E40   Byte2Txt
0x7D73   MsgErrCode
0x6607   HCRunCacheFiles
0x719A   ReadCatalogTrack
0x7F81   AUCntMaxFree
0x65E4   DriveIs80Tracks
0x7AD8   PrintOneLineCleanLine
0x013E   MAX_FREE_AU_CNT
0x7274   RWTSRes
0x6EBF   ReadOneDiskSector
0x8DC6   FileData
0x0050   TRACK_CNT
0x7284   BDOSSelectDisk
0x7269   RWTSDrive
0x7281   BDOSInit
0x0000   DRIVE_A_CPM
0x65C5   DetectTrackCount
0x728D   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x7FA8   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8DC6   TrackBuf
0x65A2   HCRunInitDisk
0x661E   ErrorHandler
0x5C3D   ERRSP
0x6EB0   IF1Init
0x76D9   InitFonts
0x6590   Start
