# file opened: hccmd.asm
   1  0000              	DEVICE ZXSPECTRUM48
   2  0000
   3  0000              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   4  0000
   5  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   6  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   7  0000              	;DEFINE  _REAL_HW_
   8  0000
   9  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
  10  0000              ;So we have to put our code after the program as loaded in RAM.
  11  0000              	ORG 26000
  12  6590
  13  6590              Start:
  14  6590              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  15  6590 CD BC 77     		call InitFonts
  16  6593              	ENDIF
  17  6593 CD 93 6F     	call IF1Init
  18  6596
  19  6596              	;install error handler
  20  6596 2A 3D 5C     	ld		hl, (ERRSP)
  21  6599 E5           	push	hl
  22  659A 21 1E 66     	ld		hl, ErrorHandler
  23  659D E5           	push	hl
  24  659E ED 73 3D 5C  	ld		(ERRSP), sp
  25  65A2
  26  65A2              HCRunInitDisk:
  27  65A2              	;Set track buffer to del marker
  28  65A2 21 B5 8E     	ld		hl, TrackBuf
  29  65A5 54           	ld		d, h
  30  65A6 5D           	ld		e, l
  31  65A7 13           	inc		de
  32  65A8 01 00 10     	ld		bc, SPT*SECT_SZ
  33  65AB 36 E5        	ld		(hl), DEL_MARKER
  34  65AD ED B0        	ldir
  35  65AF
  36  65AF              	;Invalidate file cache
  37  65AF 21 97 80     	ld		hl, FileCache
  38  65B2 54           	ld		d, h
  39  65B3 5D           	ld		e, l
  40  65B4 13           	inc		de
  41  65B5 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  42  65B8 36 00        	ld		(hl), 0
  43  65BA ED B0        	ldir
  44  65BC
  45  65BC              	;main program
  46  65BC CD 70 73     	call	BDOSGetCurrentDrive
  47  65BF FE FF        	cp		$FF
  48  65C1 20 02        	jr		nz, DetectTrackCount
  49  65C3
  50  65C3 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  51  65C5
  52  65C5              DetectTrackCount:
  53  65C5 F5           	push	af
  54  65C6 CD 64 73     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  55  65C9 F1           	pop		af
  56  65CA 32 4C 73     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  57  65CD CD 67 73     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  58  65D0
  59  65D0              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  60  65D0 1E 28        	ld		e, TRACK_CNT/2
  61  65D2 21 B5 8E     	ld		hl, FileData
  62  65D5 CD A2 6F     	call	ReadOneDiskSector
  63  65D8 3A 57 73     	ld		a, (RWTSRes)
  64  65DB B7           	or		a
  65  65DC 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  66  65DF 28 03        	jr		z, DriveIs80Tracks
  67  65E1 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  68  65E4              DriveIs80Tracks:
  69  65E4 22 70 80     	ld		(AUCntMaxFree), hl
  70  65E7
  71  65E7 CD 7D 72     	call 	ReadCatalogTrack
  72  65EA B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  73  65EB 28 1A        	jr		z, HCRunCacheFiles
  74  65ED
  75  65ED 6F           	ld		l, a
  76  65EE 26 00        	ld		h, 0
  77  65F0 11 62 7E     	ld		de, MsgErrCode
  78  65F3 CD 87 6E     	call	Byte2Txt
  79  65F6 21 57 7E     	ld		hl, MsgErr
  80  65F9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  81  65FC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  82  65FE CD 1A 78     	call	PrintStrClr
  83  6601 CD 64 73     	call	BDOSInit
  84  6604 C3 A2 65     	jp		HCRunInitDisk
  85  6607
  86  6607
  87  6607              HCRunCacheFiles:
  88  6607 CD C1 6A     	call 	GetFileNames
  89  660A
  90  660A              HCRunMain:
  91  660A CD 53 66     	call 	InitUI
  92  660D CD A1 6A     	call	DisplayFilenames
  93  6610 CD D1 66     	call	DisplayDiskInfo
  94  6613 C3 44 67     	jp		ReadKeyLoop
  95  6616
  96  6616              HCRunEnd:
  97  6616              	;restore error handler
  98  6616 E1           	pop		hl
  99  6617 E1           	pop		hl
 100  6618 22 3D 5C     	ld		(ERRSP), hl
 101  661B
 102  661B              	;ret
 103  661B C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 104  661E
 105  661E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 106  661E
 107  661E              ErrorHandler:
 108  661E E1           	pop		hl
 109  661F 22 3D 5C     	ld		(ERRSP), hl
 110  6622
 111  6622 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 112  6625 6F           	ld		l, a
 113  6626 26 00        	ld		h, 0
 114  6628 11 62 7E     	ld		de, MsgErrCode
 115  662B CD 87 6E     	call	Byte2Txt
 116  662E 21 57 7E     	ld		hl, MsgErr
 117  6631 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 118  6634 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 119  6636 CD 1A 78     	call	PrintStrClr
 120  6639
 121  6639 3A 3A 5C     	ld		a, (ERRNR)
 122  663C CD 25 73     	call	GetErrMsg
 123  663F
 124  663F 21 B5 8E     	ld		hl, DataBuf
 125  6642 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 126  6645 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 127  6647 CD 1A 78     	call	PrintStrClr
 128  664A
 129  664A CD B6 77     	call	ReadChar
 130  664D CD 64 73     	call	BDOSInit
 131  6650 C3 90 65     	jp		Start
 132  6653
 133  6653
 134  6653
 135  6653
 136  6653              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 137  6653
 138  6653              InitUI:
 139  6653 AF           	xor		a
 140  6654 32 6B 80     	ld		(SelFile), A
 141  6657 3E 11        	ld		a, LST_FIRST_COL + 1
 142  6659 32 6A 80     	ld		(NameCol), A
 143  665C 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 144  665F ED 53 B0 5C  	ld		(LineCol), de
 145  6663
 146  6663 CD D2 77     	call	ClrScr
 147  6666
 148  6666 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 149  6669 ED 4B B3 79  	ld		bc, (CurrScrAttrAddr)
 150  666D 09           	add		hl, bc
 151  666E 22 6C 80     	ld		(CursorAddr), hl
 152  6671
 153  6671 CD C3 78     	call	DrawVLines
 154  6674
 155  6674 CD 69 78     	call	DrawHLines
 156  6677
 157  6677 21 98 7D     	ld		hl, VerMsg1
 158  667A 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 159  667D 3A A7 7D     	ld		a, (VerMsg1 + 15)
 160  6680 F6 80        	or		$80
 161  6682 32 A7 7D     	ld		(VerMsg1 + 15), a
 162  6685 CD F2 77     	call	PrintStr
 163  6688 21 A8 7D     	ld		hl, VerMsg2
 164  668B 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 165  668E CD F2 77     	call	PrintStr
 166  6691
 167  6691 3E 60        	ld		a, SCR_LBL_CLR
 168  6693 11 00 17     	ld		de, 23 << 8
 169  6696 21 F8 7D     	ld		hl, BtnBar
 170  6699 CD 1A 78     	call	PrintStrClr
 171  669C
 172  669C 3E 60        	ld		a, SCR_LBL_CLR
 173  669E 21 B8 7D     	ld		hl, MsgSysInf
 174  66A1 11 00 01     	ld		de, LST_PROG_INFO << 8
 175  66A4 CD 1A 78     	call	PrintStrClr
 176  66A7
 177  66A7 3E 60        	ld		a, SCR_LBL_CLR
 178  66A9 21 C8 7D     	ld		hl, MsgDskInf
 179  66AC 11 00 04     	ld		de, LST_DISK_INFO << 8
 180  66AF CD 1A 78     	call	PrintStrClr
 181  66B2
 182  66B2 3E 60        	ld		a, SCR_LBL_CLR
 183  66B4 21 D8 7D     	ld		hl, MsgFileInf
 184  66B7 11 00 07     	ld		de, LST_FILE_INFO << 8
 185  66BA CD 1A 78     	call	PrintStrClr
 186  66BD
 187  66BD 3E 60        	ld		a, SCR_LBL_CLR
 188  66BF 21 E8 7D     	ld		hl, MsgMessages
 189  66C2 11 00 0D     	ld		de, LST_LINE_MSG << 8
 190  66C5 CD 1A 78     	call	PrintStrClr
 191  66C8
 192  66C8 3E 60        	ld		a, SCR_SEL_CLR
 193  66CA CD DB 78     	call	DrawCursor
 194  66CD
 195  66CD CD 1A 73     	call	SetFastKeys
 196  66D0
 197  66D0 C9           	ret
 198  66D1
 199  66D1
 200  66D1              DisplayDiskInfo:
 201  66D1 2A 70 80     	ld		hl, (AUCntMaxFree)
 202  66D4 ED 5B 6E 80  	ld		de, (AUCntUsed)
 203  66D8 B7           	or		a
 204  66D9 ED 52        	sbc		hl, de
 205  66DB CB 15        	rl		l								;*2, 2K/AU
 206  66DD CB 14        	rl		h
 207  66DF
 208  66DF 11 42 7E     	ld		de, MsgDriveLet
 209  66E2 CD 7C 6E     	call	Word2Txt
 210  66E5 3A 46 7E     	ld		a, (MsgDriveLet+4)
 211  66E8 F6 80        	or		$80
 212  66EA 32 46 7E     	ld		(MsgDriveLet+4), a
 213  66ED
 214  66ED 3A 4C 73     	ld		a, (RWTSDrive)
 215  66F0 C6 41        	add		'A'
 216  66F2 32 42 7E     	ld		(MsgDriveLet), a
 217  66F5 3E 2F        	ld		a, '/'
 218  66F7 32 43 7E     	ld		(MsgDriveLet+1), a
 219  66FA
 220  66FA 21 37 7E     	ld		hl, MsgDrive
 221  66FD 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 222  6700 CD F2 77     	call	PrintStr
 223  6703
 224  6703 2A 6E 80     	ld		hl, (AUCntUsed)
 225  6706 CB 15        	rl		l								;*2, 2K/AU
 226  6708 CB 14        	rl		h
 227  670A 11 52 7E     	ld		de, MsgFilesCntNo+2
 228  670D CD 7C 6E     	call	Word2Txt
 229  6710 3A 56 7E     	ld		a, (MsgFilesCntNo+6)
 230  6713 F6 80        	or		$80
 231  6715 32 56 7E     	ld		(MsgFilesCntNo+6), a
 232  6718 3E 2F        	ld		a, '/'
 233  671A 32 53 7E     	ld		(MsgFilesCntNo+3), a
 234  671D
 235  671D 3A 69 80     	ld		a, (FileCnt)
 236  6720 6F           	ld		l, a
 237  6721 26 00        	ld		h, 0
 238  6723 11 50 7E     	ld		de, MsgFilesCntNo
 239  6726 CD 87 6E     	call	Byte2Txt
 240  6729 21 47 7E     	ld		hl, MsgFilesCnt
 241  672C 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 242  672F CD F2 77     	call	PrintStr
 243  6732
 244  6732 C9           	ret
 245  6733
 246  6733              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247  6733
 248  6733              CalcFileCache:
 249  6733 3A 6B 80     	ld		a, (SelFile)
 250  6736 11 19 00     	ld		de, CACHE_SZ
 251  6739 CD E3 6E     	call	Mul
 252  673C 01 97 80     	ld		bc, FileCache
 253  673F 09           	add		hl, bc					;HL = file AU cnt
 254  6740 22 72 80     	ld		(SelFileCache), hl
 255  6743 C9           	ret
 256  6744
 257  6744              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 258  6744
 259  6744
 260  6744              ReadKeyLoop:
 261  6744 CD 33 67     	call	CalcFileCache
 262  6747 CD B4 6C     	call	DisplayFileInfo
 263  674A
 264  674A CD B6 77     	call	ReadChar
 265  674D
 266  674D FE 0A        	cp		KEY_DOWN
 267  674F 28 04        	jr		z,  DoKeyDown
 268  6751 FE 61        	cp 		'a'
 269  6753 20 11        	jr		nz, CheckUp
 270  6755
 271  6755              DoKeyDown:
 272  6755 3A 69 80     	ld		a, (FileCnt)
 273  6758 47           	ld		b, a
 274  6759 3A 6B 80     	ld		a, (SelFile)
 275  675C 3C           	inc		a
 276  675D B8           	cp		b
 277  675E 30 E4        	jr		nc, ReadKeyLoop
 278  6760 32 6B 80     	ld		(SelFile), a
 279  6763 C3 69 6A     	jp		MoveIt
 280  6766
 281  6766              CheckUp:
 282  6766 FE 0B        	cp		KEY_UP
 283  6768 28 04        	jr		z, DoKeyUp
 284  676A FE 71        	cp 		'q'
 285  676C 20 0D        	jr		nz, CheckRight
 286  676E
 287  676E              DoKeyUp:
 288  676E 3A 6B 80     	ld		a, (SelFile)
 289  6771 B7           	or		a
 290  6772 28 D0        	jr		z, ReadKeyLoop
 291  6774
 292  6774 3D           	dec		a
 293  6775 32 6B 80     	ld		(SelFile), a
 294  6778 C3 69 6A     	jp		MoveIt
 295  677B
 296  677B              CheckRight:
 297  677B FE 09        	cp		KEY_RIGHT
 298  677D 28 04        	jr		z, DoKeyRight
 299  677F FE 70        	cp 		'p'
 300  6781 20 12        	jr		nz, CheckLeft
 301  6783
 302  6783              DoKeyRight:
 303  6783 3A 69 80     	ld		a, (FileCnt)
 304  6786 47           	ld		b, a
 305  6787 3A 6B 80     	ld		a, (SelFile)
 306  678A C6 15        	add		LST_LINES_CNT
 307  678C B8           	cp		b
 308  678D 30 B5        	jr		nc, ReadKeyLoop
 309  678F
 310  678F 32 6B 80     	ld		(SelFile), a
 311  6792 C3 69 6A     	jp		MoveIt
 312  6795
 313  6795              CheckLeft:
 314  6795 FE 08        	cp		KEY_LEFT
 315  6797 28 04        	jr		z, DoKeyLeft
 316  6799 FE 6F        	cp		'o'
 317  679B 20 0D        	jr		nz, CheckEnter
 318  679D
 319  679D              DoKeyLeft:
 320  679D 3A 6B 80     	ld		a, (SelFile)
 321  67A0 D6 15        	sub		LST_LINES_CNT
 322  67A2 38 A0        	jr		c, ReadKeyLoop
 323  67A4
 324  67A4 32 6B 80     	ld		(SelFile), a
 325  67A7 C3 69 6A     	jp		MoveIt
 326  67AA
 327  67AA              CheckEnter:
 328  67AA FE 0D        	cp		KEY_ENTER
 329  67AC 28 05        	jr		z, DoKeyEnter
 330  67AE FE 6D        	cp		'm'
 331  67B0 C2 B9 67     	jp		nz, CheckKeyInfo
 332  67B3
 333  67B3              DoKeyEnter:
 334  67B3 CD 5A 6B     	call	HandleFile
 335  67B6 C3 0A 66     	jp		HCRunMain
 336  67B9
 337  67B9              CheckKeyInfo:
 338  67B9 FE 34        	cp		'4'
 339  67BB 20 21        	jr		nz, CheckKeyCopy
 340  67BD
 341  67BD 3A 69 80     	ld		a, (FileCnt)
 342  67C0 B7           	or		a
 343  67C1 CA 44 67     	jp		z, ReadKeyLoop
 344  67C4
 345  67C4 DD 2A 72 80  	ld		ix, (SelFileCache)
 346  67C8 21 18 7F     	ld		hl, MsgReadingExt
 347  67CB 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 348  67CE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 349  67D0 CD 1A 78     	call	PrintStrClr
 350  67D3 CD 9A 72     	call	ReadFileHeader
 351  67D6 06 01        	ld		b, 1
 352  67D8 CD 9E 79     	call	ClearNMsgLines
 353  67DB C3 44 67     	jp		ReadKeyLoop
 354  67DE
 355  67DE              CheckKeyCopy:
 356  67DE FE 35        	cp		'5'
 357  67E0 C2 2A 68     	jp		nz, CheckKeyFileInfo
 358  67E3
 359  67E3 3A 69 80     	ld		a, (FileCnt)
 360  67E6 B7           	or		a
 361  67E7 CA 44 67     	jp		z, ReadKeyLoop
 362  67EA
 363  67EA 2A 72 80     	ld		hl, (SelFileCache)
 364  67ED CD 92 74     	call	CopyFile
 365  67F0 3A 77 80     	ld		a, (CopyFileRes)
 366  67F3 B7           	or		a
 367  67F4 28 1A        	jr		z, CopyFileOK
 368  67F6
 369  67F6 6F           	ld		l, a
 370  67F7 26 00        	ld		h, 0
 371  67F9 11 62 7E     	ld		de, MsgErrCode
 372  67FC CD 87 6E     	call	Byte2Txt
 373  67FF 21 57 7E     	ld		hl, MsgErr
 374  6802 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 375  6805 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 376  6807 CD 1A 78     	call	PrintStrClr
 377  680A CD B6 77     	call	ReadChar
 378  680D C3 44 67     	jp		ReadKeyLoop
 379  6810
 380  6810              CopyFileOK:
 381  6810 06 02        	ld		b, 2
 382  6812 CD 9E 79     	call	ClearNMsgLines
 383  6815              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 384  6815 3A 74 80     	ld		a, (CopySelOption)
 385  6818 FE 33        	cp		'3'
 386  681A CA 44 67     	jp		z, ReadKeyLoop
 387  681D 3A 8B 80     	ld		a, (CopyFileDstDrv)
 388  6820 3D           	dec		a
 389  6821 32 4C 73     	ld		(RWTSDrive), a
 390  6824 CD 67 73     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 391  6827 C3 A2 65     	jp		HCRunInitDisk
 392  682A
 393  682A              CheckKeyFileInfo:
 394  682A FE 20        	cp		' '
 395  682C 20 0D        	jr		nz, CheckKeyDriveA
 396  682E
 397  682E 3A 69 80     	ld		a, (FileCnt)
 398  6831 B7           	or		a
 399  6832 CA 44 67     	jp		z, ReadKeyLoop
 400  6835
 401  6835 CD 26 6E     	call	ReadAllHeaders
 402  6838 C3 44 67     	jp		ReadKeyLoop
 403  683B
 404  683B              CheckKeyDriveA:
 405  683B FE 31        	cp		'1'
 406  683D 20 05        	jr		nz, CheckKeyDriveB
 407  683F 3E 00        	ld		a, DRIVE_A_CPM
 408  6841 C3 42 69     	jp		SelectDrive
 409  6844
 410  6844              CheckKeyDriveB:
 411  6844 FE 32        	cp		'2'
 412  6846 20 05        	jr		nz, CheckKeyView
 413  6848 3E 01        	ld		a, DRIVE_B_CPM
 414  684A C3 42 69     	jp		SelectDrive
 415  684D
 416  684D              CheckKeyView:
 417  684D FE 33        	cp		'3'
 418  684F 20 0D        	jr		nz, CheckKeyRename
 419  6851
 420  6851 3A 69 80     	ld		a, (FileCnt)
 421  6854 B7           	or		a
 422  6855 CA 44 67     	jp		z, ReadKeyLoop
 423  6858
 424  6858 CD D5 6B     	call	ViewFile
 425  685B C3 0A 66     	jp		HCRunMain
 426  685E
 427  685E              CheckKeyRename:
 428  685E FE 36        	cp		'6'
 429  6860 20 6C        	jr		nz, CheckKeyDel
 430  6862
 431  6862 3A 69 80     	ld		a, (FileCnt)
 432  6865 B7           	or		a
 433  6866 CA 44 67     	jp		z, ReadKeyLoop
 434  6869
 435  6869 21 5B 7F     	ld		hl, MsgNewFileName
 436  686C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 437  686F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 438  6871 CD 1A 78     	call	PrintStrClr
 439  6874
 440  6874 21 26 7F     	ld		hl, MsgClear
 441  6877 11 B5 8E     	ld		de, FileData
 442  687A 01 0B 00     	ld		bc, NAMELEN
 443  687D ED B0        	ldir
 444  687F 3E A0        	ld		a, $80 | ' '
 445  6881 12           	ld		(de), a
 446  6882 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 447  6885 21 B5 8E     	ld		hl, FileData
 448  6888 CD F2 77     	call	PrintStr
 449  688B
 450  688B 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 451  688E 01 0B 00     	ld		bc, NAMELEN
 452  6891 CD 5C 79     	call	ReadString
 453  6894
 454  6894 11 B5 8E     	ld		de, FileData
 455  6897 1A           	ld		a, (de)
 456  6898 FE 20        	cp		' '					;If starting with space, input was canceled.
 457  689A CA C6 68     	jp		z, RenameCanceled
 458  689D
 459  689D              	;Check if new name doesn't exist already. Cancel if so.
 460  689D 21 B5 8E     	ld		hl, FileData
 461  68A0 3A 4C 73     	ld 		a, (RWTSDrive)
 462  68A3 3C           	inc		a
 463  68A4 CD F8 73     	call	DoesFileExist
 464  68A7 3C           	inc		a
 465  68A8 28 10        	jr		z, RenameFileNotExist
 466  68AA
 467  68AA 21 FF 7F     	ld		hl, MsgFileExists
 468  68AD 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 469  68B0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 470  68B2 CD 1A 78     	call	PrintStrClr
 471  68B5 CD B6 77     	call	ReadChar
 472  68B8 18 0C        	jr		RenameCanceled
 473  68BA
 474  68BA              RenameFileNotExist:
 475  68BA 11 B5 8E     	ld		de, FileData
 476  68BD 2A 72 80     	ld		hl, (SelFileCache)
 477  68C0 CD 3B 74     	call	RenameFile
 478  68C3 C3 A2 65     	jp		HCRunInitDisk
 479  68C6
 480  68C6              RenameCanceled:
 481  68C6 06 02        	ld		b, 2
 482  68C8 CD 9E 79     	call	ClearNMsgLines
 483  68CB C3 44 67     	jp		ReadKeyLoop
 484  68CE
 485  68CE              CheckKeyDel:
 486  68CE FE 38        	cp		'8'
 487  68D0 20 2E        	jr		nz, CheckKeyAttrib
 488  68D2
 489  68D2 3A 69 80     	ld		a, (FileCnt)
 490  68D5 B7           	or		a
 491  68D6 CA 44 67     	jp		z, ReadKeyLoop
 492  68D9
 493  68D9 21 36 7F     	ld		hl, MsgDelete
 494  68DC 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 495  68DF 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 496  68E1 CD 1A 78     	call	PrintStrClr
 497  68E4 CD B6 77     	call	ReadChar
 498  68E7 FE 79        	cp		'y'
 499  68E9 28 08        	jr		z, DoFileDelete
 500  68EB 06 01        	ld		b, 1
 501  68ED CD 9E 79     	call	ClearNMsgLines
 502  68F0 C3 44 67     	jp		ReadKeyLoop
 503  68F3              DoFileDelete:
 504  68F3 2A 72 80     	ld		hl, (SelFileCache)
 505  68F6 3A 4C 73     	ld 		a, (RWTSDrive)
 506  68F9 3C           	inc		a					;Convert to BASIC drive number: 1,2
 507  68FA CD EC 73     	call	DeleteFile
 508  68FD C3 A2 65     	jp		HCRunInitDisk
 509  6900
 510  6900              CheckKeyAttrib:
 511  6900 FE 37        	cp		'7'
 512  6902 20 47        	jr		nz, CheckKeyDiskMenu
 513  6904
 514  6904 3A 69 80     	ld		a, (FileCnt)
 515  6907 B7           	or		a
 516  6908 CA 44 67     	jp		z, ReadKeyLoop
 517  690B
 518  690B 21 43 7F     	ld		hl, MsgSetRO
 519  690E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 520  6911 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 521  6913 CD 1A 78     	call	PrintStrClr
 522  6916 CD B6 77     	call	ReadChar
 523  6919 1E 00        	ld		e, 0
 524  691B FE 79        	cp		'y'
 525  691D 20 02        	jr		nz, CheckSYS
 526  691F 1E 01        	ld		e, 1
 527  6921
 528  6921              CheckSYS:
 529  6921 D5           	push	de
 530  6922 21 4F 7F     		ld		hl, MsgSetSYS
 531  6925 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 532  6928 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 533  692A CD 1A 78     		call	PrintStrClr
 534  692D CD B6 77     		call	ReadChar
 535  6930 FE 79        		cp		'y'
 536  6932 D1           	pop		de
 537  6933 20 04        	jr		nz, AttrChange
 538  6935 3E 02        	ld		a, %10
 539  6937 B3           	or		e
 540  6938 5F           	ld		e, a
 541  6939
 542  6939              AttrChange:
 543  6939 2A 72 80     	ld		hl, (SelFileCache)
 544  693C CD 11 74     	call	ChangeFileAttrib
 545  693F C3 A2 65     	jp		HCRunInitDisk
 546  6942
 547  6942              SelectDrive:
 548  6942 32 4C 73     	ld 		(RWTSDrive), a
 549  6945 CD 67 73     	call	BDOSSelectDisk
 550  6948              	;call	BDOSInit
 551  6948 C3 A2 65     	jp		HCRunInitDisk
 552  694B
 553  694B              CheckKeyDiskMenu:
 554  694B FE 39        	cp		'9'
 555  694D C2 61 6A     	jp		nz, CheckKeyExit
 556  6950
 557  6950 3A 4C 73     	ld		a, (RWTSDrive)
 558  6953 C6 41        	add		'A'
 559  6955              	;Update menu messages with current drive.
 560  6955 32 98 7F     	ld		(MsgMenuSingleDrv1), a
 561  6958 32 9C 7F     	ld		(MsgMenuSingleDrv2), a
 562  695B 32 A6 7F     	ld		(MsgMenuDualDrv1), a
 563  695E 32 B4 7F     	ld		(MsgMenuToComDrv), a
 564  6961 32 C8 7F     	ld		(MsgMenuFromCOMDrv), a
 565  6964              	;Update menu messages with the alternate drive.
 566  6964 3A 4C 73     	ld		a, (RWTSDrive)
 567  6967 3C           	inc		a
 568  6968 EE 03        	xor		%11
 569  696A C6 40        	add		'A'-1
 570  696C 32 AA 7F     	ld		(MsgMenuDualDrv2), a
 571  696F
 572  696F 21 6B 7F     	ld		hl, MsgMenuDiskCopy
 573  6972 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 574  6975 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 575  6977 CD 1A 78     	call	PrintStrClr
 576  697A 21 84 7F     	ld		hl, MsgMenuBack
 577  697D 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 578  6980 CD F2 77     	call	PrintStr
 579  6983 21 90 7F     	ld		hl, MsgMenuSingle
 580  6986 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 581  6989 CD F2 77     	call	PrintStr
 582  698C 21 9E 7F     	ld		hl, MsgMenuDual
 583  698F 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 584  6992 CD F2 77     	call	PrintStr
 585  6995 21 AC 7F     	ld		hl, MsgMenuToCOM
 586  6998 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 587  699B CD F2 77     	call	PrintStr
 588  699E 21 BB 7F     	ld		hl, MsgMenuFromCOM
 589  69A1 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 590  69A4 CD F2 77     	call	PrintStr
 591  69A7 21 CA 7F     	ld		hl, MsgMenuFmt1
 592  69AA 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 593  69AD CD F2 77     	call	PrintStr
 594  69B0 21 D6 7F     	ld		hl, MsgMenuFmt2
 595  69B3 11 00 15     	ld		de, LST_LINE_MSG + 8 << 8
 596  69B6 CD F2 77     	call	PrintStr
 597  69B9
 598  69B9 CD B6 77     	call	ReadChar
 599  69BC F5           	push	af
 600  69BD 06 08        		ld		b, 8
 601  69BF CD 9E 79     		call	ClearNMsgLines
 602  69C2 F1           	pop		af
 603  69C3 32 74 80     	ld		(CopySelOption), a
 604  69C6
 605  69C6              CheckKeyDiskMenuLoop:
 606  69C6 FE 30        	cp		'0'
 607  69C8 CA 5E 6A     	jp		z, DiskMenuExit
 608  69CB
 609  69CB              	;Single drive copy
 610  69CB FE 31        	cp		'1'
 611  69CD 20 0B        	jr		nz, CheckDiskMenuDualDrive
 612  69CF CD 89 70     	call	CopyDisk
 613  69D2 06 02        	ld		b, 2
 614  69D4 CD 9E 79     	call	ClearNMsgLines
 615  69D7 C3 5E 6A     	jp		DiskMenuExit
 616  69DA
 617  69DA              	;Dual drive copy
 618  69DA              CheckDiskMenuDualDrive:
 619  69DA FE 32        	cp		'2'
 620  69DC 20 0A        	jr		nz, CheckDiskMenuToCOM
 621  69DE CD 89 70     	call	CopyDisk
 622  69E1 06 02        	ld		b, 2
 623  69E3 CD 9E 79     	call	ClearNMsgLines
 624  69E6 18 76        	jr		DiskMenuExit
 625  69E8
 626  69E8              CheckDiskMenuToCOM:
 627  69E8 FE 33        	cp		'3'
 628  69EA 20 05        	jr		nz, CheckDiskMenuFromCOM
 629  69EC CD 42 71     	call	CopyDiskToCOM
 630  69EF 18 6D        	jr		DiskMenuExit
 631  69F1
 632  69F1              CheckDiskMenuFromCOM:
 633  69F1 FE 34        	cp		'4'
 634  69F3 20 06        	jr		nz, CheckDiskMenuFormat1
 635  69F5 CD 9E 71     	call	CopyDiskFromCOM
 636  69F8 C3 A2 65     	jp		HCRunInitDisk
 637  69FB
 638  69FB              CheckDiskMenuFormat1:
 639  69FB FE 35        	cp		'5'
 640  69FD C2 0A 6A     	jp		nz, CheckDiskMenuFormat2
 641  6A00
 642  6A00 3E 00        	ld		a, DRIVE_A_CPM
 643  6A02 32 4C 73     	ld		(RWTSDrive), a
 644  6A05 21 CD 7F     	ld		hl, MsgMenuFmt1+3
 645  6A08 18 0D        	jr		FormatDiskAction
 646  6A0A
 647  6A0A              CheckDiskMenuFormat2:
 648  6A0A FE 36        	cp		'6'
 649  6A0C C2 0A 66     	jp		nz, HCRunMain
 650  6A0F
 651  6A0F 3E 01        	ld		a, DRIVE_B_CPM
 652  6A11 32 4C 73     	ld		(RWTSDrive), a
 653  6A14 21 D9 7F     	ld		hl, MsgMenuFmt2+3
 654  6A17
 655  6A17              FormatDiskAction:
 656  6A17 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 657  6A1A 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 658  6A1C CD 1A 78     	call	PrintStrClr
 659  6A1F
 660  6A1F 21 4A 80     	ld		hl, MsgAreYouSure
 661  6A22 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 662  6A25 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 663  6A27 CD 1A 78     	call	PrintStrClr
 664  6A2A CD B6 77     	call	ReadChar
 665  6A2D FE 79        	cp		'y'
 666  6A2F C2 0A 66     	jp		nz, HCRunMain
 667  6A32
 668  6A32 21 26 7F     	ld		hl, MsgClear
 669  6A35 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 670  6A38 3E 45        	ld		a, SCR_DEF_CLR
 671  6A3A CD 1A 78     	call	PrintStrClr
 672  6A3D
 673  6A3D CD B8 6F     	call	FormatDisk
 674  6A40 B7           	or		a
 675  6A41 CA A2 65     	jp		z, HCRunInitDisk
 676  6A44
 677  6A44              	;Display error for format
 678  6A44 6F           	ld		l, a
 679  6A45 26 00        	ld		h, 0
 680  6A47 11 62 7E     	ld		de, MsgErrCode
 681  6A4A CD 87 6E     	call	Byte2Txt
 682  6A4D 21 57 7E     	ld		hl, MsgErr
 683  6A50 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 684  6A53 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 685  6A55 CD 1A 78     	call	PrintStrClr
 686  6A58 CD B6 77     	call	ReadChar
 687  6A5B C3 A2 65     	jp		HCRunInitDisk
 688  6A5E
 689  6A5E              DiskMenuExit:
 690  6A5E C3 44 67     	jp		ReadKeyLoop
 691  6A61
 692  6A61              CheckKeyExit:
 693  6A61 FE 30        	cp		'0'
 694  6A63 C2 44 67     	jp		nz, ReadKeyLoop
 695  6A66 C3 16 66     	jp		HCRunEnd
 696  6A69              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 697  6A69
 698  6A69              MoveIt:
 699  6A69 CD E6 78     	call 	MoveCursor
 700  6A6C C3 44 67     	jp		ReadKeyLoop
 701  6A6F
 702  6A6F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 703  6A6F
 704  6A6F
 705  6A6F              DisplayFilename:
 706  6A6F 06 0B        	LD		B, NAMELEN
 707  6A71              DispLoop:
 708  6A71 1A           	LD		A, (DE)
 709  6A72
 710  6A72              	;clear bit 7
 711  6A72 CB BF        	RES 	7, A
 712  6A74 32 81 5C     	LD		(CODE), A
 713  6A77
 714  6A77 13           	INC		DE
 715  6A78 D5           	PUSH	DE
 716  6A79 C5           	PUSH	BC
 717  6A7A CD 1E 79     		CALL	PrintChar
 718  6A7D C1           	POP		BC
 719  6A7E D1           	POP 	DE
 720  6A7F
 721  6A7F 21 B0 5C     	LD		HL, COL
 722  6A82 34           	INC		(HL)
 723  6A83 10 EC        	DJNZ	DispLoop
 724  6A85              	;now a name is displayed
 725  6A85
 726  6A85              	;check bounds
 727  6A85 3A B1 5C     	LD		A, (LINE)
 728  6A88 3C           	INC		A
 729  6A89 FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 730  6A8B 38 0A        	JR		C, LineOK
 731  6A8D
 732  6A8D              	;set names column to the next one
 733  6A8D 3A 6A 80     	LD		A, (NameCol)
 734  6A90 C6 0C        	ADD		NAMELEN + 1
 735  6A92 32 6A 80     	LD		(NameCol), A
 736  6A95
 737  6A95 3E 01        	LD		A, LST_FIRST_LINE
 738  6A97              LineOK:
 739  6A97 32 B1 5C     	LD		(LINE), A
 740  6A9A
 741  6A9A 3A 6A 80     	LD		A, (NameCol)
 742  6A9D 32 B0 5C     	LD		(COL), A
 743  6AA0
 744  6AA0 C9           	RET
 745  6AA1
 746  6AA1
 747  6AA1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 748  6AA1
 749  6AA1              DisplayFilenames:
 750  6AA1 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 751  6AA4 ED 53 B0 5C  	ld		(LineCol), de
 752  6AA8
 753  6AA8 11 97 80     	ld		de, FileCache
 754  6AAB 3A 69 80     	ld		a, (FileCnt)
 755  6AAE B7           	or		a
 756  6AAF C8           	ret		z
 757  6AB0
 758  6AB0 47           	ld		b,	a
 759  6AB1
 760  6AB1              DisplayFilenamesLoop:
 761  6AB1 C5           	push	bc
 762  6AB2 D5           		push	de
 763  6AB3 CD 6F 6A     			call	DisplayFilename
 764  6AB6 D1           		pop		de
 765  6AB7 EB           		ex		de, hl
 766  6AB8 01 19 00     		ld		bc, CACHE_SZ
 767  6ABB 09           		add		hl, bc
 768  6ABC EB           		ex		de, hl
 769  6ABD C1           	pop		bc
 770  6ABE 10 F1        	djnz	DisplayFilenamesLoop
 771  6AC0
 772  6AC0 C9           	ret
 773  6AC1
 774  6AC1
 775  6AC1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 776  6AC1              ;Selects only valid filenames (not deleted and only from first extension)
 777  6AC1              GetFileNames:
 778  6AC1 DD 21 B5 8E  	ld		ix, TrackBuf
 779  6AC5 11 97 80     	ld		de, FileCache
 780  6AC8 06 80        	ld		b, MAX_EXT_CNT
 781  6ACA AF           	xor		a
 782  6ACB 32 69 80     	ld		(FileCnt), a
 783  6ACE 21 6E 80     	ld		hl, AUCntUsed
 784  6AD1 77           	ld		(hl), a
 785  6AD2 23           	inc		hl
 786  6AD3 77           	ld		(hl), a
 787  6AD4
 788  6AD4              StoreFilenamesLoop:
 789  6AD4 AF           	xor a
 790  6AD5 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 791  6AD8 C2 4C 6B     	jp nz, NextExt
 792  6ADB
 793  6ADB              	;count AU
 794  6ADB D9           	exx
 795  6ADC E5           	push hl
 796  6ADD CD E7 6F     		call CheckExtAlloc
 797  6AE0 EB           		ex de, hl			;save first AU no.
 798  6AE1
 799  6AE1              		;store disk alocated AU count
 800  6AE1 2A 6E 80     		ld hl, (AUCntUsed)
 801  6AE4 48           		ld c, b
 802  6AE5 06 00        		ld b, 0
 803  6AE7 09           		add hl, bc
 804  6AE8 22 6E 80     		ld (AUCntUsed), hl
 805  6AEB E1           	pop hl
 806  6AEC D9           	exx
 807  6AED
 808  6AED AF           	xor	a
 809  6AEE DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 810  6AF1 20 32        	jr nz, FindExt
 811  6AF3
 812  6AF3 DD E5        	push ix
 813  6AF5 E1           	pop hl
 814  6AF6 23           	inc hl					;skip del flag
 815  6AF7
 816  6AF7 C5           	push bc
 817  6AF8 ~            		/*
 818  6AF8 ~            		push de
 819  6AF8 ~            			push hl
 820  6AF8 ~            				ex de, hl
 821  6AF8 ~            				call DisplayFilename
 822  6AF8 ~            			pop hl
 823  6AF8 ~            		pop de
 824  6AF8 ~            		*/
 825  6AF8 01 0B 00     		ld bc, NAMELEN
 826  6AFB ED B0        		ldir				;save file name
 827  6AFD
 828  6AFD D9           		exx
 829  6AFE D5           		push 	de			;de = first AU
 830  6AFF D9           		exx
 831  6B00 E1           		pop		hl
 832  6B01 EB           		ex		de, hl
hccmd.asm(833): warning: Fake instruction: ld		(hl), de
 833  6B02 73 23 72 2B  		ld		(hl), de	;save first AU
 834  6B06
 835  6B06 23           		inc		hl
 836  6B07 23           		inc		hl
 837  6B08
 838  6B08 D9           		exx					;save AU cnt for file
 839  6B09 C5           		push	bc
 840  6B0A D9           		exx
 841  6B0B C1           		pop		bc
hccmd.asm(842): warning: Fake instruction: ld		(hl), bc
 842  6B0C 71 23 70 2B  		ld		(hl), bc
 843  6B10
 844  6B10 23           		inc		hl
 845  6B11 23           		inc		hl
 846  6B12
 847  6B12              		;xor		a			;make flag 0 to signal that header is not read yet
 848  6B12              		;ld		(hl), a
 849  6B12
 850  6B12 01 0A 00     		ld		bc, HDR_SZ + 1
 851  6B15 09           		add		hl, bc
 852  6B16
 853  6B16 EB           		ex		de, hl
 854  6B17 C1           	pop bc
 855  6B18
 856  6B18
 857  6B18 3A 69 80     	ld 		a, (FileCnt)			;inc file counter
 858  6B1B 3C           	inc		a
 859  6B1C 32 69 80     	ld 		(FileCnt), a
 860  6B1F FE 54        	cp		LST_MAX_FILES
 861  6B21 38 29        	jr		c, NextExt
 862  6B23 18 34        	jr		GetFileNamesEnd
 863  6B25
 864  6B25
 865  6B25              FindExt:					;BC' = AU cnt for this ext
 866  6B25 C5           	push	bc
 867  6B26 D5           		push 	de
 868  6B27 DD E5        			push	ix
 869  6B29 D1           			pop		de
 870  6B2A 13           			inc		de				;DE = name to find
 871  6B2B
 872  6B2B 21 97 80     			ld		hl, FileCache
 873  6B2E 3A 69 80     			ld		a, (FileCnt)
 874  6B31 4F           			ld		c, a
 875  6B32 CD 89 72     			call	FindCache
 876  6B35 20 13        			jr		nz, FindExtEnd
 877  6B37
 878  6B37 01 0D 00     			ld		bc, CACHE_AU_CNT
 879  6B3A 09           			add		hl, bc
 880  6B3B D9           			exx
 881  6B3C C5           			push	bc
 882  6B3D D9           			exx
 883  6B3E C1           			pop		bc
 884  6B3F
hccmd.asm(885): warning: Fake instruction: ld		de, (hl)
 885  6B3F 5E 23 56 2B  			ld		de, (hl)		;DE = Current AU CNT for file
 886  6B43 EB           			ex		de, hl
 887  6B44 09           			add		hl, bc
 888  6B45 EB           			ex		de, hl
hccmd.asm(889): warning: Fake instruction: ld		(hl), de
 889  6B46 73 23 72 2B  			ld		(hl), de
 890  6B4A              FindExtEnd:
 891  6B4A D1           		pop		de
 892  6B4B C1           	pop		bc
 893  6B4C
 894  6B4C              NextExt:
 895  6B4C C5           	push bc
 896  6B4D 01 20 00     		ld bc, EXT_SZ
 897  6B50 DD 09        		add ix, bc
 898  6B52 C1           	pop	bc
 899  6B53
 900  6B53 05           	dec	b
 901  6B54 78           	ld	a, b
 902  6B55 B7           	or	a
 903  6B56 C2 D4 6A     	jp	nz, StoreFilenamesLoop
 904  6B59              GetFileNamesEnd:
 905  6B59 C9           	ret
 906  6B5A
 907  6B5A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 908  6B5A
 909  6B5A              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 910  6B5A              ;IN: HL = file name
 911  6B5A              HandleFile:
 912  6B5A              	;Make HL point to the selected file
 913  6B5A DD 2A 72 80  	ld		ix, (SelFileCache)
 914  6B5E DD E5        	push	ix
 915  6B60 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 916  6B63 B7           		or		a
 917  6B64 CC 9A 72     		call	z, ReadFileHeader
 918  6B67
 919  6B67 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 920  6B6A FE 00        		cp		PROG_TYPE
 921  6B6C 28 56        		jr		z, HandleFileProg
 922  6B6E
 923  6B6E FE 03        		cp		BYTE_TYPE
 924  6B70 20 62        		jr		nz, HandleFileText
 925  6B72
 926  6B72 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)		;get length
 927  6B75 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 928  6B78 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 929  6B7B 19           		add		hl, de
 930  6B7C 7C           		ld		a, h
 931  6B7D B5           		or		l
 932  6B7E 28 26        		jr		z, HandleFileSCR
 933  6B80
 934  6B80
 935  6B80              HandleFileCODE:
 936  6B80 21 84 7E     		ld		hl, MsgLoadingCODE
 937  6B83 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 938  6B86 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 939  6B88 CD 1A 78     		call	PrintStrClr
 940  6B8B
 941  6B8B              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 942  6B8B 21 11 72     		ld		hl, IF1FileLoad
 943  6B8E 11 00 5B     		ld		de, PRN_BUF
 944  6B91 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 945  6B94 ED B0        		ldir
 946  6B96              		;ld		a, $C9
 947  6B96              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 948  6B96
 949  6B96 E1           	pop		hl
 950  6B97 ED 5B B8 8E  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 951  6B9B C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 952  6B9C C1           	pop		bc						;2nd, 3rd call for error handler
 953  6B9D C1           	pop		bc
 954  6B9E ED 43 3D 5C  	ld		(ERRSP), bc
 955  6BA2 D5           	push	de						;push CODE address to return to = start of CODE block
 956  6BA3 C3 00 5B     	jp		PRN_BUF
 957  6BA6
 958  6BA6
 959  6BA6
 960  6BA6
 961  6BA6              HandleFileSCR:
 962  6BA6 21 75 7E     		ld		hl, MsgLoadingSCR
 963  6BA9 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 964  6BAC 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 965  6BAE CD 1A 78     		call	PrintStrClr
 966  6BB1
 967  6BB1 E1           	pop		hl
 968  6BB2
 969  6BB2              	IFDEF _REAL_HW_
 970  6BB2              		;Load to alternate SCREEN$ memory
 971  6BB2 11 00 C0     		ld		de, HC_VID_BANK1
 972  6BB5 CD 11 72     		call	IF1FileLoad
 973  6BB8
 974  6BB8              		;Set display to alternate SCREEN$ memory
 975  6BB8 3E 08        		ld		a, HC_CFG_VID_C000
 976  6BBA D3 7E        		out 	(HC_CFG_PORT), a
 977  6BBC CD B6 77     		call	ReadChar
 978  6BBF
 979  6BBF              		;Set back to regular SCREEN$ memory
 980  6BBF 3E 00        		ld		a, HC_CFG_VID_4000
 981  6BC1 D3 7E        		out 	(HC_CFG_PORT), a
 982  6BC3              	ELSE
 983  6BC3 ~            		ld		de, HC_VID_BANK0
 984  6BC3 ~            		call	IF1FileLoad
 985  6BC3 ~            		call	ReadChar
 986  6BC3              	ENDIF
 987  6BC3
 988  6BC3 C9           	ret
 989  6BC4
 990  6BC4              HandleFileProg:
 991  6BC4 21 66 7E     		ld		hl, MsgLoadingPrg
 992  6BC7 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 993  6BCA 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 994  6BCC CD 1A 78     		call	PrintStrClr
 995  6BCF E1           	pop		hl
 996  6BD0 CD 01 73     	call	LoadProgram
 997  6BD3 C9           	ret
 998  6BD4
 999  6BD4
1000  6BD4              HandleFileText:
1001  6BD4 E1           	pop		hl
1002  6BD5
1003  6BD5              ;Use constants for loading in RAM only as much as we can in order to fit both the binary and the text representation.
1004  6BD5              ViewFileConvertRatioText	EQU	1				;Text data is 1:1, byte to byte.
1005  6BD5              ViewFileConvertRatioBASIC	EQU	3				;BASIC tokens are expanded to text as 1 byte to 3 chars on average? To test!
1006  6BD5              ViewFileConvertRatioHEX		EQU	4				;1 byte expands to 4 bytes when printed as hex.
1007  6BD5              ViewFileConvertRatioASM		EQU	3				;Disassembly is expanded as 1:3? To test!
1008  6BD5
1009  6BD5              ViewFile:
1010  6BD5 21 5A 80     	ld		hl, MsgFileLoading
1011  6BD8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
1012  6BDB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1013  6BDD CD 1A 78     	call	PrintStrClr
1014  6BE0
1015  6BE0              	;Read file header if not yet read.
1016  6BE0 DD 2A 72 80  	ld		ix, (SelFileCache)
1017  6BE4 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
1018  6BE7 B7           	or		a
1019  6BE8 CC 9A 72     	call	z, ReadFileHeader
1020  6BEB
1021  6BEB              	;Determine file type from header.
1022  6BEB DD 2A 72 80  	ld		ix, (SelFileCache)
1023  6BEF DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1024  6BF2 FE 00        	cp		PROG_TYPE
1025  6BF4 28 74        	jr		z, ViewProgramFile
1026  6BF6
1027  6BF6 FE 03        	cp		BYTE_TYPE
1028  6BF8 28 2E        	jr		z, ViewBytesFile
1029  6BFA
1030  6BFA              	;If text file, load as much as possible to RAM.
1031  6BFA 21 00 00     	ld		hl, 0
1032  6BFD 22 7A 80     	ld		(FilePosRead), hl
1033  6C00 2A 72 80     	ld		hl, (SelFileCache)
1034  6C03 3A 4C 73     	ld 		a, (RWTSDrive)
1035  6C06 3C           	inc		a
1036  6C07 06 5C        	ld		b, MAX_SECT_BUF * ViewFileConvertRatioText
1037  6C09 CD FF 76     	call	ReadFileSection					;DE = last address read
1038  6C0C
1039  6C0C DD 2A 72 80  	ld		ix, (SelFileCache)
1040  6C10 3E 03        	ld		a, BYTE_TYPE
1041  6C12 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
1042  6C15 21 BE 8E     	ld		hl, FileData+HDR_SZ
1043  6C18 30 03        	jr		nc, ViewFileWithHeader
1044  6C1A 21 B5 8E     	ld		hl, FileData
1045  6C1D
1046  6C1D              ViewFileWithHeader:
1047  6C1D              	;Calculate size of read buffer
1048  6C1D E5           	push	hl
1049  6C1E EB           		ex	de, hl
1050  6C1F B7           		or	a
1051  6C20 ED 52        		sbc	hl, de
1052  6C22 44           		ld	b, h
1053  6C23 4D           		ld	c, l
1054  6C24 E1           	pop		hl
1055  6C25 C3 A9 6C     	jp		ViewFileAsText
1056  6C28
1057  6C28              ViewBytesFile:
1058  6C28 21 00 00     	ld		hl, 0
1059  6C2B 22 7A 80     	ld		(FilePosRead), hl
1060  6C2E 2A 72 80     	ld		hl, (SelFileCache)
1061  6C31 3A 4C 73     	ld 		a, (RWTSDrive)
1062  6C34 3C           	inc		a
1063  6C35 06 17        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioHEX
1064  6C37 CD FF 76     	call	ReadFileSection					;DE = last address read
1065  6C3A 21 BE 8E     	ld		hl, FileData + HDR_SZ
1066  6C3D EB           	ex		de, hl
1067  6C3E B7           	or		a
1068  6C3F ED 52        	sbc		hl, de
1069  6C41 44           	ld		b, h
1070  6C42 4D           	ld		c, l
1071  6C43
1072  6C43              	;Determine if read buffer was bigger than logical length and set BC to logical length if so.
1073  6C43 DD 2A 72 80  	ld		ix, (SelFileCache)
1074  6C47 DD 6E 11     	ld		l, (ix + CACHE_HDR + HDR_LEN)
1075  6C4A DD 66 12     	ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1076  6C4D B7           	or		a
1077  6C4E ED 42        	sbc		hl, bc
1078  6C50 30 06        	jr		nc, LogicalLenIsBiggerThanRead
1079  6C52 DD 4E 11     	ld		c, (ix + CACHE_HDR + HDR_LEN)
1080  6C55 DD 46 12     	ld		b, (ix + CACHE_HDR + HDR_LEN + 1)
1081  6C58
1082  6C58              LogicalLenIsBiggerThanRead:
1083  6C58 EB           	ex		de, hl
1084  6C59 11 B5 A5     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioHEX
1085  6C5C D5           	push	de
1086  6C5D
1087  6C5D CD 43 6F     		call	Bin2HexStr
1088  6C60
1089  6C60              	;Get hex print len.
1090  6C60 EB           	ex		de, hl
1091  6C61 D1           	pop		de
1092  6C62 B7           	or		a
1093  6C63 ED 52        	sbc		hl, de
1094  6C65 44           	ld		b, h
1095  6C66 4D           	ld		c, l
1096  6C67 EB           	ex		de, hl
1097  6C68 18 3F        	jr		ViewFileAsText
1098  6C6A
1099  6C6A
1100  6C6A              ViewProgramFile:
1101  6C6A 21 00 00     	ld		hl, 0
1102  6C6D 22 7A 80     	ld		(FilePosRead), hl
1103  6C70 2A 72 80     	ld		hl, (SelFileCache)
1104  6C73 3A 4C 73     	ld 		a, (RWTSDrive)
1105  6C76 3C           	inc		a
1106  6C77 06 1E        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioBASIC				;Load half of available RAM with program bytecode, leave half for decoded text.
1107  6C79 CD FF 76     	call	ReadFileSection					;DE = last address read
1108  6C7C 21 B5 8E     	ld		hl, FileData
1109  6C7F 3E 0D        	ld		a, CHAR_CR
1110  6C81 13           	inc		de
1111  6C82 12           	ld		(de), a
1112  6C83
1113  6C83 DD 2A 72 80  	ld		ix, (SelFileCache)
1114  6C87 DD 4E 15     	ld		c, (ix + CACHE_HDR + HDR_PLEN)
1115  6C8A DD 46 16     	ld		b, (ix + CACHE_HDR + HDR_PLEN + 1)
1116  6C8D 21 BE 8E     	ld		hl, FileData + HDR_SZ												;Read program bytecode after the header.
1117  6C90 11 5F AD     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioBASIC		;Store text of program after read block.
1118  6C93 D5           	push	de
1119  6C94 CD CE 7C     		call	BASIC2TXT
1120  6C97 E1           	pop		hl
1121  6C98
1122  6C98              	;Get decoded text length
1123  6C98 11 5F AD     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioBASIC
1124  6C9B 2A 96 7D     	ld		hl, (DestinationAddr)
1125  6C9E 3E 1A        	ld		a, CHAR_EOF
1126  6CA0 77           	ld		(hl), a								;Force EOF char at end of decoded basic program.
1127  6CA1 23           	inc		hl
1128  6CA2 D5           	push	de
1129  6CA3 B7           		or	a
1130  6CA4 ED 52        		sbc	hl, de
1131  6CA6 44           		ld	b, h
1132  6CA7 4D           		ld	c, l
1133  6CA8 E1           	pop		hl
1134  6CA9
1135  6CA9              ViewFileAsText:
1136  6CA9 E5           	push	hl
1137  6CAA C5           	push	bc
1138  6CAB CD D2 77     		call	ClrScr
1139  6CAE C1           	pop		bc
1140  6CAF E1           	pop		hl
1141  6CB0 CD 39 7A     	call	TextViewer
1142  6CB3 C9           	ret
1143  6CB4
1144  6CB4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1145  6CB4
1146  6CB4
1147  6CB4              DisplayFileInfo:
1148  6CB4 2A 72 80     	ld		hl, (SelFileCache)
1149  6CB7 E5           	push	hl
1150  6CB8              		;disk size - at least 2KB ==1  AU
1151  6CB8 01 0D 00     		ld		bc, CACHE_AU_CNT
1152  6CBB 09           		add		hl, bc
hccmd.asm(1153): warning: Fake instruction: ld		de, (hl)
1153  6CBC 5E 23 56 2B  		ld		de, (hl)
1154  6CC0 EB           		ex		de, hl
1155  6CC1              		;*2, since one block (AU) is 2KB.
1156  6CC1 CB 15        		rl	l
1157  6CC3 CB 14        		rl	h
1158  6CC5
1159  6CC5 11 9D 7E     		ld		de, MsgFileSzDskN
1160  6CC8 CD 7C 6E     		call	Word2Txt
1161  6CCB 21 94 7E     		ld		hl, MsgFileSzDsk
1162  6CCE 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1163  6CD1 CD F2 77     		call	PrintStr
1164  6CD4 E1           	pop		hl
1165  6CD5 E5           	push	hl
1166  6CD6              		;attributes
1167  6CD6 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1168  6CD9 09           		add		hl, bc
1169  6CDA EB           		ex		de, hl
1170  6CDB 21 AD 7E     		ld		hl, MsgFileAttrN
1171  6CDE 1A           		ld		a, (de)
1172  6CDF E6 80        		and		%10000000
1173  6CE1 28 14        		jr		z, NotRO
1174  6CE3
1175  6CE3 01 52 2F     		ld		bc, '/R'
hccmd.asm(1176): warning: Fake instruction: ld		(hl), bc
1176  6CE6 71 23 70 2B  		ld		(hl), bc
1177  6CEA 23           		inc		hl
1178  6CEB 23           		inc		hl
1179  6CEC 01 4F 2C     		ld		bc, ',O'
hccmd.asm(1180): warning: Fake instruction: ld		(hl), bc
1180  6CEF 71 23 70 2B  		ld		(hl), bc
1181  6CF3 23           		inc		hl
1182  6CF4 23           		inc		hl
1183  6CF5 18 12        		jr		CheckSys
1184  6CF7              NotRO:
1185  6CF7 01 2D 2D     		ld		bc, '--'
hccmd.asm(1186): warning: Fake instruction: ld		(hl), bc
1186  6CFA 71 23 70 2B  		ld		(hl), bc
1187  6CFE 23           		inc		hl
1188  6CFF 23           		inc		hl
1189  6D00 01 2D 2C     		ld		bc, ',-'
hccmd.asm(1190): warning: Fake instruction: ld		(hl), bc
1190  6D03 71 23 70 2B  		ld		(hl), bc
1191  6D07 23           		inc		hl
1192  6D08 23           		inc		hl
1193  6D09
1194  6D09              CheckSys:
1195  6D09 13           		inc		de
1196  6D0A 1A           		ld		a, (de)
1197  6D0B E6 80        		and		%10000000
1198  6D0D 28 0E        		jr		z, NotSYS
1199  6D0F
1200  6D0F 01 48 49     		ld		bc, 'IH'
hccmd.asm(1201): warning: Fake instruction: ld		(hl), bc
1201  6D12 71 23 70 2B  		ld		(hl), bc
1202  6D16 23           		inc		hl
1203  6D17 23           		inc		hl
1204  6D18 3E C4        		ld		a, 'D' + $80
1205  6D1A 77           		ld		(hl), a
1206  6D1B 18 0C        		jr		AttrEnd
1207  6D1D              NotSYS:
1208  6D1D 01 2D 2D     		ld		bc, '--'
hccmd.asm(1209): warning: Fake instruction: ld		(hl), bc
1209  6D20 71 23 70 2B  		ld		(hl), bc
1210  6D24 23           		inc		hl
1211  6D25 23           		inc		hl
1212  6D26 3E AD        		ld		a, '-' + $80
1213  6D28 77           		ld		(hl), a
1214  6D29              AttrEnd:
1215  6D29 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1216  6D2C 21 A4 7E     		ld		hl, MsgFileAttr
1217  6D2F CD F2 77     		call	PrintStr
1218  6D32 DD E1        	pop		ix
1219  6D34 DD E5        	push	ix
1220  6D36 DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1221  6D39 B7           		or		a
1222  6D3A CA D7 6D             jp		z, HeadNotRead
1223  6D3D
1224  6D3D DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1225  6D40 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1226  6D43 CA D7 6D             jp		z, HeadNotRead
1227  6D46
1228  6D46 DD 7E 10     		ld		a, (ix + CACHE_HDR)
1229  6D49 FE 00        		cp		PROG_TYPE
1230  6D4B 20 0B        		jr		nz, CheckNoArr
1231  6D4D
1232  6D4D 21 C7 7E     		ld		hl, MsgFileTypePrg
1233  6D50 11 BD 7E     		ld		de, MsgFileTypeN
1234  6D53 CD 20 6E     		call	MoveMsg
1235  6D56 18 4F        		jr		PrepFileLen
1236  6D58
1237  6D58              CheckNoArr:
1238  6D58 FE 01        		cp		NUMB_TYPE
1239  6D5A 20 0B        		jr		nz, CheckChrArr
1240  6D5C
1241  6D5C 21 E3 7E     		ld		hl, MsgFileTypeNoA
1242  6D5F 11 BD 7E     		ld		de, MsgFileTypeN
1243  6D62 CD 20 6E     		call	MoveMsg
1244  6D65 18 40        		jr		PrepFileLen
1245  6D67
1246  6D67              CheckChrArr:
1247  6D67 FE 02        		cp		CHAR_TYPE
1248  6D69 20 0B        		jr		nz, CheckByte
1249  6D6B
1250  6D6B 21 DC 7E     		ld		hl, MsgFileTypeChrA
1251  6D6E 11 BD 7E     		ld		de, MsgFileTypeN
1252  6D71 CD 20 6E     		call	MoveMsg
1253  6D74 18 31        		jr		PrepFileLen
1254  6D76
1255  6D76              CheckByte:
1256  6D76 FE 03        		cp		BYTE_TYPE
1257  6D78 20 24        		jr		nz, CheckText
1258  6D7A
1259  6D7A DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1260  6D7D DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1261  6D80 01 00 E5     		ld		bc, -SCR_LEN
1262  6D83 09           		add		hl, bc
1263  6D84 7C           		ld		a, h
1264  6D85 B5           		or		l
1265  6D86 20 0B        		jr		nz, NotScr
1266  6D88
1267  6D88 21 D5 7E     		ld		hl, MsgFileTypeSCR
1268  6D8B 11 BD 7E     		ld		de, MsgFileTypeN
1269  6D8E CD 20 6E     		call	MoveMsg
1270  6D91 18 14        		jr		PrepFileLen
1271  6D93              NotScr:
1272  6D93 21 CE 7E     		ld		hl, MsgFileTypeByte
1273  6D96 11 BD 7E     		ld		de, MsgFileTypeN
1274  6D99 CD 20 6E     		call	MoveMsg
1275  6D9C 18 09        		jr		PrepFileLen
1276  6D9E
1277  6D9E              CheckText:
1278  6D9E 21 EA 7E     		ld		hl, MsgFileTypeText
1279  6DA1 11 BD 7E     		ld		de, MsgFileTypeN
1280  6DA4 CD 20 6E     		call	MoveMsg
1281  6DA7
1282  6DA7              PrepFileLen:
1283  6DA7              		;File len
1284  6DA7 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1285  6DAA DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1286  6DAD              PrepFileLenText:
1287  6DAD 11 01 7F     		ld		de, MsgFileLenN
1288  6DB0 CD 7C 6E     		call	Word2Txt
1289  6DB3 26 C2        		ld		h, 'B' | $80
1290  6DB5 2E 20        		ld		l, ' '
1291  6DB7 22 06 7F     		ld		(MsgFileLenN + 5), hl
1292  6DBA
1293  6DBA DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1294  6DBD FE 00        		cp		PROG_TYPE
1295  6DBF 28 06        		jr		z, PrintProgStart
1296  6DC1
1297  6DC1 FE 03        		cp		BYTE_TYPE
1298  6DC3 28 0A        		jr		z, PrintByteStart
1299  6DC5
1300  6DC5 18 22        		jr		PrintStartNotRead
1301  6DC7
1302  6DC7              PrintProgStart:
1303  6DC7 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1304  6DCA DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1305  6DCD 18 25        		jr		PrintStart
1306  6DCF
1307  6DCF              PrintByteStart:
1308  6DCF DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1309  6DD2 DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1310  6DD5 18 1D        		jr		PrintStart
1311  6DD7
1312  6DD7              HeadNotRead:
1313  6DD7 21 F1 7E             ld        hl, MsgNA
1314  6DDA 11 BD 7E             ld        de, MsgFileTypeN
1315  6DDD CD 20 6E             call    MoveMsg
1316  6DE0
1317  6DE0 21 F1 7E     		ld		hl, MsgNA
1318  6DE3 11 01 7F     		ld		de, MsgFileLenN
1319  6DE6 CD 20 6E     		call	MoveMsg
1320  6DE9
1321  6DE9              PrintStartNotRead:
1322  6DE9 21 F1 7E     		ld		hl, MsgNA
1323  6DEC 11 11 7F     		ld		de, MsgFileStartN
1324  6DEF CD 20 6E     		call	MoveMsg
1325  6DF2 18 0E        		jr		PrintStartStr
1326  6DF4
1327  6DF4              PrintStart:
1328  6DF4 1E 20        	ld		e, ' '
1329  6DF6 16 A0        	ld		d, ' ' | $80
1330  6DF8 ED 53 16 7F  	ld		(MsgFileStartN + 5), de
1331  6DFC 11 11 7F     	ld		de, MsgFileStartN
1332  6DFF CD 7C 6E     	call	Word2Txt
1333  6E02              PrintStartStr:
1334  6E02 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1335  6E05 21 08 7F     	ld		hl, MsgFileStart
1336  6E08 CD F2 77     	call	PrintStr
1337  6E0B
1338  6E0B DD E1        	pop		ix
1339  6E0D 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1340  6E10 21 B4 7E     	ld		hl, MsgFileType
1341  6E13 CD F2 77     	call	PrintStr
1342  6E16
1343  6E16 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1344  6E19 21 F8 7E     	ld		hl, MsgFileLen
1345  6E1C CD F2 77     	call	PrintStr
1346  6E1F
1347  6E1F C9           	ret
1348  6E20
1349  6E20              MoveMsg:
1350  6E20 01 07 00     	ld		bc, 7
1351  6E23 ED B0        	ldir
1352  6E25 C9           	ret
1353  6E26
1354  6E26              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1355  6E26
1356  6E26              ReadAllHeaders:
1357  6E26 21 18 7F     	ld		hl, MsgReadingExt
1358  6E29 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1359  6E2C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1360  6E2E CD 1A 78     	call	PrintStrClr
1361  6E31
1362  6E31 CD 33 67     	call	CalcFileCache
1363  6E34
1364  6E34 3A 6B 80     	ld		a, (SelFile)
1365  6E37 47           	ld		b, a
1366  6E38 3A 69 80     	ld		a, (FileCnt)
1367  6E3B 90           	sub		b
1368  6E3C B7           	or		a
1369  6E3D C8           	ret		z
1370  6E3E
1371  6E3E 47           	ld		b, a
1372  6E3F
1373  6E3F DD 2A 72 80  	ld		ix, (SelFileCache)
1374  6E43              NextFile:
1375  6E43 C5           	push	bc
1376  6E44 CD 9A 72     		call	ReadFileHeader
1377  6E47 01 19 00     		ld		bc, CACHE_SZ
1378  6E4A DD 09        		add		ix, bc
1379  6E4C DD E5        		push	ix
1380  6E4E CD 33 67     			call	CalcFileCache
1381  6E51 CD B4 6C     			call	DisplayFileInfo
1382  6E54 DD E1        		pop		ix
1383  6E56
1384  6E56 CD B9 77     		call	KbdHit
1385  6E59 38 03        		jr		c, AKey
1386  6E5B C1           	pop		bc
1387  6E5C 18 15        	jr		ReadAllHeadersEnd
1388  6E5E
1389  6E5E              AKey:
1390  6E5E 3A 6B 80     		ld		a, (SelFile)
1391  6E61 3C           		inc		a
1392  6E62 47           		ld		b, a
1393  6E63 3A 69 80     		ld		a, (FileCnt)
1394  6E66 B8           		cp		b
1395  6E67 28 10        		jr		z, DontInc
1396  6E69 78           		ld		a, b
1397  6E6A 32 6B 80     		ld		(SelFile), a
1398  6E6D CD E6 78     		call	MoveCursor
1399  6E70 C1           	pop		bc
1400  6E71 10 D0        	djnz	NextFile
1401  6E73
1402  6E73              ReadAllHeadersEnd:
1403  6E73 06 01        	ld		b, 1
1404  6E75 CD 9E 79     	call	ClearNMsgLines
1405  6E78 C9           	ret
1406  6E79
1407  6E79              DontInc:
1408  6E79 C1           	pop		bc
1409  6E7A 18 F7        	jr		ReadAllHeadersEnd
1410  6E7C
1411  6E7C
1412  6E7C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1413  6E7C
1414  6E7C              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6E7C              	ifndef	_HCCFG_
   2+ 6E7C              	define	_HCCFG_
   3+ 6E7C
   4+ 6E7C              ;HC specific code, for configuration
   5+ 6E7C
   6+ 6E7C              HC_CFG_PORT			EQU	$7E
   7+ 6E7C              HC_FLOPPY_PORT		EQU 7
   8+ 6E7C
   9+ 6E7C              ;BASIC/CPM ROM selection
  10+ 6E7C              HC_CFG_ROM_BAS		EQU	%0
  11+ 6E7C              HC_CFG_ROM_CPM		EQU	%1
  12+ 6E7C
  13+ 6E7C              ;Address for ROM paging: 0 or $E000
  14+ 6E7C              HC_CFG_ROM_0000		EQU %00
  15+ 6E7C              HC_CFG_ROM_E000		EQU %10
  16+ 6E7C
  17+ 6E7C              ;Cfg. port Enable/Disable
  18+ 6E7C              HC_CFG_PORT_DIS		EQU %000
  19+ 6E7C              HC_CFG_PORT_EN		EQU	%100
  20+ 6E7C
  21+ 6E7C              ;Video memory bank: $4000 or $C000
  22+ 6E7C              HC_CFG_VID_4000		EQU	%0000
  23+ 6E7C              HC_CFG_VID_C000		EQU	%1000
  24+ 6E7C
  25+ 6E7C
  26+ 6E7C              ;Standar BASIC config
  27+ 6E7C              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 6E7C              ;Standar CP/M config
  29+ 6E7C              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 6E7C
  31+ 6E7C
  32+ 6E7C              HC_VID_BANK0		EQU	$4000
  33+ 6E7C              HC_VID_BANK1		EQU	$C000
  34+ 6E7C
  35+ 6E7C              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 6E7C              ;Info from Rares Atodiresei.
  37+ 6E7C              IsDrive2_80Tracks:
  38+ 6E7C              	IFUSED
  39+ 6E7C ~            	in	a, (HC_FLOPPY_PORT)
  40+ 6E7C ~            	and %10
  41+ 6E7C ~            	ret
  42+ 6E7C              	ENDIF
  43+ 6E7C
  44+ 6E7C              	endif
# file closed: hccfg.asm
1415  6E7C              	include "if1.asm"
# file opened: if1.asm
   1+ 6E7C              ;HC IF1 routines and constants
   2+ 6E7C
   3+ 6E7C              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6E7C              ;12 = Writing to a 'read' file
   5+ 6E7C              ;13 = Reading a 'write' file
   6+ 6E7C              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6E7C              ;15 = Disk full (disk or catalog full)
   8+ 6E7C              ;16 = Disk error (hardware error)
   9+ 6E7C              ;17 = File not found
  10+ 6E7C              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6E7C              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6E7C
  13+ 6E7C              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6E7C              ;00h = OK
  15+ 6E7C              ;08h = cannot format disk
  16+ 6E7C              ;10h = disk protected (read-only?)
  17+ 6E7C              ;20h = volume error
  18+ 6E7C              ;40h = drive error
  19+ 6E7C              ;80h = reading error
  20+ 6E7C              ;Codes I encountered:
  21+ 6E7C              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6E7C
  23+ 6E7C
  24+ 6E7C              	ifndef	_DISK_
  25+ 6E7C              	define	_DISK_
  26+ 6E7C
  27+ 6E7C              	include	"math.asm"
# file opened: math.asm
   1++6E7C              	ifndef	_MATH_
   2++6E7C              	define	_MATH_
   3++6E7C
   4++6E7C              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6E7C              ;http://map.tni.nl/sources/external/z80bits.html
   6++6E7C
   7++6E7C
   8++6E7C              Word2Txt:
   9++6E7C              	IFUSED
  10++6E7C D5           	push	de
  11++6E7D CD 9D 6E     		call	Word2Txt_
  12++6E80 D1           	pop		de
  13++6E81
  14++6E81 06 04        	ld		b, 4
  15++6E83 CD 92 6E     	call	StrippLeading0
  16++6E86 C9           	ret
  17++6E87
  18++6E87              Byte2Txt:
  19++6E87 D5           	push	de
  20++6E88 CD A9 6E     		call	Byte2Txt_
  21++6E8B D1           	pop		de
  22++6E8C
  23++6E8C 06 02        	ld		b, 2
  24++6E8E CD 92 6E     	call	StrippLeading0
  25++6E91 C9           	ret
  26++6E92              	ENDIF
  27++6E92
  28++6E92
  29++6E92              StrippLeading0:
  30++6E92 1A           	ld		a, (de)
  31++6E93 FE 31        	cp		'1'
  32++6E95 D0           	ret		nc
  33++6E96
  34++6E96 3E 20        	ld		a, ' '
  35++6E98 12           	ld		(de), a
  36++6E99 13           	inc		de
  37++6E9A 10 F6        	djnz	StrippLeading0
  38++6E9C C9           	ret
  39++6E9D
  40++6E9D
  41++6E9D              ;Converts the number in HL to ASCII in decimal string at DE
  42++6E9D              Word2Txt_:
  43++6E9D 01 F0 D8     	ld bc, -10000
  44++6EA0 CD B8 6E     	call DigitLoop
  45++6EA3 01 18 FC     	ld bc, -1000
  46++6EA6 CD B8 6E     	call DigitLoop
  47++6EA9              Byte2Txt_:
  48++6EA9 01 9C FF     	ld bc, -100
  49++6EAC CD B8 6E     	call DigitLoop
  50++6EAF 01 F6 FF     	ld bc, -10
  51++6EB2 CD B8 6E     	call DigitLoop
  52++6EB5 01 FF FF     	ld bc, -1
  53++6EB8
  54++6EB8              DigitLoop:
  55++6EB8 3E 2F        	ld	a, '0' - 1
  56++6EBA              DivNrLoop:
  57++6EBA 3C           	inc	a			;increase reminder
  58++6EBB 09           	add	hl, bc		;substract divizor
  59++6EBC 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6EBE ED 42        	sbc	hl, bc		;nope, restore
  61++6EC0
  62++6EC0 12           	ld (de), a
  63++6EC1 13           	inc de
  64++6EC2 C9           	ret
  65++6EC3
  66++6EC3
  67++6EC3              ;Input: HL = Dividend, C = Divisor
  68++6EC3              ;Output: HL = Quotient, A = Remainder
  69++6EC3              ;Warning: doesn't work with divisor >= $80
  70++6EC3              Div:
  71++6EC3              	IFUSED
  72++6EC3 AF           	xor a
  73++6EC4 06 10        	ld b, 16
  74++6EC6
  75++6EC6              DivLoop:
  76++6EC6 29           	add	hl,hl
  77++6EC7 17           	rla
  78++6EC8 B9           	cp	c
  79++6EC9 38 02        	jr	c, NoSub
  80++6ECB 91           	sub	c
  81++6ECC 2C           	inc	l
  82++6ECD              NoSub:
  83++6ECD 10 F7        	djnz DivLoop
  84++6ECF
  85++6ECF C9           	ret
  86++6ED0              	ENDIF
  87++6ED0
  88++6ED0              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6ED0              ;Output: A:C = Quotient, HL = Remainder
  90++6ED0              Div2:
  91++6ED0 21 00 00     	ld hl, 0
  92++6ED3 06 10        	ld b, 16
  93++6ED5              Div2Loop:
  94++6ED5 CB 31        	sll c		; unroll 16 times
  95++6ED7 17           	rla			; ...
  96++6ED8 ED 6A        	adc	hl,hl		; ...
  97++6EDA ED 52        	sbc	hl,de		; ...
  98++6EDC 30 02        	jr	nc,$+4		; ...
  99++6EDE 19           	add	hl,de		; ...
 100++6EDF 0D           	dec	c		; ...
 101++6EE0 10 F3        	djnz Div2Loop
 102++6EE2 C9           	ret
 103++6EE3
 104++6EE3
 105++6EE3              ;Input: A = Multiplier, DE = Multiplicand
 106++6EE3              ;Output: A:HL = Product
 107++6EE3              Mul:
 108++6EE3              	IFUSED
 109++6EE3 21 00 00     	ld hl, 0
 110++6EE6 01 00 07     	ld bc, $0700
 111++6EE9
 112++6EE9 87           	add	a, a		; optimised 1st iteration
 113++6EEA 30 02        	jr	nc, MulLoop
 114++6EEC 62           	ld	h, d
 115++6EED 6B           	ld	l, e
 116++6EEE
 117++6EEE              MulLoop:
 118++6EEE 29           	add	hl,hl
 119++6EEF 17           	rla
 120++6EF0 30 02        	jr	nc, NoAdd
 121++6EF2 19           	add	hl,de
 122++6EF3 89           	adc	a,c
 123++6EF4              NoAdd:
 124++6EF4 10 F8        	djnz MulLoop
 125++6EF6
 126++6EF6 C9           	ret
 127++6EF7              	ENDIF
 128++6EF7
 129++6EF7
 130++6EF7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++6EF7              ;IN: HL=address to read, DE=output address	for 2 chars
 132++6EF7              Byte2Hex:
 133++6EF7 AF           	xor	a
 134++6EF8 ED 6F        	rld
 135++6EFA CD FD 6E     	call	Byte2HexNibble
 136++6EFD
 137++6EFD              Byte2HexNibble:
 138++6EFD F5           	push	af
 139++6EFE 27           	daa
 140++6EFF C6 F0        	add		a,$F0
 141++6F01 CE 40        	adc		a,$40
 142++6F03
 143++6F03 12           	ld		(de), a
 144++6F04 13           	inc		de
 145++6F05
 146++6F05 F1           	pop		af
 147++6F06 ED 6F        	rld
 148++6F08 C9           	ret
 149++6F09
 150++6F09
 151++6F09              Byte2HexHex:
 152++6F09 CD F7 6E     	call	Byte2Hex
 153++6F0C 23           	inc		hl
 154++6F0D 3E 20        	ld		a, ' '
 155++6F0F 12           	ld		(de), a
 156++6F10 13           	inc		de
 157++6F11 C9           	ret
 158++6F12
 159++6F12              Byte2HexChar:
 160++6F12 3E 0D        	ld		a, CHAR_CR
 161++6F14 BE           	cp		(hl)
 162++6F15 28 05        	jr		z, Bin2HexLineLoopTextReplace
 163++6F17
 164++6F17 3E 1A        	ld		a, CHAR_EOF
 165++6F19 BE           	cp		(hl)
 166++6F1A 20 03        	jr		nz, Bin2HexLineLoopTextCopy
 167++6F1C
 168++6F1C              Bin2HexLineLoopTextReplace:
 169++6F1C 3E 2E        	ld		a, '.'
 170++6F1E 77           	ld		(hl), a
 171++6F1F
 172++6F1F              Bin2HexLineLoopTextCopy:
 173++6F1F ED A0        	ldi
 174++6F21 C9           	ret
 175++6F22
 176++6F22
 177++6F22              HEX_COLUMNS	EQU	16
 178++6F22
 179++6F22              Bin2HexLine:
 180++6F22              	;Hex part
 181++6F22 06 10        	ld		b, HEX_COLUMNS
 182++6F24 E5           	push	hl
 183++6F25              Bin2HexLineLoopHex:
 184++6F25 CD 09 6F     		call	Byte2HexHex
 185++6F28
 186++6F28              		;Put separator in the middle of hex line.
 187++6F28 3E 09        		ld		a, HEX_COLUMNS/2+1
 188++6F2A B8           		cp		b
 189++6F2B 20 05        		jr		nz, Bin2HexLineLoopHexNotHalf
 190++6F2D 1B           		dec		de
 191++6F2E 3E 2D        		ld		a, '-'
 192++6F30 12           		ld		(de), a
 193++6F31 13           		inc		de
 194++6F32
 195++6F32              Bin2HexLineLoopHexNotHalf:
 196++6F32 10 F1        		djnz	Bin2HexLineLoopHex
 197++6F34 E1           	pop		hl
 198++6F35
 199++6F35 1B           	dec		de
 200++6F36 3E 7C        	ld		a, '|'
 201++6F38 12           	ld		(de), a
 202++6F39 13           	inc		de
 203++6F3A
 204++6F3A              	;String part
 205++6F3A              	;Ignore CR & EOF
 206++6F3A              Bin2HexLineText:
 207++6F3A              	;just to not alter B with LDI, set C to something > 16
 208++6F3A 01 20 10     	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209++6F3D              Bin2HexLineLoopText:
 210++6F3D CD 12 6F     	call	Byte2HexChar
 211++6F40 10 FB        	djnz	Bin2HexLineLoopText
 212++6F42 C9           	ret
 213++6F43
 214++6F43
 215++6F43              ;Converts binary buffer at HL to hex string at DE
 216++6F43              Bin2HexStr:
 217++6F43              	;Calculate the number of full lines by dividing BC to 16.
 218++6F43 AF           	xor		a
 219++6F44
 220++6F44 CB 18        	rr		b
 221++6F46 CB 19        	rr		c
 222++6F48 1F           	rra
 223++6F49
 224++6F49 CB 18        	rr		b
 225++6F4B CB 19        	rr		c
 226++6F4D 1F           	rra
 227++6F4E
 228++6F4E CB 18        	rr		b
 229++6F50 CB 19        	rr		c
 230++6F52 1F           	rra
 231++6F53
 232++6F53 CB 18        	rr		b
 233++6F55 CB 19        	rr		c
 234++6F57 1F           	rra
 235++6F58
 236++6F58 1F           	rra
 237++6F59 1F           	rra
 238++6F5A 1F           	rra
 239++6F5B 1F           	rra
 240++6F5C
 241++6F5C 08           	ex		af, af'			;Keep reminder
 242++6F5D
 243++6F5D              Bin2HexStrLoop:
 244++6F5D C5           	push	bc
 245++6F5E CD 22 6F     		call	Bin2HexLine
 246++6F61 C1           	pop		bc
 247++6F62
 248++6F62 0B           	dec		bc
 249++6F63 78           	ld		a, b
 250++6F64 B1           	or		c
 251++6F65 20 F6        	jr		nz, Bin2HexStrLoop
 252++6F67
 253++6F67              	;Set remaining imcomplete line.
 254++6F67 D5           	push	de
 255++6F68 E5           	push	hl
 256++6F69 3E 20        		ld		a, ' '
 257++6F6B 06 40        		ld		b, COL_CNT
 258++6F6D              Bin2HexLineClear:
 259++6F6D 12           		ld		(de), a
 260++6F6E 13           		inc		de
 261++6F6F 10 FC        		djnz	Bin2HexLineClear
 262++6F71 E1           	pop		hl
 263++6F72 D1           	pop		de
 264++6F73
 265++6F73 D5           	push	de
 266++6F74 DD E1        	pop		ix
 267++6F76 01 30 00     	ld		bc, HEX_COLUMNS*3
 268++6F79 DD 09        	add		ix, bc
 269++6F7B
 270++6F7B              	;Write hex and char part
 271++6F7B 08           	ex		af, af'
 272++6F7C B7           	or		a
 273++6F7D C8           	ret		z
 274++6F7E
 275++6F7E 47           	ld		b, a
 276++6F7F 0E 20        	ld		c, HEX_COLUMNS*2
 277++6F81
 278++6F81              Bin2HexLineLoopHex2:
 279++6F81 CD 09 6F     	call	Byte2HexHex
 280++6F84 2B           	dec		hl
 281++6F85
 282++6F85 D5           	push	de
 283++6F86 DD 5D        		ld		e, ixl
 284++6F88 DD 54        		ld		d, ixh
 285++6F8A CD 12 6F     		call	Byte2HexChar
 286++6F8D D1           	pop		de
 287++6F8E DD 23        	inc		ix
 288++6F90 10 EF        	djnz	Bin2HexLineLoopHex2
 289++6F92
 290++6F92 C9           	ret
 291++6F93
 292++6F93              	endif
# file closed: math.asm
  28+ 6F93
  29+ 6F93              DRIVE_CUR_BAS	EQU 0
  30+ 6F93              DRIVE_A_BAS		EQU	1
  31+ 6F93              DRIVE_B_BAS		EQU	2
  32+ 6F93              DRIVE_A_CPM		EQU	0
  33+ 6F93              DRIVE_B_CPM		EQU	1
  34+ 6F93              ;Disk geometry stuff
  35+ 6F93              SPT				EQU	16			;sectors per track
  36+ 6F93              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6F93              TRACK_CNT		EQU	80			;track count
  38+ 6F93              HEAD_CNT		EQU	2			;disk face count
  39+ 6F93              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6F93              EXT_SZ			EQU	32			;directory entry size
  41+ 6F93              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6F93              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6F93              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6F93              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6F93              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6F93              REC_SZ			EQU 128			;cp/m record size
  47+ 6F93              DEL_MARKER		EQU	$E5
  48+ 6F93
  49+ 6F93
  50+ 6F93              ;Extension structure (directory entry)
  51+ 6F93              EXT_DEL_FLAG	EQU	0
  52+ 6F93              EXT_NAME		EQU 1
  53+ 6F93              EXT_IDX			EQU 12
  54+ 6F93              EXT_S1			EQU 13
  55+ 6F93              EXT_S2			EQU 14
  56+ 6F93              EXT_RC			EQU	15
  57+ 6F93              EXT_AU0			EQU	16
  58+ 6F93              EXT_AU1			EQU	18
  59+ 6F93              EXT_AU2			EQU	20
  60+ 6F93              EXT_AU3			EQU	22
  61+ 6F93              EXT_AU4			EQU	24
  62+ 6F93              EXT_AU5			EQU	26
  63+ 6F93              EXT_AU6			EQU	28
  64+ 6F93              EXT_AU7			EQU	30
  65+ 6F93              EXT_SIZE		EQU 32
  66+ 6F93
  67+ 6F93              ;FCB structure
  68+ 6F93              FCB_DRIVE		EQU 0
  69+ 6F93              FCB_NAME		EQU EXT_NAME
  70+ 6F93              FCB_EX_IDX		EQU EXT_IDX
  71+ 6F93              FCB_S1			EQU EXT_S1
  72+ 6F93              FCB_S2			EQU EXT_S2
  73+ 6F93              FCB_RC			EQU	EXT_RC
  74+ 6F93              FCB_AU			EQU	EXT_AU0
  75+ 6F93              FCB_CR			EQU	32
  76+ 6F93              FCB_R0			EQU 33
  77+ 6F93              FCB_R1			EQU 34
  78+ 6F93              FCB_R2			EQU 35
  79+ 6F93              FCB_SIZE		EQU 36
  80+ 6F93
  81+ 6F93
  82+ 6F93
  83+ 6F93              ;System variables for disk
  84+ 6F93              DSTR1			EQU	$5CD6		;drive
  85+ 6F93              FSTR1			EQU	$5CDC		;file name
  86+ 6F93              NSTR1			EQU	$5CDA		;name length
  87+ 6F93              HD11			EQU	$5CED		;BDOS argument
  88+ 6F93              COPIES			EQU	$5CEF		;BDOS function
  89+ 6F93
  90+ 6F93              ERRSP			EQU $5C3D
  91+ 6F93              ERRNR			EQU $5C3A
  92+ 6F93              ERRMSG			EQU	$0260
  93+ 6F93
  94+ 6F93              PROG			EQU $5C53
  95+ 6F93              VARS			EQU	$5C4B
  96+ 6F93              STKEND			EQU	$5C65
  97+ 6F93
  98+ 6F93              PRN_BUF			EQU	23296
  99+ 6F93
 100+ 6F93              REPDEL			EQU	23561
 101+ 6F93              REPPER			EQU	23562
 102+ 6F93              PIP				EQU	23609
 103+ 6F93
 104+ 6F93
 105+ 6F93              ;RWTS routine commands
 106+ 6F93              RWTS_CMD_SEEK	EQU	0			;position head
 107+ 6F93              RWTS_CMD_READ	EQU	1			;read sector
 108+ 6F93              RWTS_CMD_WRITE	EQU	2			;write sector
 109+ 6F93              RWTS_CMD_FMT	EQU	4			;format all tracks
 110+ 6F93
 111+ 6F93
 112+ 6F93              ;File name stuff
 113+ 6F93              NAMELEN			EQU	11			;name length
 114+ 6F93              RO_POS			EQU	8			;read-only attribute position in name
 115+ 6F93              SYS_POS			EQU	9			;system attribute position in name
 116+ 6F93
 117+ 6F93              ;File types (first byte in header)
 118+ 6F93              PROG_TYPE		EQU	0			;program
 119+ 6F93              NUMB_TYPE		EQU	1			;number array
 120+ 6F93              CHAR_TYPE		EQU	2			;char array
 121+ 6F93              BYTE_TYPE		EQU	3			;bytes
 122+ 6F93              TEXT_TYPE		EQU	4			;text, >= 4
 123+ 6F93
 124+ 6F93              ;File header offsets
 125+ 6F93              HDR_TYPE		EQU	0
 126+ 6F93              HDR_LEN			EQU 1
 127+ 6F93              HDR_ADDR		EQU 3
 128+ 6F93              HDR_PLEN		EQU	5
 129+ 6F93              HDR_LINE		EQU 7
 130+ 6F93              HDR_SZ			EQU	9
 131+ 6F93
 132+ 6F93              ;BASIC disk channel structure
 133+ 6F93              CH_RW_FLAG		EQU 11
 134+ 6F93              CH_FCB			EQU	12
 135+ 6F93              CH_DATA			EQU	50
 136+ 6F93              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137+ 6F93
 138+ 6F93              CACHE_NAME		EQU	0					;11B
 139+ 6F93              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140+ 6F93              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141+ 6F93              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142+ 6F93              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143+ 6F93              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144+ 6F93
 145+ 6F93              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146+ 6F93
 147+ 6F93              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148+ 6F93              IF1Init:
 149+ 6F93 CF           	rst		08
 150+ 6F94 31           	defb	49		;create system variables
 151+ 6F95 C9           	ret
 152+ 6F96
 153+ 6F96              ;ReadWriteTrackSector
 154+ 6F96              ;A=command: 0, 1, 2, 4
 155+ 6F96              RWTS:
 156+ 6F96 32 56 73     	ld (RWTSCmd), a
 157+ 6F99 21 4B 73     	ld hl, RWTSParams
 158+ 6F9C 22 ED 5C     	ld (HD11), hl
 159+ 6F9F CF           	rst 08
 160+ 6FA0 3A           	DEFB 58
 161+ 6FA1 C9           	ret
 162+ 6FA2
 163+ 6FA2
 164+ 6FA2              ;D = sector, E = track
 165+ 6FA2              ;HL = dma
 166+ 6FA2              ReadOneDiskSector:
 167+ 6FA2 22 50 73     	ld (RWTSDMA), hl
 168+ 6FA5 ED 53 4E 73  	ld (RWTSTrack), de
 169+ 6FA9              	;ld (RWTSDrive), a
 170+ 6FA9 3E 01        	ld a, RWTS_CMD_READ
 171+ 6FAB 18 E9        	jr	RWTS
 172+ 6FAD
 173+ 6FAD              ;D = sector, E = track
 174+ 6FAD              ;HL = dma
 175+ 6FAD              WriteOneDiskSector:
 176+ 6FAD 22 50 73     	ld (RWTSDMA), hl
 177+ 6FB0 ED 53 4E 73  	ld (RWTSTrack), de
 178+ 6FB4              	;ld (RWTSDrive), a
 179+ 6FB4 3E 02        	ld a, RWTS_CMD_WRITE
 180+ 6FB6 18 DE        	jr	RWTS
 181+ 6FB8
 182+ 6FB8              FormatDisk:
 183+ 6FB8 21 B5 8E     	ld		hl, DataBuf
 184+ 6FBB 36 E5        	ld		(hl), DEL_MARKER
 185+ 6FBD 22 50 73     	ld 		(RWTSDMA), hl
 186+ 6FC0 3E 04        	ld 		a, RWTS_CMD_FMT
 187+ 6FC2 CD 96 6F     	call	RWTS
 188+ 6FC5 3A 57 73     	ld		a, (RWTSRes)
 189+ 6FC8 C9           	ret
 190+ 6FC9
 191+ 6FC9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192+ 6FC9
 193+ 6FC9              ;Allocation unit no. to track/sector
 194+ 6FC9              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195+ 6FC9              ;IN:  HL=alloc. unit no.
 196+ 6FC9              ;OUT: B=sector; C=track (head is determined by the sector number)
 197+ 6FC9              AU2TS:
 198+ 6FC9 0E 02        	ld c, SPT/SPAL
 199+ 6FCB CD C3 6E     	call Div					;A = sector
 200+ 6FCE F5           	push af
 201+ 6FCF ~            		/*
 202+ 6FCF ~            		ld c, HEAD_CNT
 203+ 6FCF ~            		call Div				;L = track, A = head (0 or 1)
 204+ 6FCF ~            		*/
 205+ 6FCF AF           		xor a
 206+ 6FD0 CB 1C        		rr h
 207+ 6FD2 CB 1D        		rr l
 208+ 6FD4 CB 1F        		rr a
 209+ 6FD6
 210+ 6FD6 4D           		ld c, l
 211+ 6FD7 06 00        		ld b, 0
 212+ 6FD9 B7           		or a
 213+ 6FDA 28 02        		jr z, Track0
 214+ 6FDC 06 10        		ld b, SPT
 215+ 6FDE              Track0:
 216+ 6FDE F1           	pop af
 217+ 6FDF B7           	or a
 218+ 6FE0 28 02        	jr z, FirstAU
 219+ 6FE2 3E 08        	ld a, SPAL
 220+ 6FE4              FirstAU:
 221+ 6FE4 80           	add a, b
 222+ 6FE5 47           	ld  b, a
 223+ 6FE6 C9           	ret
 224+ 6FE7
 225+ 6FE7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226+ 6FE7
 227+ 6FE7              ;Checks the allocation units number used in extension
 228+ 6FE7              ;IN:	IX = extension addr
 229+ 6FE7              ;OUT:	B = no. of allocation units used
 230+ 6FE7              ;		C = no. of records used in ext.
 231+ 6FE7              ;		HL = first alloc. unit no.
 232+ 6FE7              ;		DE = last alloc. unit no.
 233+ 6FE7              CheckExtAlloc:
 234+ 6FE7 DD E5        	push ix
 235+ 6FE9 01 0F 00     		ld bc, EXT_RC
 236+ 6FEC DD 09        		add ix, bc
 237+ 6FEE DD 4E 00     		ld c, (ix)			;save rec. no.
 238+ 6FF1 DD 23        		inc ix
 239+ 6FF3 DD 6E 00     		ld l, (ix)
 240+ 6FF6 DD 66 01     		ld h, (ix + 1)
 241+ 6FF9 06 08        		ld b, EXT_AU_CNT
 242+ 6FFB              CheckAU:
 243+ 6FFB DD 7E 00     		ld a, (ix)
 244+ 6FFE DD B6 01     		or (ix + 1)
 245+ 7001 28 0C        		jr z, CheckAUEnd
 246+ 7003 DD 5E 00     		ld e, (ix)
 247+ 7006 DD 56 01     		ld d, (ix + 1)
 248+ 7009 DD 23        		inc ix
 249+ 700B DD 23        		inc ix
 250+ 700D 10 EC        		djnz CheckAU
 251+ 700F              CheckAUEnd:
 252+ 700F 3E 08        		ld a, EXT_AU_CNT
 253+ 7011 90           		sub b
 254+ 7012 47           		ld b, a
 255+ 7013 DD E1        	pop ix
 256+ 7015 C9           	ret
 257+ 7016
 258+ 7016              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259+ 7016
 260+ 7016              ;Input: TrackBuffer
 261+ 7016              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262+ 7016              ReadUsedBlocksList:
 263+ 7016 DD 21 B5 8E  	ld		ix, TrackBuf			;source buffer
 264+ 701A 21 CB 88     	ld		hl, UsedBlockListCnt 	;destination buffer
 265+ 701D ED 4B 70 80  	ld		bc, (AUCntMaxFree)		;loop counter
 266+ 7021 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 267+ 7024 73           	ld		(hl), e
 268+ 7025 23           	inc		hl
 269+ 7026 72           	ld		(hl), d
 270+ 7027 23           	inc		hl
 271+ 7028
 272+ 7028              	;Add blocks 0 and 1 for directory
 273+ 7028 11 00 00     	ld		de, 0
 274+ 702B 73           	ld		(hl), e
 275+ 702C 23           	inc		hl
 276+ 702D 72           	ld		(hl), d
 277+ 702E 23           	inc		hl
 278+ 702F
 279+ 702F 13           	inc		de
 280+ 7030 73           	ld		(hl), e
 281+ 7031 23           	inc		hl
 282+ 7032 72           	ld		(hl), d
 283+ 7033 23           	inc		hl
 284+ 7034
 285+ 7034              ReadUsedBlocksLoop:
 286+ 7034 AF           	xor		a
 287+ 7035 DD BE 00     	cp		(ix)
 288+ 7038 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289+ 703A
 290+ 703A DD E5        	push	ix
 291+ 703C C5           	push	bc
 292+ 703D 06 08        		ld		b, EXT_AU_CNT
 293+ 703F 11 10 00     		ld		de, EXT_AU0
 294+ 7042 DD 19        		add		ix, de
 295+ 7044
 296+ 7044              ReadUsedBlocksLoop2:
 297+ 7044 DD 5E 00     		ld		e, (ix)
 298+ 7047 DD 56 01     		ld		d, (ix+1)
 299+ 704A 7B           		ld		a, e
 300+ 704B B2           		or		d
 301+ 704C 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302+ 704E
 303+ 704E 73           		ld		(hl), e
 304+ 704F 23           		inc		hl
 305+ 7050 72           		ld		(hl), d
 306+ 7051 23           		inc		hl
 307+ 7052
 308+ 7052 DD 23        		inc		ix
 309+ 7054 DD 23        		inc		ix
 310+ 7056
 311+ 7056 ED 5B CB 88  		ld		de, (UsedBlockListCnt)
 312+ 705A 13           		inc		de
 313+ 705B ED 53 CB 88  		ld		(UsedBlockListCnt), de
 314+ 705F
 315+ 705F 10 E3        		djnz	ReadUsedBlocksLoop2
 316+ 7061
 317+ 7061
 318+ 7061              ReadUsedBlocksSkip:
 319+ 7061 C1           	pop		bc
 320+ 7062 DD E1        	pop		ix
 321+ 7064              ReadUsedBlocksSkip2:
 322+ 7064 11 20 00     	ld		de, EXT_SZ
 323+ 7067 DD 19        	add		ix, de
 324+ 7069
 325+ 7069 0B           	dec		bc
 326+ 706A 78           	ld		a, b
 327+ 706B B1           	or		c
 328+ 706C 20 C6        	jr		nz, ReadUsedBlocksLoop
 329+ 706E
 330+ 706E C9           	ret
 331+ 706F
 332+ 706F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 706F              ;Reads 8 sectors for an AU
 334+ 706F              ;HL = block number, DE = destination buffer
 335+ 706F              ReadFSBlock:
 336+ 706F D5           	push	de
 337+ 7070 CD C9 6F     		call	AU2TS		;B=sector, C=track
 338+ 7073 E1           	pop		hl				;HL=dest
 339+ 7074
 340+ 7074 50           	ld		d, b
 341+ 7075 59           	ld		e, c
 342+ 7076 06 08        	ld		b, SPAL
 343+ 7078
 344+ 7078 CD 57 72     	call	ReadDiskSectors
 345+ 707B C9           	ret
 346+ 707C
 347+ 707C
 348+ 707C              ;Write 8 sectors for an AU
 349+ 707C              ;HL = block number, DE = source buffer
 350+ 707C              WriteFSBlock:
 351+ 707C D5           	push	de
 352+ 707D CD C9 6F     		call	AU2TS		;B=sector, C=track
 353+ 7080 E1           	pop		hl				;HL=dest
 354+ 7081
 355+ 7081 50           	ld		d, b
 356+ 7082 59           	ld		e, c
 357+ 7083 06 08        	ld		b, SPAL
 358+ 7085
 359+ 7085 CD 6A 72     	call	WriteDiskSectors
 360+ 7088 C9           	ret
 361+ 7089
 362+ 7089              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363+ 7089              ;Copies the allocated blocks from one disk to another, dual drive.
 364+ 7089              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365+ 7089              CopyDisk:
 366+ 7089              	;Get list of used blocks in current disk, max 632 bytes
 367+ 7089 CD 16 70     	call	ReadUsedBlocksList
 368+ 708C DD 21 CD 88  	ld		ix, UsedBlockListBlk
 369+ 7090
 370+ 7090              CopyDiskLoop:
 371+ 7090 2A CB 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372+ 7093 11 E2 7F     	ld		de, MsgBlocksLeft
 373+ 7096 CD 87 6E     	call	Byte2Txt
 374+ 7099 21 E2 7F     	ld		hl, MsgBlocksLeft
 375+ 709C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 376+ 709F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 377+ 70A1 CD 1A 78     	call	PrintStrClr
 378+ 70A4
 379+ 70A4              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380+ 70A4 21 0E 00     	ld		hl, MAX_AU_RAM
 381+ 70A7 ED 4B CB 88  	ld		bc, (UsedBlockListCnt)
 382+ 70AB B7           	or		a
 383+ 70AC ED 42        	sbc		hl, bc
 384+ 70AE 30 03        	jr		nc, CopyDiskLoopRead
 385+ 70B0 01 0E 00     	ld		bc, MAX_AU_RAM
 386+ 70B3
 387+ 70B3              CopyDiskLoopRead:
 388+ 70B3 41           	ld		b, c
 389+ 70B4 11 B5 8E     	ld		de, CopyDiskBuf
 390+ 70B7              	;save initial counter and initial block number array position
 391+ 70B7 C5           	push	bc
 392+ 70B8 DD E5        	push	ix
 393+ 70BA
 394+ 70BA              CopyDiskLoopReadLoop:
 395+ 70BA DD 6E 00     		ld		l, (ix)
 396+ 70BD DD 66 01     		ld		h, (ix+1)
 397+ 70C0 DD 23        		inc		ix
 398+ 70C2 DD 23        		inc		ix
 399+ 70C4
 400+ 70C4 D5           		push	de
 401+ 70C5 C5           		push	bc
 402+ 70C6 CD 6F 70     			call	ReadFSBlock			;Stop on error or continue?
 403+ 70C9 C1           		pop		bc
 404+ 70CA D1           		pop		de
 405+ 70CB
 406+ 70CB              		;+2048
 407+ 70CB 7A           		ld		a, d
 408+ 70CC C6 08        		add		8
 409+ 70CE 57           		ld		d, a
 410+ 70CF
 411+ 70CF 10 E9        		djnz	CopyDiskLoopReadLoop
 412+ 70D1
 413+ 70D1              		;Check if selection is 1=single drive or 2=dual drive
 414+ 70D1 3A 74 80     		ld		a, (CopySelOption)
 415+ 70D4 FE 31        		cp		'1'
 416+ 70D6 20 0B        		jr		nz, CopyDiskDualDrive1
 417+ 70D8
 418+ 70D8              		;Prompt for disk change
 419+ 70D8 CD 5E 74     		call	PromptDiskChangeDst
 420+ 70DB 3A 4C 73     		ld		a, (RWTSDrive)
 421+ 70DE CD 64 73     		call	BDOSInit
 422+ 70E1 18 0A        		jr		CopyDiskReadEnd
 423+ 70E3
 424+ 70E3              CopyDiskDualDrive1:
 425+ 70E3              		;alternate drive
 426+ 70E3 3A 4C 73     		ld		a, (RWTSDrive)
 427+ 70E6 3C           		inc 	a
 428+ 70E7 EE 03        		xor		%11
 429+ 70E9 3D           		dec		a
 430+ 70EA 32 4C 73     		ld		(RWTSDrive), a
 431+ 70ED
 432+ 70ED              CopyDiskReadEnd:
 433+ 70ED              	;restore initial counter and initial block number array position
 434+ 70ED DD E1        	pop		ix
 435+ 70EF C1           	pop		bc
 436+ 70F0 11 B5 8E     	ld		de, CopyDiskBuf
 437+ 70F3 C5           	push	bc
 438+ 70F4
 439+ 70F4              CopyDiskLoopWriteLoop:
 440+ 70F4 DD 6E 00     		ld		l, (ix)
 441+ 70F7 DD 66 01     		ld		h, (ix+1)
 442+ 70FA DD 23        		inc		ix
 443+ 70FC DD 23        		inc		ix
 444+ 70FE
 445+ 70FE D5           		push	de
 446+ 70FF C5           		push	bc
 447+ 7100 CD 7C 70     			call	WriteFSBlock		;Stop on error or continue?
 448+ 7103 C1           		pop		bc
 449+ 7104 D1           		pop		de
 450+ 7105
 451+ 7105              		;+2048
 452+ 7105 7A           		ld		a, d
 453+ 7106 C6 08        		add		8
 454+ 7108 57           		ld		d, a
 455+ 7109
 456+ 7109 10 E9        		djnz	CopyDiskLoopWriteLoop
 457+ 710B
 458+ 710B              CopyDiskWriteEnd:
 459+ 710B C1           	pop		bc
 460+ 710C 48           	ld		c, b
 461+ 710D 06 00        	ld		b, 0
 462+ 710F
 463+ 710F              	;Decrease number of blocks read by now.
 464+ 710F 2A CB 88     	ld		hl, (UsedBlockListCnt)
 465+ 7112 B7           	or		a
 466+ 7113 ED 42        	sbc		hl, bc
 467+ 7115 22 CB 88     	ld		(UsedBlockListCnt), hl
 468+ 7118
 469+ 7118 7D           	ld		a, l
 470+ 7119 B4           	or		h
 471+ 711A 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472+ 711C
 473+ 711C              	;Check if selection is 1=single drive or 2=dual drive
 474+ 711C 3A 74 80     	ld		a, (CopySelOption)
 475+ 711F FE 31        	cp		'1'
 476+ 7121 20 0C        	jr		nz, CopyDiskDualDrive2
 477+ 7123
 478+ 7123              	;Prompt for disk change
 479+ 7123 CD 78 74     	call	PromptDiskChangeSrc
 480+ 7126 3A 4C 73     	ld		a, (RWTSDrive)
 481+ 7129 CD 64 73     	call	BDOSInit
 482+ 712C C3 90 70     	jp		CopyDiskLoop
 483+ 712F
 484+ 712F              CopyDiskDualDrive2:
 485+ 712F              	;alternate drive again
 486+ 712F 3A 4C 73     	ld		a, (RWTSDrive)
 487+ 7132 3C           	inc		a
 488+ 7133 EE 03        	xor		%11
 489+ 7135 3D           	dec		a
 490+ 7136 32 4C 73     	ld		(RWTSDrive), a
 491+ 7139 C3 90 70     	jp		CopyDiskLoop
 492+ 713C
 493+ 713C              CopyDiskEnd:
 494+ 713C 06 01        	ld		b, 1
 495+ 713E CD 9E 79     	call	ClearNMsgLines
 496+ 7141 C9           	ret
 497+ 7142
 498+ 7142              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499+ 7142              ;Copies the current disk blocks to COM port.
 500+ 7142              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501+ 7142              CopyDiskToCOM:
 502+ 7142              	;Get list of used blocks in current disk, max 632 bytes
 503+ 7142 CD 16 70     	call	ReadUsedBlocksList
 504+ 7145
 505+ 7145              	;Send block count and block indexes
 506+ 7145 2A CB 88     	ld		hl, (UsedBlockListCnt)
 507+ 7148 29           	add		hl, hl
 508+ 7149 23           	inc		hl
 509+ 714A 23           	inc		hl
 510+ 714B 44           	ld		b, h
 511+ 714C 4D           	ld		c, l
 512+ 714D 21 CB 88     	ld		hl, UsedBlockListCnt
 513+ 7150 CD 98 7C     	call	SERTB
 514+ 7153
 515+ 7153 DD 21 CD 88  	ld		ix, UsedBlockListBlk
 516+ 7157
 517+ 7157              CopyDiskToCOMLoop:
 518+ 7157              	;Print block count left
 519+ 7157 2A CB 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520+ 715A 11 E2 7F     	ld		de, MsgBlocksLeft
 521+ 715D CD 87 6E     	call	Byte2Txt
 522+ 7160 21 E2 7F     	ld		hl, MsgBlocksLeft
 523+ 7163 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 524+ 7166 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 525+ 7168 CD 1A 78     	call	PrintStrClr
 526+ 716B
 527+ 716B              	;Read block into buffer
 528+ 716B DD 6E 00     	ld		l, (ix)
 529+ 716E DD 66 01     	ld		h, (ix+1)
 530+ 7171 11 B5 8E     	ld		de, CopyDiskBuf
 531+ 7174 DD E5        	push	ix
 532+ 7176 CD 6F 70     		call	ReadFSBlock
 533+ 7179 DD E1        	pop		ix
 534+ 717B DD 23        	inc		ix
 535+ 717D DD 23        	inc		ix
 536+ 717F
 537+ 717F              	;Send block buffer
 538+ 717F 21 B5 8E     	ld		hl, CopyDiskBuf
 539+ 7182 01 00 08     	ld		bc, AU_SZ
 540+ 7185 CD 98 7C     	call	SERTB
 541+ 7188
 542+ 7188 ED 4B CB 88  	ld		bc, (UsedBlockListCnt)
 543+ 718C 0B           	dec		bc
 544+ 718D ED 43 CB 88  	ld		(UsedBlockListCnt), bc
 545+ 7191
 546+ 7191 DD E5        	push	ix
 547+ 7193 CD B9 77     		call	KbdHit
 548+ 7196 DD E1        	pop		ix
 549+ 7198 D8           	ret		c
 550+ 7199
 551+ 7199 78           	ld		a, b
 552+ 719A B1           	or		c
 553+ 719B 20 BA        	jr		nz, CopyDiskToCOMLoop
 554+ 719D
 555+ 719D C9           	ret
 556+ 719E
 557+ 719E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558+ 719E              CopyDiskFromCOM:
 559+ 719E              	;Receive block count.
 560+ 719E 21 CB 88     	ld		hl, UsedBlockListCnt
 561+ 71A1 01 02 00     	ld		bc, 2
 562+ 71A4 1E 00        	ld		e, 0
 563+ 71A6 CD 65 7C     	call	SERRB
 564+ 71A9
 565+ 71A9              	;Receive block indexes.
 566+ 71A9 2A CB 88     	ld		hl, (UsedBlockListCnt)
 567+ 71AC 29           	add		hl, hl
 568+ 71AD 44           	ld		b, h
 569+ 71AE 4D           	ld		c, l
 570+ 71AF 21 CD 88     	ld		hl, UsedBlockListBlk
 571+ 71B2 1E 00        	ld		e, 0
 572+ 71B4 CD 65 7C     	call	SERRB
 573+ 71B7
 574+ 71B7              	;Read each block by index and write to disk
 575+ 71B7 DD 21 CD 88  	ld		ix, UsedBlockListBlk
 576+ 71BB
 577+ 71BB              CopyDiskFromCOMLoop:
 578+ 71BB              	;Print block count left
 579+ 71BB 2A CB 88     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580+ 71BE 11 E2 7F     	ld		de, MsgBlocksLeft
 581+ 71C1 CD 87 6E     	call	Byte2Txt
 582+ 71C4 21 E2 7F     	ld		hl, MsgBlocksLeft
 583+ 71C7 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 584+ 71CA 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 585+ 71CC CD 1A 78     	call	PrintStrClr
 586+ 71CF
 587+ 71CF              	;Read block buffer
 588+ 71CF 21 B5 8E     	ld		hl, CopyDiskBuf
 589+ 71D2 01 00 08     	ld		bc, AU_SZ
 590+ 71D5 1E 00        	ld		e, 0
 591+ 71D7 CD 65 7C     	call	SERRB
 592+ 71DA
 593+ 71DA              	;Write block to disk
 594+ 71DA DD 6E 00     	ld		l, (ix)
 595+ 71DD DD 66 01     	ld		h, (ix+1)
 596+ 71E0 11 B5 8E     	ld		de, CopyDiskBuf
 597+ 71E3 DD E5        	push	ix
 598+ 71E5 CD 7C 70     		call	WriteFSBlock			;Stop on error or continue?
 599+ 71E8 DD E1        	pop		ix
 600+ 71EA DD 23        	inc		ix
 601+ 71EC DD 23        	inc		ix
 602+ 71EE
 603+ 71EE ED 4B CB 88  	ld		bc, (UsedBlockListCnt)
 604+ 71F2 0B           	dec		bc
 605+ 71F3 ED 43 CB 88  	ld		(UsedBlockListCnt), bc
 606+ 71F7
 607+ 71F7 DD E5        	push	ix
 608+ 71F9 CD B9 77     		call	KbdHit
 609+ 71FC DD E1        	pop		ix
 610+ 71FE D8           	ret		c
 611+ 71FF
 612+ 71FF 78           	ld		a, b
 613+ 7200 B1           	or		c
 614+ 7201 20 B8        	jr		nz, CopyDiskFromCOMLoop
 615+ 7203 C9           	ret
 616+ 7204
 617+ 7204              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618+ 7204
 619+ 7204              ;Compare string at HL with the one at DE, max length B
 620+ 7204              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621+ 7204              ;OUT: z flag, set = match, reset = mismatch
 622+ 7204              StrCmp:
 623+ 7204 E5           	push hl
 624+ 7205 D5           	push de
 625+ 7206              Compare:
 626+ 7206 1A           		ld a, (de)
 627+ 7207 BE           		cp (hl)
 628+ 7208 20 04        		jr nz, MisMatch
 629+ 720A 23           		inc hl
 630+ 720B 13           		inc de
 631+ 720C 10 F8        		djnz Compare
 632+ 720E              MisMatch:
 633+ 720E D1           	pop de
 634+ 720F E1           	pop hl
 635+ 7210 C9           	ret
 636+ 7211
 637+ 7211              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638+ 7211
 639+ 7211              ;Read a file into a buffer, sector by sector.
 640+ 7211              ;It's relocatable, to moved and be used when loading a CODE block.
 641+ 7211              ;It's not using BDOS, but using similar calls provided by IF1.
 642+ 7211              ;In: HL = Name address, DE = buffer
 643+ 7211              IF1FileLoad:
 644+ 7211 D5           	push	de
 645+ 7212 22 DC 5C     		ld (FSTR1), hl
 646+ 7215 26 00        		ld h, 0
 647+ 7217 3A 4C 73     		ld a, (RWTSDrive)
 648+ 721A 3C           		inc  a			;CP/M drive number to BASIC drive number
 649+ 721B 6F           		ld	l, a
 650+ 721C 22 D6 5C     		ld (DSTR1), hl
 651+ 721F 2E 0B        		ld l,NAMELEN
 652+ 7221 22 DA 5C     		ld (NSTR1), hl
 653+ 7224 CF           		rst 08
 654+ 7225 33           		DEFB 51			;open disk channel
 655+ 7226
 656+ 7226 CF           		rst		8
 657+ 7227 35           		defb	53		;read sector
 658+ 7228 D1           	pop		de
 659+ 7229 30 27        	jr		nc, FileFree
 660+ 722B
 661+ 722B DD 7E 32     	ld		a, (ix + CH_DATA)
 662+ 722E FE 04        	cp		TEXT_TYPE
 663+ 7230 30 12        	jr		nc, FileLoadNoHeader
 664+ 7232
 665+ 7232              FileLoadHeader:
 666+ 7232 DD E5        	push	ix
 667+ 7234 E1           	pop		hl
 668+ 7235 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 669+ 7238 09           	add		hl, bc
 670+ 7239 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 671+ 723C ED B0        	ldir
 672+ 723E
 673+ 723E              FileReadLoop:
 674+ 723E D5           	push	de
 675+ 723F CF           		rst		8
 676+ 7240 35           		defb	53		;read sector
 677+ 7241 D1           	pop		de
 678+ 7242 30 0E        	jr		nc, FileFree
 679+ 7244
 680+ 7244              FileLoadNoHeader:
 681+ 7244 DD E5        	push	ix
 682+ 7246 E1           	pop		hl
 683+ 7247 01 32 00     	ld		bc, CH_DATA
 684+ 724A 09           	add		hl, bc
 685+ 724B 01 00 01     	ld		bc, SECT_SZ
 686+ 724E ED B0        	ldir
 687+ 7250 18 EC        	jr		FileReadLoop
 688+ 7252
 689+ 7252              FileFree:
 690+ 7252 D5           	push	de
 691+ 7253 CF           	rst		8
 692+ 7254 38           	defb	56			;close channel (52) or detroy channel (56)
 693+ 7255 D1           	pop		de
 694+ 7256 C9           	ret
 695+ 7257              IF1FileLoadEnd:
 696+ 7257
 697+ 7257              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698+ 7257              ;HL = destination buffer, B = count of sectors, DE = track/sector
 699+ 7257              ;Out: A = error code, 0=OK
 700+ 7257              ReadDiskSectors:
 701+ 7257 C5           	push bc
 702+ 7258 E5           		push hl
 703+ 7259 D5           			push de
 704+ 725A CD A2 6F     				call ReadOneDiskSector
 705+ 725D D1           			pop de
 706+ 725E E1           		pop hl
 707+ 725F
 708+ 725F 14           		inc d
 709+ 7260 24           		inc h
 710+ 7261 C1           	pop bc
 711+ 7262
 712+ 7262 3A 57 73     	ld	a, (RWTSRes)
 713+ 7265 B7           	or	a
 714+ 7266 C0           	ret nz
 715+ 7267
 716+ 7267 10 EE        	djnz ReadDiskSectors
 717+ 7269 C9           	ret
 718+ 726A
 719+ 726A              ;HL = source buffer, B = count of sectors, DE = track/sector
 720+ 726A              ;Out: A = error code, 0=OK
 721+ 726A              WriteDiskSectors:
 722+ 726A C5           	push bc
 723+ 726B E5           		push hl
 724+ 726C D5           			push de
 725+ 726D CD AD 6F     				call WriteOneDiskSector
 726+ 7270 D1           			pop de
 727+ 7271 E1           		pop hl
 728+ 7272
 729+ 7272 14           		inc d
 730+ 7273 24           		inc h
 731+ 7274 C1           	pop bc
 732+ 7275
 733+ 7275 3A 57 73     	ld	a, (RWTSRes)
 734+ 7278 B7           	or	a
 735+ 7279 C0           	ret nz
 736+ 727A
 737+ 727A 10 EE        	djnz WriteDiskSectors
 738+ 727C C9           	ret
 739+ 727D
 740+ 727D
 741+ 727D              ;Reads disk catalog
 742+ 727D              ReadCatalogTrack:
 743+ 727D 21 B5 8E     	ld hl, TrackBuf
 744+ 7280 11 00 00     	ld de, 0
 745+ 7283 06 10        	ld b, SPT
 746+ 7285
 747+ 7285 CD 57 72     	call ReadDiskSectors
 748+ 7288 C9           	ret
 749+ 7289
 750+ 7289              ;A = track
 751+ 7289              SeekTrack:
 752+ 7289              	IFUSED
 753+ 7289 ~            	ld	(RWTSTrack), a
 754+ 7289 ~            	ld 	a, RWTS_CMD_SEEK
 755+ 7289 ~            	jp	RWTS
 756+ 7289              	ENDIF
 757+ 7289
 758+ 7289              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759+ 7289
 760+ 7289              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761+ 7289              FindCache:
 762+ 7289 06 0B        	ld		b, NAMELEN
 763+ 728B CD 04 72     	call	StrCmp			;find the file to wich this extension belongs
 764+ 728E C8           	ret		z
 765+ 728F
 766+ 728F 0D           	dec		c
 767+ 7290 20 02        	jr		nz, CacheNotFinished
 768+ 7292 B1           	or		c
 769+ 7293 C9           	ret
 770+ 7294
 771+ 7294              CacheNotFinished:
 772+ 7294 01 19 00     	ld		bc, CACHE_SZ
 773+ 7297 09           	add		hl, bc			;to the next cache line
 774+ 7298 18 EF        	jr		FindCache
 775+ 729A
 776+ 729A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777+ 729A
 778+ 729A              	;ld		ix, (SelFileCache)
 779+ 729A              ReadFileHeader:
 780+ 729A DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 781+ 729D B7           	or		a
 782+ 729E C0           	ret		nz				;return if already read
 783+ 729F
 784+ 729F DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 785+ 72A2 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 786+ 72A5 7C           	ld		a, h
 787+ 72A6 B5           	or		l
 788+ 72A7 28 46        	jr		z, ReadHeaderEnd
 789+ 72A9
 790+ 72A9 CD C9 6F     	call	AU2TS
 791+ 72AC 50           	ld		d, b
 792+ 72AD 59           	ld		e, c
 793+ 72AE 21 B5 8E     	ld		hl, DataBuf
 794+ 72B1 DD E5        	push	ix
 795+ 72B3 DD E5        	push	ix
 796+ 72B5 CD A2 6F     		call	ReadOneDiskSector
 797+ 72B8 E1           	pop		hl
 798+ 72B9 DD E1        	pop		ix
 799+ 72BB
 800+ 72BB E5           	push	hl
 801+ 72BC 21 B5 8E     		ld		hl, DataBuf
 802+ 72BF CD F3 72     		call	IsFileHeaderValid
 803+ 72C2 E1           	pop		hl
 804+ 72C3 B7           	or		a
 805+ 72C4 28 14        	jr		z, ReadFileHeaderIsTextFile
 806+ 72C6
 807+ 72C6 01 10 00     	ld		bc, CACHE_HDR
 808+ 72C9 09           	add		hl, bc
 809+ 72CA EB           	ex		hl, de
 810+ 72CB 21 B5 8E     	ld		hl, DataBuf
 811+ 72CE 01 09 00     	ld		bc, HDR_SZ
 812+ 72D1 ED B0        	ldir
 813+ 72D3
 814+ 72D3              	;For text files, read file size as reported by BDOS, since we don't have a header.
 815+ 72D3 3E 03        	ld		a, BYTE_TYPE
 816+ 72D5 DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 817+ 72D8 30 15        	jr		nc, ReadHeaderEnd
 818+ 72DA
 819+ 72DA              ReadFileHeaderIsTextFile:
 820+ 72DA DD E5        	push	ix
 821+ 72DC DD E5        	push	ix
 822+ 72DE E1           	pop		hl
 823+ 72DF CD C2 73     		call	GetFileSize
 824+ 72E2 DD E1        	pop		ix
 825+ 72E4 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 826+ 72E7 DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827+ 72EA 3E 04        	ld		a, TEXT_TYPE
 828+ 72EC DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829+ 72EF
 830+ 72EF              ReadHeaderEnd:
 831+ 72EF DD 34 0F     	inc		(ix + CACHE_FLAG)
 832+ 72F2 C9           	ret
 833+ 72F3
 834+ 72F3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835+ 72F3              ;Checks if the file header is valid. For now it checks to not have all 0s.
 836+ 72F3              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837+ 72F3              ;In: HL = header
 838+ 72F3              ;Out: A > 0 if valid
 839+ 72F3              IsFileHeaderValid:
 840+ 72F3              	IFUSED
 841+ 72F3 AF           	xor		a
 842+ 72F4 06 09        	ld		b, HDR_SZ
 843+ 72F6              IsFileHeaderValidLoop:
 844+ 72F6 B6           	or		(hl)
 845+ 72F7 23           	inc		hl
 846+ 72F8 10 FC        	djnz	IsFileHeaderValidLoop
 847+ 72FA
 848+ 72FA C9           	ret
 849+ 72FB              	ENDIF
 850+ 72FB
 851+ 72FB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852+ 72FB
 853+ 72FB              ;IN: HL = address from IF1 to call
 854+ 72FB              IF1Call:
 855+ 72FB 22 ED 5C     	LD   (HD11), HL
 856+ 72FE CF           	RST  8
 857+ 72FF 32           	DEFB 50
 858+ 7300 C9           	RET
 859+ 7301
 860+ 7301              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861+ 7301
 862+ 7301              ;Load a program from disk
 863+ 7301              ;IN: HL = file name addr
 864+ 7301              LoadProgram:
 865+ 7301 22 DC 5C     	LD   (FSTR1), HL
 866+ 7304 26 00        	LD   H, 0
 867+ 7306 2E 0B        	LD   L, NAMELEN
 868+ 7308 22 DA 5C     	LD   (NSTR1), HL
 869+ 730B 3A 4C 73     	LD	 A, (RWTSDrive)
 870+ 730E 3C           	INC  A					;Adapt for BASIC drive number
 871+ 730F 6F           	LD   L, A
 872+ 7310 22 D6 5C     	LD   (DSTR1), HL
 873+ 7313 21 41 0A     	LD   HL, LOAD_ADDR
 874+ 7316 CD FB 72     	CALL IF1Call
 875+ 7319 C9           	RET
 876+ 731A
 877+ 731A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878+ 731A
 879+ 731A              SetFastKeys:
 880+ 731A 21 09 5C     	ld		hl, REPDEL
 881+ 731D              	;ld		de, (1 << 8) | 15
 882+ 731D 11 0A 01     	ld		de, (1 << 8) | 10
if1.asm(883): warning: Fake instruction: ld		(hl), de
 883+ 7320 73 23 72 2B  	ld		(hl), de
 884+ 7324
 885+ 7324 C9           	ret
 886+ 7325
 887+ 7325
 888+ 7325              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889+ 7325              ;Reads the error message string from IF1 ROM.
 890+ 7325              GetErrMsg:
 891+ 7325 3C           	inc		a
 892+ 7326 08           	ex		af, af'
 893+ 7327
 894+ 7327 21 2D 73     	ld		hl, IF1Paged			;page-in IF1
 895+ 732A C3 FB 72     	jp		IF1Call
 896+ 732D
 897+ 732D              IF1Paged:
 898+ 732D 21 60 02     	ld		hl, ERRMSG
 899+ 7330 08           	ex		af, af'
 900+ 7331 B7           	or		a
 901+ 7332 28 0B        	jr		z, SaveMsg
 902+ 7334
 903+ 7334 06 00        	ld		b, 0
 904+ 7336              SearchMsgEnd:
 905+ 7336 CB 7E        	bit		7, (hl)
 906+ 7338 23           	inc		hl
 907+ 7339 28 FB        	jr		z, SearchMsgEnd
 908+ 733B
 909+ 733B 04           	inc		b
 910+ 733C B8           	cp		b
 911+ 733D 20 F7        	jr		nz, SearchMsgEnd
 912+ 733F
 913+ 733F              SaveMsg:
 914+ 733F 11 B5 8E     	ld		de, DataBuf
 915+ 7342              CopyMsg:
 916+ 7342 7E           	ld		a, (hl)
 917+ 7343 CB 7F        	bit		7, a
 918+ 7345 12           	ld		(de), a
 919+ 7346 23           	inc		hl
 920+ 7347 13           	inc		de
 921+ 7348 28 F8        	jr		z, CopyMsg
 922+ 734A
 923+ 734A C9           	ret
 924+ 734B
 925+ 734B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926+ 734B
 927+ 734B              ;RWTS routine I/O block
 928+ 734B              RWTSParams:
 929+ 734B 01           RWTSBlockType	DEFB	1							;?
 930+ 734C 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931+ 734D 00           RWTSVolNo		DEFB	0							;?
 932+ 734E 00           RWTSTrack		DEFB	0
 933+ 734F 00           RWTSSector		DEFB	0
 934+ 7350 00 00        RWTSDMA			DEFW	0
 935+ 7352 32 29        RWTSExtBuf		DEFW	$2932
 936+ 7354              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937+ 7354              	IFDEF _REAL_HW_
 938+ 7354 5E 73        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939+ 7356              	ELSE
 940+ 7356 ~            RWTSPrmTbl		DEFW	$1f2a
 941+ 7356              	ENDIF
 942+ 7356 01           RWTSCmd			DEFB	RWTS_CMD_READ
 943+ 7357              ;Results
 944+ 7357 00           RWTSRes			DEFB	0
 945+ 7358 00           RWTSResVolNo	DEFB	0
 946+ 7359 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 946+ 735D 00
 947+ 735E
 948+ 735E              ;Param. table, usualy found in ROM.
 949+ 735E              	IFDEF _REAL_HW_
 950+ 735E              BasPrmTbl:
 951+ 735E
 952+ 735E              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953+ 735E              	;DEFINE _STANDARD_DRIVE_PARAM_
 954+ 735E              	IFDEF _STANDARD_DRIVE_PARAM_
 955+ 735E ~            PrmDevType		DEFB	$01
 956+ 735E ~            PrmStepRate		DEFB	$0D		;(milisec)
 957+ 735E ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958+ 735E ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959+ 735E              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960+ 735E              PrmFastFactor	EQU		4
 961+ 735E 01           PrmDevType		DEFB	$01
 962+ 735F 03           PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963+ 7360 08           PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964+ 7361 19           PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965+ 7362              	ENDIF
 966+ 7362
 967+ 7362 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968+ 7364              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969+ 7364              	ENDIF
 970+ 7364
 971+ 7364              	endif
# file closed: if1.asm
1416  7364              	include "bdos.asm"
# file opened: bdos.asm
   1+ 7364              ;BDOS functions - similar to CP/M
   2+ 7364
   3+ 7364              	IFNDEF	_BDOS_
   4+ 7364              	DEFINE	_BDOS_
   5+ 7364
   6+ 7364              	include "if1.asm"
# file opened: if1.asm
   1++7364              ;HC IF1 routines and constants
   2++7364
   3++7364              ;IF1 routines error codes, also returned by BASIC commands
   4++7364              ;12 = Writing to a 'read' file
   5++7364              ;13 = Reading a 'write' file
   6++7364              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++7364              ;15 = Disk full (disk or catalog full)
   8++7364              ;16 = Disk error (hardware error)
   9++7364              ;17 = File not found
  10++7364              ;23 = Disk R/O (disk change detected, software R/O)
  11++7364              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++7364
  13++7364              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++7364              ;00h = OK
  15++7364              ;08h = cannot format disk
  16++7364              ;10h = disk protected (read-only?)
  17++7364              ;20h = volume error
  18++7364              ;40h = drive error
  19++7364              ;80h = reading error
  20++7364              ;Codes I encountered:
  21++7364              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++7364
  23++7364
  24++7364              	ifndef	_DISK_
  25++7364 ~            	define	_DISK_
  26++7364 ~
  27++7364 ~            	include	"math.asm"
  28++7364 ~
  29++7364 ~            DRIVE_CUR_BAS	EQU 0
  30++7364 ~            DRIVE_A_BAS		EQU	1
  31++7364 ~            DRIVE_B_BAS		EQU	2
  32++7364 ~            DRIVE_A_CPM		EQU	0
  33++7364 ~            DRIVE_B_CPM		EQU	1
  34++7364 ~            ;Disk geometry stuff
  35++7364 ~            SPT				EQU	16			;sectors per track
  36++7364 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++7364 ~            TRACK_CNT		EQU	80			;track count
  38++7364 ~            HEAD_CNT		EQU	2			;disk face count
  39++7364 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++7364 ~            EXT_SZ			EQU	32			;directory entry size
  41++7364 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++7364 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++7364 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++7364 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++7364 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++7364 ~            REC_SZ			EQU 128			;cp/m record size
  47++7364 ~            DEL_MARKER		EQU	$E5
  48++7364 ~
  49++7364 ~
  50++7364 ~            ;Extension structure (directory entry)
  51++7364 ~            EXT_DEL_FLAG	EQU	0
  52++7364 ~            EXT_NAME		EQU 1
  53++7364 ~            EXT_IDX			EQU 12
  54++7364 ~            EXT_S1			EQU 13
  55++7364 ~            EXT_S2			EQU 14
  56++7364 ~            EXT_RC			EQU	15
  57++7364 ~            EXT_AU0			EQU	16
  58++7364 ~            EXT_AU1			EQU	18
  59++7364 ~            EXT_AU2			EQU	20
  60++7364 ~            EXT_AU3			EQU	22
  61++7364 ~            EXT_AU4			EQU	24
  62++7364 ~            EXT_AU5			EQU	26
  63++7364 ~            EXT_AU6			EQU	28
  64++7364 ~            EXT_AU7			EQU	30
  65++7364 ~            EXT_SIZE		EQU 32
  66++7364 ~
  67++7364 ~            ;FCB structure
  68++7364 ~            FCB_DRIVE		EQU 0
  69++7364 ~            FCB_NAME		EQU EXT_NAME
  70++7364 ~            FCB_EX_IDX		EQU EXT_IDX
  71++7364 ~            FCB_S1			EQU EXT_S1
  72++7364 ~            FCB_S2			EQU EXT_S2
  73++7364 ~            FCB_RC			EQU	EXT_RC
  74++7364 ~            FCB_AU			EQU	EXT_AU0
  75++7364 ~            FCB_CR			EQU	32
  76++7364 ~            FCB_R0			EQU 33
  77++7364 ~            FCB_R1			EQU 34
  78++7364 ~            FCB_R2			EQU 35
  79++7364 ~            FCB_SIZE		EQU 36
  80++7364 ~
  81++7364 ~
  82++7364 ~
  83++7364 ~            ;System variables for disk
  84++7364 ~            DSTR1			EQU	$5CD6		;drive
  85++7364 ~            FSTR1			EQU	$5CDC		;file name
  86++7364 ~            NSTR1			EQU	$5CDA		;name length
  87++7364 ~            HD11			EQU	$5CED		;BDOS argument
  88++7364 ~            COPIES			EQU	$5CEF		;BDOS function
  89++7364 ~
  90++7364 ~            ERRSP			EQU $5C3D
  91++7364 ~            ERRNR			EQU $5C3A
  92++7364 ~            ERRMSG			EQU	$0260
  93++7364 ~
  94++7364 ~            PROG			EQU $5C53
  95++7364 ~            VARS			EQU	$5C4B
  96++7364 ~            STKEND			EQU	$5C65
  97++7364 ~
  98++7364 ~            PRN_BUF			EQU	23296
  99++7364 ~
 100++7364 ~            REPDEL			EQU	23561
 101++7364 ~            REPPER			EQU	23562
 102++7364 ~            PIP				EQU	23609
 103++7364 ~
 104++7364 ~
 105++7364 ~            ;RWTS routine commands
 106++7364 ~            RWTS_CMD_SEEK	EQU	0			;position head
 107++7364 ~            RWTS_CMD_READ	EQU	1			;read sector
 108++7364 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 109++7364 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 110++7364 ~
 111++7364 ~
 112++7364 ~            ;File name stuff
 113++7364 ~            NAMELEN			EQU	11			;name length
 114++7364 ~            RO_POS			EQU	8			;read-only attribute position in name
 115++7364 ~            SYS_POS			EQU	9			;system attribute position in name
 116++7364 ~
 117++7364 ~            ;File types (first byte in header)
 118++7364 ~            PROG_TYPE		EQU	0			;program
 119++7364 ~            NUMB_TYPE		EQU	1			;number array
 120++7364 ~            CHAR_TYPE		EQU	2			;char array
 121++7364 ~            BYTE_TYPE		EQU	3			;bytes
 122++7364 ~            TEXT_TYPE		EQU	4			;text, >= 4
 123++7364 ~
 124++7364 ~            ;File header offsets
 125++7364 ~            HDR_TYPE		EQU	0
 126++7364 ~            HDR_LEN			EQU 1
 127++7364 ~            HDR_ADDR		EQU 3
 128++7364 ~            HDR_PLEN		EQU	5
 129++7364 ~            HDR_LINE		EQU 7
 130++7364 ~            HDR_SZ			EQU	9
 131++7364 ~
 132++7364 ~            ;BASIC disk channel structure
 133++7364 ~            CH_RW_FLAG		EQU 11
 134++7364 ~            CH_FCB			EQU	12
 135++7364 ~            CH_DATA			EQU	50
 136++7364 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 137++7364 ~
 138++7364 ~            CACHE_NAME		EQU	0					;11B
 139++7364 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 140++7364 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 141++7364 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 142++7364 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 143++7364 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 144++7364 ~
 145++7364 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 146++7364 ~
 147++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 148++7364 ~            IF1Init:
 149++7364 ~            	rst		08
 150++7364 ~            	defb	49		;create system variables
 151++7364 ~            	ret
 152++7364 ~
 153++7364 ~            ;ReadWriteTrackSector
 154++7364 ~            ;A=command: 0, 1, 2, 4
 155++7364 ~            RWTS:
 156++7364 ~            	ld (RWTSCmd), a
 157++7364 ~            	ld hl, RWTSParams
 158++7364 ~            	ld (HD11), hl
 159++7364 ~            	rst 08
 160++7364 ~            	DEFB 58
 161++7364 ~            	ret
 162++7364 ~
 163++7364 ~
 164++7364 ~            ;D = sector, E = track
 165++7364 ~            ;HL = dma
 166++7364 ~            ReadOneDiskSector:
 167++7364 ~            	ld (RWTSDMA), hl
 168++7364 ~            	ld (RWTSTrack), de
 169++7364 ~            	;ld (RWTSDrive), a
 170++7364 ~            	ld a, RWTS_CMD_READ
 171++7364 ~            	jr	RWTS
 172++7364 ~
 173++7364 ~            ;D = sector, E = track
 174++7364 ~            ;HL = dma
 175++7364 ~            WriteOneDiskSector:
 176++7364 ~            	ld (RWTSDMA), hl
 177++7364 ~            	ld (RWTSTrack), de
 178++7364 ~            	;ld (RWTSDrive), a
 179++7364 ~            	ld a, RWTS_CMD_WRITE
 180++7364 ~            	jr	RWTS
 181++7364 ~
 182++7364 ~            FormatDisk:
 183++7364 ~            	ld		hl, DataBuf
 184++7364 ~            	ld		(hl), DEL_MARKER
 185++7364 ~            	ld 		(RWTSDMA), hl
 186++7364 ~            	ld 		a, RWTS_CMD_FMT
 187++7364 ~            	call	RWTS
 188++7364 ~            	ld		a, (RWTSRes)
 189++7364 ~            	ret
 190++7364 ~
 191++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 192++7364 ~
 193++7364 ~            ;Allocation unit no. to track/sector
 194++7364 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 195++7364 ~            ;IN:  HL=alloc. unit no.
 196++7364 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 197++7364 ~            AU2TS:
 198++7364 ~            	ld c, SPT/SPAL
 199++7364 ~            	call Div					;A = sector
 200++7364 ~            	push af
 201++7364 ~            		/*
 202++7364 ~            		ld c, HEAD_CNT
 203++7364 ~            		call Div				;L = track, A = head (0 or 1)
 204++7364 ~            		*/
 205++7364 ~            		xor a
 206++7364 ~            		rr h
 207++7364 ~            		rr l
 208++7364 ~            		rr a
 209++7364 ~
 210++7364 ~            		ld c, l
 211++7364 ~            		ld b, 0
 212++7364 ~            		or a
 213++7364 ~            		jr z, Track0
 214++7364 ~            		ld b, SPT
 215++7364 ~            Track0:
 216++7364 ~            	pop af
 217++7364 ~            	or a
 218++7364 ~            	jr z, FirstAU
 219++7364 ~            	ld a, SPAL
 220++7364 ~            FirstAU:
 221++7364 ~            	add a, b
 222++7364 ~            	ld  b, a
 223++7364 ~            	ret
 224++7364 ~
 225++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 226++7364 ~
 227++7364 ~            ;Checks the allocation units number used in extension
 228++7364 ~            ;IN:	IX = extension addr
 229++7364 ~            ;OUT:	B = no. of allocation units used
 230++7364 ~            ;		C = no. of records used in ext.
 231++7364 ~            ;		HL = first alloc. unit no.
 232++7364 ~            ;		DE = last alloc. unit no.
 233++7364 ~            CheckExtAlloc:
 234++7364 ~            	push ix
 235++7364 ~            		ld bc, EXT_RC
 236++7364 ~            		add ix, bc
 237++7364 ~            		ld c, (ix)			;save rec. no.
 238++7364 ~            		inc ix
 239++7364 ~            		ld l, (ix)
 240++7364 ~            		ld h, (ix + 1)
 241++7364 ~            		ld b, EXT_AU_CNT
 242++7364 ~            CheckAU:
 243++7364 ~            		ld a, (ix)
 244++7364 ~            		or (ix + 1)
 245++7364 ~            		jr z, CheckAUEnd
 246++7364 ~            		ld e, (ix)
 247++7364 ~            		ld d, (ix + 1)
 248++7364 ~            		inc ix
 249++7364 ~            		inc ix
 250++7364 ~            		djnz CheckAU
 251++7364 ~            CheckAUEnd:
 252++7364 ~            		ld a, EXT_AU_CNT
 253++7364 ~            		sub b
 254++7364 ~            		ld b, a
 255++7364 ~            	pop ix
 256++7364 ~            	ret
 257++7364 ~
 258++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 259++7364 ~
 260++7364 ~            ;Input: TrackBuffer
 261++7364 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 262++7364 ~            ReadUsedBlocksList:
 263++7364 ~            	ld		ix, TrackBuf			;source buffer
 264++7364 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 265++7364 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 266++7364 ~            	ld		de, 2					;counter of used blocks, start with 2
 267++7364 ~            	ld		(hl), e
 268++7364 ~            	inc		hl
 269++7364 ~            	ld		(hl), d
 270++7364 ~            	inc		hl
 271++7364 ~
 272++7364 ~            	;Add blocks 0 and 1 for directory
 273++7364 ~            	ld		de, 0
 274++7364 ~            	ld		(hl), e
 275++7364 ~            	inc		hl
 276++7364 ~            	ld		(hl), d
 277++7364 ~            	inc		hl
 278++7364 ~
 279++7364 ~            	inc		de
 280++7364 ~            	ld		(hl), e
 281++7364 ~            	inc		hl
 282++7364 ~            	ld		(hl), d
 283++7364 ~            	inc		hl
 284++7364 ~
 285++7364 ~            ReadUsedBlocksLoop:
 286++7364 ~            	xor		a
 287++7364 ~            	cp		(ix)
 288++7364 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 289++7364 ~
 290++7364 ~            	push	ix
 291++7364 ~            	push	bc
 292++7364 ~            		ld		b, EXT_AU_CNT
 293++7364 ~            		ld		de, EXT_AU0
 294++7364 ~            		add		ix, de
 295++7364 ~
 296++7364 ~            ReadUsedBlocksLoop2:
 297++7364 ~            		ld		e, (ix)
 298++7364 ~            		ld		d, (ix+1)
 299++7364 ~            		ld		a, e
 300++7364 ~            		or		d
 301++7364 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 302++7364 ~
 303++7364 ~            		ld		(hl), e
 304++7364 ~            		inc		hl
 305++7364 ~            		ld		(hl), d
 306++7364 ~            		inc		hl
 307++7364 ~
 308++7364 ~            		inc		ix
 309++7364 ~            		inc		ix
 310++7364 ~
 311++7364 ~            		ld		de, (UsedBlockListCnt)
 312++7364 ~            		inc		de
 313++7364 ~            		ld		(UsedBlockListCnt), de
 314++7364 ~
 315++7364 ~            		djnz	ReadUsedBlocksLoop2
 316++7364 ~
 317++7364 ~
 318++7364 ~            ReadUsedBlocksSkip:
 319++7364 ~            	pop		bc
 320++7364 ~            	pop		ix
 321++7364 ~            ReadUsedBlocksSkip2:
 322++7364 ~            	ld		de, EXT_SZ
 323++7364 ~            	add		ix, de
 324++7364 ~
 325++7364 ~            	dec		bc
 326++7364 ~            	ld		a, b
 327++7364 ~            	or		c
 328++7364 ~            	jr		nz, ReadUsedBlocksLoop
 329++7364 ~
 330++7364 ~            	ret
 331++7364 ~
 332++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333++7364 ~            ;Reads 8 sectors for an AU
 334++7364 ~            ;HL = block number, DE = destination buffer
 335++7364 ~            ReadFSBlock:
 336++7364 ~            	push	de
 337++7364 ~            		call	AU2TS		;B=sector, C=track
 338++7364 ~            	pop		hl				;HL=dest
 339++7364 ~
 340++7364 ~            	ld		d, b
 341++7364 ~            	ld		e, c
 342++7364 ~            	ld		b, SPAL
 343++7364 ~
 344++7364 ~            	call	ReadDiskSectors
 345++7364 ~            	ret
 346++7364 ~
 347++7364 ~
 348++7364 ~            ;Write 8 sectors for an AU
 349++7364 ~            ;HL = block number, DE = source buffer
 350++7364 ~            WriteFSBlock:
 351++7364 ~            	push	de
 352++7364 ~            		call	AU2TS		;B=sector, C=track
 353++7364 ~            	pop		hl				;HL=dest
 354++7364 ~
 355++7364 ~            	ld		d, b
 356++7364 ~            	ld		e, c
 357++7364 ~            	ld		b, SPAL
 358++7364 ~
 359++7364 ~            	call	WriteDiskSectors
 360++7364 ~            	ret
 361++7364 ~
 362++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 363++7364 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 364++7364 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 365++7364 ~            CopyDisk:
 366++7364 ~            	;Get list of used blocks in current disk, max 632 bytes
 367++7364 ~            	call	ReadUsedBlocksList
 368++7364 ~            	ld		ix, UsedBlockListBlk
 369++7364 ~
 370++7364 ~            CopyDiskLoop:
 371++7364 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 372++7364 ~            	ld		de, MsgBlocksLeft
 373++7364 ~            	call	Byte2Txt
 374++7364 ~            	ld		hl, MsgBlocksLeft
 375++7364 ~            	ld		de, LST_LINE_MSG + 1 << 8
 376++7364 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 377++7364 ~            	call	PrintStrClr
 378++7364 ~
 379++7364 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 380++7364 ~            	ld		hl, MAX_AU_RAM
 381++7364 ~            	ld		bc, (UsedBlockListCnt)
 382++7364 ~            	or		a
 383++7364 ~            	sbc		hl, bc
 384++7364 ~            	jr		nc, CopyDiskLoopRead
 385++7364 ~            	ld		bc, MAX_AU_RAM
 386++7364 ~
 387++7364 ~            CopyDiskLoopRead:
 388++7364 ~            	ld		b, c
 389++7364 ~            	ld		de, CopyDiskBuf
 390++7364 ~            	;save initial counter and initial block number array position
 391++7364 ~            	push	bc
 392++7364 ~            	push	ix
 393++7364 ~
 394++7364 ~            CopyDiskLoopReadLoop:
 395++7364 ~            		ld		l, (ix)
 396++7364 ~            		ld		h, (ix+1)
 397++7364 ~            		inc		ix
 398++7364 ~            		inc		ix
 399++7364 ~
 400++7364 ~            		push	de
 401++7364 ~            		push	bc
 402++7364 ~            			call	ReadFSBlock			;Stop on error or continue?
 403++7364 ~            		pop		bc
 404++7364 ~            		pop		de
 405++7364 ~
 406++7364 ~            		;+2048
 407++7364 ~            		ld		a, d
 408++7364 ~            		add		8
 409++7364 ~            		ld		d, a
 410++7364 ~
 411++7364 ~            		djnz	CopyDiskLoopReadLoop
 412++7364 ~
 413++7364 ~            		;Check if selection is 1=single drive or 2=dual drive
 414++7364 ~            		ld		a, (CopySelOption)
 415++7364 ~            		cp		'1'
 416++7364 ~            		jr		nz, CopyDiskDualDrive1
 417++7364 ~
 418++7364 ~            		;Prompt for disk change
 419++7364 ~            		call	PromptDiskChangeDst
 420++7364 ~            		ld		a, (RWTSDrive)
 421++7364 ~            		call	BDOSInit
 422++7364 ~            		jr		CopyDiskReadEnd
 423++7364 ~
 424++7364 ~            CopyDiskDualDrive1:
 425++7364 ~            		;alternate drive
 426++7364 ~            		ld		a, (RWTSDrive)
 427++7364 ~            		inc 	a
 428++7364 ~            		xor		%11
 429++7364 ~            		dec		a
 430++7364 ~            		ld		(RWTSDrive), a
 431++7364 ~
 432++7364 ~            CopyDiskReadEnd:
 433++7364 ~            	;restore initial counter and initial block number array position
 434++7364 ~            	pop		ix
 435++7364 ~            	pop		bc
 436++7364 ~            	ld		de, CopyDiskBuf
 437++7364 ~            	push	bc
 438++7364 ~
 439++7364 ~            CopyDiskLoopWriteLoop:
 440++7364 ~            		ld		l, (ix)
 441++7364 ~            		ld		h, (ix+1)
 442++7364 ~            		inc		ix
 443++7364 ~            		inc		ix
 444++7364 ~
 445++7364 ~            		push	de
 446++7364 ~            		push	bc
 447++7364 ~            			call	WriteFSBlock		;Stop on error or continue?
 448++7364 ~            		pop		bc
 449++7364 ~            		pop		de
 450++7364 ~
 451++7364 ~            		;+2048
 452++7364 ~            		ld		a, d
 453++7364 ~            		add		8
 454++7364 ~            		ld		d, a
 455++7364 ~
 456++7364 ~            		djnz	CopyDiskLoopWriteLoop
 457++7364 ~
 458++7364 ~            CopyDiskWriteEnd:
 459++7364 ~            	pop		bc
 460++7364 ~            	ld		c, b
 461++7364 ~            	ld		b, 0
 462++7364 ~
 463++7364 ~            	;Decrease number of blocks read by now.
 464++7364 ~            	ld		hl, (UsedBlockListCnt)
 465++7364 ~            	or		a
 466++7364 ~            	sbc		hl, bc
 467++7364 ~            	ld		(UsedBlockListCnt), hl
 468++7364 ~
 469++7364 ~            	ld		a, l
 470++7364 ~            	or		h
 471++7364 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 472++7364 ~
 473++7364 ~            	;Check if selection is 1=single drive or 2=dual drive
 474++7364 ~            	ld		a, (CopySelOption)
 475++7364 ~            	cp		'1'
 476++7364 ~            	jr		nz, CopyDiskDualDrive2
 477++7364 ~
 478++7364 ~            	;Prompt for disk change
 479++7364 ~            	call	PromptDiskChangeSrc
 480++7364 ~            	ld		a, (RWTSDrive)
 481++7364 ~            	call	BDOSInit
 482++7364 ~            	jp		CopyDiskLoop
 483++7364 ~
 484++7364 ~            CopyDiskDualDrive2:
 485++7364 ~            	;alternate drive again
 486++7364 ~            	ld		a, (RWTSDrive)
 487++7364 ~            	inc		a
 488++7364 ~            	xor		%11
 489++7364 ~            	dec		a
 490++7364 ~            	ld		(RWTSDrive), a
 491++7364 ~            	jp		CopyDiskLoop
 492++7364 ~
 493++7364 ~            CopyDiskEnd:
 494++7364 ~            	ld		b, 1
 495++7364 ~            	call	ClearNMsgLines
 496++7364 ~            	ret
 497++7364 ~
 498++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 499++7364 ~            ;Copies the current disk blocks to COM port.
 500++7364 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 501++7364 ~            CopyDiskToCOM:
 502++7364 ~            	;Get list of used blocks in current disk, max 632 bytes
 503++7364 ~            	call	ReadUsedBlocksList
 504++7364 ~
 505++7364 ~            	;Send block count and block indexes
 506++7364 ~            	ld		hl, (UsedBlockListCnt)
 507++7364 ~            	add		hl, hl
 508++7364 ~            	inc		hl
 509++7364 ~            	inc		hl
 510++7364 ~            	ld		b, h
 511++7364 ~            	ld		c, l
 512++7364 ~            	ld		hl, UsedBlockListCnt
 513++7364 ~            	call	SERTB
 514++7364 ~
 515++7364 ~            	ld		ix, UsedBlockListBlk
 516++7364 ~
 517++7364 ~            CopyDiskToCOMLoop:
 518++7364 ~            	;Print block count left
 519++7364 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 520++7364 ~            	ld		de, MsgBlocksLeft
 521++7364 ~            	call	Byte2Txt
 522++7364 ~            	ld		hl, MsgBlocksLeft
 523++7364 ~            	ld		de, LST_LINE_MSG + 1 << 8
 524++7364 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 525++7364 ~            	call	PrintStrClr
 526++7364 ~
 527++7364 ~            	;Read block into buffer
 528++7364 ~            	ld		l, (ix)
 529++7364 ~            	ld		h, (ix+1)
 530++7364 ~            	ld		de, CopyDiskBuf
 531++7364 ~            	push	ix
 532++7364 ~            		call	ReadFSBlock
 533++7364 ~            	pop		ix
 534++7364 ~            	inc		ix
 535++7364 ~            	inc		ix
 536++7364 ~
 537++7364 ~            	;Send block buffer
 538++7364 ~            	ld		hl, CopyDiskBuf
 539++7364 ~            	ld		bc, AU_SZ
 540++7364 ~            	call	SERTB
 541++7364 ~
 542++7364 ~            	ld		bc, (UsedBlockListCnt)
 543++7364 ~            	dec		bc
 544++7364 ~            	ld		(UsedBlockListCnt), bc
 545++7364 ~
 546++7364 ~            	push	ix
 547++7364 ~            		call	KbdHit
 548++7364 ~            	pop		ix
 549++7364 ~            	ret		c
 550++7364 ~
 551++7364 ~            	ld		a, b
 552++7364 ~            	or		c
 553++7364 ~            	jr		nz, CopyDiskToCOMLoop
 554++7364 ~
 555++7364 ~            	ret
 556++7364 ~
 557++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 558++7364 ~            CopyDiskFromCOM:
 559++7364 ~            	;Receive block count.
 560++7364 ~            	ld		hl, UsedBlockListCnt
 561++7364 ~            	ld		bc, 2
 562++7364 ~            	ld		e, 0
 563++7364 ~            	call	SERRB
 564++7364 ~
 565++7364 ~            	;Receive block indexes.
 566++7364 ~            	ld		hl, (UsedBlockListCnt)
 567++7364 ~            	add		hl, hl
 568++7364 ~            	ld		b, h
 569++7364 ~            	ld		c, l
 570++7364 ~            	ld		hl, UsedBlockListBlk
 571++7364 ~            	ld		e, 0
 572++7364 ~            	call	SERRB
 573++7364 ~
 574++7364 ~            	;Read each block by index and write to disk
 575++7364 ~            	ld		ix, UsedBlockListBlk
 576++7364 ~
 577++7364 ~            CopyDiskFromCOMLoop:
 578++7364 ~            	;Print block count left
 579++7364 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 580++7364 ~            	ld		de, MsgBlocksLeft
 581++7364 ~            	call	Byte2Txt
 582++7364 ~            	ld		hl, MsgBlocksLeft
 583++7364 ~            	ld		de, LST_LINE_MSG + 1 << 8
 584++7364 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 585++7364 ~            	call	PrintStrClr
 586++7364 ~
 587++7364 ~            	;Read block buffer
 588++7364 ~            	ld		hl, CopyDiskBuf
 589++7364 ~            	ld		bc, AU_SZ
 590++7364 ~            	ld		e, 0
 591++7364 ~            	call	SERRB
 592++7364 ~
 593++7364 ~            	;Write block to disk
 594++7364 ~            	ld		l, (ix)
 595++7364 ~            	ld		h, (ix+1)
 596++7364 ~            	ld		de, CopyDiskBuf
 597++7364 ~            	push	ix
 598++7364 ~            		call	WriteFSBlock			;Stop on error or continue?
 599++7364 ~            	pop		ix
 600++7364 ~            	inc		ix
 601++7364 ~            	inc		ix
 602++7364 ~
 603++7364 ~            	ld		bc, (UsedBlockListCnt)
 604++7364 ~            	dec		bc
 605++7364 ~            	ld		(UsedBlockListCnt), bc
 606++7364 ~
 607++7364 ~            	push	ix
 608++7364 ~            		call	KbdHit
 609++7364 ~            	pop		ix
 610++7364 ~            	ret		c
 611++7364 ~
 612++7364 ~            	ld		a, b
 613++7364 ~            	or		c
 614++7364 ~            	jr		nz, CopyDiskFromCOMLoop
 615++7364 ~            	ret
 616++7364 ~
 617++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 618++7364 ~
 619++7364 ~            ;Compare string at HL with the one at DE, max length B
 620++7364 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 621++7364 ~            ;OUT: z flag, set = match, reset = mismatch
 622++7364 ~            StrCmp:
 623++7364 ~            	push hl
 624++7364 ~            	push de
 625++7364 ~            Compare:
 626++7364 ~            		ld a, (de)
 627++7364 ~            		cp (hl)
 628++7364 ~            		jr nz, MisMatch
 629++7364 ~            		inc hl
 630++7364 ~            		inc de
 631++7364 ~            		djnz Compare
 632++7364 ~            MisMatch:
 633++7364 ~            	pop de
 634++7364 ~            	pop hl
 635++7364 ~            	ret
 636++7364 ~
 637++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 638++7364 ~
 639++7364 ~            ;Read a file into a buffer, sector by sector.
 640++7364 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 641++7364 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 642++7364 ~            ;In: HL = Name address, DE = buffer
 643++7364 ~            IF1FileLoad:
 644++7364 ~            	push	de
 645++7364 ~            		ld (FSTR1), hl
 646++7364 ~            		ld h, 0
 647++7364 ~            		ld a, (RWTSDrive)
 648++7364 ~            		inc  a			;CP/M drive number to BASIC drive number
 649++7364 ~            		ld	l, a
 650++7364 ~            		ld (DSTR1), hl
 651++7364 ~            		ld l,NAMELEN
 652++7364 ~            		ld (NSTR1), hl
 653++7364 ~            		rst 08
 654++7364 ~            		DEFB 51			;open disk channel
 655++7364 ~
 656++7364 ~            		rst		8
 657++7364 ~            		defb	53		;read sector
 658++7364 ~            	pop		de
 659++7364 ~            	jr		nc, FileFree
 660++7364 ~
 661++7364 ~            	ld		a, (ix + CH_DATA)
 662++7364 ~            	cp		TEXT_TYPE
 663++7364 ~            	jr		nc, FileLoadNoHeader
 664++7364 ~
 665++7364 ~            FileLoadHeader:
 666++7364 ~            	push	ix
 667++7364 ~            	pop		hl
 668++7364 ~            	ld		bc, CH_DATA + HDR_SZ
 669++7364 ~            	add		hl, bc
 670++7364 ~            	ld		bc, SECT_SZ - HDR_SZ
 671++7364 ~            	ldir
 672++7364 ~
 673++7364 ~            FileReadLoop:
 674++7364 ~            	push	de
 675++7364 ~            		rst		8
 676++7364 ~            		defb	53		;read sector
 677++7364 ~            	pop		de
 678++7364 ~            	jr		nc, FileFree
 679++7364 ~
 680++7364 ~            FileLoadNoHeader:
 681++7364 ~            	push	ix
 682++7364 ~            	pop		hl
 683++7364 ~            	ld		bc, CH_DATA
 684++7364 ~            	add		hl, bc
 685++7364 ~            	ld		bc, SECT_SZ
 686++7364 ~            	ldir
 687++7364 ~            	jr		FileReadLoop
 688++7364 ~
 689++7364 ~            FileFree:
 690++7364 ~            	push	de
 691++7364 ~            	rst		8
 692++7364 ~            	defb	56			;close channel (52) or detroy channel (56)
 693++7364 ~            	pop		de
 694++7364 ~            	ret
 695++7364 ~            IF1FileLoadEnd:
 696++7364 ~
 697++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 698++7364 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 699++7364 ~            ;Out: A = error code, 0=OK
 700++7364 ~            ReadDiskSectors:
 701++7364 ~            	push bc
 702++7364 ~            		push hl
 703++7364 ~            			push de
 704++7364 ~            				call ReadOneDiskSector
 705++7364 ~            			pop de
 706++7364 ~            		pop hl
 707++7364 ~
 708++7364 ~            		inc d
 709++7364 ~            		inc h
 710++7364 ~            	pop bc
 711++7364 ~
 712++7364 ~            	ld	a, (RWTSRes)
 713++7364 ~            	or	a
 714++7364 ~            	ret nz
 715++7364 ~
 716++7364 ~            	djnz ReadDiskSectors
 717++7364 ~            	ret
 718++7364 ~
 719++7364 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 720++7364 ~            ;Out: A = error code, 0=OK
 721++7364 ~            WriteDiskSectors:
 722++7364 ~            	push bc
 723++7364 ~            		push hl
 724++7364 ~            			push de
 725++7364 ~            				call WriteOneDiskSector
 726++7364 ~            			pop de
 727++7364 ~            		pop hl
 728++7364 ~
 729++7364 ~            		inc d
 730++7364 ~            		inc h
 731++7364 ~            	pop bc
 732++7364 ~
 733++7364 ~            	ld	a, (RWTSRes)
 734++7364 ~            	or	a
 735++7364 ~            	ret nz
 736++7364 ~
 737++7364 ~            	djnz WriteDiskSectors
 738++7364 ~            	ret
 739++7364 ~
 740++7364 ~
 741++7364 ~            ;Reads disk catalog
 742++7364 ~            ReadCatalogTrack:
 743++7364 ~            	ld hl, TrackBuf
 744++7364 ~            	ld de, 0
 745++7364 ~            	ld b, SPT
 746++7364 ~
 747++7364 ~            	call ReadDiskSectors
 748++7364 ~            	ret
 749++7364 ~
 750++7364 ~            ;A = track
 751++7364 ~            SeekTrack:
 752++7364 ~            	IFUSED
 753++7364 ~            	ld	(RWTSTrack), a
 754++7364 ~            	ld 	a, RWTS_CMD_SEEK
 755++7364 ~            	jp	RWTS
 756++7364 ~            	ENDIF
 757++7364 ~
 758++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759++7364 ~
 760++7364 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 761++7364 ~            FindCache:
 762++7364 ~            	ld		b, NAMELEN
 763++7364 ~            	call	StrCmp			;find the file to wich this extension belongs
 764++7364 ~            	ret		z
 765++7364 ~
 766++7364 ~            	dec		c
 767++7364 ~            	jr		nz, CacheNotFinished
 768++7364 ~            	or		c
 769++7364 ~            	ret
 770++7364 ~
 771++7364 ~            CacheNotFinished:
 772++7364 ~            	ld		bc, CACHE_SZ
 773++7364 ~            	add		hl, bc			;to the next cache line
 774++7364 ~            	jr		FindCache
 775++7364 ~
 776++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 777++7364 ~
 778++7364 ~            	;ld		ix, (SelFileCache)
 779++7364 ~            ReadFileHeader:
 780++7364 ~            	ld		a, (ix + CACHE_FLAG)
 781++7364 ~            	or		a
 782++7364 ~            	ret		nz				;return if already read
 783++7364 ~
 784++7364 ~            	ld		l, (ix + CACHE_FIRST_AU)
 785++7364 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 786++7364 ~            	ld		a, h
 787++7364 ~            	or		l
 788++7364 ~            	jr		z, ReadHeaderEnd
 789++7364 ~
 790++7364 ~            	call	AU2TS
 791++7364 ~            	ld		d, b
 792++7364 ~            	ld		e, c
 793++7364 ~            	ld		hl, DataBuf
 794++7364 ~            	push	ix
 795++7364 ~            	push	ix
 796++7364 ~            		call	ReadOneDiskSector
 797++7364 ~            	pop		hl
 798++7364 ~            	pop		ix
 799++7364 ~
 800++7364 ~            	push	hl
 801++7364 ~            		ld		hl, DataBuf
 802++7364 ~            		call	IsFileHeaderValid
 803++7364 ~            	pop		hl
 804++7364 ~            	or		a
 805++7364 ~            	jr		z, ReadFileHeaderIsTextFile
 806++7364 ~
 807++7364 ~            	ld		bc, CACHE_HDR
 808++7364 ~            	add		hl, bc
 809++7364 ~            	ex		hl, de
 810++7364 ~            	ld		hl, DataBuf
 811++7364 ~            	ld		bc, HDR_SZ
 812++7364 ~            	ldir
 813++7364 ~
 814++7364 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 815++7364 ~            	ld		a, BYTE_TYPE
 816++7364 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 817++7364 ~            	jr		nc, ReadHeaderEnd
 818++7364 ~
 819++7364 ~            ReadFileHeaderIsTextFile:
 820++7364 ~            	push	ix
 821++7364 ~            	push	ix
 822++7364 ~            	pop		hl
 823++7364 ~            		call	GetFileSize
 824++7364 ~            	pop		ix
 825++7364 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 826++7364 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 827++7364 ~            	ld		a, TEXT_TYPE
 828++7364 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 829++7364 ~
 830++7364 ~            ReadHeaderEnd:
 831++7364 ~            	inc		(ix + CACHE_FLAG)
 832++7364 ~            	ret
 833++7364 ~
 834++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 835++7364 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 836++7364 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 837++7364 ~            ;In: HL = header
 838++7364 ~            ;Out: A > 0 if valid
 839++7364 ~            IsFileHeaderValid:
 840++7364 ~            	IFUSED
 841++7364 ~            	xor		a
 842++7364 ~            	ld		b, HDR_SZ
 843++7364 ~            IsFileHeaderValidLoop:
 844++7364 ~            	or		(hl)
 845++7364 ~            	inc		hl
 846++7364 ~            	djnz	IsFileHeaderValidLoop
 847++7364 ~
 848++7364 ~            	ret
 849++7364 ~            	ENDIF
 850++7364 ~
 851++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 852++7364 ~
 853++7364 ~            ;IN: HL = address from IF1 to call
 854++7364 ~            IF1Call:
 855++7364 ~            	LD   (HD11), HL
 856++7364 ~            	RST  8
 857++7364 ~            	DEFB 50
 858++7364 ~            	RET
 859++7364 ~
 860++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 861++7364 ~
 862++7364 ~            ;Load a program from disk
 863++7364 ~            ;IN: HL = file name addr
 864++7364 ~            LoadProgram:
 865++7364 ~            	LD   (FSTR1), HL
 866++7364 ~            	LD   H, 0
 867++7364 ~            	LD   L, NAMELEN
 868++7364 ~            	LD   (NSTR1), HL
 869++7364 ~            	LD	 A, (RWTSDrive)
 870++7364 ~            	INC  A					;Adapt for BASIC drive number
 871++7364 ~            	LD   L, A
 872++7364 ~            	LD   (DSTR1), HL
 873++7364 ~            	LD   HL, LOAD_ADDR
 874++7364 ~            	CALL IF1Call
 875++7364 ~            	RET
 876++7364 ~
 877++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 878++7364 ~
 879++7364 ~            SetFastKeys:
 880++7364 ~            	ld		hl, REPDEL
 881++7364 ~            	;ld		de, (1 << 8) | 15
 882++7364 ~            	ld		de, (1 << 8) | 10
 883++7364 ~            	ld		(hl), de
 884++7364 ~
 885++7364 ~            	ret
 886++7364 ~
 887++7364 ~
 888++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 889++7364 ~            ;Reads the error message string from IF1 ROM.
 890++7364 ~            GetErrMsg:
 891++7364 ~            	inc		a
 892++7364 ~            	ex		af, af'
 893++7364 ~
 894++7364 ~            	ld		hl, IF1Paged			;page-in IF1
 895++7364 ~            	jp		IF1Call
 896++7364 ~
 897++7364 ~            IF1Paged:
 898++7364 ~            	ld		hl, ERRMSG
 899++7364 ~            	ex		af, af'
 900++7364 ~            	or		a
 901++7364 ~            	jr		z, SaveMsg
 902++7364 ~
 903++7364 ~            	ld		b, 0
 904++7364 ~            SearchMsgEnd:
 905++7364 ~            	bit		7, (hl)
 906++7364 ~            	inc		hl
 907++7364 ~            	jr		z, SearchMsgEnd
 908++7364 ~
 909++7364 ~            	inc		b
 910++7364 ~            	cp		b
 911++7364 ~            	jr		nz, SearchMsgEnd
 912++7364 ~
 913++7364 ~            SaveMsg:
 914++7364 ~            	ld		de, DataBuf
 915++7364 ~            CopyMsg:
 916++7364 ~            	ld		a, (hl)
 917++7364 ~            	bit		7, a
 918++7364 ~            	ld		(de), a
 919++7364 ~            	inc		hl
 920++7364 ~            	inc		de
 921++7364 ~            	jr		z, CopyMsg
 922++7364 ~
 923++7364 ~            	ret
 924++7364 ~
 925++7364 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926++7364 ~
 927++7364 ~            ;RWTS routine I/O block
 928++7364 ~            RWTSParams:
 929++7364 ~            RWTSBlockType	DEFB	1							;?
 930++7364 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 931++7364 ~            RWTSVolNo		DEFB	0							;?
 932++7364 ~            RWTSTrack		DEFB	0
 933++7364 ~            RWTSSector		DEFB	0
 934++7364 ~            RWTSDMA			DEFW	0
 935++7364 ~            RWTSExtBuf		DEFW	$2932
 936++7364 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 937++7364 ~            	IFDEF _REAL_HW_
 938++7364 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 939++7364 ~            	ELSE
 940++7364 ~            RWTSPrmTbl		DEFW	$1f2a
 941++7364 ~            	ENDIF
 942++7364 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 943++7364 ~            ;Results
 944++7364 ~            RWTSRes			DEFB	0
 945++7364 ~            RWTSResVolNo	DEFB	0
 946++7364 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 947++7364 ~
 948++7364 ~            ;Param. table, usualy found in ROM.
 949++7364 ~            	IFDEF _REAL_HW_
 950++7364 ~            BasPrmTbl:
 951++7364 ~
 952++7364 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 953++7364 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 954++7364 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 955++7364 ~            PrmDevType		DEFB	$01
 956++7364 ~            PrmStepRate		DEFB	$0D		;(milisec)
 957++7364 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 958++7364 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 959++7364 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 960++7364 ~            PrmFastFactor	EQU		4
 961++7364 ~            PrmDevType		DEFB	$01
 962++7364 ~            PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 963++7364 ~            PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 964++7364 ~            PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 965++7364 ~            	ENDIF
 966++7364 ~
 967++7364 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 968++7364 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 969++7364 ~            	ENDIF
 970++7364 ~
 971++7364              	endif
# file closed: if1.asm
   7+ 7364
   8+ 7364              BDOSInit:
   9+ 7364 AF           	xor		a
  10+ 7365 18 49        	jr		BDOS
  11+ 7367
  12+ 7367
  13+ 7367              ;IN: A = Drive to select
  14+ 7367              BDOSSelectDisk:
  15+ 7367              	IFUSED
  16+ 7367 DD 6F        	ld		ixl, a
  17+ 7369 DD 26 00     	ld		ixh, 0
  18+ 736C 3E 01        	ld		a, 1
  19+ 736E 18 40        	jr		BDOS
  20+ 7370              	ENDIF
  21+ 7370
  22+ 7370
  23+ 7370              BDOSMakeDiskRO:
  24+ 7370              	IFUSED
  25+ 7370 ~            	ld		a, 15
  26+ 7370 ~            	jr		BDOS
  27+ 7370              	ENDIF
  28+ 7370
  29+ 7370              ;Get Read Only flag
  30+ 7370              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 7370              BDOSGetDiskRO:
  32+ 7370              	IFUSED
  33+ 7370 ~            	ld	a, 16
  34+ 7370 ~            	jr	BDOS
  35+ 7370              	ENDIF
  36+ 7370
  37+ 7370              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 7370              BDOSGetCurrentDrive:
  39+ 7370              	IFUSED
  40+ 7370 3E 0C        	ld		a, 12
  41+ 7372 18 3C        	jr		BDOS
  42+ 7374              	ENDIF
  43+ 7374
  44+ 7374              ;Does log-off for all drives?
  45+ 7374              BDOSCloseDrives:
  46+ 7374              	IFUSED
  47+ 7374 ~            	ld		ixl, a
  48+ 7374 ~            	ld		ixh, 0
  49+ 7374 ~            	ld		a, 22
  50+ 7374 ~            	jr		BDOS
  51+ 7374              	ENDIF
  52+ 7374
  53+ 7374              ;Create a disk channel for BDOS access (does not open the file)
  54+ 7374              ;IN: HL=name addr, A=drive
  55+ 7374              ;OUT: IX=FCB
  56+ 7374              CreateChannel:
  57+ 7374 22 DC 5C     	ld (FSTR1), hl
  58+ 7377 26 00        	ld h,0
  59+ 7379 6F           	ld l,a
  60+ 737A 22 D6 5C     	ld (DSTR1), hl
  61+ 737D 2E 0B        	ld l,NAMELEN
  62+ 737F 22 DA 5C     	ld (NSTR1), hl
  63+ 7382 CF           	rst 08
  64+ 7383 37           	DEFB 55
  65+ 7384 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 7387 DD 09        	add ix, bc
  67+ 7389 C9           	ret
  68+ 738A
  69+ 738A
  70+ 738A              ;Destroy a BDOS channel
  71+ 738A              ;IN: IX=FCB
  72+ 738A              DestroyChannel:
  73+ 738A C5           	push bc
  74+ 738B 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 738E DD 09        	add ix, bc
  76+ 7390 CF           	rst 08
  77+ 7391 38           	DEFB 56
  78+ 7392 C1           	pop bc
  79+ 7393 C9           	ret
  80+ 7394
  81+ 7394
  82+ 7394              ;Input: IX=FCB
  83+ 7394              BDOSCreateFile:
  84+ 7394 3E 09        	ld	a, 9
  85+ 7396 18 18        	jr	BDOS
  86+ 7398
  87+ 7398              ;Input: IX=FCB
  88+ 7398              BDOSOpenFile:
  89+ 7398 3E 02        	ld	a, 2
  90+ 739A 18 14        	jr	BDOS
  91+ 739C
  92+ 739C              ;IN: IX=FCB
  93+ 739C              BDOSCloseFile:
  94+ 739C 3E 03        	ld	a, 3
  95+ 739E 18 10        	jr	BDOS
  96+ 73A0
  97+ 73A0
  98+ 73A0              ;0 OK,
  99+ 73A0              ;1 end of file,
 100+ 73A0              ;9 invalid FCB,
 101+ 73A0              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 73A0              ;11 (MP/M) unlocked file verification error,
 103+ 73A0              ;0FFh hardware error.
 104+ 73A0
 105+ 73A0              ;IN: IX=FCB
 106+ 73A0              BDOSReadFileBlockSeq:
 107+ 73A0 3E 07        	ld	a, 7
 108+ 73A2 18 0C        	jr	BDOS
 109+ 73A4
 110+ 73A4
 111+ 73A4              ;0 OK,
 112+ 73A4              ;1 directory full,
 113+ 73A4              ;2 disc full,
 114+ 73A4              ;8 (MP/M) record locked by another process,
 115+ 73A4              ;9 invalid FCB,
 116+ 73A4              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 73A4              ;11 (MP/M) unlocked file verification error,
 118+ 73A4              ;0FFh hardware error.
 119+ 73A4
 120+ 73A4              ;IN: IX=FCB
 121+ 73A4              BDOSWriteFileBlockSeq:
 122+ 73A4 3E 08        	ld	a, 8
 123+ 73A6 18 08        	jr	BDOS
 124+ 73A8
 125+ 73A8
 126+ 73A8              ;0 OK
 127+ 73A8              ;1 Reading unwritten data
 128+ 73A8              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 73A8              ;6 Record number out of range
 130+ 73A8              ;9 Invalid FCB
 131+ 73A8              BDOSReadFileBlockRandom:
 132+ 73A8 3E 12        	ld	a, 18
 133+ 73AA 18 04        	jr	BDOS
 134+ 73AC
 135+ 73AC              ;0 OK
 136+ 73AC              ;2 Disc full
 137+ 73AC              ;3 Cannot close extent
 138+ 73AC              ;5 Directory full
 139+ 73AC              ;6 Record number out of range
 140+ 73AC              ;8 Record is locked by another process (MP/M)
 141+ 73AC              ;9 Invalid FCB
 142+ 73AC              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 73AC              BDOSWriteFileBlockRandom:
 144+ 73AC 3E 13        	ld	a, 19
 145+ 73AE 18 00        	jr	BDOS
 146+ 73B0
 147+ 73B0
 148+ 73B0              ;Generic BDOS call
 149+ 73B0              ;IX=arg, A=function
 150+ 73B0              BDOS:
 151+ 73B0 DD 22 ED 5C  	ld (HD11), ix
 152+ 73B4 32 EF 5C     	ld (COPIES), a
 153+ 73B7 CF           	rst 08
 154+ 73B8 39           	DEFB 57
 155+ 73B9 C9           	ret
 156+ 73BA
 157+ 73BA              ;Set DMA address for BDOS
 158+ 73BA              ;IX=DMA
 159+ 73BA              BDOSSetDMA:
 160+ 73BA 3E 0D        	ld a, 13
 161+ 73BC 18 F2        	jr BDOS
 162+ 73BE
 163+ 73BE              ;In: IX=FCB
 164+ 73BE              BDOSSetRandFilePtr:
 165+ 73BE 3E 15        	ld	a, 21
 166+ 73C0 18 EE        	jr	BDOS
 167+ 73C2
 168+ 73C2              ;In: HL=filename
 169+ 73C2              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 73C2              GetFileSize:
 171+ 73C2              	IFUSED
 172+ 73C2
 173+ 73C2 3A 4C 73     	ld 		a, (RWTSDrive)
 174+ 73C5 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 73C6 CD 74 73     	call	CreateChannel
 176+ 73C9
 177+ 73C9 3E 14        	ld		a, 20
 178+ 73CB CD B0 73     	call	BDOS
 179+ 73CE              	;inc		a
 180+ 73CE              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 73CE
 182+ 73CE DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 73D1 DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 73D4
 185+ 73D4              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 73D4 3E 01        	ld		a, 1
 187+ 73D6 BC           	cp		h
 188+ 73D7 30 05        	jr		nc, GetFileSizeOK
 189+ 73D9 21 00 00     	ld		hl, 0
 190+ 73DC 18 08        	jr		GetFileSizeEnd
 191+ 73DE
 192+ 73DE              GetFileSizeOK:
 193+ 73DE              	;*128 == 2^7
 194+ 73DE 06 07        	ld		b, 7
 195+ 73E0              GetFileSizeMul:
 196+ 73E0 CB 15        	rl		l
 197+ 73E2 CB 14        	rl		h
 198+ 73E4 10 FA        	djnz	GetFileSizeMul
 199+ 73E6
 200+ 73E6              GetFileSizeEnd:
 201+ 73E6 E5           	push	hl
 202+ 73E7 CD 8A 73     		call	DestroyChannel
 203+ 73EA E1           	pop		hl
 204+ 73EB
 205+ 73EB C9           	ret
 206+ 73EC              	ENDIF
 207+ 73EC
 208+ 73EC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 73EC              ;HL=file name, A=drive
 210+ 73EC              DeleteFile:
 211+ 73EC CD 74 73     	call	CreateChannel
 212+ 73EF
 213+ 73EF 3E 06        	ld		a, 6
 214+ 73F1 CD B0 73     	call	BDOS
 215+ 73F4
 216+ 73F4 CD 8A 73     	call	DestroyChannel
 217+ 73F7 C9           	ret
 218+ 73F8
 219+ 73F8              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 73F8              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 73F8              ;HL=file name, A=drive
 222+ 73F8              DoesFileExist:
 223+ 73F8              	IFUSED
 224+ 73F8              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 73F8 F5           	push	af
 226+ 73F9 E5           	push	hl
 227+ 73FA DD 21 B5 EA  		ld		ix, FileIdx
 228+ 73FE CD BA 73     		call 	BDOSSetDMA
 229+ 7401 E1           	pop		hl
 230+ 7402 F1           	pop		af
 231+ 7403
 232+ 7403 CD 74 73     	call	CreateChannel
 233+ 7406
 234+ 7406              	;Uses FindFirst system call.
 235+ 7406 3E 04        	ld		a, 4
 236+ 7408 CD B0 73     	call	BDOS
 237+ 740B
 238+ 740B F5           	push	af
 239+ 740C CD 8A 73     		call	DestroyChannel
 240+ 740F F1           	pop		af
 241+ 7410 C9           	ret
 242+ 7411              	ENDIF
 243+ 7411
 244+ 7411              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7411              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 7411              ChangeFileAttrib:
 247+ 7411 3A 4C 73     	ld 		a, (RWTSDrive)
 248+ 7414 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 7415 D5           	push	de
 250+ 7416 CD 74 73     	call	CreateChannel
 251+ 7419 D1           	pop		de
 252+ 741A
 253+ 741A DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 741D CB 27        	sla		a								;reset existing attribute flag
 255+ 741F CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 7421 CB 1F        	rr		a								;put Carry flag in register L
 257+ 7423 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 7426
 259+ 7426 DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 7429 CB 27        	sla		a
 261+ 742B CB 1B        	rr		e
 262+ 742D CB 1F        	rr		a
 263+ 742F DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 7432
 265+ 7432              FileAttribSet:
 266+ 7432 3E 11        	ld		a, 17
 267+ 7434 CD B0 73     	call	BDOS
 268+ 7437
 269+ 7437 CD 8A 73     	call	DestroyChannel
 270+ 743A C9           	ret
 271+ 743B
 272+ 743B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 743B
 274+ 743B              ;HL=original name, DE = new name
 275+ 743B              ;Works only on the same drive.
 276+ 743B              RenameFile:
 277+ 743B 3A 4C 73     	ld 		a, (RWTSDrive)
 278+ 743E 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 743F D5           	push	de
 280+ 7440 CD 74 73     	call	CreateChannel
 281+ 7443 D1           	pop		de
 282+ 7444
 283+ 7444 DD E5        	push	ix					;IX == FCB
 284+ 7446 E1           	pop		hl
 285+ 7447 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 744A 09           	add		hl, bc
 287+ 744B EB           	ex		de, hl
 288+ 744C 3A 4C 73     	ld		a, (RWTSDrive)
 289+ 744F 12           	ld		(de), a
 290+ 7450 01 0B 00     	ld		bc, NAMELEN
 291+ 7453 ED B0        	ldir
 292+ 7455
 293+ 7455 3E 0A        	ld		a, 10
 294+ 7457 CD B0 73     	call	BDOS
 295+ 745A
 296+ 745A CD 8A 73     	call	DestroyChannel
 297+ 745D C9           	ret
 298+ 745E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 745E              PromptDiskChangeDst:
 300+ 745E 21 1E 80     	ld		hl, MsgInsertDstDsk
 301+ 7461 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 7464 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 7466 CD 1A 78     	call	PrintStrClr
 304+ 7469 21 2D 80     	ld		hl, MsgPressAnyKey
 305+ 746C 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 746F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 7471 CD 1A 78     	call	PrintStrClr
 308+ 7474 CD B6 77     	call	ReadChar
 309+ 7477 C9           	ret
 310+ 7478
 311+ 7478              PromptDiskChangeSrc:
 312+ 7478 21 0F 80     	ld		hl, MsgInsertSrcDsk
 313+ 747B 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 747E 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 7480 CD 1A 78     	call	PrintStrClr
 316+ 7483 21 2D 80     	ld		hl, MsgPressAnyKey
 317+ 7486 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 7489 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 748B CD 1A 78     	call	PrintStrClr
 320+ 748E CD B6 77     	call	ReadChar
 321+ 7491 C9           	ret
 322+ 7492              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 7492
 324+ 7492              ;HL = source file name, A = source drive
 325+ 7492              ;Use cases:
 326+ 7492              ;1. Copy from A: to B: or B: to A:.
 327+ 7492              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 7492              ;3. Copy from A:/B: to COM.
 329+ 7492              ;4. Copy from COM to A:/B:.
 330+ 7492              ;Single drive scenario:
 331+ 7492              ;1. Read first file part,
 332+ 7492              ;2. Ask for dest disk,
 333+ 7492              ;3. check if file exists/ask for overwrite,
 334+ 7492              ;4. create empty dest file,
 335+ 7492              ;5. write first file part,
 336+ 7492              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 7492              CopyFile:
 338+ 7492 3A 4C 73     	ld 		a, (RWTSDrive)
 339+ 7495 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 7496 32 7F 80     	ld		(CopyFileSrcDrv), a
 341+ 7499 32 8B 80     	ld		(CopyFileDstDrv), a
 342+ 749C 11 80 80     	ld		de, CopyFileSrcName
 343+ 749F 01 0B 00     	ld		bc, NAMELEN
 344+ 74A2 E5           	push	hl
 345+ 74A3 C5           	push	bc
 346+ 74A4 ED B0        	ldir
 347+ 74A6 C1           	pop		bc
 348+ 74A7 E1           	pop		hl
 349+ 74A8 11 8C 80     	ld		de, CopyFileDstName
 350+ 74AB ED B0        	ldir
 351+ 74AD
 352+ 74AD              	;Reset R/O attribute for destination, to allow file write.
 353+ 74AD 3A 94 80     	ld		a, (CopyFileDstName+RO_POS)
 354+ 74B0 CB BF        	res		7, a
 355+ 74B2 32 94 80     	ld		(CopyFileDstName+RO_POS), a
 356+ 74B5
 357+ 74B5 AF           	xor		a
 358+ 74B6 32 77 80     	ld		(CopyFileRes), a
 359+ 74B9 11 00 00     	ld		de, 0
 360+ 74BC ED 53 7A 80  	ld		(FilePosRead), de
 361+ 74C0 ED 53 7C 80  	ld		(FilePosWrite), de
 362+ 74C4
 363+ 74C4 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 364+ 74C7 C6 40        	add		'A'-1
 365+ 74C9              	;Update menu messages with current drive.
 366+ 74C9 32 98 7F     	ld		(MsgMenuSingleDrv1), a
 367+ 74CC 32 9C 7F     	ld		(MsgMenuSingleDrv2), a
 368+ 74CF 32 A6 7F     	ld		(MsgMenuDualDrv1), a
 369+ 74D2 32 B4 7F     	ld		(MsgMenuToComDrv), a
 370+ 74D5 32 C8 7F     	ld		(MsgMenuFromCOMDrv), a
 371+ 74D8              	;Update menu messages with the alternate drive.
 372+ 74D8 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 373+ 74DB EE 03        	xor		%11
 374+ 74DD C6 40        	add		'A'-1
 375+ 74DF 32 AA 7F     	ld		(MsgMenuDualDrv2), a
 376+ 74E2
 377+ 74E2 21 75 7F     	ld		hl, MsgMenuFileCopy
 378+ 74E5 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 74E8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 74EA CD 1A 78     	call	PrintStrClr
 381+ 74ED 21 84 7F     	ld		hl, MsgMenuBack
 382+ 74F0 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 74F3 CD F2 77     	call	PrintStr
 384+ 74F6 21 90 7F     	ld		hl, MsgMenuSingle
 385+ 74F9 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 74FC CD F2 77     	call	PrintStr
 387+ 74FF 21 9E 7F     	ld		hl, MsgMenuDual
 388+ 7502 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 7505 CD F2 77     	call	PrintStr
 390+ 7508 21 AC 7F     	ld		hl, MsgMenuToCOM
 391+ 750B 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 750E CD F2 77     	call	PrintStr
 393+ 7511 21 BB 7F     	ld		hl, MsgMenuFromCOM
 394+ 7514 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 7517 CD F2 77     	call	PrintStr
 396+ 751A
 397+ 751A CD B6 77     	call	ReadChar
 398+ 751D 32 74 80     	ld		(CopySelOption), a
 399+ 7520
 400+ 7520 F5           	push	af
 401+ 7521 06 06        		ld		b, 6
 402+ 7523 CD 9E 79     		call	ClearNMsgLines
 403+ 7526 F1           	pop		af
 404+ 7527
 405+ 7527              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 7527 FE 30        	cp		'0'
 407+ 7529 20 04        	jr		nz, CopyFileNotExit
 408+ 752B E1           	pop		hl
 409+ 752C C3 44 67     	jp		ReadKeyLoop
 410+ 752F
 411+ 752F              CopyFileNotExit:
 412+ 752F FE 31        	cp		'1'
 413+ 7531 28 4D        	jr		z, CopyFileSameDrive
 414+ 7533
 415+ 7533 FE 32        	cp		'2'
 416+ 7535 CA FF 75     	jp		z, CopyFileDualDrive
 417+ 7538
 418+ 7538 FE 33        	cp		'3'
 419+ 753A CA 49 76     	jp		z, CopyFileToCOM
 420+ 753D
 421+ 753D FE 34        	cp		'4'
 422+ 753F CA 7C 76     	jp		z, CopyFileFromCOM
 423+ 7542
 424+ 7542 E1           	pop		hl
 425+ 7543 C3 44 67     	jp		ReadKeyLoop
 426+ 7546
 427+ 7546
 428+ 7546              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 7546              CopyFileCheckOverwrite:
 430+ 7546              	;Check if destination file exists.
 431+ 7546 3A 8B 80     	ld		a, (CopyFileDstDrv)
 432+ 7549 21 8C 80     	ld		hl, CopyFileDstName
 433+ 754C CD F8 73     	call	DoesFileExist
 434+ 754F 3C           	inc		a
 435+ 7550 C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 7551
 437+ 7551              	;Ask overwrite confirmation.
 438+ 7551 21 F1 7F     	ld		hl, MsgFileOverwrite
 439+ 7554 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 7557 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 7559 CD 1A 78     	call	PrintStrClr
 442+ 755C CD B6 77     	call	ReadChar
 443+ 755F FE 79        	cp		'y'
 444+ 7561 C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 7562
 446+ 7562
 447+ 7562              CopyFileCreateNewFile:
 448+ 7562 3A 8B 80     	ld		a, (CopyFileDstDrv)
 449+ 7565 21 8C 80     	ld		hl, CopyFileDstName
 450+ 7568 F5           	push	af
 451+ 7569 E5           	push	hl
 452+ 756A CD EC 73     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 756D E1           	pop		hl
 454+ 756E F1           	pop		af
 455+ 756F CD 74 73     	call	CreateChannel
 456+ 7572 CD 94 73     	call 	BDOSCreateFile
 457+ 7575 3C           	inc  	a						;Cancel if A==$FF
 458+ 7576 C8           	ret		z
 459+ 7577
 460+ 7577              	;Close dest file once created.
 461+ 7577 F5           	push	af
 462+ 7578 CD 9C 73     		call	BDOSCloseFile
 463+ 757B CD 8A 73     		call	DestroyChannel
 464+ 757E F1           	pop		af
 465+ 757F C9           	ret
 466+ 7580
 467+ 7580              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 7580              CopyFileSameDrive:
 469+ 7580              	;Read first file section from SRC.
 470+ 7580 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 471+ 7583 21 80 80     	ld		hl, CopyFileSrcName
 472+ 7586 06 5C        	ld		b, MAX_SECT_BUF
 473+ 7588 CD FF 76     	call	ReadFileSection
 474+ 758B 3A 7E 80     	ld		a, (CopyFileSectCnt)
 475+ 758E B7           	or		a
 476+ 758F C8           	ret		z
 477+ 7590
 478+ 7590              	;Prompt for DST disk change.
 479+ 7590 CD 5E 74     	call	PromptDiskChangeDst
 480+ 7593 3A 4C 73     	ld		a, (RWTSDrive)
 481+ 7596 CD 64 73     	call	BDOSInit
 482+ 7599
 483+ 7599 06 02        	ld		b, 2
 484+ 759B CD 9E 79     	call	ClearNMsgLines
 485+ 759E
 486+ 759E CD 46 75     	call	CopyFileCheckOverwrite
 487+ 75A1 C0           	ret		nz
 488+ 75A2
 489+ 75A2 CD 62 75     	call	CopyFileCreateNewFile
 490+ 75A5 C8           	ret		z
 491+ 75A6
 492+ 75A6              CopyFileSameDriveLoop:
 493+ 75A6 3A 7E 80     	ld		a, (CopyFileSectCnt)
 494+ 75A9 6F           	ld		l, a
 495+ 75AA 26 00        	ld		h, 0
 496+ 75AC 11 3A 80     	ld		de, MsgCopySectors
 497+ 75AF CD 87 6E     	call	Byte2Txt
 498+ 75B2 21 3A 80     	ld		hl, MsgCopySectors
 499+ 75B5 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500+ 75B8 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501+ 75BA CD 1A 78     	call	PrintStrClr
 502+ 75BD
 503+ 75BD 3A 77 80     	ld		a, (CopyFileRes)			;Save read status code.
 504+ 75C0 F5           	push	af
 505+ 75C1 3A 8B 80     		ld		a, (CopyFileDstDrv)
 506+ 75C4 21 8C 80     		ld		hl, CopyFileDstName
 507+ 75C7 CD 24 77     		call	WriteFileSection
 508+ 75CA 3A 77 80     		ld		a, (CopyFileRes)
 509+ 75CD 6F           		ld		l, a
 510+ 75CE F1           	pop		af
 511+ 75CF B5           	or		l
 512+ 75D0 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 513+ 75D1
 514+ 75D1
 515+ 75D1              	;Prompt for SRC disk change.
 516+ 75D1 CD 78 74     	call	PromptDiskChangeSrc
 517+ 75D4 3A 4C 73     	ld		a, (RWTSDrive)
 518+ 75D7 CD 64 73     	call	BDOSInit
 519+ 75DA
 520+ 75DA 06 02        	ld		b, 2
 521+ 75DC CD 9E 79     	call	ClearNMsgLines
 522+ 75DF
 523+ 75DF 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 524+ 75E2 21 80 80     	ld		hl, CopyFileSrcName
 525+ 75E5 06 5C        	ld		b, MAX_SECT_BUF
 526+ 75E7 CD FF 76     	call	ReadFileSection
 527+ 75EA 3A 7E 80     	ld		a, (CopyFileSectCnt)
 528+ 75ED B7           	or		a
 529+ 75EE C8           	ret		z
 530+ 75EF
 531+ 75EF              	;Prompt for DST disk change.
 532+ 75EF CD 5E 74     	call	PromptDiskChangeDst
 533+ 75F2 3A 4C 73     	ld		a, (RWTSDrive)
 534+ 75F5 CD 64 73     	call	BDOSInit
 535+ 75F8
 536+ 75F8 06 02        	ld		b, 2
 537+ 75FA CD 9E 79     	call	ClearNMsgLines
 538+ 75FD
 539+ 75FD 18 A7        	jr		CopyFileSameDriveLoop
 540+ 75FF
 541+ 75FF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 542+ 75FF
 543+ 75FF              CopyFileDualDrive:
 544+ 75FF 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 545+ 7602 EE 03        	xor		%11
 546+ 7604 32 8B 80     	ld		(CopyFileDstDrv), a
 547+ 7607
 548+ 7607 CD 46 75     	call	CopyFileCheckOverwrite
 549+ 760A C0           	ret		nz
 550+ 760B
 551+ 760B CD 62 75     	call	CopyFileCreateNewFile
 552+ 760E C8           	ret		z
 553+ 760F
 554+ 760F              CopyFileDualDriveLoop:
 555+ 760F 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 556+ 7612 21 80 80     	ld		hl, CopyFileSrcName
 557+ 7615 06 5C        	ld		b, MAX_SECT_BUF
 558+ 7617 CD FF 76     	call	ReadFileSection
 559+ 761A 3A 7E 80     	ld		a, (CopyFileSectCnt)
 560+ 761D B7           	or		a
 561+ 761E C8           	ret		z
 562+ 761F
 563+ 761F 3A 7E 80     	ld		a, (CopyFileSectCnt)
 564+ 7622 6F           	ld		l, a
 565+ 7623 26 00        	ld		h, 0
 566+ 7625 11 3A 80     	ld		de, MsgCopySectors
 567+ 7628 CD 87 6E     	call	Byte2Txt
 568+ 762B 21 3A 80     	ld		hl, MsgCopySectors
 569+ 762E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 570+ 7631 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 571+ 7633
 572+ 7633 3A 77 80     	ld		a, (CopyFileRes)
 573+ 7636 F5           	push	af
 574+ 7637 3A 8B 80     		ld		a, (CopyFileDstDrv)
 575+ 763A 21 8C 80     		ld		hl, CopyFileDstName
 576+ 763D CD 24 77     		call	WriteFileSection
 577+ 7640 3A 77 80     		ld		a, (CopyFileRes)
 578+ 7643 6F           		ld		l, a
 579+ 7644 F1           	pop		af
 580+ 7645 B5           	or		l
 581+ 7646 C0           	ret		nz
 582+ 7647
 583+ 7647 18 C6        	jr		CopyFileDualDriveLoop
 584+ 7649
 585+ 7649              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 586+ 7649              CopyFileToCOM:
 587+ 7649 AF           	xor		a
 588+ 764A 32 77 80     	ld		(CopyFileRes), a
 589+ 764D 32 7E 80     	ld		(CopyFileSectCnt), a
 590+ 7650 11 00 00     	ld		de, 0
 591+ 7653 ED 53 7A 80  	ld		(FilePosRead), de
 592+ 7657
 593+ 7657              CopyFileToCOMLoop:
 594+ 7657 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 595+ 765A 21 80 80     	ld		hl, CopyFileSrcName
 596+ 765D 06 5C        	ld		b, MAX_SECT_BUF
 597+ 765F CD FF 76     	call	ReadFileSection
 598+ 7662
 599+ 7662 3A 7E 80     	ld		a, (CopyFileSectCnt)
 600+ 7665 B7           	or		a
 601+ 7666 28 0F        	jr		z, CopyFileToCOMEnd
 602+ 7668
 603+ 7668              	;Send buffer to COM port.
 604+ 7668 21 B5 8E     	ld		hl, FileData
 605+ 766B 47           	ld		b, a					;Sector size is 256.
 606+ 766C 0E 00        	ld		c, 0
 607+ 766E CD 98 7C     	call	SERTB
 608+ 7671
 609+ 7671 3A 77 80     	ld		a, (CopyFileRes)
 610+ 7674 B7           	or		a
 611+ 7675 28 E0        	jr		z, CopyFileToCOMLoop
 612+ 7677
 613+ 7677              CopyFileToCOMEnd:
 614+ 7677              	;Reset read error code, as 1 is returned when file is finished reading.
 615+ 7677 AF           	xor		a
 616+ 7678 32 77 80     	ld		(CopyFileRes), a
 617+ 767B
 618+ 767B C9           	ret
 619+ 767C
 620+ 767C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 621+ 767C              CopyFileFromCOM:
 622+ 767C AF           	xor		a
 623+ 767D 32 77 80     	ld		(CopyFileRes), a
 624+ 7680 11 00 00     	ld		de, 0
 625+ 7683 ED 53 7C 80  	ld		(FilePosWrite), de
 626+ 7687
 627+ 7687              	;Must ask for the new file name and check to not exist.
 628+ 7687 21 5B 7F     	ld		hl, MsgNewFileName
 629+ 768A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 630+ 768D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 631+ 768F CD 1A 78     	call	PrintStrClr
 632+ 7692
 633+ 7692 21 26 7F     	ld		hl, MsgClear
 634+ 7695 11 B5 8E     	ld		de, FileData
 635+ 7698 01 0B 00     	ld		bc, NAMELEN
 636+ 769B ED B0        	ldir
 637+ 769D 3E A0        	ld		a, $80 | ' '
 638+ 769F 12           	ld		(de), a
 639+ 76A0 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 76A3 21 B5 8E     	ld		hl, FileData
 641+ 76A6 CD F2 77     	call	PrintStr
 642+ 76A9
 643+ 76A9 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 644+ 76AC 01 0B 00     	ld		bc, NAMELEN
 645+ 76AF CD 5C 79     	call	ReadString
 646+ 76B2
 647+ 76B2 11 B5 8E     	ld		de, FileData
 648+ 76B5 1A           	ld		a, (de)
 649+ 76B6 FE 20        	cp		' '					;If starting with space, input was canceled.
 650+ 76B8 C8           	ret		z
 651+ 76B9
 652+ 76B9              	;Copy new file name
 653+ 76B9 21 B5 8E     	ld		hl, FileData
 654+ 76BC 11 8C 80     	ld		de, CopyFileDstName
 655+ 76BF 01 0B 00     	ld		bc, NAMELEN
 656+ 76C2 ED B0        	ldir
 657+ 76C4
 658+ 76C4              	;Check if new name doesn't exist already.
 659+ 76C4 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 660+ 76C7 21 8C 80     	ld		hl, CopyFileDstName
 661+ 76CA CD 46 75     	call	CopyFileCheckOverwrite
 662+ 76CD C0           	ret		nz
 663+ 76CE
 664+ 76CE              	;Delete and re-create empty destination file
 665+ 76CE 3A 7F 80     	ld		a, (CopyFileSrcDrv)
 666+ 76D1 21 8C 80     	ld		hl, CopyFileDstName
 667+ 76D4 CD 62 75     	call	CopyFileCreateNewFile
 668+ 76D7 C8           	ret		z
 669+ 76D8
 670+ 76D8              CopyFileFromCOMLoop:
 671+ 76D8 21 B5 8E     	ld		hl, FileData
 672+ 76DB 01 00 5C     	ld		bc, FileDataSize
 673+ 76DE 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 674+ 76E0 CD 65 7C     	call	SERRB				;BC = Number of bytes read from COM
 675+ 76E3 79           	ld		a, c
 676+ 76E4 B0           	or		b
 677+ 76E5 C8           	ret		z
 678+ 76E6
 679+ 76E6              	;If C is not 0, add one more sector.
 680+ 76E6 79           	ld 		a, c
 681+ 76E7 B7           	or		a
 682+ 76E8 28 01        	jr		z, CopyFileFromCOMDontInc
 683+ 76EA 04           	inc		b
 684+ 76EB              CopyFileFromCOMDontInc:
 685+ 76EB 78           	ld		a, b				;Sector size is 256
 686+ 76EC 32 7E 80     	ld		(CopyFileSectCnt), a
 687+ 76EF 3A 8B 80     	ld		a, (CopyFileDstDrv)
 688+ 76F2 21 8C 80     	ld		hl, CopyFileDstName
 689+ 76F5 CD 24 77     	call	WriteFileSection
 690+ 76F8
 691+ 76F8 3A 77 80     	ld		a, (CopyFileRes)
 692+ 76FB B7           	or		a
 693+ 76FC 28 DA        	jr		z, CopyFileFromCOMLoop
 694+ 76FE
 695+ 76FE C9           	ret
 696+ 76FF
 697+ 76FF              ;Reads/Writes disk file portion to/from memory.
 698+ 76FF              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 699+ 76FF              ;This should work with single-drive file copy from one disk to another.
 700+ 76FF              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records, B = max sectors to read
 701+ 76FF              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 702+ 76FF              ;
 703+ 76FF              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 704+ 76FF              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 705+ 76FF              ;Must use sequential read/write. But for the first operation must use random read/write.
 706+ 76FF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 76FF              ReadFileSection:
 708+ 76FF 11 A8 73     	ld		de, BDOSReadFileBlockRandom
 709+ 7702 ED 53 6C 77  	ld		(CopyFileOperAddr1), de
 710+ 7706 11 A0 73     	ld		de, BDOSReadFileBlockSeq
 711+ 7709 ED 53 8B 77  	ld		(CopyFileOperAddr2), de
 712+ 770D 11 7A 80     	ld		de, FilePosRead
 713+ 7710 ED 53 63 77  	ld		(CopyFilePtr), de
 714+ 7714 ED 53 A8 77  	ld		(CopyFilePtr2), de
 715+ 7718
 716+ 7718              	;Limit max sectors to read to leave space for the index too.
 717+ 7718 F5           	push	af
 718+ 7719 78           		ld		a, b
 719+ 771A 32 7E 80     		ld		(CopyFileSectCnt), a
 720+ 771D C5           		push	bc
 721+ 771E D9           		exx
 722+ 771F C1           		pop		bc
 723+ 7720 D9           		exx
 724+ 7721 F1           	pop		af
 725+ 7722 18 19        	jr		ReadWriteFileSection
 726+ 7724
 727+ 7724              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 728+ 7724
 729+ 7724              WriteFileSection:
 730+ 7724 11 AC 73     	ld		de, BDOSWriteFileBlockRandom
 731+ 7727 ED 53 6C 77  	ld		(CopyFileOperAddr1), de
 732+ 772B 11 A4 73     	ld		de, BDOSWriteFileBlockSeq
 733+ 772E ED 53 8B 77  	ld		(CopyFileOperAddr2), de
 734+ 7732 11 7C 80     	ld		de, FilePosWrite
 735+ 7735 ED 53 63 77  	ld		(CopyFilePtr), de
 736+ 7739 ED 53 A8 77  	ld		(CopyFilePtr2), de
 737+ 773D
 738+ 773D
 739+ 773D              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 740+ 773D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 741+ 773D              ReadWriteFileSection:
 742+ 773D CD 74 73     	call	CreateChannel
 743+ 7740 DD 22 75 80  	ld		(CopyFileFCB), ix
 744+ 7744 CD 98 73     	call 	BDOSOpenFile
 745+ 7747 3C           	inc  	a						;Cancel if A==$FF
 746+ 7748 C8           	ret		z
 747+ 7749
 748+ 7749              	;Set DMA initial pointer = FileData
 749+ 7749 DD E5        	push	ix
 750+ 774B 21 B5 8E     		ld		hl, FileData
 751+ 774E DD 21 78 80  		ld		ix, CopyFileDMAAddr
 752+ 7752 DD 75 00     		ld		(ix), l
 753+ 7755 DD 74 01     		ld		(ix+1), h
 754+ 7758 DD 21 B5 8E  		ld		ix, FileData
 755+ 775C CD BA 73     		call 	BDOSSetDMA
 756+ 775F DD E1        	pop		ix
 757+ 7761
 758+ 7761              CopyFilePtr EQU $+2
 759+ 7761              	;Update file pointer using read/write random call.
 760+ 7761 ED 5B 7A 80  	ld		de, (FilePosRead)
 761+ 7765 DD 73 21     	ld		(ix + FCB_R0), e
 762+ 7768 DD 72 22     	ld		(ix + FCB_R1), d
 763+ 776B              CopyFileOperAddr1 EQU $ + 1
 764+ 776B CD A8 73     	call 	BDOSReadFileBlockRandom
 765+ 776E
 766+ 776E 32 77 80     	ld		(CopyFileRes), a
 767+ 7771 B7           	or		a
 768+ 7772 20 22        	jr		nz, ReadWriteFileSectionEnd
 769+ 7774
 770+ 7774 3A 7E 80     	ld		a, (CopyFileSectCnt)
 771+ 7777 47           	ld		b, a
 772+ 7778
 773+ 7778              ReadWriteFileSectionLoop:
 774+ 7778 C5           	push	bc
 775+ 7779 DD 2A 78 80  		ld		ix, (CopyFileDMAAddr)
 776+ 777D CD BA 73     		call 	BDOSSetDMA
 777+ 7780 DD 24        		inc		ixh
 778+ 7782 DD 22 78 80  		ld		(CopyFileDMAAddr), ix
 779+ 7786
 780+ 7786 DD 2A 75 80  		ld		ix, (CopyFileFCB)
 781+ 778A              CopyFileOperAddr2 EQU $ + 1
 782+ 778A CD A0 73     		call 	BDOSReadFileBlockSeq
 783+ 778D 32 77 80     		ld		(CopyFileRes), a
 784+ 7790 C1           	pop		bc
 785+ 7791 B7           	or		a
 786+ 7792 20 02        	jr		nz, ReadWriteFileSectionEnd		;Exit on read/write error.
 787+ 7794 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 788+ 7796
 789+ 7796              ReadWriteFileSectionEnd:
 790+ 7796              	;Update sector count variable with how many sectors were transfered.
 791+ 7796 D9           	exx
 792+ 7797 78           	ld		a, b
 793+ 7798 D9           	exx
 794+ 7799 90           	sub		b							;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 795+ 779A 32 7E 80     	ld		(CopyFileSectCnt), a		;Store the number of sectors actually read.
 796+ 779D
 797+ 779D              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 798+ 779D CD BE 73     	call	BDOSSetRandFilePtr
 799+ 77A0 DD 5E 21     	ld		e, (ix + FCB_R0)
 800+ 77A3 DD 56 22     	ld		d, (ix + FCB_R1)
 801+ 77A6              CopyFilePtr2 EQU $+2
 802+ 77A6 ED 53 7A 80  	ld		(FilePosRead), de
 803+ 77AA
 804+ 77AA CD 9C 73     	call 	BDOSCloseFile
 805+ 77AD CD 8A 73     	call 	DestroyChannel
 806+ 77B0
 807+ 77B0 ED 5B 78 80  	ld		de, (CopyFileDMAAddr)
 808+ 77B4 15           	dec		d
 809+ 77B5 C9           	ret
 810+ 77B6
 811+ 77B6              	ENDIF
 812+ 77B6
# file closed: bdos.asm
1417  77B6              	include "ui.asm"
# file opened: ui.asm
   1+ 77B6              ;UI related functions
   2+ 77B6
   3+ 77B6              	ifndef	_UI_
   4+ 77B6              	define	_UI_
   5+ 77B6
   6+ 77B6              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++77B6              	ifndef	_HCCFG_
   2++77B6 ~            	define	_HCCFG_
   3++77B6 ~
   4++77B6 ~            ;HC specific code, for configuration
   5++77B6 ~
   6++77B6 ~            HC_CFG_PORT			EQU	$7E
   7++77B6 ~            HC_FLOPPY_PORT		EQU 7
   8++77B6 ~
   9++77B6 ~            ;BASIC/CPM ROM selection
  10++77B6 ~            HC_CFG_ROM_BAS		EQU	%0
  11++77B6 ~            HC_CFG_ROM_CPM		EQU	%1
  12++77B6 ~
  13++77B6 ~            ;Address for ROM paging: 0 or $E000
  14++77B6 ~            HC_CFG_ROM_0000		EQU %00
  15++77B6 ~            HC_CFG_ROM_E000		EQU %10
  16++77B6 ~
  17++77B6 ~            ;Cfg. port Enable/Disable
  18++77B6 ~            HC_CFG_PORT_DIS		EQU %000
  19++77B6 ~            HC_CFG_PORT_EN		EQU	%100
  20++77B6 ~
  21++77B6 ~            ;Video memory bank: $4000 or $C000
  22++77B6 ~            HC_CFG_VID_4000		EQU	%0000
  23++77B6 ~            HC_CFG_VID_C000		EQU	%1000
  24++77B6 ~
  25++77B6 ~
  26++77B6 ~            ;Standar BASIC config
  27++77B6 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++77B6 ~            ;Standar CP/M config
  29++77B6 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++77B6 ~
  31++77B6 ~
  32++77B6 ~            HC_VID_BANK0		EQU	$4000
  33++77B6 ~            HC_VID_BANK1		EQU	$C000
  34++77B6 ~
  35++77B6 ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++77B6 ~            ;Info from Rares Atodiresei.
  37++77B6 ~            IsDrive2_80Tracks:
  38++77B6 ~            	IFUSED
  39++77B6 ~            	in	a, (HC_FLOPPY_PORT)
  40++77B6 ~            	and %10
  41++77B6 ~            	ret
  42++77B6 ~            	ENDIF
  43++77B6 ~
  44++77B6              	endif
# file closed: hccfg.asm
   7+ 77B6
   8+ 77B6              COL             EQU 23728
   9+ 77B6              LINE            EQU 23729               ;Coordinates
  10+ 77B6              LineCol			EQU	COL
  11+ 77B6              CODE			EQU 23681               ;Char to print
  12+ 77B6
  13+ 77B6              CPM_FNT         EQU $25AB
  14+ 77B6
  15+ 77B6              PORT_ZX			EQU	$FE
  16+ 77B6
  17+ 77B6              ;COLORS
  18+ 77B6              CLR_BLACK		EQU 0
  19+ 77B6              CLR_BLUE		EQU 1
  20+ 77B6              CLR_RED			EQU 2
  21+ 77B6              CLR_MAGENTA		EQU 3
  22+ 77B6              CLR_GREEN		EQU 4
  23+ 77B6              CLR_CYAN		EQU	5
  24+ 77B6              CLR_YELLOW		EQU	6
  25+ 77B6              CLR_WHITE		EQU	7
  26+ 77B6              CLR_BRIGHT		EQU	%01000000
  27+ 77B6              CLR_FLASH		EQU	%10000000
  28+ 77B6
  29+ 77B6              ;PAPER
  30+ 77B6              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 77B6              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 77B6              PAPER_RED		EQU (CLR_RED << 3)
  33+ 77B6              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 77B6              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 77B6              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 77B6              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 77B6              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 77B6
  39+ 77B6              ;INK
  40+ 77B6              INK_BLACK		EQU CLR_BLACK
  41+ 77B6              INK_BLUE		EQU CLR_BLUE
  42+ 77B6              INK_RED			EQU CLR_RED
  43+ 77B6              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 77B6              INK_GREEN		EQU CLR_GREEN
  45+ 77B6              INK_CYAN		EQU	CLR_CYAN
  46+ 77B6              INK_YELLOW		EQU	CLR_YELLOW
  47+ 77B6              INK_WHITE		EQU	CLR_WHITE
  48+ 77B6
  49+ 77B6
  50+ 77B6              SCR_ATTR_ADDR	EQU 22528
  51+ 77B6              SCR_ADDR		EQU 16384
  52+ 77B6              SCR_PIX_LEN		EQU	6144
  53+ 77B6              SCR_ATTR_LEN	EQU	768
  54+ 77B6              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 77B6              SCR_BYTES_PER_LINE	EQU	32
  56+ 77B6
  57+ 77B6              SCR_COLS		EQU	64
  58+ 77B6              SCR_LINES		EQU 24
  59+ 77B6
  60+ 77B6              ;used for file names list positioning
  61+ 77B6              LST_LINES_CNT	EQU	21
  62+ 77B6              LST_FIRST_LINE	EQU	1
  63+ 77B6              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 77B6              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 77B6              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 77B6              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 77B6              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 77B6              LST_FIRST_COL	EQU	16
  69+ 77B6              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 77B6
  71+ 77B6              ;key codes
  72+ 77B6              KEY_ESC			EQU	7
  73+ 77B6              KEY_LEFT		EQU	8
  74+ 77B6              KEY_RIGHT		EQU	9
  75+ 77B6              KEY_DOWN		EQU	10
  76+ 77B6              KEY_UP			EQU	11
  77+ 77B6              KEY_BACKSP		EQU 12
  78+ 77B6              KEY_ENTER		EQU	13
  79+ 77B6              KEY_CTRL		EQU	14
  80+ 77B6
  81+ 77B6              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 77B6              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 77B6              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 77B6
  85+ 77B6              ;Special formating chars
  86+ 77B6              CHR_CR			EQU	13
  87+ 77B6              CHR_LF			EQU	10
  88+ 77B6              CHR_TAB			EQU	09
  89+ 77B6
  90+ 77B6
  91+ 77B6              ;Semi-graphical chars
  92+ 77B6              ;           UC
  93+ 77B6              ;     UL +H-+--+UR
  94+ 77B6              ;        |  |  |
  95+ 77B6              ;     ML +--+--+MR
  96+ 77B6              ;        V C|  |
  97+ 77B6              ;     LL +--+--+LR
  98+ 77B6              ;           DC
  99+ 77B6              CHR_GRID        EQU 127
 100+ 77B6              CHR_V           EQU	128
 101+ 77B6              CHR_MR          EQU	129
 102+ 77B6              CHR_UR          EQU 130
 103+ 77B6              CHR_DL          EQU 131
 104+ 77B6              CHR_DC          EQU 132
 105+ 77B6              CHR_UC          EQU 133
 106+ 77B6              CHR_ML          EQU 134
 107+ 77B6              CHR_H           EQU 135
 108+ 77B6              CHR_C           EQU 136
 109+ 77B6              CHR_LR          EQU 137
 110+ 77B6              CHR_UL          EQU 138
 111+ 77B6              CHR_FULL        EQU 139
 112+ 77B6              CHR_HALF        EQU 140
 113+ 77B6
 114+ 77B6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 77B6
 116+ 77B6              ;Return read char in A
 117+ 77B6              ReadChar:
 118+ 77B6 CF           	rst 08
 119+ 77B7 1B           	DEFB 27
 120+ 77B8 C9           	ret
 121+ 77B9
 122+ 77B9              ;Checks if a key is pressed
 123+ 77B9              ;Cy=1 if key is pressed
 124+ 77B9              KbdHit:
 125+ 77B9 CF           	rst 08
 126+ 77BA 20           	DEFB 32
 127+ 77BB C9           	ret
 128+ 77BC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 77BC
 130+ 77BC              InitFonts:
 131+ 77BC              	IFUSED
 132+ 77BC                  ;page-in CPM ROM to get fonts
 133+ 77BC F3               di
 134+ 77BD 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 77BF D3 7E            out	(HC_CFG_PORT), a
 136+ 77C1
 137+ 77C1 21 AB 25     	ld		hl, CPM_FNT
 138+ 77C4 11 4D 8B     	ld		de, FontTable
 139+ 77C7 01 68 03     	ld		bc, 872
 140+ 77CA ED B0        	ldir
 141+ 77CC
 142+ 77CC                  ;restore BASIC ROM
 143+ 77CC 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 77CE D3 7E            out	(HC_CFG_PORT), a
 145+ 77D0 FB               ei
 146+ 77D1
 147+ 77D1 C9           	ret
 148+ 77D2              	ENDIF
 149+ 77D2
 150+ 77D2              ClrScr:
 151+ 77D2 2A B1 79     	ld		hl, (CurrScrAddr)
 152+ 77D5 54           	ld		d, h
 153+ 77D6 5D           	ld		e, l
 154+ 77D7 13           	inc		de
 155+ 77D8 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 77DB 36 00        	ld		(hl), 0
 157+ 77DD ED B0        	ldir
 158+ 77DF
 159+ 77DF 23           	inc 	hl
 160+ 77E0 13           	inc		de
 161+ 77E1
 162+ 77E1 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 77E4 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 77E6 ED B0        	ldir
 165+ 77E8
 166+ 77E8              	;also set border color
 167+ 77E8 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 77EA D3 FE        	out		(PORT_ZX), a
 169+ 77EC
 170+ 77EC 3E 45        	ld		a, SCR_DEF_CLR
 171+ 77EE 32 48 5C     	ld		(23624), a
 172+ 77F1 C9           	ret
 173+ 77F2
 174+ 77F2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 77F2              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 77F2              PrintStr:
 177+ 77F2 7E           	ld		a, (hl)
 178+ 77F3 FE 20        	cp		' '
 179+ 77F5 30 02        	jr		nc, GoodChar
 180+ 77F7 3E 3F        	ld		a, '?'
 181+ 77F9              GoodChar:
 182+ 77F9 CB 7F        	bit		7, a
 183+ 77FB CB BF        	res		7, a
 184+ 77FD 32 81 5C     	ld		(CODE), a
 185+ 7800 ED 53 B0 5C  	ld		(LineCol), de
 186+ 7804 08           	ex		af, af'
 187+ 7805 D9           	exx
 188+ 7806 E5           	push	hl
 189+ 7807 CD 1E 79     	call 	PrintChar
 190+ 780A E1           	pop		hl
 191+ 780B D9           	exx
 192+ 780C 08           	ex		af, af'
 193+ 780D C0           	ret		nz
 194+ 780E
 195+ 780E 1C           	inc		e
 196+ 780F 23           	inc		hl
 197+ 7810
 198+ 7810 7B           	ld		a, e
 199+ 7811 FE 40        	cp		64
 200+ 7813 38 DD        	jr		c, PrintStr
 201+ 7815 1E 00        	ld		e, 0
 202+ 7817 14           	inc		d
 203+ 7818
 204+ 7818 18 D8        	jr		PrintStr
 205+ 781A
 206+ 781A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 781A
 208+ 781A              ;IN: HL = string, DE = coords, A = color
 209+ 781A              PrintStrClr:
 210+ 781A 32 46 78     	ld		(StrClr), a
 211+ 781D D5           	push	de
 212+ 781E CD F2 77     		call	PrintStr
 213+ 7821 E1           	pop		hl
 214+ 7822              	;get string len.
 215+ 7822 7B           	ld		a, e
 216+ 7823 95           	sub		l
 217+ 7824 1F           	rra
 218+ 7825 08           	ex		af, af'
 219+ 7826              		;line * 32
 220+ 7826 7C           		ld		a, h
 221+ 7827 17           		rla
 222+ 7828 17           		rla
 223+ 7829 11 00 00     		ld	de, 0
 224+ 782C 17           		rla
 225+ 782D CB 12        		rl	d
 226+ 782F 17           		rla
 227+ 7830 CB 12        		rl	d
 228+ 7832 17           		rla
 229+ 7833 CB 12        		rl	d
 230+ 7835 5F           		ld	e, a
 231+ 7836
 232+ 7836 26 00        		ld		h, 0
 233+ 7838 19           		add		hl, de
 234+ 7839 ED 5B B3 79  		ld		de, (CurrScrAttrAddr)
 235+ 783D 19           		add		hl, de
 236+ 783E 08           	ex		af, af'
 237+ 783F 4F           	ld		c, a
 238+ 7840 06 00        	ld		b, 0
 239+ 7842 54           	ld		d, h
 240+ 7843 5D           	ld		e, l
 241+ 7844 13           	inc 	de
 242+ 7845              StrClr	EQU	$ + 1
 243+ 7845 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 7847 ED B0        	ldir
 245+ 7849 C9           	ret
 246+ 784A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 784A
 248+ 784A              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 784A              DrawLine:
 250+ 784A 32 81 5C     	ld		(CODE), a
 251+ 784D
 252+ 784D 38 04        	jr		c, VertDir
 253+ 784F 3E 1C        	ld		a, $1C
 254+ 7851 18 02        	jr		StoreDir
 255+ 7853              VertDir:
 256+ 7853 3E 14        	ld		a, $14
 257+ 7855              StoreDir:
 258+ 7855 32 65 78     	ld		(LineDir), a
 259+ 7858
 260+ 7858              DrawLineLoop:
 261+ 7858 ED 53 B0 5C  	ld		(LineCol), de
 262+ 785C D5           	push	de
 263+ 785D D9           		exx
 264+ 785E E5           		push	hl
 265+ 785F CD 1E 79     		call 	PrintChar
 266+ 7862 E1           		pop		hl
 267+ 7863 D9           		exx
 268+ 7864 D1           	pop		de
 269+ 7865              LineDir:
 270+ 7865 1C           	inc		e
 271+ 7866 10 F0        	djnz	DrawLineLoop
 272+ 7868
 273+ 7868 C9           	ret
 274+ 7869
 275+ 7869              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 7869
 277+ 7869              DrawHLines:
 278+ 7869 11 00 00     	ld		de, 0
 279+ 786C 06 40        	ld		b, 64
 280+ 786E 3E 87        	ld		a, CHR_H
 281+ 7870 B7           	or		a
 282+ 7871 CD 4A 78     	call	DrawLine
 283+ 7874
 284+ 7874 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 7877 06 40        	ld		b, 64
 286+ 7879 3E 87        	ld		a, CHR_H
 287+ 787B B7           	or		a
 288+ 787C CD 4A 78     	call	DrawLine
 289+ 787F
 290+ 787F 06 04        	ld		b, 4
 291+ 7881 11 10 00     	ld		de, LST_FIRST_COL
 292+ 7884              DrawUpperIntersectLoop:
 293+ 7884 C5           	push	bc
 294+ 7885 D5           	push	de
 295+ 7886 3E 85        		ld		a, CHR_UC
 296+ 7888 CD AA 78     		call	DrawIntersect
 297+ 788B D1           	pop		de
 298+ 788C C1           	pop		bc
 299+ 788D 21 0C 00     	ld		hl, NAMELEN+1
 300+ 7890 19           	add		hl, de
 301+ 7891 EB           	ex		de, hl
 302+ 7892 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 7894
 304+ 7894 06 04        	ld		b, 4
 305+ 7896 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 7899              DrawLowerIntersectLoop:
 307+ 7899 C5           	push	bc
 308+ 789A D5           	push	de
 309+ 789B 3E 84        		ld		a, CHR_DC
 310+ 789D CD AA 78     		call	DrawIntersect
 311+ 78A0 D1           	pop		de
 312+ 78A1 C1           	pop		bc
 313+ 78A2 21 0C 00     	ld		hl, NAMELEN+1
 314+ 78A5 19           	add		hl, de
 315+ 78A6 EB           	ex		de, hl
 316+ 78A7 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 78A9
 318+ 78A9 C9           	ret
 319+ 78AA
 320+ 78AA
 321+ 78AA              DrawIntersect:
 322+ 78AA 21 B0 5C     	ld		hl, LineCol
ui.asm(323): warning: Fake instruction: ld		(hl), de
 323+ 78AD 73 23 72 2B  	ld		(hl), de
 324+ 78B1 32 81 5C     	ld		(CODE), a
 325+ 78B4 E5           	push	hl
 326+ 78B5 CD 1E 79     	call	PrintChar
 327+ 78B8 E1           	pop		hl
 328+ 78B9 34           	inc		(hl)
 329+ 78BA 3E 87        	ld		a, CHR_H
 330+ 78BC 32 81 5C     	ld		(CODE), a
 331+ 78BF CD 1E 79     	call	PrintChar
 332+ 78C2 C9           	ret
 333+ 78C3
 334+ 78C3
 335+ 78C3              DrawVLines:
 336+ 78C3 06 04        	ld		b, 4
 337+ 78C5 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 338+ 78C8              DrawVLinesLoop:
 339+ 78C8 C5           	push 	bc
 340+ 78C9 D5           	push	de
 341+ 78CA 06 15        		ld		b, LST_LINES_CNT
 342+ 78CC 3E 80        		ld		a, CHR_V
 343+ 78CE 37           		scf
 344+ 78CF CD 4A 78     		call	DrawLine
 345+ 78D2 D1           	pop		de
 346+ 78D3 C1           	pop	bc
 347+ 78D4 7B           	ld		a, e
 348+ 78D5 C6 0C        	add		NAMELEN+1
 349+ 78D7 5F           	ld		e, a
 350+ 78D8 10 EE        	djnz	DrawVLinesLoop
 351+ 78DA C9           	ret
 352+ 78DB
 353+ 78DB              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 354+ 78DB
 355+ 78DB              ;IN: A = color mask
 356+ 78DB              DrawCursor:
 357+ 78DB ED 5B 6C 80  	ld	de, (CursorAddr)
 358+ 78DF 06 06        	ld	b, 	(NAMELEN + 1)/2
 359+ 78E1              DrawCursorLoop:
 360+ 78E1 12           	ld	(de), a
 361+ 78E2 13           	inc de
 362+ 78E3 10 FC        	djnz DrawCursorLoop
 363+ 78E5 C9           	ret
 364+ 78E6
 365+ 78E6              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 366+ 78E6
 367+ 78E6              ;IN:	A = file idx.
 368+ 78E6              MoveCursor:
 369+ 78E6              	;File idx / SCR_LINES => cursor line & column
 370+ 78E6 6F           	ld		l, a
 371+ 78E7 26 00        	ld		h, 0
 372+ 78E9 0E 15        	ld		c, LST_LINES_CNT
 373+ 78EB CD C3 6E     	call	Div					;HL = file column, A = line
 374+ 78EE
 375+ 78EE              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 376+ 78EE C6 01        	add		LST_FIRST_LINE
 377+ 78F0
 378+ 78F0
 379+ 78F0 54           	ld d, h
 380+ 78F1 5D           	ld e, l
 381+ 78F2 21 00 00     	ld	hl, 0
 382+ 78F5
 383+ 78F5              	;line*32
 384+ 78F5 17           	rla
 385+ 78F6 17           	rla
 386+ 78F7 17           	rla
 387+ 78F8 17           	rla
 388+ 78F9 CB 14        	rl h
 389+ 78FB 17           	rla
 390+ 78FC CB 14        	rl h
 391+ 78FE 6F           	ld l, a
 392+ 78FF
 393+ 78FF
 394+ 78FF              	;col * 6
 395+ 78FF E5           	push	hl					;save line * 32
 396+ 7900 3E 06        		ld		a, (NAMELEN + 1)/2
 397+ 7902 CD E3 6E     		call	Mul				;HL = column * 12/2
 398+ 7905 D1           	pop		de
 399+ 7906 19           	add		hl, de
 400+ 7907
 401+ 7907 11 08 00     	ld		de, LST_FIRST_COL/2
 402+ 790A ED 4B B3 79  	ld		bc, (CurrScrAttrAddr)
 403+ 790E 19           	add		hl, de
 404+ 790F 09           	add		hl, bc
 405+ 7910
 406+ 7910              	;clear old cursor
 407+ 7910 3E 45        	ld		a, SCR_DEF_CLR
 408+ 7912 CD DB 78     	call	DrawCursor
 409+ 7915
 410+ 7915              	;draw new one
 411+ 7915 22 6C 80     	ld		(CursorAddr), hl
 412+ 7918 3E 60        	ld		a, SCR_SEL_CLR
 413+ 791A CD DB 78     	call	DrawCursor
 414+ 791D
 415+ 791D C9           	ret
 416+ 791E
 417+ 791E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 418+ 791E
 419+ 791E              PrintChar:
 420+ 791E ED 5B B0 5C      ld		de, (LineCol)
 421+ 7922
 422+ 7922                  ;calculate 64 column screen address
 423+ 7922              	;IN: D = line, E = col
 424+ 7922              	;OUT: HL = screen address
 425+ 7922
 426+ 7922 CB 3B            SRL     E                                       ;col = col/2
 427+ 7924 CB 19            RR      C                                       ;mark odd/even column
 428+ 7926 7A               LD      A, D                            ;A = line
 429+ 7927 E6 18            AND 24                                  ;keep only %00011000
 430+ 7929 2A B1 79         ld		hl, (CurrScrAddr)
 431+ 792C B4               OR      h								;add screen start address
 432+ 792D 67               LD      H, A                            ;save H
 433+ 792E 7A               LD      A, D                            ;A = line
 434+ 792F E6 07            AND 7                                   ;keep only %00000111
 435+ 7931 0F               RRCA                                    ;%10000011
 436+ 7932 0F               RRCA                                    ;%11000001
 437+ 7933 0F               RRCA                                    ;%11100000
 438+ 7934 B3               OR      E                                       ;add column
 439+ 7935 6F               LD      L, A                            ;HL = screen address
 440+ 7936
 441+ 7936              PrintChar3:
 442+ 7936                  ;get font address
 443+ 7936 E5               PUSH HL
 444+ 7937 AF                   XOR A
 445+ 7938 67                   LD  H, A
 446+ 7939 3A 81 5C             LD  A, (CODE)
 447+ 793C D6 20                SUB ' '
 448+ 793E 6F                   LD  L, A
 449+ 793F 29                   ADD     HL, HL                  ;char code = char code * 8
 450+ 7940 29                   ADD     HL, HL                  ;i.e. offset into font table
 451+ 7941 29                   ADD     HL, HL
 452+ 7942 11 4D 8B             LD      DE, FontTable             ;get font table
 453+ 7945 19                   ADD     HL, DE
 454+ 7946 EB                   EX      DE, HL                  ;DE = our char font address
 455+ 7947 E1               POP     HL
 456+ 7948
 457+ 7948
 458+ 7948                  ;print a char
 459+ 7948 06 08            LD      B, 8                            ;char height is 8 lines
 460+ 794A              PrintCharLine:
 461+ 794A 1A                   LD      A, (DE)                         ;load char line in A
 462+ 794B
 463+ 794B CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 464+ 794D 20 06                JR  	NZ, NoTurn
 465+ 794F
 466+ 794F 07                   RLCA
 467+ 7950 07                   RLCA
 468+ 7951 07                   RLCA
 469+ 7952 07                   RLCA
 470+ 7953 18 01                JR      Store
 471+ 7955              NoTurn:
 472+ 7955 B6                   OR (HL)
 473+ 7956              Store:
 474+ 7956 77                   LD (HL), A
 475+ 7957
 476+ 7957 13                   INC     DE                                      ;next char line in font table
 477+ 7958 24                   INC     H                                       ;next char line on screen
 478+ 7959 10 EF            DJNZ PrintCharLine                  ;last line of char?
 479+ 795B
 480+ 795B C9               ret
 481+ 795C
 482+ 795C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 483+ 795C
 484+ 795C              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 485+ 795C              ReadString:
 486+ 795C 21 B5 8E     	ld		hl, FileData
 487+ 795F D5           	push	de
 488+ 7960 DD E1        	pop		ix
 489+ 7962
 490+ 7962              ReadStringLoop:
 491+ 7962 D5           	push	de
 492+ 7963 E5           	push	hl
 493+ 7964 CD B6 77     		call ReadChar
 494+ 7967 E1           	pop		hl
 495+ 7968 D1           	pop		de
 496+ 7969
 497+ 7969 FE 0D        	cp	KEY_ENTER
 498+ 796B C8           	ret z
 499+ 796C
 500+ 796C FE 0C        	cp  KEY_BACKSP
 501+ 796E 20 0F        	jr	nz, ReadStrChar
 502+ 7970
 503+ 7970 E5           	push hl
 504+ 7971 01 B6 8E     	ld   bc, FileData+1
 505+ 7974 ED 42        	sbc	 hl, bc
 506+ 7976 E1           	pop  hl
 507+ 7977 38 16        	jr   c, ReadStrPrint
 508+ 7979
 509+ 7979 1B           	dec	de
 510+ 797A 2B           	dec	hl
 511+ 797B 36 20        	ld	(hl), ' '
 512+ 797D 18 10        	jr	ReadStrPrint
 513+ 797F
 514+ 797F              ReadStrChar:
 515+ 797F FE 20        	cp	' '
 516+ 7981 38 DF        	jr	c, ReadStringLoop
 517+ 7983 FE 7F        	cp  127
 518+ 7985 30 DB        	jr	nc, ReadStringLoop
 519+ 7987
 520+ 7987              	;Check end of string and go back if found.
 521+ 7987 46           	ld	b, (hl)
 522+ 7988 CB 78        	bit 7, b
 523+ 798A 20 03        	jr	nz, ReadStrPrint
 524+ 798C
 525+ 798C 77           	ld	(hl), a
 526+ 798D 23           	inc	hl
 527+ 798E 13           	inc	de
 528+ 798F
 529+ 798F              ReadStrPrint:
 530+ 798F E5           	push	hl
 531+ 7990 D5           	push	de
 532+ 7991 21 B5 8E     	ld		hl, FileData
 533+ 7994 DD E5        	push	ix
 534+ 7996 D1           	pop		de
 535+ 7997 CD F2 77     	call	PrintStr
 536+ 799A D1           	pop		de
 537+ 799B E1           	pop		hl
 538+ 799C
 539+ 799C 18 C4        	jr		ReadStringLoop
 540+ 799E
 541+ 799E              ClearNMsgLines:
 542+ 799E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 543+ 79A1              ClearNMsgLinesLoop:
 544+ 79A1 D5           	push	de
 545+ 79A2 C5           	push	bc
 546+ 79A3 21 26 7F     	ld		hl, MsgClear
 547+ 79A6 3E 45        	ld		a, SCR_DEF_CLR
 548+ 79A8 CD 1A 78     	call	PrintStrClr
 549+ 79AB C1           	pop		bc
 550+ 79AC D1           	pop		de
 551+ 79AD 14           	inc		d
 552+ 79AE 10 F1        	djnz	ClearNMsgLinesLoop
 553+ 79B0
 554+ 79B0 C9           	ret
 555+ 79B1
 556+ 79B1 00 40        CurrScrAddr		DEFW	SCR_ADDR
 557+ 79B3 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 558+ 79B5
 559+ 79B5                 	endif
# file closed: ui.asm
1418  79B5              	include "math.asm"
# file opened: math.asm
   1+ 79B5              	ifndef	_MATH_
   2+ 79B5 ~            	define	_MATH_
   3+ 79B5 ~
   4+ 79B5 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 79B5 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 79B5 ~
   7+ 79B5 ~
   8+ 79B5 ~            Word2Txt:
   9+ 79B5 ~            	IFUSED
  10+ 79B5 ~            	push	de
  11+ 79B5 ~            		call	Word2Txt_
  12+ 79B5 ~            	pop		de
  13+ 79B5 ~
  14+ 79B5 ~            	ld		b, 4
  15+ 79B5 ~            	call	StrippLeading0
  16+ 79B5 ~            	ret
  17+ 79B5 ~
  18+ 79B5 ~            Byte2Txt:
  19+ 79B5 ~            	push	de
  20+ 79B5 ~            		call	Byte2Txt_
  21+ 79B5 ~            	pop		de
  22+ 79B5 ~
  23+ 79B5 ~            	ld		b, 2
  24+ 79B5 ~            	call	StrippLeading0
  25+ 79B5 ~            	ret
  26+ 79B5 ~            	ENDIF
  27+ 79B5 ~
  28+ 79B5 ~
  29+ 79B5 ~            StrippLeading0:
  30+ 79B5 ~            	ld		a, (de)
  31+ 79B5 ~            	cp		'1'
  32+ 79B5 ~            	ret		nc
  33+ 79B5 ~
  34+ 79B5 ~            	ld		a, ' '
  35+ 79B5 ~            	ld		(de), a
  36+ 79B5 ~            	inc		de
  37+ 79B5 ~            	djnz	StrippLeading0
  38+ 79B5 ~            	ret
  39+ 79B5 ~
  40+ 79B5 ~
  41+ 79B5 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 79B5 ~            Word2Txt_:
  43+ 79B5 ~            	ld bc, -10000
  44+ 79B5 ~            	call DigitLoop
  45+ 79B5 ~            	ld bc, -1000
  46+ 79B5 ~            	call DigitLoop
  47+ 79B5 ~            Byte2Txt_:
  48+ 79B5 ~            	ld bc, -100
  49+ 79B5 ~            	call DigitLoop
  50+ 79B5 ~            	ld bc, -10
  51+ 79B5 ~            	call DigitLoop
  52+ 79B5 ~            	ld bc, -1
  53+ 79B5 ~
  54+ 79B5 ~            DigitLoop:
  55+ 79B5 ~            	ld	a, '0' - 1
  56+ 79B5 ~            DivNrLoop:
  57+ 79B5 ~            	inc	a			;increase reminder
  58+ 79B5 ~            	add	hl, bc		;substract divizor
  59+ 79B5 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 79B5 ~            	sbc	hl, bc		;nope, restore
  61+ 79B5 ~
  62+ 79B5 ~            	ld (de), a
  63+ 79B5 ~            	inc de
  64+ 79B5 ~            	ret
  65+ 79B5 ~
  66+ 79B5 ~
  67+ 79B5 ~            ;Input: HL = Dividend, C = Divisor
  68+ 79B5 ~            ;Output: HL = Quotient, A = Remainder
  69+ 79B5 ~            ;Warning: doesn't work with divisor >= $80
  70+ 79B5 ~            Div:
  71+ 79B5 ~            	IFUSED
  72+ 79B5 ~            	xor a
  73+ 79B5 ~            	ld b, 16
  74+ 79B5 ~
  75+ 79B5 ~            DivLoop:
  76+ 79B5 ~            	add	hl,hl
  77+ 79B5 ~            	rla
  78+ 79B5 ~            	cp	c
  79+ 79B5 ~            	jr	c, NoSub
  80+ 79B5 ~            	sub	c
  81+ 79B5 ~            	inc	l
  82+ 79B5 ~            NoSub:
  83+ 79B5 ~            	djnz DivLoop
  84+ 79B5 ~
  85+ 79B5 ~            	ret
  86+ 79B5 ~            	ENDIF
  87+ 79B5 ~
  88+ 79B5 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 79B5 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 79B5 ~            Div2:
  91+ 79B5 ~            	ld hl, 0
  92+ 79B5 ~            	ld b, 16
  93+ 79B5 ~            Div2Loop:
  94+ 79B5 ~            	sll c		; unroll 16 times
  95+ 79B5 ~            	rla			; ...
  96+ 79B5 ~            	adc	hl,hl		; ...
  97+ 79B5 ~            	sbc	hl,de		; ...
  98+ 79B5 ~            	jr	nc,$+4		; ...
  99+ 79B5 ~            	add	hl,de		; ...
 100+ 79B5 ~            	dec	c		; ...
 101+ 79B5 ~            	djnz Div2Loop
 102+ 79B5 ~            	ret
 103+ 79B5 ~
 104+ 79B5 ~
 105+ 79B5 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 79B5 ~            ;Output: A:HL = Product
 107+ 79B5 ~            Mul:
 108+ 79B5 ~            	IFUSED
 109+ 79B5 ~            	ld hl, 0
 110+ 79B5 ~            	ld bc, $0700
 111+ 79B5 ~
 112+ 79B5 ~            	add	a, a		; optimised 1st iteration
 113+ 79B5 ~            	jr	nc, MulLoop
 114+ 79B5 ~            	ld	h, d
 115+ 79B5 ~            	ld	l, e
 116+ 79B5 ~
 117+ 79B5 ~            MulLoop:
 118+ 79B5 ~            	add	hl,hl
 119+ 79B5 ~            	rla
 120+ 79B5 ~            	jr	nc, NoAdd
 121+ 79B5 ~            	add	hl,de
 122+ 79B5 ~            	adc	a,c
 123+ 79B5 ~            NoAdd:
 124+ 79B5 ~            	djnz MulLoop
 125+ 79B5 ~
 126+ 79B5 ~            	ret
 127+ 79B5 ~            	ENDIF
 128+ 79B5 ~
 129+ 79B5 ~
 130+ 79B5 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131+ 79B5 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132+ 79B5 ~            Byte2Hex:
 133+ 79B5 ~            	xor	a
 134+ 79B5 ~            	rld
 135+ 79B5 ~            	call	Byte2HexNibble
 136+ 79B5 ~
 137+ 79B5 ~            Byte2HexNibble:
 138+ 79B5 ~            	push	af
 139+ 79B5 ~            	daa
 140+ 79B5 ~            	add		a,$F0
 141+ 79B5 ~            	adc		a,$40
 142+ 79B5 ~
 143+ 79B5 ~            	ld		(de), a
 144+ 79B5 ~            	inc		de
 145+ 79B5 ~
 146+ 79B5 ~            	pop		af
 147+ 79B5 ~            	rld
 148+ 79B5 ~            	ret
 149+ 79B5 ~
 150+ 79B5 ~
 151+ 79B5 ~            Byte2HexHex:
 152+ 79B5 ~            	call	Byte2Hex
 153+ 79B5 ~            	inc		hl
 154+ 79B5 ~            	ld		a, ' '
 155+ 79B5 ~            	ld		(de), a
 156+ 79B5 ~            	inc		de
 157+ 79B5 ~            	ret
 158+ 79B5 ~
 159+ 79B5 ~            Byte2HexChar:
 160+ 79B5 ~            	ld		a, CHAR_CR
 161+ 79B5 ~            	cp		(hl)
 162+ 79B5 ~            	jr		z, Bin2HexLineLoopTextReplace
 163+ 79B5 ~
 164+ 79B5 ~            	ld		a, CHAR_EOF
 165+ 79B5 ~            	cp		(hl)
 166+ 79B5 ~            	jr		nz, Bin2HexLineLoopTextCopy
 167+ 79B5 ~
 168+ 79B5 ~            Bin2HexLineLoopTextReplace:
 169+ 79B5 ~            	ld		a, '.'
 170+ 79B5 ~            	ld		(hl), a
 171+ 79B5 ~
 172+ 79B5 ~            Bin2HexLineLoopTextCopy:
 173+ 79B5 ~            	ldi
 174+ 79B5 ~            	ret
 175+ 79B5 ~
 176+ 79B5 ~
 177+ 79B5 ~            HEX_COLUMNS	EQU	16
 178+ 79B5 ~
 179+ 79B5 ~            Bin2HexLine:
 180+ 79B5 ~            	;Hex part
 181+ 79B5 ~            	ld		b, HEX_COLUMNS
 182+ 79B5 ~            	push	hl
 183+ 79B5 ~            Bin2HexLineLoopHex:
 184+ 79B5 ~            		call	Byte2HexHex
 185+ 79B5 ~
 186+ 79B5 ~            		;Put separator in the middle of hex line.
 187+ 79B5 ~            		ld		a, HEX_COLUMNS/2+1
 188+ 79B5 ~            		cp		b
 189+ 79B5 ~            		jr		nz, Bin2HexLineLoopHexNotHalf
 190+ 79B5 ~            		dec		de
 191+ 79B5 ~            		ld		a, '-'
 192+ 79B5 ~            		ld		(de), a
 193+ 79B5 ~            		inc		de
 194+ 79B5 ~
 195+ 79B5 ~            Bin2HexLineLoopHexNotHalf:
 196+ 79B5 ~            		djnz	Bin2HexLineLoopHex
 197+ 79B5 ~            	pop		hl
 198+ 79B5 ~
 199+ 79B5 ~            	dec		de
 200+ 79B5 ~            	ld		a, '|'
 201+ 79B5 ~            	ld		(de), a
 202+ 79B5 ~            	inc		de
 203+ 79B5 ~
 204+ 79B5 ~            	;String part
 205+ 79B5 ~            	;Ignore CR & EOF
 206+ 79B5 ~            Bin2HexLineText:
 207+ 79B5 ~            	;just to not alter B with LDI, set C to something > 16
 208+ 79B5 ~            	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209+ 79B5 ~            Bin2HexLineLoopText:
 210+ 79B5 ~            	call	Byte2HexChar
 211+ 79B5 ~            	djnz	Bin2HexLineLoopText
 212+ 79B5 ~            	ret
 213+ 79B5 ~
 214+ 79B5 ~
 215+ 79B5 ~            ;Converts binary buffer at HL to hex string at DE
 216+ 79B5 ~            Bin2HexStr:
 217+ 79B5 ~            	;Calculate the number of full lines by dividing BC to 16.
 218+ 79B5 ~            	xor		a
 219+ 79B5 ~
 220+ 79B5 ~            	rr		b
 221+ 79B5 ~            	rr		c
 222+ 79B5 ~            	rra
 223+ 79B5 ~
 224+ 79B5 ~            	rr		b
 225+ 79B5 ~            	rr		c
 226+ 79B5 ~            	rra
 227+ 79B5 ~
 228+ 79B5 ~            	rr		b
 229+ 79B5 ~            	rr		c
 230+ 79B5 ~            	rra
 231+ 79B5 ~
 232+ 79B5 ~            	rr		b
 233+ 79B5 ~            	rr		c
 234+ 79B5 ~            	rra
 235+ 79B5 ~
 236+ 79B5 ~            	rra
 237+ 79B5 ~            	rra
 238+ 79B5 ~            	rra
 239+ 79B5 ~            	rra
 240+ 79B5 ~
 241+ 79B5 ~            	ex		af, af'			;Keep reminder
 242+ 79B5 ~
 243+ 79B5 ~            Bin2HexStrLoop:
 244+ 79B5 ~            	push	bc
 245+ 79B5 ~            		call	Bin2HexLine
 246+ 79B5 ~            	pop		bc
 247+ 79B5 ~
 248+ 79B5 ~            	dec		bc
 249+ 79B5 ~            	ld		a, b
 250+ 79B5 ~            	or		c
 251+ 79B5 ~            	jr		nz, Bin2HexStrLoop
 252+ 79B5 ~
 253+ 79B5 ~            	;Set remaining imcomplete line.
 254+ 79B5 ~            	push	de
 255+ 79B5 ~            	push	hl
 256+ 79B5 ~            		ld		a, ' '
 257+ 79B5 ~            		ld		b, COL_CNT
 258+ 79B5 ~            Bin2HexLineClear:
 259+ 79B5 ~            		ld		(de), a
 260+ 79B5 ~            		inc		de
 261+ 79B5 ~            		djnz	Bin2HexLineClear
 262+ 79B5 ~            	pop		hl
 263+ 79B5 ~            	pop		de
 264+ 79B5 ~
 265+ 79B5 ~            	push	de
 266+ 79B5 ~            	pop		ix
 267+ 79B5 ~            	ld		bc, HEX_COLUMNS*3
 268+ 79B5 ~            	add		ix, bc
 269+ 79B5 ~
 270+ 79B5 ~            	;Write hex and char part
 271+ 79B5 ~            	ex		af, af'
 272+ 79B5 ~            	or		a
 273+ 79B5 ~            	ret		z
 274+ 79B5 ~
 275+ 79B5 ~            	ld		b, a
 276+ 79B5 ~            	ld		c, HEX_COLUMNS*2
 277+ 79B5 ~
 278+ 79B5 ~            Bin2HexLineLoopHex2:
 279+ 79B5 ~            	call	Byte2HexHex
 280+ 79B5 ~            	dec		hl
 281+ 79B5 ~
 282+ 79B5 ~            	push	de
 283+ 79B5 ~            		ld		e, ixl
 284+ 79B5 ~            		ld		d, ixh
 285+ 79B5 ~            		call	Byte2HexChar
 286+ 79B5 ~            	pop		de
 287+ 79B5 ~            	inc		ix
 288+ 79B5 ~            	djnz	Bin2HexLineLoopHex2
 289+ 79B5 ~
 290+ 79B5 ~            	ret
 291+ 79B5 ~
 292+ 79B5              	endif
# file closed: math.asm
1419  79B5              	include "txtview.asm"
# file opened: txtview.asm
   1+ 79B5              	IFNDEF _TXTVIEW_
   2+ 79B5              	DEFINE _TXTVIEW_
   3+ 79B5
   4+ 79B5              LINE_CNT	EQU	23
   5+ 79B5              COL_CNT		EQU	64
   6+ 79B5
   7+ 79B5              CHAR_CR		EQU	$0D
   8+ 79B5              CHAR_LF		EQU	$0A
   9+ 79B5              CHAR_TAB	EQU	$09
  10+ 79B5              CHAR_EOF	EQU	$1A
  11+ 79B5
  12+ 79B5              COORDS		EQU	23728		;Coordinates
  13+ 79B5              SCRLinesDown	EQU PRN_BUF
  14+ 79B5              SCRLinesUp		EQU	SCRLinesDown + LINE_CNT*2
  15+ 79B5
  16+ 79B5
  17+ 79B5              	include "scroll.asm"
# file opened: scroll.asm
   1++79B5              ;Scrolling routines for UP/DOWN
   2++79B5              ;They use 2 tables of pointers of screen cell rows.
   3++79B5              ;One table has addresses in increasing order, for scroll down,
   4++79B5              ;the other in decreasing order, for scroll up, so the same
   5++79B5              ;scroll routine is used in both cases.
   6++79B5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++79B5
   8++79B5              ; Char Down
   9++79B5              ; Adjusts screen address HL to move eight pixels down on the display.
  10++79B5              ; enter: HL = valid screen address
  11++79B5              ; exit : HL = moves one character down
  12++79B5              ; used : AF, HL
  13++79B5              GetCellDown:
  14++79B5 7D           	ld a,l
  15++79B6 C6 20        	add a,$20
  16++79B8 6F           	ld l,a
  17++79B9 D0           	ret nc
  18++79BA 7C           	ld a,h
  19++79BB C6 08        	add a,$08
  20++79BD 67           	ld h,a
  21++79BE C9           	ret
  22++79BF
  23++79BF              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++79BF              ;Fills the two tables with pointers.
  25++79BF              ScrollInit:
  26++79BF 21 00 40     	ld		hl, SCR_ADDR
  27++79C2 06 17        	ld		b, LINE_CNT
  28++79C4 DD 21 00 5B  	ld		ix, SCRLinesDown
  29++79C8
  30++79C8              	;Don't init again if already did it.
  31++79C8 DD 7E 00     	ld		a, (ix)
  32++79CB BD           	cp		l
  33++79CC 20 05        	jr		nz, FillScrLinesLoop
  34++79CE DD 7E 01     	ld		a, (ix+1)
  35++79D1 BC           	cp		h
  36++79D2 C8           	ret		z
  37++79D3
  38++79D3              FillScrLinesLoop:
  39++79D3 DD 75 00     	ld		(ix), l
  40++79D6 DD 74 01     	ld		(ix+1), h
  41++79D9 DD 23        	inc		ix
  42++79DB DD 23        	inc		ix
  43++79DD              	;inc. pointer in destination table (of pointers to lines)
  44++79DD CD B5 79     	call	GetCellDown
  45++79E0 10 F1        	djnz	FillScrLinesLoop
  46++79E2
  47++79E2              	;now fill the table in reverse, every 2 bytes
  48++79E2 DD E5        	push	ix
  49++79E4 E1           	pop		hl
  50++79E5 2B           	dec		hl
  51++79E6 06 17        	ld		b, LINE_CNT
  52++79E8              FillScrLinesRev:
  53++79E8 56           	ld		d, (hl)
  54++79E9 2B           	dec		hl
  55++79EA 5E           	ld		e, (hl)
  56++79EB 2B           	dec		hl
  57++79EC
  58++79EC DD 73 00     	ld		(ix), e
  59++79EF DD 72 01     	ld		(ix+1), d
  60++79F2 DD 23        	inc		ix
  61++79F4 DD 23        	inc		ix
  62++79F6 10 F0        	djnz	FillScrLinesRev
  63++79F8 C9           	ret
  64++79F9
  65++79F9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  66++79F9              ScrollUp:
  67++79F9 21 2E 5B     	ld		hl, SCRLinesUp
  68++79FC 18 03        	jr		Scroll
  69++79FE
  70++79FE              ScrollDown:
  71++79FE 21 00 5B     	ld		hl, SCRLinesDown
  72++7A01
  73++7A01              Scroll:
  74++7A01 22 0F 7A     	ld		(ScrollDownPtrDest), hl
  75++7A04 23           	inc		hl
  76++7A05 23           	inc		hl
  77++7A06 22 12 7A     	ld		(ScrollDownPtrSrc), hl
  78++7A09 0E 16        	ld		c, LINE_CNT - 1
  79++7A0B
  80++7A0B              ScrollDownLoop2:
  81++7A0B 06 04        	ld		b, 4
  82++7A0D              ScrollDownPtrDest	EQU	$ + 2
  83++7A0D ED 5B 00 5B  	ld		de, (SCRLinesDown)
  84++7A11              ScrollDownPtrSrc	EQU	$ + 1
  85++7A11 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  86++7A14
  87++7A14              ScrollDownLoop:					;copy a single char line
  88++7A14 C5           	push	bc
  89++7A15 01 20 00     	ld		bc, 32
  90++7A18 ED B0        	ldir
  91++7A1A 2B           	dec		hl
  92++7A1B 1B           	dec		de
  93++7A1C 24           	inc		h
  94++7A1D 14           	inc		d
  95++7A1E 01 20 00     	ld		bc, 32
  96++7A21 ED B8        	lddr
  97++7A23 23           	inc		hl
  98++7A24 13           	inc		de
  99++7A25 24           	inc		h
 100++7A26 14           	inc		d
 101++7A27 C1           	pop		bc
 102++7A28 10 EA        	djnz	ScrollDownLoop
 103++7A2A
 104++7A2A 0D           	dec		c
 105++7A2B C8           	ret		z
 106++7A2C
 107++7A2C 2A 12 7A     	ld		hl, (ScrollDownPtrSrc)
 108++7A2F 22 0F 7A     	ld		(ScrollDownPtrDest), hl
 109++7A32 23           	inc		hl
 110++7A33 23           	inc		hl
 111++7A34 22 12 7A     	ld		(ScrollDownPtrSrc), hl
 112++7A37 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
  18+ 7A39              	include "math.asm"
# file opened: math.asm
   1++7A39              	ifndef	_MATH_
   2++7A39 ~            	define	_MATH_
   3++7A39 ~
   4++7A39 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++7A39 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6++7A39 ~
   7++7A39 ~
   8++7A39 ~            Word2Txt:
   9++7A39 ~            	IFUSED
  10++7A39 ~            	push	de
  11++7A39 ~            		call	Word2Txt_
  12++7A39 ~            	pop		de
  13++7A39 ~
  14++7A39 ~            	ld		b, 4
  15++7A39 ~            	call	StrippLeading0
  16++7A39 ~            	ret
  17++7A39 ~
  18++7A39 ~            Byte2Txt:
  19++7A39 ~            	push	de
  20++7A39 ~            		call	Byte2Txt_
  21++7A39 ~            	pop		de
  22++7A39 ~
  23++7A39 ~            	ld		b, 2
  24++7A39 ~            	call	StrippLeading0
  25++7A39 ~            	ret
  26++7A39 ~            	ENDIF
  27++7A39 ~
  28++7A39 ~
  29++7A39 ~            StrippLeading0:
  30++7A39 ~            	ld		a, (de)
  31++7A39 ~            	cp		'1'
  32++7A39 ~            	ret		nc
  33++7A39 ~
  34++7A39 ~            	ld		a, ' '
  35++7A39 ~            	ld		(de), a
  36++7A39 ~            	inc		de
  37++7A39 ~            	djnz	StrippLeading0
  38++7A39 ~            	ret
  39++7A39 ~
  40++7A39 ~
  41++7A39 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42++7A39 ~            Word2Txt_:
  43++7A39 ~            	ld bc, -10000
  44++7A39 ~            	call DigitLoop
  45++7A39 ~            	ld bc, -1000
  46++7A39 ~            	call DigitLoop
  47++7A39 ~            Byte2Txt_:
  48++7A39 ~            	ld bc, -100
  49++7A39 ~            	call DigitLoop
  50++7A39 ~            	ld bc, -10
  51++7A39 ~            	call DigitLoop
  52++7A39 ~            	ld bc, -1
  53++7A39 ~
  54++7A39 ~            DigitLoop:
  55++7A39 ~            	ld	a, '0' - 1
  56++7A39 ~            DivNrLoop:
  57++7A39 ~            	inc	a			;increase reminder
  58++7A39 ~            	add	hl, bc		;substract divizor
  59++7A39 ~            	jr	c, DivNrLoop	;still dividing?
  60++7A39 ~            	sbc	hl, bc		;nope, restore
  61++7A39 ~
  62++7A39 ~            	ld (de), a
  63++7A39 ~            	inc de
  64++7A39 ~            	ret
  65++7A39 ~
  66++7A39 ~
  67++7A39 ~            ;Input: HL = Dividend, C = Divisor
  68++7A39 ~            ;Output: HL = Quotient, A = Remainder
  69++7A39 ~            ;Warning: doesn't work with divisor >= $80
  70++7A39 ~            Div:
  71++7A39 ~            	IFUSED
  72++7A39 ~            	xor a
  73++7A39 ~            	ld b, 16
  74++7A39 ~
  75++7A39 ~            DivLoop:
  76++7A39 ~            	add	hl,hl
  77++7A39 ~            	rla
  78++7A39 ~            	cp	c
  79++7A39 ~            	jr	c, NoSub
  80++7A39 ~            	sub	c
  81++7A39 ~            	inc	l
  82++7A39 ~            NoSub:
  83++7A39 ~            	djnz DivLoop
  84++7A39 ~
  85++7A39 ~            	ret
  86++7A39 ~            	ENDIF
  87++7A39 ~
  88++7A39 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++7A39 ~            ;Output: A:C = Quotient, HL = Remainder
  90++7A39 ~            Div2:
  91++7A39 ~            	ld hl, 0
  92++7A39 ~            	ld b, 16
  93++7A39 ~            Div2Loop:
  94++7A39 ~            	sll c		; unroll 16 times
  95++7A39 ~            	rla			; ...
  96++7A39 ~            	adc	hl,hl		; ...
  97++7A39 ~            	sbc	hl,de		; ...
  98++7A39 ~            	jr	nc,$+4		; ...
  99++7A39 ~            	add	hl,de		; ...
 100++7A39 ~            	dec	c		; ...
 101++7A39 ~            	djnz Div2Loop
 102++7A39 ~            	ret
 103++7A39 ~
 104++7A39 ~
 105++7A39 ~            ;Input: A = Multiplier, DE = Multiplicand
 106++7A39 ~            ;Output: A:HL = Product
 107++7A39 ~            Mul:
 108++7A39 ~            	IFUSED
 109++7A39 ~            	ld hl, 0
 110++7A39 ~            	ld bc, $0700
 111++7A39 ~
 112++7A39 ~            	add	a, a		; optimised 1st iteration
 113++7A39 ~            	jr	nc, MulLoop
 114++7A39 ~            	ld	h, d
 115++7A39 ~            	ld	l, e
 116++7A39 ~
 117++7A39 ~            MulLoop:
 118++7A39 ~            	add	hl,hl
 119++7A39 ~            	rla
 120++7A39 ~            	jr	nc, NoAdd
 121++7A39 ~            	add	hl,de
 122++7A39 ~            	adc	a,c
 123++7A39 ~            NoAdd:
 124++7A39 ~            	djnz MulLoop
 125++7A39 ~
 126++7A39 ~            	ret
 127++7A39 ~            	ENDIF
 128++7A39 ~
 129++7A39 ~
 130++7A39 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++7A39 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132++7A39 ~            Byte2Hex:
 133++7A39 ~            	xor	a
 134++7A39 ~            	rld
 135++7A39 ~            	call	Byte2HexNibble
 136++7A39 ~
 137++7A39 ~            Byte2HexNibble:
 138++7A39 ~            	push	af
 139++7A39 ~            	daa
 140++7A39 ~            	add		a,$F0
 141++7A39 ~            	adc		a,$40
 142++7A39 ~
 143++7A39 ~            	ld		(de), a
 144++7A39 ~            	inc		de
 145++7A39 ~
 146++7A39 ~            	pop		af
 147++7A39 ~            	rld
 148++7A39 ~            	ret
 149++7A39 ~
 150++7A39 ~
 151++7A39 ~            Byte2HexHex:
 152++7A39 ~            	call	Byte2Hex
 153++7A39 ~            	inc		hl
 154++7A39 ~            	ld		a, ' '
 155++7A39 ~            	ld		(de), a
 156++7A39 ~            	inc		de
 157++7A39 ~            	ret
 158++7A39 ~
 159++7A39 ~            Byte2HexChar:
 160++7A39 ~            	ld		a, CHAR_CR
 161++7A39 ~            	cp		(hl)
 162++7A39 ~            	jr		z, Bin2HexLineLoopTextReplace
 163++7A39 ~
 164++7A39 ~            	ld		a, CHAR_EOF
 165++7A39 ~            	cp		(hl)
 166++7A39 ~            	jr		nz, Bin2HexLineLoopTextCopy
 167++7A39 ~
 168++7A39 ~            Bin2HexLineLoopTextReplace:
 169++7A39 ~            	ld		a, '.'
 170++7A39 ~            	ld		(hl), a
 171++7A39 ~
 172++7A39 ~            Bin2HexLineLoopTextCopy:
 173++7A39 ~            	ldi
 174++7A39 ~            	ret
 175++7A39 ~
 176++7A39 ~
 177++7A39 ~            HEX_COLUMNS	EQU	16
 178++7A39 ~
 179++7A39 ~            Bin2HexLine:
 180++7A39 ~            	;Hex part
 181++7A39 ~            	ld		b, HEX_COLUMNS
 182++7A39 ~            	push	hl
 183++7A39 ~            Bin2HexLineLoopHex:
 184++7A39 ~            		call	Byte2HexHex
 185++7A39 ~
 186++7A39 ~            		;Put separator in the middle of hex line.
 187++7A39 ~            		ld		a, HEX_COLUMNS/2+1
 188++7A39 ~            		cp		b
 189++7A39 ~            		jr		nz, Bin2HexLineLoopHexNotHalf
 190++7A39 ~            		dec		de
 191++7A39 ~            		ld		a, '-'
 192++7A39 ~            		ld		(de), a
 193++7A39 ~            		inc		de
 194++7A39 ~
 195++7A39 ~            Bin2HexLineLoopHexNotHalf:
 196++7A39 ~            		djnz	Bin2HexLineLoopHex
 197++7A39 ~            	pop		hl
 198++7A39 ~
 199++7A39 ~            	dec		de
 200++7A39 ~            	ld		a, '|'
 201++7A39 ~            	ld		(de), a
 202++7A39 ~            	inc		de
 203++7A39 ~
 204++7A39 ~            	;String part
 205++7A39 ~            	;Ignore CR & EOF
 206++7A39 ~            Bin2HexLineText:
 207++7A39 ~            	;just to not alter B with LDI, set C to something > 16
 208++7A39 ~            	ld		bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 209++7A39 ~            Bin2HexLineLoopText:
 210++7A39 ~            	call	Byte2HexChar
 211++7A39 ~            	djnz	Bin2HexLineLoopText
 212++7A39 ~            	ret
 213++7A39 ~
 214++7A39 ~
 215++7A39 ~            ;Converts binary buffer at HL to hex string at DE
 216++7A39 ~            Bin2HexStr:
 217++7A39 ~            	;Calculate the number of full lines by dividing BC to 16.
 218++7A39 ~            	xor		a
 219++7A39 ~
 220++7A39 ~            	rr		b
 221++7A39 ~            	rr		c
 222++7A39 ~            	rra
 223++7A39 ~
 224++7A39 ~            	rr		b
 225++7A39 ~            	rr		c
 226++7A39 ~            	rra
 227++7A39 ~
 228++7A39 ~            	rr		b
 229++7A39 ~            	rr		c
 230++7A39 ~            	rra
 231++7A39 ~
 232++7A39 ~            	rr		b
 233++7A39 ~            	rr		c
 234++7A39 ~            	rra
 235++7A39 ~
 236++7A39 ~            	rra
 237++7A39 ~            	rra
 238++7A39 ~            	rra
 239++7A39 ~            	rra
 240++7A39 ~
 241++7A39 ~            	ex		af, af'			;Keep reminder
 242++7A39 ~
 243++7A39 ~            Bin2HexStrLoop:
 244++7A39 ~            	push	bc
 245++7A39 ~            		call	Bin2HexLine
 246++7A39 ~            	pop		bc
 247++7A39 ~
 248++7A39 ~            	dec		bc
 249++7A39 ~            	ld		a, b
 250++7A39 ~            	or		c
 251++7A39 ~            	jr		nz, Bin2HexStrLoop
 252++7A39 ~
 253++7A39 ~            	;Set remaining imcomplete line.
 254++7A39 ~            	push	de
 255++7A39 ~            	push	hl
 256++7A39 ~            		ld		a, ' '
 257++7A39 ~            		ld		b, COL_CNT
 258++7A39 ~            Bin2HexLineClear:
 259++7A39 ~            		ld		(de), a
 260++7A39 ~            		inc		de
 261++7A39 ~            		djnz	Bin2HexLineClear
 262++7A39 ~            	pop		hl
 263++7A39 ~            	pop		de
 264++7A39 ~
 265++7A39 ~            	push	de
 266++7A39 ~            	pop		ix
 267++7A39 ~            	ld		bc, HEX_COLUMNS*3
 268++7A39 ~            	add		ix, bc
 269++7A39 ~
 270++7A39 ~            	;Write hex and char part
 271++7A39 ~            	ex		af, af'
 272++7A39 ~            	or		a
 273++7A39 ~            	ret		z
 274++7A39 ~
 275++7A39 ~            	ld		b, a
 276++7A39 ~            	ld		c, HEX_COLUMNS*2
 277++7A39 ~
 278++7A39 ~            Bin2HexLineLoopHex2:
 279++7A39 ~            	call	Byte2HexHex
 280++7A39 ~            	dec		hl
 281++7A39 ~
 282++7A39 ~            	push	de
 283++7A39 ~            		ld		e, ixl
 284++7A39 ~            		ld		d, ixh
 285++7A39 ~            		call	Byte2HexChar
 286++7A39 ~            	pop		de
 287++7A39 ~            	inc		ix
 288++7A39 ~            	djnz	Bin2HexLineLoopHex2
 289++7A39 ~
 290++7A39 ~            	ret
 291++7A39 ~
 292++7A39              	endif
# file closed: math.asm
  19+ 7A39
  20+ 7A39              TextViewer:
  21+ 7A39 CD 2E 7B     	call	TextViewIndex
  22+ 7A3C
  23+ 7A3C 21 00 00     	ld		hl, 0
  24+ 7A3F 22 B0 5C     	ld		(COORDS), hl
  25+ 7A42 CD BF 79     	call	ScrollInit
  26+ 7A45
  27+ 7A45              TextViewerLoop2:
  28+ 7A45              	;Display 23 lines or less.
  29+ 7A45 2A DF 7B     	ld		hl, (LineCount)
  30+ 7A48 01 17 00     	ld		bc, LINE_CNT
  31+ 7A4B B7           	or		a
  32+ 7A4C ED 42        	sbc		hl, bc
  33+ 7A4E 06 17        	ld		b, LINE_CNT
  34+ 7A50 30 04        	jr		nc, MoreThan23LinesInFile
  35+ 7A52 2A DF 7B     	ld		hl, (LineCount)
  36+ 7A55 45           	ld		b, l
  37+ 7A56              MoreThan23LinesInFile:
  38+ 7A56 DD 21 B5 EA  	ld		ix, FileIdx
  39+ 7A5A
  40+ 7A5A              ;Display first screen of text.
  41+ 7A5A              TextViewerLoop:
  42+ 7A5A C5           	push	bc
  43+ 7A5B CD 85 7B     		call	PrintOneLine
  44+ 7A5E DD 23        		inc		ix
  45+ 7A60 DD 23        		inc		ix
  46+ 7A62 DD 23        		inc		ix
  47+ 7A64
  48+ 7A64 ED 5B B0 5C  		ld		de, (COORDS)
  49+ 7A68 14           		inc		d
  50+ 7A69 1E 00        		ld		e, 0
  51+ 7A6B ED 53 B0 5C  		ld		(COORDS), de
  52+ 7A6F C1           	pop		bc
  53+ 7A70 10 E8        	djnz	TextViewerLoop
  54+ 7A72
  55+ 7A72 11 00 00     	ld		de, 0
  56+ 7A75 ED 53 E1 7B  	ld		(FirstLineShown), de
  57+ 7A79
  58+ 7A79 DD 2B        	dec		ix
  59+ 7A7B DD 2B        	dec		ix
  60+ 7A7D DD 2B        	dec		ix
  61+ 7A7F
  62+ 7A7F 2A DF 7B     	ld		hl, (LineCount)
  63+ 7A82 11 01 7C     	ld		de, MsgLineTotal
  64+ 7A85 CD 7C 6E     	call	Word2Txt
  65+ 7A88
  66+ 7A88              TextViewerLoop3:
  67+ 7A88 2A E1 7B     	ld		hl, (FirstLineShown)
  68+ 7A8B 23           	inc		hl
  69+ 7A8C 11 FB 7B     	ld		de, MsgLineNo
  70+ 7A8F CD 7C 6E     	call	Word2Txt
  71+ 7A92
  72+ 7A92 2A 72 80     	ld		hl, (SelFileCache)
  73+ 7A95 11 E9 7B     	ld		de, MsgLineFileName
  74+ 7A98 06 0B        	ld		b, NAMELEN
  75+ 7A9A              TextViewerShowFilename:
  76+ 7A9A 7E           	ld		a, (hl)
  77+ 7A9B E6 7F        	and		$7F
  78+ 7A9D 12           	ld		(de), a
  79+ 7A9E 23           	inc		hl
  80+ 7A9F 13           	inc		de
  81+ 7AA0 10 F8        	djnz	TextViewerShowFilename
  82+ 7AA2
  83+ 7AA2 21 E3 7B     	ld		hl, MsgLine
  84+ 7AA5 11 00 17     	ld		de, LINE_CNT << 8
  85+ 7AA8 3E 60        	ld		a, SCR_SEL_CLR
  86+ 7AAA CD 1A 78     	call	PrintStrClr
  87+ 7AAD
  88+ 7AAD CD B6 77     	call	ReadChar
  89+ 7AB0
  90+ 7AB0 FE 0A        	cp		KEY_DOWN
  91+ 7AB2 28 3A        	jr		z, TextViewerScrollDown
  92+ 7AB4
  93+ 7AB4 FE 0B        	cp		KEY_UP
  94+ 7AB6 28 05        	jr		z, TextViewerScrollUp
  95+ 7AB8
  96+ 7AB8 FE 30        	cp		'0'
  97+ 7ABA C8           	ret		z
  98+ 7ABB
  99+ 7ABB 18 CB        	jr		TextViewerLoop3
 100+ 7ABD
 101+ 7ABD              TextViewerScrollUp:
 102+ 7ABD              	;Do nothing if showing begining of file.
 103+ 7ABD ED 5B E1 7B  	ld		de, (FirstLineShown)
 104+ 7AC1 7A           	ld		a, d
 105+ 7AC2 B3           	or		e
 106+ 7AC3 28 C3        	jr		z, TextViewerLoop3
 107+ 7AC5
 108+ 7AC5 1B           	dec		de
 109+ 7AC6 ED 53 E1 7B  	ld		(FirstLineShown), de
 110+ 7ACA
 111+ 7ACA 7A           	ld		a, d
 112+ 7ACB B3           	or		e
 113+ 7ACC DD 21 B5 EA  	ld		ix, FileIdx
 114+ 7AD0 28 09        	jr		z, TextViewerScrollUp1
 115+ 7AD2
 116+ 7AD2              	;3*FirstLineShown
 117+ 7AD2 3E 03        	ld		a, 3
 118+ 7AD4 CD E3 6E     	call	Mul
 119+ 7AD7 EB           	ex		de, hl
 120+ 7AD8 B7           	or		a
 121+ 7AD9 DD 19        	add		ix, de
 122+ 7ADB
 123+ 7ADB
 124+ 7ADB              TextViewerScrollUp1:
 125+ 7ADB CD F9 79     	call	ScrollUp
 126+ 7ADE ED 5B B0 5C  	ld		de, (COORDS)
 127+ 7AE2 11 00 00     	ld		de, 0
 128+ 7AE5 ED 53 B0 5C  	ld		(COORDS), de
 129+ 7AE9 CD 85 7B     	call	PrintOneLine
 130+ 7AEC
 131+ 7AEC 18 9A        	jr		TextViewerLoop3
 132+ 7AEE
 133+ 7AEE              TextViewerScrollDown:
 134+ 7AEE              	;Exit if reached last line from file.
 135+ 7AEE 2A E1 7B     	ld		hl, (FirstLineShown)
 136+ 7AF1 01 18 00     	ld		bc, LINE_CNT+1
 137+ 7AF4 B7           	or		a
 138+ 7AF5 ED 4A        	adc		hl, bc
 139+ 7AF7 EB           	ex		de, hl
 140+ 7AF8 2A DF 7B     	ld		hl, (LineCount)
 141+ 7AFB B7           	or		a
 142+ 7AFC ED 52        	sbc		hl, de
 143+ 7AFE 38 88        	jr		c, TextViewerLoop3
 144+ 7B00
 145+ 7B00 2A E1 7B     	ld		hl, (FirstLineShown)
 146+ 7B03 23           	inc		hl
 147+ 7B04 22 E1 7B     	ld		(FirstLineShown), hl
 148+ 7B07 01 16 00     	ld		bc, LINE_CNT-1
 149+ 7B0A B7           	or		a
 150+ 7B0B ED 4A        	adc		hl, bc
 151+ 7B0D EB           	ex		de, hl
 152+ 7B0E
 153+ 7B0E              	;(FirstLineShown + 23	) * 3
 154+ 7B0E 3E 03        	ld		a, 3
 155+ 7B10 CD E3 6E     	call	Mul
 156+ 7B13 EB           	ex		de, hl
 157+ 7B14 DD 21 B5 EA  	ld		ix, FileIdx
 158+ 7B18 DD 19        	add		ix, de
 159+ 7B1A
 160+ 7B1A CD FE 79     	call	ScrollDown
 161+ 7B1D ED 5B B0 5C  	ld		de, (COORDS)
 162+ 7B21 11 00 16     	ld		de, (LINE_CNT - 1) << 8
 163+ 7B24 ED 53 B0 5C  	ld		(COORDS), de
 164+ 7B28
 165+ 7B28 CD 85 7B     	call	PrintOneLine
 166+ 7B2B
 167+ 7B2B C3 88 7A     	jp		TextViewerLoop3
 168+ 7B2E
 169+ 7B2E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 170+ 7B2E
 171+ 7B2E              ;Creates line start indexes, with 2 byte address and 1 byte length for each line. Stores total line count.
 172+ 7B2E              ;IN: HL=start address, BC: length
 173+ 7B2E              TextViewIndex:
 174+ 7B2E DD 21 B5 EA  	ld		ix, FileIdx
 175+ 7B32
 176+ 7B32              	;Search for CHAR_EOF, to mark end of buffer there, if found.
 177+ 7B32              	;Save initial length in DE.
 178+ 7B32 E5           	push	hl
 179+ 7B33 C5           		push	bc
 180+ 7B34 3E 1A        			ld		a, CHAR_EOF
 181+ 7B36 ED B1        			cpir
 182+ 7B38
 183+ 7B38 E5           			push	hl
 184+ 7B39 D1           			pop		de				;DE will contain the address of EOF char or end of file.
 185+ 7B3A C1           		pop		bc
 186+ 7B3B E1           	pop		hl
 187+ 7B3C
 188+ 7B3C 1B           	dec		de
 189+ 7B3D ED 53 DD 7B  	ld		(FileEnd), de
 190+ 7B41
 191+ 7B41 11 00 00     	ld		de, 0					;Assume at least one line is shown, even if empty.
 192+ 7B44 ED 53 DF 7B  	ld		(LineCount), de
 193+ 7B48
 194+ 7B48              TextViewIndexLoop:
txtview.asm(195): warning: Fake instruction: ld		(ix), hl
 195+ 7B48 DD 75 00 DD  	ld		(ix), hl
 195+ 7B4C 74 01
 196+ 7B4E
 197+ 7B4E 01 40 00     	ld		bc, COL_CNT			;Search CR char, might be on position 65.
 198+ 7B51 3E 0D        	ld		a, CHAR_CR
 199+ 7B53 ED B1        	cpir
 200+ 7B55
 201+ 7B55 3E 0A        	ld		a, CHR_LF
 202+ 7B57 BE           	cp		(hl)
 203+ 7B58 20 01        	jr		nz, TextViewIndexNoLF
 204+ 7B5A 23           	inc		hl						;Skip LF char.
 205+ 7B5B              TextViewIndexNoLF:
 206+ 7B5B
 207+ 7B5B              	;If line shorter than 64 chars, calculate actual length.
 208+ 7B5B 79           	ld		a, c
 209+ 7B5C B7           	or		a						;if c==0, line was 64 chars
 210+ 7B5D 3E 40        	ld		a, COL_CNT
 211+ 7B5F 28 02        	jr		z, TextViewIndexStoreLineLen
 212+ 7B61 0C           	inc		c						;account for the CR char found.
 213+ 7B62 91           	sub		c
 214+ 7B63
 215+ 7B63              TextViewIndexStoreLineLen:
 216+ 7B63 DD 77 02     	ld		(ix+2), a
 217+ 7B66 ED 5B DF 7B  	ld		de, (LineCount)
 218+ 7B6A 13           	inc		de
 219+ 7B6B ED 53 DF 7B  	ld		(LineCount), de
 220+ 7B6F
 221+ 7B6F              	;Check end of file.
 222+ 7B6F 3E 1A        	ld		a, CHAR_EOF
 223+ 7B71 BE           	cp		(hl)
 224+ 7B72 C8           	ret		z
 225+ 7B73
 226+ 7B73              TextViewerIncrementIndex:
 227+ 7B73              	;Point to the next index position.
 228+ 7B73 DD 23        	inc		ix
 229+ 7B75 DD 23        	inc		ix
 230+ 7B77 DD 23        	inc		ix
 231+ 7B79
 232+ 7B79              TextViewerCheckEnd:
 233+ 7B79 E5           	push	hl
 234+ 7B7A EB           		ex		de, hl
 235+ 7B7B 2A DD 7B     		ld		hl, (FileEnd)
 236+ 7B7E B7           		or		a
 237+ 7B7F ED 52        		sbc		hl, de
 238+ 7B81 E1           	pop		hl
 239+ 7B82 30 C4        	jr		nc, TextViewIndexLoop
 240+ 7B84
 241+ 7B84              TextViewerEnd:
 242+ 7B84 C9           	ret
 243+ 7B85
 244+ 7B85              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7B85              PrintOneLine:
txtview.asm(246): warning: Fake instruction: ld		hl, (ix)
 246+ 7B85 DD 6E 00 DD  	ld		hl, (ix)
 246+ 7B89 66 01
 247+ 7B8B DD 7E 02     	ld		a, (ix+2)
 248+ 7B8E
 249+ 7B8E B7           	or		a
 250+ 7B8F 06 40        	ld		b, COL_CNT
 251+ 7B91 28 34        	jr		z, PrintOneLineCleanLine
 252+ 7B93
 253+ 7B93 47           	ld		b, a
 254+ 7B94              PrintOneLineLoop:
 255+ 7B94 7E           	ld		a, (hl)
 256+ 7B95
 257+ 7B95              	;Put space instead of tab
 258+ 7B95 FE 09        	cp		CHAR_TAB
 259+ 7B97 20 02        	jr		nz, PrintOneLineNotTab
 260+ 7B99 3E 20        	ld		a, ' '
 261+ 7B9B
 262+ 7B9B              PrintOneLineNotTab:
 263+ 7B9B E5           	push	hl
 264+ 7B9C FE 20        		cp	' '
 265+ 7B9E 38 06        		jr	c, PrintCharNotValid
 266+ 7BA0 FE 7F        		cp  127
 267+ 7BA2 30 02        		jr	nc, PrintCharNotValid
 268+ 7BA4
 269+ 7BA4 18 02        		jr	PrintCharValid
 270+ 7BA6              PrintCharNotValid:
 271+ 7BA6 3E 2E        		ld	a, '.'
 272+ 7BA8              PrintCharValid:
 273+ 7BA8 32 81 5C     		ld		(CODE), a
 274+ 7BAB C5           		push	bc
 275+ 7BAC CD 1E 79     			call	PrintChar
 276+ 7BAF C1           		pop		bc
 277+ 7BB0
 278+ 7BB0 ED 5B B0 5C  		ld		de, (COORDS)
 279+ 7BB4 1C           		inc		e
 280+ 7BB5 ED 53 B0 5C  		ld		(COORDS), de
 281+ 7BB9 E1           	pop		hl
 282+ 7BBA 23           	inc		hl
 283+ 7BBB 10 D7        	djnz	PrintOneLineLoop
 284+ 7BBD
 285+ 7BBD              	;Fill rest of line with spaces.
 286+ 7BBD DD 46 02     	ld		b, (ix+2)
 287+ 7BC0 3E 40        	ld		a, COL_CNT
 288+ 7BC2 B8           	cp		b
 289+ 7BC3 C8           	ret		z
 290+ 7BC4
 291+ 7BC4 B7           	or		a
 292+ 7BC5 98           	sbc		b
 293+ 7BC6 47           	ld		b, a
 294+ 7BC7
 295+ 7BC7              PrintOneLineCleanLine:
 296+ 7BC7 3E 20        	ld		a, ' '
 297+ 7BC9 32 81 5C     	ld		(CODE), a
 298+ 7BCC C5           	push	bc
 299+ 7BCD CD 1E 79     		call	PrintChar
 300+ 7BD0 ED 5B B0 5C  		ld		de, (COORDS)
 301+ 7BD4 1C           		inc		e
 302+ 7BD5 ED 53 B0 5C  		ld		(COORDS), de
 303+ 7BD9 C1           	pop		bc
 304+ 7BDA 10 EB        	djnz	PrintOneLineCleanLine
 305+ 7BDC
 306+ 7BDC C9           	ret
 307+ 7BDD
 308+ 7BDD              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 309+ 7BDD
 310+ 7BDD 00 00        FileEnd			DEFW	0
 311+ 7BDF 00 00        LineCount		DEFW	0
 312+ 7BE1 00 00        FirstLineShown	DEFW	0
 313+ 7BE3
 314+ 7BE3 46 69 6C 65  MsgLine			defb	'File: '
 314+ 7BE7 3A 20
 315+ 7BE9 20 20 20 20  MsgLineFileName defb 	'           |'
 315+ 7BED 20 20 20 20
 315+ 7BF1 20 20 20 7C
 316+ 7BF5 4C 69 6E 65  				defb	'Line: '
 316+ 7BF9 3A 20
 317+ 7BFB 20 20 20 20  MsgLineNo		defb	'     /'
 317+ 7BFF 20 2F
 318+ 7C01 20 20 20 20  MsgLineTotal	defb	'     |'
 318+ 7C05 20 7C
 319+ 7C07 20 20 20...  				defs	21, ' '
 320+ 7C1C 7C 30 3A 45  				defb	'|0:Exi', 't' | $80
 320+ 7C20 78 69 F4
 321+ 7C23
 322+ 7C23              	ENDIF
# file closed: txtview.asm
1420  7C23              	include "serial.asm"
# file opened: serial.asm
   1+ 7C23              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7C23              ;They work with 19200 theoretical speed.
   3+ 7C23              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7C23
   5+ 7C23              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7C23              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7C23
   8+ 7C23
   9+ 7C23              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7C23              ; A=1 IF FRAMING ERROR
  11+ 7C23              ; USES BC,D _DOES NOT USE E!_
  12+ 7C23              SERRXI:
  12+ 7C23
  13+ 7C23 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7C26 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 7C28 D3 EF        	OUT	(0EFH),A
  16+ 7C2A
  17+ 7C2A              	; WAIT FOR START
  18+ 7C2A              SERWSL:
  19+ 7C2A 0B           	DEC	BC
  20+ 7C2B AF           	XOR	A
  21+ 7C2C B8           	CP	B
  22+ 7C2D 20 03        	JR	NZ,SERWS
  23+ 7C2F B9           	CP	C
  24+ 7C30 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7C32 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7C34 CB 7F        	BIT	7,A
  27+ 7C36 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 7C38
  29+ 7C38              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 7C38              ; OF BIT 0
  31+ 7C38 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 7C3A 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 7C3C
  34+ 7C3C              ; GET AND SHIFT BITS
  35+ 7C3C              SERRL:
  36+ 7C3C 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7C3E 00           	NOP			; 4 (TIMING)
  38+ 7C3F 00           	NOP			; 4 (TIMING)
  39+ 7C40 00           	NOP			; 4 (TIMING)
  40+ 7C41 DB F7        	IN	A,(0F7H)	; 11
  41+ 7C43 17           	RLA			; 4
  42+ 7C44 CB 1A        	RR	D		; 8
  43+ 7C46 06 0A        	LD	B,CBAUD		; 7
  44+ 7C48 0D           	DEC	C		; 4
  45+ 7C49 20 F1        	JR	NZ,SERRL	; 12
  46+ 7C4B
  47+ 7C4B              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 7C4B              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 7C4B              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 7C4B              ; IDLE UNTIL NEXT START BIT
  51+ 7C4B 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7C4D D3 EF        	OUT	(0EFH),A
  53+ 7C4F
  54+ 7C4F 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7C51              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7C51              SERWIL:
  57+ 7C51 05           	DEC	B
  58+ 7C52 28 0E        	JR	Z,SERRTF
  59+ 7C54 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7C56 CB 7F        	BIT	7,A
  61+ 7C58 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 7C5A
  63+ 7C5A              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 7C5A 7A           	LD	A,D
  65+ 7C5B 2F           	CPL			; INVERT BITS
  66+ 7C5C 57           	LD	D,A
  67+ 7C5D AF           	XOR	A		; 0 = SUCCESS
  68+ 7C5E C9           	RET
  69+ 7C5F
  70+ 7C5F              ; TIMEOUT
  71+ 7C5F              SERRTO:
  72+ 7C5F 3E FF        	LD	A,0FFH
  73+ 7C61 C9           	RET
  74+ 7C62
  75+ 7C62              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7C62              SERRTF:
  77+ 7C62 3E 01        	LD	A,01H
  78+ 7C64 C9           	RET
  79+ 7C65
  80+ 7C65
  81+ 7C65
  82+ 7C65              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7C65              SERRB:
  83+ 7C65
  84+ 7C65              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7C65              ; BITMAPPED OPTIONS IN E:
  86+ 7C65              ; XXXXXXIT
  87+ 7C65              ; I SET = leave Interrupts disabled at exit
  88+ 7C65              ; T SET = return after Timeout
  89+ 7C65              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7C65              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7C65              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7C65 F3           	DI
  93+ 7C66 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 7C67              				; OF RECEIVED BYTES
  95+ 7C67
  96+ 7C67              SERRBL:
  97+ 7C67 C5           	PUSH	BC
  98+ 7C68 CD 23 7C     	CALL	SERRXI
  99+ 7C6B C1           	POP	BC
 100+ 7C6C B7           	OR	A
 101+ 7C6D 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7C6F 72           	LD	(HL),D
 103+ 7C70 23           	INC	HL
 104+ 7C71 0B           	DEC	BC
 105+ 7C72 AF           	XOR	A
 106+ 7C73 B8           	CP	B
 107+ 7C74 20 F1        	JR	NZ,SERRBL
 108+ 7C76 B9           	CP	C
 109+ 7C77 20 EE        	JR	NZ,SERRBL
 110+ 7C79              ; FULL RECEIVE
 111+ 7C79 C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 7C7A
 113+ 7C7A              SERRBX:				; EXIT
 114+ 7C7A CB 4B        	BIT	1,E
 115+ 7C7C C0           	RET	NZ
 116+ 7C7D FB           	EI
 117+ 7C7E C9           	RET
 118+ 7C7F
 119+ 7C7F              SERRBT:
 120+ 7C7F FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7C81 28 04        	JR	Z,SERRBC
 122+ 7C83 CB 43        	BIT	0,E
 123+ 7C85 28 E0        	JR	Z,SERRBL
 124+ 7C87
 125+ 7C87              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 7C87 EB           	EX	DE,HL		; PRESERVE HL
 127+ 7C88 E1           	POP	HL		; GET INITIAL COUNT
 128+ 7C89 37           	SCF
 129+ 7C8A 3F           	CCF
 130+ 7C8B ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7C8D 44           	LD	B,H
 132+ 7C8E 4D           	LD	C,L		; BC = COUNT
 133+ 7C8F EB           	EX	DE,HL		; RESTORE HL
 134+ 7C90
 135+ 7C90 18 E8        	JR	SERRBX
 136+ 7C92
 137+ 7C92              SERRX:
 137+ 7C92
 138+ 7C92              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7C92              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7C92              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7C92 F3           	DI
 142+ 7C93 CD 23 7C     	CALL	SERRXI
 143+ 7C96 FB           	EI
 144+ 7C97 C9           	RET
 145+ 7C98
 146+ 7C98              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 7C98              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 7C98              SERTB:
 148+ 7C98
 149+ 7C98 7E           	LD	A,(HL)
 150+ 7C99 C5           	PUSH	BC
 151+ 7C9A CD A5 7C     		CALL	SERTX
 152+ 7C9D C1           	POP	BC
 153+ 7C9E 23           	INC	HL
 154+ 7C9F 0B           	DEC BC
 155+ 7CA0 78           	LD	A, B
 156+ 7CA1 B1           	OR	C
 157+ 7CA2 20 F4        	JR	NZ, SERTB
 158+ 7CA4 C9           	RET
 159+ 7CA5
 160+ 7CA5              ; SEND CHAR ROUTINE
 161+ 7CA5              SERTX:
 161+ 7CA5
 162+ 7CA5 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7CA6 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 7CA7 F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 7CA8 3E 01        	LD	A,01H
 166+ 7CAA D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 7CAC 1E 20        	LD	E,20H	; PORT MASK
 168+ 7CAE 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 7CB0 3E 01        	LD	A,1
 170+ 7CB2 C3 B9 7C     	JP	SBIT
 171+ 7CB5
 172+ 7CB5 AF           SHLOOP:	XOR	A		; 4
 173+ 7CB6 CB 3A        	SRL	D		; 8
 174+ 7CB8 17           	RLA			; 4
 175+ 7CB9              SBIT:
 176+ 7CB9 B3           	OR	E		; 4
 177+ 7CBA D3 EF        	OUT	(0EFH),A	; 11
 178+ 7CBC 06 0A        	LD	B,CBAUD		; 7
 179+ 7CBE              SBITDL:
 180+ 7CBE 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 7CC0 00           	NOP			; 4 (TIMING)
 182+ 7CC1 0D           	DEC	C		; 4
 183+ 7CC2 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 7CC4              ; STOP BIT
 185+ 7CC4 3E 20        	LD	A,20H
 186+ 7CC6 D3 EF        	OUT	(0EFH),A
 187+ 7CC8 06 0A        	LD	B,CBAUD
 188+ 7CCA 10 FE        STOPL:	DJNZ	STOPL
 189+ 7CCC FB           	EI
 190+ 7CCD C9           	RET
# file closed: serial.asm
1421  7CCE              	include "bas2txt.asm"
# file opened: bas2txt.asm
   1+ 7CCE              	DEVICE	ZXSPECTRUM48
   2+ 7CCE
   3+ 7CCE              CHANS		EQU		23631
   4+ 7CCE              CH_LEN		EQU		5
   5+ 7CCE              CHANNEL		EQU		3
   6+ 7CCE              CHAN_OPEN	EQU		$1601
   7+ 7CCE
   8+ 7CCE              NumMarker	EQU		$0E
   9+ 7CCE
  10+ 7CCE              PO_SEARCH	EQU		$0C41
  11+ 7CCE              TKN_TABLE	EQU		$0095
  12+ 7CCE
  13+ 7CCE
  14+ 7CCE              ;Input: HL=source of program, BC=length of program, DE=text output address
  15+ 7CCE              ;Output: DE=end of text
  16+ 7CCE              BASIC2TXT:
  17+ 7CCE 22 92 7D     	ld		(ProgramStartAddr), hl
  18+ 7CD1 09           	add		hl, bc
  19+ 7CD2 22 94 7D     	ld		(ProgramEndAddr), hl
  20+ 7CD5 ED 53 96 7D  	ld		(DestinationAddr), de
  21+ 7CD9
  22+ 7CD9              	;Open channel.
  23+ 7CD9 3E 03        	LD   A, CHANNEL
  24+ 7CDB CD 01 16     	CALL CHAN_OPEN		;
  25+ 7CDE
  26+ 7CDE              	;modify output routine
  27+ 7CDE 2A 4F 5C     	ld   hl, (CHANS)
  28+ 7CE1 01 0F 00     	ld	 bc, CH_LEN * CHANNEL
  29+ 7CE4 09           	add	 hl, bc
  30+ 7CE5 11 65 7D     	ld   de, OutputFnct
bas2txt.asm(31): warning: Fake instruction: ld   (hl), de
  31+ 7CE8 73 23 72 2B  	ld   (hl), de
  32+ 7CEC
  33+ 7CEC 2A 92 7D     	ld	hl, (ProgramStartAddr)
  34+ 7CEF
  35+ 7CEF              NextLine:
  36+ 7CEF E5           	PUSH HL
  37+ 7CF0 B7           		or	 a
  38+ 7CF1 ED 5B 94 7D  		ld   de, (ProgramEndAddr)
  39+ 7CF5 EB           		ex	de, hl
  40+ 7CF6 ED 52        		SBC  HL,DE
  41+ 7CF8 7C           		LD   A,H
  42+ 7CF9 B5           		OR   L
  43+ 7CFA E1           	POP  HL
  44+ 7CFB C8           	RET  Z				;Return if length == 0.
  45+ 7CFC
  46+ 7CFC              	;Print line number
  47+ 7CFC 3E 20        	ld		a, ' '
  48+ 7CFE CD 83 7D     	call	PrintIt
  49+ 7D01 46           	LD   B,(HL)
  50+ 7D02 23           	INC  HL
  51+ 7D03 4E           	LD   C,(HL)
  52+ 7D04 23           	INC  HL
  53+ 7D05 E5           	PUSH HL
  54+ 7D06 CD 2B 2D     		CALL $2D2B		;STACK_BC
  55+ 7D09 CD E3 2D     		CALL $2DE3		;PRINT_FP
  56+ 7D0C 3E 20        		ld		a, ' '
  57+ 7D0E CD 83 7D     		call	PrintIt
  58+ 7D11 E1           	POP  HL
  59+ 7D12
  60+ 7D12              	;Get line length in BC.
  61+ 7D12 4E           	LD   C,(HL)
  62+ 7D13 23           	INC  HL
  63+ 7D14 46           	LD   B,(HL)
  64+ 7D15 23           	INC  HL
  65+ 7D16
  66+ 7D16              	;Save line end address.
  67+ 7D16 E5           	PUSH HL
  68+ 7D17 09           		ADD  HL,BC
  69+ 7D18 22 90 7D     		LD   (LineEndAddr),HL
  70+ 7D1B E1           	POP  HL
  71+ 7D1C
  72+ 7D1C              GetCharLoop:
  73+ 7D1C              	;Load a char
  74+ 7D1C 7E           	LD   A, (HL)
  75+ 7D1D FE 0D        	CP   CHR_CR
  76+ 7D1F 20 04        	JR   NZ, IsNotCR		; A == CR
  77+ 7D21
  78+ 7D21              	;Print CR and process next line.
  79+ 7D21 23           	INC  HL
  80+ 7D22 D7           	RST  $10			;PRINT_A_1
  81+ 7D23 18 CA        	JR   NextLine
  82+ 7D25
  83+ 7D25              IsNotCR:
  84+ 7D25 FE 2E        	CP   '.'
  85+ 7D27 28 08        	JR   Z, SearchNum	; A == '.'
  86+ 7D29
  87+ 7D29 FE 3A        	CP   ':'
  88+ 7D2B 30 13        	JR   NC, TestSPC1	; A >= ':'
  89+ 7D2D
  90+ 7D2D FE 30        	CP   '0'
  91+ 7D2F 38 0F        	JR   C, TestSPC1	; A < '0'
  92+ 7D31
  93+ 7D31              SearchNum:
  94+ 7D31 44           	LD   B, H
  95+ 7D32 3E 0E        	LD   A, NumMarker
  96+ 7D34 ED B1        	CPIR
  97+ 7D36 CD B4 33     	CALL $33B4			;STACK_NUM
  98+ 7D39 E5           	PUSH HL
  99+ 7D3A CD E3 2D     		CALL $2DE3		;PRINT_FP
 100+ 7D3D E1           	POP  HL
 101+ 7D3E 18 DC        	JR   GetCharLoop
 102+ 7D40
 103+ 7D40              TestSPC1:
 104+ 7D40 FE 20        	CP   ' '
 105+ 7D42 38 02        	JR   C, TestREM		; A < ' '
 106+ 7D44
 107+ 7D44              	;Print char >= ' '
 108+ 7D44 D7           	RST  $10			;PRINT_A_1
 109+ 7D45 7E           	LD   A,(HL)
 110+ 7D46
 111+ 7D46              TestREM:
 112+ 7D46 FE EA        	CP   $EA			;RND token
 113+ 7D48 20 08        	JR   NZ, TestQuote1	; A != RND
 114+ 7D4A
 115+ 7D4A              	;Print CR.
 116+ 7D4A 3E 0D        	LD   A, CHR_CR
 117+ 7D4C D7           	RST  $10			;PRINT_A_1
 118+ 7D4D 2A 90 7D     	LD   HL,(LineEndAddr)	;Ingore chars after REM.
 119+ 7D50 18 9D        	JR   NextLine
 120+ 7D52
 121+ 7D52              TestQuote1:
 122+ 7D52 FE 22        	CP   '"'
 123+ 7D54 20 0C        	JR   NZ, SkipChar	; A != '"'
 124+ 7D56
 125+ 7D56              TestSPC2:
 126+ 7D56 23           	INC  HL
 127+ 7D57 7E           	LD   A,(HL)
 128+ 7D58 FE 20        	CP   ' '
 129+ 7D5A 38 02        	JR   C, TestQuote2	; A < ' '
 130+ 7D5C
 131+ 7D5C              	;Print >= ' '.
 132+ 7D5C D7           	RST  $10			;PRINT_A_1
 133+ 7D5D 7E           	LD   A,(HL)
 134+ 7D5E
 135+ 7D5E              TestQuote2:
 136+ 7D5E FE 22        	CP   '"'
 137+ 7D60 20 F4        	JR   NZ, TestSPC2	; A != '"'
 138+ 7D62
 139+ 7D62              SkipChar:
 140+ 7D62 23           	INC  HL
 141+ 7D63 18 B7        	JR   GetCharLoop
 142+ 7D65
 143+ 7D65              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 144+ 7D65
 145+ 7D65              OutputFnct:
 146+ 7D65 FE A4        	cp	164
 147+ 7D67 38 1A        	jr	c, PrintIt	; A <= 164 ?
 148+ 7D69
 149+ 7D69 D6 A5        	sub		165
 150+ 7D6B 11 95 00     	ld		de, TKN_TABLE
 151+ 7D6E CD 41 0C     	call	PO_SEARCH
 152+ 7D71
 153+ 7D71              NextTokenChar:
 154+ 7D71 1A           	ld		a, (de)
 155+ 7D72 13           	inc		de
 156+ 7D73 CB 7F        	bit		7, a
 157+ 7D75 20 05        	jr		nz, LastChar
 158+ 7D77 CD 83 7D     	call	PrintIt
 159+ 7D7A 18 F5        	jr		NextTokenChar
 160+ 7D7C
 161+ 7D7C              LastChar:
 162+ 7D7C E6 7F        	and		%01111111
 163+ 7D7E CD 83 7D     	call	PrintIt
 164+ 7D81 3E 20        	ld		a, ' '
 165+ 7D83
 166+ 7D83              PrintIt:
 167+ 7D83 D5           	push	de
 168+ 7D84 ED 5B 96 7D  		ld	de, (DestinationAddr)
 169+ 7D88 12           		ld	(de), a
 170+ 7D89 13           		inc	de
 171+ 7D8A ED 53 96 7D  		ld	(DestinationAddr), de
 172+ 7D8E D1           	pop		de
 173+ 7D8F C9           	ret
 174+ 7D90
 175+ 7D90 00 00        LineEndAddr			DEFW 0
 176+ 7D92 00 00        ProgramStartAddr	DEFW 0
 177+ 7D94 00 00        ProgramEndAddr		DEFW 0
 178+ 7D96 00 00        DestinationAddr		DEFW 0
 179+ 7D98
# file closed: bas2txt.asm
1422  7D98
1423  7D98              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1424  7D98 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-21"
1424  7D9C 64 20 32 30
1424  7DA0 32 33 2D 31
1424  7DA4 32 2D 32 31
1425  7DA8 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1425  7DAC 67 65 20 43
1425  7DB0 68 69 72 74
1425  7DB4 6F 61 63 E1
1426  7DB8 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1426  7DBC 72 61 6D 20
1426  7DC0 49 6E 66 6F
1426  7DC4 20 20 20 A0
1427  7DC8 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1427  7DCC 20 49 6E 66
1427  7DD0 6F 20 20 20
1427  7DD4 20 20 20 A0
1428  7DD8 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1428  7DDC 20 49 6E 66
1428  7DE0 6F 20 20 20
1428  7DE4 20 20 20 A0
1429  7DE8 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1429  7DEC 61 67 65 73
1429  7DF0 20 20 20 20
1429  7DF4 20 20 20 A0
1430  7DF8 31 2D 41 3A  BtnBar			DEFM	'1-A:|2-B:|3-View|4-Prop|5-Copy|6-Ren|7-Attr|8-Del|9-Disk|0-Exi', 't' + $80
1430  7DFC 7C 32 2D 42
1430  7E00 3A 7C 33 2D
1430  7E04 56 69 65 77
1430  7E08 7C 34 2D 50
1430  7E0C 72 6F 70 7C
1430  7E10 35 2D 43 6F
1430  7E14 70 79 7C 36
1430  7E18 2D 52 65 6E
1430  7E1C 7C 37 2D 41
1430  7E20 74 74 72 7C
1430  7E24 38 2D 44 65
1430  7E28 6C 7C 39 2D
1430  7E2C 44 69 73 6B
1430  7E30 7C 30 2D 45
1430  7E34 78 69 F4
1431  7E37 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1431  7E3B 46 72 65 65
1431  7E3F 3A 20 20
1432  7E42 41 2F        MsgDriveLet		DEFM	'A', '/'
1433  7E44 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1434  7E47 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1434  7E4B 73 2F 4B 42
1434  7E4F 3A
1435  7E50 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1435  7E54 30 30 30
1436  7E57 45 72 72 6F  MsgErr			DEFM	'Error code '
1436  7E5B 72 20 63 6F
1436  7E5F 64 65 20
1437  7E62 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1438  7E66 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1438  7E6A 69 6E 67 20
1438  7E6E 50 72 6F 67
1438  7E72 72 61 ED
1439  7E75 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1439  7E79 69 6E 67 20
1439  7E7D 53 43 52 45
1439  7E81 45 4E A4
1440  7E84 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1440  7E88 69 6E 67 20
1440  7E8C 43 4F 44 45
1440  7E90 20 28 21 A9
1441  7E94 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1441  7E98 20 4C 65 6E
1441  7E9C 3A
1442  7E9D 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1442  7EA1 30 20 CB
1443  7EA4 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1443  7EA8 69 62 20 20
1443  7EAC 3A
1444  7EAD 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1444  7EB1 48 49 C4
1445  7EB4 54 79 70 65  MsgFileType		DEFM	'Type    :'
1445  7EB8 20 20 20 20
1445  7EBC 3A
1446  7EBD 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1446  7EC1 20 20 20 20
1446  7EC5 20 A0
1447  7EC7 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1447  7ECB 72 61 ED
1448  7ECE 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1448  7ED2 73 20 A0
1449  7ED5 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1449  7ED9 45 4E A4
1450  7EDC 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1450  7EE0 41 72 F2
1451  7EE3 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1451  7EE7 41 72 F2
1452  7EEA 55 6E 74 79  MsgFileTypeText	DEFM	'Untype', 'd' + $80
1452  7EEE 70 65 E4
1453  7EF1 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1453  7EF5 20 20 A0
1454  7EF8 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1454  7EFC 74 68 20 20
1454  7F00 3A
1455  7F01 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1455  7F05 35 20 C2
1456  7F08 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1456  7F0C 74 20 20 20
1456  7F10 3A
1457  7F11 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1457  7F15 35 20 A0
1458  7F18 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1458  7F1C 69 6E 67 20
1458  7F20 68 65 61 64
1458  7F24 65 F2
1459  7F26 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1459  7F2A 20 20 20 20
1459  7F2E 20 20 20 20
1459  7F32 20 20 20 A0
1460  7F36 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1460  7F3A 66 69 6C 65
1460  7F3E 3F 20 79 2F
1460  7F42 EE
1461  7F43 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1461  7F47 52 2F 4F 3F
1461  7F4B 20 79 2F EE
1462  7F4F 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1462  7F53 48 49 44 3F
1462  7F57 20 79 2F EE
1463  7F5B 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1463  7F5F 3F 6E 6F 6E
1463  7F63 65 3D 61 62
1463  7F67 6F 72 74 BA
1464  7F6B 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1464  7F6F 20 6D 65 6E
1464  7F73 75 BA
1465  7F75 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1465  7F79 20 63 6F 70
1465  7F7D 79 20 6D 65
1465  7F81 6E 75 BA
1466  7F84 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1466  7F88 78 69 74 20
1466  7F8C 6D 65 6E F5
1467  7F90
1468  7F90 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1468  7F94 6F 70 79 20
1469  7F98 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1470  7F9C 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1471  7F9E
1472  7F9E 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1472  7FA2 6F 70 79 20
1473  7FA6 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1474  7FAA 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1475  7FAC
1476  7FAC 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1476  7FB0 6F 70 79 20
1477  7FB4 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1477  7FB8 43 4F CD
1478  7FBB
1479  7FBB 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1479  7FBF 6F 70 79 20
1479  7FC3 43 4F 4D 2D
1479  7FC7 3E
1480  7FC8 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1481  7FCA
1482  7FCA 35 2E 20 46  MsgMenuFmt1		DEFM	'5. Format A', ':' | $80
1482  7FCE 6F 72 6D 61
1482  7FD2 74 20 41 BA
1483  7FD6 36 2E 20 46  MsgMenuFmt2		DEFM	'6. Format B', ':' | $80
1483  7FDA 6F 72 6D 61
1483  7FDE 74 20 42 BA
1484  7FE2
1485  7FE2 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1485  7FE6 62 6C 6F 63
1485  7FEA 6B 73 20 6C
1485  7FEE 65 66 F4
1486  7FF1 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1486  7FF5 77 72 69 74
1486  7FF9 65 3F 20 79
1486  7FFD 2F EE
1487  7FFF 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1487  8003 20 6E 61 6D
1487  8007 65 20 65 78
1487  800B 69 73 74 F3
1488  800F 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1488  8013 53 4F 55 52
1488  8017 43 45 20 64
1488  801B 69 73 EB
1489  801E 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1489  8022 44 45 53 54
1489  8026 2E 20 64 69
1489  802A 73 6B A0
1490  802D 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1490  8031 73 20 61 6E
1490  8035 79 20 6B 65
1490  8039 F9
1491  803A 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1491  803E 73 65 63 74
1491  8042 6F 72 73 20
1491  8046 63 6F 70 F9
1492  804A 41 72 65 20  MsgAreYouSure	DEFM	'Are you sure?y/', 'n' | $80
1492  804E 79 6F 75 20
1492  8052 73 75 72 65
1492  8056 3F 79 2F EE
1493  805A 52 65 61 64  MsgFileLoading	DEFM	'Reading file..', '.' | $80
1493  805E 69 6E 67 20
1493  8062 66 69 6C 65
1493  8066 2E 2E AE
1494  8069
1495  8069              	IFNDEF	_REAL_HW_
1496  8069 ~            FontTable:
1497  8069 ~            	incbin "cpmfnt.bin"
1498  8069              	ENDIF
1499  8069              EndCode:
1500  8069
1501  8069              ;Unalocated variables
1502  8069              UnallocStart	EQU		EndCode
1503  8069              FileCnt			EQU		UnallocStart			;File counter, 1B
1504  8069              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1505  8069              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1506  8069              CursorAddr		EQU		SelFile + 1				;2 B
1507  8069              AUCntUsed		EQU		CursorAddr + 2			;2 B
1508  8069              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1509  8069              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1510  8069              CopySelOption	EQU		SelFileCache+2			;1 B
1511  8069
1512  8069              CopyFileFCB		EQU	CopySelOption + 1
1513  8069              CopyFileRes		EQU CopyFileFCB + 2
1514  8069              CopyFileDMAAddr	EQU	CopyFileRes + 1
1515  8069              FilePosRead		EQU	CopyFileDMAAddr + 2
1516  8069              FilePosWrite	EQU	FilePosRead + 2
1517  8069              CopyFileSectCnt EQU FilePosWrite + 2
1518  8069              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1519  8069              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1520  8069              CopyFileDstDrv	EQU CopyFileSrcName + 11
1521  8069              CopyFileDstName	EQU CopyFileDstDrv + 1
1522  8069
1523  8069              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1524  8069              ;FS block list constants
1525  8069              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1526  8069              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1527  8069              UsedBlockListSz		EQU 320 * 2 + 2							;640
1528  8069
1529  8069              	IFDEF	_REAL_HW_
1530  8069              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1531  8069              DataBuf			EQU		FontTable + 872
1532  8069              	ELSE
1533  8069 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1534  8069              	ENDIF
1535  8069
1536  8069              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1537  8069
1538  8069
1539  8069              ;File viewer constants
1540  8069              FileData		EQU		DataBuf
1541  8069              ;File buffer size, without index
1542  8069              FileIdxSize		EQU		5	 * 1024
1543  8069              FileDataSize	EQU		MAX_SECT_RAM * SECT_SZ - FileIdxSize
1544  8069              ;Set a few KB aside for file indexing
1545  8069              FileIdx			EQU		FileData + FileDataSize
1546  8069              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1547  8069
1548  8069
1549  8069              ;Copy buffer size, follows
1550  8069              CopyDiskBuf			EQU DataBuf
1551  8069
1552  8069              ;256 bytes for the stack should be enough.
1553  8069              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1554  8069              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1555  8069              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1556  8069
1557  8069              	DISPLAY "DataBuf: ", /D,DataBuf
1558  8069              	DISPLAY "BinSize: ", /D, EndCode - Start
1559  8069              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1560  8069              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6ECD   NoSub
0x6EC6   DivLoop
0x704B   MAX_RAM_FREE
0x0070   MAX_SECT_RAM
0x1400   FileIdxSize
0x0282   UsedBlockListSz
0x8069   UnallocStart
0x8069   EndCode
0x7E44 X MsgFreeSpaceNo
0x7D7C   LastChar
0x7D71   NextTokenChar
0x7D5E   TestQuote2
0x7D56   TestSPC2
0x7D62   SkipChar
0x7D52   TestQuote1
0x7D46   TestREM
0x7D40   TestSPC1
0x7D31   SearchNum
0x7D25   IsNotCR
0x7D1C   GetCharLoop
0x7D90   LineEndAddr
0x7D83   PrintIt
0x7CEF   NextLine
0x7D65   OutputFnct
0x7D94   ProgramEndAddr
0x7D92   ProgramStartAddr
0x0095   TKN_TABLE
0x0C41   PO_SEARCH
0x000E   NumMarker
0x1601   CHAN_OPEN
0x0003   CHANNEL
0x0005   CH_LEN
0x5C4F   CHANS
0x7CCA   STOPL
0x7CB5   SHLOOP
0x7CB9   SBIT
0x7CBE   SBITDL
0x7CA5   SERTX
0x7C92 X SERRX
0x7C87   SERRBC
0x7C7A   SERRBX
0x7C7F   SERRBT
0x7C67   SERRBL
0x7C54 X SERWI
0x7C62   SERRTF
0x7C51   SERWIL
0x7C3C   SERRL
0x7C5F   SERRTO
0x7C32   SERWS
0x7C2A   SERWSL
0x7C23   SERRXI
0x000A   CBAUD
0x7BA8   PrintCharValid
0x7BA6   PrintCharNotValid
0x7B9B   PrintOneLineNotTab
0x7B94   PrintOneLineLoop
0x7B84 X TextViewerEnd
0x7B79 X TextViewerCheckEnd
0x7B73 X TextViewerIncrementIndex
0x7B63   TextViewIndexStoreLineLen
0x7B5B   TextViewIndexNoLF
0x7B48   TextViewIndexLoop
0x7BDD   FileEnd
0x7ADB   TextViewerScrollUp1
0x7ABD   TextViewerScrollUp
0x7AEE   TextViewerScrollDown
0x7BE3   MsgLine
0x7A9A   TextViewerShowFilename
0x7BE9   MsgLineFileName
0x7BFB   MsgLineNo
0x7A88   TextViewerLoop3
0x7C01   MsgLineTotal
0x7BE1   FirstLineShown
0x7B85   PrintOneLine
0x7A5A   TextViewerLoop
0x7A56   MoreThan23LinesInFile
0x7BDF   LineCount
0x7A45 X TextViewerLoop2
0x7B2E   TextViewIndex
0x7A14   ScrollDownLoop
0x7A0B   ScrollDownLoop2
0x7A12   ScrollDownPtrSrc
0x7A0F   ScrollDownPtrDest
0x79FE   ScrollDown
0x7A01   Scroll
0x79F9   ScrollUp
0x79E8   FillScrLinesRev
0x79D3   FillScrLinesLoop
0x79BF   ScrollInit
0x79B5   GetCellDown
0x5B2E   SCRLinesUp
0x5B00   SCRLinesDown
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A X CHAR_LF
0x0017   LINE_CNT
0x79A1   ClearNMsgLinesLoop
0x798F   ReadStrPrint
0x797F   ReadStrChar
0x7962   ReadStringLoop
0x7956   Store
0x7955   NoTurn
0x794A   PrintCharLine
0x7936 X PrintChar3
0x78E1   DrawCursorLoop
0x78C8   DrawVLinesLoop
0x7899   DrawLowerIntersectLoop
0x78AA   DrawIntersect
0x7884   DrawUpperIntersectLoop
0x7858   DrawLineLoop
0x7865   LineDir
0x7855   StoreDir
0x7853   VertDir
0x784A   DrawLine
0x7846   StrClr
0x77F9   GoodChar
0x79B1   CurrScrAddr
0x8B4D   FontTable
0x008C X CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x0080   CHR_V
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A   CHR_LF
0x000D   CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x7778   ReadWriteFileSectionLoop
0x7796   ReadWriteFileSectionEnd
0x8078   CopyFileDMAAddr
0x8075   CopyFileFCB
0x773D   ReadWriteFileSection
0x77A8   CopyFilePtr2
0x7763   CopyFilePtr
0x778B   CopyFileOperAddr2
0x776C   CopyFileOperAddr1
0x76EB   CopyFileFromCOMDontInc
0x5C00   FileDataSize
0x76D8   CopyFileFromCOMLoop
0x7677   CopyFileToCOMEnd
0x7657   CopyFileToCOMLoop
0x760F   CopyFileDualDriveLoop
0x7724   WriteFileSection
0x803A   MsgCopySectors
0x75A6   CopyFileSameDriveLoop
0x807E   CopyFileSectCnt
0x7562   CopyFileCreateNewFile
0x7FF1   MsgFileOverwrite
0x7546   CopyFileCheckOverwrite
0x767C   CopyFileFromCOM
0x7649   CopyFileToCOM
0x75FF   CopyFileDualDrive
0x7580   CopyFileSameDrive
0x752F   CopyFileNotExit
0x7F75   MsgMenuFileCopy
0x807C   FilePosWrite
0x808C   CopyFileDstName
0x8080   CopyFileSrcName
0x800F   MsgInsertSrcDsk
0x802D   MsgPressAnyKey
0x801E   MsgInsertDstDsk
0x7432 X FileAttribSet
0xEAB5   FileIdx
0x73E0   GetFileSizeMul
0x73E6   GetFileSizeEnd
0x73DE   GetFileSizeOK
0x73BE   BDOSSetRandFilePtr
0x73BA   BDOSSetDMA
0x73AC   BDOSWriteFileBlockRandom
0x73A8   BDOSReadFileBlockRandom
0x73A4   BDOSWriteFileBlockSeq
0x73A0   BDOSReadFileBlockSeq
0x739C   BDOSCloseFile
0x7398   BDOSOpenFile
0x7394   BDOSCreateFile
0x738A   DestroyChannel
0x7374   CreateChannel
0x7374 X BDOSCloseDrives
0x7370 X BDOSGetDiskRO
0x7370 X BDOSMakeDiskRO
0x73B0   BDOS
0x7362 X PrmIntrlvTbl
0x7361 X PrmSpinUp
0x7360 X PrmHeadLoad
0x735E X PrmDevType
0x0004   PrmFastFactor
0x7359 X RWTSResTmp
0x7358 X RWTSResVolNo
0x735E   BasPrmTbl
0x7354 X RWTSPrmTbl
0x7352 X RWTSExtBuf
0x734F X RWTSSector
0x734D X RWTSVolNo
0x734B X RWTSBlockType
0x7342   CopyMsg
0x7336   SearchMsgEnd
0x733F   SaveMsg
0x732D   IF1Paged
0x72FB   IF1Call
0x72F6   IsFileHeaderValidLoop
0x73C2   GetFileSize
0x72DA   ReadFileHeaderIsTextFile
0x72F3   IsFileHeaderValid
0x72EF   ReadHeaderEnd
0x7294   CacheNotFinished
0x7289 X SeekTrack
0x723E   FileReadLoop
0x7232 X FileLoadHeader
0x7244   FileLoadNoHeader
0x7252   FileFree
0x720E   MisMatch
0x7206   Compare
0x7204   StrCmp
0x71BB   CopyDiskFromCOMLoop
0x7C65   SERRB
0x7157   CopyDiskToCOMLoop
0x7C98   SERTB
0x7478   PromptDiskChangeSrc
0x712F   CopyDiskDualDrive2
0x713C   CopyDiskEnd
0x710B X CopyDiskWriteEnd
0x70F4   CopyDiskLoopWriteLoop
0x70ED   CopyDiskReadEnd
0x745E   PromptDiskChangeDst
0x70E3   CopyDiskDualDrive1
0x70BA   CopyDiskLoopReadLoop
0x8EB5   CopyDiskBuf
0x70B3   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7FE2   MsgBlocksLeft
0x7090   CopyDiskLoop
0x88CD   UsedBlockListBlk
0x726A   WriteDiskSectors
0x707C   WriteFSBlock
0x7257   ReadDiskSectors
0x706F   ReadFSBlock
0x7061   ReadUsedBlocksSkip
0x7044   ReadUsedBlocksLoop2
0x7064   ReadUsedBlocksSkip2
0x7034   ReadUsedBlocksLoop
0x88CB   UsedBlockListCnt
0x7016   ReadUsedBlocksList
0x700F   CheckAUEnd
0x6FFB   CheckAU
0x6FE4   FirstAU
0x6FDE   Track0
0x6FC9   AU2TS
0x6FAD   WriteOneDiskSector
0x734E   RWTSTrack
0x7350   RWTSDMA
0x734B   RWTSParams
0x7356   RWTSCmd
0x6F96   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0004   TEXT_TYPE
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6F81   Bin2HexLineLoopHex2
0x6F6D   Bin2HexLineClear
0x0040   COL_CNT
0x6F5D   Bin2HexStrLoop
0x6F3D   Bin2HexLineLoopText
0x6F3A X Bin2HexLineText
0x6F32   Bin2HexLineLoopHexNotHalf
0x6F25   Bin2HexLineLoopHex
0x6F22   Bin2HexLine
0x0010   HEX_COLUMNS
0x6F1F   Bin2HexLineLoopTextCopy
0x6F1C   Bin2HexLineLoopTextReplace
0x6F12   Byte2HexChar
0x6F09   Byte2HexHex
0x6EFD   Byte2HexNibble
0x6EF7   Byte2Hex
0x6EF4   NoAdd
0x6EEE   MulLoop
0x6ED5   Div2Loop
0x6ED0 X Div2
0x6EC3   Div
0x6EBA   DivNrLoop
0x6EB8   DigitLoop
0x6EA9   Byte2Txt_
0x6E92   StrippLeading0
0x6E9D   Word2Txt_
0x6E7C X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x6E79   DontInc
0x6E73   ReadAllHeadersEnd
0x6E5E   AKey
0x77B9   KbdHit
0x6E43   NextFile
0x7EF8   MsgFileLen
0x7EB4   MsgFileType
0x7F08   MsgFileStart
0x6E02   PrintStartStr
0x7F11   MsgFileStartN
0x7EF1   MsgNA
0x6DF4   PrintStart
0x0007   HDR_LINE
0x6DCF   PrintByteStart
0x6DC7   PrintProgStart
0x7F01   MsgFileLenN
0x6DAD X PrepFileLenText
0x7EEA   MsgFileTypeText
0x7ECE   MsgFileTypeByte
0x7ED5   MsgFileTypeSCR
0x6D93   NotScr
0x6D9E   CheckText
0x7EDC   MsgFileTypeChrA
0x6D76   CheckByte
0x0002   CHAR_TYPE
0x7EE3   MsgFileTypeNoA
0x6D67   CheckChrArr
0x0001   NUMB_TYPE
0x6DA7   PrepFileLen
0x735F X PrmStepRate
0x6E20   MoveMsg
0x7EBD   MsgFileTypeN
0x7EC7   MsgFileTypePrg
0x6D58   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6DD7   HeadNotRead
0x7EA4   MsgFileAttr
0x6D29   AttrEnd
0x6D1D   NotSYS
0x6D09   CheckSys
0x6CF7   NotRO
0x0008   RO_POS
0x0000   CACHE_NAME
0x6DE9   PrintStartNotRead
0x7E94   MsgFileSzDsk
0x7E9D   MsgFileSzDskN
0x7A39   TextViewer
0x5CED   HD11
0x001A   CHAR_EOF
0x7D96   DestinationAddr
0x7CCE   BASIC2TXT
0x0005   HDR_PLEN
0x000D   CHAR_CR
0x6F43   Bin2HexStr
0x6C58   LogicalLenIsBiggerThanRead
0x6CA9   ViewFileAsText
0x6C1D   ViewFileWithHeader
0x76FF   ReadFileSection
0x005C   MAX_SECT_BUF
0x807A   FilePosRead
0x6C28   ViewBytesFile
0x6C6A   ViewProgramFile
0x805A   MsgFileLoading
0x7EAD   MsgFileAttrN
0x0003 X ViewFileConvertRatioASM
0x0004   ViewFileConvertRatioHEX
0x0003   ViewFileConvertRatioBASIC
0x0001   ViewFileConvertRatioText
0x7301   LoadProgram
0x807F   CopyFileSrcDrv
0x7E66   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7E75   MsgLoadingSCR
0x0003   HDR_ADDR
0x7257   IF1FileLoadEnd
0x5B00   PRN_BUF
0x7211   IF1FileLoad
0x7E84   MsgLoadingCODE
0x6B80 X HandleFileCODE
0x6BA6   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6BD4   HandleFileText
0x0003   BYTE_TYPE
0x6BC4   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6B4A   FindExtEnd
0x7289   FindCache
0x6B59   GetFileNamesEnd
0x0009   HDR_SZ
0x6B25   FindExt
0x000C   EXT_IDX
0x6FE7   CheckExtAlloc
0x6B4C   NextExt
0x0000   EXT_DEL_FLAG
0x6AD4   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x6AB1   DisplayFilenamesLoop
0x6A97   LineOK
0x5CB1   LINE
0x5CB0   COL
0x791E   PrintChar
0x5C81   CODE
0x6A71   DispLoop
0x6A6F   DisplayFilename
0x78E6   MoveCursor
0x6FB8   FormatDisk
0x804A   MsgAreYouSure
0x6A17   FormatDiskAction
0x6A0A   CheckDiskMenuFormat2
0x719E   CopyDiskFromCOM
0x69FB   CheckDiskMenuFormat1
0x7142   CopyDiskToCOM
0x69F1   CheckDiskMenuFromCOM
0x69E8   CheckDiskMenuToCOM
0x7089   CopyDisk
0x69DA   CheckDiskMenuDualDrive
0x6A5E   DiskMenuExit
0x69C6 X CheckKeyDiskMenuLoop
0x7FD6   MsgMenuFmt2
0x7FCA   MsgMenuFmt1
0x7FBB   MsgMenuFromCOM
0x7FAC   MsgMenuToCOM
0x7F9E   MsgMenuDual
0x7F90   MsgMenuSingle
0x7F84   MsgMenuBack
0x7F6B   MsgMenuDiskCopy
0x7FAA   MsgMenuDualDrv2
0x7FC8   MsgMenuFromCOMDrv
0x7FB4   MsgMenuToComDrv
0x7FA6   MsgMenuDualDrv1
0x7F9C   MsgMenuSingleDrv2
0x7F98   MsgMenuSingleDrv1
0x6A61   CheckKeyExit
0x7411   ChangeFileAttrib
0x6939   AttrChange
0x7F4F   MsgSetSYS
0x6921   CheckSYS
0x7F43   MsgSetRO
0x694B   CheckKeyDiskMenu
0x73EC   DeleteFile
0x68F3   DoFileDelete
0x7F36   MsgDelete
0x6900   CheckKeyAttrib
0x743B   RenameFile
0x7FFF   MsgFileExists
0x68BA   RenameFileNotExist
0x73F8   DoesFileExist
0x68C6   RenameCanceled
0x795C   ReadString
0x000B   NAMELEN
0x7F26   MsgClear
0x7F5B   MsgNewFileName
0x68CE   CheckKeyDel
0x6BD5   ViewFile
0x685E   CheckKeyRename
0x0001   DRIVE_B_CPM
0x684D   CheckKeyView
0x6942   SelectDrive
0x6844   CheckKeyDriveB
0x6E26   ReadAllHeaders
0x683B   CheckKeyDriveA
0x808B   CopyFileDstDrv
0x8074   CopySelOption
0x6810   CopyFileOK
0x8077   CopyFileRes
0x7492   CopyFile
0x682A   CheckKeyFileInfo
0x799E   ClearNMsgLines
0x729A   ReadFileHeader
0x7F18   MsgReadingExt
0x67DE   CheckKeyCopy
0x6B5A   HandleFile
0x67B9   CheckKeyInfo
0x67B3   DoKeyEnter
0x000D   KEY_ENTER
0x67AA   CheckEnter
0x679D   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x6795   CheckLeft
0x6783   DoKeyRight
0x0009   KEY_RIGHT
0x677B   CheckRight
0x676E   DoKeyUp
0x000B   KEY_UP
0x6A69   MoveIt
0x6766   CheckUp
0x6755   DoKeyDown
0x000A   KEY_DOWN
0x6CB4   DisplayFileInfo
0x8072   SelFileCache
0x6EE3   Mul
0x6733   CalcFileCache
0x7E47   MsgFilesCnt
0x8069   FileCnt
0x7E50   MsgFilesCntNo
0x7E37   MsgDrive
0x6E7C   Word2Txt
0x7E42   MsgDriveLet
0x806E   AUCntUsed
0x731A   SetFastKeys
0x78DB   DrawCursor
0x0060   SCR_SEL_CLR
0x7DE8   MsgMessages
0x0007   LST_FILE_INFO
0x7DD8   MsgFileInf
0x0004   LST_DISK_INFO
0x7DC8   MsgDskInf
0x7DB8   MsgSysInf
0x7DF8   BtnBar
0x0060   SCR_LBL_CLR
0x7DA8   VerMsg2
0x77F2   PrintStr
0x0001   LST_PROG_INFO
0x7D98   VerMsg1
0x7869   DrawHLines
0x78C3   DrawVLines
0x806C   CursorAddr
0x79B3   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x77D2   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x806A   NameCol
0x0010   LST_FIRST_COL
0x806B   SelFile
0x77B6   ReadChar
0x8EB5   DataBuf
0x7325   GetErrMsg
0x5C3A   ERRNR
0x6616   HCRunEnd
0x6744   ReadKeyLoop
0x66D1   DisplayDiskInfo
0x6AA1   DisplayFilenames
0x6653   InitUI
0x660A   HCRunMain
0x6AC1   GetFileNames
0x781A   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7E57   MsgErr
0x6E87   Byte2Txt
0x7E62   MsgErrCode
0x6607   HCRunCacheFiles
0x727D   ReadCatalogTrack
0x8070   AUCntMaxFree
0x65E4   DriveIs80Tracks
0x7BC7   PrintOneLineCleanLine
0x013E   MAX_FREE_AU_CNT
0x7357   RWTSRes
0x6FA2   ReadOneDiskSector
0x8EB5   FileData
0x0050   TRACK_CNT
0x7367   BDOSSelectDisk
0x734C   RWTSDrive
0x7364   BDOSInit
0x0000   DRIVE_A_CPM
0x65C5   DetectTrackCount
0x7370   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x8097   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8EB5   TrackBuf
0x65A2   HCRunInitDisk
0x661E   ErrorHandler
0x5C3D   ERRSP
0x6F93   IF1Init
0x77BC   InitFonts
0x6590   Start
