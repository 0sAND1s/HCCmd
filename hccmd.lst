# file opened: hccmd.asm
   1  0000
   2  0000
   3  0000              ;Define bellow is commented out to include the font binary in RAM, to make it work with Spectaculator HC-2000 emulator, which doesn't seem to implement the paging.
   4  0000              ;If not commented out, it will use the font table in the CPM ROM and the binary will be smaller.
   5  0000              	;DEFINE  _REAL_HW_
   6  0000
   7  0000              ;When inserting IF1 variables, our program moves, corrupting our code.
   8  0000              ;So we have to put our code after the program as loaded in RAM.
   9  0000              	ORG 25000
  10  61A8
  11  61A8              Start:
  12  61A8              	IFDEF _REAL_HW_				;If using the fonts from the CP/M ROM, must copy font table to buffer.
  13  61A8 CD 2C 74     		call InitFonts
  14  61AB              	ENDIF
  15  61AB CD 08 6C     	call IF1Init
  16  61AE
  17  61AE              	;install error handler
  18  61AE 2A 3D 5C     	ld		hl, (ERRSP)
  19  61B1 E5           	push	hl
  20  61B2 21 36 62     	ld		hl, ErrorHandler
  21  61B5 E5           	push	hl
  22  61B6 ED 73 3D 5C  	ld		(ERRSP), sp
  23  61BA
  24  61BA              HCRunInitDisk:
  25  61BA              	;Set track buffer to del marker
  26  61BA 21 D8 8B     	ld		hl, TrackBuf
  27  61BD 54           	ld		d, h
  28  61BE 5D           	ld		e, l
  29  61BF 13           	inc		de
  30  61C0 01 00 10     	ld		bc, SPT*SECT_SZ
  31  61C3 36 E5        	ld		(hl), DEL_MARKER
  32  61C5 ED B0        	ldir
  33  61C7
  34  61C7              	;Invalidate file cache
  35  61C7 21 BA 7D     	ld		hl, FileCache
  36  61CA 54           	ld		d, h
  37  61CB 5D           	ld		e, l
  38  61CC 13           	inc		de
  39  61CD 01 33 08     	ld		bc, LST_MAX_FILES*CACHE_SZ - 1
  40  61D0 36 00        	ld		(hl), 0
  41  61D2 ED B0        	ldir
  42  61D4
  43  61D4              	;main program
  44  61D4 CD E5 6F     	call	BDOSGetCurrentDrive
  45  61D7 FE FF        	cp		$FF
  46  61D9 20 02        	jr		nz, DetectTrackCount
  47  61DB
  48  61DB 3E 00        	ld		a, DRIVE_A_CPM			;When loaded from tape/serial, no disk is selected, just select drive 1.
  49  61DD
  50  61DD              DetectTrackCount:
  51  61DD F5           	push	af
  52  61DE CD D9 6F     		call	BDOSInit			;This is needed to remove write protection after changing drives.
  53  61E1 F1           	pop		af
  54  61E2 32 C1 6F     	ld		(RWTSDrive), a			;If a disk is selected previously, show that disk, it can be disk 2, not always 1.
  55  61E5 CD DC 6F     	call	BDOSSelectDisk			;Re-select drive 1 or 2.
  56  61E8
  57  61E8              	;Determine if disk is 40 or 80 tracks, to know how many blocks are free.
  58  61E8 1E 28        	ld		e, TRACK_CNT/2
  59  61EA 21 D8 8B     	ld		hl, FileData
  60  61ED CD 17 6C     	call	ReadOneDiskSector
  61  61F0 3A CC 6F     	ld		a, (RWTSRes)
  62  61F3 B7           	or		a
  63  61F4 21 3E 01     	ld		hl, MAX_FREE_AU_CNT
  64  61F7 28 03        	jr		z, DriveIs80Tracks
  65  61F9 21 9F 00     	ld		hl, MAX_FREE_AU_CNT/2
  66  61FC              DriveIs80Tracks:
  67  61FC 22 8E 7D     	ld		(AUCntMaxFree), hl
  68  61FF
  69  61FF CD F2 6E     	call 	ReadCatalogTrack
  70  6202 B7           	or		a					;Signal disk read error. On empty drive code 5 is shown.
  71  6203 28 1A        	jr		z, HCRunCacheFiles
  72  6205
  73  6205 6F           	ld		l, a
  74  6206 26 00        	ld		h, 0
  75  6208 11 5F 7B     	ld		de, MsgErrCode
  76  620B CD F0 6A     	call	Byte2Txt
  77  620E 21 54 7B     	ld		hl, MsgErr
  78  6211 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
  79  6214 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
  80  6216 CD 8A 74     	call	PrintStrClr
  81  6219 CD D9 6F     	call	BDOSInit
  82  621C C3 BA 61     	jp		HCRunInitDisk
  83  621F
  84  621F
  85  621F              HCRunCacheFiles:
  86  621F CD 02 67     	call 	GetFileNames
  87  6222
  88  6222              HCRunMain:
  89  6222 CD 6B 62     	call 	InitUI
  90  6225 CD E2 66     	call	DisplayFilenames
  91  6228 CD E9 62     	call	DisplayDiskInfo
  92  622B C3 5C 63     	jp		ReadKeyLoop
  93  622E
  94  622E              HCRunEnd:
  95  622E              	;restore error handler
  96  622E E1           	pop		hl
  97  622F E1           	pop		hl
  98  6230 22 3D 5C     	ld		(ERRSP), hl
  99  6233
 100  6233              	;ret
 101  6233 C3 A2 12     	jp		$12A2			;Jump to ROM main loop
 102  6236
 103  6236              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 104  6236
 105  6236              ErrorHandler:
 106  6236 E1           	pop		hl
 107  6237 22 3D 5C     	ld		(ERRSP), hl
 108  623A
 109  623A 3A 3A 5C     	ld		a, (ERRNR)		;Display the error message
 110  623D 6F           	ld		l, a
 111  623E 26 00        	ld		h, 0
 112  6240 11 5F 7B     	ld		de, MsgErrCode
 113  6243 CD F0 6A     	call	Byte2Txt
 114  6246 21 54 7B     	ld		hl, MsgErr
 115  6249 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 116  624C 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 117  624E CD 8A 74     	call	PrintStrClr
 118  6251
 119  6251 3A 3A 5C     	ld		a, (ERRNR)
 120  6254 CD 9A 6F     	call	GetErrMsg
 121  6257
 122  6257 21 D8 8B     	ld		hl, DataBuf
 123  625A 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 124  625D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 125  625F CD 8A 74     	call	PrintStrClr
 126  6262
 127  6262 CD 26 74     	call	ReadChar
 128  6265 CD D9 6F     	call	BDOSInit
 129  6268 C3 A8 61     	jp		Start
 130  626B
 131  626B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 132  626B
 133  626B              InitUI:
 134  626B AF           	xor		a
 135  626C 32 89 7D     	ld		(SelFile), A
 136  626F 3E 11        	ld		a, LST_FIRST_COL + 1
 137  6271 32 88 7D     	ld		(NameCol), A
 138  6274 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 139  6277 ED 53 B0 5C  	ld		(LineCol), de
 140  627B
 141  627B CD 42 74     	call	ClrScr
 142  627E
 143  627E 21 28 00     	ld		hl, SCR_BYTES_PER_LINE * LST_FIRST_LINE + LST_FIRST_COL/2
 144  6281 ED 4B 23 76  	ld		bc, (CurrScrAttrAddr)
 145  6285 09           	add		hl, bc
 146  6286 22 8A 7D     	ld		(CursorAddr), hl
 147  6289
 148  6289 CD 33 75     	call	DrawVLines
 149  628C
 150  628C CD D9 74     	call	DrawHLines
 151  628F
 152  628F 21 95 7A     	ld		hl, VerMsg1
 153  6292 11 00 02     	ld		de, LST_PROG_INFO + 1 << 8
 154  6295 3A A4 7A     	ld		a, (VerMsg1 + 15)
 155  6298 F6 80        	or		$80
 156  629A 32 A4 7A     	ld		(VerMsg1 + 15), a
 157  629D CD 62 74     	call	PrintStr
 158  62A0 21 A5 7A     	ld		hl, VerMsg2
 159  62A3 11 00 03     	ld		de, LST_PROG_INFO + 2 << 8
 160  62A6 CD 62 74     	call	PrintStr
 161  62A9
 162  62A9 3E 60        	ld		a, SCR_LBL_CLR
 163  62AB 11 00 17     	ld		de, 23 << 8
 164  62AE 21 F5 7A     	ld		hl, BtnBar
 165  62B1 CD 8A 74     	call	PrintStrClr
 166  62B4
 167  62B4 3E 60        	ld		a, SCR_LBL_CLR
 168  62B6 21 B5 7A     	ld		hl, MsgSysInf
 169  62B9 11 00 01     	ld		de, LST_PROG_INFO << 8
 170  62BC CD 8A 74     	call	PrintStrClr
 171  62BF
 172  62BF 3E 60        	ld		a, SCR_LBL_CLR
 173  62C1 21 C5 7A     	ld		hl, MsgDskInf
 174  62C4 11 00 04     	ld		de, LST_DISK_INFO << 8
 175  62C7 CD 8A 74     	call	PrintStrClr
 176  62CA
 177  62CA 3E 60        	ld		a, SCR_LBL_CLR
 178  62CC 21 D5 7A     	ld		hl, MsgFileInf
 179  62CF 11 00 07     	ld		de, LST_FILE_INFO << 8
 180  62D2 CD 8A 74     	call	PrintStrClr
 181  62D5
 182  62D5 3E 60        	ld		a, SCR_LBL_CLR
 183  62D7 21 E5 7A     	ld		hl, MsgMessages
 184  62DA 11 00 0D     	ld		de, LST_LINE_MSG << 8
 185  62DD CD 8A 74     	call	PrintStrClr
 186  62E0
 187  62E0 3E 60        	ld		a, SCR_SEL_CLR
 188  62E2 CD 4B 75     	call	DrawCursor
 189  62E5
 190  62E5 CD 8F 6F     	call	SetFastKeys
 191  62E8
 192  62E8 C9           	ret
 193  62E9
 194  62E9
 195  62E9              DisplayDiskInfo:
 196  62E9 2A 8E 7D     	ld		hl, (AUCntMaxFree)
 197  62EC ED 5B 8C 7D  	ld		de, (AUCntUsed)
 198  62F0 B7           	or		a
 199  62F1 ED 52        	sbc		hl, de
 200  62F3 CB 15        	rl		l								;*2, 2K/AU
 201  62F5 CB 14        	rl		h
 202  62F7
 203  62F7 11 3F 7B     	ld		de, MsgDriveLet
 204  62FA CD E5 6A     	call	Word2Txt
 205  62FD 3A 43 7B     	ld		a, (MsgDriveLet+4)
 206  6300 F6 80        	or		$80
 207  6302 32 43 7B     	ld		(MsgDriveLet+4), a
 208  6305
 209  6305 3A C1 6F     	ld		a, (RWTSDrive)
 210  6308 C6 41        	add		'A'
 211  630A 32 3F 7B     	ld		(MsgDriveLet), a
 212  630D 3E 2F        	ld		a, '/'
 213  630F 32 40 7B     	ld		(MsgDriveLet+1), a
 214  6312
 215  6312 21 34 7B     	ld		hl, MsgDrive
 216  6315 11 00 05     	ld		de, LST_DISK_INFO + 1 << 8
 217  6318 CD 62 74     	call	PrintStr
 218  631B
 219  631B 2A 8C 7D     	ld		hl, (AUCntUsed)
 220  631E CB 15        	rl		l								;*2, 2K/AU
 221  6320 CB 14        	rl		h
 222  6322 11 4F 7B     	ld		de, MsgFilesCntNo+2
 223  6325 CD E5 6A     	call	Word2Txt
 224  6328 3A 53 7B     	ld		a, (MsgFilesCntNo+6)
 225  632B F6 80        	or		$80
 226  632D 32 53 7B     	ld		(MsgFilesCntNo+6), a
 227  6330 3E 2F        	ld		a, '/'
 228  6332 32 50 7B     	ld		(MsgFilesCntNo+3), a
 229  6335
 230  6335 3A 87 7D     	ld		a, (FileCnt)
 231  6338 6F           	ld		l, a
 232  6339 26 00        	ld		h, 0
 233  633B 11 4D 7B     	ld		de, MsgFilesCntNo
 234  633E CD F0 6A     	call	Byte2Txt
 235  6341 21 44 7B     	ld		hl, MsgFilesCnt
 236  6344 11 00 06     	ld		de, LST_DISK_INFO + 2 << 8
 237  6347 CD 62 74     	call	PrintStr
 238  634A
 239  634A C9           	ret
 240  634B
 241  634B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 242  634B
 243  634B              CalcFileCache:
 244  634B 3A 89 7D     	ld		a, (SelFile)
 245  634E 11 19 00     	ld		de, CACHE_SZ
 246  6351 CD 4C 6B     	call	Mul
 247  6354 01 BA 7D     	ld		bc, FileCache
 248  6357 09           	add		hl, bc					;HL = file AU cnt
 249  6358 22 90 7D     	ld		(SelFileCache), hl
 250  635B C9           	ret
 251  635C
 252  635C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 253  635C
 254  635C
 255  635C              ReadKeyLoop:
 256  635C CD 4B 63     	call	CalcFileCache
 257  635F CD 29 69     	call	DisplayFileInfo
 258  6362
 259  6362 CD 26 74     	call	ReadChar
 260  6365
 261  6365 FE 0A        	cp		KEY_DOWN
 262  6367 28 04        	jr		z,  DoKeyDown
 263  6369 FE 61        	cp 		'a'
 264  636B 20 11        	jr		nz, CheckUp
 265  636D
 266  636D              DoKeyDown:
 267  636D 3A 87 7D     	ld		a, (FileCnt)
 268  6370 47           	ld		b, a
 269  6371 3A 89 7D     	ld		a, (SelFile)
 270  6374 3C           	inc		a
 271  6375 B8           	cp		b
 272  6376 30 E4        	jr		nc, ReadKeyLoop
 273  6378 32 89 7D     	ld		(SelFile), a
 274  637B C3 AA 66     	jp		MoveIt
 275  637E
 276  637E              CheckUp:
 277  637E FE 0B        	cp		KEY_UP
 278  6380 28 04        	jr		z, DoKeyUp
 279  6382 FE 71        	cp 		'q'
 280  6384 20 0D        	jr		nz, CheckRight
 281  6386
 282  6386              DoKeyUp:
 283  6386 3A 89 7D     	ld		a, (SelFile)
 284  6389 B7           	or		a
 285  638A 28 D0        	jr		z, ReadKeyLoop
 286  638C
 287  638C 3D           	dec		a
 288  638D 32 89 7D     	ld		(SelFile), a
 289  6390 C3 AA 66     	jp		MoveIt
 290  6393
 291  6393              CheckRight:
 292  6393 FE 09        	cp		KEY_RIGHT
 293  6395 28 04        	jr		z, DoKeyRight
 294  6397 FE 70        	cp 		'p'
 295  6399 20 12        	jr		nz, CheckLeft
 296  639B
 297  639B              DoKeyRight:
 298  639B 3A 87 7D     	ld		a, (FileCnt)
 299  639E 47           	ld		b, a
 300  639F 3A 89 7D     	ld		a, (SelFile)
 301  63A2 C6 15        	add		LST_LINES_CNT
 302  63A4 B8           	cp		b
 303  63A5 30 B5        	jr		nc, ReadKeyLoop
 304  63A7
 305  63A7 32 89 7D     	ld		(SelFile), a
 306  63AA C3 AA 66     	jp		MoveIt
 307  63AD
 308  63AD              CheckLeft:
 309  63AD FE 08        	cp		KEY_LEFT
 310  63AF 28 04        	jr		z, DoKeyLeft
 311  63B1 FE 6F        	cp		'o'
 312  63B3 20 0D        	jr		nz, CheckEnter
 313  63B5
 314  63B5              DoKeyLeft:
 315  63B5 3A 89 7D     	ld		a, (SelFile)
 316  63B8 D6 15        	sub		LST_LINES_CNT
 317  63BA 38 A0        	jr		c, ReadKeyLoop
 318  63BC
 319  63BC 32 89 7D     	ld		(SelFile), a
 320  63BF C3 AA 66     	jp		MoveIt
 321  63C2
 322  63C2              CheckEnter:
 323  63C2 FE 0D        	cp		KEY_ENTER
 324  63C4 28 05        	jr		z, DoKeyEnter
 325  63C6 FE 6D        	cp		'm'
 326  63C8 C2 D1 63     	jp		nz, CheckKeyInfo
 327  63CB
 328  63CB              DoKeyEnter:
 329  63CB CD 97 67     	call	HandleFile
 330  63CE C3 22 62     	jp		HCRunMain
 331  63D1
 332  63D1              CheckKeyInfo:
 333  63D1 FE 34        	cp		'4'
 334  63D3 20 21        	jr		nz, CheckKeyCopy
 335  63D5
 336  63D5 3A 87 7D     	ld		a, (FileCnt)
 337  63D8 B7           	or		a
 338  63D9 CA 5C 63     	jp		z, ReadKeyLoop
 339  63DC
 340  63DC DD 2A 90 7D  	ld		ix, (SelFileCache)
 341  63E0 21 15 7C     	ld		hl, MsgReadingExt
 342  63E3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 343  63E6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 344  63E8 CD 8A 74     	call	PrintStrClr
 345  63EB CD 0F 6F     	call	ReadFileHeader
 346  63EE 06 01        	ld		b, 1
 347  63F0 CD 0E 76     	call	ClearNMsgLines
 348  63F3 C3 5C 63     	jp		ReadKeyLoop
 349  63F6
 350  63F6              CheckKeyCopy:
 351  63F6 FE 35        	cp		'5'
 352  63F8 C2 42 64     	jp		nz, CheckKeyFileInfo
 353  63FB
 354  63FB 3A 87 7D     	ld		a, (FileCnt)
 355  63FE B7           	or		a
 356  63FF CA 5C 63     	jp		z, ReadKeyLoop
 357  6402
 358  6402 2A 90 7D     	ld		hl, (SelFileCache)
 359  6405 CD 07 71     	call	CopyFile
 360  6408 3A 9A 7D     	ld		a, (CopyFileRes)
 361  640B B7           	or		a
 362  640C 28 1A        	jr		z, CopyFileOK
 363  640E
 364  640E 6F           	ld		l, a
 365  640F 26 00        	ld		h, 0
 366  6411 11 5F 7B     	ld		de, MsgErrCode
 367  6414 CD F0 6A     	call	Byte2Txt
 368  6417 21 54 7B     	ld		hl, MsgErr
 369  641A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 370  641D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 371  641F CD 8A 74     	call	PrintStrClr
 372  6422 CD 26 74     	call	ReadChar
 373  6425 C3 5C 63     	jp		ReadKeyLoop
 374  6428
 375  6428              CopyFileOK:
 376  6428 06 02        	ld		b, 2
 377  642A CD 0E 76     	call	ClearNMsgLines
 378  642D              	;Display destination disk after file copy, if on disk copy, to to COM (1, 2, 4).
 379  642D 3A 92 7D     	ld		a, (CopySelOption)
 380  6430 FE 33        	cp		'3'
 381  6432 CA 5C 63     	jp		z, ReadKeyLoop
 382  6435 3A AE 7D     	ld		a, (CopyFileDstDrv)
 383  6438 3D           	dec		a
 384  6439 32 C1 6F     	ld		(RWTSDrive), a
 385  643C CD DC 6F     	call	BDOSSelectDisk		;Select destination disk after copy, to show the new file list.
 386  643F C3 BA 61     	jp		HCRunInitDisk
 387  6442
 388  6442              CheckKeyFileInfo:
 389  6442 FE 20        	cp		' '
 390  6444 20 0D        	jr		nz, CheckKeyDriveA
 391  6446
 392  6446 3A 87 7D     	ld		a, (FileCnt)
 393  6449 B7           	or		a
 394  644A CA 5C 63     	jp		z, ReadKeyLoop
 395  644D
 396  644D CD 8F 6A     	call	ReadAllHeaders
 397  6450 C3 5C 63     	jp		ReadKeyLoop
 398  6453
 399  6453              CheckKeyDriveA:
 400  6453 FE 31        	cp		'1'
 401  6455 20 05        	jr		nz, CheckKeyDriveB
 402  6457 3E 00        	ld		a, DRIVE_A_CPM
 403  6459 C3 83 65     	jp		SelectDrive
 404  645C
 405  645C              CheckKeyDriveB:
 406  645C FE 32        	cp		'2'
 407  645E 20 05        	jr		nz, CheckKeyView
 408  6460 3E 01        	ld		a, DRIVE_B_CPM
 409  6462 C3 83 65     	jp		SelectDrive
 410  6465
 411  6465              CheckKeyView:
 412  6465 FE 33        	cp		'3'
 413  6467 20 36        	jr		nz, CheckKeyRename
 414  6469
 415  6469 3A 87 7D     	ld		a, (FileCnt)
 416  646C B7           	or		a
 417  646D CA 5C 63     	jp		z, ReadKeyLoop
 418  6470
 419  6470
 420  6470 21 57 7D     	ld		hl, MsgViewFileMenu
 421  6473 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 422  6476 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 423  6478 CD 8A 74     	call		PrintStrClr
 424  647B 21 66 7D     	ld		hl, MsgViewFileText
 425  647E 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 426  6481 CD 62 74     	call		PrintStr
 427  6484 21 6F 7D     	ld		hl, MsgViewFileHex
 428  6487 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 429  648A CD 62 74     	call		PrintStr
 430  648D 21 77 7D     	ld		hl, MsgViewFileAuto
 431  6490 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 432  6493 CD 62 74     	call		PrintStr
 433  6496 CD 26 74     	call		ReadChar
 434  6499
 435  6499 CD 12 68     	call		ViewFile
 436  649C C3 22 62     	jp		HCRunMain
 437  649F
 438  649F              CheckKeyRename:
 439  649F FE 36        	cp		'6'
 440  64A1 20 6C        	jr		nz, CheckKeyDel
 441  64A3
 442  64A3 3A 87 7D     	ld		a, (FileCnt)
 443  64A6 B7           	or		a
 444  64A7 CA 5C 63     	jp		z, ReadKeyLoop
 445  64AA
 446  64AA 21 58 7C     	ld		hl, MsgNewFileName
 447  64AD 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 448  64B0 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 449  64B2 CD 8A 74     	call	PrintStrClr
 450  64B5
 451  64B5 21 23 7C     	ld		hl, MsgClear
 452  64B8 11 D8 8B     	ld		de, FileData
 453  64BB 01 0B 00     	ld		bc, NAMELEN
 454  64BE ED B0        	ldir
 455  64C0 3E A0        	ld		a, $80 | ' '
 456  64C2 12           	ld		(de), a
 457  64C3 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 458  64C6 21 D8 8B     	ld		hl, FileData
 459  64C9 CD 62 74     	call	PrintStr
 460  64CC
 461  64CC 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 462  64CF 01 0B 00     	ld		bc, NAMELEN
 463  64D2 CD CC 75     	call	ReadString
 464  64D5
 465  64D5 11 D8 8B     	ld		de, FileData
 466  64D8 1A           	ld		a, (de)
 467  64D9 FE 20        	cp		' '					;If starting with space, input was canceled.
 468  64DB CA 07 65     	jp		z, RenameCanceled
 469  64DE
 470  64DE              	;Check if new name doesn't exist already. Cancel if so.
 471  64DE 21 D8 8B     	ld		hl, FileData
 472  64E1 3A C1 6F     	ld 		a, (RWTSDrive)
 473  64E4 3C           	inc		a
 474  64E5 CD 6D 70     	call	DoesFileExist
 475  64E8 3C           	inc		a
 476  64E9 28 10        	jr		z, RenameFileNotExist
 477  64EB
 478  64EB 21 FC 7C     	ld		hl, MsgFileExists
 479  64EE 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 480  64F1 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 481  64F3 CD 8A 74     	call	PrintStrClr
 482  64F6 CD 26 74     	call	ReadChar
 483  64F9 18 0C        	jr		RenameCanceled
 484  64FB
 485  64FB              RenameFileNotExist:
 486  64FB 11 D8 8B     	ld		de, FileData
 487  64FE 2A 90 7D     	ld		hl, (SelFileCache)
 488  6501 CD B0 70     	call	RenameFile
 489  6504 C3 BA 61     	jp		HCRunInitDisk
 490  6507
 491  6507              RenameCanceled:
 492  6507 06 02        	ld		b, 2
 493  6509 CD 0E 76     	call	ClearNMsgLines
 494  650C C3 5C 63     	jp		ReadKeyLoop
 495  650F
 496  650F              CheckKeyDel:
 497  650F FE 38        	cp		'8'
 498  6511 20 2E        	jr		nz, CheckKeyAttrib
 499  6513
 500  6513 3A 87 7D     	ld		a, (FileCnt)
 501  6516 B7           	or		a
 502  6517 CA 5C 63     	jp		z, ReadKeyLoop
 503  651A
 504  651A 21 33 7C     	ld		hl, MsgDelete
 505  651D 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 506  6520 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 507  6522 CD 8A 74     	call	PrintStrClr
 508  6525 CD 26 74     	call	ReadChar
 509  6528 FE 79        	cp		'y'
 510  652A 28 08        	jr		z, DoFileDelete
 511  652C 06 01        	ld		b, 1
 512  652E CD 0E 76     	call	ClearNMsgLines
 513  6531 C3 5C 63     	jp		ReadKeyLoop
 514  6534              DoFileDelete:
 515  6534 2A 90 7D     	ld		hl, (SelFileCache)
 516  6537 3A C1 6F     	ld 		a, (RWTSDrive)
 517  653A 3C           	inc		a					;Convert to BASIC drive number: 1,2
 518  653B CD 61 70     	call	DeleteFile
 519  653E C3 BA 61     	jp		HCRunInitDisk
 520  6541
 521  6541              CheckKeyAttrib:
 522  6541 FE 37        	cp		'7'
 523  6543 20 47        	jr		nz, CheckKeyDiskMenu
 524  6545
 525  6545 3A 87 7D     	ld		a, (FileCnt)
 526  6548 B7           	or		a
 527  6549 CA 5C 63     	jp		z, ReadKeyLoop
 528  654C
 529  654C 21 40 7C     	ld		hl, MsgSetRO
 530  654F 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 531  6552 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 532  6554 CD 8A 74     	call	PrintStrClr
 533  6557 CD 26 74     	call	ReadChar
 534  655A 1E 00        	ld		e, 0
 535  655C FE 79        	cp		'y'
 536  655E 20 02        	jr		nz, CheckSYS
 537  6560 1E 01        	ld		e, 1
 538  6562
 539  6562              CheckSYS:
 540  6562 D5           	push	de
 541  6563 21 4C 7C     		ld		hl, MsgSetSYS
 542  6566 11 00 0F     		ld		de, LST_LINE_MSG + 2 << 8
 543  6569 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 544  656B CD 8A 74     		call	PrintStrClr
 545  656E CD 26 74     		call	ReadChar
 546  6571 FE 79        		cp		'y'
 547  6573 D1           	pop		de
 548  6574 20 04        	jr		nz, AttrChange
 549  6576 3E 02        	ld		a, %10
 550  6578 B3           	or		e
 551  6579 5F           	ld		e, a
 552  657A
 553  657A              AttrChange:
 554  657A 2A 90 7D     	ld		hl, (SelFileCache)
 555  657D CD 86 70     	call	ChangeFileAttrib
 556  6580 C3 BA 61     	jp		HCRunInitDisk
 557  6583
 558  6583              SelectDrive:
 559  6583 32 C1 6F     	ld 		(RWTSDrive), a
 560  6586 CD DC 6F     	call	BDOSSelectDisk
 561  6589              	;call	BDOSInit
 562  6589 C3 BA 61     	jp		HCRunInitDisk
 563  658C
 564  658C              CheckKeyDiskMenu:
 565  658C FE 39        	cp		'9'
 566  658E C2 A2 66     	jp		nz, CheckKeyExit
 567  6591
 568  6591 3A C1 6F     	ld		a, (RWTSDrive)
 569  6594 C6 41        	add		'A'
 570  6596              	;Update menu messages with current drive.
 571  6596 32 95 7C     	ld		(MsgMenuSingleDrv1), a
 572  6599 32 99 7C     	ld		(MsgMenuSingleDrv2), a
 573  659C 32 A3 7C     	ld		(MsgMenuDualDrv1), a
 574  659F 32 B1 7C     	ld		(MsgMenuToComDrv), a
 575  65A2 32 C5 7C     	ld		(MsgMenuFromCOMDrv), a
 576  65A5              	;Update menu messages with the alternate drive.
 577  65A5 3A C1 6F     	ld		a, (RWTSDrive)
 578  65A8 3C           	inc		a
 579  65A9 EE 03        	xor		%11
 580  65AB C6 40        	add		'A'-1
 581  65AD 32 A7 7C     	ld		(MsgMenuDualDrv2), a
 582  65B0
 583  65B0 21 68 7C     	ld		hl, MsgMenuDiskCopy
 584  65B3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 585  65B6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586  65B8 CD 8A 74     	call	PrintStrClr
 587  65BB 21 81 7C     	ld		hl, MsgMenuBack
 588  65BE 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 589  65C1 CD 62 74     	call	PrintStr
 590  65C4 21 8D 7C     	ld		hl, MsgMenuSingle
 591  65C7 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 592  65CA CD 62 74     	call	PrintStr
 593  65CD 21 9B 7C     	ld		hl, MsgMenuDual
 594  65D0 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 595  65D3 CD 62 74     	call	PrintStr
 596  65D6 21 A9 7C     	ld		hl, MsgMenuToCOM
 597  65D9 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 598  65DC CD 62 74     	call	PrintStr
 599  65DF 21 B8 7C     	ld		hl, MsgMenuFromCOM
 600  65E2 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 601  65E5 CD 62 74     	call	PrintStr
 602  65E8 21 C7 7C     	ld		hl, MsgMenuFmt1
 603  65EB 11 00 14     	ld		de, LST_LINE_MSG + 7 << 8
 604  65EE CD 62 74     	call	PrintStr
 605  65F1 21 D3 7C     	ld		hl, MsgMenuFmt2
 606  65F4 11 00 15     	ld		de, LST_LINE_MSG + 8 << 8
 607  65F7 CD 62 74     	call	PrintStr
 608  65FA
 609  65FA CD 26 74     	call	ReadChar
 610  65FD F5           	push	af
 611  65FE 06 08        		ld		b, 8
 612  6600 CD 0E 76     		call	ClearNMsgLines
 613  6603 F1           	pop		af
 614  6604 32 92 7D     	ld		(CopySelOption), a
 615  6607
 616  6607              CheckKeyDiskMenuLoop:
 617  6607 FE 30        	cp		'0'
 618  6609 CA 9F 66     	jp		z, DiskMenuExit
 619  660C
 620  660C              	;Single drive copy
 621  660C FE 31        	cp		'1'
 622  660E 20 0B        	jr		nz, CheckDiskMenuDualDrive
 623  6610 CD FE 6C     	call	CopyDisk
 624  6613 06 02        	ld		b, 2
 625  6615 CD 0E 76     	call	ClearNMsgLines
 626  6618 C3 9F 66     	jp		DiskMenuExit
 627  661B
 628  661B              	;Dual drive copy
 629  661B              CheckDiskMenuDualDrive:
 630  661B FE 32        	cp		'2'
 631  661D 20 0A        	jr		nz, CheckDiskMenuToCOM
 632  661F CD FE 6C     	call	CopyDisk
 633  6622 06 02        	ld		b, 2
 634  6624 CD 0E 76     	call	ClearNMsgLines
 635  6627 18 76        	jr		DiskMenuExit
 636  6629
 637  6629              CheckDiskMenuToCOM:
 638  6629 FE 33        	cp		'3'
 639  662B 20 05        	jr		nz, CheckDiskMenuFromCOM
 640  662D CD B7 6D     	call	CopyDiskToCOM
 641  6630 18 6D        	jr		DiskMenuExit
 642  6632
 643  6632              CheckDiskMenuFromCOM:
 644  6632 FE 34        	cp		'4'
 645  6634 20 06        	jr		nz, CheckDiskMenuFormat1
 646  6636 CD 13 6E     	call	CopyDiskFromCOM
 647  6639 C3 BA 61     	jp		HCRunInitDisk
 648  663C
 649  663C              CheckDiskMenuFormat1:
 650  663C FE 35        	cp		'5'
 651  663E C2 4B 66     	jp		nz, CheckDiskMenuFormat2
 652  6641
 653  6641 3E 00        	ld		a, DRIVE_A_CPM
 654  6643 32 C1 6F     	ld		(RWTSDrive), a
 655  6646 21 CA 7C     	ld		hl, MsgMenuFmt1+3
 656  6649 18 0D        	jr		FormatDiskAction
 657  664B
 658  664B              CheckDiskMenuFormat2:
 659  664B FE 36        	cp		'6'
 660  664D C2 22 62     	jp		nz, HCRunMain
 661  6650
 662  6650 3E 01        	ld		a, DRIVE_B_CPM
 663  6652 32 C1 6F     	ld		(RWTSDrive), a
 664  6655 21 D6 7C     	ld		hl, MsgMenuFmt2+3
 665  6658
 666  6658              FormatDiskAction:
 667  6658 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 668  665B 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 669  665D CD 8A 74     	call	PrintStrClr
 670  6660
 671  6660 21 47 7D     	ld		hl, MsgAreYouSure
 672  6663 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 673  6666 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 674  6668 CD 8A 74     	call	PrintStrClr
 675  666B CD 26 74     	call	ReadChar
 676  666E FE 79        	cp		'y'
 677  6670 C2 22 62     	jp		nz, HCRunMain
 678  6673
 679  6673 21 23 7C     	ld		hl, MsgClear
 680  6676 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 681  6679 3E 45        	ld		a, SCR_DEF_CLR
 682  667B CD 8A 74     	call	PrintStrClr
 683  667E
 684  667E CD 2D 6C     	call	FormatDisk
 685  6681 B7           	or		a
 686  6682 CA BA 61     	jp		z, HCRunInitDisk
 687  6685
 688  6685              	;Display error for format
 689  6685 6F           	ld		l, a
 690  6686 26 00        	ld		h, 0
 691  6688 11 5F 7B     	ld		de, MsgErrCode
 692  668B CD F0 6A     	call	Byte2Txt
 693  668E 21 54 7B     	ld		hl, MsgErr
 694  6691 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 695  6694 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 696  6696 CD 8A 74     	call	PrintStrClr
 697  6699 CD 26 74     	call	ReadChar
 698  669C C3 BA 61     	jp		HCRunInitDisk
 699  669F
 700  669F              DiskMenuExit:
 701  669F C3 5C 63     	jp		ReadKeyLoop
 702  66A2
 703  66A2              CheckKeyExit:
 704  66A2 FE 30        	cp		'0'
 705  66A4 C2 5C 63     	jp		nz, ReadKeyLoop
 706  66A7 C3 2E 62     	jp		HCRunEnd
 707  66AA              	;jp		0					;Had to exit by reset, since after doing CLEAR in unpack.asm, we can't return to BASIC as before.
 708  66AA
 709  66AA              MoveIt:
 710  66AA CD 56 75     	call 	MoveCursor
 711  66AD C3 5C 63     	jp		ReadKeyLoop
 712  66B0
 713  66B0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 714  66B0
 715  66B0
 716  66B0              DisplayFilename:
 717  66B0 06 0B        	LD		B, NAMELEN
 718  66B2              DispLoop:
 719  66B2 1A           	LD		A, (DE)
 720  66B3
 721  66B3              	;clear bit 7
 722  66B3 CB BF        	RES 	7, A
 723  66B5 32 81 5C     	LD		(CODE), A
 724  66B8
 725  66B8 13           	INC		DE
 726  66B9 D5           	PUSH	DE
 727  66BA C5           	PUSH	BC
 728  66BB CD 8E 75     		CALL	PrintChar
 729  66BE C1           	POP		BC
 730  66BF D1           	POP 	DE
 731  66C0
 732  66C0 21 B0 5C     	LD		HL, COL
 733  66C3 34           	INC		(HL)
 734  66C4 10 EC        	DJNZ	DispLoop
 735  66C6              	;now a name is displayed
 736  66C6
 737  66C6              	;check bounds
 738  66C6 3A B1 5C     	LD		A, (LINE)
 739  66C9 3C           	INC		A
 740  66CA FE 16        	CP		LST_LINES_CNT + LST_FIRST_LINE
 741  66CC 38 0A        	JR		C, LineOK
 742  66CE
 743  66CE              	;set names column to the next one
 744  66CE 3A 88 7D     	LD		A, (NameCol)
 745  66D1 C6 0C        	ADD		NAMELEN + 1
 746  66D3 32 88 7D     	LD		(NameCol), A
 747  66D6
 748  66D6 3E 01        	LD		A, LST_FIRST_LINE
 749  66D8              LineOK:
 750  66D8 32 B1 5C     	LD		(LINE), A
 751  66DB
 752  66DB 3A 88 7D     	LD		A, (NameCol)
 753  66DE 32 B0 5C     	LD		(COL), A
 754  66E1
 755  66E1 C9           	RET
 756  66E2
 757  66E2
 758  66E2              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 759  66E2
 760  66E2              DisplayFilenames:
 761  66E2 11 11 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL + 1
 762  66E5 ED 53 B0 5C  	ld		(LineCol), de
 763  66E9
 764  66E9 11 BA 7D     	ld		de, FileCache
 765  66EC 3A 87 7D     	ld		a, (FileCnt)
 766  66EF B7           	or		a
 767  66F0 C8           	ret		z
 768  66F1
 769  66F1 47           	ld		b,	a
 770  66F2
 771  66F2              DisplayFilenamesLoop:
 772  66F2 C5           	push	bc
 773  66F3 D5           		push	de
 774  66F4 CD B0 66     			call	DisplayFilename
 775  66F7 D1           		pop		de
 776  66F8 EB           		ex		de, hl
 777  66F9 01 19 00     		ld		bc, CACHE_SZ
 778  66FC 09           		add		hl, bc
 779  66FD EB           		ex		de, hl
 780  66FE C1           	pop		bc
 781  66FF 10 F1        	djnz	DisplayFilenamesLoop
 782  6701
 783  6701 C9           	ret
 784  6702
 785  6702
 786  6702              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 787  6702              ;Selects only valid filenames (not deleted and only from first extension)
 788  6702              GetFileNames:
 789  6702 DD 21 D8 8B  	ld		ix, TrackBuf
 790  6706 11 BA 7D     	ld		de, FileCache
 791  6709 06 80        	ld		b, MAX_EXT_CNT
 792  670B AF           	xor		a
 793  670C 32 87 7D     	ld		(FileCnt), a
 794  670F 21 8C 7D     	ld		hl, AUCntUsed
 795  6712 77           	ld		(hl), a
 796  6713 23           	inc		hl
 797  6714 77           	ld		(hl), a
 798  6715
 799  6715              StoreFilenamesLoop:
 800  6715 AF           	xor a
 801  6716 DD BE 00     	cp (ix + EXT_DEL_FLAG)
 802  6719 C2 89 67     	jp nz, NextExt
 803  671C
 804  671C              	;count AU
 805  671C D9           	exx
 806  671D E5           	push hl
 807  671E CD 5C 6C     		call CheckExtAlloc
 808  6721 EB           		ex de, hl			;save first AU no.
 809  6722
 810  6722              		;store disk alocated AU count
 811  6722 2A 8C 7D     		ld hl, (AUCntUsed)
 812  6725 48           		ld c, b
 813  6726 06 00        		ld b, 0
 814  6728 09           		add hl, bc
 815  6729 22 8C 7D     		ld (AUCntUsed), hl
 816  672C E1           	pop hl
 817  672D D9           	exx
 818  672E
 819  672E AF           	xor	a
 820  672F DD BE 0C     	cp (ix + EXT_IDX)		;check if first extension
 821  6732 20 2E        	jr nz, FindExt
 822  6734
 823  6734 DD E5        	push ix
 824  6736 E1           	pop hl
 825  6737 23           	inc hl					;skip del flag
 826  6738
 827  6738 C5           	push bc
 828  6739 ~            		/*
 829  6739 ~            		push de
 830  6739 ~            			push hl
 831  6739 ~            				ex de, hl
 832  6739 ~            				call DisplayFilename
 833  6739 ~            			pop hl
 834  6739 ~            		pop de
 835  6739 ~            		*/
 836  6739 01 0B 00     		ld bc, NAMELEN
 837  673C ED B0        		ldir				;save file name
 838  673E
 839  673E D9           		exx
 840  673F D5           		push 	de			;de = first AU
 841  6740 D9           		exx
 842  6741 E1           		pop		hl
 843  6742 EB           		ex		de, hl
 844  6743 73           		ld		(hl), e
 845  6744 23           		inc		hl
 846  6745 72           		ld		(hl), d		;save first AU
 847  6746
 848  6746 23           		inc		hl
 849  6747
 850  6747 D9           		exx					;save AU cnt for file
 851  6748 C5           		push	bc
 852  6749 D9           		exx
 853  674A C1           		pop		bc
 854  674B 71           		ld		(hl), c
 855  674C 23           		inc		hl
 856  674D 70           		ld		(hl), b
 857  674E 23           		inc		hl
 858  674F
 859  674F              		;xor		a			;make flag 0 to signal that header is not read yet
 860  674F              		;ld		(hl), a
 861  674F
 862  674F 01 0A 00     		ld		bc, HDR_SZ + 1
 863  6752 09           		add		hl, bc
 864  6753
 865  6753 EB           		ex		de, hl
 866  6754 C1           	pop bc
 867  6755
 868  6755
 869  6755 3A 87 7D     	ld 		a, (FileCnt)			;inc file counter
 870  6758 3C           	inc		a
 871  6759 32 87 7D     	ld 		(FileCnt), a
 872  675C FE 54        	cp		LST_MAX_FILES
 873  675E 38 29        	jr		c, NextExt
 874  6760 18 34        	jr		GetFileNamesEnd
 875  6762
 876  6762
 877  6762              FindExt:					;BC' = AU cnt for this ext
 878  6762 C5           	push	bc
 879  6763 D5           		push 	de
 880  6764 DD E5        			push	ix
 881  6766 D1           			pop		de
 882  6767 13           			inc		de				;DE = name to find
 883  6768
 884  6768 21 BA 7D     			ld		hl, FileCache
 885  676B 3A 87 7D     			ld		a, (FileCnt)
 886  676E 4F           			ld		c, a
 887  676F CD FE 6E     			call	FindCache
 888  6772 20 13        			jr		nz, FindExtEnd
 889  6774
 890  6774 01 0D 00     			ld		bc, CACHE_AU_CNT
 891  6777 09           			add		hl, bc
 892  6778 D9           			exx
 893  6779 C5           			push	bc
 894  677A D9           			exx
 895  677B C1           			pop		bc
 896  677C
 897  677C 5E           			ld		e, (hl)		;DE = Current AU CNT for file
 898  677D 23           			inc		hl
 899  677E 56           			ld		d, (hl)
 900  677F 2B           			dec		hl
 901  6780 EB           			ex		de, hl
 902  6781 09           			add		hl, bc
 903  6782 EB           			ex		de, hl
 904  6783 73           			ld		(hl), e
 905  6784 23           			inc		hl
 906  6785 72           			ld		(hl), d
 907  6786 2B           			dec		hl
 908  6787              FindExtEnd:
 909  6787 D1           		pop		de
 910  6788 C1           	pop		bc
 911  6789
 912  6789              NextExt:
 913  6789 C5           	push bc
 914  678A 01 20 00     		ld bc, EXT_SZ
 915  678D DD 09        		add ix, bc
 916  678F C1           	pop	bc
 917  6790
 918  6790 05           	dec	b
 919  6791 78           	ld	a, b
 920  6792 B7           	or	a
 921  6793 C2 15 67     	jp	nz, StoreFilenamesLoop
 922  6796              GetFileNamesEnd:
 923  6796 C9           	ret
 924  6797
 925  6797              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 926  6797
 927  6797              ;Take care of file depeding on file type: run programs, display SCREEN$, load code
 928  6797              ;IN: HL = file name
 929  6797              HandleFile:
 930  6797              	;Make HL point to the selected file
 931  6797 DD 2A 90 7D  	ld		ix, (SelFileCache)
 932  679B DD E5        	push	ix
 933  679D DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
 934  67A0 B7           		or		a
 935  67A1 CC 0F 6F     		call	z, ReadFileHeader
 936  67A4
 937  67A4 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
 938  67A7 FE 00        		cp		PROG_TYPE
 939  67A9 28 56        		jr		z, HandleFileProg
 940  67AB
 941  67AB FE 03        		cp		BYTE_TYPE
 942  67AD 20 62        		jr		nz, HandleFileText
 943  67AF
 944  67AF DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)		;get length
 945  67B2 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
 946  67B5 11 00 E5     		ld		de, -SCR_LEN			;check if the length is for a screen$ file
 947  67B8 19           		add		hl, de
 948  67B9 7C           		ld		a, h
 949  67BA B5           		or		l
 950  67BB 28 26        		jr		z, HandleFileSCR
 951  67BD
 952  67BD
 953  67BD              HandleFileCODE:
 954  67BD 21 81 7B     		ld		hl, MsgLoadingCODE
 955  67C0 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 956  67C3 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 957  67C5 CD 8A 74     		call	PrintStrClr
 958  67C8
 959  67C8              		;Copy file load function to printer buffer to not be overwritten by CODE block.
 960  67C8 21 86 6E     		ld		hl, IF1FileLoad
 961  67CB 11 00 5B     		ld		de, PRN_BUF
 962  67CE 01 46 00     		ld		bc, IF1FileLoadEnd - IF1FileLoad
 963  67D1 ED B0        		ldir
 964  67D3              		;ld		a, $C9
 965  67D3              		;ld		(de), a				;put a RET here, since FileFree won't be called.
 966  67D3
 967  67D3 E1           	pop		hl
 968  67D4 ED 5B DB 8B  	ld		de, (DataBuf + HDR_ADDR)	;get CODE start address to load to and then execute
 969  67D8 C1           	pop		bc						;balance stack to exit to BASIC after CODE returns - 1 call for this function
 970  67D9 C1           	pop		bc						;2nd, 3rd call for error handler
 971  67DA C1           	pop		bc
 972  67DB ED 43 3D 5C  	ld		(ERRSP), bc
 973  67DF D5           	push	de						;push CODE address to return to = start of CODE block
 974  67E0 C3 00 5B     	jp		PRN_BUF
 975  67E3
 976  67E3
 977  67E3
 978  67E3
 979  67E3              HandleFileSCR:
 980  67E3 21 72 7B     		ld		hl, MsgLoadingSCR
 981  67E6 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
 982  67E9 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
 983  67EB CD 8A 74     		call	PrintStrClr
 984  67EE
 985  67EE E1           	pop		hl
 986  67EF
 987  67EF              	IFDEF _REAL_HW_
 988  67EF              		;Load to alternate SCREEN$ memory
 989  67EF 11 00 C0     		ld		de, HC_VID_BANK1
 990  67F2 CD 86 6E     		call	IF1FileLoad
 991  67F5
 992  67F5              		;Set display to alternate SCREEN$ memory
 993  67F5 3E 08        		ld		a, HC_CFG_VID_C000
 994  67F7 D3 7E        		out 	(HC_CFG_PORT), a
 995  67F9 CD 26 74     		call	ReadChar
 996  67FC
 997  67FC              		;Set back to regular SCREEN$ memory
 998  67FC 3E 00        		ld		a, HC_CFG_VID_4000
 999  67FE D3 7E        		out 	(HC_CFG_PORT), a
1000  6800              	ELSE
1001  6800 ~            		ld		de, HC_VID_BANK0
1002  6800 ~            		call	IF1FileLoad
1003  6800 ~            		call	ReadChar
1004  6800              	ENDIF
1005  6800
1006  6800 C9           	ret
1007  6801
1008  6801              HandleFileProg:
1009  6801 21 63 7B     		ld		hl, MsgLoadingPrg
1010  6804 11 00 0E     		ld		de, LST_LINE_MSG+1 << 8
1011  6807 3E C5        		ld		a, SCR_DEF_CLR | CLR_FLASH
1012  6809 CD 8A 74     		call	PrintStrClr
1013  680C E1           	pop		hl
1014  680D CD 76 6F     	call	LoadProgram
1015  6810 C9           	ret
1016  6811
1017  6811
1018  6811              HandleFileText:
1019  6811 E1           	pop		hl
1020  6812
1021  6812
1022  6812              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1023  6812
1024  6812              ;Use constants for loading in RAM only as much as we can in order to fit both the binary and the text representation.
1025  6812              ViewFileConvertRatioText	EQU	1				;Text data is stored as is, 1:1, byte to byte.
1026  6812              ViewFileConvertRatioBASIC	EQU	4				;BASIC tokens are expanded to text as 1 byte to 3 chars on average? To test!
1027  6812              ViewFileConvertRatioHEX		EQU	5				;1 byte expands to 4 bytes when printed as hex. So RAM stores 1+4 bytes for each byte.
1028  6812              ViewFileConvertRatioASM		EQU	3				;Disassembly is expanded as 1:3? To test!
1029  6812
1030  6812              ;Auto viewing mode will show content bases on file type: no type - as text, programs as BASIC, rest - as hex
1031  6812              ;Skip header, if exists.
1032  6812
1033  6812              ViewFile:
1034  6812 21 00 00     	ld	hl, 0
1035  6815 22 9D 7D     	ld	(FilePosRead), hl
1036  6818 32 93 7D     	ld	(ViewSelOption), a
1037  681B AF           	xor	a
1038  681C 32 95 7D     	ld	(ViewFilePart), a
1039  681F DD 21 D8 FA  	ld	ix, FileBlocksIdx
1040  6823 21 00 00     	ld	hl, 0
1041  6826 DD 75 00     	ld	(ix), l
1042  6829 DD 74 01     	ld	(ix+1), h
1043  682C DD 22 96 7D  	ld	(FileBlocksIdxPos), ix
1044  6830
1045  6830              	;Read file header if not yet read.
1046  6830 DD 2A 90 7D  	ld		ix, (SelFileCache)
1047  6834 DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
1048  6837 B7           	or		a
1049  6838 CC 0F 6F     	call		z, ReadFileHeader
1050  683B
1051  683B              ViewFileNextBlock:
1052  683B 3A 93 7D     	ld		a, (ViewSelOption)
1053  683E
1054  683E FE 31        	cp		'1'
1055  6840 28 13        	jr		z, ViewFileAsText
1056  6842
1057  6842 FE 32        	cp		'2'
1058  6844 28 17        	jr		z, ViewFileAsHex
1059  6846
1060  6846              ViewFileAuto:
1061  6846              	;Decide how to display file, if auto mode.
1062  6846 DD 2A 90 7D  	ld		ix, (SelFileCache)
1063  684A DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1064  684D FE 00        	cp		PROG_TYPE
1065  684F 28 22        	jr		z, ViewFileAsBASIC
1066  6851
1067  6851 FE 03        	cp		BYTE_TYPE
1068  6853 28 08        	jr		z, ViewFileAsHex
1069  6855
1070  6855              ViewFileAsText:
1071  6855              	;If text file, load as much as possible to RAM.
1072  6855 06 5F        	ld		b, MAX_SECT_BUF * ViewFileConvertRatioText
1073  6857 CD EF 68     	call		ReadFileForViewing
1074  685A C3 97 68     	jp		ViewFileText
1075  685D
1076  685D              ViewFileAsHex:
1077  685D 06 13        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioHEX
1078  685F CD EF 68     	call		ReadFileForViewing
1079  6862 11 D8 9E     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioHEX
1080  6865 D5           	push		de
1081  6866 CD A4 6B     		call	Bin2HexStr
1082  6869 E1           	pop		hl
1083  686A              	;Determine lenght of hex print buffer.
1084  686A EB           	ex		de, hl
1085  686B B7           	or		a
1086  686C ED 52        	sbc		hl, de
1087  686E 44           	ld		b, h
1088  686F 4D           	ld		c, l
1089  6870 EB           	ex		de, hl
1090  6871 18 24        	jr		ViewFileText
1091  6873
1092  6873
1093  6873              ViewFileAsBASIC:
1094  6873 06 17        	ld		b, MAX_SECT_BUF/ViewFileConvertRatioBASIC		;Load half of available RAM with program bytecode, leave half for decoded text.
1095  6875 CD EF 68     	call		ReadFileForViewing
1096  6878              	;Read program length from header. Skip file header.
1097  6878 01 09 00     	ld		bc, HDR_SZ
1098  687B 09           	add		hl, bc
1099  687C DD 2A 90 7D  	ld		ix, (SelFileCache)
1100  6880 DD 4E 15     	ld		c, (ix + CACHE_HDR + HDR_PLEN)
1101  6883 DD 46 16     	ld		b, (ix + CACHE_HDR + HDR_PLEN + 1)
1102  6886 11 98 A3     	ld		de, FileData + MAX_SECT_BUF*SECT_SZ/ViewFileConvertRatioBASIC		;Store text of program after read block.
1103  6889 D5           	push		de
1104  688A CD C1 79     		call	BASIC2TXT
1105  688D D1           	pop		de
1106  688E              	;Get decoded text length
1107  688E 2A 93 7A     	ld		hl, (DestinationAddr)
1108  6891 B7           	or		a
1109  6892 ED 52        	sbc		hl, de
1110  6894 44           	ld		b, h
1111  6895 4D           	ld		c, l
1112  6896 EB           	ex		de, hl
1113  6897
1114  6897              ViewFileText:
1115  6897 E5           	push	hl
1116  6898 C5           	push	bc
1117  6899 CD 42 74     		call	ClrScr
1118  689C C1           	pop	bc
1119  689D E1           	pop	hl
1120  689E E5           	push	hl
1121  689F CD A9 76     		call	TextViewer
1122  68A2 E1           	pop	hl
1123  68A3
1124  68A3              ViewFileTextLoop:
1125  68A3 3A 08 5C     	ld	a, (LAST_K)
1126  68A6
1127  68A6 FE 30        	cp	'0'
1128  68A8 C8           	ret	z
1129  68A9
1130  68A9 FE 0B        	cp	KEY_UP
1131  68AB 20 22        	jr	nz, ViewFileTextLoopDown
1132  68AD
1133  68AD 3A 95 7D     	ld	a, (ViewFilePart)
1134  68B0 B7           	or	a
1135  68B1 28 F0        	jr	z, ViewFileTextLoop
1136  68B3
1137  68B3 3D           	dec	a
1138  68B4 32 95 7D     	ld	(ViewFilePart), a
1139  68B7
1140  68B7              	;Go back 1 block index.
1141  68B7 DD 2A 96 7D  	ld	ix, (FileBlocksIdxPos)
1142  68BB DD 2B        	dec	ix
1143  68BD DD 2B        	dec	ix
1144  68BF DD 6E 00     	ld	l, (ix)
1145  68C2 DD 66 01     	ld	h, (ix+1)
1146  68C5 22 9D 7D     	ld	(FilePosRead), hl
1147  68C8 DD 22 96 7D  	ld	(FileBlocksIdxPos), ix
1148  68CC C3 3B 68     	jp	ViewFileNextBlock
1149  68CF
1150  68CF
1151  68CF              ViewFileTextLoopDown:
1152  68CF FE 0A        	cp	KEY_DOWN
1153  68D1 20 D0        	jr	nz, ViewFileTextLoop
1154  68D3
1155  68D3 21 95 7D     	ld	hl, ViewFilePart
1156  68D6 34           	inc	(hl)
1157  68D7
1158  68D7              	;Save file index for when scrolling back.
1159  68D7 DD 2A 96 7D  	ld	ix, (FileBlocksIdxPos)
1160  68DB DD 23        	inc	ix
1161  68DD DD 23        	inc	ix
1162  68DF 2A 9D 7D     	ld	hl, (FilePosRead)
1163  68E2 DD 75 00     	ld	(ix), l
1164  68E5 DD 74 01     	ld	(ix+1), h
1165  68E8 DD 22 96 7D  	ld	(FileBlocksIdxPos), ix
1166  68EC C3 3B 68     	jp	ViewFileNextBlock
1167  68EF
1168  68EF
1169  68EF              ;Reads file section, as much as it fits in RAM for the type of output.
1170  68EF              ;Returns HL=start address and BC=length read.
1171  68EF              ;IN: B = how many sectors to read.
1172  68EF              ReadFileForViewing:
1173  68EF 2A 90 7D     	ld		hl, (SelFileCache)
1174  68F2 78           	ld		a, b
1175  68F3 32 94 7D     	ld		(ViewSectMax), a
1176  68F6 3A C1 6F     	ld 		a, (RWTSDrive)
1177  68F9 3C           	inc		a
1178  68FA CD 74 73     	call		ReadFileSection		;DE = last address read
1179  68FD
1180  68FD              	;Calculate size of read buffer.
1181  68FD D5           	push		de
1182  68FE 21 D8 8B     		ld		hl, FileData
1183  6901 EB           		ex		de, hl
1184  6902 B7           		or		a
1185  6903 ED 52        		sbc		hl, de
1186  6905 44           		ld		b, h
1187  6906 4D           		ld		c, l
1188  6907 D1           	pop		de
1189  6908
1190  6908              	;Check file type from header, to see if header exists or not.
1191  6908 DD 2A 90 7D  	ld		ix, (SelFileCache)
1192  690C DD 7E 10     	ld		a, (ix + CACHE_HDR + HDR_TYPE)
1193  690F FE 04        	cp		TEXT_TYPE
1194  6911 38 12        	jr		c, ReadFileForViewingNotText
1195  6913
1196  6913              	;Find EOF for text files and ajust lenght.
1197  6913 21 D8 8B     	ld		hl, FileData
1198  6916 50           	ld		d, b
1199  6917 59           	ld		e, c
1200  6918 3E 1A        	ld		a, CHAR_EOF
1201  691A ED B1        	cpir
1202  691C 20 01        	jr		nz, ReadFileForViewingNotFoundEOF
1203  691E 03           	inc		bc
1204  691F              ReadFileForViewingNotFoundEOF:
1205  691F B7           	or		a
1206  6920 EB           	ex		hl, de
1207  6921 ED 42        	sbc		hl, bc
1208  6923 44           	ld		b, h
1209  6924 4D           	ld		c, l
1210  6925
1211  6925              ReadFileForViewingNotText:
1212  6925 21 D8 8B     	ld		hl, FileData
1213  6928 C9           	ret
1214  6929
1215  6929
1216  6929              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1217  6929
1218  6929
1219  6929              DisplayFileInfo:
1220  6929 2A 90 7D     	ld		hl, (SelFileCache)
1221  692C E5           	push	hl
1222  692D              		;disk size - at least 2KB ==1  AU
1223  692D 01 0D 00     		ld		bc, CACHE_AU_CNT
1224  6930 09           		add		hl, bc
1225  6931 5E           		ld		e, (hl)
1226  6932 23           		inc		hl
1227  6933 56           		ld		d, (hl)
1228  6934 2B           		dec		hl
1229  6935 EB           		ex		de, hl
1230  6936              		;*2, since one block (AU) is 2KB.
1231  6936 CB 15        		rl	l
1232  6938 CB 14        		rl	h
1233  693A
1234  693A 11 9A 7B     		ld		de, MsgFileSzDskN
1235  693D CD E5 6A     		call	Word2Txt
1236  6940 21 91 7B     		ld		hl, MsgFileSzDsk
1237  6943 11 00 08     		ld		de, LST_FILE_INFO + 1 << 8
1238  6946 CD 62 74     		call	PrintStr
1239  6949 E1           	pop		hl
1240  694A E5           	push	hl
1241  694B              		;attributes
1242  694B 01 08 00     		ld		bc, CACHE_NAME + RO_POS
1243  694E 09           		add		hl, bc
1244  694F EB           		ex		de, hl
1245  6950 21 AA 7B     		ld		hl, MsgFileAttrN
1246  6953 1A           		ld		a, (de)
1247  6954 E6 80        		and		%10000000
1248  6956 28 10        		jr		z, NotRO
1249  6958
1250  6958 01 52 2F     		ld		bc, '/R'
1251  695B 71           		ld		(hl), c
1252  695C 23           		inc		hl
1253  695D 70           		ld		(hl), b
1254  695E 23           		inc		hl
1255  695F 01 4F 2C     		ld		bc, ',O'
1256  6962 71           		ld		(hl), c
1257  6963 23           		inc		hl
1258  6964 70           		ld		(hl), b
1259  6965 23           		inc		hl
1260  6966 18 0E        		jr		CheckSys
1261  6968              NotRO:
1262  6968 01 2D 2D     		ld		bc, '--'
1263  696B 71           		ld		(hl), c
1264  696C 23           		inc		hl
1265  696D 70           		ld		(hl), b
1266  696E 23           		inc		hl
1267  696F 01 2D 2C     		ld		bc, ',-'
1268  6972 71           		ld		(hl), c
1269  6973 23           		inc		hl
1270  6974 70           		ld		(hl), b
1271  6975 23           		inc		hl
1272  6976
1273  6976              CheckSys:
1274  6976 13           		inc		de
1275  6977 1A           		ld		a, (de)
1276  6978 E6 80        		and		%10000000
1277  697A 28 0C        		jr		z, NotSYS
1278  697C
1279  697C 01 48 49     		ld		bc, 'IH'
1280  697F 71           		ld		(hl), c
1281  6980 23           		inc		hl
1282  6981 70           		ld		(hl), b
1283  6982 23           		inc		hl
1284  6983 3E C4        		ld		a, 'D' + $80
1285  6985 77           		ld		(hl), a
1286  6986 18 0A        		jr		AttrEnd
1287  6988              NotSYS:
1288  6988 01 2D 2D     		ld		bc, '--'
1289  698B 71           		ld		(hl), c
1290  698C 23           		inc		hl
1291  698D 70           		ld		(hl), b
1292  698E 23           		inc		hl
1293  698F 3E AD        		ld		a, '-' + $80
1294  6991 77           		ld		(hl), a
1295  6992              AttrEnd:
1296  6992 11 00 09     		ld		de, LST_FILE_INFO + 2 << 8
1297  6995 21 A1 7B     		ld		hl, MsgFileAttr
1298  6998 CD 62 74     		call	PrintStr
1299  699B DD E1        	pop		ix
1300  699D DD E5        	push	ix
1301  699F DD 7E 0F     		ld		a, (ix + CACHE_FLAG)
1302  69A2 B7           		or		a
1303  69A3 CA 40 6A             jp		z, HeadNotRead
1304  69A6
1305  69A6 DD 7E 0B     		ld		a, (ix + CACHE_FIRST_AU)
1306  69A9 DD B6 0C     		or		(ix + CACHE_FIRST_AU + 1)
1307  69AC CA 40 6A             jp		z, HeadNotRead
1308  69AF
1309  69AF DD 7E 10     		ld		a, (ix + CACHE_HDR)
1310  69B2 FE 00        		cp		PROG_TYPE
1311  69B4 20 0B        		jr		nz, CheckNoArr
1312  69B6
1313  69B6 21 C4 7B     		ld		hl, MsgFileTypePrg
1314  69B9 11 BA 7B     		ld		de, MsgFileTypeN
1315  69BC CD 89 6A     		call	MoveMsg
1316  69BF 18 4F        		jr		PrepFileLen
1317  69C1
1318  69C1              CheckNoArr:
1319  69C1 FE 01        		cp		NUMB_TYPE
1320  69C3 20 0B        		jr		nz, CheckChrArr
1321  69C5
1322  69C5 21 E0 7B     		ld		hl, MsgFileTypeNoA
1323  69C8 11 BA 7B     		ld		de, MsgFileTypeN
1324  69CB CD 89 6A     		call	MoveMsg
1325  69CE 18 40        		jr		PrepFileLen
1326  69D0
1327  69D0              CheckChrArr:
1328  69D0 FE 02        		cp		CHAR_TYPE
1329  69D2 20 0B        		jr		nz, CheckByte
1330  69D4
1331  69D4 21 D9 7B     		ld		hl, MsgFileTypeChrA
1332  69D7 11 BA 7B     		ld		de, MsgFileTypeN
1333  69DA CD 89 6A     		call	MoveMsg
1334  69DD 18 31        		jr		PrepFileLen
1335  69DF
1336  69DF              CheckByte:
1337  69DF FE 03        		cp		BYTE_TYPE
1338  69E1 20 24        		jr		nz, CheckText
1339  69E3
1340  69E3 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1341  69E6 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1342  69E9 01 00 E5     		ld		bc, -SCR_LEN
1343  69EC 09           		add		hl, bc
1344  69ED 7C           		ld		a, h
1345  69EE B5           		or		l
1346  69EF 20 0B        		jr		nz, NotScr
1347  69F1
1348  69F1 21 D2 7B     		ld		hl, MsgFileTypeSCR
1349  69F4 11 BA 7B     		ld		de, MsgFileTypeN
1350  69F7 CD 89 6A     		call	MoveMsg
1351  69FA 18 14        		jr		PrepFileLen
1352  69FC              NotScr:
1353  69FC 21 CB 7B     		ld		hl, MsgFileTypeByte
1354  69FF 11 BA 7B     		ld		de, MsgFileTypeN
1355  6A02 CD 89 6A     		call	MoveMsg
1356  6A05 18 09        		jr		PrepFileLen
1357  6A07
1358  6A07              CheckText:
1359  6A07 21 E7 7B     		ld		hl, MsgFileTypeText
1360  6A0A 11 BA 7B     		ld		de, MsgFileTypeN
1361  6A0D CD 89 6A     		call	MoveMsg
1362  6A10
1363  6A10              PrepFileLen:
1364  6A10              		;File len
1365  6A10 DD 6E 11     		ld		l, (ix + CACHE_HDR + HDR_LEN)
1366  6A13 DD 66 12     		ld		h, (ix + CACHE_HDR + HDR_LEN + 1)
1367  6A16              PrepFileLenText:
1368  6A16 11 FE 7B     		ld		de, MsgFileLenN
1369  6A19 CD E5 6A     		call	Word2Txt
1370  6A1C 26 C2        		ld		h, 'B' | $80
1371  6A1E 2E 20        		ld		l, ' '
1372  6A20 22 03 7C     		ld		(MsgFileLenN + 5), hl
1373  6A23
1374  6A23 DD 7E 10     		ld		a, (ix + CACHE_HDR + HDR_TYPE)
1375  6A26 FE 00        		cp		PROG_TYPE
1376  6A28 28 06        		jr		z, PrintProgStart
1377  6A2A
1378  6A2A FE 03        		cp		BYTE_TYPE
1379  6A2C 28 0A        		jr		z, PrintByteStart
1380  6A2E
1381  6A2E 18 22        		jr		PrintStartNotRead
1382  6A30
1383  6A30              PrintProgStart:
1384  6A30 DD 6E 17     		ld		l, (ix + CACHE_HDR + HDR_LINE)
1385  6A33 DD 66 18     		ld		h, (ix + CACHE_HDR + HDR_LINE + 1)
1386  6A36 18 25        		jr		PrintStart
1387  6A38
1388  6A38              PrintByteStart:
1389  6A38 DD 6E 13     		ld		l, (ix + CACHE_HDR + HDR_ADDR)
1390  6A3B DD 66 14     		ld		h, (ix + CACHE_HDR + HDR_ADDR + 1)
1391  6A3E 18 1D        		jr		PrintStart
1392  6A40
1393  6A40              HeadNotRead:
1394  6A40 21 EE 7B             ld        hl, MsgNA
1395  6A43 11 BA 7B             ld        de, MsgFileTypeN
1396  6A46 CD 89 6A             call    MoveMsg
1397  6A49
1398  6A49 21 EE 7B     		ld		hl, MsgNA
1399  6A4C 11 FE 7B     		ld		de, MsgFileLenN
1400  6A4F CD 89 6A     		call	MoveMsg
1401  6A52
1402  6A52              PrintStartNotRead:
1403  6A52 21 EE 7B     		ld		hl, MsgNA
1404  6A55 11 0E 7C     		ld		de, MsgFileStartN
1405  6A58 CD 89 6A     		call	MoveMsg
1406  6A5B 18 0E        		jr		PrintStartStr
1407  6A5D
1408  6A5D              PrintStart:
1409  6A5D 1E 20        	ld		e, ' '
1410  6A5F 16 A0        	ld		d, ' ' | $80
1411  6A61 ED 53 13 7C  	ld		(MsgFileStartN + 5), de
1412  6A65 11 0E 7C     	ld		de, MsgFileStartN
1413  6A68 CD E5 6A     	call	Word2Txt
1414  6A6B              PrintStartStr:
1415  6A6B 11 00 0B     	ld		de, LST_FILE_INFO + 4 << 8
1416  6A6E 21 05 7C     	ld		hl, MsgFileStart
1417  6A71 CD 62 74     	call	PrintStr
1418  6A74
1419  6A74 DD E1        	pop		ix
1420  6A76 11 00 0A     	ld		de, LST_FILE_INFO + 3 << 8
1421  6A79 21 B1 7B     	ld		hl, MsgFileType
1422  6A7C CD 62 74     	call	PrintStr
1423  6A7F
1424  6A7F 11 00 0C     	ld		de, LST_FILE_INFO + 5 << 8
1425  6A82 21 F5 7B     	ld		hl, MsgFileLen
1426  6A85 CD 62 74     	call	PrintStr
1427  6A88
1428  6A88 C9           	ret
1429  6A89
1430  6A89              MoveMsg:
1431  6A89 01 07 00     	ld		bc, 7
1432  6A8C ED B0        	ldir
1433  6A8E C9           	ret
1434  6A8F
1435  6A8F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1436  6A8F
1437  6A8F              ReadAllHeaders:
1438  6A8F 21 15 7C     	ld		hl, MsgReadingExt
1439  6A92 11 00 0E     	ld		de, LST_LINE_MSG+1 << 8
1440  6A95 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
1441  6A97 CD 8A 74     	call	PrintStrClr
1442  6A9A
1443  6A9A CD 4B 63     	call	CalcFileCache
1444  6A9D
1445  6A9D 3A 89 7D     	ld		a, (SelFile)
1446  6AA0 47           	ld		b, a
1447  6AA1 3A 87 7D     	ld		a, (FileCnt)
1448  6AA4 90           	sub		b
1449  6AA5 B7           	or		a
1450  6AA6 C8           	ret		z
1451  6AA7
1452  6AA7 47           	ld		b, a
1453  6AA8
1454  6AA8 DD 2A 90 7D  	ld		ix, (SelFileCache)
1455  6AAC              NextFile:
1456  6AAC C5           	push	bc
1457  6AAD CD 0F 6F     		call	ReadFileHeader
1458  6AB0 01 19 00     		ld		bc, CACHE_SZ
1459  6AB3 DD 09        		add		ix, bc
1460  6AB5 DD E5        		push	ix
1461  6AB7 CD 4B 63     			call	CalcFileCache
1462  6ABA CD 29 69     			call	DisplayFileInfo
1463  6ABD DD E1        		pop		ix
1464  6ABF
1465  6ABF CD 29 74     		call	KbdHit
1466  6AC2 38 03        		jr		c, AKey
1467  6AC4 C1           	pop		bc
1468  6AC5 18 15        	jr		ReadAllHeadersEnd
1469  6AC7
1470  6AC7              AKey:
1471  6AC7 3A 89 7D     		ld		a, (SelFile)
1472  6ACA 3C           		inc		a
1473  6ACB 47           		ld		b, a
1474  6ACC 3A 87 7D     		ld		a, (FileCnt)
1475  6ACF B8           		cp		b
1476  6AD0 28 10        		jr		z, DontInc
1477  6AD2 78           		ld		a, b
1478  6AD3 32 89 7D     		ld		(SelFile), a
1479  6AD6 CD 56 75     		call	MoveCursor
1480  6AD9 C1           	pop		bc
1481  6ADA 10 D0        	djnz	NextFile
1482  6ADC
1483  6ADC              ReadAllHeadersEnd:
1484  6ADC 06 01        	ld		b, 1
1485  6ADE CD 0E 76     	call	ClearNMsgLines
1486  6AE1 C9           	ret
1487  6AE2
1488  6AE2              DontInc:
1489  6AE2 C1           	pop		bc
1490  6AE3 18 F7        	jr		ReadAllHeadersEnd
1491  6AE5
1492  6AE5
1493  6AE5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1494  6AE5
1495  6AE5              	include "hccfg.asm"
# file opened: hccfg.asm
   1+ 6AE5              	ifndef	_HCCFG_
   2+ 6AE5              	define	_HCCFG_
   3+ 6AE5
   4+ 6AE5              ;HC specific code, for configuration
   5+ 6AE5
   6+ 6AE5              HC_CFG_PORT			EQU	$7E
   7+ 6AE5              HC_FLOPPY_PORT		EQU 7
   8+ 6AE5
   9+ 6AE5              ;BASIC/CPM ROM selection
  10+ 6AE5              HC_CFG_ROM_BAS		EQU	%0
  11+ 6AE5              HC_CFG_ROM_CPM		EQU	%1
  12+ 6AE5
  13+ 6AE5              ;Address for ROM paging: 0 or $E000
  14+ 6AE5              HC_CFG_ROM_0000		EQU %00
  15+ 6AE5              HC_CFG_ROM_E000		EQU %10
  16+ 6AE5
  17+ 6AE5              ;Cfg. port Enable/Disable
  18+ 6AE5              HC_CFG_PORT_DIS		EQU %000
  19+ 6AE5              HC_CFG_PORT_EN		EQU	%100
  20+ 6AE5
  21+ 6AE5              ;Video memory bank: $4000 or $C000
  22+ 6AE5              HC_CFG_VID_4000		EQU	%0000
  23+ 6AE5              HC_CFG_VID_C000		EQU	%1000
  24+ 6AE5
  25+ 6AE5
  26+ 6AE5              ;Standar BASIC config
  27+ 6AE5              HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28+ 6AE5              ;Standar CP/M config
  29+ 6AE5              HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30+ 6AE5
  31+ 6AE5
  32+ 6AE5              HC_VID_BANK0		EQU	$4000
  33+ 6AE5              HC_VID_BANK1		EQU	$C000
  34+ 6AE5
  35+ 6AE5              ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36+ 6AE5              ;Info from Rares Atodiresei.
  37+ 6AE5              IsDrive2_80Tracks:
  38+ 6AE5              	IFUSED
  39+ 6AE5 ~            	in	a, (HC_FLOPPY_PORT)
  40+ 6AE5 ~            	and %10
  41+ 6AE5 ~            	ret
  42+ 6AE5              	ENDIF
  43+ 6AE5
  44+ 6AE5              	endif
# file closed: hccfg.asm
1496  6AE5              	include "if1.asm"
# file opened: if1.asm
   1+ 6AE5              ;HC IF1 routines and constants
   2+ 6AE5
   3+ 6AE5              ;IF1 routines error codes, also returned by BASIC commands
   4+ 6AE5              ;12 = Writing to a 'read' file
   5+ 6AE5              ;13 = Reading a 'write' file
   6+ 6AE5              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7+ 6AE5              ;15 = Disk full (disk or catalog full)
   8+ 6AE5              ;16 = Disk error (hardware error)
   9+ 6AE5              ;17 = File not found
  10+ 6AE5              ;23 = Disk R/O (disk change detected, software R/O)
  11+ 6AE5              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12+ 6AE5
  13+ 6AE5              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14+ 6AE5              ;00h = OK
  15+ 6AE5              ;08h = cannot format disk
  16+ 6AE5              ;10h = disk protected (read-only?)
  17+ 6AE5              ;20h = volume error
  18+ 6AE5              ;40h = drive error
  19+ 6AE5              ;80h = reading error
  20+ 6AE5              ;Codes I encountered:
  21+ 6AE5              ;04h = a CP/M disk was inserted instead of a BASIC one
  22+ 6AE5
  23+ 6AE5
  24+ 6AE5              	ifndef	_DISK_
  25+ 6AE5              	define	_DISK_
  26+ 6AE5
  27+ 6AE5              	include	"math.asm"
# file opened: math.asm
   1++6AE5              	ifndef	_MATH_
   2++6AE5              	define	_MATH_
   3++6AE5
   4++6AE5              ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++6AE5              ;http://map.tni.nl/sources/external/z80bits.html
   6++6AE5
   7++6AE5
   8++6AE5              Word2Txt:
   9++6AE5              	IFUSED
  10++6AE5 D5           	push	de
  11++6AE6 CD 06 6B     		call	Word2Txt_
  12++6AE9 D1           	pop	de
  13++6AEA
  14++6AEA 06 04        	ld	b, 4
  15++6AEC CD FB 6A     	call	StrippLeading0
  16++6AEF C9           	ret
  17++6AF0
  18++6AF0              Byte2Txt:
  19++6AF0 D5           	push	de
  20++6AF1 CD 12 6B     		call	Byte2Txt_
  21++6AF4 D1           	pop	de
  22++6AF5
  23++6AF5 06 02        	ld	b, 2
  24++6AF7 CD FB 6A     	call	StrippLeading0
  25++6AFA C9           	ret
  26++6AFB              	ENDIF
  27++6AFB
  28++6AFB
  29++6AFB              StrippLeading0:
  30++6AFB 1A           	ld	a, (de)
  31++6AFC FE 31        	cp	'1'
  32++6AFE D0           	ret	nc
  33++6AFF
  34++6AFF 3E 20        	ld	a, ' '
  35++6B01 12           	ld	(de), a
  36++6B02 13           	inc	de
  37++6B03 10 F6        	djnz	StrippLeading0
  38++6B05 C9           	ret
  39++6B06
  40++6B06
  41++6B06              ;Converts the number in HL to ASCII in decimal string at DE
  42++6B06              Word2Txt_:
  43++6B06 01 F0 D8     	ld bc, -10000
  44++6B09 CD 21 6B     	call DigitLoop
  45++6B0C 01 18 FC     	ld bc, -1000
  46++6B0F CD 21 6B     	call DigitLoop
  47++6B12              Byte2Txt_:
  48++6B12 01 9C FF     	ld bc, -100
  49++6B15 CD 21 6B     	call DigitLoop
  50++6B18 01 F6 FF     	ld bc, -10
  51++6B1B CD 21 6B     	call DigitLoop
  52++6B1E 01 FF FF     	ld bc, -1
  53++6B21
  54++6B21              DigitLoop:
  55++6B21 3E 2F        	ld	a, '0' - 1
  56++6B23              DivNrLoop:
  57++6B23 3C           	inc	a		;increase reminder
  58++6B24 09           	add	hl, bc	;substract divizor
  59++6B25 38 FC        	jr	c, DivNrLoop	;still dividing?
  60++6B27 ED 42        	sbc	hl, bc	;nope, restore
  61++6B29
  62++6B29 12           	ld (de), a
  63++6B2A 13           	inc de
  64++6B2B C9           	ret
  65++6B2C
  66++6B2C
  67++6B2C              ;Input: HL = Dividend, C = Divisor
  68++6B2C              ;Output: HL = Quotient, A = Remainder
  69++6B2C              ;Warning: doesn't work with divisor >= $80
  70++6B2C              Div:
  71++6B2C              	IFUSED
  72++6B2C AF           	xor a
  73++6B2D 06 10        	ld b, 16
  74++6B2F
  75++6B2F              DivLoop:
  76++6B2F 29           	add	hl,hl
  77++6B30 17           	rla
  78++6B31 B9           	cp	c
  79++6B32 38 02        	jr	c, NoSub
  80++6B34 91           	sub	c
  81++6B35 2C           	inc	l
  82++6B36              NoSub:
  83++6B36 10 F7        	djnz DivLoop
  84++6B38
  85++6B38 C9           	ret
  86++6B39              	ENDIF
  87++6B39
  88++6B39              ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++6B39              ;Output: A:C = Quotient, HL = Remainder
  90++6B39              Div2:
  91++6B39 21 00 00     	ld hl, 0
  92++6B3C 06 10        	ld b, 16
  93++6B3E              Div2Loop:
  94++6B3E CB 31        	sll c	; unroll 16 times
  95++6B40 17           	rla		; ...
  96++6B41 ED 6A        	adc	hl,hl	; ...
  97++6B43 ED 52        	sbc	hl,de	; ...
  98++6B45 30 02        	jr	nc,$+4	; ...
  99++6B47 19           	add	hl,de	; ...
 100++6B48 0D           	dec	c	; ...
 101++6B49 10 F3        	djnz Div2Loop
 102++6B4B C9           	ret
 103++6B4C
 104++6B4C
 105++6B4C              ;Input: A = Multiplier, DE = Multiplicand
 106++6B4C              ;Output: A:HL = Product
 107++6B4C              Mul:
 108++6B4C              	IFUSED
 109++6B4C 21 00 00     	ld hl, 0
 110++6B4F 01 00 07     	ld bc, $0700
 111++6B52
 112++6B52 87           	add	a, a	; optimised 1st iteration
 113++6B53 30 02        	jr	nc, MulLoop
 114++6B55 62           	ld	h, d
 115++6B56 6B           	ld	l, e
 116++6B57
 117++6B57              MulLoop:
 118++6B57 29           	add	hl,hl
 119++6B58 17           	rla
 120++6B59 30 02        	jr	nc, NoAdd
 121++6B5B 19           	add	hl,de
 122++6B5C 89           	adc	a,c
 123++6B5D              NoAdd:
 124++6B5D 10 F8        	djnz MulLoop
 125++6B5F
 126++6B5F C9           	ret
 127++6B60              	ENDIF
 128++6B60
 129++6B60
 130++6B60              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++6B60              ;IN: HL=address to read, DE=output address	for 2 chars
 132++6B60              Byte2Hex:
 133++6B60 AF           	xor	a
 134++6B61 ED 6F        	rld
 135++6B63 CD 66 6B     	call	Byte2HexNibble
 136++6B66
 137++6B66              Byte2HexNibble:
 138++6B66 F5           	push	af
 139++6B67 27           	daa
 140++6B68 C6 F0        	add	a,$F0
 141++6B6A CE 40        	adc	a,$40
 142++6B6C
 143++6B6C 12           	ld	(de), a
 144++6B6D 13           	inc	de
 145++6B6E
 146++6B6E F1           	pop	af
 147++6B6F ED 6F        	rld
 148++6B71 C9           	ret
 149++6B72
 150++6B72
 151++6B72              Byte2HexHex:
 152++6B72 CD 60 6B     	call	Byte2Hex
 153++6B75 23           	inc	hl
 154++6B76 3E 20        	ld	a, ' '
 155++6B78 12           	ld	(de), a
 156++6B79 13           	inc	de
 157++6B7A C9           	ret
 158++6B7B
 159++6B7B              Byte2HexChar:
 160++6B7B 3E 0D        	ld	a, CHAR_CR
 161++6B7D BE           	cp	(hl)
 162++6B7E 20 03        	jr	nz, Bin2HexLineLoopTextCopy
 163++6B80
 164++6B80              Bin2HexLineLoopTextReplace:
 165++6B80 3E 2E        	ld	a, '.'
 166++6B82 77           	ld	(hl), a
 167++6B83
 168++6B83              Bin2HexLineLoopTextCopy:
 169++6B83 ED A0        	ldi
 170++6B85 C9           	ret
 171++6B86
 172++6B86
 173++6B86              HEX_COLUMNS	EQU	16
 174++6B86
 175++6B86              Bin2HexLine:
 176++6B86              	;Hex part
 177++6B86 06 10        	ld	b, HEX_COLUMNS
 178++6B88 E5           	push	hl
 179++6B89              Bin2HexLineLoopHex:
 180++6B89 CD 72 6B     		call	Byte2HexHex
 181++6B8C 10 FB        		djnz	Bin2HexLineLoopHex
 182++6B8E E1           	pop	hl
 183++6B8F
 184++6B8F 1B           	dec	de
 185++6B90 3E 80        	ld	a, CHR_V
 186++6B92 12           	ld	(de), a
 187++6B93 13           	inc	de
 188++6B94
 189++6B94 DD 62        	ld	ixh, d
 190++6B96 DD 6B        	ld	ixl, e
 191++6B98 DD 77 E7     	ld	(ix - (HEX_COLUMNS/2)*3 - 1), a
 192++6B9B
 193++6B9B              	;String part
 194++6B9B              Bin2HexLineText:
 195++6B9B              	;just to not alter B with LDI, set C to something > 16
 196++6B9B 01 20 10     	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 197++6B9E              Bin2HexLineLoopText:
 198++6B9E CD 7B 6B     	call	Byte2HexChar
 199++6BA1 10 FB        	djnz	Bin2HexLineLoopText
 200++6BA3 C9           	ret
 201++6BA4
 202++6BA4
 203++6BA4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 204++6BA4              ;Converts binary buffer at HL to hex string at DE
 205++6BA4              Bin2HexStr:
 206++6BA4              	;Calculate the number of full lines by dividing BC to 16.
 207++6BA4 AF           	xor	a
 208++6BA5
 209++6BA5 CB 18        	rr	b
 210++6BA7 CB 19        	rr	c
 211++6BA9 1F           	rra
 212++6BAA
 213++6BAA CB 18        	rr	b
 214++6BAC CB 19        	rr	c
 215++6BAE 1F           	rra
 216++6BAF
 217++6BAF CB 18        	rr	b
 218++6BB1 CB 19        	rr	c
 219++6BB3 1F           	rra
 220++6BB4
 221++6BB4 CB 18        	rr	b
 222++6BB6 CB 19        	rr	c
 223++6BB8 1F           	rra
 224++6BB9
 225++6BB9 1F           	rra
 226++6BBA 1F           	rra
 227++6BBB 1F           	rra
 228++6BBC 1F           	rra
 229++6BBD
 230++6BBD 08           	ex		af, af'		;Keep reminder
 231++6BBE
 232++6BBE              Bin2HexStrLoop:
 233++6BBE C5           	push	bc
 234++6BBF CD 86 6B     		call	Bin2HexLine
 235++6BC2 C1           	pop	bc
 236++6BC3
 237++6BC3 0B           	dec	bc
 238++6BC4 78           	ld	a, b
 239++6BC5 B1           	or	c
 240++6BC6 20 F6        	jr	nz, Bin2HexStrLoop
 241++6BC8
 242++6BC8              	;Set remaining imcomplete line.
 243++6BC8              	;Exit if last line is empty.
 244++6BC8 08           	ex	af, af'
 245++6BC9 B7           	or	a
 246++6BCA C8           	ret	z
 247++6BCB 08           	ex	af, af'
 248++6BCC
 249++6BCC              	;Clear the whole last line.
 250++6BCC D5           	push	de
 251++6BCD E5           	push	hl
 252++6BCE 3E 20        		ld	a, ' '
 253++6BD0 06 40        		ld	b, COL_CNT
 254++6BD2              Bin2HexLineClear:
 255++6BD2 12           		ld	(de), a
 256++6BD3 13           		inc	de
 257++6BD4 10 FC        		djnz	Bin2HexLineClear
 258++6BD6 E1           	pop	hl
 259++6BD7 D1           	pop	de
 260++6BD8
 261++6BD8              	;Save start of last line.
 262++6BD8 D5           	push	de
 263++6BD9 DD E1        	pop	ix
 264++6BDB DD E5        	push	ix
 265++6BDD
 266++6BDD              	;Save start of char part in IX.
 267++6BDD 01 30 00     	ld	bc, HEX_COLUMNS*3
 268++6BE0 DD 09        	add	ix, bc
 269++6BE2
 270++6BE2              	;Write the hex and char parts of line.
 271++6BE2 08           	ex	af, af'
 272++6BE3 47           	ld	b, a
 273++6BE4 0E 20        	ld	c, HEX_COLUMNS*2
 274++6BE6
 275++6BE6              Bin2HexLineLoopHex2:
 276++6BE6 CD 72 6B     	call	Byte2HexHex
 277++6BE9 2B           	dec	hl
 278++6BEA
 279++6BEA D5           	push	de
 280++6BEB DD 5D        		ld	e, ixl
 281++6BED DD 54        		ld	d, ixh
 282++6BEF 0E 01        		ld	c, 1
 283++6BF1 CD 7B 6B     		call	Byte2HexChar
 284++6BF4 D1           	pop	de
 285++6BF5
 286++6BF5 DD 23        	inc	ix
 287++6BF7 10 ED        	djnz	Bin2HexLineLoopHex2
 288++6BF9
 289++6BF9              	;Save end of buffer in DE, to let the caller know where the buffer ends.
 290++6BF9 DD 5D        	ld	e, ixl
 291++6BFB DD 54        	ld	d, ixh
 292++6BFD
 293++6BFD DD E1        	pop	ix
 294++6BFF              	;Write delimiters.
 295++6BFF 3E 80        	ld	a, CHR_V
 296++6C01 DD 77 17     	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 297++6C04 DD 77 2F     	ld	(ix + HEX_COLUMNS*3 - 1), a
 298++6C07
 299++6C07 C9           	ret
 300++6C08
 301++6C08              	endif
# file closed: math.asm
  28+ 6C08
  29+ 6C08              DRIVE_CUR_BAS	EQU 0
  30+ 6C08              DRIVE_A_BAS		EQU	1
  31+ 6C08              DRIVE_B_BAS		EQU	2
  32+ 6C08              DRIVE_A_CPM		EQU	0
  33+ 6C08              DRIVE_B_CPM		EQU	1
  34+ 6C08              ;Disk geometry stuff
  35+ 6C08              SPT				EQU	16			;sectors per track
  36+ 6C08              SECT_SZ			EQU	256			;sector size in bytes
  37+ 6C08              TRACK_CNT		EQU	80			;track count
  38+ 6C08              HEAD_CNT		EQU	2			;disk face count
  39+ 6C08              AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40+ 6C08              EXT_SZ			EQU	32			;directory entry size
  41+ 6C08              DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42+ 6C08              EXT_AU_CNT		EQU 8			;allocation units in one extension
  43+ 6C08              SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44+ 6C08              MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45+ 6C08              MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46+ 6C08              REC_SZ			EQU 128			;cp/m record size
  47+ 6C08              DEL_MARKER		EQU	$E5
  48+ 6C08
  49+ 6C08
  50+ 6C08              ;Extension structure (directory entry)
  51+ 6C08              EXT_DEL_FLAG	EQU	0
  52+ 6C08              EXT_NAME		EQU 1
  53+ 6C08              EXT_IDX			EQU 12
  54+ 6C08              EXT_S1			EQU 13
  55+ 6C08              EXT_S2			EQU 14
  56+ 6C08              EXT_RC			EQU	15
  57+ 6C08              EXT_AU0			EQU	16
  58+ 6C08              EXT_AU1			EQU	18
  59+ 6C08              EXT_AU2			EQU	20
  60+ 6C08              EXT_AU3			EQU	22
  61+ 6C08              EXT_AU4			EQU	24
  62+ 6C08              EXT_AU5			EQU	26
  63+ 6C08              EXT_AU6			EQU	28
  64+ 6C08              EXT_AU7			EQU	30
  65+ 6C08              EXT_SIZE		EQU 32
  66+ 6C08
  67+ 6C08              ;FCB structure
  68+ 6C08              FCB_DRIVE		EQU 0
  69+ 6C08              FCB_NAME		EQU EXT_NAME
  70+ 6C08              FCB_EX_IDX		EQU EXT_IDX
  71+ 6C08              FCB_S1			EQU EXT_S1
  72+ 6C08              FCB_S2			EQU EXT_S2
  73+ 6C08              FCB_RC			EQU	EXT_RC
  74+ 6C08              FCB_AU			EQU	EXT_AU0
  75+ 6C08              FCB_CR			EQU	32
  76+ 6C08              FCB_R0			EQU 33
  77+ 6C08              FCB_R1			EQU 34
  78+ 6C08              FCB_R2			EQU 35
  79+ 6C08              FCB_SIZE		EQU 36
  80+ 6C08
  81+ 6C08
  82+ 6C08
  83+ 6C08              ;System variables for disk
  84+ 6C08              DSTR1			EQU	$5CD6		;drive
  85+ 6C08              FSTR1			EQU	$5CDC		;file name
  86+ 6C08              NSTR1			EQU	$5CDA		;name length
  87+ 6C08              HD11			EQU	$5CED		;BDOS argument
  88+ 6C08              COPIES			EQU	$5CEF		;BDOS function
  89+ 6C08
  90+ 6C08              ERRSP			EQU $5C3D
  91+ 6C08              ERRNR			EQU $5C3A
  92+ 6C08              ERRMSG			EQU	$0260
  93+ 6C08
  94+ 6C08              PROG			EQU $5C53
  95+ 6C08              VARS			EQU	$5C4B
  96+ 6C08              STKEND			EQU	$5C65
  97+ 6C08
  98+ 6C08              PRN_BUF			EQU	23296
  99+ 6C08
 100+ 6C08              REPDEL			EQU	23561
 101+ 6C08              REPPER			EQU	23562
 102+ 6C08              PIP			EQU	23609
 103+ 6C08              LAST_K			EQU	$5C08
 104+ 6C08
 105+ 6C08
 106+ 6C08              ;RWTS routine commands
 107+ 6C08              RWTS_CMD_SEEK	EQU	0			;position head
 108+ 6C08              RWTS_CMD_READ	EQU	1			;read sector
 109+ 6C08              RWTS_CMD_WRITE	EQU	2			;write sector
 110+ 6C08              RWTS_CMD_FMT	EQU	4			;format all tracks
 111+ 6C08
 112+ 6C08
 113+ 6C08              ;File name stuff
 114+ 6C08              NAMELEN			EQU	11			;name length
 115+ 6C08              RO_POS			EQU	8			;read-only attribute position in name
 116+ 6C08              SYS_POS			EQU	9			;system attribute position in name
 117+ 6C08
 118+ 6C08              ;File types (first byte in header)
 119+ 6C08              PROG_TYPE		EQU	0			;program
 120+ 6C08              NUMB_TYPE		EQU	1			;number array
 121+ 6C08              CHAR_TYPE		EQU	2			;char array
 122+ 6C08              BYTE_TYPE		EQU	3			;bytes
 123+ 6C08              TEXT_TYPE		EQU	4			;text, >= 4
 124+ 6C08
 125+ 6C08              ;File header offsets
 126+ 6C08              HDR_TYPE		EQU	0
 127+ 6C08              HDR_LEN			EQU 1
 128+ 6C08              HDR_ADDR		EQU 3
 129+ 6C08              HDR_PLEN		EQU	5
 130+ 6C08              HDR_LINE		EQU 7
 131+ 6C08              HDR_SZ			EQU	9
 132+ 6C08
 133+ 6C08              ;BASIC disk channel structure
 134+ 6C08              CH_RW_FLAG		EQU 11
 135+ 6C08              CH_FCB			EQU	12
 136+ 6C08              CH_DATA			EQU	50
 137+ 6C08              CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 138+ 6C08
 139+ 6C08              CACHE_NAME		EQU	0					;11B
 140+ 6C08              CACHE_FIRST_AU	EQU	NAMELEN				;2B
 141+ 6C08              CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 142+ 6C08              CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 143+ 6C08              CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 144+ 6C08              CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 145+ 6C08
 146+ 6C08              LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 147+ 6C08
 148+ 6C08              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 149+ 6C08              IF1Init:
 150+ 6C08 CF           	rst		08
 151+ 6C09 31           	defb	49		;create system variables
 152+ 6C0A C9           	ret
 153+ 6C0B
 154+ 6C0B              ;ReadWriteTrackSector
 155+ 6C0B              ;A=command: 0, 1, 2, 4
 156+ 6C0B              RWTS:
 157+ 6C0B 32 CB 6F     	ld (RWTSCmd), a
 158+ 6C0E 21 C0 6F     	ld hl, RWTSParams
 159+ 6C11 22 ED 5C     	ld (HD11), hl
 160+ 6C14 CF           	rst 08
 161+ 6C15 3A           	DEFB 58
 162+ 6C16 C9           	ret
 163+ 6C17
 164+ 6C17
 165+ 6C17              ;D = sector, E = track
 166+ 6C17              ;HL = dma
 167+ 6C17              ReadOneDiskSector:
 168+ 6C17 22 C5 6F     	ld (RWTSDMA), hl
 169+ 6C1A ED 53 C3 6F  	ld (RWTSTrack), de
 170+ 6C1E              	;ld (RWTSDrive), a
 171+ 6C1E 3E 01        	ld a, RWTS_CMD_READ
 172+ 6C20 18 E9        	jr	RWTS
 173+ 6C22
 174+ 6C22              ;D = sector, E = track
 175+ 6C22              ;HL = dma
 176+ 6C22              WriteOneDiskSector:
 177+ 6C22 22 C5 6F     	ld (RWTSDMA), hl
 178+ 6C25 ED 53 C3 6F  	ld (RWTSTrack), de
 179+ 6C29              	;ld (RWTSDrive), a
 180+ 6C29 3E 02        	ld a, RWTS_CMD_WRITE
 181+ 6C2B 18 DE        	jr	RWTS
 182+ 6C2D
 183+ 6C2D              FormatDisk:
 184+ 6C2D 21 D8 8B     	ld		hl, DataBuf
 185+ 6C30 36 E5        	ld		(hl), DEL_MARKER
 186+ 6C32 22 C5 6F     	ld 		(RWTSDMA), hl
 187+ 6C35 3E 04        	ld 		a, RWTS_CMD_FMT
 188+ 6C37 CD 0B 6C     	call	RWTS
 189+ 6C3A 3A CC 6F     	ld		a, (RWTSRes)
 190+ 6C3D C9           	ret
 191+ 6C3E
 192+ 6C3E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193+ 6C3E
 194+ 6C3E              ;Allocation unit no. to track/sector
 195+ 6C3E              ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 196+ 6C3E              ;IN:  HL=alloc. unit no.
 197+ 6C3E              ;OUT: B=sector; C=track (head is determined by the sector number)
 198+ 6C3E              AU2TS:
 199+ 6C3E 0E 02        	ld c, SPT/SPAL
 200+ 6C40 CD 2C 6B     	call Div					;A = sector
 201+ 6C43 F5           	push af
 202+ 6C44 ~            		/*
 203+ 6C44 ~            		ld c, HEAD_CNT
 204+ 6C44 ~            		call Div				;L = track, A = head (0 or 1)
 205+ 6C44 ~            		*/
 206+ 6C44 AF           		xor a
 207+ 6C45 CB 1C        		rr h
 208+ 6C47 CB 1D        		rr l
 209+ 6C49 CB 1F        		rr a
 210+ 6C4B
 211+ 6C4B 4D           		ld c, l
 212+ 6C4C 06 00        		ld b, 0
 213+ 6C4E B7           		or a
 214+ 6C4F 28 02        		jr z, Track0
 215+ 6C51 06 10        		ld b, SPT
 216+ 6C53              Track0:
 217+ 6C53 F1           	pop af
 218+ 6C54 B7           	or a
 219+ 6C55 28 02        	jr z, FirstAU
 220+ 6C57 3E 08        	ld a, SPAL
 221+ 6C59              FirstAU:
 222+ 6C59 80           	add a, b
 223+ 6C5A 47           	ld  b, a
 224+ 6C5B C9           	ret
 225+ 6C5C
 226+ 6C5C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 227+ 6C5C
 228+ 6C5C              ;Checks the allocation units number used in extension
 229+ 6C5C              ;IN:	IX = extension addr
 230+ 6C5C              ;OUT:	B = no. of allocation units used
 231+ 6C5C              ;		C = no. of records used in ext.
 232+ 6C5C              ;		HL = first alloc. unit no.
 233+ 6C5C              ;		DE = last alloc. unit no.
 234+ 6C5C              CheckExtAlloc:
 235+ 6C5C DD E5        	push ix
 236+ 6C5E 01 0F 00     		ld bc, EXT_RC
 237+ 6C61 DD 09        		add ix, bc
 238+ 6C63 DD 4E 00     		ld c, (ix)			;save rec. no.
 239+ 6C66 DD 23        		inc ix
 240+ 6C68 DD 6E 00     		ld l, (ix)
 241+ 6C6B DD 66 01     		ld h, (ix + 1)
 242+ 6C6E 06 08        		ld b, EXT_AU_CNT
 243+ 6C70              CheckAU:
 244+ 6C70 DD 7E 00     		ld a, (ix)
 245+ 6C73 DD B6 01     		or (ix + 1)
 246+ 6C76 28 0C        		jr z, CheckAUEnd
 247+ 6C78 DD 5E 00     		ld e, (ix)
 248+ 6C7B DD 56 01     		ld d, (ix + 1)
 249+ 6C7E DD 23        		inc ix
 250+ 6C80 DD 23        		inc ix
 251+ 6C82 10 EC        		djnz CheckAU
 252+ 6C84              CheckAUEnd:
 253+ 6C84 3E 08        		ld a, EXT_AU_CNT
 254+ 6C86 90           		sub b
 255+ 6C87 47           		ld b, a
 256+ 6C88 DD E1        	pop ix
 257+ 6C8A C9           	ret
 258+ 6C8B
 259+ 6C8B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 260+ 6C8B
 261+ 6C8B              ;Input: TrackBuffer
 262+ 6C8B              ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 263+ 6C8B              ReadUsedBlocksList:
 264+ 6C8B DD 21 D8 8B  	ld		ix, TrackBuf			;source buffer
 265+ 6C8F 21 EE 85     	ld		hl, UsedBlockListCnt 	;destination buffer
 266+ 6C92 ED 4B 8E 7D  	ld		bc, (AUCntMaxFree)		;loop counter
 267+ 6C96 11 02 00     	ld		de, 2					;counter of used blocks, start with 2
 268+ 6C99 73           	ld		(hl), e
 269+ 6C9A 23           	inc		hl
 270+ 6C9B 72           	ld		(hl), d
 271+ 6C9C 23           	inc		hl
 272+ 6C9D
 273+ 6C9D              	;Add blocks 0 and 1 for directory
 274+ 6C9D 11 00 00     	ld		de, 0
 275+ 6CA0 73           	ld		(hl), e
 276+ 6CA1 23           	inc		hl
 277+ 6CA2 72           	ld		(hl), d
 278+ 6CA3 23           	inc		hl
 279+ 6CA4
 280+ 6CA4 13           	inc		de
 281+ 6CA5 73           	ld		(hl), e
 282+ 6CA6 23           	inc		hl
 283+ 6CA7 72           	ld		(hl), d
 284+ 6CA8 23           	inc		hl
 285+ 6CA9
 286+ 6CA9              ReadUsedBlocksLoop:
 287+ 6CA9 AF           	xor		a
 288+ 6CAA DD BE 00     	cp		(ix)
 289+ 6CAD 20 2A        	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 290+ 6CAF
 291+ 6CAF DD E5        	push	ix
 292+ 6CB1 C5           	push	bc
 293+ 6CB2 06 08        		ld		b, EXT_AU_CNT
 294+ 6CB4 11 10 00     		ld		de, EXT_AU0
 295+ 6CB7 DD 19        		add		ix, de
 296+ 6CB9
 297+ 6CB9              ReadUsedBlocksLoop2:
 298+ 6CB9 DD 5E 00     		ld		e, (ix)
 299+ 6CBC DD 56 01     		ld		d, (ix+1)
 300+ 6CBF 7B           		ld		a, e
 301+ 6CC0 B2           		or		d
 302+ 6CC1 28 13        		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 303+ 6CC3
 304+ 6CC3 73           		ld		(hl), e
 305+ 6CC4 23           		inc		hl
 306+ 6CC5 72           		ld		(hl), d
 307+ 6CC6 23           		inc		hl
 308+ 6CC7
 309+ 6CC7 DD 23        		inc		ix
 310+ 6CC9 DD 23        		inc		ix
 311+ 6CCB
 312+ 6CCB ED 5B EE 85  		ld		de, (UsedBlockListCnt)
 313+ 6CCF 13           		inc		de
 314+ 6CD0 ED 53 EE 85  		ld		(UsedBlockListCnt), de
 315+ 6CD4
 316+ 6CD4 10 E3        		djnz	ReadUsedBlocksLoop2
 317+ 6CD6
 318+ 6CD6
 319+ 6CD6              ReadUsedBlocksSkip:
 320+ 6CD6 C1           	pop		bc
 321+ 6CD7 DD E1        	pop		ix
 322+ 6CD9              ReadUsedBlocksSkip2:
 323+ 6CD9 11 20 00     	ld		de, EXT_SZ
 324+ 6CDC DD 19        	add		ix, de
 325+ 6CDE
 326+ 6CDE 0B           	dec		bc
 327+ 6CDF 78           	ld		a, b
 328+ 6CE0 B1           	or		c
 329+ 6CE1 20 C6        	jr		nz, ReadUsedBlocksLoop
 330+ 6CE3
 331+ 6CE3 C9           	ret
 332+ 6CE4
 333+ 6CE4              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 334+ 6CE4              ;Reads 8 sectors for an AU
 335+ 6CE4              ;HL = block number, DE = destination buffer
 336+ 6CE4              ReadFSBlock:
 337+ 6CE4 D5           	push	de
 338+ 6CE5 CD 3E 6C     		call	AU2TS		;B=sector, C=track
 339+ 6CE8 E1           	pop		hl				;HL=dest
 340+ 6CE9
 341+ 6CE9 50           	ld		d, b
 342+ 6CEA 59           	ld		e, c
 343+ 6CEB 06 08        	ld		b, SPAL
 344+ 6CED
 345+ 6CED CD CC 6E     	call	ReadDiskSectors
 346+ 6CF0 C9           	ret
 347+ 6CF1
 348+ 6CF1
 349+ 6CF1              ;Write 8 sectors for an AU
 350+ 6CF1              ;HL = block number, DE = source buffer
 351+ 6CF1              WriteFSBlock:
 352+ 6CF1 D5           	push	de
 353+ 6CF2 CD 3E 6C     		call	AU2TS		;B=sector, C=track
 354+ 6CF5 E1           	pop		hl				;HL=dest
 355+ 6CF6
 356+ 6CF6 50           	ld		d, b
 357+ 6CF7 59           	ld		e, c
 358+ 6CF8 06 08        	ld		b, SPAL
 359+ 6CFA
 360+ 6CFA CD DF 6E     	call	WriteDiskSectors
 361+ 6CFD C9           	ret
 362+ 6CFE
 363+ 6CFE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364+ 6CFE              ;Copies the allocated blocks from one disk to another, dual drive.
 365+ 6CFE              ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366+ 6CFE              CopyDisk:
 367+ 6CFE              	;Get list of used blocks in current disk, max 632 bytes
 368+ 6CFE CD 8B 6C     	call	ReadUsedBlocksList
 369+ 6D01 DD 21 F0 85  	ld		ix, UsedBlockListBlk
 370+ 6D05
 371+ 6D05              CopyDiskLoop:
 372+ 6D05 2A EE 85     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373+ 6D08 11 DF 7C     	ld		de, MsgBlocksLeft
 374+ 6D0B CD F0 6A     	call	Byte2Txt
 375+ 6D0E 21 DF 7C     	ld		hl, MsgBlocksLeft
 376+ 6D11 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 377+ 6D14 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 378+ 6D16 CD 8A 74     	call	PrintStrClr
 379+ 6D19
 380+ 6D19              	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381+ 6D19 21 0E 00     	ld		hl, MAX_AU_RAM
 382+ 6D1C ED 4B EE 85  	ld		bc, (UsedBlockListCnt)
 383+ 6D20 B7           	or		a
 384+ 6D21 ED 42        	sbc		hl, bc
 385+ 6D23 30 03        	jr		nc, CopyDiskLoopRead
 386+ 6D25 01 0E 00     	ld		bc, MAX_AU_RAM
 387+ 6D28
 388+ 6D28              CopyDiskLoopRead:
 389+ 6D28 41           	ld		b, c
 390+ 6D29 11 D8 8B     	ld		de, CopyDiskBuf
 391+ 6D2C              	;save initial counter and initial block number array position
 392+ 6D2C C5           	push	bc
 393+ 6D2D DD E5        	push	ix
 394+ 6D2F
 395+ 6D2F              CopyDiskLoopReadLoop:
 396+ 6D2F DD 6E 00     		ld		l, (ix)
 397+ 6D32 DD 66 01     		ld		h, (ix+1)
 398+ 6D35 DD 23        		inc		ix
 399+ 6D37 DD 23        		inc		ix
 400+ 6D39
 401+ 6D39 D5           		push	de
 402+ 6D3A C5           		push	bc
 403+ 6D3B CD E4 6C     			call	ReadFSBlock			;Stop on error or continue?
 404+ 6D3E C1           		pop		bc
 405+ 6D3F D1           		pop		de
 406+ 6D40
 407+ 6D40              		;+2048
 408+ 6D40 7A           		ld		a, d
 409+ 6D41 C6 08        		add		8
 410+ 6D43 57           		ld		d, a
 411+ 6D44
 412+ 6D44 10 E9        		djnz	CopyDiskLoopReadLoop
 413+ 6D46
 414+ 6D46              		;Check if selection is 1=single drive or 2=dual drive
 415+ 6D46 3A 92 7D     		ld		a, (CopySelOption)
 416+ 6D49 FE 31        		cp		'1'
 417+ 6D4B 20 0B        		jr		nz, CopyDiskDualDrive1
 418+ 6D4D
 419+ 6D4D              		;Prompt for disk change
 420+ 6D4D CD D3 70     		call	PromptDiskChangeDst
 421+ 6D50 3A C1 6F     		ld		a, (RWTSDrive)
 422+ 6D53 CD D9 6F     		call	BDOSInit
 423+ 6D56 18 0A        		jr		CopyDiskReadEnd
 424+ 6D58
 425+ 6D58              CopyDiskDualDrive1:
 426+ 6D58              		;alternate drive
 427+ 6D58 3A C1 6F     		ld		a, (RWTSDrive)
 428+ 6D5B 3C           		inc 	a
 429+ 6D5C EE 03        		xor		%11
 430+ 6D5E 3D           		dec		a
 431+ 6D5F 32 C1 6F     		ld		(RWTSDrive), a
 432+ 6D62
 433+ 6D62              CopyDiskReadEnd:
 434+ 6D62              	;restore initial counter and initial block number array position
 435+ 6D62 DD E1        	pop		ix
 436+ 6D64 C1           	pop		bc
 437+ 6D65 11 D8 8B     	ld		de, CopyDiskBuf
 438+ 6D68 C5           	push	bc
 439+ 6D69
 440+ 6D69              CopyDiskLoopWriteLoop:
 441+ 6D69 DD 6E 00     		ld		l, (ix)
 442+ 6D6C DD 66 01     		ld		h, (ix+1)
 443+ 6D6F DD 23        		inc		ix
 444+ 6D71 DD 23        		inc		ix
 445+ 6D73
 446+ 6D73 D5           		push	de
 447+ 6D74 C5           		push	bc
 448+ 6D75 CD F1 6C     			call	WriteFSBlock		;Stop on error or continue?
 449+ 6D78 C1           		pop		bc
 450+ 6D79 D1           		pop		de
 451+ 6D7A
 452+ 6D7A              		;+2048
 453+ 6D7A 7A           		ld		a, d
 454+ 6D7B C6 08        		add		8
 455+ 6D7D 57           		ld		d, a
 456+ 6D7E
 457+ 6D7E 10 E9        		djnz	CopyDiskLoopWriteLoop
 458+ 6D80
 459+ 6D80              CopyDiskWriteEnd:
 460+ 6D80 C1           	pop		bc
 461+ 6D81 48           	ld		c, b
 462+ 6D82 06 00        	ld		b, 0
 463+ 6D84
 464+ 6D84              	;Decrease number of blocks read by now.
 465+ 6D84 2A EE 85     	ld		hl, (UsedBlockListCnt)
 466+ 6D87 B7           	or		a
 467+ 6D88 ED 42        	sbc		hl, bc
 468+ 6D8A 22 EE 85     	ld		(UsedBlockListCnt), hl
 469+ 6D8D
 470+ 6D8D 7D           	ld		a, l
 471+ 6D8E B4           	or		h
 472+ 6D8F 28 20        	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 473+ 6D91
 474+ 6D91              	;Check if selection is 1=single drive or 2=dual drive
 475+ 6D91 3A 92 7D     	ld		a, (CopySelOption)
 476+ 6D94 FE 31        	cp		'1'
 477+ 6D96 20 0C        	jr		nz, CopyDiskDualDrive2
 478+ 6D98
 479+ 6D98              	;Prompt for disk change
 480+ 6D98 CD ED 70     	call	PromptDiskChangeSrc
 481+ 6D9B 3A C1 6F     	ld		a, (RWTSDrive)
 482+ 6D9E CD D9 6F     	call	BDOSInit
 483+ 6DA1 C3 05 6D     	jp		CopyDiskLoop
 484+ 6DA4
 485+ 6DA4              CopyDiskDualDrive2:
 486+ 6DA4              	;alternate drive again
 487+ 6DA4 3A C1 6F     	ld		a, (RWTSDrive)
 488+ 6DA7 3C           	inc		a
 489+ 6DA8 EE 03        	xor		%11
 490+ 6DAA 3D           	dec		a
 491+ 6DAB 32 C1 6F     	ld		(RWTSDrive), a
 492+ 6DAE C3 05 6D     	jp		CopyDiskLoop
 493+ 6DB1
 494+ 6DB1              CopyDiskEnd:
 495+ 6DB1 06 01        	ld		b, 1
 496+ 6DB3 CD 0E 76     	call	ClearNMsgLines
 497+ 6DB6 C9           	ret
 498+ 6DB7
 499+ 6DB7              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 500+ 6DB7              ;Copies the current disk blocks to COM port.
 501+ 6DB7              ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 502+ 6DB7              CopyDiskToCOM:
 503+ 6DB7              	;Get list of used blocks in current disk, max 632 bytes
 504+ 6DB7 CD 8B 6C     	call	ReadUsedBlocksList
 505+ 6DBA
 506+ 6DBA              	;Send block count and block indexes
 507+ 6DBA 2A EE 85     	ld		hl, (UsedBlockListCnt)
 508+ 6DBD 29           	add		hl, hl
 509+ 6DBE 23           	inc		hl
 510+ 6DBF 23           	inc		hl
 511+ 6DC0 44           	ld		b, h
 512+ 6DC1 4D           	ld		c, l
 513+ 6DC2 21 EE 85     	ld		hl, UsedBlockListCnt
 514+ 6DC5 CD 8B 79     	call	SERTB
 515+ 6DC8
 516+ 6DC8 DD 21 F0 85  	ld		ix, UsedBlockListBlk
 517+ 6DCC
 518+ 6DCC              CopyDiskToCOMLoop:
 519+ 6DCC              	;Print block count left
 520+ 6DCC 2A EE 85     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 521+ 6DCF 11 DF 7C     	ld		de, MsgBlocksLeft
 522+ 6DD2 CD F0 6A     	call	Byte2Txt
 523+ 6DD5 21 DF 7C     	ld		hl, MsgBlocksLeft
 524+ 6DD8 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 525+ 6DDB 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 526+ 6DDD CD 8A 74     	call	PrintStrClr
 527+ 6DE0
 528+ 6DE0              	;Read block into buffer
 529+ 6DE0 DD 6E 00     	ld		l, (ix)
 530+ 6DE3 DD 66 01     	ld		h, (ix+1)
 531+ 6DE6 11 D8 8B     	ld		de, CopyDiskBuf
 532+ 6DE9 DD E5        	push	ix
 533+ 6DEB CD E4 6C     		call	ReadFSBlock
 534+ 6DEE DD E1        	pop		ix
 535+ 6DF0 DD 23        	inc		ix
 536+ 6DF2 DD 23        	inc		ix
 537+ 6DF4
 538+ 6DF4              	;Send block buffer
 539+ 6DF4 21 D8 8B     	ld		hl, CopyDiskBuf
 540+ 6DF7 01 00 08     	ld		bc, AU_SZ
 541+ 6DFA CD 8B 79     	call	SERTB
 542+ 6DFD
 543+ 6DFD ED 4B EE 85  	ld		bc, (UsedBlockListCnt)
 544+ 6E01 0B           	dec		bc
 545+ 6E02 ED 43 EE 85  	ld		(UsedBlockListCnt), bc
 546+ 6E06
 547+ 6E06 DD E5        	push	ix
 548+ 6E08 CD 29 74     		call	KbdHit
 549+ 6E0B DD E1        	pop		ix
 550+ 6E0D D8           	ret		c
 551+ 6E0E
 552+ 6E0E 78           	ld		a, b
 553+ 6E0F B1           	or		c
 554+ 6E10 20 BA        	jr		nz, CopyDiskToCOMLoop
 555+ 6E12
 556+ 6E12 C9           	ret
 557+ 6E13
 558+ 6E13              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 559+ 6E13              CopyDiskFromCOM:
 560+ 6E13              	;Receive block count.
 561+ 6E13 21 EE 85     	ld		hl, UsedBlockListCnt
 562+ 6E16 01 02 00     	ld		bc, 2
 563+ 6E19 1E 00        	ld		e, 0
 564+ 6E1B CD 58 79     	call	SERRB
 565+ 6E1E
 566+ 6E1E              	;Receive block indexes.
 567+ 6E1E 2A EE 85     	ld		hl, (UsedBlockListCnt)
 568+ 6E21 29           	add		hl, hl
 569+ 6E22 44           	ld		b, h
 570+ 6E23 4D           	ld		c, l
 571+ 6E24 21 F0 85     	ld		hl, UsedBlockListBlk
 572+ 6E27 1E 00        	ld		e, 0
 573+ 6E29 CD 58 79     	call	SERRB
 574+ 6E2C
 575+ 6E2C              	;Read each block by index and write to disk
 576+ 6E2C DD 21 F0 85  	ld		ix, UsedBlockListBlk
 577+ 6E30
 578+ 6E30              CopyDiskFromCOMLoop:
 579+ 6E30              	;Print block count left
 580+ 6E30 2A EE 85     	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 581+ 6E33 11 DF 7C     	ld		de, MsgBlocksLeft
 582+ 6E36 CD F0 6A     	call	Byte2Txt
 583+ 6E39 21 DF 7C     	ld		hl, MsgBlocksLeft
 584+ 6E3C 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 585+ 6E3F 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 586+ 6E41 CD 8A 74     	call	PrintStrClr
 587+ 6E44
 588+ 6E44              	;Read block buffer
 589+ 6E44 21 D8 8B     	ld		hl, CopyDiskBuf
 590+ 6E47 01 00 08     	ld		bc, AU_SZ
 591+ 6E4A 1E 00        	ld		e, 0
 592+ 6E4C CD 58 79     	call	SERRB
 593+ 6E4F
 594+ 6E4F              	;Write block to disk
 595+ 6E4F DD 6E 00     	ld		l, (ix)
 596+ 6E52 DD 66 01     	ld		h, (ix+1)
 597+ 6E55 11 D8 8B     	ld		de, CopyDiskBuf
 598+ 6E58 DD E5        	push	ix
 599+ 6E5A CD F1 6C     		call	WriteFSBlock			;Stop on error or continue?
 600+ 6E5D DD E1        	pop		ix
 601+ 6E5F DD 23        	inc		ix
 602+ 6E61 DD 23        	inc		ix
 603+ 6E63
 604+ 6E63 ED 4B EE 85  	ld		bc, (UsedBlockListCnt)
 605+ 6E67 0B           	dec		bc
 606+ 6E68 ED 43 EE 85  	ld		(UsedBlockListCnt), bc
 607+ 6E6C
 608+ 6E6C DD E5        	push	ix
 609+ 6E6E CD 29 74     		call	KbdHit
 610+ 6E71 DD E1        	pop		ix
 611+ 6E73 D8           	ret		c
 612+ 6E74
 613+ 6E74 78           	ld		a, b
 614+ 6E75 B1           	or		c
 615+ 6E76 20 B8        	jr		nz, CopyDiskFromCOMLoop
 616+ 6E78 C9           	ret
 617+ 6E79
 618+ 6E79              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619+ 6E79
 620+ 6E79              ;Compare string at HL with the one at DE, max length B
 621+ 6E79              ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 622+ 6E79              ;OUT: z flag, set = match, reset = mismatch
 623+ 6E79              StrCmp:
 624+ 6E79 E5           	push hl
 625+ 6E7A D5           	push de
 626+ 6E7B              Compare:
 627+ 6E7B 1A           		ld a, (de)
 628+ 6E7C BE           		cp (hl)
 629+ 6E7D 20 04        		jr nz, MisMatch
 630+ 6E7F 23           		inc hl
 631+ 6E80 13           		inc de
 632+ 6E81 10 F8        		djnz Compare
 633+ 6E83              MisMatch:
 634+ 6E83 D1           	pop de
 635+ 6E84 E1           	pop hl
 636+ 6E85 C9           	ret
 637+ 6E86
 638+ 6E86              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 639+ 6E86
 640+ 6E86              ;Read a file into a buffer, sector by sector.
 641+ 6E86              ;It's relocatable, to moved and be used when loading a CODE block.
 642+ 6E86              ;It's not using BDOS, but using similar calls provided by IF1.
 643+ 6E86              ;In: HL = Name address, DE = buffer
 644+ 6E86              IF1FileLoad:
 645+ 6E86 D5           	push	de
 646+ 6E87 22 DC 5C     		ld (FSTR1), hl
 647+ 6E8A 26 00        		ld h, 0
 648+ 6E8C 3A C1 6F     		ld a, (RWTSDrive)
 649+ 6E8F 3C           		inc  a			;CP/M drive number to BASIC drive number
 650+ 6E90 6F           		ld	l, a
 651+ 6E91 22 D6 5C     		ld (DSTR1), hl
 652+ 6E94 2E 0B        		ld l,NAMELEN
 653+ 6E96 22 DA 5C     		ld (NSTR1), hl
 654+ 6E99 CF           		rst 08
 655+ 6E9A 33           		DEFB 51			;open disk channel
 656+ 6E9B
 657+ 6E9B CF           		rst		8
 658+ 6E9C 35           		defb	53		;read sector
 659+ 6E9D D1           	pop		de
 660+ 6E9E 30 27        	jr		nc, FileFree
 661+ 6EA0
 662+ 6EA0 DD 7E 32     	ld		a, (ix + CH_DATA)
 663+ 6EA3 FE 04        	cp		TEXT_TYPE
 664+ 6EA5 30 12        	jr		nc, FileLoadNoHeader
 665+ 6EA7
 666+ 6EA7              FileLoadHeader:
 667+ 6EA7 DD E5        	push	ix
 668+ 6EA9 E1           	pop		hl
 669+ 6EAA 01 3B 00     	ld		bc, CH_DATA + HDR_SZ
 670+ 6EAD 09           	add		hl, bc
 671+ 6EAE 01 F7 00     	ld		bc, SECT_SZ - HDR_SZ
 672+ 6EB1 ED B0        	ldir
 673+ 6EB3
 674+ 6EB3              FileReadLoop:
 675+ 6EB3 D5           	push	de
 676+ 6EB4 CF           		rst		8
 677+ 6EB5 35           		defb	53		;read sector
 678+ 6EB6 D1           	pop		de
 679+ 6EB7 30 0E        	jr		nc, FileFree
 680+ 6EB9
 681+ 6EB9              FileLoadNoHeader:
 682+ 6EB9 DD E5        	push	ix
 683+ 6EBB E1           	pop		hl
 684+ 6EBC 01 32 00     	ld		bc, CH_DATA
 685+ 6EBF 09           	add		hl, bc
 686+ 6EC0 01 00 01     	ld		bc, SECT_SZ
 687+ 6EC3 ED B0        	ldir
 688+ 6EC5 18 EC        	jr		FileReadLoop
 689+ 6EC7
 690+ 6EC7              FileFree:
 691+ 6EC7 D5           	push	de
 692+ 6EC8 CF           	rst		8
 693+ 6EC9 38           	defb	56			;close channel (52) or detroy channel (56)
 694+ 6ECA D1           	pop		de
 695+ 6ECB C9           	ret
 696+ 6ECC              IF1FileLoadEnd:
 697+ 6ECC
 698+ 6ECC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 699+ 6ECC              ;HL = destination buffer, B = count of sectors, DE = track/sector
 700+ 6ECC              ;Out: A = error code, 0=OK
 701+ 6ECC              ReadDiskSectors:
 702+ 6ECC C5           	push bc
 703+ 6ECD E5           		push hl
 704+ 6ECE D5           			push de
 705+ 6ECF CD 17 6C     				call ReadOneDiskSector
 706+ 6ED2 D1           			pop de
 707+ 6ED3 E1           		pop hl
 708+ 6ED4
 709+ 6ED4 14           		inc d
 710+ 6ED5 24           		inc h
 711+ 6ED6 C1           	pop bc
 712+ 6ED7
 713+ 6ED7 3A CC 6F     	ld	a, (RWTSRes)
 714+ 6EDA B7           	or	a
 715+ 6EDB C0           	ret nz
 716+ 6EDC
 717+ 6EDC 10 EE        	djnz ReadDiskSectors
 718+ 6EDE C9           	ret
 719+ 6EDF
 720+ 6EDF              ;HL = source buffer, B = count of sectors, DE = track/sector
 721+ 6EDF              ;Out: A = error code, 0=OK
 722+ 6EDF              WriteDiskSectors:
 723+ 6EDF C5           	push bc
 724+ 6EE0 E5           		push hl
 725+ 6EE1 D5           			push de
 726+ 6EE2 CD 22 6C     				call WriteOneDiskSector
 727+ 6EE5 D1           			pop de
 728+ 6EE6 E1           		pop hl
 729+ 6EE7
 730+ 6EE7 14           		inc d
 731+ 6EE8 24           		inc h
 732+ 6EE9 C1           	pop bc
 733+ 6EEA
 734+ 6EEA 3A CC 6F     	ld	a, (RWTSRes)
 735+ 6EED B7           	or	a
 736+ 6EEE C0           	ret nz
 737+ 6EEF
 738+ 6EEF 10 EE        	djnz WriteDiskSectors
 739+ 6EF1 C9           	ret
 740+ 6EF2
 741+ 6EF2
 742+ 6EF2              ;Reads disk catalog
 743+ 6EF2              ReadCatalogTrack:
 744+ 6EF2 21 D8 8B     	ld hl, TrackBuf
 745+ 6EF5 11 00 00     	ld de, 0
 746+ 6EF8 06 10        	ld b, SPT
 747+ 6EFA
 748+ 6EFA CD CC 6E     	call ReadDiskSectors
 749+ 6EFD C9           	ret
 750+ 6EFE
 751+ 6EFE              ;A = track
 752+ 6EFE              SeekTrack:
 753+ 6EFE              	IFUSED
 754+ 6EFE ~            	ld	(RWTSTrack), a
 755+ 6EFE ~            	ld 	a, RWTS_CMD_SEEK
 756+ 6EFE ~            	jp	RWTS
 757+ 6EFE              	ENDIF
 758+ 6EFE
 759+ 6EFE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 760+ 6EFE
 761+ 6EFE              ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 762+ 6EFE              FindCache:
 763+ 6EFE 06 0B        	ld		b, NAMELEN
 764+ 6F00 CD 79 6E     	call	StrCmp			;find the file to wich this extension belongs
 765+ 6F03 C8           	ret		z
 766+ 6F04
 767+ 6F04 0D           	dec		c
 768+ 6F05 20 02        	jr		nz, CacheNotFinished
 769+ 6F07 B1           	or		c
 770+ 6F08 C9           	ret
 771+ 6F09
 772+ 6F09              CacheNotFinished:
 773+ 6F09 01 19 00     	ld		bc, CACHE_SZ
 774+ 6F0C 09           	add		hl, bc			;to the next cache line
 775+ 6F0D 18 EF        	jr		FindCache
 776+ 6F0F
 777+ 6F0F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 778+ 6F0F
 779+ 6F0F              	;ld		ix, (SelFileCache)
 780+ 6F0F              ReadFileHeader:
 781+ 6F0F DD 7E 0F     	ld		a, (ix + CACHE_FLAG)
 782+ 6F12 B7           	or		a
 783+ 6F13 C0           	ret		nz				;return if already read
 784+ 6F14
 785+ 6F14 DD 6E 0B     	ld		l, (ix + CACHE_FIRST_AU)
 786+ 6F17 DD 66 0C     	ld		h, (ix + CACHE_FIRST_AU + 1)
 787+ 6F1A 7C           	ld		a, h
 788+ 6F1B B5           	or		l
 789+ 6F1C 28 46        	jr		z, ReadHeaderEnd
 790+ 6F1E
 791+ 6F1E CD 3E 6C     	call	AU2TS
 792+ 6F21 50           	ld		d, b
 793+ 6F22 59           	ld		e, c
 794+ 6F23 21 D8 8B     	ld		hl, DataBuf
 795+ 6F26 DD E5        	push	ix
 796+ 6F28 DD E5        	push	ix
 797+ 6F2A CD 17 6C     		call	ReadOneDiskSector
 798+ 6F2D E1           	pop		hl
 799+ 6F2E DD E1        	pop		ix
 800+ 6F30
 801+ 6F30 E5           	push	hl
 802+ 6F31 21 D8 8B     		ld		hl, DataBuf
 803+ 6F34 CD 68 6F     		call	IsFileHeaderValid
 804+ 6F37 E1           	pop		hl
 805+ 6F38 B7           	or		a
 806+ 6F39 28 14        	jr		z, ReadFileHeaderIsTextFile
 807+ 6F3B
 808+ 6F3B 01 10 00     	ld		bc, CACHE_HDR
 809+ 6F3E 09           	add		hl, bc
 810+ 6F3F EB           	ex		hl, de
 811+ 6F40 21 D8 8B     	ld		hl, DataBuf
 812+ 6F43 01 09 00     	ld		bc, HDR_SZ
 813+ 6F46 ED B0        	ldir
 814+ 6F48
 815+ 6F48              	;For text files, read file size as reported by BDOS, since we don't have a header.
 816+ 6F48 3E 03        	ld		a, BYTE_TYPE
 817+ 6F4A DD BE 10     	cp		(ix + CACHE_HDR + HDR_TYPE)
 818+ 6F4D 30 15        	jr		nc, ReadHeaderEnd
 819+ 6F4F
 820+ 6F4F              ReadFileHeaderIsTextFile:
 821+ 6F4F DD E5        	push	ix
 822+ 6F51 DD E5        	push	ix
 823+ 6F53 E1           	pop		hl
 824+ 6F54 CD 37 70     		call	GetFileSize
 825+ 6F57 DD E1        	pop		ix
 826+ 6F59 DD 75 11     	ld		(ix + CACHE_HDR + HDR_LEN), l
 827+ 6F5C DD 74 12     	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 828+ 6F5F 3E 04        	ld		a, TEXT_TYPE
 829+ 6F61 DD 77 10     	ld		(ix + CACHE_HDR + HDR_TYPE), a
 830+ 6F64
 831+ 6F64              ReadHeaderEnd:
 832+ 6F64 DD 34 0F     	inc		(ix + CACHE_FLAG)
 833+ 6F67 C9           	ret
 834+ 6F68
 835+ 6F68              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 836+ 6F68              ;Checks if the file header is valid. For now it checks to not have all 0s.
 837+ 6F68              ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 838+ 6F68              ;In: HL = header
 839+ 6F68              ;Out: A > 0 if valid
 840+ 6F68              IsFileHeaderValid:
 841+ 6F68              	IFUSED
 842+ 6F68 AF           	xor		a
 843+ 6F69 06 09        	ld		b, HDR_SZ
 844+ 6F6B              IsFileHeaderValidLoop:
 845+ 6F6B B6           	or		(hl)
 846+ 6F6C 23           	inc		hl
 847+ 6F6D 10 FC        	djnz	IsFileHeaderValidLoop
 848+ 6F6F
 849+ 6F6F C9           	ret
 850+ 6F70              	ENDIF
 851+ 6F70
 852+ 6F70              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 853+ 6F70
 854+ 6F70              ;IN: HL = address from IF1 to call
 855+ 6F70              IF1Call:
 856+ 6F70 22 ED 5C     	LD   (HD11), HL
 857+ 6F73 CF           	RST  8
 858+ 6F74 32           	DEFB 50
 859+ 6F75 C9           	RET
 860+ 6F76
 861+ 6F76              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 862+ 6F76
 863+ 6F76              ;Load a program from disk
 864+ 6F76              ;IN: HL = file name addr
 865+ 6F76              LoadProgram:
 866+ 6F76 22 DC 5C     	LD   (FSTR1), HL
 867+ 6F79 26 00        	LD   H, 0
 868+ 6F7B 2E 0B        	LD   L, NAMELEN
 869+ 6F7D 22 DA 5C     	LD   (NSTR1), HL
 870+ 6F80 3A C1 6F     	LD	 A, (RWTSDrive)
 871+ 6F83 3C           	INC  A					;Adapt for BASIC drive number
 872+ 6F84 6F           	LD   L, A
 873+ 6F85 22 D6 5C     	LD   (DSTR1), HL
 874+ 6F88 21 41 0A     	LD   HL, LOAD_ADDR
 875+ 6F8B CD 70 6F     	CALL IF1Call
 876+ 6F8E C9           	RET
 877+ 6F8F
 878+ 6F8F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 879+ 6F8F
 880+ 6F8F              SetFastKeys:
 881+ 6F8F 3E 0A        	ld		a, 10
 882+ 6F91 32 09 5C     	ld		(REPDEL), a
 883+ 6F94 3E 01        	ld		a, 1
 884+ 6F96 32 0A 5C     	ld		(REPDEL+1),a
 885+ 6F99
 886+ 6F99 C9           	ret
 887+ 6F9A
 888+ 6F9A
 889+ 6F9A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890+ 6F9A              ;Reads the error message string from IF1 ROM.
 891+ 6F9A              GetErrMsg:
 892+ 6F9A 3C           	inc		a
 893+ 6F9B 08           	ex		af, af'
 894+ 6F9C
 895+ 6F9C 21 A2 6F     	ld		hl, IF1Paged			;page-in IF1
 896+ 6F9F C3 70 6F     	jp		IF1Call
 897+ 6FA2
 898+ 6FA2              IF1Paged:
 899+ 6FA2 21 60 02     	ld		hl, ERRMSG
 900+ 6FA5 08           	ex		af, af'
 901+ 6FA6 B7           	or		a
 902+ 6FA7 28 0B        	jr		z, SaveMsg
 903+ 6FA9
 904+ 6FA9 06 00        	ld		b, 0
 905+ 6FAB              SearchMsgEnd:
 906+ 6FAB CB 7E        	bit		7, (hl)
 907+ 6FAD 23           	inc		hl
 908+ 6FAE 28 FB        	jr		z, SearchMsgEnd
 909+ 6FB0
 910+ 6FB0 04           	inc		b
 911+ 6FB1 B8           	cp		b
 912+ 6FB2 20 F7        	jr		nz, SearchMsgEnd
 913+ 6FB4
 914+ 6FB4              SaveMsg:
 915+ 6FB4 11 D8 8B     	ld		de, DataBuf
 916+ 6FB7              CopyMsg:
 917+ 6FB7 7E           	ld		a, (hl)
 918+ 6FB8 CB 7F        	bit		7, a
 919+ 6FBA 12           	ld		(de), a
 920+ 6FBB 23           	inc		hl
 921+ 6FBC 13           	inc		de
 922+ 6FBD 28 F8        	jr		z, CopyMsg
 923+ 6FBF
 924+ 6FBF C9           	ret
 925+ 6FC0
 926+ 6FC0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 927+ 6FC0
 928+ 6FC0              ;RWTS routine I/O block
 929+ 6FC0              RWTSParams:
 930+ 6FC0 01           RWTSBlockType	DEFB	1							;?
 931+ 6FC1 00           RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 932+ 6FC2 00           RWTSVolNo		DEFB	0							;?
 933+ 6FC3 00           RWTSTrack		DEFB	0
 934+ 6FC4 00           RWTSSector		DEFB	0
 935+ 6FC5 00 00        RWTSDMA			DEFW	0
 936+ 6FC7 32 29        RWTSExtBuf		DEFW	$2932
 937+ 6FC9              ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 938+ 6FC9              	IFDEF _REAL_HW_
 939+ 6FC9 D3 6F        RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 940+ 6FCB              	ELSE
 941+ 6FCB ~            RWTSPrmTbl		DEFW	$1f2a
 942+ 6FCB              	ENDIF
 943+ 6FCB 01           RWTSCmd			DEFB	RWTS_CMD_READ
 944+ 6FCC              ;Results
 945+ 6FCC 00           RWTSRes			DEFB	0
 946+ 6FCD 00           RWTSResVolNo	DEFB	0
 947+ 6FCE 00 00 00 00  RWTSResTmp		DEFB	0, 0, 0, 0, 0
 947+ 6FD2 00
 948+ 6FD3
 949+ 6FD3              ;Param. table, usualy found in ROM.
 950+ 6FD3              	IFDEF _REAL_HW_
 951+ 6FD3              BasPrmTbl:
 952+ 6FD3
 953+ 6FD3              ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 954+ 6FD3              	;DEFINE _STANDARD_DRIVE_PARAM_
 955+ 6FD3              	IFDEF _STANDARD_DRIVE_PARAM_
 956+ 6FD3 ~            PrmDevType		DEFB	$01
 957+ 6FD3 ~            PrmStepRate		DEFB	$0D		;(milisec)
 958+ 6FD3 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 959+ 6FD3 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 960+ 6FD3              	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 961+ 6FD3              PrmFastFactor	EQU		4
 962+ 6FD3 01           PrmDevType		DEFB	$01
 963+ 6FD4 03           PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 964+ 6FD5 08           PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 965+ 6FD6 19           PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 966+ 6FD7              	ENDIF
 967+ 6FD7
 968+ 6FD7 30 1F        PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 969+ 6FD9              ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 970+ 6FD9              	ENDIF
 971+ 6FD9
 972+ 6FD9              	endif
# file closed: if1.asm
1497  6FD9              	include "bdos.asm"
# file opened: bdos.asm
   1+ 6FD9              ;BDOS functions - similar to CP/M
   2+ 6FD9
   3+ 6FD9              	IFNDEF	_BDOS_
   4+ 6FD9              	DEFINE	_BDOS_
   5+ 6FD9
   6+ 6FD9              	include "if1.asm"
# file opened: if1.asm
   1++6FD9              ;HC IF1 routines and constants
   2++6FD9
   3++6FD9              ;IF1 routines error codes, also returned by BASIC commands
   4++6FD9              ;12 = Writing to a 'read' file
   5++6FD9              ;13 = Reading a 'write' file
   6++6FD9              ;14 = Disk 'write' protected (by hardware, disk notch open)
   7++6FD9              ;15 = Disk full (disk or catalog full)
   8++6FD9              ;16 = Disk error (hardware error)
   9++6FD9              ;17 = File not found
  10++6FD9              ;23 = Disk R/O (disk change detected, software R/O)
  11++6FD9              ;24 = File R/O (attempting to delete or copy a file with R/O attribute)
  12++6FD9
  13++6FD9              ;Error codes returned by the low level IF1 RWTS routine, from "ABC de calculatoare personale..." book.
  14++6FD9              ;00h = OK
  15++6FD9              ;08h = cannot format disk
  16++6FD9              ;10h = disk protected (read-only?)
  17++6FD9              ;20h = volume error
  18++6FD9              ;40h = drive error
  19++6FD9              ;80h = reading error
  20++6FD9              ;Codes I encountered:
  21++6FD9              ;04h = a CP/M disk was inserted instead of a BASIC one
  22++6FD9
  23++6FD9
  24++6FD9              	ifndef	_DISK_
  25++6FD9 ~            	define	_DISK_
  26++6FD9 ~
  27++6FD9 ~            	include	"math.asm"
  28++6FD9 ~
  29++6FD9 ~            DRIVE_CUR_BAS	EQU 0
  30++6FD9 ~            DRIVE_A_BAS		EQU	1
  31++6FD9 ~            DRIVE_B_BAS		EQU	2
  32++6FD9 ~            DRIVE_A_CPM		EQU	0
  33++6FD9 ~            DRIVE_B_CPM		EQU	1
  34++6FD9 ~            ;Disk geometry stuff
  35++6FD9 ~            SPT				EQU	16			;sectors per track
  36++6FD9 ~            SECT_SZ			EQU	256			;sector size in bytes
  37++6FD9 ~            TRACK_CNT		EQU	80			;track count
  38++6FD9 ~            HEAD_CNT		EQU	2			;disk face count
  39++6FD9 ~            AU_SZ			EQU	2048		;allocation unit size in bytes (8 sectors, half of a track)
  40++6FD9 ~            EXT_SZ			EQU	32			;directory entry size
  41++6FD9 ~            DIR_TRK_CNT		EQU	1			;tracks rezerved for directory
  42++6FD9 ~            EXT_AU_CNT		EQU 8			;allocation units in one extension
  43++6FD9 ~            SPAL			EQU	(AU_SZ/SECT_SZ);sectors per allocation unit
  44++6FD9 ~            MAX_EXT_CNT		EQU	(SPT * DIR_TRK_CNT * SECT_SZ / EXT_SZ);maximum directory entries
  45++6FD9 ~            MAX_FREE_AU_CNT		EQU	((TRACK_CNT * HEAD_CNT - DIR_TRK_CNT) * SPT * SECT_SZ)/AU_SZ ;max free allocation units (318)
  46++6FD9 ~            REC_SZ			EQU 128			;cp/m record size
  47++6FD9 ~            DEL_MARKER		EQU	$E5
  48++6FD9 ~
  49++6FD9 ~
  50++6FD9 ~            ;Extension structure (directory entry)
  51++6FD9 ~            EXT_DEL_FLAG	EQU	0
  52++6FD9 ~            EXT_NAME		EQU 1
  53++6FD9 ~            EXT_IDX			EQU 12
  54++6FD9 ~            EXT_S1			EQU 13
  55++6FD9 ~            EXT_S2			EQU 14
  56++6FD9 ~            EXT_RC			EQU	15
  57++6FD9 ~            EXT_AU0			EQU	16
  58++6FD9 ~            EXT_AU1			EQU	18
  59++6FD9 ~            EXT_AU2			EQU	20
  60++6FD9 ~            EXT_AU3			EQU	22
  61++6FD9 ~            EXT_AU4			EQU	24
  62++6FD9 ~            EXT_AU5			EQU	26
  63++6FD9 ~            EXT_AU6			EQU	28
  64++6FD9 ~            EXT_AU7			EQU	30
  65++6FD9 ~            EXT_SIZE		EQU 32
  66++6FD9 ~
  67++6FD9 ~            ;FCB structure
  68++6FD9 ~            FCB_DRIVE		EQU 0
  69++6FD9 ~            FCB_NAME		EQU EXT_NAME
  70++6FD9 ~            FCB_EX_IDX		EQU EXT_IDX
  71++6FD9 ~            FCB_S1			EQU EXT_S1
  72++6FD9 ~            FCB_S2			EQU EXT_S2
  73++6FD9 ~            FCB_RC			EQU	EXT_RC
  74++6FD9 ~            FCB_AU			EQU	EXT_AU0
  75++6FD9 ~            FCB_CR			EQU	32
  76++6FD9 ~            FCB_R0			EQU 33
  77++6FD9 ~            FCB_R1			EQU 34
  78++6FD9 ~            FCB_R2			EQU 35
  79++6FD9 ~            FCB_SIZE		EQU 36
  80++6FD9 ~
  81++6FD9 ~
  82++6FD9 ~
  83++6FD9 ~            ;System variables for disk
  84++6FD9 ~            DSTR1			EQU	$5CD6		;drive
  85++6FD9 ~            FSTR1			EQU	$5CDC		;file name
  86++6FD9 ~            NSTR1			EQU	$5CDA		;name length
  87++6FD9 ~            HD11			EQU	$5CED		;BDOS argument
  88++6FD9 ~            COPIES			EQU	$5CEF		;BDOS function
  89++6FD9 ~
  90++6FD9 ~            ERRSP			EQU $5C3D
  91++6FD9 ~            ERRNR			EQU $5C3A
  92++6FD9 ~            ERRMSG			EQU	$0260
  93++6FD9 ~
  94++6FD9 ~            PROG			EQU $5C53
  95++6FD9 ~            VARS			EQU	$5C4B
  96++6FD9 ~            STKEND			EQU	$5C65
  97++6FD9 ~
  98++6FD9 ~            PRN_BUF			EQU	23296
  99++6FD9 ~
 100++6FD9 ~            REPDEL			EQU	23561
 101++6FD9 ~            REPPER			EQU	23562
 102++6FD9 ~            PIP			EQU	23609
 103++6FD9 ~            LAST_K			EQU	$5C08
 104++6FD9 ~
 105++6FD9 ~
 106++6FD9 ~            ;RWTS routine commands
 107++6FD9 ~            RWTS_CMD_SEEK	EQU	0			;position head
 108++6FD9 ~            RWTS_CMD_READ	EQU	1			;read sector
 109++6FD9 ~            RWTS_CMD_WRITE	EQU	2			;write sector
 110++6FD9 ~            RWTS_CMD_FMT	EQU	4			;format all tracks
 111++6FD9 ~
 112++6FD9 ~
 113++6FD9 ~            ;File name stuff
 114++6FD9 ~            NAMELEN			EQU	11			;name length
 115++6FD9 ~            RO_POS			EQU	8			;read-only attribute position in name
 116++6FD9 ~            SYS_POS			EQU	9			;system attribute position in name
 117++6FD9 ~
 118++6FD9 ~            ;File types (first byte in header)
 119++6FD9 ~            PROG_TYPE		EQU	0			;program
 120++6FD9 ~            NUMB_TYPE		EQU	1			;number array
 121++6FD9 ~            CHAR_TYPE		EQU	2			;char array
 122++6FD9 ~            BYTE_TYPE		EQU	3			;bytes
 123++6FD9 ~            TEXT_TYPE		EQU	4			;text, >= 4
 124++6FD9 ~
 125++6FD9 ~            ;File header offsets
 126++6FD9 ~            HDR_TYPE		EQU	0
 127++6FD9 ~            HDR_LEN			EQU 1
 128++6FD9 ~            HDR_ADDR		EQU 3
 129++6FD9 ~            HDR_PLEN		EQU	5
 130++6FD9 ~            HDR_LINE		EQU 7
 131++6FD9 ~            HDR_SZ			EQU	9
 132++6FD9 ~
 133++6FD9 ~            ;BASIC disk channel structure
 134++6FD9 ~            CH_RW_FLAG		EQU 11
 135++6FD9 ~            CH_FCB			EQU	12
 136++6FD9 ~            CH_DATA			EQU	50
 137++6FD9 ~            CH_DMA			EQU CH_DATA - CH_FCB	;offset of DMA from start of FCB
 138++6FD9 ~
 139++6FD9 ~            CACHE_NAME		EQU	0					;11B
 140++6FD9 ~            CACHE_FIRST_AU	EQU	NAMELEN				;2B
 141++6FD9 ~            CACHE_AU_CNT	EQU	CACHE_FIRST_AU + 2	;2B
 142++6FD9 ~            CACHE_FLAG		EQU CACHE_AU_CNT + 2	;1B
 143++6FD9 ~            CACHE_HDR		EQU	CACHE_FLAG + 1		;9B
 144++6FD9 ~            CACHE_SZ		EQU	25					;11 + 2 + 2 + 1 + 9
 145++6FD9 ~
 146++6FD9 ~            LOAD_ADDR		EQU	2625		;address of the load procedure in IF1 ROM
 147++6FD9 ~
 148++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 149++6FD9 ~            IF1Init:
 150++6FD9 ~            	rst		08
 151++6FD9 ~            	defb	49		;create system variables
 152++6FD9 ~            	ret
 153++6FD9 ~
 154++6FD9 ~            ;ReadWriteTrackSector
 155++6FD9 ~            ;A=command: 0, 1, 2, 4
 156++6FD9 ~            RWTS:
 157++6FD9 ~            	ld (RWTSCmd), a
 158++6FD9 ~            	ld hl, RWTSParams
 159++6FD9 ~            	ld (HD11), hl
 160++6FD9 ~            	rst 08
 161++6FD9 ~            	DEFB 58
 162++6FD9 ~            	ret
 163++6FD9 ~
 164++6FD9 ~
 165++6FD9 ~            ;D = sector, E = track
 166++6FD9 ~            ;HL = dma
 167++6FD9 ~            ReadOneDiskSector:
 168++6FD9 ~            	ld (RWTSDMA), hl
 169++6FD9 ~            	ld (RWTSTrack), de
 170++6FD9 ~            	;ld (RWTSDrive), a
 171++6FD9 ~            	ld a, RWTS_CMD_READ
 172++6FD9 ~            	jr	RWTS
 173++6FD9 ~
 174++6FD9 ~            ;D = sector, E = track
 175++6FD9 ~            ;HL = dma
 176++6FD9 ~            WriteOneDiskSector:
 177++6FD9 ~            	ld (RWTSDMA), hl
 178++6FD9 ~            	ld (RWTSTrack), de
 179++6FD9 ~            	;ld (RWTSDrive), a
 180++6FD9 ~            	ld a, RWTS_CMD_WRITE
 181++6FD9 ~            	jr	RWTS
 182++6FD9 ~
 183++6FD9 ~            FormatDisk:
 184++6FD9 ~            	ld		hl, DataBuf
 185++6FD9 ~            	ld		(hl), DEL_MARKER
 186++6FD9 ~            	ld 		(RWTSDMA), hl
 187++6FD9 ~            	ld 		a, RWTS_CMD_FMT
 188++6FD9 ~            	call	RWTS
 189++6FD9 ~            	ld		a, (RWTSRes)
 190++6FD9 ~            	ret
 191++6FD9 ~
 192++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 193++6FD9 ~
 194++6FD9 ~            ;Allocation unit no. to track/sector
 195++6FD9 ~            ;Formula: T=(AllocUnit*SPAL)/SPT; Sect=T mod SPT; Track=T/2 (2 disk faces); Head=T mod 2
 196++6FD9 ~            ;IN:  HL=alloc. unit no.
 197++6FD9 ~            ;OUT: B=sector; C=track (head is determined by the sector number)
 198++6FD9 ~            AU2TS:
 199++6FD9 ~            	ld c, SPT/SPAL
 200++6FD9 ~            	call Div					;A = sector
 201++6FD9 ~            	push af
 202++6FD9 ~            		/*
 203++6FD9 ~            		ld c, HEAD_CNT
 204++6FD9 ~            		call Div				;L = track, A = head (0 or 1)
 205++6FD9 ~            		*/
 206++6FD9 ~            		xor a
 207++6FD9 ~            		rr h
 208++6FD9 ~            		rr l
 209++6FD9 ~            		rr a
 210++6FD9 ~
 211++6FD9 ~            		ld c, l
 212++6FD9 ~            		ld b, 0
 213++6FD9 ~            		or a
 214++6FD9 ~            		jr z, Track0
 215++6FD9 ~            		ld b, SPT
 216++6FD9 ~            Track0:
 217++6FD9 ~            	pop af
 218++6FD9 ~            	or a
 219++6FD9 ~            	jr z, FirstAU
 220++6FD9 ~            	ld a, SPAL
 221++6FD9 ~            FirstAU:
 222++6FD9 ~            	add a, b
 223++6FD9 ~            	ld  b, a
 224++6FD9 ~            	ret
 225++6FD9 ~
 226++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 227++6FD9 ~
 228++6FD9 ~            ;Checks the allocation units number used in extension
 229++6FD9 ~            ;IN:	IX = extension addr
 230++6FD9 ~            ;OUT:	B = no. of allocation units used
 231++6FD9 ~            ;		C = no. of records used in ext.
 232++6FD9 ~            ;		HL = first alloc. unit no.
 233++6FD9 ~            ;		DE = last alloc. unit no.
 234++6FD9 ~            CheckExtAlloc:
 235++6FD9 ~            	push ix
 236++6FD9 ~            		ld bc, EXT_RC
 237++6FD9 ~            		add ix, bc
 238++6FD9 ~            		ld c, (ix)			;save rec. no.
 239++6FD9 ~            		inc ix
 240++6FD9 ~            		ld l, (ix)
 241++6FD9 ~            		ld h, (ix + 1)
 242++6FD9 ~            		ld b, EXT_AU_CNT
 243++6FD9 ~            CheckAU:
 244++6FD9 ~            		ld a, (ix)
 245++6FD9 ~            		or (ix + 1)
 246++6FD9 ~            		jr z, CheckAUEnd
 247++6FD9 ~            		ld e, (ix)
 248++6FD9 ~            		ld d, (ix + 1)
 249++6FD9 ~            		inc ix
 250++6FD9 ~            		inc ix
 251++6FD9 ~            		djnz CheckAU
 252++6FD9 ~            CheckAUEnd:
 253++6FD9 ~            		ld a, EXT_AU_CNT
 254++6FD9 ~            		sub b
 255++6FD9 ~            		ld b, a
 256++6FD9 ~            	pop ix
 257++6FD9 ~            	ret
 258++6FD9 ~
 259++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 260++6FD9 ~
 261++6FD9 ~            ;Input: TrackBuffer
 262++6FD9 ~            ;Output: DataBuf = used block count (2 bytes), used block numbers (2 bytes each), 640 + 2 bytes
 263++6FD9 ~            ReadUsedBlocksList:
 264++6FD9 ~            	ld		ix, TrackBuf			;source buffer
 265++6FD9 ~            	ld		hl, UsedBlockListCnt 	;destination buffer
 266++6FD9 ~            	ld		bc, (AUCntMaxFree)		;loop counter
 267++6FD9 ~            	ld		de, 2					;counter of used blocks, start with 2
 268++6FD9 ~            	ld		(hl), e
 269++6FD9 ~            	inc		hl
 270++6FD9 ~            	ld		(hl), d
 271++6FD9 ~            	inc		hl
 272++6FD9 ~
 273++6FD9 ~            	;Add blocks 0 and 1 for directory
 274++6FD9 ~            	ld		de, 0
 275++6FD9 ~            	ld		(hl), e
 276++6FD9 ~            	inc		hl
 277++6FD9 ~            	ld		(hl), d
 278++6FD9 ~            	inc		hl
 279++6FD9 ~
 280++6FD9 ~            	inc		de
 281++6FD9 ~            	ld		(hl), e
 282++6FD9 ~            	inc		hl
 283++6FD9 ~            	ld		(hl), d
 284++6FD9 ~            	inc		hl
 285++6FD9 ~
 286++6FD9 ~            ReadUsedBlocksLoop:
 287++6FD9 ~            	xor		a
 288++6FD9 ~            	cp		(ix)
 289++6FD9 ~            	jr		nz, ReadUsedBlocksSkip2;skip dir entry because it's not for user code 0
 290++6FD9 ~
 291++6FD9 ~            	push	ix
 292++6FD9 ~            	push	bc
 293++6FD9 ~            		ld		b, EXT_AU_CNT
 294++6FD9 ~            		ld		de, EXT_AU0
 295++6FD9 ~            		add		ix, de
 296++6FD9 ~
 297++6FD9 ~            ReadUsedBlocksLoop2:
 298++6FD9 ~            		ld		e, (ix)
 299++6FD9 ~            		ld		d, (ix+1)
 300++6FD9 ~            		ld		a, e
 301++6FD9 ~            		or		d
 302++6FD9 ~            		jr		z, ReadUsedBlocksSkip;end dir entry reading when the AU number is 0
 303++6FD9 ~
 304++6FD9 ~            		ld		(hl), e
 305++6FD9 ~            		inc		hl
 306++6FD9 ~            		ld		(hl), d
 307++6FD9 ~            		inc		hl
 308++6FD9 ~
 309++6FD9 ~            		inc		ix
 310++6FD9 ~            		inc		ix
 311++6FD9 ~
 312++6FD9 ~            		ld		de, (UsedBlockListCnt)
 313++6FD9 ~            		inc		de
 314++6FD9 ~            		ld		(UsedBlockListCnt), de
 315++6FD9 ~
 316++6FD9 ~            		djnz	ReadUsedBlocksLoop2
 317++6FD9 ~
 318++6FD9 ~
 319++6FD9 ~            ReadUsedBlocksSkip:
 320++6FD9 ~            	pop		bc
 321++6FD9 ~            	pop		ix
 322++6FD9 ~            ReadUsedBlocksSkip2:
 323++6FD9 ~            	ld		de, EXT_SZ
 324++6FD9 ~            	add		ix, de
 325++6FD9 ~
 326++6FD9 ~            	dec		bc
 327++6FD9 ~            	ld		a, b
 328++6FD9 ~            	or		c
 329++6FD9 ~            	jr		nz, ReadUsedBlocksLoop
 330++6FD9 ~
 331++6FD9 ~            	ret
 332++6FD9 ~
 333++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 334++6FD9 ~            ;Reads 8 sectors for an AU
 335++6FD9 ~            ;HL = block number, DE = destination buffer
 336++6FD9 ~            ReadFSBlock:
 337++6FD9 ~            	push	de
 338++6FD9 ~            		call	AU2TS		;B=sector, C=track
 339++6FD9 ~            	pop		hl				;HL=dest
 340++6FD9 ~
 341++6FD9 ~            	ld		d, b
 342++6FD9 ~            	ld		e, c
 343++6FD9 ~            	ld		b, SPAL
 344++6FD9 ~
 345++6FD9 ~            	call	ReadDiskSectors
 346++6FD9 ~            	ret
 347++6FD9 ~
 348++6FD9 ~
 349++6FD9 ~            ;Write 8 sectors for an AU
 350++6FD9 ~            ;HL = block number, DE = source buffer
 351++6FD9 ~            WriteFSBlock:
 352++6FD9 ~            	push	de
 353++6FD9 ~            		call	AU2TS		;B=sector, C=track
 354++6FD9 ~            	pop		hl				;HL=dest
 355++6FD9 ~
 356++6FD9 ~            	ld		d, b
 357++6FD9 ~            	ld		e, c
 358++6FD9 ~            	ld		b, SPAL
 359++6FD9 ~
 360++6FD9 ~            	call	WriteDiskSectors
 361++6FD9 ~            	ret
 362++6FD9 ~
 363++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 364++6FD9 ~            ;Copies the allocated blocks from one disk to another, dual drive.
 365++6FD9 ~            ;TODO: Sort blocks to minimize seek time and improve copy speed.
 366++6FD9 ~            CopyDisk:
 367++6FD9 ~            	;Get list of used blocks in current disk, max 632 bytes
 368++6FD9 ~            	call	ReadUsedBlocksList
 369++6FD9 ~            	ld		ix, UsedBlockListBlk
 370++6FD9 ~
 371++6FD9 ~            CopyDiskLoop:
 372++6FD9 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 373++6FD9 ~            	ld		de, MsgBlocksLeft
 374++6FD9 ~            	call	Byte2Txt
 375++6FD9 ~            	ld		hl, MsgBlocksLeft
 376++6FD9 ~            	ld		de, LST_LINE_MSG + 1 << 8
 377++6FD9 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 378++6FD9 ~            	call	PrintStrClr
 379++6FD9 ~
 380++6FD9 ~            	;Calculate how many blocks to read = min(MAX_AU_RAM, blocks left)
 381++6FD9 ~            	ld		hl, MAX_AU_RAM
 382++6FD9 ~            	ld		bc, (UsedBlockListCnt)
 383++6FD9 ~            	or		a
 384++6FD9 ~            	sbc		hl, bc
 385++6FD9 ~            	jr		nc, CopyDiskLoopRead
 386++6FD9 ~            	ld		bc, MAX_AU_RAM
 387++6FD9 ~
 388++6FD9 ~            CopyDiskLoopRead:
 389++6FD9 ~            	ld		b, c
 390++6FD9 ~            	ld		de, CopyDiskBuf
 391++6FD9 ~            	;save initial counter and initial block number array position
 392++6FD9 ~            	push	bc
 393++6FD9 ~            	push	ix
 394++6FD9 ~
 395++6FD9 ~            CopyDiskLoopReadLoop:
 396++6FD9 ~            		ld		l, (ix)
 397++6FD9 ~            		ld		h, (ix+1)
 398++6FD9 ~            		inc		ix
 399++6FD9 ~            		inc		ix
 400++6FD9 ~
 401++6FD9 ~            		push	de
 402++6FD9 ~            		push	bc
 403++6FD9 ~            			call	ReadFSBlock			;Stop on error or continue?
 404++6FD9 ~            		pop		bc
 405++6FD9 ~            		pop		de
 406++6FD9 ~
 407++6FD9 ~            		;+2048
 408++6FD9 ~            		ld		a, d
 409++6FD9 ~            		add		8
 410++6FD9 ~            		ld		d, a
 411++6FD9 ~
 412++6FD9 ~            		djnz	CopyDiskLoopReadLoop
 413++6FD9 ~
 414++6FD9 ~            		;Check if selection is 1=single drive or 2=dual drive
 415++6FD9 ~            		ld		a, (CopySelOption)
 416++6FD9 ~            		cp		'1'
 417++6FD9 ~            		jr		nz, CopyDiskDualDrive1
 418++6FD9 ~
 419++6FD9 ~            		;Prompt for disk change
 420++6FD9 ~            		call	PromptDiskChangeDst
 421++6FD9 ~            		ld		a, (RWTSDrive)
 422++6FD9 ~            		call	BDOSInit
 423++6FD9 ~            		jr		CopyDiskReadEnd
 424++6FD9 ~
 425++6FD9 ~            CopyDiskDualDrive1:
 426++6FD9 ~            		;alternate drive
 427++6FD9 ~            		ld		a, (RWTSDrive)
 428++6FD9 ~            		inc 	a
 429++6FD9 ~            		xor		%11
 430++6FD9 ~            		dec		a
 431++6FD9 ~            		ld		(RWTSDrive), a
 432++6FD9 ~
 433++6FD9 ~            CopyDiskReadEnd:
 434++6FD9 ~            	;restore initial counter and initial block number array position
 435++6FD9 ~            	pop		ix
 436++6FD9 ~            	pop		bc
 437++6FD9 ~            	ld		de, CopyDiskBuf
 438++6FD9 ~            	push	bc
 439++6FD9 ~
 440++6FD9 ~            CopyDiskLoopWriteLoop:
 441++6FD9 ~            		ld		l, (ix)
 442++6FD9 ~            		ld		h, (ix+1)
 443++6FD9 ~            		inc		ix
 444++6FD9 ~            		inc		ix
 445++6FD9 ~
 446++6FD9 ~            		push	de
 447++6FD9 ~            		push	bc
 448++6FD9 ~            			call	WriteFSBlock		;Stop on error or continue?
 449++6FD9 ~            		pop		bc
 450++6FD9 ~            		pop		de
 451++6FD9 ~
 452++6FD9 ~            		;+2048
 453++6FD9 ~            		ld		a, d
 454++6FD9 ~            		add		8
 455++6FD9 ~            		ld		d, a
 456++6FD9 ~
 457++6FD9 ~            		djnz	CopyDiskLoopWriteLoop
 458++6FD9 ~
 459++6FD9 ~            CopyDiskWriteEnd:
 460++6FD9 ~            	pop		bc
 461++6FD9 ~            	ld		c, b
 462++6FD9 ~            	ld		b, 0
 463++6FD9 ~
 464++6FD9 ~            	;Decrease number of blocks read by now.
 465++6FD9 ~            	ld		hl, (UsedBlockListCnt)
 466++6FD9 ~            	or		a
 467++6FD9 ~            	sbc		hl, bc
 468++6FD9 ~            	ld		(UsedBlockListCnt), hl
 469++6FD9 ~
 470++6FD9 ~            	ld		a, l
 471++6FD9 ~            	or		h
 472++6FD9 ~            	jr		z, CopyDiskEnd						;Exit if finished all blocks.
 473++6FD9 ~
 474++6FD9 ~            	;Check if selection is 1=single drive or 2=dual drive
 475++6FD9 ~            	ld		a, (CopySelOption)
 476++6FD9 ~            	cp		'1'
 477++6FD9 ~            	jr		nz, CopyDiskDualDrive2
 478++6FD9 ~
 479++6FD9 ~            	;Prompt for disk change
 480++6FD9 ~            	call	PromptDiskChangeSrc
 481++6FD9 ~            	ld		a, (RWTSDrive)
 482++6FD9 ~            	call	BDOSInit
 483++6FD9 ~            	jp		CopyDiskLoop
 484++6FD9 ~
 485++6FD9 ~            CopyDiskDualDrive2:
 486++6FD9 ~            	;alternate drive again
 487++6FD9 ~            	ld		a, (RWTSDrive)
 488++6FD9 ~            	inc		a
 489++6FD9 ~            	xor		%11
 490++6FD9 ~            	dec		a
 491++6FD9 ~            	ld		(RWTSDrive), a
 492++6FD9 ~            	jp		CopyDiskLoop
 493++6FD9 ~
 494++6FD9 ~            CopyDiskEnd:
 495++6FD9 ~            	ld		b, 1
 496++6FD9 ~            	call	ClearNMsgLines
 497++6FD9 ~            	ret
 498++6FD9 ~
 499++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 500++6FD9 ~            ;Copies the current disk blocks to COM port.
 501++6FD9 ~            ;Send count of blocks - 2B, then for each block send block index - 2B, block buffer - 2048B.
 502++6FD9 ~            CopyDiskToCOM:
 503++6FD9 ~            	;Get list of used blocks in current disk, max 632 bytes
 504++6FD9 ~            	call	ReadUsedBlocksList
 505++6FD9 ~
 506++6FD9 ~            	;Send block count and block indexes
 507++6FD9 ~            	ld		hl, (UsedBlockListCnt)
 508++6FD9 ~            	add		hl, hl
 509++6FD9 ~            	inc		hl
 510++6FD9 ~            	inc		hl
 511++6FD9 ~            	ld		b, h
 512++6FD9 ~            	ld		c, l
 513++6FD9 ~            	ld		hl, UsedBlockListCnt
 514++6FD9 ~            	call	SERTB
 515++6FD9 ~
 516++6FD9 ~            	ld		ix, UsedBlockListBlk
 517++6FD9 ~
 518++6FD9 ~            CopyDiskToCOMLoop:
 519++6FD9 ~            	;Print block count left
 520++6FD9 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 521++6FD9 ~            	ld		de, MsgBlocksLeft
 522++6FD9 ~            	call	Byte2Txt
 523++6FD9 ~            	ld		hl, MsgBlocksLeft
 524++6FD9 ~            	ld		de, LST_LINE_MSG + 1 << 8
 525++6FD9 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 526++6FD9 ~            	call	PrintStrClr
 527++6FD9 ~
 528++6FD9 ~            	;Read block into buffer
 529++6FD9 ~            	ld		l, (ix)
 530++6FD9 ~            	ld		h, (ix+1)
 531++6FD9 ~            	ld		de, CopyDiskBuf
 532++6FD9 ~            	push	ix
 533++6FD9 ~            		call	ReadFSBlock
 534++6FD9 ~            	pop		ix
 535++6FD9 ~            	inc		ix
 536++6FD9 ~            	inc		ix
 537++6FD9 ~
 538++6FD9 ~            	;Send block buffer
 539++6FD9 ~            	ld		hl, CopyDiskBuf
 540++6FD9 ~            	ld		bc, AU_SZ
 541++6FD9 ~            	call	SERTB
 542++6FD9 ~
 543++6FD9 ~            	ld		bc, (UsedBlockListCnt)
 544++6FD9 ~            	dec		bc
 545++6FD9 ~            	ld		(UsedBlockListCnt), bc
 546++6FD9 ~
 547++6FD9 ~            	push	ix
 548++6FD9 ~            		call	KbdHit
 549++6FD9 ~            	pop		ix
 550++6FD9 ~            	ret		c
 551++6FD9 ~
 552++6FD9 ~            	ld		a, b
 553++6FD9 ~            	or		c
 554++6FD9 ~            	jr		nz, CopyDiskToCOMLoop
 555++6FD9 ~
 556++6FD9 ~            	ret
 557++6FD9 ~
 558++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 559++6FD9 ~            CopyDiskFromCOM:
 560++6FD9 ~            	;Receive block count.
 561++6FD9 ~            	ld		hl, UsedBlockListCnt
 562++6FD9 ~            	ld		bc, 2
 563++6FD9 ~            	ld		e, 0
 564++6FD9 ~            	call	SERRB
 565++6FD9 ~
 566++6FD9 ~            	;Receive block indexes.
 567++6FD9 ~            	ld		hl, (UsedBlockListCnt)
 568++6FD9 ~            	add		hl, hl
 569++6FD9 ~            	ld		b, h
 570++6FD9 ~            	ld		c, l
 571++6FD9 ~            	ld		hl, UsedBlockListBlk
 572++6FD9 ~            	ld		e, 0
 573++6FD9 ~            	call	SERRB
 574++6FD9 ~
 575++6FD9 ~            	;Read each block by index and write to disk
 576++6FD9 ~            	ld		ix, UsedBlockListBlk
 577++6FD9 ~
 578++6FD9 ~            CopyDiskFromCOMLoop:
 579++6FD9 ~            	;Print block count left
 580++6FD9 ~            	ld		hl, (UsedBlockListCnt)		;block count, max 320, 2 for catalog
 581++6FD9 ~            	ld		de, MsgBlocksLeft
 582++6FD9 ~            	call	Byte2Txt
 583++6FD9 ~            	ld		hl, MsgBlocksLeft
 584++6FD9 ~            	ld		de, LST_LINE_MSG + 1 << 8
 585++6FD9 ~            	ld		a, SCR_DEF_CLR | CLR_FLASH
 586++6FD9 ~            	call	PrintStrClr
 587++6FD9 ~
 588++6FD9 ~            	;Read block buffer
 589++6FD9 ~            	ld		hl, CopyDiskBuf
 590++6FD9 ~            	ld		bc, AU_SZ
 591++6FD9 ~            	ld		e, 0
 592++6FD9 ~            	call	SERRB
 593++6FD9 ~
 594++6FD9 ~            	;Write block to disk
 595++6FD9 ~            	ld		l, (ix)
 596++6FD9 ~            	ld		h, (ix+1)
 597++6FD9 ~            	ld		de, CopyDiskBuf
 598++6FD9 ~            	push	ix
 599++6FD9 ~            		call	WriteFSBlock			;Stop on error or continue?
 600++6FD9 ~            	pop		ix
 601++6FD9 ~            	inc		ix
 602++6FD9 ~            	inc		ix
 603++6FD9 ~
 604++6FD9 ~            	ld		bc, (UsedBlockListCnt)
 605++6FD9 ~            	dec		bc
 606++6FD9 ~            	ld		(UsedBlockListCnt), bc
 607++6FD9 ~
 608++6FD9 ~            	push	ix
 609++6FD9 ~            		call	KbdHit
 610++6FD9 ~            	pop		ix
 611++6FD9 ~            	ret		c
 612++6FD9 ~
 613++6FD9 ~            	ld		a, b
 614++6FD9 ~            	or		c
 615++6FD9 ~            	jr		nz, CopyDiskFromCOMLoop
 616++6FD9 ~            	ret
 617++6FD9 ~
 618++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 619++6FD9 ~
 620++6FD9 ~            ;Compare string at HL with the one at DE, max length B
 621++6FD9 ~            ;IN: HL, DE = addr. of strings to compare, B = max. length of strings to compare
 622++6FD9 ~            ;OUT: z flag, set = match, reset = mismatch
 623++6FD9 ~            StrCmp:
 624++6FD9 ~            	push hl
 625++6FD9 ~            	push de
 626++6FD9 ~            Compare:
 627++6FD9 ~            		ld a, (de)
 628++6FD9 ~            		cp (hl)
 629++6FD9 ~            		jr nz, MisMatch
 630++6FD9 ~            		inc hl
 631++6FD9 ~            		inc de
 632++6FD9 ~            		djnz Compare
 633++6FD9 ~            MisMatch:
 634++6FD9 ~            	pop de
 635++6FD9 ~            	pop hl
 636++6FD9 ~            	ret
 637++6FD9 ~
 638++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 639++6FD9 ~
 640++6FD9 ~            ;Read a file into a buffer, sector by sector.
 641++6FD9 ~            ;It's relocatable, to moved and be used when loading a CODE block.
 642++6FD9 ~            ;It's not using BDOS, but using similar calls provided by IF1.
 643++6FD9 ~            ;In: HL = Name address, DE = buffer
 644++6FD9 ~            IF1FileLoad:
 645++6FD9 ~            	push	de
 646++6FD9 ~            		ld (FSTR1), hl
 647++6FD9 ~            		ld h, 0
 648++6FD9 ~            		ld a, (RWTSDrive)
 649++6FD9 ~            		inc  a			;CP/M drive number to BASIC drive number
 650++6FD9 ~            		ld	l, a
 651++6FD9 ~            		ld (DSTR1), hl
 652++6FD9 ~            		ld l,NAMELEN
 653++6FD9 ~            		ld (NSTR1), hl
 654++6FD9 ~            		rst 08
 655++6FD9 ~            		DEFB 51			;open disk channel
 656++6FD9 ~
 657++6FD9 ~            		rst		8
 658++6FD9 ~            		defb	53		;read sector
 659++6FD9 ~            	pop		de
 660++6FD9 ~            	jr		nc, FileFree
 661++6FD9 ~
 662++6FD9 ~            	ld		a, (ix + CH_DATA)
 663++6FD9 ~            	cp		TEXT_TYPE
 664++6FD9 ~            	jr		nc, FileLoadNoHeader
 665++6FD9 ~
 666++6FD9 ~            FileLoadHeader:
 667++6FD9 ~            	push	ix
 668++6FD9 ~            	pop		hl
 669++6FD9 ~            	ld		bc, CH_DATA + HDR_SZ
 670++6FD9 ~            	add		hl, bc
 671++6FD9 ~            	ld		bc, SECT_SZ - HDR_SZ
 672++6FD9 ~            	ldir
 673++6FD9 ~
 674++6FD9 ~            FileReadLoop:
 675++6FD9 ~            	push	de
 676++6FD9 ~            		rst		8
 677++6FD9 ~            		defb	53		;read sector
 678++6FD9 ~            	pop		de
 679++6FD9 ~            	jr		nc, FileFree
 680++6FD9 ~
 681++6FD9 ~            FileLoadNoHeader:
 682++6FD9 ~            	push	ix
 683++6FD9 ~            	pop		hl
 684++6FD9 ~            	ld		bc, CH_DATA
 685++6FD9 ~            	add		hl, bc
 686++6FD9 ~            	ld		bc, SECT_SZ
 687++6FD9 ~            	ldir
 688++6FD9 ~            	jr		FileReadLoop
 689++6FD9 ~
 690++6FD9 ~            FileFree:
 691++6FD9 ~            	push	de
 692++6FD9 ~            	rst		8
 693++6FD9 ~            	defb	56			;close channel (52) or detroy channel (56)
 694++6FD9 ~            	pop		de
 695++6FD9 ~            	ret
 696++6FD9 ~            IF1FileLoadEnd:
 697++6FD9 ~
 698++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 699++6FD9 ~            ;HL = destination buffer, B = count of sectors, DE = track/sector
 700++6FD9 ~            ;Out: A = error code, 0=OK
 701++6FD9 ~            ReadDiskSectors:
 702++6FD9 ~            	push bc
 703++6FD9 ~            		push hl
 704++6FD9 ~            			push de
 705++6FD9 ~            				call ReadOneDiskSector
 706++6FD9 ~            			pop de
 707++6FD9 ~            		pop hl
 708++6FD9 ~
 709++6FD9 ~            		inc d
 710++6FD9 ~            		inc h
 711++6FD9 ~            	pop bc
 712++6FD9 ~
 713++6FD9 ~            	ld	a, (RWTSRes)
 714++6FD9 ~            	or	a
 715++6FD9 ~            	ret nz
 716++6FD9 ~
 717++6FD9 ~            	djnz ReadDiskSectors
 718++6FD9 ~            	ret
 719++6FD9 ~
 720++6FD9 ~            ;HL = source buffer, B = count of sectors, DE = track/sector
 721++6FD9 ~            ;Out: A = error code, 0=OK
 722++6FD9 ~            WriteDiskSectors:
 723++6FD9 ~            	push bc
 724++6FD9 ~            		push hl
 725++6FD9 ~            			push de
 726++6FD9 ~            				call WriteOneDiskSector
 727++6FD9 ~            			pop de
 728++6FD9 ~            		pop hl
 729++6FD9 ~
 730++6FD9 ~            		inc d
 731++6FD9 ~            		inc h
 732++6FD9 ~            	pop bc
 733++6FD9 ~
 734++6FD9 ~            	ld	a, (RWTSRes)
 735++6FD9 ~            	or	a
 736++6FD9 ~            	ret nz
 737++6FD9 ~
 738++6FD9 ~            	djnz WriteDiskSectors
 739++6FD9 ~            	ret
 740++6FD9 ~
 741++6FD9 ~
 742++6FD9 ~            ;Reads disk catalog
 743++6FD9 ~            ReadCatalogTrack:
 744++6FD9 ~            	ld hl, TrackBuf
 745++6FD9 ~            	ld de, 0
 746++6FD9 ~            	ld b, SPT
 747++6FD9 ~
 748++6FD9 ~            	call ReadDiskSectors
 749++6FD9 ~            	ret
 750++6FD9 ~
 751++6FD9 ~            ;A = track
 752++6FD9 ~            SeekTrack:
 753++6FD9 ~            	IFUSED
 754++6FD9 ~            	ld	(RWTSTrack), a
 755++6FD9 ~            	ld 	a, RWTS_CMD_SEEK
 756++6FD9 ~            	jp	RWTS
 757++6FD9 ~            	ENDIF
 758++6FD9 ~
 759++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 760++6FD9 ~
 761++6FD9 ~            ;IN: DE = file name to search in cache, HL = file cache table, C = item count
 762++6FD9 ~            FindCache:
 763++6FD9 ~            	ld		b, NAMELEN
 764++6FD9 ~            	call	StrCmp			;find the file to wich this extension belongs
 765++6FD9 ~            	ret		z
 766++6FD9 ~
 767++6FD9 ~            	dec		c
 768++6FD9 ~            	jr		nz, CacheNotFinished
 769++6FD9 ~            	or		c
 770++6FD9 ~            	ret
 771++6FD9 ~
 772++6FD9 ~            CacheNotFinished:
 773++6FD9 ~            	ld		bc, CACHE_SZ
 774++6FD9 ~            	add		hl, bc			;to the next cache line
 775++6FD9 ~            	jr		FindCache
 776++6FD9 ~
 777++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 778++6FD9 ~
 779++6FD9 ~            	;ld		ix, (SelFileCache)
 780++6FD9 ~            ReadFileHeader:
 781++6FD9 ~            	ld		a, (ix + CACHE_FLAG)
 782++6FD9 ~            	or		a
 783++6FD9 ~            	ret		nz				;return if already read
 784++6FD9 ~
 785++6FD9 ~            	ld		l, (ix + CACHE_FIRST_AU)
 786++6FD9 ~            	ld		h, (ix + CACHE_FIRST_AU + 1)
 787++6FD9 ~            	ld		a, h
 788++6FD9 ~            	or		l
 789++6FD9 ~            	jr		z, ReadHeaderEnd
 790++6FD9 ~
 791++6FD9 ~            	call	AU2TS
 792++6FD9 ~            	ld		d, b
 793++6FD9 ~            	ld		e, c
 794++6FD9 ~            	ld		hl, DataBuf
 795++6FD9 ~            	push	ix
 796++6FD9 ~            	push	ix
 797++6FD9 ~            		call	ReadOneDiskSector
 798++6FD9 ~            	pop		hl
 799++6FD9 ~            	pop		ix
 800++6FD9 ~
 801++6FD9 ~            	push	hl
 802++6FD9 ~            		ld		hl, DataBuf
 803++6FD9 ~            		call	IsFileHeaderValid
 804++6FD9 ~            	pop		hl
 805++6FD9 ~            	or		a
 806++6FD9 ~            	jr		z, ReadFileHeaderIsTextFile
 807++6FD9 ~
 808++6FD9 ~            	ld		bc, CACHE_HDR
 809++6FD9 ~            	add		hl, bc
 810++6FD9 ~            	ex		hl, de
 811++6FD9 ~            	ld		hl, DataBuf
 812++6FD9 ~            	ld		bc, HDR_SZ
 813++6FD9 ~            	ldir
 814++6FD9 ~
 815++6FD9 ~            	;For text files, read file size as reported by BDOS, since we don't have a header.
 816++6FD9 ~            	ld		a, BYTE_TYPE
 817++6FD9 ~            	cp		(ix + CACHE_HDR + HDR_TYPE)
 818++6FD9 ~            	jr		nc, ReadHeaderEnd
 819++6FD9 ~
 820++6FD9 ~            ReadFileHeaderIsTextFile:
 821++6FD9 ~            	push	ix
 822++6FD9 ~            	push	ix
 823++6FD9 ~            	pop		hl
 824++6FD9 ~            		call	GetFileSize
 825++6FD9 ~            	pop		ix
 826++6FD9 ~            	ld		(ix + CACHE_HDR + HDR_LEN), l
 827++6FD9 ~            	ld		(ix + CACHE_HDR + HDR_LEN + 1), h
 828++6FD9 ~            	ld		a, TEXT_TYPE
 829++6FD9 ~            	ld		(ix + CACHE_HDR + HDR_TYPE), a
 830++6FD9 ~
 831++6FD9 ~            ReadHeaderEnd:
 832++6FD9 ~            	inc		(ix + CACHE_FLAG)
 833++6FD9 ~            	ret
 834++6FD9 ~
 835++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 836++6FD9 ~            ;Checks if the file header is valid. For now it checks to not have all 0s.
 837++6FD9 ~            ;Some text files can be mistakend for Program files, because the first byte is 0 == PROG_TYPE.
 838++6FD9 ~            ;In: HL = header
 839++6FD9 ~            ;Out: A > 0 if valid
 840++6FD9 ~            IsFileHeaderValid:
 841++6FD9 ~            	IFUSED
 842++6FD9 ~            	xor		a
 843++6FD9 ~            	ld		b, HDR_SZ
 844++6FD9 ~            IsFileHeaderValidLoop:
 845++6FD9 ~            	or		(hl)
 846++6FD9 ~            	inc		hl
 847++6FD9 ~            	djnz	IsFileHeaderValidLoop
 848++6FD9 ~
 849++6FD9 ~            	ret
 850++6FD9 ~            	ENDIF
 851++6FD9 ~
 852++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 853++6FD9 ~
 854++6FD9 ~            ;IN: HL = address from IF1 to call
 855++6FD9 ~            IF1Call:
 856++6FD9 ~            	LD   (HD11), HL
 857++6FD9 ~            	RST  8
 858++6FD9 ~            	DEFB 50
 859++6FD9 ~            	RET
 860++6FD9 ~
 861++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 862++6FD9 ~
 863++6FD9 ~            ;Load a program from disk
 864++6FD9 ~            ;IN: HL = file name addr
 865++6FD9 ~            LoadProgram:
 866++6FD9 ~            	LD   (FSTR1), HL
 867++6FD9 ~            	LD   H, 0
 868++6FD9 ~            	LD   L, NAMELEN
 869++6FD9 ~            	LD   (NSTR1), HL
 870++6FD9 ~            	LD	 A, (RWTSDrive)
 871++6FD9 ~            	INC  A					;Adapt for BASIC drive number
 872++6FD9 ~            	LD   L, A
 873++6FD9 ~            	LD   (DSTR1), HL
 874++6FD9 ~            	LD   HL, LOAD_ADDR
 875++6FD9 ~            	CALL IF1Call
 876++6FD9 ~            	RET
 877++6FD9 ~
 878++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 879++6FD9 ~
 880++6FD9 ~            SetFastKeys:
 881++6FD9 ~            	ld		a, 10
 882++6FD9 ~            	ld		(REPDEL), a
 883++6FD9 ~            	ld		a, 1
 884++6FD9 ~            	ld		(REPDEL+1),a
 885++6FD9 ~
 886++6FD9 ~            	ret
 887++6FD9 ~
 888++6FD9 ~
 889++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 890++6FD9 ~            ;Reads the error message string from IF1 ROM.
 891++6FD9 ~            GetErrMsg:
 892++6FD9 ~            	inc		a
 893++6FD9 ~            	ex		af, af'
 894++6FD9 ~
 895++6FD9 ~            	ld		hl, IF1Paged			;page-in IF1
 896++6FD9 ~            	jp		IF1Call
 897++6FD9 ~
 898++6FD9 ~            IF1Paged:
 899++6FD9 ~            	ld		hl, ERRMSG
 900++6FD9 ~            	ex		af, af'
 901++6FD9 ~            	or		a
 902++6FD9 ~            	jr		z, SaveMsg
 903++6FD9 ~
 904++6FD9 ~            	ld		b, 0
 905++6FD9 ~            SearchMsgEnd:
 906++6FD9 ~            	bit		7, (hl)
 907++6FD9 ~            	inc		hl
 908++6FD9 ~            	jr		z, SearchMsgEnd
 909++6FD9 ~
 910++6FD9 ~            	inc		b
 911++6FD9 ~            	cp		b
 912++6FD9 ~            	jr		nz, SearchMsgEnd
 913++6FD9 ~
 914++6FD9 ~            SaveMsg:
 915++6FD9 ~            	ld		de, DataBuf
 916++6FD9 ~            CopyMsg:
 917++6FD9 ~            	ld		a, (hl)
 918++6FD9 ~            	bit		7, a
 919++6FD9 ~            	ld		(de), a
 920++6FD9 ~            	inc		hl
 921++6FD9 ~            	inc		de
 922++6FD9 ~            	jr		z, CopyMsg
 923++6FD9 ~
 924++6FD9 ~            	ret
 925++6FD9 ~
 926++6FD9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 927++6FD9 ~
 928++6FD9 ~            ;RWTS routine I/O block
 929++6FD9 ~            RWTSParams:
 930++6FD9 ~            RWTSBlockType	DEFB	1							;?
 931++6FD9 ~            RWTSDrive		DEFB	DRIVE_A_CPM					;NOT like BASIC (0,1,2), just 0,1.
 932++6FD9 ~            RWTSVolNo		DEFB	0							;?
 933++6FD9 ~            RWTSTrack		DEFB	0
 934++6FD9 ~            RWTSSector		DEFB	0
 935++6FD9 ~            RWTSDMA			DEFW	0
 936++6FD9 ~            RWTSExtBuf		DEFW	$2932
 937++6FD9 ~            ;The emulators don't like the short times set in the parameter table, but the real hardware works fine and faster.
 938++6FD9 ~            	IFDEF _REAL_HW_
 939++6FD9 ~            RWTSPrmTbl		DEFW	BasPrmTbl			;$1f2a
 940++6FD9 ~            	ELSE
 941++6FD9 ~            RWTSPrmTbl		DEFW	$1f2a
 942++6FD9 ~            	ENDIF
 943++6FD9 ~            RWTSCmd			DEFB	RWTS_CMD_READ
 944++6FD9 ~            ;Results
 945++6FD9 ~            RWTSRes			DEFB	0
 946++6FD9 ~            RWTSResVolNo	DEFB	0
 947++6FD9 ~            RWTSResTmp		DEFB	0, 0, 0, 0, 0
 948++6FD9 ~
 949++6FD9 ~            ;Param. table, usualy found in ROM.
 950++6FD9 ~            	IFDEF _REAL_HW_
 951++6FD9 ~            BasPrmTbl:
 952++6FD9 ~
 953++6FD9 ~            ;In one user case, these short time parameters caused issues, the loading from disk was much slower instead of faster.
 954++6FD9 ~            	;DEFINE _STANDARD_DRIVE_PARAM_
 955++6FD9 ~            	IFDEF _STANDARD_DRIVE_PARAM_
 956++6FD9 ~            PrmDevType		DEFB	$01
 957++6FD9 ~            PrmStepRate		DEFB	$0D		;(milisec)
 958++6FD9 ~            PrmHeadLoad		DEFB	$23		;(milisec)
 959++6FD9 ~            PrmSpinUp		DEFB	$64		;(1/100 sec)
 960++6FD9 ~            	ELSE ;Reduce original parameters by a third, instead of setting all to 1s, to increase compatibility with some bad drivers. Minimal values worked for me, but might not work for some users, depending on drive.
 961++6FD9 ~            PrmFastFactor	EQU		4
 962++6FD9 ~            PrmDevType		DEFB	$01
 963++6FD9 ~            PrmStepRate		DEFB	$0D/PrmFastFactor		;(milisec)
 964++6FD9 ~            PrmHeadLoad		DEFB	$23/PrmFastFactor		;(milisec)
 965++6FD9 ~            PrmSpinUp		DEFB	$64/PrmFastFactor		;(1/100 sec)
 966++6FD9 ~            	ENDIF
 967++6FD9 ~
 968++6FD9 ~            PrmIntrlvTbl	DEFW	$1F30	;InterleaveTbl
 969++6FD9 ~            ;InterleaveTbl   DEFB	1, 3, 5, 7, 9, 11, 13, 15, 2, 4, 6, 8, 10, 12, 14, 16
 970++6FD9 ~            	ENDIF
 971++6FD9 ~
 972++6FD9              	endif
# file closed: if1.asm
   7+ 6FD9
   8+ 6FD9              BDOSInit:
   9+ 6FD9 AF           	xor		a
  10+ 6FDA 18 49        	jr		BDOS
  11+ 6FDC
  12+ 6FDC
  13+ 6FDC              ;IN: A = Drive to select
  14+ 6FDC              BDOSSelectDisk:
  15+ 6FDC              	IFUSED
  16+ 6FDC DD 6F        	ld		ixl, a
  17+ 6FDE DD 26 00     	ld		ixh, 0
  18+ 6FE1 3E 01        	ld		a, 1
  19+ 6FE3 18 40        	jr		BDOS
  20+ 6FE5              	ENDIF
  21+ 6FE5
  22+ 6FE5
  23+ 6FE5              BDOSMakeDiskRO:
  24+ 6FE5              	IFUSED
  25+ 6FE5 ~            	ld		a, 15
  26+ 6FE5 ~            	jr		BDOS
  27+ 6FE5              	ENDIF
  28+ 6FE5
  29+ 6FE5              ;Get Read Only flag
  30+ 6FE5              ;OUT: HL = bitflags of R/O drives, A = LSb, P = MSb
  31+ 6FE5              BDOSGetDiskRO:
  32+ 6FE5              	IFUSED
  33+ 6FE5 ~            	ld	a, 16
  34+ 6FE5 ~            	jr	BDOS
  35+ 6FE5              	ENDIF
  36+ 6FE5
  37+ 6FE5              ;OUT: A = 0, 1 or $FF if no drive selected
  38+ 6FE5              BDOSGetCurrentDrive:
  39+ 6FE5              	IFUSED
  40+ 6FE5 3E 0C        	ld		a, 12
  41+ 6FE7 18 3C        	jr		BDOS
  42+ 6FE9              	ENDIF
  43+ 6FE9
  44+ 6FE9              ;Does log-off for all drives?
  45+ 6FE9              BDOSCloseDrives:
  46+ 6FE9              	IFUSED
  47+ 6FE9 ~            	ld		ixl, a
  48+ 6FE9 ~            	ld		ixh, 0
  49+ 6FE9 ~            	ld		a, 22
  50+ 6FE9 ~            	jr		BDOS
  51+ 6FE9              	ENDIF
  52+ 6FE9
  53+ 6FE9              ;Create a disk channel for BDOS access (does not open the file)
  54+ 6FE9              ;IN: HL=name addr, A=drive
  55+ 6FE9              ;OUT: IX=FCB
  56+ 6FE9              CreateChannel:
  57+ 6FE9 22 DC 5C     	ld (FSTR1), hl
  58+ 6FEC 26 00        	ld h,0
  59+ 6FEE 6F           	ld l,a
  60+ 6FEF 22 D6 5C     	ld (DSTR1), hl
  61+ 6FF2 2E 0B        	ld l,NAMELEN
  62+ 6FF4 22 DA 5C     	ld (NSTR1), hl
  63+ 6FF7 CF           	rst 08
  64+ 6FF8 37           	DEFB 55
  65+ 6FF9 01 0C 00     	ld bc, CH_FCB			;adjust to get cp/m fcb
  66+ 6FFC DD 09        	add ix, bc
  67+ 6FFE C9           	ret
  68+ 6FFF
  69+ 6FFF
  70+ 6FFF              ;Destroy a BDOS channel
  71+ 6FFF              ;IN: IX=FCB
  72+ 6FFF              DestroyChannel:
  73+ 6FFF C5           	push bc
  74+ 7000 01 F4 FF     	ld bc, -CH_FCB			;adjust to get the basic channel
  75+ 7003 DD 09        	add ix, bc
  76+ 7005 CF           	rst 08
  77+ 7006 38           	DEFB 56
  78+ 7007 C1           	pop bc
  79+ 7008 C9           	ret
  80+ 7009
  81+ 7009
  82+ 7009              ;Input: IX=FCB
  83+ 7009              BDOSCreateFile:
  84+ 7009 3E 09        	ld	a, 9
  85+ 700B 18 18        	jr	BDOS
  86+ 700D
  87+ 700D              ;Input: IX=FCB
  88+ 700D              BDOSOpenFile:
  89+ 700D 3E 02        	ld	a, 2
  90+ 700F 18 14        	jr	BDOS
  91+ 7011
  92+ 7011              ;IN: IX=FCB
  93+ 7011              BDOSCloseFile:
  94+ 7011 3E 03        	ld	a, 3
  95+ 7013 18 10        	jr	BDOS
  96+ 7015
  97+ 7015
  98+ 7015              ;0 OK,
  99+ 7015              ;1 end of file,
 100+ 7015              ;9 invalid FCB,
 101+ 7015              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 102+ 7015              ;11 (MP/M) unlocked file verification error,
 103+ 7015              ;0FFh hardware error.
 104+ 7015
 105+ 7015              ;IN: IX=FCB
 106+ 7015              BDOSReadFileBlockSeq:
 107+ 7015 3E 07        	ld	a, 7
 108+ 7017 18 0C        	jr	BDOS
 109+ 7019
 110+ 7019
 111+ 7019              ;0 OK,
 112+ 7019              ;1 directory full,
 113+ 7019              ;2 disc full,
 114+ 7019              ;8 (MP/M) record locked by another process,
 115+ 7019              ;9 invalid FCB,
 116+ 7019              ;10 (CP/M) media changed; (MP/M) FCB checksum error,
 117+ 7019              ;11 (MP/M) unlocked file verification error,
 118+ 7019              ;0FFh hardware error.
 119+ 7019
 120+ 7019              ;IN: IX=FCB
 121+ 7019              BDOSWriteFileBlockSeq:
 122+ 7019 3E 08        	ld	a, 8
 123+ 701B 18 08        	jr	BDOS
 124+ 701D
 125+ 701D
 126+ 701D              ;0 OK
 127+ 701D              ;1 Reading unwritten data
 128+ 701D              ;4 Reading unwritten extent (a 16k portion of file does not exist)
 129+ 701D              ;6 Record number out of range
 130+ 701D              ;9 Invalid FCB
 131+ 701D              BDOSReadFileBlockRandom:
 132+ 701D 3E 12        	ld	a, 18
 133+ 701F 18 04        	jr	BDOS
 134+ 7021
 135+ 7021              ;0 OK
 136+ 7021              ;2 Disc full
 137+ 7021              ;3 Cannot close extent
 138+ 7021              ;5 Directory full
 139+ 7021              ;6 Record number out of range
 140+ 7021              ;8 Record is locked by another process (MP/M)
 141+ 7021              ;9 Invalid FCB
 142+ 7021              ;10 Media changed (CP/M); FCB checksum error (MP/M)
 143+ 7021              BDOSWriteFileBlockRandom:
 144+ 7021 3E 13        	ld	a, 19
 145+ 7023 18 00        	jr	BDOS
 146+ 7025
 147+ 7025
 148+ 7025              ;Generic BDOS call
 149+ 7025              ;IX=arg, A=function
 150+ 7025              BDOS:
 151+ 7025 DD 22 ED 5C  	ld (HD11), ix
 152+ 7029 32 EF 5C     	ld (COPIES), a
 153+ 702C CF           	rst 08
 154+ 702D 39           	DEFB 57
 155+ 702E C9           	ret
 156+ 702F
 157+ 702F              ;Set DMA address for BDOS
 158+ 702F              ;IX=DMA
 159+ 702F              BDOSSetDMA:
 160+ 702F 3E 0D        	ld a, 13
 161+ 7031 18 F2        	jr BDOS
 162+ 7033
 163+ 7033              ;In: IX=FCB
 164+ 7033              BDOSSetRandFilePtr:
 165+ 7033 3E 15        	ld	a, 21
 166+ 7035 18 EE        	jr	BDOS
 167+ 7037
 168+ 7037              ;In: HL=filename
 169+ 7037              ;Out: HL=file size in bytes from the 128-bytes record count returned by the BDOS function.
 170+ 7037              GetFileSize:
 171+ 7037              	IFUSED
 172+ 7037
 173+ 7037 3A C1 6F     	ld 		a, (RWTSDrive)
 174+ 703A 3C           	inc		a					;Convert to BASIC drive number: 1,2
 175+ 703B CD E9 6F     	call	CreateChannel
 176+ 703E
 177+ 703E 3E 14        	ld		a, 20
 178+ 7040 CD 25 70     	call	BDOS
 179+ 7043              	;inc		a
 180+ 7043              	;jr		z, GetFileSizeEnd				;This function always returns $FF in A, but the result is OK.
 181+ 7043
 182+ 7043 DD 6E 21     	ld		l, (ix + FCB_R0)
 183+ 7046 DD 66 22     	ld		h, (ix + FCB_R1)
 184+ 7049
 185+ 7049              	;If the file is bigger than $200 * 128 bytes records, we display 0.
 186+ 7049 3E 01        	ld		a, 1
 187+ 704B BC           	cp		h
 188+ 704C 30 05        	jr		nc, GetFileSizeOK
 189+ 704E 21 00 00     	ld		hl, 0
 190+ 7051 18 08        	jr		GetFileSizeEnd
 191+ 7053
 192+ 7053              GetFileSizeOK:
 193+ 7053              	;*128 == 2^7
 194+ 7053 06 07        	ld		b, 7
 195+ 7055              GetFileSizeMul:
 196+ 7055 CB 15        	rl		l
 197+ 7057 CB 14        	rl		h
 198+ 7059 10 FA        	djnz	GetFileSizeMul
 199+ 705B
 200+ 705B              GetFileSizeEnd:
 201+ 705B E5           	push	hl
 202+ 705C CD FF 6F     		call	DestroyChannel
 203+ 705F E1           	pop		hl
 204+ 7060
 205+ 7060 C9           	ret
 206+ 7061              	ENDIF
 207+ 7061
 208+ 7061              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 209+ 7061              ;HL=file name, A=drive
 210+ 7061              DeleteFile:
 211+ 7061 CD E9 6F     	call	CreateChannel
 212+ 7064
 213+ 7064 3E 06        	ld		a, 6
 214+ 7066 CD 25 70     	call	BDOS
 215+ 7069
 216+ 7069 CD FF 6F     	call	DestroyChannel
 217+ 706C C9           	ret
 218+ 706D
 219+ 706D              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 220+ 706D              ;Returns A >= 0 if the file exists, returns $FF on error.
 221+ 706D              ;HL=file name, A=drive
 222+ 706D              DoesFileExist:
 223+ 706D              	IFUSED
 224+ 706D              	;Set temp DMA address to free RAM, to not overwrite file buffer.
 225+ 706D F5           	push	af
 226+ 706E E5           	push	hl
 227+ 706F DD 21 D8 EA  		ld		ix, FileIdx
 228+ 7073 CD 2F 70     		call 	BDOSSetDMA
 229+ 7076 E1           	pop		hl
 230+ 7077 F1           	pop		af
 231+ 7078
 232+ 7078 CD E9 6F     	call	CreateChannel
 233+ 707B
 234+ 707B              	;Uses FindFirst system call.
 235+ 707B 3E 04        	ld		a, 4
 236+ 707D CD 25 70     	call	BDOS
 237+ 7080
 238+ 7080 F5           	push	af
 239+ 7081 CD FF 6F     		call	DestroyChannel
 240+ 7084 F1           	pop		af
 241+ 7085 C9           	ret
 242+ 7086              	ENDIF
 243+ 7086
 244+ 7086              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 245+ 7086              ;IN: E0 = RO, E1 = SYS, HL=filename
 246+ 7086              ChangeFileAttrib:
 247+ 7086 3A C1 6F     	ld 		a, (RWTSDrive)
 248+ 7089 3C           	inc		a					;Convert to BASIC drive number: 1,2
 249+ 708A D5           	push	de
 250+ 708B CD E9 6F     	call	CreateChannel
 251+ 708E D1           	pop		de
 252+ 708F
 253+ 708F DD 7E 09     	ld		a, (ix + EXT_NAME + RO_POS)
 254+ 7092 CB 27        	sla		a								;reset existing attribute flag
 255+ 7094 CB 1B        	rr		e								;put wanted flag in Carry flag
 256+ 7096 CB 1F        	rr		a								;put Carry flag in register L
 257+ 7098 DD 77 09     	ld		(ix + EXT_NAME + RO_POS), a		;set wanted flag
 258+ 709B
 259+ 709B DD 7E 0A     	ld		a, (ix + EXT_NAME + SYS_POS)
 260+ 709E CB 27        	sla		a
 261+ 70A0 CB 1B        	rr		e
 262+ 70A2 CB 1F        	rr		a
 263+ 70A4 DD 77 0A     	ld		(ix + EXT_NAME + SYS_POS), a
 264+ 70A7
 265+ 70A7              FileAttribSet:
 266+ 70A7 3E 11        	ld		a, 17
 267+ 70A9 CD 25 70     	call	BDOS
 268+ 70AC
 269+ 70AC CD FF 6F     	call	DestroyChannel
 270+ 70AF C9           	ret
 271+ 70B0
 272+ 70B0              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 273+ 70B0
 274+ 70B0              ;HL=original name, DE = new name
 275+ 70B0              ;Works only on the same drive.
 276+ 70B0              RenameFile:
 277+ 70B0 3A C1 6F     	ld 		a, (RWTSDrive)
 278+ 70B3 3C           	inc		a					;Convert to BASIC drive number: 1,2
 279+ 70B4 D5           	push	de
 280+ 70B5 CD E9 6F     	call	CreateChannel
 281+ 70B8 D1           	pop		de
 282+ 70B9
 283+ 70B9 DD E5        	push	ix					;IX == FCB
 284+ 70BB E1           	pop		hl
 285+ 70BC 01 11 00     	ld		bc, 17				;new name must be found at FCB + 16
 286+ 70BF 09           	add		hl, bc
 287+ 70C0 EB           	ex		de, hl
 288+ 70C1 3A C1 6F     	ld		a, (RWTSDrive)
 289+ 70C4 12           	ld		(de), a
 290+ 70C5 01 0B 00     	ld		bc, NAMELEN
 291+ 70C8 ED B0        	ldir
 292+ 70CA
 293+ 70CA 3E 0A        	ld		a, 10
 294+ 70CC CD 25 70     	call	BDOS
 295+ 70CF
 296+ 70CF CD FF 6F     	call	DestroyChannel
 297+ 70D2 C9           	ret
 298+ 70D3              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 299+ 70D3              PromptDiskChangeDst:
 300+ 70D3 21 1B 7D     	ld		hl, MsgInsertDstDsk
 301+ 70D6 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 302+ 70D9 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 303+ 70DB CD 8A 74     	call	PrintStrClr
 304+ 70DE 21 2A 7D     	ld		hl, MsgPressAnyKey
 305+ 70E1 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 306+ 70E4 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 307+ 70E6 CD 8A 74     	call	PrintStrClr
 308+ 70E9 CD 26 74     	call	ReadChar
 309+ 70EC C9           	ret
 310+ 70ED
 311+ 70ED              PromptDiskChangeSrc:
 312+ 70ED 21 0C 7D     	ld		hl, MsgInsertSrcDsk
 313+ 70F0 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 314+ 70F3 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 315+ 70F5 CD 8A 74     	call	PrintStrClr
 316+ 70F8 21 2A 7D     	ld		hl, MsgPressAnyKey
 317+ 70FB 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 318+ 70FE 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 319+ 7100 CD 8A 74     	call	PrintStrClr
 320+ 7103 CD 26 74     	call	ReadChar
 321+ 7106 C9           	ret
 322+ 7107              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 323+ 7107
 324+ 7107              ;HL = source file name, A = source drive
 325+ 7107              ;Use cases:
 326+ 7107              ;1. Copy from A: to B: or B: to A:.
 327+ 7107              ;2. Copy from A: to A:, from B: to B: with alternating disks (single drive) - asks for disk swap.
 328+ 7107              ;3. Copy from A:/B: to COM.
 329+ 7107              ;4. Copy from COM to A:/B:.
 330+ 7107              ;Single drive scenario:
 331+ 7107              ;1. Read first file part,
 332+ 7107              ;2. Ask for dest disk,
 333+ 7107              ;3. check if file exists/ask for overwrite,
 334+ 7107              ;4. create empty dest file,
 335+ 7107              ;5. write first file part,
 336+ 7107              ;6. enter copy loop: ask for SRC disk, read file part, ask for DST disk, write file part, check end, loop.
 337+ 7107              CopyFile:
 338+ 7107 3A C1 6F     	ld 		a, (RWTSDrive)
 339+ 710A 3C           	inc		a					;Convert to BASIC drive number: 1,2
 340+ 710B 32 A2 7D     	ld		(CopyFileSrcDrv), a
 341+ 710E 32 AE 7D     	ld		(CopyFileDstDrv), a
 342+ 7111 11 A3 7D     	ld		de, CopyFileSrcName
 343+ 7114 01 0B 00     	ld		bc, NAMELEN
 344+ 7117 E5           	push	hl
 345+ 7118 C5           	push	bc
 346+ 7119 ED B0        	ldir
 347+ 711B C1           	pop		bc
 348+ 711C E1           	pop		hl
 349+ 711D 11 AF 7D     	ld		de, CopyFileDstName
 350+ 7120 ED B0        	ldir
 351+ 7122
 352+ 7122              	;Reset R/O attribute for destination, to allow file write.
 353+ 7122 3A B7 7D     	ld		a, (CopyFileDstName+RO_POS)
 354+ 7125 CB BF        	res		7, a
 355+ 7127 32 B7 7D     	ld		(CopyFileDstName+RO_POS), a
 356+ 712A
 357+ 712A AF           	xor		a
 358+ 712B 32 9A 7D     	ld		(CopyFileRes), a
 359+ 712E 11 00 00     	ld		de, 0
 360+ 7131 ED 53 9D 7D  	ld		(FilePosRead), de
 361+ 7135 ED 53 9F 7D  	ld		(FilePosWrite), de
 362+ 7139
 363+ 7139 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 364+ 713C C6 40        	add		'A'-1
 365+ 713E              	;Update menu messages with current drive.
 366+ 713E 32 95 7C     	ld		(MsgMenuSingleDrv1), a
 367+ 7141 32 99 7C     	ld		(MsgMenuSingleDrv2), a
 368+ 7144 32 A3 7C     	ld		(MsgMenuDualDrv1), a
 369+ 7147 32 B1 7C     	ld		(MsgMenuToComDrv), a
 370+ 714A 32 C5 7C     	ld		(MsgMenuFromCOMDrv), a
 371+ 714D              	;Update menu messages with the alternate drive.
 372+ 714D 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 373+ 7150 EE 03        	xor		%11
 374+ 7152 C6 40        	add		'A'-1
 375+ 7154 32 A7 7C     	ld		(MsgMenuDualDrv2), a
 376+ 7157
 377+ 7157 21 72 7C     	ld		hl, MsgMenuFileCopy
 378+ 715A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 379+ 715D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 380+ 715F CD 8A 74     	call	PrintStrClr
 381+ 7162 21 81 7C     	ld		hl, MsgMenuBack
 382+ 7165 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 383+ 7168 CD 62 74     	call	PrintStr
 384+ 716B 21 8D 7C     	ld		hl, MsgMenuSingle
 385+ 716E 11 00 10     	ld		de, LST_LINE_MSG + 3 << 8
 386+ 7171 CD 62 74     	call	PrintStr
 387+ 7174 21 9B 7C     	ld		hl, MsgMenuDual
 388+ 7177 11 00 11     	ld		de, LST_LINE_MSG + 4 << 8
 389+ 717A CD 62 74     	call	PrintStr
 390+ 717D 21 A9 7C     	ld		hl, MsgMenuToCOM
 391+ 7180 11 00 12     	ld		de, LST_LINE_MSG + 5 << 8
 392+ 7183 CD 62 74     	call	PrintStr
 393+ 7186 21 B8 7C     	ld		hl, MsgMenuFromCOM
 394+ 7189 11 00 13     	ld		de, LST_LINE_MSG + 6 << 8
 395+ 718C CD 62 74     	call	PrintStr
 396+ 718F
 397+ 718F CD 26 74     	call	ReadChar
 398+ 7192 32 92 7D     	ld		(CopySelOption), a
 399+ 7195
 400+ 7195 F5           	push	af
 401+ 7196 06 06        		ld		b, 6
 402+ 7198 CD 0E 76     		call	ClearNMsgLines
 403+ 719B F1           	pop		af
 404+ 719C
 405+ 719C              	;1=single drive copy, 2=dual drive copy, 3=from file to COM, 4=from COM to file
 406+ 719C FE 30        	cp		'0'
 407+ 719E 20 04        	jr		nz, CopyFileNotExit
 408+ 71A0 E1           	pop		hl
 409+ 71A1 C3 5C 63     	jp		ReadKeyLoop
 410+ 71A4
 411+ 71A4              CopyFileNotExit:
 412+ 71A4 FE 31        	cp		'1'
 413+ 71A6 28 4D        	jr		z, CopyFileSameDrive
 414+ 71A8
 415+ 71A8 FE 32        	cp		'2'
 416+ 71AA CA 74 72     	jp		z, CopyFileDualDrive
 417+ 71AD
 418+ 71AD FE 33        	cp		'3'
 419+ 71AF CA BE 72     	jp		z, CopyFileToCOM
 420+ 71B2
 421+ 71B2 FE 34        	cp		'4'
 422+ 71B4 CA F1 72     	jp		z, CopyFileFromCOM
 423+ 71B7
 424+ 71B7 E1           	pop		hl
 425+ 71B8 C3 5C 63     	jp		ReadKeyLoop
 426+ 71BB
 427+ 71BB
 428+ 71BB              ;OUT: Z=1 => file doesn't exist or overwrite was confirmed if it does exist.
 429+ 71BB              CopyFileCheckOverwrite:
 430+ 71BB              	;Check if destination file exists.
 431+ 71BB 3A AE 7D     	ld		a, (CopyFileDstDrv)
 432+ 71BE 21 AF 7D     	ld		hl, CopyFileDstName
 433+ 71C1 CD 6D 70     	call	DoesFileExist
 434+ 71C4 3C           	inc		a
 435+ 71C5 C8           	ret		z						;return Z=1 when file doesn't exist
 436+ 71C6
 437+ 71C6              	;Ask overwrite confirmation.
 438+ 71C6 21 EE 7C     	ld		hl, MsgFileOverwrite
 439+ 71C9 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 440+ 71CC 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 441+ 71CE CD 8A 74     	call	PrintStrClr
 442+ 71D1 CD 26 74     	call	ReadChar
 443+ 71D4 FE 79        	cp		'y'
 444+ 71D6 C9           	ret								;return Z=1 when user confirmed file overwrite
 445+ 71D7
 446+ 71D7
 447+ 71D7              CopyFileCreateNewFile:
 448+ 71D7 3A AE 7D     	ld		a, (CopyFileDstDrv)
 449+ 71DA 21 AF 7D     	ld		hl, CopyFileDstName
 450+ 71DD F5           	push	af
 451+ 71DE E5           	push	hl
 452+ 71DF CD 61 70     		call	DeleteFile			;Delete destination file if it exists, like the CP/M guide recommends.
 453+ 71E2 E1           	pop		hl
 454+ 71E3 F1           	pop		af
 455+ 71E4 CD E9 6F     	call	CreateChannel
 456+ 71E7 CD 09 70     	call 	BDOSCreateFile
 457+ 71EA 3C           	inc  	a						;Cancel if A==$FF
 458+ 71EB C8           	ret		z
 459+ 71EC
 460+ 71EC              	;Close dest file once created.
 461+ 71EC F5           	push	af
 462+ 71ED CD 11 70     		call	BDOSCloseFile
 463+ 71F0 CD FF 6F     		call	DestroyChannel
 464+ 71F3 F1           	pop		af
 465+ 71F4 C9           	ret
 466+ 71F5
 467+ 71F5              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 468+ 71F5              CopyFileSameDrive:
 469+ 71F5              	;Read first file section from SRC.
 470+ 71F5 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 471+ 71F8 21 A3 7D     	ld		hl, CopyFileSrcName
 472+ 71FB 06 5F        	ld		b, MAX_SECT_BUF
 473+ 71FD CD 74 73     	call	ReadFileSection
 474+ 7200 3A A1 7D     	ld		a, (CopyFileSectCnt)
 475+ 7203 B7           	or		a
 476+ 7204 C8           	ret		z
 477+ 7205
 478+ 7205              	;Prompt for DST disk change.
 479+ 7205 CD D3 70     	call	PromptDiskChangeDst
 480+ 7208 3A C1 6F     	ld		a, (RWTSDrive)
 481+ 720B CD D9 6F     	call	BDOSInit
 482+ 720E
 483+ 720E 06 02        	ld		b, 2
 484+ 7210 CD 0E 76     	call	ClearNMsgLines
 485+ 7213
 486+ 7213 CD BB 71     	call	CopyFileCheckOverwrite
 487+ 7216 C0           	ret		nz
 488+ 7217
 489+ 7217 CD D7 71     	call	CopyFileCreateNewFile
 490+ 721A C8           	ret		z
 491+ 721B
 492+ 721B              CopyFileSameDriveLoop:
 493+ 721B 3A A1 7D     	ld		a, (CopyFileSectCnt)
 494+ 721E 6F           	ld		l, a
 495+ 721F 26 00        	ld		h, 0
 496+ 7221 11 37 7D     	ld		de, MsgCopySectors
 497+ 7224 CD F0 6A     	call	Byte2Txt
 498+ 7227 21 37 7D     	ld		hl, MsgCopySectors
 499+ 722A 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 500+ 722D 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 501+ 722F CD 8A 74     	call	PrintStrClr
 502+ 7232
 503+ 7232 3A 9A 7D     	ld		a, (CopyFileRes)			;Save read status code.
 504+ 7235 F5           	push	af
 505+ 7236 3A AE 7D     		ld		a, (CopyFileDstDrv)
 506+ 7239 21 AF 7D     		ld		hl, CopyFileDstName
 507+ 723C CD 95 73     		call	WriteFileSection
 508+ 723F 3A 9A 7D     		ld		a, (CopyFileRes)
 509+ 7242 6F           		ld		l, a
 510+ 7243 F1           	pop		af
 511+ 7244 B5           	or		l
 512+ 7245 C0           	ret		nz							;Exit if read or write had error. Error 1 on read means EOF (some data might still be read).
 513+ 7246
 514+ 7246
 515+ 7246              	;Prompt for SRC disk change.
 516+ 7246 CD ED 70     	call	PromptDiskChangeSrc
 517+ 7249 3A C1 6F     	ld		a, (RWTSDrive)
 518+ 724C CD D9 6F     	call	BDOSInit
 519+ 724F
 520+ 724F 06 02        	ld		b, 2
 521+ 7251 CD 0E 76     	call	ClearNMsgLines
 522+ 7254
 523+ 7254 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 524+ 7257 21 A3 7D     	ld		hl, CopyFileSrcName
 525+ 725A 06 5F        	ld		b, MAX_SECT_BUF
 526+ 725C CD 74 73     	call	ReadFileSection
 527+ 725F 3A A1 7D     	ld		a, (CopyFileSectCnt)
 528+ 7262 B7           	or		a
 529+ 7263 C8           	ret		z
 530+ 7264
 531+ 7264              	;Prompt for DST disk change.
 532+ 7264 CD D3 70     	call	PromptDiskChangeDst
 533+ 7267 3A C1 6F     	ld		a, (RWTSDrive)
 534+ 726A CD D9 6F     	call	BDOSInit
 535+ 726D
 536+ 726D 06 02        	ld		b, 2
 537+ 726F CD 0E 76     	call	ClearNMsgLines
 538+ 7272
 539+ 7272 18 A7        	jr		CopyFileSameDriveLoop
 540+ 7274
 541+ 7274              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 542+ 7274
 543+ 7274              CopyFileDualDrive:
 544+ 7274 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 545+ 7277 EE 03        	xor		%11
 546+ 7279 32 AE 7D     	ld		(CopyFileDstDrv), a
 547+ 727C
 548+ 727C CD BB 71     	call	CopyFileCheckOverwrite
 549+ 727F C0           	ret		nz
 550+ 7280
 551+ 7280 CD D7 71     	call	CopyFileCreateNewFile
 552+ 7283 C8           	ret		z
 553+ 7284
 554+ 7284              CopyFileDualDriveLoop:
 555+ 7284 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 556+ 7287 21 A3 7D     	ld		hl, CopyFileSrcName
 557+ 728A 06 5F        	ld		b, MAX_SECT_BUF
 558+ 728C CD 74 73     	call	ReadFileSection
 559+ 728F 3A A1 7D     	ld		a, (CopyFileSectCnt)
 560+ 7292 B7           	or		a
 561+ 7293 C8           	ret		z
 562+ 7294
 563+ 7294 3A A1 7D     	ld		a, (CopyFileSectCnt)
 564+ 7297 6F           	ld		l, a
 565+ 7298 26 00        	ld		h, 0
 566+ 729A 11 37 7D     	ld		de, MsgCopySectors
 567+ 729D CD F0 6A     	call	Byte2Txt
 568+ 72A0 21 37 7D     	ld		hl, MsgCopySectors
 569+ 72A3 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 570+ 72A6 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 571+ 72A8
 572+ 72A8 3A 9A 7D     	ld		a, (CopyFileRes)
 573+ 72AB F5           	push	af
 574+ 72AC 3A AE 7D     		ld		a, (CopyFileDstDrv)
 575+ 72AF 21 AF 7D     		ld		hl, CopyFileDstName
 576+ 72B2 CD 95 73     		call	WriteFileSection
 577+ 72B5 3A 9A 7D     		ld		a, (CopyFileRes)
 578+ 72B8 6F           		ld		l, a
 579+ 72B9 F1           	pop		af
 580+ 72BA B5           	or		l
 581+ 72BB C0           	ret		nz
 582+ 72BC
 583+ 72BC 18 C6        	jr		CopyFileDualDriveLoop
 584+ 72BE
 585+ 72BE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 586+ 72BE              CopyFileToCOM:
 587+ 72BE AF           	xor		a
 588+ 72BF 32 9A 7D     	ld		(CopyFileRes), a
 589+ 72C2 32 A1 7D     	ld		(CopyFileSectCnt), a
 590+ 72C5 11 00 00     	ld		de, 0
 591+ 72C8 ED 53 9D 7D  	ld		(FilePosRead), de
 592+ 72CC
 593+ 72CC              CopyFileToCOMLoop:
 594+ 72CC 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 595+ 72CF 21 A3 7D     	ld		hl, CopyFileSrcName
 596+ 72D2 06 5F        	ld		b, MAX_SECT_BUF
 597+ 72D4 CD 74 73     	call	ReadFileSection
 598+ 72D7
 599+ 72D7 3A A1 7D     	ld		a, (CopyFileSectCnt)
 600+ 72DA B7           	or		a
 601+ 72DB 28 0F        	jr		z, CopyFileToCOMEnd
 602+ 72DD
 603+ 72DD              	;Send buffer to COM port.
 604+ 72DD 21 D8 8B     	ld		hl, FileData
 605+ 72E0 47           	ld		b, a					;Sector size is 256.
 606+ 72E1 0E 00        	ld		c, 0
 607+ 72E3 CD 8B 79     	call	SERTB
 608+ 72E6
 609+ 72E6 3A 9A 7D     	ld		a, (CopyFileRes)
 610+ 72E9 B7           	or		a
 611+ 72EA 28 E0        	jr		z, CopyFileToCOMLoop
 612+ 72EC
 613+ 72EC              CopyFileToCOMEnd:
 614+ 72EC              	;Reset read error code, as 1 is returned when file is finished reading.
 615+ 72EC AF           	xor		a
 616+ 72ED 32 9A 7D     	ld		(CopyFileRes), a
 617+ 72F0
 618+ 72F0 C9           	ret
 619+ 72F1
 620+ 72F1              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 621+ 72F1              CopyFileFromCOM:
 622+ 72F1 AF           	xor		a
 623+ 72F2 32 9A 7D     	ld		(CopyFileRes), a
 624+ 72F5 11 00 00     	ld		de, 0
 625+ 72F8 ED 53 9F 7D  	ld		(FilePosWrite), de
 626+ 72FC
 627+ 72FC              	;Must ask for the new file name and check to not exist.
 628+ 72FC 21 58 7C     	ld		hl, MsgNewFileName
 629+ 72FF 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 630+ 7302 3E C5        	ld		a, SCR_DEF_CLR | CLR_FLASH
 631+ 7304 CD 8A 74     	call	PrintStrClr
 632+ 7307
 633+ 7307 21 23 7C     	ld		hl, MsgClear
 634+ 730A 11 D8 8B     	ld		de, FileData
 635+ 730D 01 0B 00     	ld		bc, NAMELEN
 636+ 7310 ED B0        	ldir
 637+ 7312 3E A0        	ld		a, $80 | ' '
 638+ 7314 12           	ld		(de), a
 639+ 7315 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 640+ 7318 21 D8 8B     	ld		hl, FileData
 641+ 731B CD 62 74     	call	PrintStr
 642+ 731E
 643+ 731E 11 00 0F     	ld		de, LST_LINE_MSG + 2 << 8
 644+ 7321 01 0B 00     	ld		bc, NAMELEN
 645+ 7324 CD CC 75     	call	ReadString
 646+ 7327
 647+ 7327 11 D8 8B     	ld		de, FileData
 648+ 732A 1A           	ld		a, (de)
 649+ 732B FE 20        	cp		' '					;If starting with space, input was canceled.
 650+ 732D C8           	ret		z
 651+ 732E
 652+ 732E              	;Copy new file name
 653+ 732E 21 D8 8B     	ld		hl, FileData
 654+ 7331 11 AF 7D     	ld		de, CopyFileDstName
 655+ 7334 01 0B 00     	ld		bc, NAMELEN
 656+ 7337 ED B0        	ldir
 657+ 7339
 658+ 7339              	;Check if new name doesn't exist already.
 659+ 7339 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 660+ 733C 21 AF 7D     	ld		hl, CopyFileDstName
 661+ 733F CD BB 71     	call	CopyFileCheckOverwrite
 662+ 7342 C0           	ret		nz
 663+ 7343
 664+ 7343              	;Delete and re-create empty destination file
 665+ 7343 3A A2 7D     	ld		a, (CopyFileSrcDrv)
 666+ 7346 21 AF 7D     	ld		hl, CopyFileDstName
 667+ 7349 CD D7 71     	call	CopyFileCreateNewFile
 668+ 734C C8           	ret		z
 669+ 734D
 670+ 734D              CopyFileFromCOMLoop:
 671+ 734D 21 D8 8B     	ld		hl, FileData
 672+ 7350 01 00 5F     	ld		bc, FileDataSize
 673+ 7353 1E 01        	ld		e, 1				;Exit on timeout, don't get stuck waiting for more data from PC.
 674+ 7355 CD 58 79     	call	SERRB				;BC = Number of bytes read from COM
 675+ 7358 79           	ld		a, c
 676+ 7359 B0           	or		b
 677+ 735A C8           	ret		z
 678+ 735B
 679+ 735B              	;If C is not 0, add one more sector.
 680+ 735B 79           	ld 		a, c
 681+ 735C B7           	or		a
 682+ 735D 28 01        	jr		z, CopyFileFromCOMDontInc
 683+ 735F 04           	inc		b
 684+ 7360              CopyFileFromCOMDontInc:
 685+ 7360 78           	ld		a, b				;Sector size is 256
 686+ 7361 32 A1 7D     	ld		(CopyFileSectCnt), a
 687+ 7364 3A AE 7D     	ld		a, (CopyFileDstDrv)
 688+ 7367 21 AF 7D     	ld		hl, CopyFileDstName
 689+ 736A CD 95 73     	call	WriteFileSection
 690+ 736D
 691+ 736D 3A 9A 7D     	ld		a, (CopyFileRes)
 692+ 7370 B7           	or		a
 693+ 7371 28 DA        	jr		z, CopyFileFromCOMLoop
 694+ 7373
 695+ 7373 C9           	ret
 696+ 7374
 697+ 7374              ;Reads/Writes disk file portion to/from memory.
 698+ 7374              ;Meant to be used with 2 step copy operation: 1) read part of file to RAM, 2) write from RAM to destination file, at specified position.
 699+ 7374              ;This should work with single-drive file copy from one disk to another.
 700+ 7374              ;In: A = drive, HL = name, FilePosRead/FilePosWrite = file offset in 128 byte records, B = max sectors to read
 701+ 7374              ;Out: FileData = read buffer, DE = end of data address, CopyFileRes = result code, FilePosRead/FilePosWrite are updated
 702+ 7374              ;
 703+ 7374              ;http://www.gaby.de/cpm/manuals/archive/cpm22htm/ch5.htm#Function_34:
 704+ 7374              ;"Note that reading or writing the last record of an extent in random mode does not cause an automatic extent switch as it does in sequential mode."
 705+ 7374              ;Must use sequential read/write. But for the first operation must use random read/write.
 706+ 7374              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 707+ 7374              ReadFileSection:
 708+ 7374 11 1D 70     	ld		de, BDOSReadFileBlockRandom
 709+ 7377 ED 53 DD 73  	ld		(CopyFileOperAddr1), de
 710+ 737B 11 15 70     	ld		de, BDOSReadFileBlockSeq
 711+ 737E ED 53 FC 73  	ld		(CopyFileOperAddr2), de
 712+ 7382 11 9D 7D     	ld		de, FilePosRead
 713+ 7385 ED 53 D4 73  	ld		(CopyFilePtr), de
 714+ 7389 ED 53 19 74  	ld		(CopyFilePtr2), de
 715+ 738D
 716+ 738D              	;Limit max sectors to read to leave space for the index too.
 717+ 738D F5           	push	af
 718+ 738E 78           		ld		a, b
 719+ 738F 32 A1 7D     		ld		(CopyFileSectCnt), a
 720+ 7392 F1           	pop		af
 721+ 7393 18 19        	jr		ReadWriteFileSection
 722+ 7395
 723+ 7395              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 724+ 7395
 725+ 7395              WriteFileSection:
 726+ 7395 11 21 70     	ld		de, BDOSWriteFileBlockRandom
 727+ 7398 ED 53 DD 73  	ld		(CopyFileOperAddr1), de
 728+ 739C 11 19 70     	ld		de, BDOSWriteFileBlockSeq
 729+ 739F ED 53 FC 73  	ld		(CopyFileOperAddr2), de
 730+ 73A3 11 9F 7D     	ld		de, FilePosWrite
 731+ 73A6 ED 53 D4 73  	ld		(CopyFilePtr), de
 732+ 73AA ED 53 19 74  	ld		(CopyFilePtr2), de
 733+ 73AE
 734+ 73AE
 735+ 73AE              ;Common routine for both read and write operations. Code is patched to execute either read or write.
 736+ 73AE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 737+ 73AE              ReadWriteFileSection:
 738+ 73AE CD E9 6F     	call	CreateChannel
 739+ 73B1 DD 22 98 7D  	ld	(CopyFileFCB), ix
 740+ 73B5 CD 0D 70     	call 	BDOSOpenFile
 741+ 73B8 3C           	inc  	a						;Cancel if A==$FF
 742+ 73B9 C8           	ret	z
 743+ 73BA
 744+ 73BA              	;Set DMA initial pointer = FileData
 745+ 73BA DD E5        	push	ix
 746+ 73BC 21 D8 8B     		ld		hl, FileData
 747+ 73BF DD 21 9B 7D  		ld		ix, CopyFileDMAAddr
 748+ 73C3 DD 75 00     		ld		(ix), l
 749+ 73C6 DD 74 01     		ld		(ix+1), h
 750+ 73C9 DD 21 D8 8B  		ld		ix, FileData
 751+ 73CD CD 2F 70     		call 	BDOSSetDMA
 752+ 73D0 DD E1        	pop		ix
 753+ 73D2
 754+ 73D2              CopyFilePtr EQU $+2
 755+ 73D2              	;Update file pointer using read/write random call.
 756+ 73D2 ED 5B 9D 7D  	ld		de, (FilePosRead)
 757+ 73D6 DD 73 21     	ld		(ix + FCB_R0), e
 758+ 73D9 DD 72 22     	ld		(ix + FCB_R1), d
 759+ 73DC              CopyFileOperAddr1 EQU $ + 1
 760+ 73DC CD 1D 70     	call 	BDOSReadFileBlockRandom
 761+ 73DF
 762+ 73DF 32 9A 7D     	ld		(CopyFileRes), a
 763+ 73E2 B7           	or		a
 764+ 73E3 20 22        	jr		nz, ReadWriteFileSectionEnd
 765+ 73E5
 766+ 73E5 3A A1 7D     	ld		a, (CopyFileSectCnt)
 767+ 73E8 47           	ld		b, a
 768+ 73E9
 769+ 73E9              ReadWriteFileSectionLoop:
 770+ 73E9 C5           	push	bc
 771+ 73EA DD 2A 9B 7D  		ld		ix, (CopyFileDMAAddr)
 772+ 73EE CD 2F 70     		call 	BDOSSetDMA
 773+ 73F1 DD 24        		inc		ixh
 774+ 73F3 DD 22 9B 7D  		ld		(CopyFileDMAAddr), ix
 775+ 73F7
 776+ 73F7 DD 2A 98 7D  		ld		ix, (CopyFileFCB)
 777+ 73FB              CopyFileOperAddr2 EQU $ + 1
 778+ 73FB CD 15 70     		call 	BDOSReadFileBlockSeq
 779+ 73FE 32 9A 7D     		ld		(CopyFileRes), a
 780+ 7401 C1           	pop		bc
 781+ 7402 B7           	or		a
 782+ 7403 20 02        	jr		nz, ReadWriteFileSectionEnd	;Exit on read/write error.
 783+ 7405 10 E2        	djnz	ReadWriteFileSectionLoop		;Exit on buffer full.
 784+ 7407
 785+ 7407              ReadWriteFileSectionEnd:
 786+ 7407              	;Update sector count variable with how many sectors were transfered.
 787+ 7407 3A A1 7D     	ld		a, (CopyFileSectCnt)
 788+ 740A 90           	sub		b				;Substract the number of sectors left to read when EOF was encountered or buffer ended.
 789+ 740B 32 A1 7D     	ld		(CopyFileSectCnt), a		;Store the number of sectors actualy read.
 790+ 740E
 791+ 740E              	;Update random access file pointer with the last read value, before file ended or before RAM buffer ended.
 792+ 740E CD 33 70     	call	BDOSSetRandFilePtr
 793+ 7411 DD 5E 21     	ld		e, (ix + FCB_R0)
 794+ 7414 DD 56 22     	ld		d, (ix + FCB_R1)
 795+ 7417              CopyFilePtr2 EQU $+2
 796+ 7417 ED 53 9D 7D  	ld		(FilePosRead), de
 797+ 741B
 798+ 741B CD 11 70     	call 	BDOSCloseFile
 799+ 741E CD FF 6F     	call 	DestroyChannel
 800+ 7421
 801+ 7421 ED 5B 9B 7D  	ld		de, (CopyFileDMAAddr)
 802+ 7425              	;dec		d
 803+ 7425 C9           	ret
 804+ 7426
 805+ 7426              	ENDIF
 806+ 7426
# file closed: bdos.asm
1498  7426              	include "ui.asm"
# file opened: ui.asm
   1+ 7426              ;UI related functions
   2+ 7426
   3+ 7426              	ifndef	_UI_
   4+ 7426              	define	_UI_
   5+ 7426
   6+ 7426              	include	"hccfg.asm"
# file opened: hccfg.asm
   1++7426              	ifndef	_HCCFG_
   2++7426 ~            	define	_HCCFG_
   3++7426 ~
   4++7426 ~            ;HC specific code, for configuration
   5++7426 ~
   6++7426 ~            HC_CFG_PORT			EQU	$7E
   7++7426 ~            HC_FLOPPY_PORT		EQU 7
   8++7426 ~
   9++7426 ~            ;BASIC/CPM ROM selection
  10++7426 ~            HC_CFG_ROM_BAS		EQU	%0
  11++7426 ~            HC_CFG_ROM_CPM		EQU	%1
  12++7426 ~
  13++7426 ~            ;Address for ROM paging: 0 or $E000
  14++7426 ~            HC_CFG_ROM_0000		EQU %00
  15++7426 ~            HC_CFG_ROM_E000		EQU %10
  16++7426 ~
  17++7426 ~            ;Cfg. port Enable/Disable
  18++7426 ~            HC_CFG_PORT_DIS		EQU %000
  19++7426 ~            HC_CFG_PORT_EN		EQU	%100
  20++7426 ~
  21++7426 ~            ;Video memory bank: $4000 or $C000
  22++7426 ~            HC_CFG_VID_4000		EQU	%0000
  23++7426 ~            HC_CFG_VID_C000		EQU	%1000
  24++7426 ~
  25++7426 ~
  26++7426 ~            ;Standar BASIC config
  27++7426 ~            HC_CFG_BASIC		EQU	HC_CFG_ROM_BAS | HC_CFG_ROM_0000 | HC_CFG_VID_4000
  28++7426 ~            ;Standar CP/M config
  29++7426 ~            HC_CFG_CPM			EQU	HC_CFG_ROM_CPM | HC_CFG_ROM_E000 | HC_CFG_VID_C000
  30++7426 ~
  31++7426 ~
  32++7426 ~            HC_VID_BANK0		EQU	$4000
  33++7426 ~            HC_VID_BANK1		EQU	$C000
  34++7426 ~
  35++7426 ~            ;OUT: A = 0 for 40 tracks, 1 for 80 tracks, as set by jumper 5 on the IF1 board.
  36++7426 ~            ;Info from Rares Atodiresei.
  37++7426 ~            IsDrive2_80Tracks:
  38++7426 ~            	IFUSED
  39++7426 ~            	in	a, (HC_FLOPPY_PORT)
  40++7426 ~            	and %10
  41++7426 ~            	ret
  42++7426 ~            	ENDIF
  43++7426 ~
  44++7426              	endif
# file closed: hccfg.asm
   7+ 7426
   8+ 7426              COL             EQU 23728
   9+ 7426              LINE            EQU 23729               ;Coordinates
  10+ 7426              LineCol			EQU	COL
  11+ 7426              CODE			EQU 23681               ;Char to print
  12+ 7426
  13+ 7426              CPM_FNT         EQU $25AB
  14+ 7426
  15+ 7426              PORT_ZX			EQU	$FE
  16+ 7426
  17+ 7426              ;COLORS
  18+ 7426              CLR_BLACK		EQU 0
  19+ 7426              CLR_BLUE		EQU 1
  20+ 7426              CLR_RED			EQU 2
  21+ 7426              CLR_MAGENTA		EQU 3
  22+ 7426              CLR_GREEN		EQU 4
  23+ 7426              CLR_CYAN		EQU	5
  24+ 7426              CLR_YELLOW		EQU	6
  25+ 7426              CLR_WHITE		EQU	7
  26+ 7426              CLR_BRIGHT		EQU	%01000000
  27+ 7426              CLR_FLASH		EQU	%10000000
  28+ 7426
  29+ 7426              ;PAPER
  30+ 7426              PAPER_BLACK		EQU (CLR_BLACK << 3)
  31+ 7426              PAPER_BLUE		EQU (CLR_BLUE << 3)
  32+ 7426              PAPER_RED		EQU (CLR_RED << 3)
  33+ 7426              PAPER_MAGENTA	EQU (CLR_MAGENTA << 3)
  34+ 7426              PAPER_GREEN		EQU (CLR_GREEN << 3)
  35+ 7426              PAPER_CYAN		EQU	(CLR_CYAN << 3)
  36+ 7426              PAPER_YELLOW	EQU	(CLR_YELLOW << 3)
  37+ 7426              PAPER_WHITE		EQU	(CLR_WHITE << 3)
  38+ 7426
  39+ 7426              ;INK
  40+ 7426              INK_BLACK		EQU CLR_BLACK
  41+ 7426              INK_BLUE		EQU CLR_BLUE
  42+ 7426              INK_RED			EQU CLR_RED
  43+ 7426              INK_MAGENTA		EQU CLR_MAGENTA
  44+ 7426              INK_GREEN		EQU CLR_GREEN
  45+ 7426              INK_CYAN		EQU	CLR_CYAN
  46+ 7426              INK_YELLOW		EQU	CLR_YELLOW
  47+ 7426              INK_WHITE		EQU	CLR_WHITE
  48+ 7426
  49+ 7426
  50+ 7426              SCR_ATTR_ADDR	EQU 22528
  51+ 7426              SCR_ADDR		EQU 16384
  52+ 7426              SCR_PIX_LEN		EQU	6144
  53+ 7426              SCR_ATTR_LEN	EQU	768
  54+ 7426              SCR_LEN			EQU	SCR_PIX_LEN + SCR_ATTR_LEN
  55+ 7426              SCR_BYTES_PER_LINE	EQU	32
  56+ 7426
  57+ 7426              SCR_COLS		EQU	64
  58+ 7426              SCR_LINES		EQU 24
  59+ 7426
  60+ 7426              ;used for file names list positioning
  61+ 7426              LST_LINES_CNT	EQU	21
  62+ 7426              LST_FIRST_LINE	EQU	1
  63+ 7426              LST_LAST_LINE	EQU LST_FIRST_LINE + LST_LINES_CNT
  64+ 7426              LST_PROG_INFO	EQU LST_FIRST_LINE
  65+ 7426              LST_DISK_INFO	EQU LST_PROG_INFO + 3
  66+ 7426              LST_FILE_INFO	EQU LST_DISK_INFO + 3
  67+ 7426              LST_LINE_MSG	EQU LST_FILE_INFO + 6
  68+ 7426              LST_FIRST_COL	EQU	16
  69+ 7426              LST_MAX_FILES	EQU LST_LINES_CNT * 4
  70+ 7426
  71+ 7426              ;key codes
  72+ 7426              KEY_ESC			EQU	7
  73+ 7426              KEY_LEFT		EQU	8
  74+ 7426              KEY_RIGHT		EQU	9
  75+ 7426              KEY_DOWN		EQU	10
  76+ 7426              KEY_UP			EQU	11
  77+ 7426              KEY_BACKSP		EQU	12
  78+ 7426              KEY_ENTER		EQU	13
  79+ 7426              KEY_CTRL		EQU	14
  80+ 7426
  81+ 7426              SCR_DEF_CLR		EQU INK_CYAN | PAPER_BLACK | CLR_BRIGHT
  82+ 7426              SCR_SEL_CLR		EQU INK_BLACK | PAPER_GREEN | CLR_BRIGHT
  83+ 7426              SCR_LBL_CLR		EQU	SCR_SEL_CLR
  84+ 7426
  85+ 7426              ;Special formating chars
  86+ 7426              CHR_CR			EQU	13
  87+ 7426              CHR_LF			EQU	10
  88+ 7426              CHR_TAB			EQU	09
  89+ 7426
  90+ 7426
  91+ 7426              ;Semi-graphical chars
  92+ 7426              ;           UC
  93+ 7426              ;     UL +H-+--+UR
  94+ 7426              ;        |  |  |
  95+ 7426              ;     ML +--+--+MR
  96+ 7426              ;        V C|  |
  97+ 7426              ;     LL +--+--+LR
  98+ 7426              ;           DC
  99+ 7426              CHR_GRID        EQU 127
 100+ 7426              CHR_V           EQU 128
 101+ 7426              CHR_MR          EQU 129
 102+ 7426              CHR_UR          EQU 130
 103+ 7426              CHR_DL          EQU 131
 104+ 7426              CHR_DC          EQU 132
 105+ 7426              CHR_UC          EQU 133
 106+ 7426              CHR_ML          EQU 134
 107+ 7426              CHR_H           EQU 135
 108+ 7426              CHR_C           EQU 136
 109+ 7426              CHR_LR          EQU 137
 110+ 7426              CHR_UL          EQU 138
 111+ 7426              CHR_FULL        EQU 139
 112+ 7426              CHR_HALF        EQU 140
 113+ 7426
 114+ 7426              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 115+ 7426
 116+ 7426              ;Return read char in A
 117+ 7426              ReadChar:
 118+ 7426 CF           	rst 08
 119+ 7427 1B           	DEFB 27
 120+ 7428 C9           	ret
 121+ 7429
 122+ 7429              ;Checks if a key is pressed
 123+ 7429              ;Cy=1 if key is pressed
 124+ 7429              KbdHit:
 125+ 7429 CF           	rst 08
 126+ 742A 20           	DEFB 32
 127+ 742B C9           	ret
 128+ 742C              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 129+ 742C
 130+ 742C              InitFonts:
 131+ 742C              	IFUSED
 132+ 742C                  ;page-in CPM ROM to get fonts
 133+ 742C F3               di
 134+ 742D 3E 01            ld a, HC_CFG_ROM_CPM
 135+ 742F D3 7E            out	(HC_CFG_PORT), a
 136+ 7431
 137+ 7431 21 AB 25     	ld		hl, CPM_FNT
 138+ 7434 11 70 88     	ld		de, FontTable
 139+ 7437 01 68 03     	ld		bc, 872
 140+ 743A ED B0        	ldir
 141+ 743C
 142+ 743C                  ;restore BASIC ROM
 143+ 743C 3E 00            ld a, HC_CFG_ROM_BAS
 144+ 743E D3 7E            out	(HC_CFG_PORT), a
 145+ 7440 FB               ei
 146+ 7441
 147+ 7441 C9           	ret
 148+ 7442              	ENDIF
 149+ 7442
 150+ 7442              ClrScr:
 151+ 7442 2A 21 76     	ld		hl, (CurrScrAddr)
 152+ 7445 54           	ld		d, h
 153+ 7446 5D           	ld		e, l
 154+ 7447 13           	inc		de
 155+ 7448 01 FF 17     	ld		bc, SCR_PIX_LEN - 1
 156+ 744B 36 00        	ld		(hl), 0
 157+ 744D ED B0        	ldir
 158+ 744F
 159+ 744F 23           	inc 	hl
 160+ 7450 13           	inc		de
 161+ 7451
 162+ 7451 01 FF 02     	ld		bc, SCR_ATTR_LEN - 1
 163+ 7454 36 45        	ld		(hl), SCR_DEF_CLR
 164+ 7456 ED B0        	ldir
 165+ 7458
 166+ 7458              	;also set border color
 167+ 7458 3E 08        	ld		a, SCR_DEF_CLR >> 3
 168+ 745A D3 FE        	out		(PORT_ZX), a
 169+ 745C
 170+ 745C 3E 45        	ld		a, SCR_DEF_CLR
 171+ 745E 32 48 5C     	ld		(23624), a
 172+ 7461 C9           	ret
 173+ 7462
 174+ 7462              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 175+ 7462              ;IN: HL = str. addr, DE = line/col, str ends with last char bit 7 set
 176+ 7462              PrintStr:
 177+ 7462 7E           	ld		a, (hl)
 178+ 7463 FE 20        	cp		' '
 179+ 7465 30 02        	jr		nc, GoodChar
 180+ 7467 3E 3F        	ld		a, '?'
 181+ 7469              GoodChar:
 182+ 7469 CB 7F        	bit		7, a
 183+ 746B CB BF        	res		7, a
 184+ 746D 32 81 5C     	ld		(CODE), a
 185+ 7470 ED 53 B0 5C  	ld		(LineCol), de
 186+ 7474 08           	ex		af, af'
 187+ 7475 D9           	exx
 188+ 7476 E5           	push	hl
 189+ 7477 CD 8E 75     	call 	PrintChar
 190+ 747A E1           	pop		hl
 191+ 747B D9           	exx
 192+ 747C 08           	ex		af, af'
 193+ 747D C0           	ret		nz
 194+ 747E
 195+ 747E 1C           	inc		e
 196+ 747F 23           	inc		hl
 197+ 7480
 198+ 7480 7B           	ld		a, e
 199+ 7481 FE 40        	cp		64
 200+ 7483 38 DD        	jr		c, PrintStr
 201+ 7485 1E 00        	ld		e, 0
 202+ 7487 14           	inc		d
 203+ 7488
 204+ 7488 18 D8        	jr		PrintStr
 205+ 748A
 206+ 748A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 207+ 748A
 208+ 748A              ;IN: HL = string, DE = coords, A = color
 209+ 748A              PrintStrClr:
 210+ 748A 32 B6 74     	ld		(StrClr), a
 211+ 748D D5           	push	de
 212+ 748E CD 62 74     		call	PrintStr
 213+ 7491 E1           	pop		hl
 214+ 7492              	;get string len.
 215+ 7492 7B           	ld		a, e
 216+ 7493 95           	sub		l
 217+ 7494 1F           	rra
 218+ 7495 08           	ex		af, af'
 219+ 7496              		;line * 32
 220+ 7496 7C           		ld		a, h
 221+ 7497 17           		rla
 222+ 7498 17           		rla
 223+ 7499 11 00 00     		ld	de, 0
 224+ 749C 17           		rla
 225+ 749D CB 12        		rl	d
 226+ 749F 17           		rla
 227+ 74A0 CB 12        		rl	d
 228+ 74A2 17           		rla
 229+ 74A3 CB 12        		rl	d
 230+ 74A5 5F           		ld	e, a
 231+ 74A6
 232+ 74A6 26 00        		ld		h, 0
 233+ 74A8 19           		add		hl, de
 234+ 74A9 ED 5B 23 76  		ld		de, (CurrScrAttrAddr)
 235+ 74AD 19           		add		hl, de
 236+ 74AE 08           	ex		af, af'
 237+ 74AF 4F           	ld		c, a
 238+ 74B0 06 00        	ld		b, 0
 239+ 74B2 54           	ld		d, h
 240+ 74B3 5D           	ld		e, l
 241+ 74B4 13           	inc 	de
 242+ 74B5              StrClr	EQU	$ + 1
 243+ 74B5 36 28        	ld		(hl), INK_BLACK | PAPER_CYAN
 244+ 74B7 ED B0        	ldir
 245+ 74B9 C9           	ret
 246+ 74BA              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 247+ 74BA
 248+ 74BA              ;IN: B = length, D = line, E = col, A = char, C = horiz/vertical
 249+ 74BA              DrawLine:
 250+ 74BA 32 81 5C     	ld		(CODE), a
 251+ 74BD
 252+ 74BD 38 04        	jr		c, VertDir
 253+ 74BF 3E 1C        	ld		a, $1C
 254+ 74C1 18 02        	jr		StoreDir
 255+ 74C3              VertDir:
 256+ 74C3 3E 14        	ld		a, $14
 257+ 74C5              StoreDir:
 258+ 74C5 32 D5 74     	ld		(LineDir), a
 259+ 74C8
 260+ 74C8              DrawLineLoop:
 261+ 74C8 ED 53 B0 5C  	ld		(LineCol), de
 262+ 74CC D5           	push	de
 263+ 74CD D9           		exx
 264+ 74CE E5           		push	hl
 265+ 74CF CD 8E 75     		call 	PrintChar
 266+ 74D2 E1           		pop		hl
 267+ 74D3 D9           		exx
 268+ 74D4 D1           	pop		de
 269+ 74D5              LineDir:
 270+ 74D5 1C           	inc		e
 271+ 74D6 10 F0        	djnz	DrawLineLoop
 272+ 74D8
 273+ 74D8 C9           	ret
 274+ 74D9
 275+ 74D9              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 276+ 74D9
 277+ 74D9              DrawHLines:
 278+ 74D9 11 00 00     	ld		de, 0
 279+ 74DC 06 40        	ld		b, 64
 280+ 74DE 3E 87        	ld		a, CHR_H
 281+ 74E0 B7           	or		a
 282+ 74E1 CD BA 74     	call	DrawLine
 283+ 74E4
 284+ 74E4 11 00 16     	ld		de, LST_LAST_LINE << 8
 285+ 74E7 06 40        	ld		b, 64
 286+ 74E9 3E 87        	ld		a, CHR_H
 287+ 74EB B7           	or		a
 288+ 74EC CD BA 74     	call	DrawLine
 289+ 74EF
 290+ 74EF 06 04        	ld		b, 4
 291+ 74F1 11 10 00     	ld		de, LST_FIRST_COL
 292+ 74F4              DrawUpperIntersectLoop:
 293+ 74F4 C5           	push	bc
 294+ 74F5 D5           	push	de
 295+ 74F6 3E 85        		ld		a, CHR_UC
 296+ 74F8 CD 1A 75     		call	DrawIntersect
 297+ 74FB D1           	pop		de
 298+ 74FC C1           	pop		bc
 299+ 74FD 21 0C 00     	ld		hl, NAMELEN+1
 300+ 7500 19           	add		hl, de
 301+ 7501 EB           	ex		de, hl
 302+ 7502 10 F0        	djnz	DrawUpperIntersectLoop
 303+ 7504
 304+ 7504 06 04        	ld		b, 4
 305+ 7506 11 10 16     	ld		de, (LST_LAST_LINE << 8) | LST_FIRST_COL
 306+ 7509              DrawLowerIntersectLoop:
 307+ 7509 C5           	push	bc
 308+ 750A D5           	push	de
 309+ 750B 3E 84        		ld		a, CHR_DC
 310+ 750D CD 1A 75     		call	DrawIntersect
 311+ 7510 D1           	pop		de
 312+ 7511 C1           	pop		bc
 313+ 7512 21 0C 00     	ld		hl, NAMELEN+1
 314+ 7515 19           	add		hl, de
 315+ 7516 EB           	ex		de, hl
 316+ 7517 10 F0        	djnz	DrawLowerIntersectLoop
 317+ 7519
 318+ 7519 C9           	ret
 319+ 751A
 320+ 751A
 321+ 751A              DrawIntersect:
 322+ 751A 21 B0 5C     	ld		hl, LineCol
 323+ 751D 73           	ld		(hl), e
 324+ 751E 23           	inc		hl
 325+ 751F 72           	ld		(hl), d
 326+ 7520 2B           	dec		hl
 327+ 7521 32 81 5C     	ld		(CODE), a
 328+ 7524 E5           	push	hl
 329+ 7525 CD 8E 75     	call	PrintChar
 330+ 7528 E1           	pop		hl
 331+ 7529 34           	inc		(hl)
 332+ 752A 3E 87        	ld		a, CHR_H
 333+ 752C 32 81 5C     	ld		(CODE), a
 334+ 752F CD 8E 75     	call	PrintChar
 335+ 7532 C9           	ret
 336+ 7533
 337+ 7533
 338+ 7533              DrawVLines:
 339+ 7533 06 04        	ld		b, 4
 340+ 7535 11 10 01     	ld		de, (LST_FIRST_LINE << 8) | LST_FIRST_COL
 341+ 7538              DrawVLinesLoop:
 342+ 7538 C5           	push 	bc
 343+ 7539 D5           	push	de
 344+ 753A 06 15        		ld		b, LST_LINES_CNT
 345+ 753C 3E 80        		ld		a, CHR_V
 346+ 753E 37           		scf
 347+ 753F CD BA 74     		call	DrawLine
 348+ 7542 D1           	pop		de
 349+ 7543 C1           	pop	bc
 350+ 7544 7B           	ld		a, e
 351+ 7545 C6 0C        	add		NAMELEN+1
 352+ 7547 5F           	ld		e, a
 353+ 7548 10 EE        	djnz	DrawVLinesLoop
 354+ 754A C9           	ret
 355+ 754B
 356+ 754B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 357+ 754B
 358+ 754B              ;IN: A = color mask
 359+ 754B              DrawCursor:
 360+ 754B ED 5B 8A 7D  	ld	de, (CursorAddr)
 361+ 754F 06 06        	ld	b, 	(NAMELEN + 1)/2
 362+ 7551              DrawCursorLoop:
 363+ 7551 12           	ld	(de), a
 364+ 7552 13           	inc de
 365+ 7553 10 FC        	djnz DrawCursorLoop
 366+ 7555 C9           	ret
 367+ 7556
 368+ 7556              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 369+ 7556
 370+ 7556              ;IN:	A = file idx.
 371+ 7556              MoveCursor:
 372+ 7556              	;File idx / SCR_LINES => cursor line & column
 373+ 7556 6F           	ld		l, a
 374+ 7557 26 00        	ld		h, 0
 375+ 7559 0E 15        	ld		c, LST_LINES_CNT
 376+ 755B CD 2C 6B     	call	Div					;HL = file column, A = line
 377+ 755E
 378+ 755E              	;cursor addr = SCR_ATTR_ADDR + (line + LST_FIRST_LINE) * SCR_BYTES_PER_LINE + column * NAMELEN/2
 379+ 755E C6 01        	add		LST_FIRST_LINE
 380+ 7560
 381+ 7560
 382+ 7560 54           	ld d, h
 383+ 7561 5D           	ld e, l
 384+ 7562 21 00 00     	ld	hl, 0
 385+ 7565
 386+ 7565              	;line*32
 387+ 7565 17           	rla
 388+ 7566 17           	rla
 389+ 7567 17           	rla
 390+ 7568 17           	rla
 391+ 7569 CB 14        	rl h
 392+ 756B 17           	rla
 393+ 756C CB 14        	rl h
 394+ 756E 6F           	ld l, a
 395+ 756F
 396+ 756F
 397+ 756F              	;col * 6
 398+ 756F E5           	push	hl					;save line * 32
 399+ 7570 3E 06        		ld		a, (NAMELEN + 1)/2
 400+ 7572 CD 4C 6B     		call	Mul				;HL = column * 12/2
 401+ 7575 D1           	pop		de
 402+ 7576 19           	add		hl, de
 403+ 7577
 404+ 7577 11 08 00     	ld		de, LST_FIRST_COL/2
 405+ 757A ED 4B 23 76  	ld		bc, (CurrScrAttrAddr)
 406+ 757E 19           	add		hl, de
 407+ 757F 09           	add		hl, bc
 408+ 7580
 409+ 7580              	;clear old cursor
 410+ 7580 3E 45        	ld		a, SCR_DEF_CLR
 411+ 7582 CD 4B 75     	call	DrawCursor
 412+ 7585
 413+ 7585              	;draw new one
 414+ 7585 22 8A 7D     	ld		(CursorAddr), hl
 415+ 7588 3E 60        	ld		a, SCR_SEL_CLR
 416+ 758A CD 4B 75     	call	DrawCursor
 417+ 758D
 418+ 758D C9           	ret
 419+ 758E
 420+ 758E              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 421+ 758E
 422+ 758E              PrintChar:
 423+ 758E ED 5B B0 5C      ld		de, (LineCol)
 424+ 7592
 425+ 7592                  ;calculate 64 column screen address
 426+ 7592              	;IN: D = line, E = col
 427+ 7592              	;OUT: HL = screen address
 428+ 7592
 429+ 7592 CB 3B            SRL     E                                       ;col = col/2
 430+ 7594 CB 19            RR      C                                       ;mark odd/even column
 431+ 7596 7A               LD      A, D                            ;A = line
 432+ 7597 E6 18            AND 24                                  ;keep only %00011000
 433+ 7599 2A 21 76         ld		hl, (CurrScrAddr)
 434+ 759C B4               OR      h								;add screen start address
 435+ 759D 67               LD      H, A                            ;save H
 436+ 759E 7A               LD      A, D                            ;A = line
 437+ 759F E6 07            AND 7                                   ;keep only %00000111
 438+ 75A1 0F               RRCA                                    ;%10000011
 439+ 75A2 0F               RRCA                                    ;%11000001
 440+ 75A3 0F               RRCA                                    ;%11100000
 441+ 75A4 B3               OR      E                                       ;add column
 442+ 75A5 6F               LD      L, A                            ;HL = screen address
 443+ 75A6
 444+ 75A6              PrintChar3:
 445+ 75A6                  ;get font address
 446+ 75A6 E5               PUSH HL
 447+ 75A7 AF                   XOR A
 448+ 75A8 67                   LD  H, A
 449+ 75A9 3A 81 5C             LD  A, (CODE)
 450+ 75AC D6 20                SUB ' '
 451+ 75AE 6F                   LD  L, A
 452+ 75AF 29                   ADD     HL, HL                  ;char code = char code * 8
 453+ 75B0 29                   ADD     HL, HL                  ;i.e. offset into font table
 454+ 75B1 29                   ADD     HL, HL
 455+ 75B2 11 70 88             LD      DE, FontTable             ;get font table
 456+ 75B5 19                   ADD     HL, DE
 457+ 75B6 EB                   EX      DE, HL                  ;DE = our char font address
 458+ 75B7 E1               POP     HL
 459+ 75B8
 460+ 75B8
 461+ 75B8                  ;print a char
 462+ 75B8 06 08            LD      B, 8                            ;char height is 8 lines
 463+ 75BA              PrintCharLine:
 464+ 75BA 1A                   LD      A, (DE)                         ;load char line in A
 465+ 75BB
 466+ 75BB CB 79                BIT     7, C                            ;restore correct position of the 2 chars in cell if on odd column
 467+ 75BD 20 06                JR  	NZ, NoTurn
 468+ 75BF
 469+ 75BF 07                   RLCA
 470+ 75C0 07                   RLCA
 471+ 75C1 07                   RLCA
 472+ 75C2 07                   RLCA
 473+ 75C3 18 01                JR      Store
 474+ 75C5              NoTurn:
 475+ 75C5 B6                   OR (HL)
 476+ 75C6              Store:
 477+ 75C6 77                   LD (HL), A
 478+ 75C7
 479+ 75C7 13                   INC     DE                                      ;next char line in font table
 480+ 75C8 24                   INC     H                                       ;next char line on screen
 481+ 75C9 10 EF            DJNZ PrintCharLine                  ;last line of char?
 482+ 75CB
 483+ 75CB C9               ret
 484+ 75CC
 485+ 75CC              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 486+ 75CC
 487+ 75CC              ;DE = screen coord; Output: DataBuf == read string, terminated at ' ' | $80
 488+ 75CC              ReadString:
 489+ 75CC 21 D8 8B     	ld		hl, FileData
 490+ 75CF D5           	push	de
 491+ 75D0 DD E1        	pop		ix
 492+ 75D2
 493+ 75D2              ReadStringLoop:
 494+ 75D2 D5           	push	de
 495+ 75D3 E5           	push	hl
 496+ 75D4 CD 26 74     		call ReadChar
 497+ 75D7 E1           	pop		hl
 498+ 75D8 D1           	pop		de
 499+ 75D9
 500+ 75D9 FE 0D        	cp	KEY_ENTER
 501+ 75DB C8           	ret z
 502+ 75DC
 503+ 75DC FE 0C        	cp  KEY_BACKSP
 504+ 75DE 20 0F        	jr	nz, ReadStrChar
 505+ 75E0
 506+ 75E0 E5           	push hl
 507+ 75E1 01 D9 8B     	ld   bc, FileData+1
 508+ 75E4 ED 42        	sbc	 hl, bc
 509+ 75E6 E1           	pop  hl
 510+ 75E7 38 16        	jr   c, ReadStrPrint
 511+ 75E9
 512+ 75E9 1B           	dec	de
 513+ 75EA 2B           	dec	hl
 514+ 75EB 36 20        	ld	(hl), ' '
 515+ 75ED 18 10        	jr	ReadStrPrint
 516+ 75EF
 517+ 75EF              ReadStrChar:
 518+ 75EF FE 20        	cp	' '
 519+ 75F1 38 DF        	jr	c, ReadStringLoop
 520+ 75F3 FE 8C        	cp	CHR_HALF
 521+ 75F5 30 DB        	jr	nc, ReadStringLoop
 522+ 75F7
 523+ 75F7              	;Check end of string and go back if found.
 524+ 75F7 46           	ld	b, (hl)
 525+ 75F8 CB 78        	bit 7, b
 526+ 75FA 20 03        	jr	nz, ReadStrPrint
 527+ 75FC
 528+ 75FC 77           	ld	(hl), a
 529+ 75FD 23           	inc	hl
 530+ 75FE 13           	inc	de
 531+ 75FF
 532+ 75FF              ReadStrPrint:
 533+ 75FF E5           	push	hl
 534+ 7600 D5           	push	de
 535+ 7601 21 D8 8B     	ld		hl, FileData
 536+ 7604 DD E5        	push	ix
 537+ 7606 D1           	pop		de
 538+ 7607 CD 62 74     	call	PrintStr
 539+ 760A D1           	pop		de
 540+ 760B E1           	pop		hl
 541+ 760C
 542+ 760C 18 C4        	jr		ReadStringLoop
 543+ 760E
 544+ 760E              ClearNMsgLines:
 545+ 760E 11 00 0E     	ld		de, LST_LINE_MSG + 1 << 8
 546+ 7611              ClearNMsgLinesLoop:
 547+ 7611 D5           	push	de
 548+ 7612 C5           	push	bc
 549+ 7613 21 23 7C     	ld		hl, MsgClear
 550+ 7616 3E 45        	ld		a, SCR_DEF_CLR
 551+ 7618 CD 8A 74     	call	PrintStrClr
 552+ 761B C1           	pop		bc
 553+ 761C D1           	pop		de
 554+ 761D 14           	inc		d
 555+ 761E 10 F1        	djnz	ClearNMsgLinesLoop
 556+ 7620
 557+ 7620 C9           	ret
 558+ 7621
 559+ 7621 00 40        CurrScrAddr		DEFW	SCR_ADDR
 560+ 7623 00 58        CurrScrAttrAddr	DEFW	SCR_ATTR_ADDR
 561+ 7625
 562+ 7625                 	endif
# file closed: ui.asm
1499  7625              	include "math.asm"
# file opened: math.asm
   1+ 7625              	ifndef	_MATH_
   2+ 7625 ~            	define	_MATH_
   3+ 7625 ~
   4+ 7625 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5+ 7625 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6+ 7625 ~
   7+ 7625 ~
   8+ 7625 ~            Word2Txt:
   9+ 7625 ~            	IFUSED
  10+ 7625 ~            	push	de
  11+ 7625 ~            		call	Word2Txt_
  12+ 7625 ~            	pop	de
  13+ 7625 ~
  14+ 7625 ~            	ld	b, 4
  15+ 7625 ~            	call	StrippLeading0
  16+ 7625 ~            	ret
  17+ 7625 ~
  18+ 7625 ~            Byte2Txt:
  19+ 7625 ~            	push	de
  20+ 7625 ~            		call	Byte2Txt_
  21+ 7625 ~            	pop	de
  22+ 7625 ~
  23+ 7625 ~            	ld	b, 2
  24+ 7625 ~            	call	StrippLeading0
  25+ 7625 ~            	ret
  26+ 7625 ~            	ENDIF
  27+ 7625 ~
  28+ 7625 ~
  29+ 7625 ~            StrippLeading0:
  30+ 7625 ~            	ld	a, (de)
  31+ 7625 ~            	cp	'1'
  32+ 7625 ~            	ret	nc
  33+ 7625 ~
  34+ 7625 ~            	ld	a, ' '
  35+ 7625 ~            	ld	(de), a
  36+ 7625 ~            	inc	de
  37+ 7625 ~            	djnz	StrippLeading0
  38+ 7625 ~            	ret
  39+ 7625 ~
  40+ 7625 ~
  41+ 7625 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42+ 7625 ~            Word2Txt_:
  43+ 7625 ~            	ld bc, -10000
  44+ 7625 ~            	call DigitLoop
  45+ 7625 ~            	ld bc, -1000
  46+ 7625 ~            	call DigitLoop
  47+ 7625 ~            Byte2Txt_:
  48+ 7625 ~            	ld bc, -100
  49+ 7625 ~            	call DigitLoop
  50+ 7625 ~            	ld bc, -10
  51+ 7625 ~            	call DigitLoop
  52+ 7625 ~            	ld bc, -1
  53+ 7625 ~
  54+ 7625 ~            DigitLoop:
  55+ 7625 ~            	ld	a, '0' - 1
  56+ 7625 ~            DivNrLoop:
  57+ 7625 ~            	inc	a		;increase reminder
  58+ 7625 ~            	add	hl, bc	;substract divizor
  59+ 7625 ~            	jr	c, DivNrLoop	;still dividing?
  60+ 7625 ~            	sbc	hl, bc	;nope, restore
  61+ 7625 ~
  62+ 7625 ~            	ld (de), a
  63+ 7625 ~            	inc de
  64+ 7625 ~            	ret
  65+ 7625 ~
  66+ 7625 ~
  67+ 7625 ~            ;Input: HL = Dividend, C = Divisor
  68+ 7625 ~            ;Output: HL = Quotient, A = Remainder
  69+ 7625 ~            ;Warning: doesn't work with divisor >= $80
  70+ 7625 ~            Div:
  71+ 7625 ~            	IFUSED
  72+ 7625 ~            	xor a
  73+ 7625 ~            	ld b, 16
  74+ 7625 ~
  75+ 7625 ~            DivLoop:
  76+ 7625 ~            	add	hl,hl
  77+ 7625 ~            	rla
  78+ 7625 ~            	cp	c
  79+ 7625 ~            	jr	c, NoSub
  80+ 7625 ~            	sub	c
  81+ 7625 ~            	inc	l
  82+ 7625 ~            NoSub:
  83+ 7625 ~            	djnz DivLoop
  84+ 7625 ~
  85+ 7625 ~            	ret
  86+ 7625 ~            	ENDIF
  87+ 7625 ~
  88+ 7625 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89+ 7625 ~            ;Output: A:C = Quotient, HL = Remainder
  90+ 7625 ~            Div2:
  91+ 7625 ~            	ld hl, 0
  92+ 7625 ~            	ld b, 16
  93+ 7625 ~            Div2Loop:
  94+ 7625 ~            	sll c	; unroll 16 times
  95+ 7625 ~            	rla		; ...
  96+ 7625 ~            	adc	hl,hl	; ...
  97+ 7625 ~            	sbc	hl,de	; ...
  98+ 7625 ~            	jr	nc,$+4	; ...
  99+ 7625 ~            	add	hl,de	; ...
 100+ 7625 ~            	dec	c	; ...
 101+ 7625 ~            	djnz Div2Loop
 102+ 7625 ~            	ret
 103+ 7625 ~
 104+ 7625 ~
 105+ 7625 ~            ;Input: A = Multiplier, DE = Multiplicand
 106+ 7625 ~            ;Output: A:HL = Product
 107+ 7625 ~            Mul:
 108+ 7625 ~            	IFUSED
 109+ 7625 ~            	ld hl, 0
 110+ 7625 ~            	ld bc, $0700
 111+ 7625 ~
 112+ 7625 ~            	add	a, a	; optimised 1st iteration
 113+ 7625 ~            	jr	nc, MulLoop
 114+ 7625 ~            	ld	h, d
 115+ 7625 ~            	ld	l, e
 116+ 7625 ~
 117+ 7625 ~            MulLoop:
 118+ 7625 ~            	add	hl,hl
 119+ 7625 ~            	rla
 120+ 7625 ~            	jr	nc, NoAdd
 121+ 7625 ~            	add	hl,de
 122+ 7625 ~            	adc	a,c
 123+ 7625 ~            NoAdd:
 124+ 7625 ~            	djnz MulLoop
 125+ 7625 ~
 126+ 7625 ~            	ret
 127+ 7625 ~            	ENDIF
 128+ 7625 ~
 129+ 7625 ~
 130+ 7625 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131+ 7625 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132+ 7625 ~            Byte2Hex:
 133+ 7625 ~            	xor	a
 134+ 7625 ~            	rld
 135+ 7625 ~            	call	Byte2HexNibble
 136+ 7625 ~
 137+ 7625 ~            Byte2HexNibble:
 138+ 7625 ~            	push	af
 139+ 7625 ~            	daa
 140+ 7625 ~            	add	a,$F0
 141+ 7625 ~            	adc	a,$40
 142+ 7625 ~
 143+ 7625 ~            	ld	(de), a
 144+ 7625 ~            	inc	de
 145+ 7625 ~
 146+ 7625 ~            	pop	af
 147+ 7625 ~            	rld
 148+ 7625 ~            	ret
 149+ 7625 ~
 150+ 7625 ~
 151+ 7625 ~            Byte2HexHex:
 152+ 7625 ~            	call	Byte2Hex
 153+ 7625 ~            	inc	hl
 154+ 7625 ~            	ld	a, ' '
 155+ 7625 ~            	ld	(de), a
 156+ 7625 ~            	inc	de
 157+ 7625 ~            	ret
 158+ 7625 ~
 159+ 7625 ~            Byte2HexChar:
 160+ 7625 ~            	ld	a, CHAR_CR
 161+ 7625 ~            	cp	(hl)
 162+ 7625 ~            	jr	nz, Bin2HexLineLoopTextCopy
 163+ 7625 ~
 164+ 7625 ~            Bin2HexLineLoopTextReplace:
 165+ 7625 ~            	ld	a, '.'
 166+ 7625 ~            	ld	(hl), a
 167+ 7625 ~
 168+ 7625 ~            Bin2HexLineLoopTextCopy:
 169+ 7625 ~            	ldi
 170+ 7625 ~            	ret
 171+ 7625 ~
 172+ 7625 ~
 173+ 7625 ~            HEX_COLUMNS	EQU	16
 174+ 7625 ~
 175+ 7625 ~            Bin2HexLine:
 176+ 7625 ~            	;Hex part
 177+ 7625 ~            	ld	b, HEX_COLUMNS
 178+ 7625 ~            	push	hl
 179+ 7625 ~            Bin2HexLineLoopHex:
 180+ 7625 ~            		call	Byte2HexHex
 181+ 7625 ~            		djnz	Bin2HexLineLoopHex
 182+ 7625 ~            	pop	hl
 183+ 7625 ~
 184+ 7625 ~            	dec	de
 185+ 7625 ~            	ld	a, CHR_V
 186+ 7625 ~            	ld	(de), a
 187+ 7625 ~            	inc	de
 188+ 7625 ~
 189+ 7625 ~            	ld	ixh, d
 190+ 7625 ~            	ld	ixl, e
 191+ 7625 ~            	ld	(ix - (HEX_COLUMNS/2)*3 - 1), a
 192+ 7625 ~
 193+ 7625 ~            	;String part
 194+ 7625 ~            Bin2HexLineText:
 195+ 7625 ~            	;just to not alter B with LDI, set C to something > 16
 196+ 7625 ~            	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 197+ 7625 ~            Bin2HexLineLoopText:
 198+ 7625 ~            	call	Byte2HexChar
 199+ 7625 ~            	djnz	Bin2HexLineLoopText
 200+ 7625 ~            	ret
 201+ 7625 ~
 202+ 7625 ~
 203+ 7625 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 204+ 7625 ~            ;Converts binary buffer at HL to hex string at DE
 205+ 7625 ~            Bin2HexStr:
 206+ 7625 ~            	;Calculate the number of full lines by dividing BC to 16.
 207+ 7625 ~            	xor	a
 208+ 7625 ~
 209+ 7625 ~            	rr	b
 210+ 7625 ~            	rr	c
 211+ 7625 ~            	rra
 212+ 7625 ~
 213+ 7625 ~            	rr	b
 214+ 7625 ~            	rr	c
 215+ 7625 ~            	rra
 216+ 7625 ~
 217+ 7625 ~            	rr	b
 218+ 7625 ~            	rr	c
 219+ 7625 ~            	rra
 220+ 7625 ~
 221+ 7625 ~            	rr	b
 222+ 7625 ~            	rr	c
 223+ 7625 ~            	rra
 224+ 7625 ~
 225+ 7625 ~            	rra
 226+ 7625 ~            	rra
 227+ 7625 ~            	rra
 228+ 7625 ~            	rra
 229+ 7625 ~
 230+ 7625 ~            	ex		af, af'		;Keep reminder
 231+ 7625 ~
 232+ 7625 ~            Bin2HexStrLoop:
 233+ 7625 ~            	push	bc
 234+ 7625 ~            		call	Bin2HexLine
 235+ 7625 ~            	pop	bc
 236+ 7625 ~
 237+ 7625 ~            	dec	bc
 238+ 7625 ~            	ld	a, b
 239+ 7625 ~            	or	c
 240+ 7625 ~            	jr	nz, Bin2HexStrLoop
 241+ 7625 ~
 242+ 7625 ~            	;Set remaining imcomplete line.
 243+ 7625 ~            	;Exit if last line is empty.
 244+ 7625 ~            	ex	af, af'
 245+ 7625 ~            	or	a
 246+ 7625 ~            	ret	z
 247+ 7625 ~            	ex	af, af'
 248+ 7625 ~
 249+ 7625 ~            	;Clear the whole last line.
 250+ 7625 ~            	push	de
 251+ 7625 ~            	push	hl
 252+ 7625 ~            		ld	a, ' '
 253+ 7625 ~            		ld	b, COL_CNT
 254+ 7625 ~            Bin2HexLineClear:
 255+ 7625 ~            		ld	(de), a
 256+ 7625 ~            		inc	de
 257+ 7625 ~            		djnz	Bin2HexLineClear
 258+ 7625 ~            	pop	hl
 259+ 7625 ~            	pop	de
 260+ 7625 ~
 261+ 7625 ~            	;Save start of last line.
 262+ 7625 ~            	push	de
 263+ 7625 ~            	pop	ix
 264+ 7625 ~            	push	ix
 265+ 7625 ~
 266+ 7625 ~            	;Save start of char part in IX.
 267+ 7625 ~            	ld	bc, HEX_COLUMNS*3
 268+ 7625 ~            	add	ix, bc
 269+ 7625 ~
 270+ 7625 ~            	;Write the hex and char parts of line.
 271+ 7625 ~            	ex	af, af'
 272+ 7625 ~            	ld	b, a
 273+ 7625 ~            	ld	c, HEX_COLUMNS*2
 274+ 7625 ~
 275+ 7625 ~            Bin2HexLineLoopHex2:
 276+ 7625 ~            	call	Byte2HexHex
 277+ 7625 ~            	dec	hl
 278+ 7625 ~
 279+ 7625 ~            	push	de
 280+ 7625 ~            		ld	e, ixl
 281+ 7625 ~            		ld	d, ixh
 282+ 7625 ~            		ld	c, 1
 283+ 7625 ~            		call	Byte2HexChar
 284+ 7625 ~            	pop	de
 285+ 7625 ~
 286+ 7625 ~            	inc	ix
 287+ 7625 ~            	djnz	Bin2HexLineLoopHex2
 288+ 7625 ~
 289+ 7625 ~            	;Save end of buffer in DE, to let the caller know where the buffer ends.
 290+ 7625 ~            	ld	e, ixl
 291+ 7625 ~            	ld	d, ixh
 292+ 7625 ~
 293+ 7625 ~            	pop	ix
 294+ 7625 ~            	;Write delimiters.
 295+ 7625 ~            	ld	a, CHR_V
 296+ 7625 ~            	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 297+ 7625 ~            	ld	(ix + HEX_COLUMNS*3 - 1), a
 298+ 7625 ~
 299+ 7625 ~            	ret
 300+ 7625 ~
 301+ 7625              	endif
# file closed: math.asm
1500  7625              	include "txtview.asm"
# file opened: txtview.asm
   1+ 7625              	IFNDEF _TXTVIEW_
   2+ 7625              	DEFINE _TXTVIEW_
   3+ 7625
   4+ 7625              LINE_CNT	EQU	23
   5+ 7625              COL_CNT		EQU	64
   6+ 7625
   7+ 7625              CHAR_CR	EQU	$0D
   8+ 7625              CHAR_LF	EQU	$0A
   9+ 7625              CHAR_TAB	EQU	$09
  10+ 7625              CHAR_EOF	EQU	$1A
  11+ 7625
  12+ 7625              COORDS		EQU	23728	;Coordinates
  13+ 7625              SCRLinesDown	EQU	PRN_BUF
  14+ 7625              SCRLinesUp	EQU	SCRLinesDown + LINE_CNT*2
  15+ 7625
  16+ 7625
  17+ 7625              	include "scroll.asm"
# file opened: scroll.asm
   1++7625              ;Scrolling routines for UP/DOWN
   2++7625              ;They use 2 tables of pointers of screen cell rows.
   3++7625              ;One table has addresses in increasing order, for scroll down,
   4++7625              ;the other in decreasing order, for scroll up, so the same
   5++7625              ;scroll routine is used in both cases.
   6++7625              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   7++7625
   8++7625              ; Char Down
   9++7625              ; Adjusts screen address HL to move eight pixels down on the display.
  10++7625              ; enter: HL = valid screen address
  11++7625              ; exit : HL = moves one character down
  12++7625              ; used : AF, HL
  13++7625              GetCellDown:
  14++7625 7D           	ld a,l
  15++7626 C6 20        	add a,$20
  16++7628 6F           	ld l,a
  17++7629 D0           	ret nc
  18++762A 7C           	ld a,h
  19++762B C6 08        	add a,$08
  20++762D 67           	ld h,a
  21++762E C9           	ret
  22++762F
  23++762F              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  24++762F              ;Fills the two tables with pointers.
  25++762F              ScrollInit:
  26++762F 21 00 40     	ld		hl, SCR_ADDR
  27++7632 06 17        	ld		b, LINE_CNT
  28++7634 DD 21 00 5B  	ld		ix, SCRLinesDown
  29++7638
  30++7638              	;Don't init again if already did it.
  31++7638 DD 7E 00     	ld		a, (ix)
  32++763B BD           	cp		l
  33++763C 20 05        	jr		nz, FillScrLinesLoop
  34++763E DD 7E 01     	ld		a, (ix+1)
  35++7641 BC           	cp		h
  36++7642 C8           	ret		z
  37++7643
  38++7643              FillScrLinesLoop:
  39++7643 DD 75 00     	ld		(ix), l
  40++7646 DD 74 01     	ld		(ix+1), h
  41++7649 DD 23        	inc		ix
  42++764B DD 23        	inc		ix
  43++764D              	;inc. pointer in destination table (of pointers to lines)
  44++764D CD 25 76     	call	GetCellDown
  45++7650 10 F1        	djnz	FillScrLinesLoop
  46++7652
  47++7652              	;now fill the table in reverse, every 2 bytes
  48++7652 DD E5        	push	ix
  49++7654 E1           	pop		hl
  50++7655 2B           	dec		hl
  51++7656 06 17        	ld		b, LINE_CNT
  52++7658              FillScrLinesRev:
  53++7658 56           	ld		d, (hl)
  54++7659 2B           	dec		hl
  55++765A 5E           	ld		e, (hl)
  56++765B 2B           	dec		hl
  57++765C
  58++765C DD 73 00     	ld		(ix), e
  59++765F DD 72 01     	ld		(ix+1), d
  60++7662 DD 23        	inc		ix
  61++7664 DD 23        	inc		ix
  62++7666 10 F0        	djnz	FillScrLinesRev
  63++7668 C9           	ret
  64++7669
  65++7669              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  66++7669              ScrollUp:
  67++7669 21 2E 5B     	ld		hl, SCRLinesUp
  68++766C 18 03        	jr		Scroll
  69++766E
  70++766E              ScrollDown:
  71++766E 21 00 5B     	ld		hl, SCRLinesDown
  72++7671
  73++7671              Scroll:
  74++7671 22 7F 76     	ld		(ScrollDownPtrDest), hl
  75++7674 23           	inc		hl
  76++7675 23           	inc		hl
  77++7676 22 82 76     	ld		(ScrollDownPtrSrc), hl
  78++7679 0E 16        	ld		c, LINE_CNT - 1
  79++767B
  80++767B              ScrollDownLoop2:
  81++767B 06 04        	ld		b, 4
  82++767D              ScrollDownPtrDest	EQU	$ + 2
  83++767D ED 5B 00 5B  	ld		de, (SCRLinesDown)
  84++7681              ScrollDownPtrSrc	EQU	$ + 1
  85++7681 2A 02 5B     	ld		hl, (SCRLinesDown + 2)
  86++7684
  87++7684              ScrollDownLoop:					;copy a single char line
  88++7684 C5           	push	bc
  89++7685 01 20 00     	ld		bc, 32
  90++7688 ED B0        	ldir
  91++768A 2B           	dec		hl
  92++768B 1B           	dec		de
  93++768C 24           	inc		h
  94++768D 14           	inc		d
  95++768E 01 20 00     	ld		bc, 32
  96++7691 ED B8        	lddr
  97++7693 23           	inc		hl
  98++7694 13           	inc		de
  99++7695 24           	inc		h
 100++7696 14           	inc		d
 101++7697 C1           	pop		bc
 102++7698 10 EA        	djnz	ScrollDownLoop
 103++769A
 104++769A 0D           	dec		c
 105++769B C8           	ret		z
 106++769C
 107++769C 2A 82 76     	ld		hl, (ScrollDownPtrSrc)
 108++769F 22 7F 76     	ld		(ScrollDownPtrDest), hl
 109++76A2 23           	inc		hl
 110++76A3 23           	inc		hl
 111++76A4 22 82 76     	ld		(ScrollDownPtrSrc), hl
 112++76A7 18 D2        	jr		ScrollDownLoop2
# file closed: scroll.asm
  18+ 76A9              	include "math.asm"
# file opened: math.asm
   1++76A9              	ifndef	_MATH_
   2++76A9 ~            	define	_MATH_
   3++76A9 ~
   4++76A9 ~            ;The folowing 3 routines where inspired or taken from: Milos "baze" Bazelides, baze@stonline.sk
   5++76A9 ~            ;http://map.tni.nl/sources/external/z80bits.html
   6++76A9 ~
   7++76A9 ~
   8++76A9 ~            Word2Txt:
   9++76A9 ~            	IFUSED
  10++76A9 ~            	push	de
  11++76A9 ~            		call	Word2Txt_
  12++76A9 ~            	pop	de
  13++76A9 ~
  14++76A9 ~            	ld	b, 4
  15++76A9 ~            	call	StrippLeading0
  16++76A9 ~            	ret
  17++76A9 ~
  18++76A9 ~            Byte2Txt:
  19++76A9 ~            	push	de
  20++76A9 ~            		call	Byte2Txt_
  21++76A9 ~            	pop	de
  22++76A9 ~
  23++76A9 ~            	ld	b, 2
  24++76A9 ~            	call	StrippLeading0
  25++76A9 ~            	ret
  26++76A9 ~            	ENDIF
  27++76A9 ~
  28++76A9 ~
  29++76A9 ~            StrippLeading0:
  30++76A9 ~            	ld	a, (de)
  31++76A9 ~            	cp	'1'
  32++76A9 ~            	ret	nc
  33++76A9 ~
  34++76A9 ~            	ld	a, ' '
  35++76A9 ~            	ld	(de), a
  36++76A9 ~            	inc	de
  37++76A9 ~            	djnz	StrippLeading0
  38++76A9 ~            	ret
  39++76A9 ~
  40++76A9 ~
  41++76A9 ~            ;Converts the number in HL to ASCII in decimal string at DE
  42++76A9 ~            Word2Txt_:
  43++76A9 ~            	ld bc, -10000
  44++76A9 ~            	call DigitLoop
  45++76A9 ~            	ld bc, -1000
  46++76A9 ~            	call DigitLoop
  47++76A9 ~            Byte2Txt_:
  48++76A9 ~            	ld bc, -100
  49++76A9 ~            	call DigitLoop
  50++76A9 ~            	ld bc, -10
  51++76A9 ~            	call DigitLoop
  52++76A9 ~            	ld bc, -1
  53++76A9 ~
  54++76A9 ~            DigitLoop:
  55++76A9 ~            	ld	a, '0' - 1
  56++76A9 ~            DivNrLoop:
  57++76A9 ~            	inc	a		;increase reminder
  58++76A9 ~            	add	hl, bc	;substract divizor
  59++76A9 ~            	jr	c, DivNrLoop	;still dividing?
  60++76A9 ~            	sbc	hl, bc	;nope, restore
  61++76A9 ~
  62++76A9 ~            	ld (de), a
  63++76A9 ~            	inc de
  64++76A9 ~            	ret
  65++76A9 ~
  66++76A9 ~
  67++76A9 ~            ;Input: HL = Dividend, C = Divisor
  68++76A9 ~            ;Output: HL = Quotient, A = Remainder
  69++76A9 ~            ;Warning: doesn't work with divisor >= $80
  70++76A9 ~            Div:
  71++76A9 ~            	IFUSED
  72++76A9 ~            	xor a
  73++76A9 ~            	ld b, 16
  74++76A9 ~
  75++76A9 ~            DivLoop:
  76++76A9 ~            	add	hl,hl
  77++76A9 ~            	rla
  78++76A9 ~            	cp	c
  79++76A9 ~            	jr	c, NoSub
  80++76A9 ~            	sub	c
  81++76A9 ~            	inc	l
  82++76A9 ~            NoSub:
  83++76A9 ~            	djnz DivLoop
  84++76A9 ~
  85++76A9 ~            	ret
  86++76A9 ~            	ENDIF
  87++76A9 ~
  88++76A9 ~            ;Input: A:C = Dividend, DE = Divisor, HL = 0
  89++76A9 ~            ;Output: A:C = Quotient, HL = Remainder
  90++76A9 ~            Div2:
  91++76A9 ~            	ld hl, 0
  92++76A9 ~            	ld b, 16
  93++76A9 ~            Div2Loop:
  94++76A9 ~            	sll c	; unroll 16 times
  95++76A9 ~            	rla		; ...
  96++76A9 ~            	adc	hl,hl	; ...
  97++76A9 ~            	sbc	hl,de	; ...
  98++76A9 ~            	jr	nc,$+4	; ...
  99++76A9 ~            	add	hl,de	; ...
 100++76A9 ~            	dec	c	; ...
 101++76A9 ~            	djnz Div2Loop
 102++76A9 ~            	ret
 103++76A9 ~
 104++76A9 ~
 105++76A9 ~            ;Input: A = Multiplier, DE = Multiplicand
 106++76A9 ~            ;Output: A:HL = Product
 107++76A9 ~            Mul:
 108++76A9 ~            	IFUSED
 109++76A9 ~            	ld hl, 0
 110++76A9 ~            	ld bc, $0700
 111++76A9 ~
 112++76A9 ~            	add	a, a	; optimised 1st iteration
 113++76A9 ~            	jr	nc, MulLoop
 114++76A9 ~            	ld	h, d
 115++76A9 ~            	ld	l, e
 116++76A9 ~
 117++76A9 ~            MulLoop:
 118++76A9 ~            	add	hl,hl
 119++76A9 ~            	rla
 120++76A9 ~            	jr	nc, NoAdd
 121++76A9 ~            	add	hl,de
 122++76A9 ~            	adc	a,c
 123++76A9 ~            NoAdd:
 124++76A9 ~            	djnz MulLoop
 125++76A9 ~
 126++76A9 ~            	ret
 127++76A9 ~            	ENDIF
 128++76A9 ~
 129++76A9 ~
 130++76A9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 131++76A9 ~            ;IN: HL=address to read, DE=output address	for 2 chars
 132++76A9 ~            Byte2Hex:
 133++76A9 ~            	xor	a
 134++76A9 ~            	rld
 135++76A9 ~            	call	Byte2HexNibble
 136++76A9 ~
 137++76A9 ~            Byte2HexNibble:
 138++76A9 ~            	push	af
 139++76A9 ~            	daa
 140++76A9 ~            	add	a,$F0
 141++76A9 ~            	adc	a,$40
 142++76A9 ~
 143++76A9 ~            	ld	(de), a
 144++76A9 ~            	inc	de
 145++76A9 ~
 146++76A9 ~            	pop	af
 147++76A9 ~            	rld
 148++76A9 ~            	ret
 149++76A9 ~
 150++76A9 ~
 151++76A9 ~            Byte2HexHex:
 152++76A9 ~            	call	Byte2Hex
 153++76A9 ~            	inc	hl
 154++76A9 ~            	ld	a, ' '
 155++76A9 ~            	ld	(de), a
 156++76A9 ~            	inc	de
 157++76A9 ~            	ret
 158++76A9 ~
 159++76A9 ~            Byte2HexChar:
 160++76A9 ~            	ld	a, CHAR_CR
 161++76A9 ~            	cp	(hl)
 162++76A9 ~            	jr	nz, Bin2HexLineLoopTextCopy
 163++76A9 ~
 164++76A9 ~            Bin2HexLineLoopTextReplace:
 165++76A9 ~            	ld	a, '.'
 166++76A9 ~            	ld	(hl), a
 167++76A9 ~
 168++76A9 ~            Bin2HexLineLoopTextCopy:
 169++76A9 ~            	ldi
 170++76A9 ~            	ret
 171++76A9 ~
 172++76A9 ~
 173++76A9 ~            HEX_COLUMNS	EQU	16
 174++76A9 ~
 175++76A9 ~            Bin2HexLine:
 176++76A9 ~            	;Hex part
 177++76A9 ~            	ld	b, HEX_COLUMNS
 178++76A9 ~            	push	hl
 179++76A9 ~            Bin2HexLineLoopHex:
 180++76A9 ~            		call	Byte2HexHex
 181++76A9 ~            		djnz	Bin2HexLineLoopHex
 182++76A9 ~            	pop	hl
 183++76A9 ~
 184++76A9 ~            	dec	de
 185++76A9 ~            	ld	a, CHR_V
 186++76A9 ~            	ld	(de), a
 187++76A9 ~            	inc	de
 188++76A9 ~
 189++76A9 ~            	ld	ixh, d
 190++76A9 ~            	ld	ixl, e
 191++76A9 ~            	ld	(ix - (HEX_COLUMNS/2)*3 - 1), a
 192++76A9 ~
 193++76A9 ~            	;String part
 194++76A9 ~            Bin2HexLineText:
 195++76A9 ~            	;just to not alter B with LDI, set C to something > 16
 196++76A9 ~            	ld	bc, (HEX_COLUMNS << 8) | HEX_COLUMNS*2
 197++76A9 ~            Bin2HexLineLoopText:
 198++76A9 ~            	call	Byte2HexChar
 199++76A9 ~            	djnz	Bin2HexLineLoopText
 200++76A9 ~            	ret
 201++76A9 ~
 202++76A9 ~
 203++76A9 ~            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 204++76A9 ~            ;Converts binary buffer at HL to hex string at DE
 205++76A9 ~            Bin2HexStr:
 206++76A9 ~            	;Calculate the number of full lines by dividing BC to 16.
 207++76A9 ~            	xor	a
 208++76A9 ~
 209++76A9 ~            	rr	b
 210++76A9 ~            	rr	c
 211++76A9 ~            	rra
 212++76A9 ~
 213++76A9 ~            	rr	b
 214++76A9 ~            	rr	c
 215++76A9 ~            	rra
 216++76A9 ~
 217++76A9 ~            	rr	b
 218++76A9 ~            	rr	c
 219++76A9 ~            	rra
 220++76A9 ~
 221++76A9 ~            	rr	b
 222++76A9 ~            	rr	c
 223++76A9 ~            	rra
 224++76A9 ~
 225++76A9 ~            	rra
 226++76A9 ~            	rra
 227++76A9 ~            	rra
 228++76A9 ~            	rra
 229++76A9 ~
 230++76A9 ~            	ex		af, af'		;Keep reminder
 231++76A9 ~
 232++76A9 ~            Bin2HexStrLoop:
 233++76A9 ~            	push	bc
 234++76A9 ~            		call	Bin2HexLine
 235++76A9 ~            	pop	bc
 236++76A9 ~
 237++76A9 ~            	dec	bc
 238++76A9 ~            	ld	a, b
 239++76A9 ~            	or	c
 240++76A9 ~            	jr	nz, Bin2HexStrLoop
 241++76A9 ~
 242++76A9 ~            	;Set remaining imcomplete line.
 243++76A9 ~            	;Exit if last line is empty.
 244++76A9 ~            	ex	af, af'
 245++76A9 ~            	or	a
 246++76A9 ~            	ret	z
 247++76A9 ~            	ex	af, af'
 248++76A9 ~
 249++76A9 ~            	;Clear the whole last line.
 250++76A9 ~            	push	de
 251++76A9 ~            	push	hl
 252++76A9 ~            		ld	a, ' '
 253++76A9 ~            		ld	b, COL_CNT
 254++76A9 ~            Bin2HexLineClear:
 255++76A9 ~            		ld	(de), a
 256++76A9 ~            		inc	de
 257++76A9 ~            		djnz	Bin2HexLineClear
 258++76A9 ~            	pop	hl
 259++76A9 ~            	pop	de
 260++76A9 ~
 261++76A9 ~            	;Save start of last line.
 262++76A9 ~            	push	de
 263++76A9 ~            	pop	ix
 264++76A9 ~            	push	ix
 265++76A9 ~
 266++76A9 ~            	;Save start of char part in IX.
 267++76A9 ~            	ld	bc, HEX_COLUMNS*3
 268++76A9 ~            	add	ix, bc
 269++76A9 ~
 270++76A9 ~            	;Write the hex and char parts of line.
 271++76A9 ~            	ex	af, af'
 272++76A9 ~            	ld	b, a
 273++76A9 ~            	ld	c, HEX_COLUMNS*2
 274++76A9 ~
 275++76A9 ~            Bin2HexLineLoopHex2:
 276++76A9 ~            	call	Byte2HexHex
 277++76A9 ~            	dec	hl
 278++76A9 ~
 279++76A9 ~            	push	de
 280++76A9 ~            		ld	e, ixl
 281++76A9 ~            		ld	d, ixh
 282++76A9 ~            		ld	c, 1
 283++76A9 ~            		call	Byte2HexChar
 284++76A9 ~            	pop	de
 285++76A9 ~
 286++76A9 ~            	inc	ix
 287++76A9 ~            	djnz	Bin2HexLineLoopHex2
 288++76A9 ~
 289++76A9 ~            	;Save end of buffer in DE, to let the caller know where the buffer ends.
 290++76A9 ~            	ld	e, ixl
 291++76A9 ~            	ld	d, ixh
 292++76A9 ~
 293++76A9 ~            	pop	ix
 294++76A9 ~            	;Write delimiters.
 295++76A9 ~            	ld	a, CHR_V
 296++76A9 ~            	ld	(ix + HEX_COLUMNS*3/2 - 1), a
 297++76A9 ~            	ld	(ix + HEX_COLUMNS*3 - 1), a
 298++76A9 ~
 299++76A9 ~            	ret
 300++76A9 ~
 301++76A9              	endif
# file closed: math.asm
  19+ 76A9
  20+ 76A9              TextViewer:
  21+ 76A9 CD 1A 78     	call	TextViewIndex
  22+ 76AC
  23+ 76AC              	;Get file size and divide by RAM buffer size, to get total file parts.
  24+ 76AC 2A 90 7D     	ld	hl, (SelFileCache)
  25+ 76AF CD 37 70     	call	GetFileSize
  26+ 76B2              	;Divide by the buffer size set for the current visualisation type (text/hex).
  27+ 76B2 3A 94 7D     	ld	a, (ViewSectMax)
  28+ 76B5 57           	ld	d, a
  29+ 76B6 1E 00        	ld	e, 0
  30+ 76B8 7C           	ld	a, h
  31+ 76B9 4D           	ld	c, l
  32+ 76BA 21 00 00     	ld	hl, 0
  33+ 76BD CD 39 6B     	call	Div2
  34+ 76C0 EB           	ex	de, hl
  35+ 76C1 67           	ld	h, a
  36+ 76C2 69           	ld	l, c
  37+ 76C3 7A           	ld	a, d
  38+ 76C4 B3           	or	e
  39+ 76C5 28 07        	jr	z, TextViewerBlockCountNoReminder
  40+ 76C7 23           	inc	hl
  41+ 76C8 11 01 79     	ld	de, MsgFilePartTotal
  42+ 76CB CD F0 6A     	call	Byte2Txt
  43+ 76CE
  44+ 76CE              TextViewerBlockCountNoReminder:
  45+ 76CE 21 00 00     	ld	hl, 0
  46+ 76D1 22 B0 5C     	ld	(COORDS), hl
  47+ 76D4 CD 2F 76     	call	ScrollInit
  48+ 76D7
  49+ 76D7              	;Check if we have in file 23 lines or less.
  50+ 76D7 2A D0 78     	ld	hl, (LineCount)
  51+ 76DA 01 17 00     	ld	bc, LINE_CNT
  52+ 76DD B7           	or	a
  53+ 76DE ED 42        	sbc	hl, bc
  54+ 76E0 06 17        	ld	b, LINE_CNT
  55+ 76E2 30 0A        	jr	nc, MoreThan23LinesInFile
  56+ 76E4
  57+ 76E4              	;If file has less than 23 lines, show only lines 0 to line count-1.
  58+ 76E4 2A D0 78     	ld	hl, (LineCount)
  59+ 76E7 45           	ld	b, l
  60+ 76E8 2B           	dec	hl
  61+ 76E9 11 00 00     	ld	de, 0
  62+ 76EC 18 1D        	jr	TextViewerShowBegining
  63+ 76EE
  64+ 76EE              MoreThan23LinesInFile:
  65+ 76EE              	;Check last key pressed to see if we need to show last part of file or the first part.
  66+ 76EE 3A 08 5C     	ld	a, (LAST_K)
  67+ 76F1 FE 0B        	cp	KEY_UP
  68+ 76F3 11 00 00     	ld	de, 0
  69+ 76F6 21 16 00     	ld	hl, LINE_CNT-1
  70+ 76F9 20 10        	jr	nz, TextViewerShowBegining
  71+ 76FB
  72+ 76FB              	;Must show end of file.
  73+ 76FB 2A D0 78     	ld	hl, (LineCount)
  74+ 76FE 2B           	dec	hl
  75+ 76FF E5           	push	hl
  76+ 7700 C5           	push	bc
  77+ 7701 01 16 00     		ld	bc, LINE_CNT-1
  78+ 7704 B7           		or	a
  79+ 7705 ED 42        		sbc	hl, bc
  80+ 7707 54           		ld	d, h
  81+ 7708 5D           		ld	e, l
  82+ 7709 C1           	pop	bc
  83+ 770A E1           	pop	hl
  84+ 770B
  85+ 770B              TextViewerShowBegining:
  86+ 770B 22 D4 78     	ld	(LastLineShown), hl
  87+ 770E ED 53 D2 78  	ld	(FirstLineShown), de
  88+ 7712
  89+ 7712              	;If first line is 0, don't need to add offset.
  90+ 7712 7A           	ld	a, d
  91+ 7713 B3           	or	e
  92+ 7714 DD 21 D8 EA  	ld	ix, FileIdx
  93+ 7718 28 0D        	jr	z, TextViewerLoop
  94+ 771A
  95+ 771A              	;Get pointer to the first line index.
  96+ 771A 3E 03        	ld	a, 3
  97+ 771C C5           	push	bc
  98+ 771D E5           	push	hl
  99+ 771E CD 4C 6B     		call	Mul
 100+ 7721 44           		ld	b, h
 101+ 7722 4D           		ld	c, l
 102+ 7723 DD 09        		add	ix, bc
 103+ 7725 E1           	pop	hl
 104+ 7726 C1           	pop	bc
 105+ 7727
 106+ 7727              ;Display first screen of text.
 107+ 7727              TextViewerLoop:
 108+ 7727 C5           	push	bc
 109+ 7728 CD 76 78     		call	PrintOneLine
 110+ 772B DD 23        		inc	ix
 111+ 772D DD 23        		inc	ix
 112+ 772F DD 23        		inc	ix
 113+ 7731
 114+ 7731 ED 5B B0 5C  		ld	de, (COORDS)
 115+ 7735 14           		inc	d
 116+ 7736 1E 00        		ld	e, 0
 117+ 7738 ED 53 B0 5C  		ld	(COORDS), de
 118+ 773C C1           	pop	bc
 119+ 773D 10 E8        	djnz	TextViewerLoop
 120+ 773F
 121+ 773F DD 2B        	dec	ix
 122+ 7741 DD 2B        	dec	ix
 123+ 7743 DD 2B        	dec	ix
 124+ 7745
 125+ 7745 2A D0 78     	ld	hl, (LineCount)
 126+ 7748 11 F2 78     	ld	de, MsgLineTotal
 127+ 774B CD E5 6A     	call	Word2Txt
 128+ 774E
 129+ 774E              TextViewerLoop3:
 130+ 774E 2A D4 78     	ld	hl, (LastLineShown)
 131+ 7751 23           	inc	hl
 132+ 7752 11 EC 78     	ld	de, MsgLineNo
 133+ 7755 CD E5 6A     	call	Word2Txt
 134+ 7758 3A 95 7D     	ld	a, (ViewFilePart)
 135+ 775B 3C           	inc	a
 136+ 775C 6F           	ld	l, a
 137+ 775D 26 00        	ld	h, 0
 138+ 775F 11 FD 78     	ld	de, MsgFilePart
 139+ 7762 CD F0 6A     	call	Byte2Txt
 140+ 7765
 141+ 7765 2A 90 7D     	ld	hl, (SelFileCache)
 142+ 7768 11 DB 78     	ld	de, MsgLineFileName
 143+ 776B 06 0B        	ld	b, NAMELEN
 144+ 776D              TextViewerShowFilename:
 145+ 776D 7E           	ld	a, (hl)
 146+ 776E E6 7F        	and	$7F
 147+ 7770 12           	ld	(de), a
 148+ 7771 23           	inc	hl
 149+ 7772 13           	inc	de
 150+ 7773 10 F8        	djnz	TextViewerShowFilename
 151+ 7775
 152+ 7775 21 D6 78     	ld	hl, MsgLine
 153+ 7778 11 00 17     	ld	de, LINE_CNT << 8
 154+ 777B 3E 60        	ld	a, SCR_SEL_CLR
 155+ 777D CD 8A 74     	call	PrintStrClr
 156+ 7780
 157+ 7780 CD 26 74     	call	ReadChar
 158+ 7783
 159+ 7783 FE 0A        	cp	KEY_DOWN
 160+ 7785 28 51        	jr	z, TextViewerScrollDown
 161+ 7787 FE 61        	cp	'a'
 162+ 7789 28 4D        	jr	z, TextViewerScrollDown
 163+ 778B
 164+ 778B FE 0B        	cp	KEY_UP
 165+ 778D 28 09        	jr	z, TextViewerScrollUp
 166+ 778F FE 71        	cp	'q'
 167+ 7791 28 05        	jr	z, TextViewerScrollUp
 168+ 7793
 169+ 7793 FE 30        	cp	'0'
 170+ 7795 C8           	ret	z
 171+ 7796
 172+ 7796 18 B6        	jr	TextViewerLoop3
 173+ 7798
 174+ 7798              TextViewerScrollUp:
 175+ 7798              	;Do nothing if showing begining of file.
 176+ 7798 ED 5B D2 78  	ld	de, (FirstLineShown)
 177+ 779C 7A           	ld	a, d
 178+ 779D B3           	or	e
 179+ 779E 20 07        	jr	nz, TextViewerScrollUpOK
 180+ 77A0
 181+ 77A0 3A 95 7D     	ld	a, (ViewFilePart)
 182+ 77A3 B7           	or	a
 183+ 77A4 28 A8        	jr	z, TextViewerLoop3
 184+ 77A6 C9           	ret
 185+ 77A7
 186+ 77A7              TextViewerScrollUpOK:
 187+ 77A7 1B           	dec	de
 188+ 77A8 ED 53 D2 78  	ld	(FirstLineShown), de
 189+ 77AC
 190+ 77AC 2A D4 78     	ld	hl, (LastLineShown)
 191+ 77AF 2B           	dec	hl
 192+ 77B0 22 D4 78     	ld	(LastLineShown), hl
 193+ 77B3
 194+ 77B3 7A           	ld	a, d
 195+ 77B4 B3           	or	e
 196+ 77B5 DD 21 D8 EA  	ld	ix, FileIdx
 197+ 77B9 28 09        	jr	z, TextViewerScrollUp1
 198+ 77BB
 199+ 77BB              	;3*FirstLineShown
 200+ 77BB 3E 03        	ld	a, 3
 201+ 77BD CD 4C 6B     	call	Mul
 202+ 77C0 EB           	ex	de, hl
 203+ 77C1 B7           	or	a
 204+ 77C2 DD 19        	add	ix, de
 205+ 77C4
 206+ 77C4
 207+ 77C4              TextViewerScrollUp1:
 208+ 77C4 CD 69 76     	call	ScrollUp
 209+ 77C7 ED 5B B0 5C  	ld	de, (COORDS)
 210+ 77CB 11 00 00     	ld	de, 0
 211+ 77CE ED 53 B0 5C  	ld	(COORDS), de
 212+ 77D2 CD 76 78     	call	PrintOneLine
 213+ 77D5
 214+ 77D5 C3 4E 77     	jp	TextViewerLoop3
 215+ 77D8
 216+ 77D8              TextViewerScrollDown:
 217+ 77D8              	;Exit if reached last line from file and more data is available for reading.
 218+ 77D8 ED 5B D4 78  	ld	de, (LastLineShown)
 219+ 77DC 13           	inc	de
 220+ 77DD 2A D0 78     	ld	hl, (LineCount)
 221+ 77E0 B7           	or	a
 222+ 77E1 ED 52        	sbc	hl, de
 223+ 77E3 7C           	ld	a, h
 224+ 77E4 B5           	or	l
 225+ 77E5 20 08        	jr	nz, TextViewerScrollDown1
 226+ 77E7
 227+ 77E7              	;Exit if not end of file.
 228+ 77E7 3A 9A 7D     	ld	a, (CopyFileRes)
 229+ 77EA B7           	or	a
 230+ 77EB C2 4E 77     	jp	nz, TextViewerLoop3
 231+ 77EE C9           	ret
 232+ 77EF
 233+ 77EF              TextViewerScrollDown1:
 234+ 77EF ED 53 D4 78  	ld	(LastLineShown), de
 235+ 77F3
 236+ 77F3 2A D2 78     	ld	hl, (FirstLineShown)
 237+ 77F6 23           	inc	hl
 238+ 77F7 22 D2 78     	ld	(FirstLineShown), hl
 239+ 77FA
 240+ 77FA              	;Index of next line = LastLineShown * 3
 241+ 77FA 3E 03        	ld	a, 3
 242+ 77FC CD 4C 6B     	call	Mul
 243+ 77FF EB           	ex	de, hl
 244+ 7800 DD 21 D8 EA  	ld	ix, FileIdx
 245+ 7804 DD 19        	add	ix, de
 246+ 7806
 247+ 7806 CD 6E 76     	call	ScrollDown
 248+ 7809 ED 5B B0 5C  	ld	de, (COORDS)
 249+ 780D 11 00 16     	ld	de, (LINE_CNT - 1) << 8
 250+ 7810 ED 53 B0 5C  	ld	(COORDS), de
 251+ 7814
 252+ 7814 CD 76 78     	call	PrintOneLine
 253+ 7817 C3 4E 77     	jp	TextViewerLoop3
 254+ 781A
 255+ 781A              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 256+ 781A
 257+ 781A              ;Creates line start indexes, with 2 byte address and 1 byte length for each line. Stores total line count.
 258+ 781A              ;IN: HL=start address, BC: length
 259+ 781A              TextViewIndex:
 260+ 781A DD 21 D8 EA  	ld	ix, FileIdx
 261+ 781E
 262+ 781E              	;Save initial length in DE.
 263+ 781E E5           	push	hl
 264+ 781F B7           		or	a
 265+ 7820 ED 4A        		adc	hl, bc
 266+ 7822 EB           		ex	de, hl
 267+ 7823 E1           	pop	hl
 268+ 7824
 269+ 7824 ED 53 CE 78  	ld	(FileEnd), de
 270+ 7828
 271+ 7828 11 00 00     	ld	de, 0				;Assume at least one line is shown, even if empty.
 272+ 782B ED 53 D0 78  	ld	(LineCount), de
 273+ 782F
 274+ 782F              TextViewIndexLoop:
 275+ 782F DD 75 00     	ld	(ix), l
 276+ 7832 DD 74 01     	ld	(ix+1), h
 277+ 7835
 278+ 7835              	;BC to hold 64 or less, if on last line from file.
 279+ 7835 ED 5B CE 78  	ld	de, (FileEnd)
 280+ 7839 EB           	ex	de, hl
 281+ 783A B7           	or	a
 282+ 783B ED 52        	sbc	hl, de
 283+ 783D C8           	ret	z
 284+ 783E
 285+ 783E E5           	push	hl
 286+ 783F 01 40 00     		ld	bc, COL_CNT
 287+ 7842 B7           		or	a
 288+ 7843 ED 42        		sbc	hl, bc
 289+ 7845 EB           		ex	de, hl
 290+ 7846 D1           	pop	de
 291+ 7847 79           	ld	a, c
 292+ 7848 30 01        	jr	nc, TextViewLineShort
 293+ 784A 7B           	ld	a, e
 294+ 784B
 295+ 784B              TextViewLineShort:
 296+ 784B 5F           	ld	e, a		;Save line lenght.
 297+ 784C
 298+ 784C              	;Must detect if line is shorter because of CR.
 299+ 784C 4F           	ld	c, a
 300+ 784D 3E 0D        	ld	a, CHAR_CR
 301+ 784F ED B1        	cpir
 302+ 7851 20 01        	jr	nz, TextViewNotFoundCR
 303+ 7853 0C           	inc	c
 304+ 7854
 305+ 7854              TextViewNotFoundCR:
 306+ 7854 7B           	ld	a, e
 307+ 7855 91           	sub	c
 308+ 7856 DD 77 02     	ld	(ix+2), a
 309+ 7859
 310+ 7859 3E 0D        	ld	a, CHAR_CR	;Don't show an empty line if the CR char is exactly after 64 chars.
 311+ 785B BE           	cp	(hl)
 312+ 785C 20 01        	jr	nz, TextViewCheckLF
 313+ 785E 23           	inc	hl
 314+ 785F
 315+ 785F              TextViewCheckLF:
 316+ 785F 3E 0A        	ld	a, CHR_LF
 317+ 7861 BE           	cp	(hl)
 318+ 7862 20 01        	jr	nz, TextViewNoLF
 319+ 7864 23           	inc	hl					;Skip LF char.
 320+ 7865              TextViewNoLF:
 321+ 7865
 322+ 7865              	;Point to the next index position.
 323+ 7865 ED 4B D0 78  	ld	bc, (LineCount)
 324+ 7869 03           	inc	bc
 325+ 786A ED 43 D0 78  	ld	(LineCount), bc
 326+ 786E
 327+ 786E DD 23        	inc	ix
 328+ 7870 DD 23        	inc	ix
 329+ 7872 DD 23        	inc	ix
 330+ 7874 18 B9        	jr	 TextViewIndexLoop
 331+ 7876
 332+ 7876              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 333+ 7876              PrintOneLine:
 334+ 7876 DD 6E 00     	ld	l, (ix)
 335+ 7879 DD 66 01     	ld	h, (ix+1)
 336+ 787C DD 7E 02     	ld	a, (ix+2)
 337+ 787F
 338+ 787F B7           	or	a
 339+ 7880 06 40        	ld	b, COL_CNT
 340+ 7882 28 34        	jr	z, PrintOneLineCleanLine
 341+ 7884
 342+ 7884 47           	ld	b, a
 343+ 7885              PrintOneLineLoop:
 344+ 7885 7E           	ld	a, (hl)
 345+ 7886
 346+ 7886              	;Put space instead of tab
 347+ 7886 FE 09        	cp	CHAR_TAB
 348+ 7888 20 02        	jr	nz, PrintOneLineNotTab
 349+ 788A 3E 20        	ld	a, ' '
 350+ 788C
 351+ 788C              PrintOneLineNotTab:
 352+ 788C E5           	push	hl
 353+ 788D FE 20        		cp	' '
 354+ 788F 38 06        		jr	c, PrintCharNotValid
 355+ 7891 FE 8C        		cp	CHR_HALF
 356+ 7893 30 02        		jr	nc, PrintCharNotValid
 357+ 7895
 358+ 7895 18 02        		jr	PrintCharValid
 359+ 7897              PrintCharNotValid:
 360+ 7897 3E 2E        		ld	a, '.'
 361+ 7899              PrintCharValid:
 362+ 7899 32 81 5C     		ld	(CODE), a
 363+ 789C C5           		push	bc
 364+ 789D CD 8E 75     			call	PrintChar
 365+ 78A0 C1           		pop	bc
 366+ 78A1
 367+ 78A1 ED 5B B0 5C  		ld	de, (COORDS)
 368+ 78A5 1C           		inc	e
 369+ 78A6 ED 53 B0 5C  		ld	(COORDS), de
 370+ 78AA E1           	pop	hl
 371+ 78AB 23           	inc	hl
 372+ 78AC 10 D7        	djnz	PrintOneLineLoop
 373+ 78AE
 374+ 78AE              	;Fill rest of line with spaces.
 375+ 78AE DD 46 02     	ld	b, (ix+2)
 376+ 78B1 3E 40        	ld	a, COL_CNT
 377+ 78B3 B8           	cp	b
 378+ 78B4 C8           	ret	z
 379+ 78B5
 380+ 78B5 B7           	or	a
 381+ 78B6 98           	sbc	b
 382+ 78B7 47           	ld	b, a
 383+ 78B8
 384+ 78B8              PrintOneLineCleanLine:
 385+ 78B8 3E 20        	ld	a, ' '
 386+ 78BA 32 81 5C     	ld	(CODE), a
 387+ 78BD C5           	push	bc
 388+ 78BE CD 8E 75     		call	PrintChar
 389+ 78C1 ED 5B B0 5C  		ld	de, (COORDS)
 390+ 78C5 1C           		inc	e
 391+ 78C6 ED 53 B0 5C  		ld	(COORDS), de
 392+ 78CA C1           	pop	bc
 393+ 78CB 10 EB        	djnz	PrintOneLineCleanLine
 394+ 78CD
 395+ 78CD C9           	ret
 396+ 78CE
 397+ 78CE              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 398+ 78CE
 399+ 78CE 00 00        FileEnd		DEFW	0
 400+ 78D0 00 00        LineCount	DEFW	0
 401+ 78D2 00 00        FirstLineShown	DEFW	0
 402+ 78D4 00 00        LastLineShown	DEFW	0
 403+ 78D6
 404+ 78D6 46 69 6C 65  MsgLine	defb	'File:'
 404+ 78DA 3A
 405+ 78DB 20 20 20 20  MsgLineFileName defb 	'           |'
 405+ 78DF 20 20 20 20
 405+ 78E3 20 20 20 7C
 406+ 78E7 4C 69 6E 65  		defb	'Line:'
 406+ 78EB 3A
 407+ 78EC 20 20 20 20  MsgLineNo	defb	'     /'
 407+ 78F0 20 2F
 408+ 78F2 20 20 20 20  MsgLineTotal	defb	'     |'
 408+ 78F6 20 7C
 409+ 78F8 50 61 72 74  		defb	'Part:'
 409+ 78FC 3A
 410+ 78FD 20 20 20 2F  MsgFilePart	defb	'   /'
 411+ 7901 20 20 20 7C  MsgFilePartTotal	defb	'   |'
 412+ 7905 20 20 20...  		defs	10, ' '
 413+ 790F 7C 30 3A 45  		defb	'|0:Exi', 't' | $80
 413+ 7913 78 69 F4
 414+ 7916
 415+ 7916              	ENDIF
# file closed: txtview.asm
1501  7916              	include "serial.asm"
# file opened: serial.asm
   1+ 7916              ;GEORGE CHIRTOACA: This are COM Rx/Tx routines by Mihai Gaitos, from here http://hawk.ro/stories/hc/hc_serial_en.html .
   2+ 7916              ;They work with 19200 theoretical speed.
   3+ 7916              ;The BASIC commands are reliable at 4800 PC2HC and 9600 HC2PC theoretical speed.
   4+ 7916
   5+ 7916              CBAUD	EQU	10	; CBAUD for 19200
   6+ 7916              ;CBAUD	EQU	24	; CBAUD for 9600
   7+ 7916
   8+ 7916
   9+ 7916              ; ACTUAL RECEIVE CHAR ROUTINE (CHAR IN D, A=0 IF OK, -1 IF T/O)
  10+ 7916              ; A=1 IF FRAMING ERROR
  11+ 7916              ; USES BC,D _DOES NOT USE E!_
  12+ 7916              SERRXI:
  12+ 7916
  13+ 7916 01 00 00     	LD	BC,0000		; TIMEOUT
  14+ 7919 3E 30        	LD	A,30H		; ASSERT RTS
  15+ 791B D3 EF        	OUT	(0EFH),A
  16+ 791D
  17+ 791D              	; WAIT FOR START
  18+ 791D              SERWSL:
  19+ 791D 0B           	DEC	BC
  20+ 791E AF           	XOR	A
  21+ 791F B8           	CP	B
  22+ 7920 20 03        	JR	NZ,SERWS
  23+ 7922 B9           	CP	C
  24+ 7923 28 2D        	JR	Z,SERRTO	; TIMEOUT
  25+ 7925 DB F7        SERWS:	IN	A,(0F7H)	; GET LINE STATUS
  26+ 7927 CB 7F        	BIT	7,A
  27+ 7929 28 F2        	JR	Z,SERWSL	; IF 0 THEN WAIT SOME MORE
  28+ 792B
  29+ 792B              ; WE GOT START; DELAY BY 3/2 BITS TO ARRIVE IN THE MIDDLE
  30+ 792B              ; OF BIT 0
  31+ 792B 06 0F        	LD	B,CBAUD / 2 + CBAUD
  32+ 792D 0E 08        	LD	C,8		; 8 DATA BITS
  33+ 792F
  34+ 792F              ; GET AND SHIFT BITS
  35+ 792F              SERRL:
  36+ 792F 10 FE        	DJNZ	SERRL		; 13*B-5
  37+ 7931 00           	NOP			; 4 (TIMING)
  38+ 7932 00           	NOP			; 4 (TIMING)
  39+ 7933 00           	NOP			; 4 (TIMING)
  40+ 7934 DB F7        	IN	A,(0F7H)	; 11
  41+ 7936 17           	RLA			; 4
  42+ 7937 CB 1A        	RR	D		; 8
  43+ 7939 06 0A        	LD	B,CBAUD		; 7
  44+ 793B 0D           	DEC	C		; 4
  45+ 793C 20 F1        	JR	NZ,SERRL	; 12
  46+ 793E
  47+ 793E              ; WE ARE NOW AT LAST BIT. DEASSERT RTS AND WAIT
  48+ 793E              ; FOR THE LINE TO GO IDLE. IF LAST BIT IS 1 THIS WILL CAUSE
  49+ 793E              ; IMMEDIATE EXIT BUT IT IS NOT A PROBLEM SINCE LINE WILL REMAIN
  50+ 793E              ; IDLE UNTIL NEXT START BIT
  51+ 793E 3E 20        	LD	A,20H		; DEASSERT RTS
  52+ 7940 D3 EF        	OUT	(0EFH),A
  53+ 7942
  54+ 7942 06 0A        	LD	B,CBAUD		; TIMEOUT
  55+ 7944              	; WAIT FOR STOP, SIMILAR TO WAIT FOR START
  56+ 7944              SERWIL:
  57+ 7944 05           	DEC	B
  58+ 7945 28 0E        	JR	Z,SERRTF
  59+ 7947 DB F7        SERWI:	IN	A,(0F7H)	; GET LINE STATUS
  60+ 7949 CB 7F        	BIT	7,A
  61+ 794B 20 F7        	JR	NZ,SERWIL	; IF NOT IDLE WAIT SOME MORE
  62+ 794D
  63+ 794D              ; RECEIVE ENDED AND LINE IS IDLE
  64+ 794D 7A           	LD	A,D
  65+ 794E 2F           	CPL			; INVERT BITS
  66+ 794F 57           	LD	D,A
  67+ 7950 AF           	XOR	A		; 0 = SUCCESS
  68+ 7951 C9           	RET
  69+ 7952
  70+ 7952              ; TIMEOUT
  71+ 7952              SERRTO:
  72+ 7952 3E FF        	LD	A,0FFH
  73+ 7954 C9           	RET
  74+ 7955
  75+ 7955              ; FRAMING (STOP NOT RECEIVED) ERROR
  76+ 7955              SERRTF:
  77+ 7955 3E 01        	LD	A,01H
  78+ 7957 C9           	RET
  79+ 7958
  80+ 7958
  81+ 7958
  82+ 7958              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  83+ 7958              SERRB:
  83+ 7958
  84+ 7958              ; RECEIVE BLOCK (ADDR IN HL, BYTE COUNT IN BC)
  85+ 7958              ; BITMAPPED OPTIONS IN E:
  86+ 7958              ; XXXXXXIT
  87+ 7958              ; I SET = leave Interrupts disabled at exit
  88+ 7958              ; T SET = return after Timeout
  89+ 7958              ; EXIT: A=0 SUCCESS, A=FF TIMEOUT, A=1 FRAMING ERROR
  90+ 7958              ; BC=NUMBER OF BYTES RECEIVED
  91+ 7958              ; HL=POINTER TO ADDRESS OF LAST RECEIVED BYTE + 1
  92+ 7958 F3           	DI
  93+ 7959 C5           	PUSH	BC		; NEEDED TO RETURN COUNT
  94+ 795A              				; OF RECEIVED BYTES
  95+ 795A
  96+ 795A              SERRBL:
  97+ 795A C5           	PUSH	BC
  98+ 795B CD 16 79     	CALL	SERRXI
  99+ 795E C1           	POP	BC
 100+ 795F B7           	OR	A
 101+ 7960 20 10        	JR	NZ,SERRBT	; CHECK TIMEOUT
 102+ 7962 72           	LD	(HL),D
 103+ 7963 23           	INC	HL
 104+ 7964 0B           	DEC	BC
 105+ 7965 AF           	XOR	A
 106+ 7966 B8           	CP	B
 107+ 7967 20 F1        	JR	NZ,SERRBL
 108+ 7969 B9           	CP	C
 109+ 796A 20 EE        	JR	NZ,SERRBL
 110+ 796C              ; FULL RECEIVE
 111+ 796C C1           	POP	BC		; RESTORE BYTE COUNT
 112+ 796D
 113+ 796D              SERRBX:				; EXIT
 114+ 796D CB 4B        	BIT	1,E
 115+ 796F C0           	RET	NZ
 116+ 7970 FB           	EI
 117+ 7971 C9           	RET
 118+ 7972
 119+ 7972              SERRBT:
 120+ 7972 FE 01        	CP	1		; FRAMING ERROR ALWAYS ABORTS
 121+ 7974 28 04        	JR	Z,SERRBC
 122+ 7976 CB 43        	BIT	0,E
 123+ 7978 28 E0        	JR	Z,SERRBL
 124+ 797A
 125+ 797A              SERRBC:	; CALCULATE NO. OF BYTES RECEIVED
 126+ 797A EB           	EX	DE,HL		; PRESERVE HL
 127+ 797B E1           	POP	HL		; GET INITIAL COUNT
 128+ 797C 37           	SCF
 129+ 797D 3F           	CCF
 130+ 797E ED 42        	SBC	HL,BC		; SUBSTRACT REMAINING
 131+ 7980 44           	LD	B,H
 132+ 7981 4D           	LD	C,L		; BC = COUNT
 133+ 7982 EB           	EX	DE,HL		; RESTORE HL
 134+ 7983
 135+ 7983 18 E8        	JR	SERRBX
 136+ 7985
 137+ 7985              SERRX:
 137+ 7985
 138+ 7985              ; RECEIVE CHAR WRAPPER (WRT INTERRUPTS), SINCE RECEIVE BLOCK
 139+ 7985              ; MUST MAKE MULTIPLE RX CALLS W/O ENABLING INTERRUPTS
 140+ 7985              ; CHAR IN D; A=0 IF SUCCESS; A=FF IF TIMEOUT
 141+ 7985 F3           	DI
 142+ 7986 CD 16 79     	CALL	SERRXI
 143+ 7989 FB           	EI
 144+ 798A C9           	RET
 145+ 798B
 146+ 798B              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 147+ 798B              ; SEND BLOCK (ADDR IN HL, BYTE COUNT IN BC)
 148+ 798B              SERTB:
 148+ 798B
 149+ 798B 7E           	LD	A,(HL)
 150+ 798C C5           	PUSH	BC
 151+ 798D CD 98 79     		CALL	SERTX
 152+ 7990 C1           	POP	BC
 153+ 7991 23           	INC	HL
 154+ 7992 0B           	DEC BC
 155+ 7993 78           	LD	A, B
 156+ 7994 B1           	OR	C
 157+ 7995 20 F4        	JR	NZ, SERTB
 158+ 7997 C9           	RET
 159+ 7998
 160+ 7998              ; SEND CHAR ROUTINE
 161+ 7998              SERTX:
 161+ 7998
 162+ 7998 2F           	CPL		; ENSURE CORRECT BIT POLARITY ON WIRE
 163+ 7999 57           	LD	D,A	; WILL SHIFT FROM D
 164+ 799A F3           	DI		; HC CP/M SEEMS TO MESS WITH PORTS...
 165+ 799B 3E 01        	LD	A,01H
 166+ 799D D3 F7        	OUT	(0F7H),A; ENSURE SERIAL, NOT "NETWORK"
 167+ 799F 1E 20        	LD	E,20H	; PORT MASK
 168+ 79A1 0E 09        	LD	C,09H	; 1 START+8 DATA BITS
 169+ 79A3 3E 01        	LD	A,1
 170+ 79A5 C3 AC 79     	JP	SBIT
 171+ 79A8
 172+ 79A8 AF           SHLOOP:	XOR	A		; 4
 173+ 79A9 CB 3A        	SRL	D		; 8
 174+ 79AB 17           	RLA			; 4
 175+ 79AC              SBIT:
 176+ 79AC B3           	OR	E		; 4
 177+ 79AD D3 EF        	OUT	(0EFH),A	; 11
 178+ 79AF 06 0A        	LD	B,CBAUD		; 7
 179+ 79B1              SBITDL:
 180+ 79B1 10 FE        	DJNZ	SBITDL		; 13*B-5
 181+ 79B3 00           	NOP			; 4 (TIMING)
 182+ 79B4 0D           	DEC	C		; 4
 183+ 79B5 20 F1        	JR	NZ,SHLOOP	; 12
 184+ 79B7              ; STOP BIT
 185+ 79B7 3E 20        	LD	A,20H
 186+ 79B9 D3 EF        	OUT	(0EFH),A
 187+ 79BB 06 0A        	LD	B,CBAUD
 188+ 79BD 10 FE        STOPL:	DJNZ	STOPL
 189+ 79BF FB           	EI
 190+ 79C0 C9           	RET
# file closed: serial.asm
1502  79C1              	include "bas2txt.asm"
# file opened: bas2txt.asm
   1+ 79C1              	IFNDEF _BAS2TXT_
   2+ 79C1              	DEFINE _BAS2TXT_
   3+ 79C1
   4+ 79C1              CHANS		EQU		23631
   5+ 79C1              CH_LEN		EQU		5
   6+ 79C1              CHANNEL		EQU		3
   7+ 79C1              CHAN_OPEN	EQU		$1601
   8+ 79C1
   9+ 79C1              NumMarker	EQU		$0E
  10+ 79C1
  11+ 79C1              PO_SEARCH	EQU		$0C41
  12+ 79C1              TKN_TABLE	EQU		$0095
  13+ 79C1
  14+ 79C1
  15+ 79C1              ;Input: HL=source of program, BC=length of program, DE=text output address
  16+ 79C1              ;Output: DE=end of text
  17+ 79C1              BASIC2TXT:
  18+ 79C1 22 8F 7A     	ld		(ProgramStartAddr), hl
  19+ 79C4 09           	add		hl, bc
  20+ 79C5 22 91 7A     	ld		(ProgramEndAddr), hl
  21+ 79C8 ED 53 93 7A  	ld		(DestinationAddr), de
  22+ 79CC
  23+ 79CC              	;Open channel.
  24+ 79CC 3E 03        	LD   A, CHANNEL
  25+ 79CE CD 01 16     	CALL CHAN_OPEN		;
  26+ 79D1
  27+ 79D1              	;modify output routine
  28+ 79D1 2A 4F 5C     	ld   hl, (CHANS)
  29+ 79D4 01 0F 00     	ld	 bc, CH_LEN * CHANNEL
  30+ 79D7 09           	add	 hl, bc
  31+ 79D8 11 62 7A     	ld   de, OutputFnct
  32+ 79DB 73           	ld   (hl), e
  33+ 79DC 23           	inc	hl
  34+ 79DD 72           	ld	(hl), d
  35+ 79DE
  36+ 79DE 2A 8F 7A     	ld	hl, (ProgramStartAddr)
  37+ 79E1
  38+ 79E1              NextLine:
  39+ 79E1 E5           	PUSH HL
  40+ 79E2 B7           		or	 a
  41+ 79E3 ED 5B 91 7A  		ld   de, (ProgramEndAddr)
  42+ 79E7 EB           		ex	de, hl
  43+ 79E8 ED 52        		SBC  HL,DE
  44+ 79EA 7C           		LD   A,H
  45+ 79EB B5           		OR   L
  46+ 79EC E1           	POP  HL
  47+ 79ED C8           	RET  Z				;Return if length == 0.
  48+ 79EE
  49+ 79EE              	;Print line number
  50+ 79EE 3E 20        	ld		a, ' '
  51+ 79F0 CD 80 7A     	call	PrintIt
  52+ 79F3 46           	LD   B,(HL)
  53+ 79F4 23           	INC  HL
  54+ 79F5 4E           	LD   C,(HL)
  55+ 79F6 23           	INC  HL
  56+ 79F7 E5           	PUSH HL
  57+ 79F8 CD 2B 2D     		CALL $2D2B		;STACK_BC
  58+ 79FB CD E3 2D     		CALL $2DE3		;PRINT_FP
  59+ 79FE 3E 20        		ld		a, ' '
  60+ 7A00 CD 80 7A     		call	PrintIt
  61+ 7A03 E1           	POP  HL
  62+ 7A04
  63+ 7A04              	;Get line length in BC.
  64+ 7A04 4E           	LD   C,(HL)
  65+ 7A05 23           	INC  HL
  66+ 7A06 46           	LD   B,(HL)
  67+ 7A07 23           	INC  HL
  68+ 7A08
  69+ 7A08              	;Save line end address.
  70+ 7A08 E5           	PUSH HL
  71+ 7A09 09           		ADD  HL,BC
  72+ 7A0A 22 8D 7A     		LD   (LineEndAddr),HL
  73+ 7A0D E1           	POP  HL
  74+ 7A0E
  75+ 7A0E              GetCharLoop:
  76+ 7A0E              	;Load a char
  77+ 7A0E 7E           	LD   A, (HL)
  78+ 7A0F FE 0D        	CP   CHR_CR
  79+ 7A11 20 04        	JR   NZ, IsNotCR		; A == CR
  80+ 7A13
  81+ 7A13              	;Print CR and process next line.
  82+ 7A13 23           	INC  HL
  83+ 7A14 D7           	RST  $10			;PRINT_A_1
  84+ 7A15 18 CA        	JR   NextLine
  85+ 7A17
  86+ 7A17              IsNotCR:
  87+ 7A17 FE 2E        	CP   '.'
  88+ 7A19 28 08        	JR   Z, SearchNum	; A == '.'
  89+ 7A1B
  90+ 7A1B FE 3A        	CP   ':'
  91+ 7A1D 30 13        	JR   NC, TestSPC1	; A >= ':'
  92+ 7A1F
  93+ 7A1F FE 30        	CP   '0'
  94+ 7A21 38 0F        	JR   C, TestSPC1	; A < '0'
  95+ 7A23
  96+ 7A23              SearchNum:
  97+ 7A23 44           	LD   B, H
  98+ 7A24 3E 0E        	LD   A, NumMarker
  99+ 7A26 ED B1        	CPIR
 100+ 7A28 CD B4 33     	CALL $33B4			;STACK_NUM
 101+ 7A2B E5           	PUSH HL
 102+ 7A2C CD E3 2D     		CALL $2DE3		;PRINT_FP
 103+ 7A2F E1           	POP  HL
 104+ 7A30 18 DC        	JR   GetCharLoop
 105+ 7A32
 106+ 7A32              TestSPC1:
 107+ 7A32 FE 20        	CP   ' '
 108+ 7A34 38 02        	JR   C, TestREM		; A < ' '
 109+ 7A36
 110+ 7A36              	;Print char >= ' '
 111+ 7A36 D7           	RST  $10			;PRINT_A_1
 112+ 7A37 7E           	LD   A,(HL)
 113+ 7A38
 114+ 7A38              TestREM:
 115+ 7A38 FE EA        	CP   $EA			;RND token
 116+ 7A3A 20 13        	JR   NZ, TestQuote1	; A != RND
 117+ 7A3C
 118+ 7A3C 23           	INC  HL
 119+ 7A3D              TestREMLoop:
 120+ 7A3D 7E           	LD   A, (HL)
 121+ 7A3E D7           	RST  $10			;PRINT_A_1
 122+ 7A3F 23           	INC  HL
 123+ 7A40 ED 5B 8D 7A  	LD   DE,(LineEndAddr)	;Ingore chars after REM.
 124+ 7A44 E5           	push hl
 125+ 7A45 B7           	  or  a
 126+ 7A46 ED 52        	  sbc hl, de
 127+ 7A48 7C           	  ld  a, h
 128+ 7A49 B5           	  or  l
 129+ 7A4A E1           	pop  hl
 130+ 7A4B 20 F0        	jr   nz, TestREMLoop
 131+ 7A4D 18 92        	JR   NextLine
 132+ 7A4F
 133+ 7A4F              TestQuote1:
 134+ 7A4F FE 22        	CP   '"'
 135+ 7A51 20 0C        	JR   NZ, SkipChar	; A != '"'
 136+ 7A53
 137+ 7A53              TestSPC2:
 138+ 7A53 23           	INC  HL
 139+ 7A54 7E           	LD   A,(HL)
 140+ 7A55 FE 20        	CP   ' '
 141+ 7A57 38 02        	JR   C, TestQuote2	; A < ' '
 142+ 7A59
 143+ 7A59              	;Print >= ' '.
 144+ 7A59 D7           	RST  $10			;PRINT_A_1
 145+ 7A5A 7E           	LD   A,(HL)
 146+ 7A5B
 147+ 7A5B              TestQuote2:
 148+ 7A5B FE 22        	CP   '"'
 149+ 7A5D 20 F4        	JR   NZ, TestSPC2	; A != '"'
 150+ 7A5F
 151+ 7A5F              SkipChar:
 152+ 7A5F 23           	INC  HL
 153+ 7A60 18 AC        	JR   GetCharLoop
 154+ 7A62
 155+ 7A62              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 156+ 7A62
 157+ 7A62              OutputFnct:
 158+ 7A62 FE A4        	cp	164
 159+ 7A64 38 1A        	jr	c, PrintIt	; A <= 164 ?
 160+ 7A66
 161+ 7A66 D6 A5        	sub		165
 162+ 7A68 11 95 00     	ld		de, TKN_TABLE
 163+ 7A6B CD 41 0C     	call	PO_SEARCH
 164+ 7A6E
 165+ 7A6E              NextTokenChar:
 166+ 7A6E 1A           	ld		a, (de)
 167+ 7A6F 13           	inc		de
 168+ 7A70 CB 7F        	bit		7, a
 169+ 7A72 20 05        	jr		nz, LastChar
 170+ 7A74 CD 80 7A     	call	PrintIt
 171+ 7A77 18 F5        	jr		NextTokenChar
 172+ 7A79
 173+ 7A79              LastChar:
 174+ 7A79 E6 7F        	and		%01111111
 175+ 7A7B CD 80 7A     	call	PrintIt
 176+ 7A7E 3E 20        	ld		a, ' '
 177+ 7A80
 178+ 7A80              PrintIt:
 179+ 7A80 D5           	push	de
 180+ 7A81 ED 5B 93 7A  		ld	de, (DestinationAddr)
 181+ 7A85 12           		ld	(de), a
 182+ 7A86 13           		inc	de
 183+ 7A87 ED 53 93 7A  		ld	(DestinationAddr), de
 184+ 7A8B D1           	pop		de
 185+ 7A8C C9           	ret
 186+ 7A8D
 187+ 7A8D 00 00        LineEndAddr		DEFW 0
 188+ 7A8F 00 00        ProgramStartAddr	DEFW 0
 189+ 7A91 00 00        ProgramEndAddr		DEFW 0
 190+ 7A93 00 00        DestinationAddr		DEFW 0
 191+ 7A95
 192+ 7A95              	ENDIF
# file closed: bas2txt.asm
1503  7A95
1504  7A95              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1505  7A95 48 43 43 6D  VerMsg1			DEFM	'HCCmd ', "2023-12-30"
1505  7A99 64 20 32 30
1505  7A9D 32 33 2D 31
1505  7AA1 32 2D 33 30
1506  7AA5 47 65 6F 72  VerMsg2			DEFM	'George Chirtoac', 'a' + $80
1506  7AA9 67 65 20 43
1506  7AAD 68 69 72 74
1506  7AB1 6F 61 63 E1
1507  7AB5 50 72 6F 67  MsgSysInf		DEFM	'Program Info   ', ' ' + $80
1507  7AB9 72 61 6D 20
1507  7ABD 49 6E 66 6F
1507  7AC1 20 20 20 A0
1508  7AC5 44 69 73 6B  MsgDskInf		DEFM	'Disk Info      ', ' ' + $80
1508  7AC9 20 49 6E 66
1508  7ACD 6F 20 20 20
1508  7AD1 20 20 20 A0
1509  7AD5 46 69 6C 65  MsgFileInf		DEFM	'File Info      ', ' ' + $80
1509  7AD9 20 49 6E 66
1509  7ADD 6F 20 20 20
1509  7AE1 20 20 20 A0
1510  7AE5 4D 65 73 73  MsgMessages		DEFM	'Messages       ', ' ' + $80
1510  7AE9 61 67 65 73
1510  7AED 20 20 20 20
1510  7AF1 20 20 20 A0
1511  7AF5 31 2D 41 3A  BtnBar			DEFM	'1-A:|2-B:|3-View|4-Prop|5-Copy|6-Ren|7-Attr|8-Del|9-Disk|0-Exi', 't' + $80
1511  7AF9 7C 32 2D 42
1511  7AFD 3A 7C 33 2D
1511  7B01 56 69 65 77
1511  7B05 7C 34 2D 50
1511  7B09 72 6F 70 7C
1511  7B0D 35 2D 43 6F
1511  7B11 70 79 7C 36
1511  7B15 2D 52 65 6E
1511  7B19 7C 37 2D 41
1511  7B1D 74 74 72 7C
1511  7B21 38 2D 44 65
1511  7B25 6C 7C 39 2D
1511  7B29 44 69 73 6B
1511  7B2D 7C 30 2D 45
1511  7B31 78 69 F4
1512  7B34 44 72 76 2F  MsgDrive		DEFM	'Drv/Free:  '
1512  7B38 46 72 65 65
1512  7B3C 3A 20 20
1513  7B3F 41 2F        MsgDriveLet		DEFM	'A', '/'
1514  7B41 30 30 30     MsgFreeSpaceNo	DEFM	'000'
1515  7B44 46 69 6C 65  MsgFilesCnt		DEFM	'Files/KB:'
1515  7B48 73 2F 4B 42
1515  7B4C 3A
1516  7B4D 30 30 30 2F  MsgFilesCntNo	DEFM	'000/000'
1516  7B51 30 30 30
1517  7B54 45 72 72 6F  MsgErr			DEFM	'Error code '
1517  7B58 72 20 63 6F
1517  7B5C 64 65 20
1518  7B5F 30 30 30 A0  MsgErrCode		DEFM	'000',' ' + $80
1519  7B63 4C 6F 61 64  MsgLoadingPrg	DEFM	'Loading Progra', 'm' + $80
1519  7B67 69 6E 67 20
1519  7B6B 50 72 6F 67
1519  7B6F 72 61 ED
1520  7B72 4C 6F 61 64  MsgLoadingSCR	DEFM	'Loading SCREEN', '$' + $80
1520  7B76 69 6E 67 20
1520  7B7A 53 43 52 45
1520  7B7E 45 4E A4
1521  7B81 4C 6F 61 64  MsgLoadingCODE	DEFM	'Loading CODE (!', ')' + $80
1521  7B85 69 6E 67 20
1521  7B89 43 4F 44 45
1521  7B8D 20 28 21 A9
1522  7B91 44 69 73 6B  MsgFileSzDsk	DEFM	'Disk Len:'
1522  7B95 20 4C 65 6E
1522  7B99 3A
1523  7B9A 30 30 30 30  MsgFileSzDskN	DEFM	'00000 ', 'K' + $80
1523  7B9E 30 20 CB
1524  7BA1 41 74 74 72  MsgFileAttr		DEFM	'Attrib  :'
1524  7BA5 69 62 20 20
1524  7BA9 3A
1525  7BAA 52 2F 4F 2C  MsgFileAttrN	DEFM	'R/O,HI', 'D' + $80
1525  7BAE 48 49 C4
1526  7BB1 54 79 70 65  MsgFileType		DEFM	'Type    :'
1526  7BB5 20 20 20 20
1526  7BB9 3A
1527  7BBA 20 20 20 20  MsgFileTypeN	DEFM	'         ', ' ' + $80
1527  7BBE 20 20 20 20
1527  7BC2 20 A0
1528  7BC4 50 72 6F 67  MsgFileTypePrg	DEFM	'Progra', 'm' + $80
1528  7BC8 72 61 ED
1529  7BCB 42 79 74 65  MsgFileTypeByte	DEFM	'Bytes ', ' ' + $80
1529  7BCF 73 20 A0
1530  7BD2 53 43 52 45  MsgFileTypeSCR	DEFM	'SCREEN', '$' + $80
1530  7BD6 45 4E A4
1531  7BD9 43 68 72 2E  MsgFileTypeChrA	DEFM	'Chr.Ar', 'r' + $80
1531  7BDD 41 72 F2
1532  7BE0 4E 6F 2E 20  MsgFileTypeNoA	DEFM	'No. Ar', 'r' + $80
1532  7BE4 41 72 F2
1533  7BE7 55 6E 74 79  MsgFileTypeText	DEFM	'Untype', 'd' + $80
1533  7BEB 70 65 E4
1534  7BEE 4E 2F 41 20  MsgNA			DEFM	'N/A   ', ' ' + $80
1534  7BF2 20 20 A0
1535  7BF5 4C 65 6E 67  MsgFileLen		DEFM	'Length  :'
1535  7BF9 74 68 20 20
1535  7BFD 3A
1536  7BFE 36 35 35 33  MsgFileLenN		DEFM	'65535 ', 'B' + $80
1536  7C02 35 20 C2
1537  7C05 53 74 61 72  MsgFileStart	DEFM	'Start   :'
1537  7C09 74 20 20 20
1537  7C0D 3A
1538  7C0E 36 35 35 33  MsgFileStartN	DEFM	'65535 ', ' ' + $80
1538  7C12 35 20 A0
1539  7C15 52 65 61 64  MsgReadingExt	DEFM	'Reading heade', 'r' | $80
1539  7C19 69 6E 67 20
1539  7C1D 68 65 61 64
1539  7C21 65 F2
1540  7C23 20 20 20 20  MsgClear		DEFM	'               ', ' ' | $80
1540  7C27 20 20 20 20
1540  7C2B 20 20 20 20
1540  7C2F 20 20 20 A0
1541  7C33 44 65 6C 20  MsgDelete		DEFM	'Del file? y/', 'n' | $80
1541  7C37 66 69 6C 65
1541  7C3B 3F 20 79 2F
1541  7C3F EE
1542  7C40 53 65 74 20  MsgSetRO		DEFM	'Set R/O? y/', 'n' | $80
1542  7C44 52 2F 4F 3F
1542  7C48 20 79 2F EE
1543  7C4C 53 65 74 20  MsgSetSYS		DEFM	'Set HID? y/', 'n' | $80
1543  7C50 48 49 44 3F
1543  7C54 20 79 2F EE
1544  7C58 4E 61 6D 65  MsgNewFileName	DEFM	'Name?none=abort', ':' | $80
1544  7C5C 3F 6E 6F 6E
1544  7C60 65 3D 61 62
1544  7C64 6F 72 74 BA
1545  7C68 44 69 73 6B  MsgMenuDiskCopy	DEFM	'Disk menu', ':' | $80
1545  7C6C 20 6D 65 6E
1545  7C70 75 BA
1546  7C72 46 69 6C 65  MsgMenuFileCopy	DEFM	'File copy menu', ':' | $80
1546  7C76 20 63 6F 70
1546  7C7A 79 20 6D 65
1546  7C7E 6E 75 BA
1547  7C81 30 2E 20 45  MsgMenuBack		DEFM	'0. Exit men', 'u' | $80
1547  7C85 78 69 74 20
1547  7C89 6D 65 6E F5
1548  7C8D
1549  7C8D 31 2E 20 43  MsgMenuSingle	DEFM	'1. Copy '
1549  7C91 6F 70 79 20
1550  7C95 41 3A 2D 3E  MsgMenuSingleDrv1	DEFM	'A:->'
1551  7C99 41 BA        MsgMenuSingleDrv2	DEFM	'A', ':' | $80
1552  7C9B
1553  7C9B 32 2E 20 43  MsgMenuDual		DEFM	'2. Copy '
1553  7C9F 6F 70 79 20
1554  7CA3 41 3A 2D 3E  MsgMenuDualDrv1	DEFM	'A:->'
1555  7CA7 42 BA        MsgMenuDualDrv2	DEFM	'B', ':' | $80
1556  7CA9
1557  7CA9 33 2E 20 43  MsgMenuToCOM	DEFM	'3. Copy '
1557  7CAD 6F 70 79 20
1558  7CB1 41 3A 2D 3E  MsgMenuToComDrv	DEFM	'A:->CO', 'M' | $80
1558  7CB5 43 4F CD
1559  7CB8
1560  7CB8 34 2E 20 43  MsgMenuFromCOM	DEFM	'4. Copy COM->'
1560  7CBC 6F 70 79 20
1560  7CC0 43 4F 4D 2D
1560  7CC4 3E
1561  7CC5 41 BA        MsgMenuFromCOMDrv	DEFM	'A', ':' | $80
1562  7CC7
1563  7CC7 35 2E 20 46  MsgMenuFmt1		DEFM	'5. Format A', ':' | $80
1563  7CCB 6F 72 6D 61
1563  7CCF 74 20 41 BA
1564  7CD3 36 2E 20 46  MsgMenuFmt2		DEFM	'6. Format B', ':' | $80
1564  7CD7 6F 72 6D 61
1564  7CDB 74 20 42 BA
1565  7CDF
1566  7CDF 30 30 30 20  MsgBlocksLeft	DEFM	'000 blocks lef', 't' | $80
1566  7CE3 62 6C 6F 63
1566  7CE7 6B 73 20 6C
1566  7CEB 65 66 F4
1567  7CEE 4F 76 65 72  MsgFileOverwrite	DEFM	'Overwrite? y/', 'n' | $80
1567  7CF2 77 72 69 74
1567  7CF6 65 3F 20 79
1567  7CFA 2F EE
1568  7CFC 46 69 6C 65  MsgFileExists	DEFM	'File name exist', 's' | $80
1568  7D00 20 6E 61 6D
1568  7D04 65 20 65 78
1568  7D08 69 73 74 F3
1569  7D0C 50 75 74 20  MsgInsertSrcDsk	DEFM	'Put SOURCE dis', 'k' | $80
1569  7D10 53 4F 55 52
1569  7D14 43 45 20 64
1569  7D18 69 73 EB
1570  7D1B 50 75 74 20  MsgInsertDstDsk	DEFM	'Put DEST. disk', ' ' | $80
1570  7D1F 44 45 53 54
1570  7D23 2E 20 64 69
1570  7D27 73 6B A0
1571  7D2A 50 72 65 73  MsgPressAnyKey	DEFM	'Press any ke', 'y' | $80
1571  7D2E 73 20 61 6E
1571  7D32 79 20 6B 65
1571  7D36 F9
1572  7D37 30 30 30 20  MsgCopySectors	DEFM	'000 sectors cop', 'y' | $80
1572  7D3B 73 65 63 74
1572  7D3F 6F 72 73 20
1572  7D43 63 6F 70 F9
1573  7D47 41 72 65 20  MsgAreYouSure	DEFM	'Are you sure?y/', 'n' | $80
1573  7D4B 79 6F 75 20
1573  7D4F 73 75 72 65
1573  7D53 3F 79 2F EE
1574  7D57 56 69 65 77  MsgViewFileMenu	DEFM	'View file menu', ':' | $80
1574  7D5B 20 66 69 6C
1574  7D5F 65 20 6D 65
1574  7D63 6E 75 BA
1575  7D66 31 2E 41 73  MsgViewFileText	DEFM	'1.As tex', 't' | $80
1575  7D6A 20 74 65 78
1575  7D6E F4
1576  7D6F 32 2E 41 73  MsgViewFileHex	DEFM	'2.As he', 'x' | $80
1576  7D73 20 68 65 F8
1577  7D77 33 2E 41 75  MsgViewFileAuto	DEFM	'3.Auto-1/2/BASI', 'C' | $80
1577  7D7B 74 6F 2D 31
1577  7D7F 2F 32 2F 42
1577  7D83 41 53 49 C3
1578  7D87
1579  7D87              	IFNDEF	_REAL_HW_
1580  7D87 ~            FontTable:
1581  7D87 ~            	incbin "cpmfnt.bin"
1582  7D87              	ENDIF
1583  7D87              EndCode:
1584  7D87
1585  7D87              ;Unalocated variables
1586  7D87              UnallocStart	EQU		EndCode
1587  7D87              FileCnt			EQU		UnallocStart			;File counter, 1B
1588  7D87              NameCol			EQU		FileCnt + 1				;Column for file name, 1B
1589  7D87              SelFile			EQU		NameCol + 1 			;Selected file using cursor, 1B
1590  7D87              CursorAddr		EQU		SelFile + 1				;2 B
1591  7D87              AUCntUsed		EQU		CursorAddr + 2			;2 B
1592  7D87              AUCntMaxFree	EQU		AUCntUsed + 2			;2 B
1593  7D87              SelFileCache	EQU		AUCntMaxFree + 2		;2 B
1594  7D87              CopySelOption	EQU		SelFileCache+2			;1 B
1595  7D87              ViewSelOption	EQU		CopySelOption + 1
1596  7D87              ViewSectMax	EQU		ViewSelOption + 1
1597  7D87              ViewFilePart	EQU		ViewSectMax+1
1598  7D87              FileBlocksIdxPos EQU		ViewFilePart+1
1599  7D87
1600  7D87              CopyFileFCB		EQU	FileBlocksIdxPos + 2
1601  7D87              CopyFileRes		EQU CopyFileFCB + 2
1602  7D87              CopyFileDMAAddr	EQU	CopyFileRes + 1
1603  7D87              FilePosRead		EQU	CopyFileDMAAddr + 2
1604  7D87              FilePosWrite	EQU	FilePosRead + 2
1605  7D87              CopyFileSectCnt EQU FilePosWrite + 2
1606  7D87              CopyFileSrcDrv	EQU CopyFileSectCnt + 1
1607  7D87              CopyFileSrcName	EQU CopyFileSrcDrv + 1
1608  7D87              CopyFileDstDrv	EQU CopyFileSrcName + 11
1609  7D87              CopyFileDstName	EQU CopyFileDstDrv + 1
1610  7D87
1611  7D87              FileCache		EQU		CopyFileDstName + 11				;cache table, size = 92 * 25 = 2300
1612  7D87              ;FS block list constants
1613  7D87              UsedBlockListCnt	EQU	FileCache + LST_MAX_FILES*CACHE_SZ
1614  7D87              UsedBlockListBlk	EQU	UsedBlockListCnt + 2
1615  7D87              UsedBlockListSz		EQU 320 * 2 + 2							;640
1616  7D87
1617  7D87              	IFDEF	_REAL_HW_
1618  7D87              FontTable		EQU		UsedBlockListCnt + UsedBlockListSz
1619  7D87              DataBuf			EQU		FontTable + 872
1620  7D87              	ELSE
1621  7D87 ~            DataBuf			EQU		UsedBlockListCnt + UsedBlockListSz
1622  7D87              	ENDIF
1623  7D87
1624  7D87              TrackBuf		EQU		DataBuf	;size = 16 * 256 = 4096
1625  7D87
1626  7D87
1627  7D87              ;File viewer constants
1628  7D87              FileData		EQU		DataBuf
1629  7D87              ;4K index allows for 2000 lines of text.
1630  7D87              FileIdxSize		EQU		4 * 1024
1631  7D87              FileIdxBlocksSize	EQU		1 * 1024
1632  7D87              ;File buffer size, without index
1633  7D87              FileDataSize	EQU		(MAX_SECT_RAM * SECT_SZ) - FileIdxSize - FileIdxBlocksSize
1634  7D87              ;Set a few KB aside for file indexing
1635  7D87              FileIdx			EQU		FileData + FileDataSize
1636  7D87              FileBlocksIdx		EQU		FileIdx + FileIdxSize
1637  7D87              MAX_SECT_BUF	EQU		FileDataSize/SECT_SZ
1638  7D87
1639  7D87
1640  7D87              ;Copy buffer size, follows
1641  7D87              CopyDiskBuf			EQU DataBuf
1642  7D87
1643  7D87              ;256 bytes for the stack should be enough.
1644  7D87              MAX_RAM_FREE	EQU		$FF00 - DataBuf
1645  7D87              MAX_AU_RAM		EQU		MAX_RAM_FREE/AU_SZ
1646  7D87              MAX_SECT_RAM	EQU		MAX_RAM_FREE/SECT_SZ
1647  7D87
1648  7D87              	DISPLAY "DataBuf addr: ", /D,DataBuf
1649  7D87              	DISPLAY "BinSize: ", /D, EndCode - Start
1650  7D87              	DISPLAY "VarSize: ", /D, DataBuf - UnallocStart
1651  7D87              	DISPLAY "MAX_RAM_FREE: ",/D,MAX_RAM_FREE
# file closed: hccmd.asm

Value    Label
------ - -----------------------------------------------------------
0x6B36   NoSub
0x6B2F   DivLoop
0x7328   MAX_RAM_FREE
0x0073   MAX_SECT_RAM
0x0400   FileIdxBlocksSize
0x1000   FileIdxSize
0x0282   UsedBlockListSz
0x7D87   UnallocStart
0x7D87   EndCode
0x7B41 X MsgFreeSpaceNo
0x7A79   LastChar
0x7A6E   NextTokenChar
0x7A5B   TestQuote2
0x7A53   TestSPC2
0x7A5F   SkipChar
0x7A3D   TestREMLoop
0x7A4F   TestQuote1
0x7A38   TestREM
0x7A32   TestSPC1
0x7A23   SearchNum
0x7A17   IsNotCR
0x7A0E   GetCharLoop
0x7A8D   LineEndAddr
0x7A80   PrintIt
0x79E1   NextLine
0x7A62   OutputFnct
0x7A91   ProgramEndAddr
0x7A8F   ProgramStartAddr
0x0095   TKN_TABLE
0x0C41   PO_SEARCH
0x000E   NumMarker
0x1601   CHAN_OPEN
0x0003   CHANNEL
0x0005   CH_LEN
0x5C4F   CHANS
0x79BD   STOPL
0x79A8   SHLOOP
0x79AC   SBIT
0x79B1   SBITDL
0x7998   SERTX
0x7985 X SERRX
0x797A   SERRBC
0x796D   SERRBX
0x7972   SERRBT
0x795A   SERRBL
0x7947 X SERWI
0x7955   SERRTF
0x7944   SERWIL
0x792F   SERRL
0x7952   SERRTO
0x7925   SERWS
0x791D   SERWSL
0x7916   SERRXI
0x000A   CBAUD
0x7899   PrintCharValid
0x7897   PrintCharNotValid
0x788C   PrintOneLineNotTab
0x7885   PrintOneLineLoop
0x7865   TextViewNoLF
0x785F   TextViewCheckLF
0x7854   TextViewNotFoundCR
0x784B   TextViewLineShort
0x782F   TextViewIndexLoop
0x78CE   FileEnd
0x77EF   TextViewerScrollDown1
0x77C4   TextViewerScrollUp1
0x77A7   TextViewerScrollUpOK
0x77D8   TextViewerScrollDown
0x78D6   MsgLine
0x776D   TextViewerShowFilename
0x78DB   MsgLineFileName
0x78FD   MsgFilePart
0x78EC   MsgLineNo
0x774E   TextViewerLoop3
0x78F2   MsgLineTotal
0x7876   PrintOneLine
0x7727   TextViewerLoop
0x78D2   FirstLineShown
0x7798   TextViewerScrollUp
0x78D4   LastLineShown
0x770B   TextViewerShowBegining
0x76EE   MoreThan23LinesInFile
0x78D0   LineCount
0x7901   MsgFilePartTotal
0x76CE   TextViewerBlockCountNoReminder
0x781A   TextViewIndex
0x7684   ScrollDownLoop
0x767B   ScrollDownLoop2
0x7682   ScrollDownPtrSrc
0x767F   ScrollDownPtrDest
0x766E   ScrollDown
0x7671   Scroll
0x7669   ScrollUp
0x7658   FillScrLinesRev
0x7643   FillScrLinesLoop
0x762F   ScrollInit
0x7625   GetCellDown
0x5B2E   SCRLinesUp
0x5B00   SCRLinesDown
0x5CB0   COORDS
0x0009   CHAR_TAB
0x000A X CHAR_LF
0x0017   LINE_CNT
0x7611   ClearNMsgLinesLoop
0x75FF   ReadStrPrint
0x75EF   ReadStrChar
0x75D2   ReadStringLoop
0x75C6   Store
0x75C5   NoTurn
0x75BA   PrintCharLine
0x75A6 X PrintChar3
0x7551   DrawCursorLoop
0x7538   DrawVLinesLoop
0x7509   DrawLowerIntersectLoop
0x751A   DrawIntersect
0x74F4   DrawUpperIntersectLoop
0x74C8   DrawLineLoop
0x74D5   LineDir
0x74C5   StoreDir
0x74C3   VertDir
0x74BA   DrawLine
0x74B6   StrClr
0x7469   GoodChar
0x7621   CurrScrAddr
0x8870   FontTable
0x008C   CHR_HALF
0x008B X CHR_FULL
0x008A X CHR_UL
0x0089 X CHR_LR
0x0088 X CHR_C
0x0087   CHR_H
0x0086 X CHR_ML
0x0085   CHR_UC
0x0084   CHR_DC
0x0083 X CHR_DL
0x0082 X CHR_UR
0x0081 X CHR_MR
0x007F X CHR_GRID
0x0009 X CHR_TAB
0x000A   CHR_LF
0x000D   CHR_CR
0x000E X KEY_CTRL
0x000C   KEY_BACKSP
0x0007 X KEY_ESC
0x0016   LST_LAST_LINE
0x0018 X SCR_LINES
0x0040 X SCR_COLS
0x0300   SCR_ATTR_LEN
0x1800   SCR_PIX_LEN
0x4000   SCR_ADDR
0x5800   SCR_ATTR_ADDR
0x0007 X INK_WHITE
0x0006 X INK_YELLOW
0x0005   INK_CYAN
0x0004 X INK_GREEN
0x0003 X INK_MAGENTA
0x0002 X INK_RED
0x0001 X INK_BLUE
0x0000   INK_BLACK
0x0038 X PAPER_WHITE
0x0030 X PAPER_YELLOW
0x0028   PAPER_CYAN
0x0020   PAPER_GREEN
0x0018 X PAPER_MAGENTA
0x0010 X PAPER_RED
0x0008 X PAPER_BLUE
0x0000   PAPER_BLACK
0x0040   CLR_BRIGHT
0x0007   CLR_WHITE
0x0006   CLR_YELLOW
0x0005   CLR_CYAN
0x0004   CLR_GREEN
0x0003   CLR_MAGENTA
0x0002   CLR_RED
0x0001   CLR_BLUE
0x0000   CLR_BLACK
0x00FE   PORT_ZX
0x25AB   CPM_FNT
0x73E9   ReadWriteFileSectionLoop
0x7407   ReadWriteFileSectionEnd
0x7D9B   CopyFileDMAAddr
0x7D98   CopyFileFCB
0x73AE   ReadWriteFileSection
0x7419   CopyFilePtr2
0x73D4   CopyFilePtr
0x73FC   CopyFileOperAddr2
0x73DD   CopyFileOperAddr1
0x7360   CopyFileFromCOMDontInc
0x5F00   FileDataSize
0x734D   CopyFileFromCOMLoop
0x72EC   CopyFileToCOMEnd
0x72CC   CopyFileToCOMLoop
0x7284   CopyFileDualDriveLoop
0x7395   WriteFileSection
0x7D37   MsgCopySectors
0x721B   CopyFileSameDriveLoop
0x7DA1   CopyFileSectCnt
0x71D7   CopyFileCreateNewFile
0x7CEE   MsgFileOverwrite
0x71BB   CopyFileCheckOverwrite
0x72F1   CopyFileFromCOM
0x72BE   CopyFileToCOM
0x7274   CopyFileDualDrive
0x71F5   CopyFileSameDrive
0x71A4   CopyFileNotExit
0x7C72   MsgMenuFileCopy
0x7D9F   FilePosWrite
0x7DAF   CopyFileDstName
0x7D0C   MsgInsertSrcDsk
0x7D2A   MsgPressAnyKey
0x7D1B   MsgInsertDstDsk
0x70A7 X FileAttribSet
0xEAD8   FileIdx
0x7055   GetFileSizeMul
0x705B   GetFileSizeEnd
0x7053   GetFileSizeOK
0x7033   BDOSSetRandFilePtr
0x702F   BDOSSetDMA
0x7021   BDOSWriteFileBlockRandom
0x701D   BDOSReadFileBlockRandom
0x7019   BDOSWriteFileBlockSeq
0x7015   BDOSReadFileBlockSeq
0x7011   BDOSCloseFile
0x700D   BDOSOpenFile
0x7009   BDOSCreateFile
0x6FFF   DestroyChannel
0x6FE9   CreateChannel
0x6FE9 X BDOSCloseDrives
0x6FE5 X BDOSGetDiskRO
0x6FE5 X BDOSMakeDiskRO
0x7025   BDOS
0x6FD7 X PrmIntrlvTbl
0x6FD6 X PrmSpinUp
0x6FD5 X PrmHeadLoad
0x6FD3 X PrmDevType
0x0004   PrmFastFactor
0x6FCE X RWTSResTmp
0x6FCD X RWTSResVolNo
0x6FD3   BasPrmTbl
0x6FC9 X RWTSPrmTbl
0x6FC7 X RWTSExtBuf
0x6FC4 X RWTSSector
0x6FC2 X RWTSVolNo
0x6FC0 X RWTSBlockType
0x6FB7   CopyMsg
0x6FAB   SearchMsgEnd
0x6FB4   SaveMsg
0x6FA2   IF1Paged
0x6F70   IF1Call
0x6F6B   IsFileHeaderValidLoop
0x7037   GetFileSize
0x6F4F   ReadFileHeaderIsTextFile
0x6F68   IsFileHeaderValid
0x6F64   ReadHeaderEnd
0x6F09   CacheNotFinished
0x6EFE X SeekTrack
0x6EB3   FileReadLoop
0x6EA7 X FileLoadHeader
0x6EB9   FileLoadNoHeader
0x6EC7   FileFree
0x6E83   MisMatch
0x6E7B   Compare
0x6E79   StrCmp
0x6E30   CopyDiskFromCOMLoop
0x7958   SERRB
0x6DCC   CopyDiskToCOMLoop
0x798B   SERTB
0x70ED   PromptDiskChangeSrc
0x6DA4   CopyDiskDualDrive2
0x6DB1   CopyDiskEnd
0x6D80 X CopyDiskWriteEnd
0x6D69   CopyDiskLoopWriteLoop
0x6D62   CopyDiskReadEnd
0x70D3   PromptDiskChangeDst
0x6D58   CopyDiskDualDrive1
0x6D2F   CopyDiskLoopReadLoop
0x8BD8   CopyDiskBuf
0x6D28   CopyDiskLoopRead
0x000E   MAX_AU_RAM
0x7CDF   MsgBlocksLeft
0x6D05   CopyDiskLoop
0x85F0   UsedBlockListBlk
0x6EDF   WriteDiskSectors
0x6CF1   WriteFSBlock
0x6ECC   ReadDiskSectors
0x6CE4   ReadFSBlock
0x6CD6   ReadUsedBlocksSkip
0x6CB9   ReadUsedBlocksLoop2
0x6CD9   ReadUsedBlocksSkip2
0x6CA9   ReadUsedBlocksLoop
0x85EE   UsedBlockListCnt
0x6C8B   ReadUsedBlocksList
0x6C84   CheckAUEnd
0x6C70   CheckAU
0x6C59   FirstAU
0x6C53   Track0
0x6C3E   AU2TS
0x6C22   WriteOneDiskSector
0x6FC3   RWTSTrack
0x6FC5   RWTSDMA
0x6FC0   RWTSParams
0x6FCB   RWTSCmd
0x6C0B   RWTS
0x0A41   LOAD_ADDR
0x0026 X CH_DMA
0x0032   CH_DATA
0x000C   CH_FCB
0x000B X CH_RW_FLAG
0x0009   SYS_POS
0x0004   RWTS_CMD_FMT
0x0002   RWTS_CMD_WRITE
0x0001   RWTS_CMD_READ
0x0000 X RWTS_CMD_SEEK
0x5C39 X PIP
0x5C0A X REPPER
0x5C09   REPDEL
0x5C65 X STKEND
0x5C4B X VARS
0x5C53 X PROG
0x0260   ERRMSG
0x5CEF   COPIES
0x5CDA   NSTR1
0x5CDC   FSTR1
0x5CD6   DSTR1
0x0024 X FCB_SIZE
0x0023 X FCB_R2
0x0022   FCB_R1
0x0021   FCB_R0
0x0020 X FCB_CR
0x0010 X FCB_AU
0x000F X FCB_RC
0x000E X FCB_S2
0x000D X FCB_S1
0x000C X FCB_EX_IDX
0x0001 X FCB_NAME
0x0000 X FCB_DRIVE
0x0020 X EXT_SIZE
0x001E X EXT_AU7
0x001C X EXT_AU6
0x001A X EXT_AU5
0x0018 X EXT_AU4
0x0016 X EXT_AU3
0x0014 X EXT_AU2
0x0012 X EXT_AU1
0x0010   EXT_AU0
0x000F   EXT_RC
0x000E   EXT_S2
0x000D   EXT_S1
0x0001   EXT_NAME
0x0080 X REC_SZ
0x0008   SPAL
0x0008   EXT_AU_CNT
0x0001   DIR_TRK_CNT
0x0800   AU_SZ
0x0002   HEAD_CNT
0x0002 X DRIVE_B_BAS
0x0001 X DRIVE_A_BAS
0x0000 X DRIVE_CUR_BAS
0x6BE6   Bin2HexLineLoopHex2
0x6BD2   Bin2HexLineClear
0x0040   COL_CNT
0x6BBE   Bin2HexStrLoop
0x6B9E   Bin2HexLineLoopText
0x6B9B X Bin2HexLineText
0x0080   CHR_V
0x6B89   Bin2HexLineLoopHex
0x6B86   Bin2HexLine
0x0010   HEX_COLUMNS
0x6B80 X Bin2HexLineLoopTextReplace
0x6B83   Bin2HexLineLoopTextCopy
0x000D   CHAR_CR
0x6B7B   Byte2HexChar
0x6B72   Byte2HexHex
0x6B66   Byte2HexNibble
0x6B60   Byte2Hex
0x6B5D   NoAdd
0x6B57   MulLoop
0x6B3E   Div2Loop
0x6B39   Div2
0x6B2C   Div
0x6B23   DivNrLoop
0x6B21   DigitLoop
0x6B12   Byte2Txt_
0x6AFB   StrippLeading0
0x6B06   Word2Txt_
0x6AE5 X IsDrive2_80Tracks
0x4000 X HC_VID_BANK0
0x000B X HC_CFG_CPM
0x0000 X HC_CFG_BASIC
0x0004 X HC_CFG_PORT_EN
0x0000 X HC_CFG_PORT_DIS
0x0002   HC_CFG_ROM_E000
0x0000   HC_CFG_ROM_0000
0x0001   HC_CFG_ROM_CPM
0x0000   HC_CFG_ROM_BAS
0x0007 X HC_FLOPPY_PORT
0x6AE2   DontInc
0x6ADC   ReadAllHeadersEnd
0x6AC7   AKey
0x7429   KbdHit
0x6AAC   NextFile
0x7BF5   MsgFileLen
0x7BB1   MsgFileType
0x7C05   MsgFileStart
0x6A6B   PrintStartStr
0x7C0E   MsgFileStartN
0x7BEE   MsgNA
0x6A5D   PrintStart
0x0007   HDR_LINE
0x6A38   PrintByteStart
0x6A30   PrintProgStart
0x7BFE   MsgFileLenN
0x6A16 X PrepFileLenText
0x7BE7   MsgFileTypeText
0x7BCB   MsgFileTypeByte
0x7BD2   MsgFileTypeSCR
0x69FC   NotScr
0x6A07   CheckText
0x7BD9   MsgFileTypeChrA
0x69DF   CheckByte
0x0002   CHAR_TYPE
0x7BE0   MsgFileTypeNoA
0x69D0   CheckChrArr
0x0001   NUMB_TYPE
0x6A10   PrepFileLen
0x6FD4 X PrmStepRate
0x6A89   MoveMsg
0x7BBA   MsgFileTypeN
0x7BC4   MsgFileTypePrg
0x69C1   CheckNoArr
0x000B   CACHE_FIRST_AU
0x6A40   HeadNotRead
0x7BA1   MsgFileAttr
0x6992   AttrEnd
0x6988   NotSYS
0x6976   CheckSys
0x6968   NotRO
0x0008   RO_POS
0x0000   CACHE_NAME
0x6A52   PrintStartNotRead
0x7B91   MsgFileSzDsk
0x7B9A   MsgFileSzDskN
0x7DA3   CopyFileSrcName
0x691F   ReadFileForViewingNotFoundEOF
0x5CED   HD11
0x001A   CHAR_EOF
0x6925   ReadFileForViewingNotText
0x0004   TEXT_TYPE
0x7374   ReadFileSection
0x7D94   ViewSectMax
0x68CF   ViewFileTextLoopDown
0x5C08   LAST_K
0x68A3   ViewFileTextLoop
0x76A9   TextViewer
0x7A93   DestinationAddr
0x79C1   BASIC2TXT
0x0005   HDR_PLEN
0x6BA4   Bin2HexStr
0x6897   ViewFileText
0x68EF   ReadFileForViewing
0x005F   MAX_SECT_BUF
0x6873   ViewFileAsBASIC
0x6846 X ViewFileAuto
0x685D   ViewFileAsHex
0x6855   ViewFileAsText
0x683B   ViewFileNextBlock
0x7D96   FileBlocksIdxPos
0xFAD8   FileBlocksIdx
0x7D95   ViewFilePart
0x7D93   ViewSelOption
0x7D9D   FilePosRead
0x7BAA   MsgFileAttrN
0x0003 X ViewFileConvertRatioASM
0x0005   ViewFileConvertRatioHEX
0x0004   ViewFileConvertRatioBASIC
0x0001   ViewFileConvertRatioText
0x6F76   LoadProgram
0x7DA2   CopyFileSrcDrv
0x7B63   MsgLoadingPrg
0x0000   HC_CFG_VID_4000
0x007E   HC_CFG_PORT
0x0008   HC_CFG_VID_C000
0xC000   HC_VID_BANK1
0x7B72   MsgLoadingSCR
0x0003   HDR_ADDR
0x6ECC   IF1FileLoadEnd
0x5B00   PRN_BUF
0x6E86   IF1FileLoad
0x7B81   MsgLoadingCODE
0x67BD X HandleFileCODE
0x67E3   HandleFileSCR
0x1B00   SCR_LEN
0x0001   HDR_LEN
0x6811   HandleFileText
0x0003   BYTE_TYPE
0x6801   HandleFileProg
0x0000   PROG_TYPE
0x0000   HDR_TYPE
0x0010   CACHE_HDR
0x000F   CACHE_FLAG
0x0020   EXT_SZ
0x000D   CACHE_AU_CNT
0x6787   FindExtEnd
0x6EFE   FindCache
0x6796   GetFileNamesEnd
0x0009   HDR_SZ
0x6762   FindExt
0x000C   EXT_IDX
0x6C5C   CheckExtAlloc
0x6789   NextExt
0x0000   EXT_DEL_FLAG
0x6715   StoreFilenamesLoop
0x0080   MAX_EXT_CNT
0x66F2   DisplayFilenamesLoop
0x66D8   LineOK
0x5CB1   LINE
0x5CB0   COL
0x758E   PrintChar
0x5C81   CODE
0x66B2   DispLoop
0x66B0   DisplayFilename
0x7556   MoveCursor
0x6C2D   FormatDisk
0x7D47   MsgAreYouSure
0x6658   FormatDiskAction
0x664B   CheckDiskMenuFormat2
0x6E13   CopyDiskFromCOM
0x663C   CheckDiskMenuFormat1
0x6DB7   CopyDiskToCOM
0x6632   CheckDiskMenuFromCOM
0x6629   CheckDiskMenuToCOM
0x6CFE   CopyDisk
0x661B   CheckDiskMenuDualDrive
0x669F   DiskMenuExit
0x6607 X CheckKeyDiskMenuLoop
0x7CD3   MsgMenuFmt2
0x7CC7   MsgMenuFmt1
0x7CB8   MsgMenuFromCOM
0x7CA9   MsgMenuToCOM
0x7C9B   MsgMenuDual
0x7C8D   MsgMenuSingle
0x7C81   MsgMenuBack
0x7C68   MsgMenuDiskCopy
0x7CA7   MsgMenuDualDrv2
0x7CC5   MsgMenuFromCOMDrv
0x7CB1   MsgMenuToComDrv
0x7CA3   MsgMenuDualDrv1
0x7C99   MsgMenuSingleDrv2
0x7C95   MsgMenuSingleDrv1
0x66A2   CheckKeyExit
0x7086   ChangeFileAttrib
0x657A   AttrChange
0x7C4C   MsgSetSYS
0x6562   CheckSYS
0x7C40   MsgSetRO
0x658C   CheckKeyDiskMenu
0x7061   DeleteFile
0x6534   DoFileDelete
0x7C33   MsgDelete
0x6541   CheckKeyAttrib
0x70B0   RenameFile
0x7CFC   MsgFileExists
0x64FB   RenameFileNotExist
0x706D   DoesFileExist
0x6507   RenameCanceled
0x75CC   ReadString
0x000B   NAMELEN
0x7C23   MsgClear
0x7C58   MsgNewFileName
0x650F   CheckKeyDel
0x6812   ViewFile
0x7D77   MsgViewFileAuto
0x7D6F   MsgViewFileHex
0x7D66   MsgViewFileText
0x7D57   MsgViewFileMenu
0x649F   CheckKeyRename
0x0001   DRIVE_B_CPM
0x6465   CheckKeyView
0x6583   SelectDrive
0x645C   CheckKeyDriveB
0x6A8F   ReadAllHeaders
0x6453   CheckKeyDriveA
0x7DAE   CopyFileDstDrv
0x7D92   CopySelOption
0x6428   CopyFileOK
0x7D9A   CopyFileRes
0x7107   CopyFile
0x6442   CheckKeyFileInfo
0x760E   ClearNMsgLines
0x6F0F   ReadFileHeader
0x7C15   MsgReadingExt
0x63F6   CheckKeyCopy
0x6797   HandleFile
0x63D1   CheckKeyInfo
0x63CB   DoKeyEnter
0x000D   KEY_ENTER
0x63C2   CheckEnter
0x63B5   DoKeyLeft
0x0008   KEY_LEFT
0x0015   LST_LINES_CNT
0x63AD   CheckLeft
0x639B   DoKeyRight
0x0009   KEY_RIGHT
0x6393   CheckRight
0x6386   DoKeyUp
0x000B   KEY_UP
0x66AA   MoveIt
0x637E   CheckUp
0x636D   DoKeyDown
0x000A   KEY_DOWN
0x6929   DisplayFileInfo
0x7D90   SelFileCache
0x6B4C   Mul
0x634B   CalcFileCache
0x7B44   MsgFilesCnt
0x7D87   FileCnt
0x7B4D   MsgFilesCntNo
0x7B34   MsgDrive
0x6AE5   Word2Txt
0x7B3F   MsgDriveLet
0x7D8C   AUCntUsed
0x6F8F   SetFastKeys
0x754B   DrawCursor
0x0060   SCR_SEL_CLR
0x7AE5   MsgMessages
0x0007   LST_FILE_INFO
0x7AD5   MsgFileInf
0x0004   LST_DISK_INFO
0x7AC5   MsgDskInf
0x7AB5   MsgSysInf
0x7AF5   BtnBar
0x0060   SCR_LBL_CLR
0x7AA5   VerMsg2
0x7462   PrintStr
0x0001   LST_PROG_INFO
0x7A95   VerMsg1
0x74D9   DrawHLines
0x7533   DrawVLines
0x7D8A   CursorAddr
0x7623   CurrScrAttrAddr
0x0020   SCR_BYTES_PER_LINE
0x7442   ClrScr
0x5CB0   LineCol
0x0001   LST_FIRST_LINE
0x7D88   NameCol
0x0010   LST_FIRST_COL
0x7D89   SelFile
0x7426   ReadChar
0x8BD8   DataBuf
0x6F9A   GetErrMsg
0x5C3A   ERRNR
0x622E   HCRunEnd
0x635C   ReadKeyLoop
0x62E9   DisplayDiskInfo
0x66E2   DisplayFilenames
0x626B   InitUI
0x6222   HCRunMain
0x6702   GetFileNames
0x748A   PrintStrClr
0x0080   CLR_FLASH
0x0045   SCR_DEF_CLR
0x000D   LST_LINE_MSG
0x7B54   MsgErr
0x6AF0   Byte2Txt
0x7B5F   MsgErrCode
0x621F   HCRunCacheFiles
0x6EF2   ReadCatalogTrack
0x7D8E   AUCntMaxFree
0x61FC   DriveIs80Tracks
0x78B8   PrintOneLineCleanLine
0x013E   MAX_FREE_AU_CNT
0x6FCC   RWTSRes
0x6C17   ReadOneDiskSector
0x8BD8   FileData
0x0050   TRACK_CNT
0x6FDC   BDOSSelectDisk
0x6FC1   RWTSDrive
0x6FD9   BDOSInit
0x0000   DRIVE_A_CPM
0x61DD   DetectTrackCount
0x6FE5   BDOSGetCurrentDrive
0x0019   CACHE_SZ
0x0054   LST_MAX_FILES
0x7DBA   FileCache
0x00E5   DEL_MARKER
0x0100   SECT_SZ
0x0010   SPT
0x8BD8   TrackBuf
0x61BA   HCRunInitDisk
0x6236   ErrorHandler
0x5C3D   ERRSP
0x6C08   IF1Init
0x742C   InitFonts
0x61A8   Start
